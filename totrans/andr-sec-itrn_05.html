<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Cryptographic Providers"><div class="titlepage"><div><div><h1 class="title"><a id="cryptographic_providers"/>Chapter 5. Cryptographic Providers</h1></div></div></div><p><a id="iddle1463" class="indexterm"/><a id="iddle1502" class="indexterm"/>This chapter introduces Android’s cryptographic provider architecture and discusses the built-in providers and the algorithms they support. Because Android builds on the <span class="emphasis"><em>Java Cryptography Architecture (JCA)</em></span>, we introduce its design in brief, starting with the <span class="emphasis"><em>cryptographic service provider (CSP)</em></span> framework. We then discuss the main JCA classes and interfaces, and the cryptographic primitives they implement. (We will briefly introduce each cryptographic primitive, but a thorough discussion is beyond the scope of this book and some familiarity with basic cryptography is assumed.) Next, we present Android’s JCA providers and cryptographic libraries as well as the algorithms each provider supports. Finally, we show how to use additional cryptography algorithms by installing a custom JCA provider.</p><div class="sect1" title="JCA Provider Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="jca_provider_architecture"/>JCA Provider Architecture</h1></div></div></div><p><a id="iddle1220" class="indexterm"/><a id="iddle1473" class="indexterm"/><a id="iddle1532" class="indexterm"/><a id="iddle2008" class="indexterm"/>JCA provides an extensible cryptographic provider framework and a set of APIs covering the major cryptographic primitives in use today (block ciphers, message digests, digital signatures, and so on). This architecture aims to be implementation-independent and extensible. Applications that use the standard JCA APIs only need to specify the cryptographic algorithm they want to use and (in most cases) do not depend on a particular provider implementation. Support for new cryptographic algorithms can be added by simply registering an additional provider that implements the required algorithms. Additionally, cryptographic services offered by different providers are generally interoperable (with certain restrictions when keys are hardware-protected or key material is otherwise not directly available) and applications are free to mix and match services from different providers as needed. Let’s look at JCA’s architecture in more detail.</p><div class="sect2" title="Cryptographic Service Providers"><div class="titlepage"><div><div><h2 class="title"><a id="cryptographic_service_providers"/>Cryptographic Service Providers</h2></div></div></div><p>JCA splits cryptographic functionality into a number of abstract cryptographic services called <span class="emphasis"><em>engines</em></span> and defines APIs for each service in the form of an <span class="emphasis"><em>engine class</em></span>. For example, digital signatures are represented by the <code class="literal">Signature</code> engine class, and encryption is modeled with the <code class="literal">Cipher</code> class. (You’ll find a comprehensive list of engine classes in the next section.)</p><p>In the context of JCA, a <span class="emphasis"><em>cryptographic service provider</em></span> (<span class="emphasis"><em>CSP</em></span>, or simply <span class="emphasis"><em>provider</em></span>) is a package (or set of packages) that provides a concrete implementation of certain cryptographic services. Each provider advertises the services and algorithms it implements, allowing the JCA framework to maintain a registry of supported algorithms and their implementing providers. This registry maintains a preference order for providers, so if a certain algorithm is offered by more than one provider, the one with higher preference order is returned to the requesting application. An exception to this rule is made for engine classes that support <span class="emphasis"><em>delayed provider selection</em></span> (<code class="literal">Cipher</code>, <code class="literal">KeyAgreement</code>, <code class="literal">Mac</code>, and <code class="literal">Signature</code>). With delayed provider selection, the provider is selected not when an instance of the engine class is created, but when the engine class is initialized for a particular cryptographic operation. Initialization requires a <code class="literal">Key</code> instance, which the system uses to find a provider that can accept the specified <code class="literal">Key</code> object. Delayed provider selection is helpful when using keys that are stored in hardware because the system cannot find the hardware-backed provider based on the algorithm name alone. However, concrete <code class="literal">Key</code> instances passed to initialization methods usually have enough information to determine the underlying provider.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note01"/>Note</h3><p><span class="emphasis"><em>Current Android versions don’t support delayed provider selection, but some related work is being done in the master branch, and delayed provider selection will likely be supported in a future version.</em></span></p></div><p>Let’s look at an example using the provider configuration illustrated in <a class="xref" href="ch05.html#jca_algorithm_implementation_selection_w" title="Figure 5-1. JCA algorithm implementation selection when provider is not specified">Figure 5-1</a>.</p><div class="figure"><a id="jca_algorithm_implementation_selection_w"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00013"/><img src="figs/web/05fig01.png.jpg" alt="JCA algorithm implementation selection when provider is not specified"/></div></div><p class="title">Figure 5-1. JCA algorithm implementation selection when provider is not specified</p></div><p><a id="iddle1221" class="indexterm"/><a id="iddle1474" class="indexterm"/><a id="iddle2009" class="indexterm"/><a id="iddle2762" class="indexterm"/><a id="iddle2804" class="indexterm"/><a id="iddle2853" class="indexterm"/>If an application requests an implementation of the SHA-256 digest algorithm without specifying a provider (as shown in <a class="xref" href="ch05.html#requesting_a_sha-256_implementation_with" title="Example 5-1. Requesting a SHA-256 implementation without specifying a provider">Example 5-1</a>), the provider framework returns the implementation found in <span class="emphasis"><em>ProviderB</em></span> (number 2 in the list in <a class="xref" href="ch05.html#jca_algorithm_implementation_selection_w" title="Figure 5-1. JCA algorithm implementation selection when provider is not specified">Figure 5-1</a>), not the one in <span class="emphasis"><em>ProviderC</em></span>, which also supports SHA-256, but which is number 3 in the list in <a class="xref" href="ch05.html#jca_algorithm_implementation_selection_w" title="Figure 5-1. JCA algorithm implementation selection when provider is not specified">Figure 5-1</a>.</p><div class="example"><a id="requesting_a_sha-256_implementation_with"/><p class="title">Example 5-1. Requesting a SHA-256 implementation without specifying a provider</p><div class="example-contents"><pre class="programlisting">MessageDigest md = MessageDigest.getInstance("SHA-256");</pre></div></div><p>On the other hand, if the application specifically requests <span class="emphasis"><em>ProviderC</em></span> (as shown in <a class="xref" href="ch05.html#requesting_a_sha-256_implementation_from" title="Example 5-2. Requesting a SHA-256 implementation from a specific provider">Example 5-2</a>), its implementation will be returned even though <span class="emphasis"><em>ProviderB</em></span> has a higher preference order.</p><div class="example"><a id="requesting_a_sha-256_implementation_from"/><p class="title">Example 5-2. Requesting a SHA-256 implementation from a specific provider</p><div class="example-contents"><pre class="programlisting">MessageDigest md = MessageDigest.getInstance("SHA-256", "ProviderC");</pre></div></div><p>Generally, applications should not explicitly request a provider unless they include the requested provider as part of the application or can handle fallback if the preferred provider is not available.</p><div class="sect3" title="Provider Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="provider_implementation"/>Provider Implementation</h3></div></div></div><p>The JCA framework guarantees implementation independence by requiring all implementations of a particular cryptographic service or algorithm to conform to a common interface. For each engine class that represents a particular cryptographic service, the framework defines a corresponding abstract <span class="emphasis"><em>Service Provider Interface (SPI)</em></span> class. Providers that offer a particular cryptographic service implement and advertise the corresponding SPI class. For example, a provider that implements a given encryption algorithm would have an implementation of the <code class="literal">CipherSpi</code> class that corresponds to the <code class="literal">Cipher</code> engine class. When an application calls the <code class="literal">Cipher.getInstance()</code> factory method, the JCA framework finds the appropriate provider by using the process outlined in “<a class="xref" href="ch05.html#cryptographic_service_providers" title="Cryptographic Service Providers">Cryptographic Service Providers</a>” and returns a <code class="literal">Cipher</code> instance that routes all of its method calls to the <code class="literal">CipherSpi</code> subclass implemented in the selected provider.</p><p><a id="iddle1106" class="indexterm"/><a id="iddle1219" class="indexterm"/><a id="iddle1222" class="indexterm"/><a id="iddle1472" class="indexterm"/><a id="iddle1475" class="indexterm"/><a id="iddle1956" class="indexterm"/><a id="iddle2007" class="indexterm"/><a id="iddle2010" class="indexterm"/><a id="iddle2530" class="indexterm"/><a id="iddle2596" class="indexterm"/><a id="iddle2718" class="indexterm"/>In addition to SPI implementation classes, each provider has a subclass of the abstract <code class="literal">java.security.Provider</code> class that defines the name and version of the provider and, more importantly, a list of the supported algorithms and matching SPI implementation classes. The JCA provider framework uses this <code class="literal">Provider</code> class to build the provider registry, and queries it when searching for algorithm implementations to return to its clients.</p></div><div class="sect3" title="Static Provider Registration"><div class="titlepage"><div><div><h3 class="title"><a id="static_provider_registration"/>Static Provider Registration</h3></div></div></div><p>In order for a provider to be visible to the JCA framework, it must be registered first. There are two ways to register a provider: statically and dynamically. Static registration requires editing the system security properties file and adding an entry for the provider. (On Android, this properties file is called <span class="emphasis"><em>security.properties</em></span> and is only present inside the <span class="emphasis"><em>core.jar</em></span> system library. Therefore, it cannot be edited and static provider registration is not supported. We describe it here only for completeness.)</p><p>A provider entry in the security properties file is formatted as shown in <a class="xref" href="ch05.html#static_registration_of_a_jca_provider" title="Example 5-3. Static registration of a JCA provider">Example 5-3</a>.</p><div class="example"><a id="static_registration_of_a_jca_provider"/><p class="title">Example 5-3. Static registration of a JCA provider</p><div class="example-contents"><pre class="programlisting">security.provider.n=ProviderClassName</pre></div></div><p>Here, <span class="emphasis"><em>n</em></span> is the provider’s preference order that is used when searching for requested algorithms (when no provider name is specified). The order is 1-based; that is, 1 is the most preferred, followed by 2, and so on. <code class="literal">ProviderClassName</code> is the name of the <code class="literal">java.security.Provider</code> class implementation described in “<a class="xref" href="ch05.html#provider_implementation" title="Provider Implementation">Provider Implementation</a>”.</p></div><div class="sect3" title="Dynamic Provider Registration"><div class="titlepage"><div><div><h3 class="title"><a id="dynamic_provider_registration"/>Dynamic Provider Registration</h3></div></div></div><p>Providers are registered dynamically (at runtime) with the <code class="literal">addProvider()</code> and <code class="literal">insertProviderAt()</code> methods of the <code class="literal">java.security.Security</code> class. These methods return the actual position in which the provider was added, or –1 if the provider was not added because it was already installed. Providers can also be removed dynamically by calling the <code class="literal">removeProvider()</code> method.</p><p>The <code class="literal">Security</code> class manages the list of security <code class="literal">Provider</code>s and effectively acts as the provider registry described in the previous sections. In Java SE, programs require special permissions in order to register providers and modify the provider registry because by inserting a new provider at the top of the provider list, they can effectively replace the system security implementation. In Android, modifications to the provider registry are limited to the current app process and cannot affect the system or other applications. Therefore, no special permissions are required in order to register a JCA provider.</p><p>Dynamic modifications to the provider registry are typically placed in a static block to ensure that they are executed before any application code. <a class="xref" href="ch05.html#dynamically_inserting_a_custom_jca_provi" title="Example 5-4. Dynamically inserting a custom JCA provider">Example 5-4</a> shows an example of replacing the default (top priority) provider with a custom one.</p><div class="example"><a id="dynamically_inserting_a_custom_jca_provi"/><p class="title">Example 5-4. Dynamically inserting a custom JCA provider</p><div class="example-contents"><pre class="programlisting">static {
    Security.insertProviderAt(new MyProvider(), 1);
}</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch05note02"/>Note</h3><p><a id="iddle1492" class="indexterm"/><a id="iddle1493" class="indexterm"/><a id="iddle1872" class="indexterm"/><a id="iddle2018" class="indexterm"/><a id="iddle2019" class="indexterm"/><a id="iddle2326" class="indexterm"/><a id="iddle2327" class="indexterm"/><span class="emphasis"><em>If the class is loaded more than once (for example, by different class loaders), the static block may be executed multiple times. You can work around this by checking whether the provider is already available or by using a holder class that is loaded only once.</em></span></p></div></div></div></div><div class="sect1" title="JCA Engine Classes"><div class="titlepage"><div><div><h1 class="title"><a id="jca_engine_classes"/>JCA Engine Classes</h1></div></div></div><p>An engine class provides the interface to a specific type of cryptographic service. JCA engines provide one of the following services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Cryptographic operations (encrypt/decrypt, sign/verify, hash, and so on)</p></li><li class="listitem"><p>Generation or conversion of cryptographic material (keys and algorithm parameters)</p></li><li class="listitem"><p>Management and storage of cryptographic objects, such as keys and digital certificates</p></li></ul></div><div class="sect2" title="Obtaining an Engine Class Instance"><div class="titlepage"><div><div><h2 class="title"><a id="obtaining_an_engine_class_instance"/>Obtaining an Engine Class Instance</h2></div></div></div><p>In addition to providing a unified interface to cryptographic operations, engine classes decouple client code from the underlying implementation, which is why they cannot be instantiated directly; instead, they provide a static factory method called <code class="literal">getInstance()</code> that lets you request an implementation indirectly. The <code class="literal">getInstance()</code> method typically has one of the signatures shown in <a class="xref" href="ch05.html#jca_engine_class_factory_method_signatur" title="Example 5-5. JCA engine class factory method signatures">Example 5-5</a>.</p><div class="example"><a id="jca_engine_class_factory_method_signatur"/><p class="title">Example 5-5. JCA engine class factory method signatures</p><div class="example-contents"><pre class="programlisting">static EngineClassName getInstance(String algorithm)➊
    throws NoSuchAlgorithmException
static EngineClassName getInstance(String algorithm, String provider)➋
    throws NoSuchAlgorithmException, NoSuchProviderException
static EngineClassName getInstance(String algorithm, Provider provider)➌
    throws NoSuchAlgorithmException</pre></div></div><p>Usually, you would use the signature at ➊ and specify only the algorithm name. The signatures at ➋ and ➌ allow you to request an implementation from a specific provider. All variants throw a <code class="literal">NoSuchAlgorithmException</code> if an implementation for the requested algorithm is not available and ➋ throws <code class="literal">NoSuchProviderException</code> if a provider with the specified name is not registered.</p></div><div class="sect2" title="Algorithm Names"><div class="titlepage"><div><div><h2 class="title"><a id="algorithm_names"/>Algorithm Names</h2></div></div></div><p><a id="iddle1111" class="indexterm"/><a id="iddle1128" class="indexterm"/><a id="iddle1461" class="indexterm"/><a id="iddle1476" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1499" class="indexterm"/><a id="iddle1503" class="indexterm"/><a id="iddle2006" class="indexterm"/><a id="iddle2035" class="indexterm"/><a id="iddle2052" class="indexterm"/><a id="iddle2555" class="indexterm"/><a id="iddle2619" class="indexterm"/><a id="iddle2636" class="indexterm"/><a id="iddle2696" class="indexterm"/><a id="iddle2805" class="indexterm"/>The string <code class="literal">algorithm</code> parameter that all factory methods take maps to a particular cryptographic algorithm or transformation, or specifies an implementation strategy for higher-level objects that manage collections of certificates or keys. Usually, the mapping is straightforward. For example, <span class="emphasis"><em>SHA-256</em></span> maps to an implementation of the SHA-256 hashing algorithm and <span class="emphasis"><em>AES</em></span> requests an implementation of the AES encryption algorithm. However, some algorithm names have structure and specify more than one parameter of the requested implementation. For example, <span class="emphasis"><em>SHA256withRSA</em></span> specifies a signature implementation that uses SHA-256 for hashing the signed message and RSA to perform the signature operation. Algorithms can also have aliases, and more than one algorithm name can map to the same implementation.</p><p>Algorithm names are case-insensitive. The standard algorithm names supported by each JCA engine class are defined in the <span class="emphasis"><em>JCA Standard Algorithm Name Documentation</em></span> (sometimes referred to as just <span class="emphasis"><em>Standard Names</em></span>).<sup>[<a id="ch05fn01" href="#ftn.ch05fn01" class="footnote">38</a>]</sup> In addition to those, providers can define their own algorithm names and aliases. (See each provider’s documentation for details.) You can use the code in <a class="xref" href="ch05.html#listing_all_jca_providers_and_the_algori" title="Example 5-6. Listing all JCA providers and the algorithms they support">Example 5-6</a> to list all providers, the algorithm names of cryptographic services offered by each provider, and the implementation classes they map to.</p><div class="example"><a id="listing_all_jca_providers_and_the_algori"/><p class="title">Example 5-6. Listing all JCA providers and the algorithms they support</p><div class="example-contents"><pre class="programlisting">Provider[] providers = Security.getProviders();
for (Provider p : providers) {
     System.out.printf("%s/%s/%f\n", p.getName(), p.getInfo(), p.getVersion());
     Set&lt;Service&gt; services = p.getServices();
     for (Service s : services) {
         System.out.printf("\t%s/%s/%s\n", s.getType(),
              s.getAlgorithm(), s.getClassName());
    }
}</pre></div></div><p>We will show the format for the algorithm name of major engine classes as we introduce them in the following sections.</p></div><div class="sect2" title="SecureRandom"><div class="titlepage"><div><div><h2 class="title"><a id="securerandom"/>SecureRandom</h2></div></div></div><p>The <code class="literal">SecureRandom</code> class represents a cryptographic <span class="emphasis"><em>Random Number Generator (RNG)</em></span>. While you may not directly use it too often, it is used internally by most cryptographic operations to generate keys and other cryptographic material. The typical software implementation is usually a <span class="emphasis"><em>Cryptographically Secure Pseudo Random Number Generator (CSPRNG)</em></span>, which produces a sequence of numbers that approximate the properties of true random numbers based on an initial value called a <span class="emphasis"><em>seed</em></span>. As the quality of random numbers produced <a id="iddle1462" class="indexterm"/><a id="iddle1504" class="indexterm"/><a id="iddle1758" class="indexterm"/><a id="iddle2029" class="indexterm"/><a id="iddle2203" class="indexterm"/><a id="iddle2293" class="indexterm"/><a id="iddle2791" class="indexterm"/>by a CSPRNG largely depends on its seed, it is chosen carefully, usually based on the output of a true RNG.</p><p>On Android, CSPRNG implementations are seeded by reading seed bytes from the standard Linux <span class="emphasis"><em>/dev/urandom</em></span> device file, which is an interface to the kernel CSPRNG. As the kernel CSPRNG itself may be in a fairly predictable state right after starting, Android periodically saves the state (which is 4096 bytes as of Android 4.4) of the kernel CSPRNG to the <span class="emphasis"><em>/data/system/entropy.dat</em></span> file. The contents of that file are written back to <span class="emphasis"><em>/dev/urandom</em></span> on boot in order to carry over the previous CSPRNG state. This is performed by the <code class="literal">EntropyMixer</code> system service.</p><p>Unlike most engine classes, <code class="literal">SecureRandom</code> has public constructors that you can use to create an instance. The recommended way to get a properly seeded instance on Android is to use the default (no argument) constructor (➊ in <a class="xref" href="ch05.html#using_securerandom_to_generate_random_by" title="Example 5-7. Using SecureRandom to generate random bytes">Example 5-7</a>). If you use the <code class="literal">getInstance()</code> factory method, you need to pass <span class="emphasis"><em>SHA1PRNG</em></span> as the algorithm name, which is the only universally supported algorithm name for <code class="literal">SecureRandom</code>. Because <span class="emphasis"><em>SHA1PRNG</em></span> is not exactly a cryptographic standard, implementations from different providers might behave differently. To have <code class="literal">SecureRandom</code> generate random bytes, you pass a byte array to its <code class="literal">nextBytes()</code> method (➋ in <a class="xref" href="ch05.html#using_securerandom_to_generate_random_by" title="Example 5-7. Using SecureRandom to generate random bytes">Example 5-7</a>). It will generate as many bytes as the array length (16 in <a class="xref" href="ch05.html#using_securerandom_to_generate_random_by" title="Example 5-7. Using SecureRandom to generate random bytes">Example 5-7</a>) and store them in it.</p><div class="example"><a id="using_securerandom_to_generate_random_by"/><p class="title">Example 5-7. Using <code class="literal">SecureRandom</code> to generate random bytes</p><div class="example-contents"><pre class="programlisting">SecureRandom sr = new SecureRandom();➊
byte[] output = new byte[16];
sr.nextBytes(output);➋</pre></div></div><p>Seeding <code class="literal">SecureRandom</code> manually is not recommended because seeding the system CSPRNG improperly may result in it producing a predictable sequence of bytes, which could compromise any higher-level operations that require random input. However, if you need to manually seed <code class="literal">SecureRandom</code> for some reason (for example, if the default system seeding implementation is known to be flawed), you can do so by using the <code class="literal">SecureRandom(byte[] seed)</code> constructor or by calling the <code class="literal">setSeed()</code> method. When seeding manually, make sure that the seed you are using is sufficiently random; for example, by reading it from <span class="emphasis"><em>/dev/urandom</em></span>.</p><p>Additionally, depending on the underlying implementation, calling <code class="literal">setSeed()</code> may not replace, but instead only add to the internal CSPRNG state; so two <code class="literal">SecureRandom</code> instances seeded with the same seed value may not produce the same number sequence. Therefore, <code class="literal">SecureRandom</code> should not be used when deterministic values are required. Instead, use a cryptographic primitive that is designed to produce deterministic output from a given input, such as a hash algorithm or a key derivation function.</p></div><div class="sect2" title="MessageDigest"><div class="titlepage"><div><div><h2 class="title"><a id="messagedigest"/>MessageDigest</h2></div></div></div><p>The <code class="literal">MessageDigest</code> class represents the functionality of a cryptographic message digest, also referred to as a hash function. A cryptographic message digest takes an arbitrarily long sequence of bytes and generates a fixed-size <a id="iddle1235" class="indexterm"/><a id="iddle1500" class="indexterm"/><a id="iddle1611" class="indexterm"/><a id="iddle2036" class="indexterm"/><a id="iddle2824" class="indexterm"/><a id="iddle2983" class="indexterm"/>byte sequence called a <span class="emphasis"><em>digest</em></span> or <span class="emphasis"><em>hash</em></span>. A good hash function guarantees that even a small change in its input results in completely different output and that it is very difficult to find two inputs that are different but produce the same hash value (<span class="emphasis"><em>collision resistance</em></span>), or generate an input that has a given hash (<span class="emphasis"><em>pre-image resistance</em></span>). Another important property of hash functions is second pre-image resistance. In order to withstand second pre-image attacks, a hash function should make it difficult to find a second input m<sub>2</sub> that hashes to the same value as a given input m<sub>1</sub>.</p><p><a class="xref" href="ch05.html#using_messagedigest_to_hash_data" title="Example 5-8. Using MessageDigest to hash data">Example 5-8</a> shows how to use the <code class="literal">MessageDigest</code> class.</p><div class="example"><a id="using_messagedigest_to_hash_data"/><p class="title">Example 5-8. Using <code class="literal">MessageDigest</code> to hash data</p><div class="example-contents"><pre class="programlisting">MessageDigest md = MessageDigest.getInstance("SHA-256");➊
byte[] data = getMessage();
byte[] digest = md.digest(data);➋</pre></div></div><p>A <code class="literal">MessageDigest</code> instance is created by passing the hash algorithm name to the <code class="literal">getInstance()</code> factory method ➊. Input may be provided in chunks by using one of the <code class="literal">update()</code> methods, and then calling one of the <code class="literal">digest()</code> methods to get the calculated hash value. Alternatively, if the input data size is fixed and relatively short, it can be hashed in one step by using the <code class="literal">digest(byte[] input)</code> method ➋, as shown in <a class="xref" href="ch05.html#using_messagedigest_to_hash_data" title="Example 5-8. Using MessageDigest to hash data">Example 5-8</a>.</p></div><div class="sect2" title="Signature"><div class="titlepage"><div><div><h2 class="title"><a id="signature-id00010"/>Signature</h2></div></div></div><p>The <code class="literal">Signature</code> class provides a common interface for digital signature algorithms based on asymmetric encryption. A digital signature algorithm takes an arbitrary message and a private key and produces a fixed-sized byte string called a <span class="emphasis"><em>signature</em></span>. Digital signatures typically apply a digest algorithm to the input message, encode the calculated hash value, and then use a private key operation to produce the signature. The signature can then be verified using the corresponding public key by applying the reverse operation, calculating the hash value of the signed message, and comparing it to the one encoded in the signature. Successful verification guarantees the integrity of the signed message and, on the condition that the signing private key has remained indeed private, its authenticity.</p><p><code class="literal">Signature</code> instances are created with the standard <code class="literal">getInstance()</code> factory method. The algorithm name used is generally in the form <span class="emphasis"><em>&lt;digest&gt;with &lt;encryption&gt;</em></span>, where <span class="emphasis"><em>&lt;digest&gt;</em></span> is a hash algorithm name as used by <code class="literal">MessageDigest</code> (such as <span class="emphasis"><em>SHA256</em></span>), and <span class="emphasis"><em>&lt;encryption&gt;</em></span> is an asymmetric encryption algorithm (such as <span class="emphasis"><em>RSA</em></span> or <span class="emphasis"><em>DSA</em></span>). For example, a <span class="emphasis"><em>SHA512withRSA</em></span> <code class="literal">Signature</code> would first use the SHA-512 hash algorithm to produce a digest value and then encrypt the encoded digest with an RSA private key to produce the signature. For signature algorithms that use a mask generation function such as RSA-PSS, the algorithm name takes the form <span class="emphasis"><em>&lt;digest&gt;with&lt;encryption&gt;and&lt;mgf&gt;</em></span> (for example, <span class="emphasis"><em>SHA256withRSAandMGF1</em></span>).</p><p><a class="xref" href="ch05.html#generating_and_verifying_a_signature_wit" title="Example 5-9. Generating and verifying a signature with the Signature class">Example 5-9</a> shows how to use the <code class="literal">Signature</code> class to generate and verify a cryptographic signature.</p><div class="example"><a id="generating_and_verifying_a_signature_wit"/><p class="title">Example 5-9. Generating and verifying a signature with the <code class="literal">Signature</code> class</p><div class="example-contents"><pre class="programlisting">PrivateKey privKey = getPrivateKey();
PublicKey pubKey = getPublicKey();
byte[] data = "sign me".getBytes("ASCII");

Signature sig = Signature.getInstance("SHA256withRSA");
sig.initSign(privKey);➊
sig.update(data);➋
byte[] signature = sig.sign();➌

sig.initVerify(pubKey);➍
sig.update(data);
boolean valid = sig.verify(signature);➎</pre></div></div><p><a id="iddle1236" class="indexterm"/><a id="iddle1381" class="indexterm"/><a id="iddle1388" class="indexterm"/><a id="iddle1481" class="indexterm"/><a id="iddle1955" class="indexterm"/><a id="iddle2016" class="indexterm"/><a id="iddle2417" class="indexterm"/><a id="iddle2888" class="indexterm"/><a id="iddle3064" class="indexterm"/>After obtaining an instance, the <code class="literal">Signature</code> object is initialized for either signing, by passing a private key to the <code class="literal">initSign()</code> method (➊ in <a class="xref" href="ch05.html#generating_and_verifying_a_signature_wit" title="Example 5-9. Generating and verifying a signature with the Signature class">Example 5-9</a>), or verification, by passing a public key or certificate to the <code class="literal">initVerify()</code> method ➍ for verification.</p><p>Signing is similar to calculating a hash with <code class="literal">MessageDigest</code>: the data to be signed is fed in chunks to one of the <code class="literal">update()</code> methods ➋ or in bulk to the <code class="literal">sign()</code> method ➌, which returns the signature value. To verify a signature, the signed data is passed to one of the <code class="literal">update()</code> methods. Finally, the signature is passed to the <code class="literal">verify()</code> method ➎, which returns <code class="literal">true</code> if the signature is valid.</p></div><div class="sect2" title="Cipher"><div class="titlepage"><div><div><h2 class="title"><a id="cipher"/>Cipher</h2></div></div></div><p>The <code class="literal">Cipher</code> class provides a common interface to encryption and decryption operations. Encryption is the process of using some algorithm (called a <span class="emphasis"><em>cipher</em></span>) and a key to transform data (called <span class="emphasis"><em>plaintext,</em></span> or <span class="emphasis"><em>plaintext message</em></span>) into a randomly looking form (called <span class="emphasis"><em>ciphertext</em></span>). The inverse operation, called <span class="emphasis"><em>decryption</em></span>, transforms the ciphertext back into the original plaintext.</p><p>The two major types of encryption widely used today are <span class="emphasis"><em>symmetric encryption</em></span> and <span class="emphasis"><em>asymmetric encryption</em></span>. Symmetric, or <span class="emphasis"><em>secret key</em></span>, encryption uses the same key to encrypt and decrypt data. Asymmetric encryption uses a pair of keys: a <span class="emphasis"><em>public key</em></span> and a <span class="emphasis"><em>private key</em></span>. Data encrypted with one of the keys can only be decrypted with the other key of the pair. The <code class="literal">Cipher</code> class supports both symmetric and asymmetric encryption.</p><p>Depending on how they process input, ciphers can be <span class="emphasis"><em>block</em></span> or <span class="emphasis"><em>stream</em></span>. Block ciphers work on fixed-sized chunks of data called <span class="emphasis"><em>blocks</em></span>. If the input cannot be divided into an integral number of blocks, the last block is <span class="emphasis"><em>padded</em></span> by adding the necessary number of bytes to match the block size. Both the operation and the added bytes are called <span class="emphasis"><em>padding</em></span>. Padding is removed in the decryption process and is not included in the decrypted plaintext. If a padding algorithm is specified, the <code class="literal">Cipher</code> class can add and remove padding automatically. On the other hand, stream ciphers process input data one byte (or even bit) at a time and do not require padding.</p><div class="sect3" title="Block Cipher Modes of Operation"><div class="titlepage"><div><div><h3 class="title"><a id="block_cipher_modes_of_operation"/>Block Cipher Modes of Operation</h3></div></div></div><p><a id="iddle1283" class="indexterm"/><a id="iddle1326" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1377" class="indexterm"/><a id="iddle1379" class="indexterm"/><a id="iddle1385" class="indexterm"/><a id="iddle1389" class="indexterm"/><a id="iddle1428" class="indexterm"/><a id="iddle1506" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1703" class="indexterm"/><a id="iddle1953" class="indexterm"/><a id="iddle2000" class="indexterm"/><a id="iddle2014" class="indexterm"/><a id="iddle2333" class="indexterm"/><a id="iddle2375" class="indexterm"/>Block ciphers employ different strategies when processing input blocks in order to produce the final ciphertext (or plaintext when decrypting). Those strategies are called <span class="emphasis"><em>modes of operation</em></span>, <span class="emphasis"><em>cipher modes</em></span>, or simply <span class="emphasis"><em>modes</em></span>. The simplest processing strategy is to split the plaintext into blocks (padding as necessary), apply the cipher to each block, and then concatenate the encrypted blocks to produce the ciphertext. This mode is called <span class="emphasis"><em>Electronic Code Book (ECB)</em></span> mode, and while it’s straightforward and easy to use, it has the major disadvantage that identical plaintext blocks produce identical ciphertext blocks. Thus, plaintext structure is reflected in the ciphertext, which compromises message confidentiality and facilitates cryptanalysis. This has often been illustrated with the infamous “ECB Penguin” from the Wikipedia entry on block cipher modes.<sup>[<a id="ch05fn02" href="#ftn.ch05fn02" class="footnote">39</a>]</sup> We present our Android version in <a class="xref" href="ch05.html#ciphertext_patterns_produced_by_differen" title="Figure 5-2. Ciphertext patterns produced by different cipher modes">Figure 5-2</a>.<sup>[<a id="ch05fn03" href="#ftn.ch05fn03" class="footnote">40</a>]</sup> Here, ➊ is the original image, ➋ is the image encrypted in ECB mode, and ➌ is the same image encrypted in CBC mode. As you can see, the pattern of the original image is distinguishable in ➋, while ➌ looks like random noise.</p><div class="figure"><a id="ciphertext_patterns_produced_by_differen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00014"/><img src="figs/web/05fig02.png.jpg" alt="Ciphertext patterns produced by different cipher modes"/></div></div><p class="title">Figure 5-2. Ciphertext patterns produced by different cipher modes</p></div><p><span class="emphasis"><em>Feedback modes</em></span> add randomness to the ciphertext by combining the previous encrypted block with the current plaintext block before encrypting. In order to produce the first cipher block, they combine the first plaintext block with a block-sized string of bytes not found in the original plain text, called an <span class="emphasis"><em>initialization vector (IV)</em></span>. When configured to use a feedback mode, the <code class="literal">Cipher</code> class can use a client-specified IV or generate one automatically. Commonly used feedback modes are <span class="emphasis"><em>Cipher-block chaining (CBC)</em></span>, <span class="emphasis"><em>Cipher feedback (CFB)</em></span>, and <span class="emphasis"><em>Output feedback (OFB)</em></span>.</p><p>Another way to add randomness to the ciphertext, employed by the <span class="emphasis"><em>Counter (CTR)</em></span> mode, is to encrypt the successive values of a counter sequence in order to produce a new key for each plaintext block that needs to be encrypted. This effectively turns the underlying block cipher into a stream cipher and no padding is required.</p><p><a id="iddle1110" class="indexterm"/><a id="iddle1112" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1380" class="indexterm"/><a id="iddle1661" class="indexterm"/><a id="iddle1841" class="indexterm"/><a id="iddle2015" class="indexterm"/><a id="iddle2487" class="indexterm"/><a id="iddle2543" class="indexterm"/><a id="iddle2598" class="indexterm"/><a id="iddle2615" class="indexterm"/>Newer cipher modes, such as <span class="emphasis"><em>Galois/Counter Mode (GCM)</em></span>, not only diffuse patterns in the original plaintext but also authenticate the ciphertext, making sure it has not been tampered with. They provide <span class="emphasis"><em>authenticated encryption (AE)</em></span> or <span class="emphasis"><em>Authenticated Encryption with Associated Data (AEAD)</em></span>.<sup>[<a id="ch05fn04" href="#ftn.ch05fn04" class="footnote">41</a>]</sup> The <code class="literal">Cipher</code> APIs have been extended to support authenticated encryption in Java SE 7, and those extensions have been available since Android 4.4, which has a Java 7–compatible runtime library API. AE ciphers concatenate the authentication tag output by the encryption operation to the ciphertext that operation produces in order to form their final output. In the Java <code class="literal">Cipher</code> API, the tag is included (or verified, when decrypting) implicitly after calling <code class="literal">doFinal()</code>, so you should not use the output of <code class="literal">update()</code> until you’re sure the implicit tag at the end validates.</p></div><div class="sect3" title="Obtaining a Cipher Instance"><div class="titlepage"><div><div><h3 class="title"><a id="obtaining_a_cipher_instance"/>Obtaining a Cipher Instance</h3></div></div></div><p>Having reviewed the major parameters of a cipher, we can finally discuss how to create <code class="literal">Cipher</code> instances. Like the other engine classes, <code class="literal">Cipher</code> objects are created with the <code class="literal">getInstance()</code> factory method, which requires not just a simple algorithm name, but that you fully specify the cryptographic <span class="emphasis"><em>transformation</em></span> that the requested cipher will perform.</p><p><a class="xref" href="ch05.html#creating_a_cipher_instance" title="Example 5-10. Creating a Cipher instance">Example 5-10</a> shows how to create a <code class="literal">Cipher</code> instance by passing a transformation string to <code class="literal">getInstance()</code>.</p><div class="example"><a id="creating_a_cipher_instance"/><p class="title">Example 5-10. Creating a <code class="literal">Cipher</code> instance</p><div class="example-contents"><pre class="programlisting">Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");</pre></div></div><p>A transformation needs to specify the encryption algorithm, cipher mode, and padding. The transformation string passed to <code class="literal">getInstance()</code> is in the <span class="emphasis"><em>algorithm/mode/padding</em></span> format. For example, the transformation string used in <a class="xref" href="ch05.html#creating_a_cipher_instance" title="Example 5-10. Creating a Cipher instance">Example 5-10</a> would create a <code class="literal">Cipher</code> instance that uses AES as the encryption algorithm, CBC as the cipher mode, and PKCS#5 padding.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note03"/>Note</h3><p><span class="emphasis"><em>The term</em></span> PKCS <span class="emphasis"><em>will appear quite a few times in our discussion of JCA providers and engine classes. The acronym stands for</em></span> Public Key Cryptography Standard <span class="emphasis"><em>and refers to a group of cryptography standards that were originally developed and published by RSA Security, Inc. in the early 1990s. Most have evolved into public Internet standard and are now published and maintained as RFCs (Requests for Comments, formal documents describing Internet standards), but they are still referred to by their original name. Notable standards include PKCS#1, which defines the basic algorithms for RSA encryption and signatures; PKCS#5, which defines password-based encryption; PKCS#7, which defines message encryption and signing under a PKI and became the basis of S/MIME; and PKCS#12, which defines a container for keys and certificates. A full list can be found on EMC’s website.</em></span><sup>[<a id="ch05fn05" href="#ftn.ch05fn05" class="footnote">42</a>]</sup></p></div><p><a id="iddle1384" class="indexterm"/><a id="iddle1529" class="indexterm"/><a id="iddle1725" class="indexterm"/><a id="iddle2017" class="indexterm"/><a id="iddle2981" class="indexterm"/><a id="iddle3135" class="indexterm"/>A <code class="literal">Cipher</code> instance can be created by passing only the algorithm name, but in that case the returned implementation would use provider-specific defaults for the cipher mode and padding. This is not only not portable across providers, but could severely impact the security of the system if, for example, a less-secure-than-intended cipher mode (such as ECB) is used at runtime. This “shortcut” is a major design flaw of the JCA provider framework and should never be used.</p></div><div class="sect3" title="Using a Cipher"><div class="titlepage"><div><div><h3 class="title"><a id="using_a_cipher"/>Using a Cipher</h3></div></div></div><p>Once a <code class="literal">Cipher</code> instance has been obtained, it needs to be initialized before encrypting or decrypting data. A <code class="literal">Cipher</code> is initialized by passing an integer constant that denotes the operation mode (<code class="literal">ENCRYPT_MODE</code>, <code class="literal">DECRYPT_MODE</code>, <code class="literal">WRAP_MODE</code>, or <code class="literal">UNWRAP_MODE</code>), a key or certificate, and, optionally, algorithm parameters, to one of the corresponding <code class="literal">init()</code> methods. <code class="literal">ENCRYPT_MODE</code> and <code class="literal">DECRYPT_MODE</code> are used to encrypt and decrypt arbitrary data, while <code class="literal">WRAP_MODE</code> and <code class="literal">UNWRAP_MODE</code> are specialized modes used when encrypting (<span class="emphasis"><em>wrapping</em></span>) and decrypting (<span class="emphasis"><em>unwrapping</em></span>) the key material of a <code class="literal">Key</code> object with another key.</p><p><a class="xref" href="ch05.html#using_the_cipher_class_to_encrypt_and_de" title="Example 5-11. Using the Cipher class to encrypt and decrypt data">Example 5-11</a> shows how to use the <code class="literal">Cipher</code> class to encrypt and decrypt data.</p><div class="example"><a id="using_the_cipher_class_to_encrypt_and_de"/><p class="title">Example 5-11. Using the <code class="literal">Cipher</code> class to encrypt and decrypt data</p><div class="example-contents"><pre class="programlisting">SecureRandom sr = new SecureRandom();
SecretKey key = getSecretKey();
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");➊

byte[] iv = new byte[cipher.getBlockSize()];
sr.nextBytes(iv);
IvParameterSpec ivParams = new IvParameterSpec(iv);➋
cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);➌
byte[] plaintext = "encrypt me".getBytes("UTF-8");
ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte[] output = cipher.update(plaintext);➍
if (output != null) {
    baos.write(output);
}
output = cipher.doFinal();➎
baos.write(output);
byte[] ciphertext = baos.toByteArray();

cipher.init(Cipher.DECRYPT_MODE, key, ivParams);➏
baos = new ByteArrayOutputStream();
output = cipher.update(ciphertext);➐
if (output != null) {
    baos.write(output);
}
output = cipher.doFinal();➑
baos.write(output);
byte[] decryptedPlaintext = baos.toByteArray();➒</pre></div></div><p><a id="iddle1490" class="indexterm"/><a id="iddle1530" class="indexterm"/><a id="iddle2028" class="indexterm"/><a id="iddle2169" class="indexterm"/><a id="iddle2178" class="indexterm"/><a id="iddle2201" class="indexterm"/><a id="iddle2806" class="indexterm"/>In this example, we create a <code class="literal">Cipher</code> instance that uses AES in CBC mode and PKCS#5 padding ➊; generate a random IV and wrap it into an <code class="literal">IvParameterSpec</code> object ➋; and then initialize the <code class="literal">Cipher</code> for encryption by passing <code class="literal">ENCRYPT_MODE</code>, the encryption key, and the IV to the <code class="literal">init()</code> method ➌. We can then encrypt data by passing data chunks to the <code class="literal">update()</code> method ➍, which returns intermediate results (or <code class="literal">null</code> if the input data is too short to result in a new block), and obtain the last block by calling the <code class="literal">doFinal()</code> method ➎. The final ciphertext is obtained by concatenating the intermediate result(s) with the final block.</p><p>To decrypt, we initialize the <code class="literal">cipher</code> in <code class="literal">DECRYPT_MODE</code> ➏, passing the same key and the IV used for encryption. We then call <code class="literal">update()</code> ➐, this time using the ciphertext as input, and finally call <code class="literal">doFinal()</code> ➑ to obtain the last chunk of plaintext. The final plaintext is obtained by concatenating the intermediate result(s) with the final chunk ➒.</p></div></div><div class="sect2" title="Mac"><div class="titlepage"><div><div><h2 class="title"><a id="mac"/>Mac</h2></div></div></div><p>The <code class="literal">Mac</code> class provides a common interface to <span class="emphasis"><em>Message Authentication Code (MAC)</em></span> algorithms. A MAC is used to check the integrity of messages transmitted over an unreliable channel. MAC algorithms use a secret key to calculate a value, <span class="emphasis"><em>the MAC</em></span> (also called a <span class="emphasis"><em>tag</em></span>), which can be used to authenticate the message and check its integrity. The same key is used to perform verification, so it needs to be shared between the communicating parties. (A MAC is often combined with a cipher to provide both confidentiality and integrity.)</p><div class="example"><a id="using_the_mac_class_to_generate_a_messag"/><p class="title">Example 5-12. Using the <code class="literal">Mac</code> class to generate a message authentication code</p><div class="example-contents"><pre class="programlisting">KeyGenerator keygen = KeyGenerator.getInstance("HmacSha256");
SecretKey key = keygen.generateKey();
Mac mac = Mac.getInstance("HmacSha256");➊
mac.init(key);➋
byte[] message = "MAC me".getBytes("UTF-8");
byte[] tag = mac.doFinal(message);➌</pre></div></div><p>A <code class="literal">Mac</code> instance is obtained with the <code class="literal">getInstance()</code> factory method ➊ (as shown in <a class="xref" href="ch05.html#using_the_mac_class_to_generate_a_messag" title="Example 5-12. Using the Mac class to generate a message authentication code">Example 5-12</a>) by requesting an implementation of the HMAC<sup>[<a id="ch05fn06" href="#ftn.ch05fn06" class="footnote">43</a>]</sup> MAC algorithm that uses SHA-256 as the hash function. It is then initialized ➋ with a <code class="literal">SecretKey</code> instance, which may be generated with a <code class="literal">KeyGenerator</code> (see “<a class="xref" href="ch05.html#keygenerator" title="KeyGenerator">KeyGenerator</a>”), derived from a password or directly instantiated from raw key bytes. For MAC implementations based on hash functions (such as HMAC SHA-256 in this example), the type of key does not matter, but implementations that use a symmetric cipher may require a matching key type to be passed. We can then pass the message in chunks using one of the <code class="literal">update()</code> methods and call <code class="literal">doFinal()</code> to obtain the final MAC value, or perform the operation in one step by passing the message bytes directly to <code class="literal">doFinal()</code> ➌.</p></div><div class="sect2" title="Key"><div class="titlepage"><div><div><h2 class="title"><a id="key"/>Key</h2></div></div></div><p><a id="iddle1485" class="indexterm"/><a id="iddle1494" class="indexterm"/><a id="iddle1498" class="indexterm"/><a id="iddle1853" class="indexterm"/><a id="iddle1864" class="indexterm"/><a id="iddle1871" class="indexterm"/><a id="iddle2023" class="indexterm"/><a id="iddle2030" class="indexterm"/><a id="iddle2034" class="indexterm"/><a id="iddle2107" class="indexterm"/><a id="iddle2430" class="indexterm"/><a id="iddle2679" class="indexterm"/>The <code class="literal">Key</code> interface represents <span class="emphasis"><em>opaque</em></span> keys in the JCA framework. Opaque keys can be used in cryptographic operations, but usually do not provide access to the underlying <span class="emphasis"><em>key material</em></span> (raw key bytes). This allows us to use the same JCA classes and interfaces both with software implementations of cryptographic algorithms that store key material on memory, and with hardware-backed ones, where the key material may reside in a hardware token (smart card, HSM<sup>[<a id="ch05fn07" href="#ftn.ch05fn07" class="footnote">44</a>]</sup> and so on) and is not directly accessible.</p><p>The <code class="literal">Key</code> interface defines only three methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="String getAlgorithm()"><span class="title"><strong><span class="strong"><strong><code class="literal">String getAlgorithm()</code></strong></span></strong></span>. Returns the name of the encryption algorithm (symmetric or asymmetric) that this key can be used with. Examples are <span class="emphasis"><em>AES</em></span> or <span class="emphasis"><em>RSA</em></span>.</p></li><li class="listitem"><p title="byte[] getEncoded()"><span class="title"><strong><span class="strong"><strong><code class="literal">byte[] getEncoded()</code></strong></span></strong></span>. Returns a standard encoded form of the key that can be used when transmitting the key to other systems. This can be encrypted for private keys. For hardware-backed implementations that do not allow exporting key material, this method typically returns <code class="literal">null</code>.</p></li><li class="listitem"><p title="String getFormat()"><span class="title"><strong><span class="strong"><strong><code class="literal">String getFormat()</code></strong></span></strong></span>. Returns the format of the encoded key. This is usually <span class="emphasis"><em>RAW</em></span> for keys that are not encoded in any particular format. Other formats defined in JCA are <span class="emphasis"><em>X.509</em></span> and <span class="emphasis"><em>PKCS#8</em></span>.</p></li></ul></div><p>You can obtain a <code class="literal">Key</code> instance in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Generate keys using a <code class="literal">KeyGenerator</code> or a <code class="literal">KeyPairGenerator</code>.</p></li><li class="listitem"><p>Convert from some encoded representation using a <code class="literal">KeyFactory</code>.</p></li><li class="listitem"><p>Retrieve a stored key from a <code class="literal">KeyStore</code>.</p></li></ul></div><p>We discuss different <code class="literal">Key</code> types and how they are created and accessed in the next sections.</p></div><div class="sect2" title="SecretKey and PBEKey"><div class="titlepage"><div><div><h2 class="title"><a id="secretkey_and_pbekey"/>SecretKey and PBEKey</h2></div></div></div><p>The <code class="literal">SecretKey</code> interface represents keys used in symmetric algorithms. It is a marker interface and does not add any methods to those of the parent <code class="literal">Key</code> interface. It has only one implementation that can be directly instantiated, namely <code class="literal">SecretKeySpec</code>. It is both a key implementation and a key specification (as discussed in the “<a class="xref" href="ch05.html#keyspec" title="KeySpec">KeySpec</a>” section that follows) and allows you to instantiate <code class="literal">SecretKey</code> instances based on the raw key material.</p><p>The <code class="literal">PBEKey</code> subinterface represents keys derived using <span class="emphasis"><em>Password Based Encryption (PBE)</em></span>.<sup>[<a id="ch05fn08" href="#ftn.ch05fn08" class="footnote">45</a>]</sup> PBE defines algorithms that derive strong cryptographic keys from passwords and passphrases, which typically have low entropy and thus cannot be used directly as keys. PBE is based on two main ideas: using a <span class="emphasis"><em>salt</em></span> to protect from table-assisted (pre-computed) dictionary attacks (<span class="emphasis"><em>salting</em></span>), and using a large iteration count to make the key derivation computationally <a id="iddle1483" class="indexterm"/><a id="iddle1487" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1495" class="indexterm"/><a id="iddle1496" class="indexterm"/><a id="iddle1876" class="indexterm"/><a id="iddle1880" class="indexterm"/><a id="iddle2021" class="indexterm"/><a id="iddle2025" class="indexterm"/><a id="iddle2026" class="indexterm"/><a id="iddle2031" class="indexterm"/><a id="iddle2032" class="indexterm"/><a id="iddle2086" class="indexterm"/><a id="iddle2117" class="indexterm"/><a id="iddle2119" class="indexterm"/><a id="iddle2128" class="indexterm"/><a id="iddle2514" class="indexterm"/><a id="iddle2545" class="indexterm"/>expensive (<span class="emphasis"><em>key stretching</em></span>). The salt and iteration count are used as parameters to PBE algorithms and thus need to be retained in order to generate the same key from a particular password. Thus <code class="literal">PBEKey</code> implementations are required to implement <code class="literal">getSalt()</code> and <code class="literal">getIterationCount()</code> along with <code class="literal">getPassword()</code>.</p></div><div class="sect2" title="PublicKey, PrivateKey, and KeyPair"><div class="titlepage"><div><div><h2 class="title"><a id="publickeycomma_privatekeycomma_and_keypa"/>PublicKey, PrivateKey, and KeyPair</h2></div></div></div><p>Public and private keys for asymmetric encryption algorithms are modeled with the <code class="literal">PublicKey</code> and <code class="literal">PrivateKey</code> interfaces. They are marker interfaces and do not add any new methods. JCA defines specialized classes for concrete asymmetric algorithms that hold the parameters of the corresponding keys, such as <code class="literal">RSAPublicKey</code> and <code class="literal">RSAPrivateCrtKey</code>. The <code class="literal">KeyPair</code> interface is simply a container for a public key and a private key.</p></div><div class="sect2" title="KeySpec"><div class="titlepage"><div><div><h2 class="title"><a id="keyspec"/>KeySpec</h2></div></div></div><p>As discussed in <a class="xref" href="ch05.html#key" title="Key">Key</a>, the JCA <code class="literal">Key</code> interface represents opaque keys. On the other hand, <code class="literal">KeySpec</code> models a <span class="emphasis"><em>key specification</em></span>, which is a <span class="emphasis"><em>transparent</em></span> key representation that allows you to access individual key parameters.</p><p>In practice, most <code class="literal">Key</code> and <code class="literal">KeySpec</code> interfaces for concrete algorithms overlap considerably because the key parameters need to be accessible in order to implement the encryption algorithms. For example, both <code class="literal">RSAPrivateKey</code> and <code class="literal">RSAPrivateKeySpec</code> define <code class="literal">getModulus()</code> and <code class="literal">getPrivateExponent()</code> methods. The difference is only important when an algorithm is implemented in hardware, in which case the <code class="literal">KeySpec</code> will only contain a reference to the hardware-managed key and not the actual key parameters. The corresponding <code class="literal">Key</code> will hold a handle to the hardware-managed key and can be used to perform cryptographic operations, but it will not hold any key material. For example, an <code class="literal">RSAPrivateKey</code> that is stored in hardware will return <code class="literal">null</code> when its <code class="literal">getPrivateExponent()</code> method is called.</p><p><code class="literal">KeySpec</code> implementations can hold an encoded key representation, in which case they are algorithm independent. For example, the <code class="literal">PKCS8EncodedKeySpec</code> can hold either an RSA key or a DSA key in DER-encoded PKCS#8 format.<sup>[<a id="ch05fn09" href="#ftn.ch05fn09" class="footnote">46</a>]</sup> On the other hand, an algorithm-specific <code class="literal">KeySpec</code> holds all key parameters as fields. For example, <code class="literal">RSAPrivateKeySpec</code> contains the modulus and private exponent for an RSA key, which can be obtained using the <code class="literal">getModulus()</code> and <code class="literal">getPrivateExponent()</code> methods, respectively. Regardless of their type, <code class="literal">KeySpec</code>s are converted to <code class="literal">Key</code> objects using a <code class="literal">KeyFactory</code>.</p></div><div class="sect2" title="KeyFactory"><div class="titlepage"><div><div><h2 class="title"><a id="keyfactory"/>KeyFactory</h2></div></div></div><p>A <code class="literal">KeyFactory</code> encapsulates a conversion routine needed to turn a transparent public or private key representation (some <code class="literal">KeySpec</code> subclass) into an opaque<sup>[<a id="ch05fn10" href="#ftn.ch05fn10" class="footnote">47</a>]</sup> <a id="iddle1497" class="indexterm"/><a id="iddle1848" class="indexterm"/><a id="iddle1865" class="indexterm"/><a id="iddle1874" class="indexterm"/><a id="iddle2033" class="indexterm"/><a id="iddle2677" class="indexterm"/><a id="iddle2927" class="indexterm"/><a id="iddle3145" class="indexterm"/>key object (some <code class="literal">Key</code> subclass) that can be used to perform a cryptographic operation, or vice versa. A <code class="literal">KeyFactory</code> that converts an encoded key typically parses the encoded key data and stores each key parameter in the corresponding field of the concrete <code class="literal">Key</code> class. For example, to parse an X.509-encoded RSA public key, you can use the following code (see <a class="xref" href="ch05.html#using_a_keyfactory_to_convert_an_xdot509" title="Example 5-13. Using a KeyFactory to convert an X.509 encoded key to an RSAPublicKey object">Example 5-13</a>).</p><div class="example"><a id="using_a_keyfactory_to_convert_an_xdot509"/><p class="title">Example 5-13. Using a <code class="literal">KeyFactory</code> to convert an X.509 encoded key to an <code class="literal">RSAPublicKey</code> object</p><div class="example-contents"><pre class="programlisting">KeyFactory kf = KeyFactory.getInstance("RSA");➊
byte[] encodedKey = readRsaPublicKey();
X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);➋
RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(keySpec);➌</pre></div></div><p>Here we create an RSA <code class="literal">KeyFactory</code> by passing <span class="emphasis"><em>RSA</em></span> to <code class="literal">KeyFactory.getInstance()</code> ➊. We then read the encoded RSA key, use the encoded key bytes to instantiate an <code class="literal">X509EncodedKeySpec</code> ➋, and finally pass the <code class="literal">KeySpec</code> to the factory’s <code class="literal">generatePublic()</code> method ➌ in order to obtain an <code class="literal">RSAPublicKey</code> instance.</p><p>A <code class="literal">KeyFactory</code> can also convert an algorithm-specific <code class="literal">KeySpec</code>, such as <code class="literal">RSAPrivateKeySpec</code>, to a matching <code class="literal">Key</code> (<code class="literal">RSAPrivateKey</code>, in this example) instance, but in that case it merely copies the key parameters (or key handle) from one class to the other. Calling the <code class="literal">KeyFactory.getKeySpec()</code> method converts a <code class="literal">Key</code> object to a <code class="literal">KeySpec</code>, but this usage is not very common because an encoded key representation can be obtained simply by calling <code class="literal">getEncoded()</code> directly on the key object, and algorithm-specific <code class="literal">KeySpec</code>s generally do not provide any more information than a concrete <code class="literal">Key</code> class does.</p><p>Another feature of <code class="literal">KeyFactory</code> is converting a <code class="literal">Key</code> instance from a different provider into a corresponding key object compatible with the current provider. The operation is called <span class="emphasis"><em>key translation</em></span> and is performed using the <code class="literal">translateKey(Key key)</code> method.</p></div><div class="sect2" title="SecretKeyFactory"><div class="titlepage"><div><div><h2 class="title"><a id="secretkeyfactory"/>SecretKeyFactory</h2></div></div></div><p><code class="literal">SecretKeyFactory</code> is very similar to <code class="literal">KeyFactory</code> except that it only operates on secret (symmetric) keys. You can use it to convert a symmetric key specification into a <code class="literal">Key</code> object and vice versa. In practice though, if you have access to the key material of a symmetric key, it is much easier to use it to instantiate directly a <code class="literal">SecretKeySpec</code> that is also a <code class="literal">Key</code>, so it is not used very often in this fashion.</p><p>A much more common use case is generating a symmetric key from a user-supplied password using PBE (see <a class="xref" href="ch05.html#generating_a_secret_key_from_a_password" title="Example 5-14. Generating a secret key from a password using SecretKeyFactory">Example 5-14</a>).</p><div class="example"><a id="generating_a_secret_key_from_a_password"/><p class="title">Example 5-14. Generating a secret key from a password using <code class="literal">SecretKeyFactory</code></p><div class="example-contents"><pre class="programlisting">byte[] salt = generateSalt();
int iterationCount = 1000; int keyLength = 256;
KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
                                 iterationCount, keyLength);➊
SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");➋
SecretKey key = skf.generateSecret(keySpec);➌</pre></div></div><p><a id="iddle1484" class="indexterm"/><a id="iddle1486" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle1707" class="indexterm"/><a id="iddle1847" class="indexterm"/><a id="iddle2022" class="indexterm"/><a id="iddle2024" class="indexterm"/><a id="iddle2090" class="indexterm"/><a id="iddle2111" class="indexterm"/>In this case, a <code class="literal">PBEKeySpec</code> is initialized with the password, a randomly generated salt, iteration count, and the desired key length ➊. A <code class="literal">SecretKey</code> factory that implements a PBE key derivation algorithm (in this case, PBKDF2) is then obtained with a call to <code class="literal">getInstance()</code> ➋. Passing the <code class="literal">PBEKeySpec</code> to <code class="literal">generateSecret()</code> executes the key derivation algorithm and returns a <code class="literal">SecretKey</code> instance ➌ that can be used for encryption or decryption.</p></div><div class="sect2" title="KeyPairGenerator"><div class="titlepage"><div><div><h2 class="title"><a id="keypairgenerator"/>KeyPairGenerator</h2></div></div></div><p>The <code class="literal">KeyPairGenerator</code> class generates pairs of public and private keys. A <code class="literal">KeyPairGenerator</code> is instantiated by passing an asymmetric algorithm name to the <code class="literal">getInstance()</code> factory method (➊ in <a class="xref" href="ch05.html#initializing_keypairgenerator_with_algor" title="Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters">Example 5-15</a>).</p><div class="example"><a id="initializing_keypairgenerator_with_algor"/><p class="title">Example 5-15. Initializing <code class="literal">KeyPairGenerator</code> with algorithm-specific parameters</p><div class="example-contents"><pre class="programlisting">KeyPairGenerator kpg = KeyPairGenerator.getInstance("ECDH");➊
ECGenParameterSpec ecParamSpec = new ECGenParameterSpec("secp256r1");➋
kpg.initialize(ecParamSpec);➌
KeyPair keyPair = kpg.generateKeyPair();➍</pre></div></div><p>There are two ways to initialize a <code class="literal">KeyPairGenerator</code>: by specifying the desired key size and by specifying algorithm-specific parameters. In both cases, you can optionally pass a <code class="literal">SecureRandom</code> instance to be used for key generation. If only a key size is specified, key generation will use default parameters (if any). To specify additional parameters, you must instantiate and configure an <code class="literal">AlgorithmParameterSpec</code> instance appropriate for the asymmetric algorithm you are using and pass it to the <code class="literal">initialize()</code> method, as shown in <a class="xref" href="ch05.html#initializing_keypairgenerator_with_algor" title="Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters">Example 5-15</a>. In this example, the <code class="literal">ECGenParameterSpec</code> initialized in ➋ is an <code class="literal">AlgorithmParameterSpec</code> that allows you to specify the curve name used when generating <span class="emphasis"><em>Elliptic Curve (EC)</em></span> cryptography keys. After it is passed to the <code class="literal">initialize()</code> method in ➌, the subsequent <code class="literal">generateKeyPair()</code> call in ➍ will use the specified curve (<span class="emphasis"><em>secp256r1</em></span>) to generate the key pair.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note04"/>Note</h3><p><span class="emphasis"><em>While named curves have been defined by various standards, the Oracle JCA specification does not explicitly define any elliptic curve names. As there is no official JCA standard, curve names supported by Android may vary based on platform version.</em></span></p></div></div><div class="sect2" title="KeyGenerator"><div class="titlepage"><div><div><h2 class="title"><a id="keygenerator"/>KeyGenerator</h2></div></div></div><p>The <code class="literal">KeyGenerator</code> is very similar to the <code class="literal">KeyPairGenerator</code> class, except that it generates symmetric keys. While you can generate most symmetric keys by requesting a sequence of random bytes from <code class="literal">SecureRandom</code>, <code class="literal">KeyGenerator</code> implementations perform additional checks for weak keys and set key <a id="iddle1113" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle1609" class="indexterm"/><a id="iddle2020" class="indexterm"/><a id="iddle2063" class="indexterm"/>parity bytes where appropriate (for DES and derived algorithms) and can take advantage of available cryptography hardware, so it’s best to use <code class="literal">KeyGenerator</code> instead of generating keys manually.</p><p><a class="xref" href="ch05.html#generating_an_aes_key_with_keygenerator" title="Example 5-16. Generating an AES key with KeyGenerator">Example 5-16</a> shows how to generate an AES key using <code class="literal">KeyGenerator</code>.</p><div class="example"><a id="generating_an_aes_key_with_keygenerator"/><p class="title">Example 5-16. Generating an AES key with <code class="literal">KeyGenerator</code></p><div class="example-contents"><pre class="programlisting">KeyGenerator keygen = KeyGenerator.getInstance("AES");➊
kg.init(256);➋
SecretKey key = keygen.generateKey();➌</pre></div></div><p>To generate a key using <code class="literal">KeyGenerator</code>, create an instance ➊, specify the desired key size with <code class="literal">init()</code> ➋, and then call <code class="literal">generateKey()</code> ➌ to generate the key.</p></div><div class="sect2" title="KeyAgreement"><div class="titlepage"><div><div><h2 class="title"><a id="keyagreement"/>KeyAgreement</h2></div></div></div><p>The <code class="literal">KeyAgreement</code> class represents a <span class="emphasis"><em>key agreement protocol</em></span> that allows two or more parties to generate a shared key without needing to exchange secret information. While there are different key agreement protocols, the ones most widely used today are based on the <span class="emphasis"><em>Diffie-Hellman (DH) key exchange</em></span>— either the original one based on discrete logarithm cryptography<sup>[<a id="ch05fn11" href="#ftn.ch05fn11" class="footnote">48</a>]</sup> (simply known as <span class="emphasis"><em>DH</em></span>), or the newer variant based on elliptic key cryptography (<span class="emphasis"><em>ECDH</em></span><sup>[<a id="ch05fn12" href="#ftn.ch05fn12" class="footnote">49</a>]</sup>).</p><p>Both variants of the protocol are modeled in JCA using the <code class="literal">KeyAgreement</code> class and can be performed in the same way, with the only difference being the keys. For both variants, each communicating party needs to have a key pair, with both key pairs generated with the same key parameters (prime modulus and base generator for DH, and typically the same well-defined named curve for ECDH). Then the parties only need to exchange public keys and execute the key agreement algorithm to arrive at a common secret.</p><p><a class="xref" href="ch05.html#using_keyagreement_to_generate_a_shared" title="Example 5-17. Using KeyAgreement to generate a shared secret">Example 5-17</a> illustrates using the <code class="literal">KeyAgreement</code> class to generate a shared secret using ECDH.</p><div class="example"><a id="using_keyagreement_to_generate_a_shared"/><p class="title">Example 5-17. Using <code class="literal">KeyAgreement</code> to generate a shared secret</p><div class="example-contents"><pre class="programlisting">PrivateKey myPrivKey = getPrivateKey();
PublicKey remotePubKey = getRemotePubKey();
KeyAgreement keyAgreement = KeyAgreement.getInstance("ECDH");➊
keyAgreement.init(myPrivKey);➋
keyAgreement.doPhase(remotePubKey, true);➌
byte[] secret = keyAgreement.generateSecret();➍</pre></div></div><p>A <code class="literal">KeyAgreement</code> instance is first created by passing the algorithm name, <span class="emphasis"><em>ECDH</em></span>, to the <code class="literal">getInstance()</code> factory method ➊. Then the agreement <a id="iddle1489" class="indexterm"/><a id="iddle1666" class="indexterm"/><a id="iddle1849" class="indexterm"/><a id="iddle2027" class="indexterm"/><a id="iddle2057" class="indexterm"/><a id="iddle2081" class="indexterm"/><a id="iddle2120" class="indexterm"/><a id="iddle2513" class="indexterm"/><a id="iddle2676" class="indexterm"/><a id="iddle2932" class="indexterm"/>is initialized by passing the local private key to the <code class="literal">init()</code> method ➋. Next, the <code class="literal">doPhase()</code> method is called <span class="emphasis"><em>N</em></span> – 1 times, where <span class="emphasis"><em>N</em></span> is the number of communicating parties, passing each party’s public key as the first parameter, and setting the second parameter to <code class="literal">true</code> when executing the last phase of the agreement ➌. (For two communicating parties, as in this example, the <code class="literal">doPhase()</code> method needs to be called only once.) Finally, calling the <code class="literal">generateSecret()</code> method ➍ produces the shared secret.</p><p><a class="xref" href="ch05.html#using_keyagreement_to_generate_a_shared" title="Example 5-17. Using KeyAgreement to generate a shared secret">Example 5-17</a> shows the call flow for only one of the parties (<span class="emphasis"><em>A</em></span>), but the other party (<span class="emphasis"><em>B</em></span>) needs to execute the same sequence using its own private key to initialize the agreement, and passing <span class="emphasis"><em>A</em></span>’s public key to <code class="literal">doPhase()</code>.</p><p>Note that while the value (or part of it) returned by <code class="literal">generateSecret()</code> can be used directly as a symmetric key, the preferred method is to use it as the input for a <span class="emphasis"><em>key-derivation function (KDF)</em></span> and use the output of the KDF as key(s). Directly using the generated shared secret may lead to some loss of entropy, and doing so limits the number of keys that can be produced using a single DH key agreement operation. On the other hand, using a KDF diffuses any structure that the secret may have (such as padding) and allows for generating multiple derived keys by mixing in a salt.</p><p><code class="literal">KeyAgreement</code> has another <code class="literal">generateSecret()</code> method which takes an algorithm name as a parameter and returns a <code class="literal">SecretKey</code> instance that can be used to initialize a <code class="literal">Cipher</code> directly. If the <code class="literal">KeyAgreement</code> instance has been created with an algorithm string that includes a KDF specification (for example, <span class="emphasis"><em>ECDHwithSHA1KDF</em></span>), this method will apply the KDF to the shared secret before returning a <code class="literal">SecretKey</code>. If a KDF has not been specified, most implementations simply truncate the shared secret in order to obtain key material for the returned <code class="literal">SecretKey</code>.</p></div><div class="sect2" title="KeyStore"><div class="titlepage"><div><div><h2 class="title"><a id="keystore"/>KeyStore</h2></div></div></div><p>JCA uses the term <span class="emphasis"><em>keystore</em></span> to refer to a database of keys and certificates. A keystore manages multiple cryptographic objects, referred to as <span class="emphasis"><em>entries</em></span> that are each associated with a string <span class="emphasis"><em>alias.</em></span> The <code class="literal">KeyStore</code> class offers a well-defined interface to a keystore that defines three types of entries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="PrivateKeyEntry"><span class="title"><strong><span class="strong"><strong><code class="literal">PrivateKeyEntry</code></strong></span></strong></span>. A private key with an associated certificate chain. For a software implementation, the private key material is usually encrypted and protected by a user-supplied passphrase.</p></li><li class="listitem"><p title="SecretKeyEntry"><span class="title"><strong><span class="strong"><strong><code class="literal">SecretKeyEntry</code></strong></span></strong></span>. A secret (symmetric) key. Not all <code class="literal">KeyStore</code> implementations support storing secret keys.</p></li><li class="listitem"><p title="TrustedCertificateEntry"><span class="title"><strong><span class="strong"><strong><code class="literal">TrustedCertificateEntry</code></strong></span></strong></span>. A public key certificate of another party. <code class="literal">TrustedCertificateEntry</code>s often contain CA certificates that can be used to establish trust relationships. A keystore that contains only <code class="literal">TrustedCertificateEntry</code>s is called a <span class="emphasis"><em>truststore</em></span>.</p></li></ul></div><div class="sect3" title="KeyStore Types"><div class="titlepage"><div><div><h3 class="title"><a id="keystore_types"/>KeyStore Types</h3></div></div></div><p>A <code class="literal">KeyStore</code> implementation does not need to be persistent, but most implementations are. Different implementations are identified by a <span class="emphasis"><em>keystore type</em></span> <a id="iddle1278" class="indexterm"/><a id="iddle1297" class="indexterm"/><a id="iddle2474" class="indexterm"/>that defines the storage and data format of the keystore, as well as the methods used to protect stored keys. The default <code class="literal">KeyStore</code> type is set with the <code class="literal">keystore.type</code> system property.</p><p>The default <code class="literal">KeyStore</code> implementation of most JCA providers is usually a keystore type that stores its data in a file. The file format may be proprietary or based on a public standard. Proprietary formats include the original Java SE <span class="emphasis"><em>JKS</em></span> format and its security enhanced version <span class="emphasis"><em>JCEKS</em></span>, as well as the <span class="emphasis"><em>Bouncy Castle KeyStore (BKS)</em></span> format, which is the default in Android.</p></div><div class="sect3" title="PKCS#12 File-Backed KeyStores"><div class="titlepage"><div><div><h3 class="title"><a id="pkcshash12_file-backed_keystores"/>PKCS#12 File-Backed KeyStores</h3></div></div></div><p>The most widely used public standard that allows for bundling private keys and associated certificates in a file is the <span class="emphasis"><em>Personal Information Exchange Syntax Standard</em></span>, commonly referred to as <span class="emphasis"><em>PKCS#12</em></span>. It is a successor of the <span class="emphasis"><em>Personal Information Exchange Syntax (PFX)</em></span> standard, so the terms PKCS#12 and PFX are used somewhat interchangeably, and PKCS#12 files are often called PFX files.</p><p>PKCS#12 is a container format that can contain multiple embedded objects, such as private keys, certificates, and even CRLs. Like the previous PKCS standards, which PKCS#12 builds upon, the container contents are defined in <span class="emphasis"><em>ASN.1</em></span><sup>[<a id="ch05fn13" href="#ftn.ch05fn13" class="footnote">50</a>]</sup> and are essentially a sequence of nested structures. The internal container structures are called <code class="literal">SafeBags</code>, with different bags defined for certificates (<code class="literal">CertBag</code>), private keys (<code class="literal">KeyBag</code>), and encrypted private keys (<code class="literal">PKCS8ShroudedKeyBag</code>). The integrity of the whole file is protected by a MAC that uses a key derived from an <span class="emphasis"><em>integrity password</em></span>, and each individual private key entry is encrypted with a key derived from a <span class="emphasis"><em>privacy password</em></span>. In practice, the two passwords are usually the same. PKCS#12 can also use public keys to protect the privacy and integrity of the archive contents, but this usage is not very common.</p><p>A typical PKCS#12 file that contains a user’s encrypted password key and an associated certificate might have structure like that illustrated in Figure 5-3 (note that some of the wrapper structures have been removed for clarity).</p><div class="figure"><a id="structure_of_a_pkcshash12_file_holding_a"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00015"/><img src="figs/web/05fig03.png" alt="Structure of a PKCS#12 file holding a private key and an associated certificate"/></div></div><p class="title">Figure 5-3. Structure of a PKCS#12 file holding a private key and an associated certificate</p></div><p><a id="iddle1129" class="indexterm"/><a id="iddle1335" class="indexterm"/><a id="iddle1355" class="indexterm"/><a id="iddle1477" class="indexterm"/><a id="iddle1479" class="indexterm"/><a id="iddle1534" class="indexterm"/><a id="iddle1919" class="indexterm"/><a id="iddle1935" class="indexterm"/><a id="iddle2011" class="indexterm"/><a id="iddle2012" class="indexterm"/><a id="iddle2875" class="indexterm"/><a id="iddle3146" class="indexterm"/><a class="xref" href="ch05.html#using_the_keystore_class_to_extract_a_pr" title="Example 5-18. Using the KeyStore class to extract a private key and certificate from a PKCS#12 file">Example 5-18</a> shows how to obtain a private key and certificate from a PKCS#12 file.</p><div class="example"><a id="using_the_keystore_class_to_extract_a_pr"/><p class="title">Example 5-18. Using the <code class="literal">KeyStore</code> class to extract a private key and certificate from a PKCS#12 file</p><div class="example-contents"><pre class="programlisting">KeyStore keyStore = KeyStore.getInstance("PKCS12");➊
InputStream in = new FileInputStream("mykey.pfx");
keyStore.load(in, "password".toCharArray());➋
KeyStore.PrivateKeyEntry keyEntry =
      (KeyStore.PrivateKeyEntry)keyStore.getEntry("mykey", null);➌
X509Certificate cert = (X509Certificate) keyEntry.getCertificate();➍
RSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();➎</pre></div></div><p>The <code class="literal">KeyStore</code> class can be used to access the contents of a PKCS#12 file by specifying <span class="emphasis"><em>PKCS12</em></span> as the keystore type when creating an instance (➊ in <a class="xref" href="ch05.html#using_the_keystore_class_to_extract_a_pr" title="Example 5-18. Using the KeyStore class to extract a private key and certificate from a PKCS#12 file">Example 5-18</a>). To load and parse the PKCS#12 file, we call the <code class="literal">load()</code> method ➋, passing an <code class="literal">InputStream</code> from which to read the file, and the file integrity password. Once the file is loaded, we can obtain a private key entry by calling the <code class="literal">getEntry()</code> method and passing the key alias ➌ and, optionally, a <code class="literal">KeyStore.PasswordProtection</code> instance initialized with the password for the requested entry, if it’s different from the file integrity password. If the alias is unknown, all aliases can be listed with the <code class="literal">aliases()</code> method. Once we have a <code class="literal">PrivateKeyEntry</code>, we can access the public key certificate ➍ or the private key ➎. New entries can be added with the <code class="literal">setEntry()</code> method and deleted with the <code class="literal">deleteEntry()</code> method. Changes to the <code class="literal">KeyStore</code> contents can be persisted to disk by calling the <code class="literal">store()</code> method, which accepts an <code class="literal">OutputStream</code> (to which the keystore bytes are written) and an integrity password (which is used to derive MAC and encryption keys) as parameters.</p><p>A <code class="literal">KeyStore</code> implementation does not have to use a single file for storing key and certificate objects. It can use multiple files, a database, or any other storage mechanism. In fact, keys may not be stored on the host system at all, but on a separate hardware device such as a smart card or a <span class="emphasis"><em>hardware security module (HSM)</em></span>. (Android-specific <code class="literal">KeyStore</code> implementations that provide an interface to the system’s trust store and credential storage are introduced in <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a> and <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>.)</p></div></div><div class="sect2" title="CertificateFactory and CertPath"><div class="titlepage"><div><div><h2 class="title"><a id="certificatefactory_and_certpath"/>CertificateFactory and CertPath</h2></div></div></div><p><code class="literal">CertificateFactory</code> acts as a certificate and CRL parser and can build certificate chains from a list of certificates. It can read a stream that contains encoded certificates or CRLs and output a collection (or a single instance) of <code class="literal">java.security.cert.Certificate</code> and <code class="literal">java.security.cert.CRL</code> objects. Usually, only an <span class="emphasis"><em>X.509</em></span> implementation that parses X.509 certificates and CRLs is available.</p><p><a class="xref" href="ch05.html#parsing_an_xdot509_certificate_file_with" title="Example 5-19. Parsing an X.509 certificate file with CertificateFactory">Example 5-19</a> shows how to parse a certificate file using <code class="literal">CertificateFactory</code>.</p><div class="example"><a id="parsing_an_xdot509_certificate_file_with"/><p class="title">Example 5-19. Parsing an X.509 certificate file with <code class="literal">CertificateFactory</code></p><div class="example-contents"><pre class="programlisting">CertificateFactory cf = CertificateFactory.getInstance("X.509");➊
InputStream in = new FileInputStream("certificate.cer");
X509Certificate cert = (X509Certificate) cf.generateCertificate(in);➋</pre></div></div><p><a id="iddle1353" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1478" class="indexterm"/><a id="iddle1480" class="indexterm"/><a id="iddle1843" class="indexterm"/><a id="iddle1844" class="indexterm"/><a id="iddle2013" class="indexterm"/><a id="iddle3054" class="indexterm"/>To create a <code class="literal">CertificateFactory</code>, we pass <span class="emphasis"><em>X.509</em></span> as the factory type to <code class="literal">getInstance()</code> ➊, and then call <code class="literal">generateCertificate()</code>, passing an <code class="literal">InputStream</code> from which to read ➋. Because this is an <span class="emphasis"><em>X.509</em></span> factory, the obtained object can be safely cast to <code class="literal">java.security.cert.X509Certificate</code>. If the read file includes multiple certificates that form a certificate chain, a <code class="literal">CertPath</code> object can be obtained by calling the <code class="literal">generateCertPath()</code> method.</p></div><div class="sect2" title="CertPathValidator and CertPathBuilder"><div class="titlepage"><div><div><h2 class="title"><a id="certpathvalidator_and_certpathbuilder"/>CertPathValidator and CertPathBuilder</h2></div></div></div><p>The <code class="literal">CertPathValidator</code> class encapsulates a certificate chain validation algorithm as defined by the <span class="emphasis"><em>Public-Key Infrastructure (X.509)</em></span> or <span class="emphasis"><em>PKIX</em></span> standard.<sup>[<a id="ch05fn14" href="#ftn.ch05fn14" class="footnote">51</a>]</sup> We discuss PKIX and certificate chain validation in more detail in <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>, but <a class="xref" href="ch05.html#building_and_validating_a_certificate_ch" title="Example 5-20. Building and validating a certificate chain with CertPathValidator">Example 5-20</a> shows how to use <code class="literal">CertificateFactory</code> and <code class="literal">CertPathValidator</code> to build and validate a certificate chain.</p><div class="example"><a id="building_and_validating_a_certificate_ch"/><p class="title">Example 5-20. Building and validating a certificate chain with <code class="literal">CertPathValidator</code></p><div class="example-contents"><pre class="programlisting">CertPathValidator certPathValidator = CertPathValidator.getInstance("PKIX");➊
CertificateFactory cf = CertificateFactory.getInstance("X.509");

X509Certificate[] chain = getCertChain();
CertPath certPath = cf.generateCertPath(Arrays.asList(chain));➋
Set&lt;TrustAnchor&gt; trustAnchors = getTrustAnchors();
PKIXParameters result = new PKIXParameters(trustAnchors);➌
PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult)
             certPathValidator.validate(certPath, pkixParams);➍</pre></div></div><p>As you can see, we first obtain a <code class="literal">CertPathValidator</code> instance by passing <span class="emphasis"><em>PKIX</em></span> to the <code class="literal">getInstance()</code> method ➊. We then build a certificate chain using <code class="literal">CertificateFactory</code>’s <code class="literal">generateCertPath()</code> method ➋. Note that if the passed list of certificates does not form a valid chain, this method throws a <code class="literal">CertificateException</code>. If we do not already have all the certificates needed to form a chain, we can use a <code class="literal">CertPathBuilder</code> initialized with a <code class="literal">CertStore</code> to find the needed certificates and build a <code class="literal">CertPath</code> (not shown).</p><p>Once we have a <code class="literal">CertPath</code>, we initialize the <code class="literal">PKIXParameters</code> class with a set of <span class="emphasis"><em>trust anchors</em></span> (typically, these are trusted CA certificates; see <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a> for details) ➌, and then call <code class="literal">CertPathValidator.validate()</code> ➍, passing the <code class="literal">CertPath</code> that we built in ➋ and the <code class="literal">PKIXParameters</code> instance. If validation succeeds, <code class="literal">validate()</code> returns a <code class="literal">PKIXCertPathValidatorResult</code> instance; if not, it throws a <code class="literal">CertPathValidatorException</code> that contains detailed information about why it failed.</p></div></div><div class="sect1" title="Android JCA Providers"><div class="titlepage"><div><div><h1 class="title"><a id="android_jca_providers"/>Android JCA Providers</h1></div></div></div><p><a id="iddle1299" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1466" class="indexterm"/><a id="iddle1468" class="indexterm"/><a id="iddle1501" class="indexterm"/><a id="iddle1613" class="indexterm"/><a id="iddle1668" class="indexterm"/><a id="iddle2049" class="indexterm"/><a id="iddle2087" class="indexterm"/><a id="iddle2204" class="indexterm"/><a id="iddle2533" class="indexterm"/><a id="iddle2534" class="indexterm"/><a id="iddle2537" class="indexterm"/><a id="iddle2697" class="indexterm"/><a id="iddle2797" class="indexterm"/><a id="iddle2801" class="indexterm"/><a id="iddle2803" class="indexterm"/><a id="iddle2825" class="indexterm"/>Android’s cryptography providers are based on JCA and follow its architecture with some relatively minor exceptions. While low-level Android components directly use native cryptography libraries (such as OpenSSL), JCA is the main cryptographic API and is used by system components and third-party applications alike.</p><p>Android has three core JCA providers that include implementations of the engine classes outlined in the previous section and two <span class="emphasis"><em>Java Secure Socket Extension (JSSE)</em></span> providers that implement SSL functionality. (JSSE is discussed in detail in <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>.)</p><p>Let’s examine Android’s core JCA providers.</p><div class="sect2" title="Harmony’s Crypto Provider"><div class="titlepage"><div><div><h2 class="title"><a id="harmonyapostrophes_crypto_provider"/>Harmony’s Crypto Provider</h2></div></div></div><p>Android’s Java runtime library implementation is derived from the retired Apache Harmony project,<sup>[<a id="ch05fn15" href="#ftn.ch05fn15" class="footnote">52</a>]</sup> which also includes a limited JCA provider simply named <span class="emphasis"><em>Crypto</em></span> that provides implementations for basic cryptographic services like random number generation, hashing, and digital signatures. Crypto is still included in Android for backward compatibility but has the lowest priority of all JCA providers, so engine class implementations from Crypto are not returned unless explicitly requested. <a class="xref" href="ch05.html#algorithms_supported_by_the_crypto_provi" title="Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4">Table 5-1</a> shows the engine classes and algorithms that Crypto supports.</p><div class="table"><a id="algorithms_supported_by_the_crypto_provi"/><p class="title">Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4</p><div class="table-contents"><table summary="Algorithms Supported by the Crypto Provider as of Android 4.4.4" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Engine Class Name</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Supported Algorithms</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">MessageDigest</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>SHA-1</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">SecureRandom</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>SHA1PRNG</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">Signature</code></p></td><td style="" valign="top"><p><span class="emphasis"><em>SHA1withDSA</em></span></p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="ch05note05"/>Note</h3><p><span class="emphasis"><em>While the algorithms listed in <a class="xref" href="ch05.html#algorithms_supported_by_the_crypto_provi" title="Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4">Table 5-1</a> are still available in Android 4.4, all except</em></span> SHA1PRNG <span class="emphasis"><em>have been removed in the Android master branch and may not be available in future versions.</em></span></p></div></div><div class="sect2" title="Android’s Bouncy Castle Provider"><div class="titlepage"><div><div><h2 class="title"><a id="androidapostrophes_bouncy_castle_provide"/>Android’s Bouncy Castle Provider</h2></div></div></div><p>Before Android version 4.0, the only full-featured JCA provider in Android was the Bouncy Castle provider. The Bouncy Castle provider is part of the Bouncy Castle Crypto APIs,<sup>[<a id="ch05fn16" href="#ftn.ch05fn16" class="footnote">53</a>]</sup> a set of open source Java implementations of cryptographic algorithms and protocols.</p><p><a id="iddle1114" class="indexterm"/><a id="iddle1195" class="indexterm"/><a id="iddle1284" class="indexterm"/><a id="iddle1336" class="indexterm"/><a id="iddle1354" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1361" class="indexterm"/><a id="iddle1382" class="indexterm"/><a id="iddle1539" class="indexterm"/><a id="iddle2492" class="indexterm"/><a id="iddle2557" class="indexterm"/><a id="iddle2588" class="indexterm"/><a id="iddle2618" class="indexterm"/><a id="iddle3143" class="indexterm"/><a id="iddle3147" class="indexterm"/>Android includes a modified version of the Bouncy Castle provider, which is derived from the mainstream version by applying a set of Android-specific patches. Those patches are maintained in the Android source tree and updated for each new release of the mainstream Bouncy Castle provider. The main differences from the mainstream version are summarized below.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Algorithms, modes, and algorithm parameters not supported by Java’s reference implementation (RI) have been removed (RIPEMD, SHA-224, GOST3411, Twofish, CMAC, El Gamal, RSA-PSS, ECMQV, and so on).</p></li><li class="listitem"><p>Insecure algorithms such as MD2 and RC2 have been removed.</p></li><li class="listitem"><p>Java-based implementations of MD5 and the SHA family of digest algorithms have been replaced with a native implementation.</p></li><li class="listitem"><p>Some PBE algorithms have been removed (for example, <span class="emphasis"><em>PBEwithHmacSHA256</em></span>).</p></li><li class="listitem"><p>Support for accessing certificates stored in LDAP has been removed.</p></li><li class="listitem"><p>Support for certificate blacklists has been added (blacklists are discussed in <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>).</p></li><li class="listitem"><p>Various performance optimizations have been made.</p></li><li class="listitem"><p>The package name has been changed to <code class="literal">com.android.org.bouncycastle</code> to avoid conflict with apps that bundle in Bouncy Castle (since Android 3.0).</p></li></ul></div><p>The engine classes and algorithms supported by Android’s Bouncy Castle provider as of version 4.4.4 (based on Bouncy Castle 1.49) are listed in <a class="xref" href="ch05.html#algorithms_supported_by_androidapostroph" title="Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android 4.4.4">Table 5-2</a>.</p><div class="table"><a id="algorithms_supported_by_androidapostroph"/><p class="title">Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android 4.4.4</p><div class="table-contents"><table summary="Algorithms Supported by Android’s Bouncy Castle Provider as of Android 4.4.4" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Engine Class Name</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Supported Algorithms</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CertPathBuilder</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>PKIX</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CertPathValidator</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>PKIX</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CertStore</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>Collection</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CertificateFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>X.509</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Cipher</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>AES</em></span></p>
<p><span class="emphasis"><em>AESWRAP</em></span></p>
<p><span class="emphasis"><em>ARC4</em></span></p>
<p><span class="emphasis"><em>BLOWFISH</em></span></p>
<p><span class="emphasis"><em>DES</em></span></p>
<p><span class="emphasis"><em>DESEDE</em></span></p>
<p><span class="emphasis"><em>DESEDEWRAP</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND128BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND192BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND256BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5ANDDES</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5ANDRC2</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA1ANDDES</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA1ANDRC2</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND128BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND192BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND256BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITRC2-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITRC4</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND192BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND2-KEYTRIPLEDES-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND256BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND3-KEYTRIPLEDES-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND40BITRC2-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND40BITRC4</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAANDTWOFISH-CBC</em></span></p>
<p><span class="emphasis"><em>RSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1115" class="indexterm"/><a id="iddle1196" class="indexterm"/><a id="iddle1279" class="indexterm"/><a id="iddle1285" class="indexterm"/><a id="iddle1298" class="indexterm"/><a id="iddle1540" class="indexterm"/><a id="iddle1610" class="indexterm"/><a id="iddle1614" class="indexterm"/><a id="iddle1669" class="indexterm"/><a id="iddle2064" class="indexterm"/><a id="iddle2088" class="indexterm"/><a id="iddle2091" class="indexterm"/><a id="iddle2112" class="indexterm"/><a id="iddle2121" class="indexterm"/><a id="iddle2170" class="indexterm"/><a id="iddle2205" class="indexterm"/><a id="iddle2558" class="indexterm"/><a id="iddle2637" class="indexterm"/><a id="iddle2798" class="indexterm"/><a id="iddle2807" class="indexterm"/><code class="literal">KeyAgreement</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DH</em></span></p>
<p><span class="emphasis"><em>ECDH</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DH</em></span></p>
<p><span class="emphasis"><em>DSA</em></span></p>
<p><span class="emphasis"><em>EC</em></span></p>
<p><span class="emphasis"><em>RSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyGenerator</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>AES</em></span></p>
<p><span class="emphasis"><em>ARC4</em></span></p>
<p><span class="emphasis"><em>BLOWFISH</em></span></p>
<p><span class="emphasis"><em>DES</em></span></p>
<p><span class="emphasis"><em>DESEDE</em></span></p>
<p><span class="emphasis"><em>HMACMD5</em></span></p>
<p><span class="emphasis"><em>HMACSHA1</em></span></p>
<p><span class="emphasis"><em>HMACSHA256</em></span></p>
<p><span class="emphasis"><em>HMACSHA384</em></span></p>
<p><span class="emphasis"><em>HMACSHA512</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyPairGenerator</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DH</em></span></p>
<p><span class="emphasis"><em>DSA</em></span></p>
<p><span class="emphasis"><em>EC</em></span></p>
<p><span class="emphasis"><em>RSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyStore</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>BKS</em></span> (default)</p>
<p><span class="emphasis"><em>BouncyCastle</em></span></p>
<p><span class="emphasis"><em>PKCS12</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Mac</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>HMACMD5</em></span></p>
<p><span class="emphasis"><em>HMACSHA1</em></span></p>
<p><span class="emphasis"><em>HMACSHA256</em></span></p>
<p><span class="emphasis"><em>HMACSHA384</em></span></p>
<p><span class="emphasis"><em>HMACSHA512</em></span></p>
<p><span class="emphasis"><em>PBEWITHHMACSHA</em></span></p>
<p><span class="emphasis"><em>PBEWITHHMACSHA1</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">MessageDigest</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>MD5</em></span></p>
<p><span class="emphasis"><em>SHA-1</em></span></p>
<p><span class="emphasis"><em>SHA-256</em></span></p>
<p><span class="emphasis"><em>SHA-384</em></span></p>
<p><span class="emphasis"><em>SHA-512</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1149" class="indexterm"/><a id="iddle1464" class="indexterm"/><a id="iddle1541" class="indexterm"/><a id="iddle2532" class="indexterm"/><a id="iddle2678" class="indexterm"/><a id="iddle2826" class="indexterm"/><code class="literal">SecretKeyFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DES</em></span></p>
<p><span class="emphasis"><em>DESEDE</em></span></p>
<p><span class="emphasis"><em>PBEWITHHMACSHA1</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND128BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND192BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5AND256BITAES-CBC-OPENSSL</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5ANDDES</em></span></p>
<p><span class="emphasis"><em>PBEWITHMD5ANDRC2</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA1ANDDES</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA1ANDRC2</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND128BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND192BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHA256AND256BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITRC2-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND128BITRC4</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND192BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND2-KEYTRIPLEDES-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND256BITAES-CBC-BC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND3-KEYTRIPLEDES-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND40BITRC2-CBC</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAAND40BITRC4</em></span></p>
<p><span class="emphasis"><em>PBEWITHSHAANDTWOFISH-CBC</em></span></p>
<p><span class="emphasis"><em>PBKDF2WithHmacSHA1</em></span></p>
<p><span class="emphasis"><em>PBKDF2WithHmacSHA1And8BIT</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">Signature</code></p></td><td style="" valign="top"><p><span class="emphasis"><em>ECDSA</em></span></p>
<p><span class="emphasis"><em>MD5WITHRSA</em></span></p>
<p><span class="emphasis"><em>NONEWITHDSA</em></span></p>
<p><span class="emphasis"><em>NONEwithECDSA</em></span></p>
<p><span class="emphasis"><em>SHA1WITHRSA</em></span></p>
<p><span class="emphasis"><em>SHA1withDSA</em></span></p>
<p><span class="emphasis"><em>SHA256WITHECDSA</em></span></p>
<p><span class="emphasis"><em>SHA256WITHRSA</em></span></p>
<p><span class="emphasis"><em>SHA384WITHECDSA</em></span></p>
<p><span class="emphasis"><em>SHA384WITHRSA</em></span></p>
<p><span class="emphasis"><em>SHA512WITHECDSA</em></span></p>
<p><span class="emphasis"><em>SHA512WITHRSA</em></span></p></td></tr></tbody></table></div></div></div><div class="sect2" title="AndroidOpenSSL Provider"><div class="titlepage"><div><div><h2 class="title"><a id="androidopenssl_provider"/>AndroidOpenSSL Provider</h2></div></div></div><p>As mentioned in <a class="xref" href="ch05.html#androidapostrophes_bouncy_castle_provide" title="Android’s Bouncy Castle Provider">Android’s Bouncy Castle Provider</a>, hash algorithms in Android’s Bouncy Castle provider have been replaced with native code for performance reasons. In order to further improve cryptographic performance, the number of supported engine classes and algorithms in the native AndroidOpenSSL provider has been steadily growing with each release since 4.0.</p><p>Originally, AndroidOpenSSL was only used to implement SSL sockets, but as of Android 4.4, it covers most of the functionality offered by Bouncy Castle. Because it is the preferred provider (with the highest priority, 1), engine classes that don’t explicitly request Bouncy Castle get an implementation from the AndroidOpenSSL provider. As the name implies, its cryptographic functionality is provided by the OpenSSL library. The provider <a id="iddle1116" class="indexterm"/><a id="iddle1197" class="indexterm"/><a id="iddle1383" class="indexterm"/><a id="iddle1416" class="indexterm"/><a id="iddle1615" class="indexterm"/><a id="iddle1670" class="indexterm"/><a id="iddle2065" class="indexterm"/><a id="iddle2089" class="indexterm"/><a id="iddle2113" class="indexterm"/><a id="iddle2171" class="indexterm"/><a id="iddle2206" class="indexterm"/><a id="iddle2559" class="indexterm"/><a id="iddle2638" class="indexterm"/><a id="iddle2799" class="indexterm"/><a id="iddle2808" class="indexterm"/><a id="iddle3148" class="indexterm"/>implementation uses JNI to link OpenSSL’s native code to the Java SPI classes required to implement a JCA provider. The bulk of the implementation is in the <code class="literal">NativeCrypto</code> Java class, which is called by most SPI classes.</p><p>AndroidOpenSSL is part of Android’s <span class="emphasis"><em>libcore</em></span> library, which implements the core part of Android’s Java runtime library. Starting with Android 4.4, AndroidOpenSSL has been decoupled from <span class="emphasis"><em>libcore</em></span> so that it can be compiled as a standalone library and included in applications that want a stable cryptographic implementation that does not depend on the platform version. The standalone provider is called <span class="emphasis"><em>Conscrypt</em></span> and lives in the <code class="literal">org.conscrypt</code> package, renamed to <code class="literal">com.android.org.conscrypt</code> when built as part of the Android platform.</p><p>The engine classes and algorithms supported by the AndroidOpenSSL provider as of version 4.4.4 are listed in <a class="xref" href="ch05.html#algorithms_supported_by_the_androidopens" title="Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android 4.4.4">Table 5-3</a>.</p><div class="table"><a id="algorithms_supported_by_the_androidopens"/><p class="title">Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android 4.4.4</p><div class="table-contents"><table summary="Algorithms Supported by the AndroidOpenSSL Provider as of Android 4.4.4" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Engine Class Name</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Supported Algorithms</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CertificateFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>X509</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Cipher</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>AES/CBC/NoPadding</em></span></p>
<p><span class="emphasis"><em>AES/CBC/PKCS5Padding</em></span></p>
<p><span class="emphasis"><em>AES/CFB/NoPadding</em></span></p>
<p><span class="emphasis"><em>AES/CTR/NoPadding</em></span></p>
<p><span class="emphasis"><em>AES/ECB/NoPadding</em></span></p>
<p><span class="emphasis"><em>AES/ECB/PKCS5Padding</em></span></p>
<p><span class="emphasis"><em>AES/OFB/NoPadding</em></span></p>
<p><span class="emphasis"><em>ARC4</em></span></p>
<p><span class="emphasis"><em>DESEDE/CBC/NoPadding</em></span></p>
<p><span class="emphasis"><em>DESEDE/CBC/PKCS5Padding</em></span></p>
<p><span class="emphasis"><em>DESEDE/CFB/NoPadding</em></span></p>
<p><span class="emphasis"><em>DESEDE/ECB/NoPadding</em></span></p>
<p><span class="emphasis"><em>DESEDE/ECB/PKCS5Padding</em></span></p>
<p><span class="emphasis"><em>DESEDE/OFB/NoPadding</em></span></p>
<p><span class="emphasis"><em>RSA/ECB/NoPadding</em></span></p>
<p><span class="emphasis"><em>RSA/ECB/PKCS1Padding</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyAgreement</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>ECDH</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyFactory</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DSA</em></span></p>
<p><span class="emphasis"><em>EC</em></span></p>
<p><span class="emphasis"><em>RSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">KeyPairGenerator</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>DSA</em></span></p>
<p><span class="emphasis"><em>EC</em></span></p>
<p><span class="emphasis"><em>RSA</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Mac</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>HmacMD5</em></span></p>
<p><span class="emphasis"><em>HmacSHA1</em></span></p>
<p><span class="emphasis"><em>HmacSHA256</em></span></p>
<p><span class="emphasis"><em>HmacSHA384</em></span></p>
<p><span class="emphasis"><em>HmacSHA512</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">MessageDigest</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>MD5</em></span></p>
<p><span class="emphasis"><em>SHA-1</em></span></p>
<p><span class="emphasis"><em>SHA-256</em></span></p>
<p><span class="emphasis"><em>SHA-384</em></span></p>
<p><span class="emphasis"><em>SHA-512</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1467" class="indexterm"/><a id="iddle1470" class="indexterm"/><a id="iddle2353" class="indexterm"/><a id="iddle2535" class="indexterm"/><a id="iddle2536" class="indexterm"/><a id="iddle2698" class="indexterm"/><a id="iddle2802" class="indexterm"/><a id="iddle2827" class="indexterm"/><code class="literal">SecureRandom</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>SHA1PRNG</em></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">Signature</code></p></td><td style="" valign="top"><p><span class="emphasis"><em>ECDSA</em></span></p>
<p><span class="emphasis"><em>MD5WithRSA</em></span></p>
<p><span class="emphasis"><em>NONEwithRSA</em></span></p>
<p><span class="emphasis"><em>SHA1WithRSA</em></span></p>
<p><span class="emphasis"><em>SHA1withDSA</em></span></p>
<p><span class="emphasis"><em>SHA256WithRSA</em></span></p>
<p><span class="emphasis"><em>SHA256withECDSA</em></span></p>
<p><span class="emphasis"><em>SHA384WithRSA</em></span></p>
<p><span class="emphasis"><em>SHA384withECDSA</em></span></p>
<p><span class="emphasis"><em>SHA512WithRSA</em></span></p>
<p><span class="emphasis"><em>SHA512withECDSA</em></span></p></td></tr></tbody></table></div></div></div><div class="sect2" title="OpenSSL"><div class="titlepage"><div><div><h2 class="title"><a id="openssl"/>OpenSSL</h2></div></div></div><p>OpenSSL is an open source cryptographic toolkit that implements the SSL and TLS protocols and is widely used as a general purpose cryptography library.<sup>[<a id="ch05fn17" href="#ftn.ch05fn17" class="footnote">54</a>]</sup> It is included in Android as a system library and used to implement the AndroidOpenSSL JCA provider that was introduced in “<a class="xref" href="ch05.html#androidopenssl_provider" title="AndroidOpenSSL Provider">AndroidOpenSSL Provider</a>”, as well as by some other system components.</p><p>Different Android releases use different OpenSSL versions (generally the latest stable version, which is 1.0.1e in Android 4.4), with an evolving set of patches applied. Therefore, Android does not offer a stable public OpenSSL API, so applications that need to use OpenSSL should include the library and not link to the system version. The only public cryptographic API is the JCA one, which offers a stable interface decoupled from the underlying implementation.</p></div></div><div class="sect1" title="Using a Custom Provider"><div class="titlepage"><div><div><h1 class="title"><a id="using_a_custom_provider"/>Using a Custom Provider</h1></div></div></div><p>While Android’s built-in providers cover most widely used cryptographic primitives, they do not support some more exotic algorithms and even some newer standards. As mentioned in our discussion of the JCA architecture, Android applications can register custom providers for their own use, but cannot affect system-wide providers.</p><p><a id="iddle1107" class="indexterm"/><a id="iddle1469" class="indexterm"/><a id="iddle1957" class="indexterm"/><a id="iddle2538" class="indexterm"/><a id="iddle2854" class="indexterm"/><a id="iddle3149" class="indexterm"/>One of the most widely used and full-featured JCA providers is Bouncy Castle, also the base of one of Android’s built-in providers. However, as discussed in <a class="xref" href="ch05.html#androidapostrophes_bouncy_castle_provide" title="Android’s Bouncy Castle Provider">Android’s Bouncy Castle Provider</a>, the version shipped with Android has had a number of algorithms removed. If you need to use any of those algorithms, you can try simply bundling the full Bouncy Castle library with your application—but that may cause class loading conflicts, especially on versions of Android earlier than 3.0, which do not change the system’s Bouncy Castle’s package name. To avoid this, you can change the library’s root package with a tool such as jarjar,<sup>[<a id="ch05fn18" href="#ftn.ch05fn18" class="footnote">55</a>]</sup> or use Spongy Castle.<sup>[<a id="ch05fn19" href="#ftn.ch05fn19" class="footnote">56</a>]</sup></p><div class="sect2" title="Spongy Castle"><div class="titlepage"><div><div><h2 class="title"><a id="spongy_castle"/>Spongy Castle</h2></div></div></div><p>Spongy Castle is a repackaged version of Bouncy Castle. It moves all package names from <code class="literal">org.bouncycastle.*</code> to <code class="literal">org.spongycastle.*</code> in order to avoid class loader conflicts, and changes the provider name from <span class="emphasis"><em>BC</em></span> to <span class="emphasis"><em>SC</em></span>. No class names are changed, so the API is the same as Bouncy Castle. To use Spongy Castle, you simply need to register it with the JCA framework using <code class="literal">Security.addProvider()</code> or <code class="literal">Security.insertProviderAt()</code>. You can then request algorithms not implemented by Android’s built-in providers simply by passing the algorithm name to the respective <code class="literal">getInstance()</code> method.</p><p>To explicitly request an implementation from Spongy Castle, pass the <span class="emphasis"><em>SC</em></span> string as the provider name. If you bundle the Spongy Castle library with your app, you can also directly use Bouncy Castle’s lightweight cryptographic API (which is often more flexible) without going through the JCA engine classes. Additionally, some cryptographic operations, such as signing an X.509 certificate or creating an S/MIME message, have no matching JCA APIs and can only be performed using the lower-level Bouncy Castle APIs.</p><p><a class="xref" href="ch05.html#registering_and_using_the_spongy_castle" title="Example 5-21. Registering and using the Spongy Castle provider">Example 5-21</a> shows how to register the Spongy Castle provider and request an RSA-PSS (originally defined in PKCS#1<sup>[<a id="ch05fn20" href="#ftn.ch05fn20" class="footnote">57</a>]</sup>) <code class="literal">Signature</code> implementation, which is not supported by any of Android’s built-in JCA providers.</p><div class="example"><a id="registering_and_using_the_spongy_castle"/><p class="title">Example 5-21. Registering and using the Spongy Castle provider</p><div class="example-contents"><pre class="programlisting">static {
    Security.insertProviderAt(
        new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}
Signature sig = Signature.getInstance("SHA1withRSA/PSS", "SC");</pre></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00011"/>Summary</h1></div></div></div><p>Android implements the Java Cryptography Architecture (JCA) and comes bundled with a number of cryptographic providers. JCA defines interfaces to common cryptographic algorithms in the form of engine classes. Cryptographic providers offer implementations of those engine classes and allow clients to request an algorithm implementation by name, without having to know about the actual underlying implementation. The two main JCA providers in Android are the Bouncy Castle provider and the AndroidOpenSSL provider. Bouncy Castle is implemented in pure Java, while AndroidOpenSSL is backed by native code and offers better performance. As of Android 4.4, AndroidOpenSSL is the preferred JCA provider.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch05fn01" href="#ch05fn01" class="para">38</a>] </sup>Oracle, <span class="emphasis"><em>Java™ Cryptography Architecture Standard Algorithm Name Documentation</em></span>, <span class="emphasis"><em><a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn02" href="#ch05fn02" class="para">39</a>] </sup>Wikipedia, “Block cipher mode of operation,” <span class="emphasis"><em><a class="ulink" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn03" href="#ch05fn03" class="para">40</a>] </sup>The Android robot is reproduced or modified from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn04" href="#ch05fn04" class="para">41</a>] </sup>D. McGrew, <span class="emphasis"><em>RFC 5116 – An Interface and Algorithms for Authenticated Encryption</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.ietf.org/rfc/rfc5116.txt">http://www.ietf.org/rfc/rfc5116.txt</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn05" href="#ch05fn05" class="para">42</a>] </sup>RSA Laboratories, <span class="emphasis"><em>Public-Key Cryptography Standards (PKCS)</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn06" href="#ch05fn06" class="para">43</a>] </sup>H. Krawczyk, M. Bellare, and R. Canetti, <span class="emphasis"><em>HMAC: Keyed-Hashing for Message Authentication</em></span>, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc2104">http://tools.ietf.org/html/rfc2104</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn07" href="#ch05fn07" class="para">44</a>] </sup>Hardware Security Module</p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn08" href="#ch05fn08" class="para">45</a>] </sup>B. Kaliski, <span class="emphasis"><em>PKCS #5: Password-Based Cryptography Specification, Version 2.0</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.ietf.org/rfc/rfc2898.txt">http://www.ietf.org/rfc/rfc2898.txt</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn09" href="#ch05fn09" class="para">46</a>] </sup>RSA Laboratories, <span class="emphasis"><em>PKCS #8: Private-Key Information Syntax Standard</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn10" href="#ch05fn10" class="para">47</a>] </sup>Some <code class="literal">Key</code> subclasses, such as <code class="literal">RSAPrivateKey</code>, expose all key material and thus are not technically opaque.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn11" href="#ch05fn11" class="para">48</a>] </sup>RSA Laboratories, <span class="emphasis"><em>PKCS #3: Diffie-Hellman Key-Agreement Standard</em></span>, <span class="emphasis"><em><a class="ulink" href="ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc">ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn12" href="#ch05fn12" class="para">49</a>] </sup>NIST, <span class="emphasis"><em>Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography</em></span>, <span class="emphasis"><em><a class="ulink" href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn13" href="#ch05fn13" class="para">50</a>] </sup><span class="emphasis"><em>Abstract Syntax Notation One (ASN.1)</em></span>: A standard notation that describes rules and structures for encoding data in telecommunications and computer networking. Extensively used in cryptography standards to define the structure of cryptographic objects.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn14" href="#ch05fn14" class="para">51</a>] </sup>D. Cooper et al., <span class="emphasis"><em>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</em></span>, May 2008, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc5280">http://tools.ietf.org/html/rfc5280</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn15" href="#ch05fn15" class="para">52</a>] </sup>The Apache Software Foundation, “Apache Harmony,” <span class="emphasis"><em><a class="ulink" href="http://harmony.apache.org/">http://harmony.apache.org/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn16" href="#ch05fn16" class="para">53</a>] </sup>Legion of the Bouncy Castle Inc., “Bouncy Castle Crypto APIs,” <span class="emphasis"><em><a class="ulink" href="https://www.bouncycastle.org/java.html">https://www.bouncycastle.org/java.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn17" href="#ch05fn17" class="para">54</a>] </sup>The OpenSSL Project, “OpenSSL: The Open Source toolkit for SSL/TLS,” <span class="emphasis"><em><a class="ulink" href="http://www.openssl.org/">http://www.openssl.org/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn18" href="#ch05fn18" class="para">55</a>] </sup>Chris Nokleberg, “Jar Jar Links,” <span class="emphasis"><em><a class="ulink" href="https://code.google.com/p/jarjar/">https://code.google.com/p/jarjar/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn19" href="#ch05fn19" class="para">56</a>] </sup>Roberto Tyley, “Spongy Castle,” <span class="emphasis"><em><a class="ulink" href="http://rtyley.github.io/spongycastle/">http://rtyley.github.io/spongycastle/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn20" href="#ch05fn20" class="para">57</a>] </sup>J. Jonsson and B. Kaliski, <span class="emphasis"><em>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</em></span>, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc3447">http://tools.ietf.org/html/rfc3447</a></em></span></p></div></div></div></body></html>