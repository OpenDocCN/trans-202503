<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ENCRYPTION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">Encryption is the principal application of cryptography; it makes data incomprehensible to ensure its <i>confidentiality</i>. Encryption uses an algorithm called a <i>cipher</i> and a secret value called the <i>key</i>. If you don’t know the secret key, you can’t decrypt, nor can you learn any bit of information on the encrypted message—and neither can any attacker.</p>&#13;
<p class="TX">This chapter focuses on symmetric encryption, which is the simplest kind of encryption. In <i>symmetric encryption</i>, the decryption key is the same as the encryption key (unlike <i>asymmetric encryption</i>, or <i>public-key encryption</i>, in which the keys are different). You’ll start by learning about the weakest forms of symmetric encryption, classical ciphers that are secure against only the most illiterate attacker, and then we’ll move on to the strongest forms that are secure forever.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-7"/><samp class="SANS_Futura_Std_Bold_B_11">The Basics</samp></h3>&#13;
<p class="TNI">When encrypting a message, <i>plaintext</i> refers to the unencrypted message and <i>ciphertext</i> to the encrypted message. A cipher is therefore composed of two functions: <i>encryption</i> turns a plaintext into a ciphertext, and <i>decryption</i> turns a ciphertext back into a plaintext. But we’ll often say “cipher” when we actually mean “encryption.” For example, <a href="chapter1.xhtml#fig1-1">Figure 1-1</a> shows a cipher, <b>E</b>, represented as a box taking as input a plaintext, <i>P</i>, and a key, <i>K</i>, and producing a ciphertext, <i>C</i>, as output. I’ll write this relation as <i>C</i> = <b>E</b>(<i>K</i>, <i>P</i>). Similarly, when the cipher is in decryption mode, I’ll write <b>D</b>(<i>K</i>, <i>C</i>).</p>&#13;
<figure class="IMG"><img id="fig1-1" class="img7" src="../images/fig1-1.jpg" alt="" width="731" height="221"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Basic encryption and decryption</samp></p></figcaption>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For some ciphers, the ciphertext is the same size as the plaintext; for others, the ciphertext is slightly longer. However, ciphertexts can never be shorter than plaintexts.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-8"/><samp class="SANS_Futura_Std_Bold_B_11">Classical Ciphers</samp></h3>&#13;
<p class="TNI">Classical ciphers predate computers and therefore work on letters rather than on bits, making them much simpler than a modern cipher like the Data Encryption Standard. For example, in ancient Rome or during World War I, you couldn’t use a computer chip’s power to scramble a message; you had to do everything with only pen and paper. There are many classical ciphers, but the most famous are the Caesar cipher and Vigen<span class="accent">è</span>re cipher.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-5"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Caesar Cipher</samp></h4>&#13;
<p class="TNI">The Caesar cipher is so named because the Roman historian Suetonius reported that Julius Caesar used it. It encrypts a message by shifting each of the letters down three positions in the alphabet, wrapping back around to <i>A</i> if the shift reaches <i>Z</i>. For example, <i>ZOO</i> encrypts to <i>CRR</i>, <i>FDHVDU</i> decrypts to <i>CAESAR</i>, and so on, as shown in <a href="chapter1.xhtml#fig1-2">Figure 1-2</a>. There’s nothing special about the value 3; it’s just easier to compute in one’s head than 11 or 23.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>&#13;
<figure class="IMG"><img id="fig1-2" class="img7" src="../images/fig1-2.jpg" alt="" width="865" height="559"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The Caesar cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Caesar cipher is super easy to break: to decrypt a given ciphertext, simply shift the letters three positions back to retrieve the plaintext. That said, the Caesar cipher may have been strong enough during the time of Crassus and Cicero. Because no secret key is involved (it’s always 3), users of Caesar’s cipher assumed that attackers were illiterate or too uneducated to figure it out—an assumption that’s much less realistic today. (In fact, in 2006, the Italian police arrested a mafia boss after decrypting messages written on small scraps of paper that were encrypted using a variant of the Caesar cipher: <i>ABC</i> was encrypted to 456 instead of <i>DEF</i>, for example.)</p>&#13;
<p class="TX">Could the Caesar cipher be made more secure? You might imagine a version that uses a secret shift value instead of always using 3, but that wouldn’t help much because an attacker could try all 25 possible shift values until the decrypted message makes sense.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-6"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Vigenère Cipher</samp></h4>&#13;
<p class="TNI">It took about 1,500 years to see a meaningful improvement of the Caesar cipher in the form of the Vigen<span class="accent">è</span>re cipher, created in the 16th century by an Italian named Giovan Battista Bellaso. The name <i>Vigenère</i> comes from the Frenchman Blaise de Vigen<span class="accent">è</span>re, who invented a different cipher in the 16th century, but due to historical misattribution, Vigen<span class="accent">è</span>re’s name stuck. Nevertheless, the Vigen<span class="accent">è</span>re cipher became popular and was later used during the American Civil War by Confederate forces and during WWI by the Swiss Army, among others.</p>&#13;
<p class="TX">The Vigen<span class="accent">è</span>re cipher is similar to the Caesar cipher, except that letters aren’t shifted by three places but rather by values defined by a <i>key</i>, a collection of letters that represent numbers based on their position in the alphabet. For example, if the key is DUH, letters in the plaintext are shifted using the values 3, 20, 7 because <i>D</i> is three letters after <i>A</i>, <i>U</i> is 20 letters after <i>A</i>, and <i>H</i> is seven letters after <i>A</i>. The 3, 20, 7 pattern repeats until you’ve encrypted the entire plaintext. For example, the word <i>CRYPTO</i> would encrypt to <i>FLFSNV</i> using DUH as the key: <i>C</i> is shifted three positions to <i>F</i>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/><i>R</i> is shifted 20 positions to <i>L</i>, and so on. <a href="chapter1.xhtml#fig1-3">Figure 1-3</a> illustrates this principle when encrypting the sentence <i>THEY DRINK THE TEA</i>.</p>&#13;
<figure class="IMG"><img id="fig1-3" class="img1" src="../images/fig1-3.jpg" alt="" width="1694" height="333"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: The Vigenère cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Vigen<span class="accent">è</span>re cipher is clearly more secure than the Caesar cipher, yet it’s still fairly easy to break. The first step in decrypting it is to figure out the key’s length. Take the example in <a href="chapter1.xhtml#fig1-3">Figure 1-3</a>, wherein <i>THEY DRINK THE TEA</i> encrypts to <i>WBLBXYLHRWBLWYH</i> with the key DUH. (Spaces are usually removed to hide word boundaries.) Notice that in the ciphertext <i>WBLBXYLHRWBLWYH</i>, the group of three letters <i>WBL</i> appears twice in the ciphertext at nine-letter intervals. This suggests that the same three-letter word was encrypted using the same shift values, producing <i>WBL</i> each time. A cryptanalyst can then deduce that the key’s length is either nine or a value that divides nine (that is, three). Furthermore, they may guess that this repeated three-letter word is <i>THE</i> and therefore determine DUH as a possible encryption key.</p>&#13;
<p class="TX">The second step to breaking the Vigen<span class="accent">è</span>re cipher is to determine the actual key using a method called <i>frequency analysis</i>, which exploits the uneven distribution of letters in languages. For example, in English, <i>E</i> is the most common letter, so if you find that <i>X</i> is the most common letter in a ciphertext, then the most likely plaintext value at this position is <i>E</i>.</p>&#13;
<p class="TX">Despite its relative weakness, the Vigen<span class="accent">è</span>re cipher may have been good enough to securely encrypt messages in its time. Frequency analysis is limited in that it requires a few sentences, meaning it won’t work if the cipher is used to encrypt short messages. Also, most messages needed to be secret for short periods of time, so it didn’t matter if ciphertexts were eventually decrypted by the enemy. (The 19th-century cryptographer Auguste Kerckhoffs estimated that most encrypted wartime messages required confidentiality for only three to four hours.)</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H1" id="sec5"><span id="h1-9"/><samp class="SANS_Futura_Std_Bold_B_11">How Ciphers Work</samp></h3>&#13;
<p class="TNI">Basing ourselves on the simplistic Caesar and Vigen<span class="accent">è</span>re ciphers, we can try to abstract out the workings of a cipher by identifying its two main components: a permutation and a mode of operation. A <i>permutation</i> is a function that transforms an item (in cryptography, a letter or a group of bits) such that each item has a unique inverse (for example, the Caesar cipher’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>three-letter shift). A <i>mode of operation</i> is an algorithm that uses a permutation to process messages of arbitrary size. The mode of the Caesar cipher is trivial—it just repeats the same permutation for each letter—but as you’ve seen, the Vigen<span class="accent">è</span>re cipher has a more complex mode, where letters at different positions undergo different permutations.</p>&#13;
<p class="TX">In the following sections, I discuss in more detail what these components are and how they relate to a cipher’s security. I use each component to show why classical ciphers are doomed to be insecure, unlike modern ciphers that run on high-speed computers.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Permutation</samp></h4>&#13;
<p class="TNI">Most classical ciphers work by replacing each letter with another letter—in other words, by performing a <i>substitution</i>. In the Caesar and Vigen<span class="accent">è</span>re ciphers, the substitution is a shift in the alphabet, though the alphabet or set of symbols can vary: instead of the English alphabet, it could be the Arabic alphabet; instead of letters, it could be words, numbers, or ideograms, for example. The representation or encoding of information is a separate matter that is mostly irrelevant to security. (We’re considering Latin letters because that’s what classical ciphers use.)</p>&#13;
<p class="TX">A cipher’s substitution can’t be just any substitution. It should be a permutation, which is a rearrangement of the letters <i>A</i> to <i>Z</i>, such that each letter has a unique inverse. For example, a substitution that transforms the letters <i>A</i>, <i>B</i>, <i>C</i>, and <i>D</i>, respectively, to <i>C</i>, <i>A</i>, <i>D</i>, and <i>B</i> is a permutation, because each letter maps to another single letter. But a substitution that transforms <i>A</i>, <i>B</i>, <i>C</i>, <i>D</i> to <i>D</i>, <i>A</i>, <i>A</i>, <i>C</i> is not a permutation, because both B and C map onto A. With a permutation, each letter has exactly one inverse.</p>&#13;
<p class="TX">Still, not every permutation is secure. To be secure, a cipher’s permutation should satisfy three criteria:</p>&#13;
<p class="RunInPara"><b>The permutation should be determined by the key </b>This keeps the permutation secret as long as the key is secret. In the Vigen<span class="runinpara_accent">è</span>re cipher, if you don’t know the key, you don’t know which of the 26 permutations was used; hence, you can’t easily decrypt.</p>&#13;
<p class="RunInPara"><b>Different keys should result in different permutations </b>Otherwise, it becomes easier to decrypt without the key: if different keys result in identical permutations, that means there are fewer distinct keys than distinct permutations and therefore fewer possibilities to try when decrypting without the key. In the Vigen<span class="runinpara_accent">è</span>re cipher, each letter from the key determines a substitution; there are 26 distinct letters and as many distinct permutations.</p>&#13;
<p class="RunInPara"><b>The permutation should look random, loosely speaking </b>There should be no pattern in the ciphertext after performing a permutation, because patterns make a permutation predictable for an attacker and therefore less secure. For example, the Vigen<span class="runinpara_accent">è</span>re cipher’s substitution is pretty predictable: for a given offset, if you determine that <i>A</i> encrypts to <i>F</i>, you could conclude that the shift value is 5, and you would also know that <i>B</i> encrypts to <i>G</i>, that <i>C</i> encrypts to <i>H</i>, and so on. However, with a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>randomly chosen permutation, knowing that <i>A</i> encrypts to <i>F</i> would tell you only that <i>B</i> does <i>not</i> encrypt to <i>F</i>.</p>&#13;
<p class="TX">We’ll call a permutation that satisfies these criteria a <i>secure permutation</i>. As you’ll see next, a secure permutation is necessary but insufficient on its own for building a secure cipher. A cipher also needs a mode of operation to support messages of any length.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Mode of Operation</samp></h4>&#13;
<p class="TNI">Say we have a secure permutation that transforms <i>A</i> to <i>X</i>, <i>B</i> to <i>M</i>, and <i>N</i> to <i>L</i>, for example. The word <i>BANANA</i> therefore encrypts to <i>MXLXLX</i>, where each occurrence of <i>A</i> is replaced by an <i>X</i>. Using the same permutation for all the letters in the plaintext thus reveals any duplicate letters. By analyzing these duplicates, you might not learn the entire message, but you’ll learn <i>something</i> about it. In the <i>BANANA</i> example, you don’t need the key to guess that the plaintext’s three <i>X</i> positions share a letter and that another letter is shared at the two <i>L</i> positions. If you know the message is a fruit’s name, you could determine that it’s <i>BANANA</i> rather than <i>CHERRY</i>, <i>LYCHEE</i>, or another six-letter fruit.</p>&#13;
<p class="TX">The mode of operation (or <i>mode</i>) of a cipher mitigates the exposure of duplicate letters in the plaintext by using different permutations for duplicate letters. The mode of the Vigen<span class="accent">è</span>re cipher partially addresses this: if the key is <i>N</i> letters long, then <i>N</i> different permutations will be used for every <i>N</i> consecutive letter. However, this can still result in patterns in the ciphertext because every <i>N</i>th letter of the message uses the same permutation. That’s why frequency analysis works to break the Vigen<span class="accent">è</span>re cipher.</p>&#13;
<p class="TX">Frequency analysis can be defeated if the Vigen<span class="accent">è</span>re cipher encrypts only plaintexts that are of the same length as the key. But even then, there’s another problem: reusing the same key several times exposes similarities between plaintexts. For example, with the key KYN, the words <i>TIE</i> and <i>PIE</i> encrypt to <i>DGR</i> and <i>ZGR</i>, respectively. Both end with the same two letters (<i>GR</i>), revealing that both plaintexts share their last two letters as well. Finding these patterns shouldn’t be possible with a secure cipher.</p>&#13;
<p class="TX">To build a secure cipher, you must combine a secure permutation with a secure mode. Ideally, this combination prevents attackers from learning anything about a message other than its length.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why Classical Ciphers Are Insecure</samp></h4>&#13;
<p class="TNI">Classical ciphers are doomed to be insecure because they’re limited to operations you can do in your head or on a piece of paper. They lack the computational power of a computer and are easily broken by simple computer programs. Let’s see the fundamental reason why that simplicity makes them insecure in today’s world.</p>&#13;
<p class="TX">Remember that a cipher’s permutation should look random to be secure. Of course, the best way to look random is to <i>be</i> random—that is, to select every permutation randomly from the set of all permutations. And there are many permutations to choose from. In the case of the 26-letter English alphabet, there are approximately 2<sup>88</sup> permutations:</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg9-1.jpg" alt="" width="1382" height="37"/></figure>&#13;
<p class="TX">Here, the exclamation point (!) is the factorial symbol, defined as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg9-2.jpg" alt="" width="1382" height="48"/></figure>&#13;
<p class="TX">(To see why we end up with this number, count the permutations as lists of reordered letters: there are 26 choices for the first possible letter, then 25 possibilities for the second, 24 for the third, and so on.) This number is huge: it’s of the same order of magnitude as the number of atoms in the human body. But classical ciphers can use only a small fraction of those permutations—namely, those that require simple operations (such as shifts) and have a short description (like a short algorithm or a small lookup table). The problem is that a secure permutation can’t accommodate both of these limitations.</p>&#13;
<p class="TX">You can get secure permutations using simple operations by picking a random permutation, representing it as a table of 25 letters (enough to represent a permutation of 26 letters, with the 26th one missing), and applying it by looking up letters in this table. But then you wouldn’t have a short description. For example, it would take 250 letters to describe 10 different permutations, rather than just the 10 letters used in the Vigen<span class="accent">è</span>re cipher.</p>&#13;
<p class="TX">You can also produce secure permutations with a short description. Instead of just shifting the alphabet, you could use more complex operations such as addition and multiplication. This is how modern ciphers work: given a key of typically 128 or 256 bits, they perform hundreds of bit operations to encrypt a single letter. This process is fast on a computer that can do billions of bit operations per second, but it would take hours to do by hand and would still be vulnerable to frequency analysis.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-10"/><samp class="SANS_Futura_Std_Bold_B_11">The Perfect Cipher: The One-Time Pad</samp></h3>&#13;
<p class="TNI">Essentially, a classical cipher can’t be secure unless it comes with a huge key, but encrypting with a huge key is impractical. However, the one-time pad is such a cipher, and it is the most secure cipher. In fact, it guarantees <i>perfect secrecy</i>: even if an attacker has unlimited computing power, it’s impossible to learn anything about the plaintext except for its length.</p>&#13;
<p class="TX">In the next sections, I’ll show you how a one-time pad works and then offer a sketch of its security proof.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encryption and Decryption</samp></h4>&#13;
<p class="TNI">The one-time pad takes a plaintext, <i>P</i>, and a random key, <i>K</i>, that’s the same length as <i>P</i> and produces a ciphertext, <i>C</i>, defined as</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg9-3.jpg" alt="" width="1388" height="30"/></figure>&#13;
<p class="Continued">where <i>C</i>, <i>P</i>, and <i>K</i> are bit strings of the same length and <span class="symbol">⊕</span> is the bitwise exclusive OR operation (XOR), defined as 0 <span class="symbol">⊕</span> 0 = 0, 0 <span class="symbol">⊕</span> 1 = 1, 1 <span class="symbol">⊕</span> 0 = 1, 1 <span class="symbol">⊕</span> 1 = 0.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I’m presenting the one-time pad in its usual form, as working on bits, but it can be adapted to other symbols. With letters, for example, you’d end up with a variant of the Caesar cipher with a shift index picked at random for each letter.</i></p>&#13;
<p class="TX">The one-time pad’s decryption is identical to encryption; it’s just an XOR: <i>P</i> = <i>C</i> <span class="symbol">⊕</span> <i>K</i>. Indeed, we can verify <i>C</i> <span class="symbol">⊕</span> <i>K</i> = <i>P</i> <span class="symbol">⊕</span> <i>K</i> <span class="symbol">⊕</span> <i>K</i> = <i>P</i> because XORing <i>K</i> with itself gives the all-zero string 000 . . . 000. That’s it—even simpler than the Caesar cipher.</p>&#13;
<p class="TX">For example, if <i>P</i> = 01101101 and <i>K</i> = 10110100, then we can calculate the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg10-1.jpg" alt="" width="1392" height="30"/></figure>&#13;
<p class="TX">Decryption retrieves <i>P</i> by computing the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg10-2.jpg" alt="" width="1392" height="30"/></figure>&#13;
<p class="TX">The important thing is that a one-time pad can be used <i>one time</i>: each key <i>K</i> should be used only once. If the same <i>K</i> is used to encrypt <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> to <i>C</i><sub>1</sub> and <i>C</i><sub>2</sub>, then an eavesdropper can compute the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg10-3.jpg" alt="" width="1392" height="52"/></figure>&#13;
<p class="TX">An eavesdropper would thus learn the XOR difference of <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub>, information that should be kept secret. Moreover, if either plaintext message is known, then the other message can be recovered.</p>&#13;
<p class="TX">The one-time pad is utterly inconvenient to use because it requires a key as long as the plaintext and a new random key for each new message or group of data. To encrypt a 1TB hard drive, you’d need another 1TB drive to store the key! Nonetheless, the one-time pad has been used throughout history—by the British Special Operations Executive during World War II, by Soviet spies, by the National Security Agency (NSA)—and is still used today in specific contexts. (I’ve heard of Swiss bankers who couldn’t agree on a cipher trusted by both parties and ended up using one-time pads, but I don’t recommend doing this.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why Is the One-Time Pad Secure?</samp></h4>&#13;
<p class="TNI">Although the one-time pad is not practical, it’s important to understand what makes it secure. In the 1940s, American mathematician Claude Shannon proved that the one-time pad’s key must be at least as long as the message to achieve perfect secrecy. The proof’s idea is fairly simple. You assume that the attacker has unlimited power and thus can try all the keys. The goal is to encrypt such that the attacker can’t rule out any possible plaintext given some ciphertext.</p>&#13;
<p class="TX">The intuition behind the one-time pad’s perfect secrecy goes as follows: if <i>K</i> is random, the resulting <i>C</i> looks as random as <i>K</i> to an attacker because the XOR of a random string with any fixed string yields a random string. To see <span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>this, consider the probability of getting 0 as the first bit of a random string (a probability of 1/2). What’s the probability that a random bit XORed with the second bit is 0? Right, 1/2 again. The same argument can be iterated over bit strings of any length. The ciphertext <i>C</i> thus looks random to an attacker that doesn’t know <i>K</i>, so it’s literally impossible to learn anything about <i>P</i> given <i>C</i>, even for an attacker with unlimited time and power. In other words, knowing the ciphertext gives no information whatsoever about the plaintext except its length—pretty much the definition of a secure cipher.</p>&#13;
<p class="TX">For example, if a ciphertext is 128 bits long (meaning the plaintext is 128 bits as well), there are 2<sup>128</sup> possible ciphertexts; therefore, there should be 2<sup>128</sup> possible plaintexts from the attacker’s point of view. But if there are fewer than 2<sup>128</sup> possible keys, the attacker can rule out some plaintexts. If the key is only 64 bits, for example, the attacker can determine the 2<sup>64</sup> possible plaintexts and rule out the overwhelming majority of 128-bit strings. The attacker wouldn’t learn what the plaintext is, but they would learn what the plaintext is not, which makes the encryption’s secrecy imperfect.</p>&#13;
<p class="TX">You must have a key as long as the plaintext to achieve perfect security, but this quickly becomes impractical for real-world use. Next, I’ll discuss the approaches taken in modern-day encryption to achieve the best security that’s both possible and practical.</p>&#13;
<aside class="box" aria-label="box-1">&#13;
<p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">PROBABILITY IN CRYPTOGRAPHY</samp></p>&#13;
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">probability</samp> <samp class="SANS_Futura_Std_Book_11">is a number that expresses the likelihood, or chance, of some event happening. It’s expressed as a number between 0 and 1, where 0 means “never” and 1 means “always.” The higher the probability, the greater the chance. Many explanations of probability use the example of white balls and red balls in a bag and the probability of picking a ball of either color.</samp></p>&#13;
<p class="Box"><samp class="SANS_Futura_Std_Book_11">Cryptography often uses probabilities to measure an attack’s chances of success, by first counting the number of successful events (for example, the event “find the correct secret key”) and then counting the total number of possible events (for example, the total number of keys is 2</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">n</samp> <samp class="SANS_Futura_Std_Book_11">if we deal with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp><samp class="SANS_Futura_Std_Book_11">-bit keys). In this example, the probability that a randomly chosen key is the correct one is 1/2</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">n</samp><samp class="SANS_Futura_Std_Book_11">, or the count of successful events (1 secret key) and the count of possible events (2</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">n</samp> <samp class="SANS_Futura_Std_Book_11">possible keys). The number 1/2</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">n</samp> <samp class="SANS_Futura_Std_Book_11">is negligibly small for common key lengths such as 128 and 256.</samp></p>&#13;
<p class="Box"><samp class="SANS_Futura_Std_Book_11">The probability of an event</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">not happening</samp> <samp class="SANS_Futura_Std_Book_11">is 1 –</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp><samp class="SANS_Futura_Std_Book_11">, where</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp> <samp class="SANS_Futura_Std_Book_11">is the event’s probability. The probability of getting a wrong key in our example is therefore 1 – 1/2</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">n</samp><samp class="SANS_Futura_Std_Book_11">, a number very close to 1, meaning almost certainty.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>&#13;
<h3 class="H1" id="sec12"><span id="h1-11"/><samp class="SANS_Futura_Std_Bold_B_11">Encryption Security</samp></h3>&#13;
<p class="TNI">Classical ciphers aren’t secure, but a perfectly secure cipher like the one-time pad is impractical. We’ll thus have to give a little in terms of security if we want secure <i>and</i> usable ciphers. But what does <i>secure</i> really mean, besides the obvious and informal “eavesdroppers can’t decrypt secure messages”?</p>&#13;
<p class="TX">A cipher is secure if, even given a large number of plaintext–ciphertext pairs, <i>nothing can be learned</i> about the cipher’s behavior when applied to other plaintexts or ciphertexts. This opens up new questions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">How does an attacker come by these pairs? How large is a “large number”? This is all defined by <i>attack models</i>, assumptions about what the attacker can and cannot do.</li>&#13;
<li class="BL">What could be “learned,” and what “cipher’s behavior” are we talking about? This is defined by <i>security goals</i>, descriptions of what is considered a successful attack.</li>&#13;
</ul>&#13;
<p class="TX">Attack models and security goals must go together; you can’t claim that a system is secure without explaining against whom or from what it’s safe. A <i>security notion</i> is the combination of a security goal with an attack model. We’ll say that a cipher <i>achieves</i> a certain security notion if any attacker working in a given model can’t break the security goal.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Models</samp></h4>&#13;
<p class="TNI">An attack model is a set of assumptions about how attackers might interact with a cipher and what they can and can’t do. The goals of an attack model are as follows:</p>&#13;
<ul class="ul">&#13;
<li class="BL">To set requirements for cryptographers who design ciphers so that they know what attackers and what kinds of attacks to protect against.</li>&#13;
<li class="BL">To give guidelines to users about whether a cipher will be safe to use in their environment.</li>&#13;
<li class="BL">To provide clues for cryptanalysts who attempt to break ciphers so they know whether a given attack is valid. An attack is valid only if it’s doable in the model considered.</li>&#13;
</ul>&#13;
<p class="TX">Attack models don’t need to match reality exactly; they’re an approximation. As the statistician George E. P. Box put it, “All models are wrong; the practical question is how wrong do they have to be to not be useful.” To be useful in cryptography, attack models should at least encompass what attackers can actually do to attack a cipher. It’s beneficial if a model overestimates attackers’ capabilities because it helps anticipate future attack techniques—only the paranoid cryptographers survive. A bad model underestimates attackers and provides false confidence in a cipher by making it seem secure in theory when it’s not secure in reality.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kerckhoffs’s Principle</samp></h5>&#13;
<p class="TNI">One assumption made in all models is <i>Kerckhoffs’s principle</i>, which states that the security of a cipher should rely only on the secrecy of the key and not on the secrecy of the cipher. This may sound obvious today, when ciphers and protocols are publicly specified and used by everyone. But historically, Dutch linguist Auguste Kerckhoffs was referring to military encryption machines specifically designed for a given army or division. Quoting from his 1883 essay, “La Cryptographie Militaire,” where he listed six requirements of a military encryption system: “The system must not require secrecy and can be stolen by the enemy without causing trouble.”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Black-Box Models</samp></h5>&#13;
<p class="TNI">Let’s consider some useful attack models expressed in terms of what the attacker can observe and what queries they can make to the cipher. A <i>query</i> for our purposes is the operation that sends an input value to some function and gets the output in return, without exposing the details of that function. An <i>encryption query</i>, for example, takes a plaintext and returns a corresponding ciphertext, without revealing the secret key.</p>&#13;
<p class="TX">We call these <i>black-box models</i> because the attacker sees only what goes in and out of the cipher. For example, some smart card chips securely protect a cipher’s internals as well as its keys, yet you’re allowed to connect to the chip and ask it to decrypt any ciphertext. The attacker would then receive the corresponding plaintext, which may help them determine the key. That’s a real example where <i>decryption queries</i> are possible.</p>&#13;
<p class="TX">There are several different black-box attack models. Here, I list them in order from weakest to strongest, describing attackers’ capabilities for each model:</p>&#13;
<p class="RunInPara"><b>Ciphertext-only attackers (COAs) </b>Observe ciphertexts but don’t know the associated plaintexts or how the plaintexts were selected. Attackers in the COA model are passive and can’t perform encryption or decryption queries.</p>&#13;
<p class="RunInPara"><b>Known-plaintext attackers (KPAs) </b>Observe ciphertexts and do know the associated plaintexts. Attackers in the KPA model thus get a list of plaintext–ciphertext pairs, where plaintexts are assumed to be randomly selected. KPA is a passive attacker model.</p>&#13;
<p class="RunInPara"><b>Chosen-plaintext attackers (CPAs) </b>Can perform encryption queries for plaintexts of their choice and observe the resulting ciphertexts. This model captures situations where attackers can choose all or part of the encrypted plaintexts and then get to see the ciphertexts. Unlike COA or KPA, which are passive models, CPAs are <i>active</i> attackers because they influence the encryption processes rather than passively eavesdropping.</p>&#13;
<p class="RunInPara"><b>Chosen-ciphertext attackers (CCAs) </b>Can both encrypt and decrypt; that is, they get to perform encryption queries and decryption queries (of ciphertexts different from the targeted ciphertext). The CCA model <span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>may sound ludicrous at first—if you can decrypt, what else do you need?—but like the CPA model, it aims to represent situations where attackers can have some influence on the ciphertext and later get access to the plaintext. Moreover, decryption is not always enough to break a system. For example, some video-protection devices allow attackers to perform encryption queries and decryption queries using the device’s chip, but in that context, attackers are interested in the key in order to redistribute it; in this case, being able to decrypt “for free” isn’t sufficient to break the system.</p>&#13;
<p class="TX">In the preceding models, ciphertexts that are observed as well as queried don’t come for free. Each ciphertext comes from the computation of the encryption function. This means that generating 2<i><sup>N</sup></i> plaintext–ciphertext pairs through encryption queries takes about as much computation as trying 2<i><sup>N</sup></i> keys, for example. The cost of queries should be taken into account when computing the cost of an attack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Gray-Box Models</samp></h5>&#13;
<p class="TNI">In a <i>gray-box model</i>, the attacker has access to a cipher’s <i>implementation</i>. This makes gray-box models more realistic than black-box models for applications such as smart cards, embedded systems, and virtualized systems, to which attackers often have physical access and can thus tamper with the algorithms’ internals. By the same token, gray-box models are more difficult to define than black-box ones because they depend on physical, analog properties rather than just on an algorithm’s input and outputs, and crypto theory often fails to abstract the complexity of the real world.</p>&#13;
<p class="TX"><i>Side-channel attacks</i> are a family of attacks within gray-box models. A side channel is a source of information that depends on the implementation of the cipher, be it in software or in hardware. Side-channel attackers observe or measure analog characteristics of a cipher’s implementation but don’t alter its integrity; they are <i>noninvasive</i>. For pure software implementations, typical side channels are the execution time and the behavior of the system that surrounds the cipher, such as error messages, return values, and branches. In the case of implementations on smart cards, for example, typical side-channel attackers measure power consumption, electromagnetic emanations, or acoustic noise.</p>&#13;
<p class="TX"><i>Invasive attacks</i> are a family of attacks on cipher implementations that are more powerful than side-channel attacks and are more expensive because they often require sophisticated equipment. You can run basic side-channel attacks with a standard PC and an off-the-shelf oscilloscope, but invasive attacks may require tools such as a high-resolution microscope and a chemical lab. Invasive attacks consist of a whole set of techniques and procedures, including using nitric acid to remove a chip’s packaging, acquiring microscopic imagery, partial reverse engineering, and modifying the chip’s behavior with techniques such as laser fault injection and electromagnetic injections.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>&#13;
<h4 class="H2" id="sec17"><span id="h2-13"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp></h4>&#13;
<p class="TNI">I’ve informally defined the goal of security as “nothing can be learned about the cipher’s behavior.” To turn this idea into a rigorous mathematical definition, cryptographers define two security goals that correspond to different ideas of what it means to learn about a cipher’s behavior:</p>&#13;
<p class="RunInPara"><b>Indistinguishability (IND) </b>Ciphertexts should be indistinguishable from random strings. This is usually illustrated with a hypothetical game: if an attacker picks two plaintexts and then receives a ciphertext of one of the two (chosen at random), they shouldn’t be able to tell which plaintext was encrypted, even by performing encryption queries with the two plaintexts (and decryption queries, if the model is CCA rather than CPA).</p>&#13;
<p class="RunInPara"><b>Nonmalleability (NM) </b>Given a ciphertext <i>C</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>P</i><sub>1</sub>), it should be impossible to create another ciphertext, <i>C</i><sub>2</sub>, whose corresponding plaintext, <i>P</i><sub>2</sub>, is related to <i>P</i><sub>1</sub> in a meaningful way (for example, to create a <i>P</i><sub>2</sub> that is equal to <i>P</i><sub>1</sub> <span class="symbol">⊕</span> 1 or to <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>X</i> for some known value, <i>X</i>). Surprisingly, the one-time pad is malleable: given a ciphertext <i>C</i><sub>1</sub> = <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>K</i>, you can define <i>C</i><sub>2</sub> = <i>C</i><sub>1</sub> <span class="symbol">⊕</span> 1, which is a valid ciphertext of <i>P</i><sub>2</sub> = <i>P</i><sub>1</sub> <span class="symbol">⊕</span> 1 under the same key <i>K</i>. Oops, so much for our perfect cipher.</p>&#13;
<p class="TX">Next, I’ll discuss these security goals in the context of different attack models.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Notions</samp></h4>&#13;
<p class="TNI">Security goals are useful only when combined with an attack model. The convention is to write a security notion as <i>GOAL</i>-<i>MODEL</i>. For example, IND-CPA denotes indistinguishability against chosen-plaintext attackers, NM-CCA denotes nonmalleability against chosen-ciphertext attackers, and so on. Let’s start with the security goals for an attacker.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Semantic Security and Randomized Encryption: IND-CPA</samp></h5>&#13;
<p class="TNI">The most important security notion is IND-CPA, also called <i>semantic security</i>. It captures the intuition that ciphertexts shouldn’t leak any information about plaintexts as long as the key is secret. To achieve IND-CPA security, encryption must return different ciphertexts if called twice on the same plaintext; otherwise, an attacker could identify duplicate plaintexts from their ciphertexts, contradicting the definition that ciphertexts shouldn’t reveal any information. But note that even the IND-CPA-secure scheme will inevitably leak one piece of information about the plaintext: its length, or at least approximate length. This is why encrypting compressed data is generally not a good idea, as the size of the compressed data can reveal information on the original data.</p>&#13;
<p class="TX">One way to achieve IND-CPA security is to use <i>randomized encryption</i>. As the name suggests, it randomizes the encryption process and returns different ciphertexts when the same plaintext is encrypted twice. Encryption <span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>can then be expressed as <i>C</i> = <b>E</b>(<i>K</i>, <i>R</i>, <i>P</i>), where <i>R</i> is fresh random bits. Decryption remains deterministic, however, because given <b>D</b>(<i>K</i>, <i>R</i>, <i>C</i>), you should always get <i>P</i>, regardless of the value of <i>R</i>.</p>&#13;
<p class="TX">What if encryption isn’t randomized? In the IND game introduced in the “<span class="Xref">Security Goals</span>” section on the previous page, the attacker picks two plaintexts, <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub>, and receives a ciphertext of one of the two but doesn’t know which plaintext the ciphertext corresponds to. That is, they get <i>C</i><span class="ePub-I-SUB">i</span> = <b>E</b>(<i>K</i>, <i>P</i><span class="ePub-I-SUB">i</span>) and have to guess whether <i>i</i> is 1 or 2. In the CPA model, the attacker can perform encryption queries to determine both <i>C</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>P</i><sub>1</sub>) and <i>C</i><sub>2</sub> = <b>E</b>(<i>K</i>, <i>P</i><sub>2</sub>). If encryption isn’t randomized, it suffices to see if <i>C</i><span class="ePub-I-SUB">i</span> is equal to <i>C</i><sub>1</sub> or to <i>C</i><sub>2</sub> in order to determine which plaintext was encrypted and thereby win the IND game. Therefore, randomization is key to the IND-CPA notion.</p>&#13;
<p class="TX">If you don’t have a pseudorandom generator, you may still achieve IND-CPA security by using an encryption scheme that requires a <i>nonce</i> (or <i>number used only once</i>), rather than a random, unpredictable value. A nonce must be unique for every new encryption call. A mere counter (1, 2, 3, . . .) would do the trick. For example, AES-CTR (the AES block cipher used in CTR mode) is IND-CPA if its additional input, the nonce, is unique. Unlike some randomized encryption schemes that just use randomness as part of the encryption process, the nonce is <i>necessary to decrypt</i> with algorithms using nonces.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>With randomized encryption, ciphertexts must be slightly longer than plaintexts to allow for more than one possible ciphertext per plaintext. For example, if there are 2</i><i><sup>64</sup></i> <i>possible ciphertexts per plaintext, ciphertexts must be at least 64 bits longer than plaintexts.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Semantically Secure Encryption</samp></h5>&#13;
<p class="TNI">One of the simplest constructions of a semantically secure cipher uses a <i>deterministic random bit generator (DRBG)</i>, an algorithm that returns random-looking bits given some secret value:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg16-1.jpg" alt="" width="1375" height="55"/></figure>&#13;
<p class="TX">Here, <i>R</i> is a string randomly chosen for each new encryption and given to a DRBG along with the key (<i>K</i> || <i>R</i> denotes the string consisting of <i>K</i> followed by <i>R</i>). This approach is reminiscent of the one-time pad: instead of picking a random key of the same length as the message, we leverage a random bit generator to get a random-looking string.</p>&#13;
<p class="TX">The proof that this cipher is IND-CPA secure is simple, if we assume that the DRBG produces random bits. The proof works ad absurdum: if you can distinguish ciphertexts from random strings, which means you can distinguish <b>DRBG</b>(<i>K</i> || <i>R</i>) <span class="symbol">⊕</span> <i>P</i> from random, then this means you can distinguish <b>DRBG</b>(<i>K</i> || <i>R</i>) from random. Remember that the CPA model lets you get ciphertexts for chosen values of <i>P</i>, so you can XOR <i>P</i> to <b>DRBG</b>(<i>K</i> || <i>R</i>) <span class="symbol">⊕</span> <i>P</i> and get <b>DRBG</b>(<i>K</i> || <i>R</i>). But now we have a contradiction because we started <span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>by assuming that <b>DRBG</b>(<i>K</i> || <i>R</i>) can’t be distinguished from random, producing random strings. So we conclude that ciphertexts can’t be distinguished from random strings and therefore that the cipher is secure.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>As an exercise, try to determine what other security notions are satisfied by the cipher</i> <b><i>E</i></b><i>(</i><span class="note_Italic">K</span><i>,</i> <span class="note_Italic">R</span><i>,</i> <span class="note_Italic">P</span><i>) = (</i><b><i>DRBG</i></b><i>(</i><span class="note_Italic">K</span> <i>||</i> <span class="note_Italic">R</span><i>)</i> <span class="symbol">⊕</span> <span class="note_Italic">P</span><i>,</i> <span class="note_Italic">R</span><i>). Is it NM-CPA? IND-CCA? You’ll find the answers in the next section.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Notions Comparisons</samp></h5>&#13;
<p class="TNI">You’ve learned that attack models such as CPA and CCA are combined with security goals such as NM and IND to build the security notions NM-CPA, NM-CCA, IND-CPA, and IND-CCA. How are these notions related? Can we prove that satisfying notion X implies satisfying notion Y?</p>&#13;
<p class="TX">Some relations are obvious: IND-CCA implies IND-CPA, and NM-CCA implies NM-CPA because anything a CPA attacker can do, a CCA attacker can do as well. That is, if you can’t break a cipher by performing chosen-ciphertext and chosen-plaintext queries, you can’t break it by performing only chosen-plaintext queries.</p>&#13;
<p class="TX">A less obvious relation is that IND-CPA does not imply NM-CPA. To understand this, observe that the previous IND-CPA construction (<b>DRBG</b>(<i>K</i>, <i>R</i>) <span class="symbol">⊕</span> <i>P</i>, <i>R</i>) is not NM-CPA: given a ciphertext (<i>X</i>, <i>R</i>), you can create the ciphertext (<i>X</i> <span class="symbol">⊕</span> 1, <i>R</i>), which is a valid ciphertext of <i>P</i> <span class="symbol">⊕</span> 1, thus contradicting the notion of nonmalleability.</p>&#13;
<p class="TX">But the opposite relation holds: NM-CPA implies IND-CPA. The intuition is that IND-CPA encryption is like putting items in a bag: you don’t get to see them, but you can rearrange their positions in the bag by shaking it up and down. NM-CPA is more like a safe: once inside, you can’t interact with what you put in there. This analogy doesn’t work for IND-CCA and NM-CCA, which are equivalent notions that each imply the presence of the other. I’ll spare you the proof, which is pretty technical.</p>&#13;
<aside class="box" aria-label="box-2">&#13;
<p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">TWO TYPES OF ENCRYPTION APPLICATIONS</samp></p>&#13;
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">There are two main types of encryption applications.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">In-transit encryption</samp> <samp class="SANS_Futura_Std_Book_11">protects data sent from one machine to another: data is encrypted before being sent and decrypted after being received, as in encrypted connections to e-commerce websites.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">At-rest encryption</samp> <samp class="SANS_Futura_Std_Book_11">protects data stored on an information system. Data is encrypted before being written to memory and decrypted before being read. Examples include disk encryption systems on laptops as well as virtual machine encryption for cloud virtual instances. The security notions we’ve seen apply to both types of applications, but the right notion to consider may depend on the application.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>&#13;
<h3 class="H1" id="sec22"><span id="h1-12"/><samp class="SANS_Futura_Std_Bold_B_11">Asymmetric Encryption</samp></h3>&#13;
<p class="TNI">So far, we’ve considered only symmetric encryption, where two parties share a key. In <i>asymmetric encryption</i>, there are two keys: one encrypts and the other decrypts. The encryption key is called a <i>public key</i> and is generally considered publicly available to anyone who wants to send you encrypted messages. The decryption key, however, must remain secret and is called a <i>private key</i>.</p>&#13;
<p class="TX">The public key can be computed from the private key, but the private key can’t be computed from the public key. In other words, it’s easy to compute in one direction but not in the other—and that’s the point of <i>public-key cryptography</i>, whose functions are easy to compute in one direction but practically impossible to invert.</p>&#13;
<p class="TX">The attack models and security goals for asymmetric encryption are about the same as for symmetric encryption, except that because the encryption key is public, any attacker can make encryption queries by using the public key to encrypt. The default model for asymmetric encryption is therefore the chosen-plaintext attacker.</p>&#13;
<p class="TX">Symmetric and asymmetric encryption are the two main types of encryption, and they are usually combined to build secure communication systems. They also form the basis of more sophisticated schemes, as you’ll see next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H1" id="sec23"><span id="h1-13"/><samp class="SANS_Futura_Std_Bold_B_11">When Ciphers Do More Than Encryption</samp></h3>&#13;
<p class="TNI">Basic encryption turns plaintexts into ciphertexts and ciphertexts into plaintexts, with no requirements other than security. However, some applications often need more than that, be it extra security features or functionalities. That’s why cryptographers created variants of symmetric and asymmetric encryption. Some are well understood, efficient, and widely deployed, while others are experimental, hardly used, and offer poor performance.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Encryption</samp></h4>&#13;
<p class="TNI"><i>Authenticated encryption (AE)</i> is a type of symmetric encryption that returns an <i>authentication tag</i> in addition to a ciphertext. <a href="chapter1.xhtml#fig1-4">Figure 1-4</a> shows authenticated encryption sets <b>AE</b>(<i>K</i>, <i>P</i>) = (<i>C</i>, <i>T</i>), where the authentication tag <i>T</i> is a short string that’s impossible to guess without the key. Decryption takes <i>K</i>, <i>C</i>, and <i>T</i> and returns the plaintext <i>P</i> only if it verifies that <i>T</i> is a valid tag for that plaintext–ciphertext pair; otherwise, it aborts and returns some error.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>&#13;
<figure class="IMG"><img id="fig1-4" class="img5" src="../images/fig1-4.jpg" alt="" width="321" height="221"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: Authenticated encryption</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The tag ensures the <i>integrity</i> of the message and serves as evidence that the ciphertext received is identical to the one sent in the first place by a legitimate party that knows the key <i>K</i>. When <i>K</i> is shared with only one other party, the tag also guarantees that the message was sent by that party; that is, it implicitly <i>authenticates</i> the expected sender as the actual creator of the message.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I use “creator” rather than “sender” here because an eavesdropper can record some (</i><span class="note_Italic">C</span><i>,</i> <span class="note_Italic">T</span><i>) pairs sent by party A to party B and then send them again to B, pretending to be A. This is called a</i> <span class="note_Italic">replay attack</span><i>, and it can be prevented—for example, by including a counter number in the message. When a message is decrypted, its counter</i> <span class="note_Italic">i</span> <i>increases by one:</i> <span class="note_Italic">i</span> <i>+ 1. In this way, one could check the counter to see if a message has been sent twice, indicating that an attacker is attempting a replay attack by resending the message. This also enables the detection of lost messages.</i></p>&#13;
<p class="TX"><i>Authenticated encryption with associated data (AEAD)</i> is an extension of authenticated encryption that takes some cleartext and unencrypted data and uses it to generate the authentication tag <b>AEAD</b>(<i>K</i>, <i>P</i>, <i>A</i>) = (<i>C</i>, <i>A</i>, <i>T</i>). A typical application of AEAD protects protocols’ datagrams with a cleartext header and an encrypted payload. In such cases, at least some header data has to remain in the clear; for example, destination addresses need to be clear to route network packets.</p>&#13;
<p class="TX">For more on authenticated encryption, jump to <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-16"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Format-Preserving Encryption</samp></h4>&#13;
<p class="TNI">A basic cipher takes bits and returns bits; it doesn’t care whether bits represent text, an image, or a PDF document. The ciphertext may in turn be encoded as raw bytes, hexadecimal characters, base64, and other formats. But what if you need the ciphertext to have the same format as the plaintext, as is sometimes required by database systems that can record data only in a prescribed format?</p>&#13;
<p class="TX"><i>Format-preserving encryption (FPE)</i> solves this problem. It can create ciphertexts that have the same format as the plaintext. For example, FPE can encrypt IP addresses to IP addresses (as shown in <a href="chapter1.xhtml#fig1-5">Figure 1-5</a>), ZIP codes to ZIP codes, credit card numbers to credit card numbers with a valid checksum, and so on.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>&#13;
<figure class="IMG"><img id="fig1-5" class="img5" src="../images/fig1-5.jpg" alt="" width="615" height="221"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Format-preserving encryption for IP addresses</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fully Homomorphic Encryption</samp></h4>&#13;
<p class="TNI"><i>Fully homomorphic encryption (FHE)</i> is the holy grail to cryptographers: it enables its users to replace a ciphertext, <i>C</i> = <b>E</b>(<i>K</i>, <i>P</i>), with another ciphertext, <i>C</i> <span class="symbol">′</span> = <b>E</b>(<i>K</i>, <b>F</b>(<i>P</i>)), where <b>F</b>(<i>P</i>) can be any function of <i>P</i>, without ever decrypting the initial ciphertext, <i>C</i>. For example, <i>P</i> can be a text document and <b>F</b> can be the modification of part of the text. Imagine a cloud application that stores your encrypted data, but the cloud provider doesn’t know what the data is or the type of changes made when you modify that data. Sounds amazing, doesn’t it?</p>&#13;
<p class="TX">But there’s a flip side: this type of encryption is slow—so slow that even the most basic operation would take an unacceptably long time. The first FHE scheme was created in 2009, and since then more efficient variants have appeared, but it remains unclear whether FHE will ever be fast enough to be useful. However, application-specific use cases of (partially) homomorphic encryption have proved more efficient for operations such as evaluating machine learning models.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h4 class="H2" id="sec27"><span id="h2-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searchable Encryption</samp></h4>&#13;
<p class="TNI"><i>Searchable encryption</i> enables searching over an encrypted database without leaking the searched terms by encrypting the search query itself. Like fully homomorphic encryption, searchable encryption could enhance the privacy of many cloud-based applications by hiding your searches from your cloud provider. Some commercial solutions claim to offer searchable encryption, though they’re mostly based on standard cryptography with a few tricks to enable partial searchability. As of this writing, however, searchable encryption remains experimental within the research community.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h4 class="H2" id="sec28"><span id="h2-19"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tweakable Encryption</samp></h4>&#13;
<p class="TNI"><i>Tweakable encryption (TE)</i> is similar to basic encryption, except for an additional parameter called the <i>tweak</i>, which aims to simulate different versions of a cipher (see <a href="chapter1.xhtml#fig1-6">Figure 1-6</a>). The tweak might be a unique per-customer value to ensure that a customer’s cipher can’t be cloned by other parties using the same product, but the main application of TE is <i>disk encryption</i>. However, TE is not bound to a single application and is a lower-level type of encryption used to build other schemes, such as authentication encryption modes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/>&#13;
<figure class="IMG"><img id="fig1-6" class="img5" src="../images/fig1-6.jpg" alt="" width="323" height="330"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Tweakable encryption</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In disk encryption, TE encrypts the content of storage devices such as hard drives or solid-state drives. (Randomized encryption can’t be used because it increases the size of the data, which is unacceptable for files on storage media.) To make encryption unpredictable, TE uses a tweak value that depends on the position of the data encrypted, which is usually a sector number or a block index.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<h3 class="H1" id="sec29"><span id="h1-14"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Encryption algorithms or implementations thereof can fail to protect confidentiality in many ways. This can be due to a failure to match the security requirements (such as “be IND-CPA secure”) or to set requirements matching reality (if you target only IND-CPA security when attackers can actually perform chosen-ciphertext queries). Alas, many engineers don’t even think about cryptographic security requirements and want to be “secure” without understanding what that actually means. That’s usually a recipe for disaster. Let’s look at two examples.</p>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<h4 class="H2" id="sec30"><span id="h2-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weak Cipher</samp></h4>&#13;
<p class="TNI">Our first example concerns ciphers that can be attacked using cryptanalysis techniques, as occurred with the 2G mobile communication standard. Encryption in 2G mobile phones used a cipher called A5/1 that turned out to be weaker than expected, enabling the interception of calls by anyone with the right skills and tools. Telecommunication operators had to find workarounds to prevent the attack.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The 2G standard also defined A5/2, a cipher for areas other than the European Union and United States. A5/2 was purposefully weaker to prevent the use of strong encryption everywhere.</i></p>&#13;
<p class="TX">That said, attacking A5/1 isn’t trivial, and it took more than 10 years for researchers to come up with an effective cryptanalysis method. Furthermore, the attack is a <i>time-memory trade-off (TMTO)</i>, a type of method that first runs computations for days or weeks to build large lookup tables, which are subsequently used for the actual attack. For A5/1, the precomputed tables are <span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>of the order of 1TB. Later standards for mobile encryption, such as 3G and LTE, specify stronger ciphers, but that doesn’t mean their encryption won’t be compromised; it simply means that the encryption won’t be compromised by breaking the symmetric cipher that’s part of the system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
<h4 class="H2" id="sec31"><span id="h2-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Wrong Model</samp></h4>&#13;
<p class="TNI">The next example concerns an invalid attack model that overlooked some side channels.</p>&#13;
<p class="TX">Many communication protocols that use encryption ensure that they use ciphers considered secure in the CPA or CCA model. However, some attacks don’t require encryption queries, as in the CPA model, nor do they require decryption queries, as in the CCA model. They simply need <i>validity queries</i> to tell whether a ciphertext is valid, and these queries are usually sent to the system responsible for decrypting ciphertexts. <i>Padding oracle attacks</i> are an example of such attacks, wherein an attacker learns whether a ciphertext conforms to the required format.</p>&#13;
<p class="TX">Specifically, in the case of padding oracle attacks, a ciphertext is valid only if its plaintext has the proper <i>padding</i>, a sequence of bytes appended to the plaintext to simplify encryption. Decryption fails if the padding is incorrect, and attackers can often detect decryption failures and attempt to exploit them. For example, the presence of the Java exception <samp class="SANS_TheSansMonoCd_W5Regular_11">javax.crypto.BadPaddingException</samp> indicates that an incorrect padding was observed.</p>&#13;
<p class="TX">In 2010, researchers found padding oracle attacks in several web application servers. The validity queries consisted of sending a ciphertext to some system and observing whether it threw an error. Thanks to these queries, they could decrypt otherwise-secure ciphertexts without knowing the key.</p>&#13;
<p class="TX">Cryptographers often overlook attacks like padding oracle attacks because they usually depend on an application’s behavior and on how users can interact with the application. But if you don’t anticipate such attacks and fail to include them in your model when designing and deploying cryptography, you may have some nasty surprises.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<h3 class="H1" id="sec32"><span id="h1-15"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">We discuss encryption and its various forms in more detail throughout this book, especially how modern, secure ciphers work. Still, I can’t cover everything and have passed over many fascinating topics. For example, to learn the theoretical foundations of encryption and gain a deeper understanding of the notion of indistinguishability, read the 1982 paper that introduced the idea of semantic security, “Probabilistic Encryption and How to Play Mental Poker Keeping Secret All Partial Information” by Goldwasser and Micali. If you’re interested in physical attacks and cryptographic hardware, the proceedings of the Cryptographic Hardware and Embedded Systems (CHES) conference are the main reference.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>There are also many more types of encryption than those presented in this chapter, including attribute-based encryption, broadcast encryption, functional encryption, identity-based encryption, message-locked encryption, and proxy reencryption, to cite but a few. For the latest research on those topics, check <i><a href="https://eprint.iacr.org">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org</a></i>, an electronic archive of cryptography research papers.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>