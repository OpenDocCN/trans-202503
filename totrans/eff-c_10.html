<html><head></head><body>
<section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<span aria-label="213" epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch10">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>
<span class="CT1"><samp class="SANS_Dogma_OT_Bold_B_11">PROGRAM STRUCTURE</samp></span>
</h1>
</hgroup>
<p class="CAU"><i>with Aaron Ballman</i></p>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">Any real-world system is made up of multiple components, such as source files, headers, and libraries. Many contain resources including images, sounds, and configuration files. Composing a program from smaller logical components is good software engineering practice, because these components are easier to manage than a single large file.</p>
<p class="TX">In this chapter, you’ll learn how to structure your program into multiple units consisting of both source and include files. You’ll also learn how to link multiple object files together to create libraries and executable files.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-84"/><samp class="SANS_Futura_Std_Bold_B_11">Principles of Componentization</samp></h2>
<p class="TNI">Nothing prevents you from writing your entire program within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function of a single source file. However, as the function grows, that <span aria-label="214" epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/>approach will quickly become unmanageable. For this reason, it makes sense to decompose your program into a collection of components that exchange information across a shared boundary, or <i>interface</i>. Organizing source code into components makes it easier to understand and allows you to reuse the code elsewhere in the program, or even with other programs.</p>
<p class="TX">Understanding how best to decompose a program typically requires experience. Many of the decisions programmers make are driven by performance. For example, you may need to minimize communication over a high-latency interface. Bad hardware can only go so far; you need bad software to really screw up performance.</p>
<p class="TX">Performance is only one software quality attribute (ISO/IEC 25000:2014) and must be balanced with maintainability, code readability, understandability, safety, and security. For example, you may design a client application to handle input field validation from the user interface to avoid a round trip to the server. This helps performance but can hurt security if inputs to the server are not validated. A simple solution is to validate inputs in both locations.</p>
<p class="TX">Developers frequently do strange things for illusionary gains. The strangest of these is invoking the undefined behavior of signed integer overflow to improve performance. Frequently, these local code optimizations have no impact on overall system performance and are considered <i>premature optimizations</i>. Donald Knuth, author of <i>The Art of Computer Programming</i> (Addison-Wesley, 1997), described premature optimization as “the root of all evil.”</p>
<p class="TX">In this section, we’ll cover some principles of component-based software engineering.</p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2" id="sec2"><span id="h2-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coupling and Cohesion</samp></h3>
<p class="TNI">In addition to performance, the aim of a well-structured program is to achieve desirable properties like low coupling and high cohesion. <i>Cohesion</i> is a measure of the commonality between elements of a programming interface. Assume, for example, that a header exposes functions for calculating the length of a string, calculating the tangent of a given input value, and creating a thread. This header has low cohesion because the exposed functions are unrelated to each other. Conversely, a header that exposes functions to calculate the length of a string, concatenate two strings together, and search for a substring within a string has high cohesion because all the functionality is related. This way, if you need to work with strings, you need only to include the string header. Similarly, related functions and type definitions that form a public interface should be exposed by the same header to provide a highly cohesive interface of limited functionality. We’ll discuss public interfaces further in “<span class="Xref">Data Abstractions</span>” on <span class="Xref"><a href="#pg_215">page 215</a></span>.</p>
<p class="TX"><i>Coupling</i> is a measure of the interdependency of programming interfaces. For example, a tightly coupled header can’t be included in a program by itself; instead, it must be included with other headers in a specific order. You may couple interfaces for a variety of reasons, such as a mutual reliance on data structures, interdependence between functions, or the use of <span aria-label="215" epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/>a shared global state. But when interfaces are tightly coupled, modifying program behavior becomes difficult because changes can have a ripple effect across the system. You should always strive to have loose coupling between interface components, regardless of whether they’re members of a public interface or implementation details of the program.</p>
<p class="TX">By separating your program logic into distinct, highly cohesive components, you make it easier to reason about the components and test the program (because you can verify the correctness of each component independently). The result is a more maintainable, less buggy system.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Reuse</samp></h3>
<p class="TNI"><i>Code reuse</i> is the practice of implementing functionality once and then reusing it in various parts of the program without duplicating the code. Code duplication can lead to subtly unexpected behavior, oversized and bloated executables, and increased maintenance costs. And anyway, why write the same code more than once?</p>
<p class="TX"><i>Functions</i> are the lowest-level reusable units of functionality. Any logic that you might repeat more than once is a candidate for encapsulating in a function. If the functionality has only minor differences, you might be able to create a parameterized function that serves multiple purposes. Each function should perform work that isn’t duplicated by any other function. You can then compose individual functions to solve increasingly sophisticated problems.</p>
<p class="TX">Packaging reusable logic into functions can improve maintainability and eliminate defects. For example, though you could determine the length of a null-terminated string by writing a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, it’s more maintainable to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function from the C standard library. Because other programmers are already familiar with the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function, they’ll have an easier time understanding what that function is doing than what the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is doing. Furthermore, if you reuse existing functionality, you’re less likely to introduce behavioral differences in ad hoc implementations, and you make it easier to globally replace the functionality with a better-performing algorithm or more secure implementation, for example.</p>
<p class="TX">When designing functional interfaces, a balance must be struck between <i>generality</i> and <i>specificity</i>. An interface that’s specific to the current requirement may be lean and effective but hard to modify when requirements change. A general interface might allow for future requirements but be cumbersome for foreseeable needs.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Abstractions</samp></h3>
<p class="TNI">A <i>data abstraction</i> is any reusable software component that enforces a clear separation between the abstraction’s public interface and the implementation details. The <i>public interface</i> for each data abstraction includes the data type definitions, function declarations, and constant definitions required by the users of the data abstraction and is placed in headers. The implementation details of how the data abstraction is coded, as well as any private <span aria-label="216" epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>utility functions, are hidden within source files or in headers that are in a separate location from the public interface headers. This separation of the public interface from the private implementation allows you to change the implementation details without breaking code that depends on your component.</p>
<p class="TX"><i>Header files</i> typically contain function declarations and type definitions for the component. For example, the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;string.h&gt;</samp> header provides the public interface for string-related functionality, while <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;threads.h&gt;</samp> provides utility functions for threading. This logical separation has low coupling and high cohesion, making it easier to access only the specific components you need and reduce compile time and the likelihood of name collisions. You don’t need to know anything about threading application programming interfaces (APIs), for example, if all you need is the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function.</p>
<p class="TX">Another consideration is whether you should explicitly include the headers required by your header or require the users of the header to include them first. It’s a good idea for data abstractions to be self-contained and include the headers they use. Not doing so is a burden on the users of the abstraction and leaks implementation details about the data abstraction. Examples in this book don’t always follow this practice to keep these file listings concise.</p>
<p class="TX"><i>Source files</i> implement the functionality declared by a given header or the application-specific program logic used to perform whatever actions are needed for a given program. For example, if you have a <i>network.h</i> header that describes a public interface for network communications, you may have a <i>network.c</i> source file (or <i>network_win32.c</i> for Windows only and <i>network _linux.c</i> for Linux only) that implements the network communication logic.</p>
<p class="TX">It’s possible to share implementation details between two source files by using a header, but the header file should be placed in a distinct location from the public interface to prevent accidentally exposing implementation details.</p>
<p class="TX">A <i>collection</i> is a good example of a data abstraction that separates the basic functionality from the implementation or underlying data structure. A collection groups data elements and supports operations such as adding elements to the collection, removing data elements from the collection, and checking whether the collection contains a specific data element.</p>
<p class="TX">There are many ways to implement a collection. For example, a collection of data elements may be represented as a flat array, a binary tree, a directed (possibly acyclic) graph, or a different structure. The choice of data structure can impact an algorithm’s performance, depending on what kind of data you’re representing and how much data there is to represent. For example, a binary tree may be a better abstraction for a large amount of data that needs good lookup performance, whereas a flat array is likely a better abstraction for a small amount of data of fixed size. Separating the interface of the collection data abstraction from the implementation of the underlying data structure allows the implementation to change without requiring changes to code that relies on the collection interface.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<span aria-label="217" epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>
<h3 class="H2" id="sec5"><span id="h2-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opaque Types</samp></h3>
<p class="TNI">Data abstractions are most effective when used with opaque data types that hide information. In C, <i>opaque</i> (or <i>private</i>) data types are those expressed using an incomplete type, such as a forward-declared structure type. An <i>incomplete type</i> is a type that describes an identifier but lacks information needed to determine the size of objects of that type or their layout. Hiding internal-only data structures discourages programmers who use the data abstraction from writing code that depends on implementation details, which may change. The incomplete type is exposed to users of the data abstraction, while the fully defined type is accessible only to the implementation.</p>
<p class="TX">Say we want to implement a collection that supports a limited number of operations, such as adding an element, removing an element, and searching for an element. The following example implements <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> as an opaque type, hiding the implementation details of the data type from the library’s user. To accomplish this, we create two headers: an external <i>collection.h</i> header included by the user of the data type and an internal header included only in files that implement the functionality of the data type.</p>
<p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection.h</samp></p>
<pre class="pre"><code>typedef struct collection * collection_type;
// function declarations
extern errno_t create_collection(collection_type *result);
extern void destroy_collection(collection_type col);
extern errno_t add_to_collection(
  collection_type col, const void *data, size_t byteCount
);
extern errno_t remove_from_collection(
  collection_type col, const void *data, size_t byteCount
);
extern errno_t find_in_collection(
  const collection_type col, const void *data, size_t byteCount
);
//<var> --snip--</var></code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> identifier is aliased to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp> (an incomplete type). Consequently, functions in the public interface must accept a pointer to this type, instead of an actual value type, because of the constraints placed on the use of incomplete types in C.</p>
<p class="TX">In the internal header, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp> is fully defined but not visible to a user of the data abstraction:</p>
<p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection_priv.h</samp></p>
<pre class="pre"><code>struct node_type {
  void *data;
  size_t size;
  struct node_type *next;
};

struct collection_type {
  size_t num_elements;
<span aria-label="218" epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/>  struct node_type *head;
};</code></pre>
<p class="TX">Users of the data abstraction include only the external <i>collection.h</i> file, whereas modules that implement the abstract data type also include the internal definitions <i>collection_priv.h</i> file. This allows the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> data type to remain private.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">

<h2 class="H1" id="sec6"><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">Executables</samp></h2>
<p class="TNI">In <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, we learned that the compiler is a pipeline of translation phases and that the compiler’s ultimate output is object code. The last phase of translation, called the <i>link phase</i>, takes the object code for all the translation units in the program and links them together to form a final executable. This can be an executable that a user can run, such as <i>a.out</i> or <i>foo.exe</i>, a library, or a more specialized program such as a device driver or a firmware image (machine code to be burned onto read-only memory [ROM]). Linking allows you to separate your code into distinct source files that can be compiled independently, which helps to build reusable components.</p>
<p class="TX"><i>Libraries</i> are executable components that cannot be executed independently. Instead, you incorporate libraries into executable programs. You can invoke the functionality of the library by including the library’s headers in your source code and calling the declared functions. The C standard library is an example of a library—you include the headers from the library, but you do not directly compile the source code that implements the library functionality. Instead, the implementation ships with a prebuilt version of the library code.</p>
<p class="TX">Libraries allow you to build on the work of others for the generic components of a program so you can focus on developing the logic that is unique to your program. For example, when writing a video game, reusing existing libraries should allow you to focus on developing the game logic, not worrying about the details of retrieving user input, network communications, or graphics rendering. Libraries compiled with one compiler can often be used by programs built with a different compiler.</p>
<p class="TX">Libraries are linked into your application and can be either static or dynamic. A <i>static library</i>, also known as an <i>archive</i>, incorporates its machine or object code directly into the resulting executable, which means that a static library is often tied to a specific release of the program. Because a static library is incorporated at link time, the contents of the static library can be further optimized for your program’s use of the library. Library code used by the program can be made available for link-time optimizations (for example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-flto</samp> flag), while unused library code can be stripped from the final executable.</p>
<p class="TX">A <i>dynamic library</i>, also referred to as a <i>shared library</i> or a <i>dynamic shared object</i>, is an executable without the startup routines. It can be packaged with the executable or installed separately but must be available when the <span aria-label="219" epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/>executable calls a function provided by the dynamic library. Many modern operating systems will load the dynamic library code into memory once and share it across all the applications that need it. You can replace a dynamic library with different versions as necessary after your application has been deployed.</p>
<p class="TX">Letting the library evolve separately from the program comes with its own set of benefits and risks. A developer can correct bugs in the library after an application has already shipped without requiring the application to be recompiled, for instance. However, dynamic libraries provide the potential opportunity for a malicious attacker to replace a library with a nefarious one or an end user to accidentally use an incorrect version of the library. It’s also possible to make a <i>breaking change</i> in a new library release that results in an incompatibility with existing applications that use the library. Static libraries might execute somewhat faster because the object code (binary) is included in the executable file, enabling further optimizations. The benefits of using dynamic libraries usually outweigh the disadvantages.</p>
<p class="TX">Each library has one or more headers that contain the public interface to the library and one or more source files that implement the logic for the library. You can benefit from structuring your code as a collection of libraries even if the components aren’t turned into actual libraries. Using an actual library makes it harder to accidentally design a tightly coupled interface where one component has special knowledge of the internal details of another component.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h2 class="H1" id="sec7"><span id="h1-86"/><samp class="SANS_Futura_Std_Bold_B_11">Linkage</samp></h2>
<p class="TNI"><i>Linkage</i> is a process that controls whether an interface is public or private and determines whether any two identifiers refer to the same entity. Ignoring macros and macro parameters that are replaced early in the translation phases, an <i>identifier</i> can denote a standard attribute, an attribute prefix, or an attribute name; an object; a function; a tag or a member of a structure, union, or enumeration; a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> name; or a label name.</p>
<p class="TX">C provides three kinds of linkage: external, internal, or none. Each declaration of an identifier with <i>external linkage</i> refers to the same function or object everywhere in the program. Identifiers referring to declarations with internal linkage refer to the same entity only within the translation unit containing the declaration. If two translation units both refer to the same internal linkage identifier, they refer to different instances of the entity. If a declaration has <i>no linkage</i>, it’s a unique entity in each translation unit.</p>
<p class="TX">The linkage of a declaration is either explicitly declared or implied. If you declare an entity at file scope without explicitly specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, the entity is implicitly given external linkage. Identifiers that have no linkage include function parameters, block scope identifiers declared without an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier, or enumeration constants.</p>
<p class="TX"><a href="chapter10.xhtml#Lis10-1">Listing 10-1</a> shows examples of declarations of each kind of linkage.</p>
<span id="Lis10-1"/>
<pre><code><span aria-label="220" epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/>static int i; // i has explicit internal linkage
extern void foo(int j) {
  // foo has explicit external linkage
  // j has no linkage because it is a parameter
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Examples of internal, external, and no linkage</samp></p>
<p class="TX">If you explicitly declare an identifier with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage class specifier at file scope, it has internal linkage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> keyword gives internal linkage only to file scope entities. Declaring a variable at block scope as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> creates an identifier with no linkage, but it does give the variable static storage duration. As a reminder, static storage duration means its lifetime is the entire execution of the program, and its stored value is initialized only once, prior to program startup. The different meanings of <i>static</i> when used in different contexts are obviously confusing and consequently a common interview question.</p>
<p class="TX">You can create an identifier with external linkage by declaring it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier. This works only if you haven’t previously declared the linkage for that identifier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier has no effect if a prior declaration gave the identifier linkage.</p>
<p class="TX">Declarations with conflicting linkage can lead to undefined behavior; see CERT C rule DCL36-C, “Do not declare an identifier with conflicting linkage classifications,” for more information.</p>
<p class="TX"><a href="chapter10.xhtml#Lis10-2">Listing 10-2</a> shows sample declarations with implicit linkage.</p>
<span id="Lis10-2"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">foo.c</samp></p>
<pre class="pre"><code>void func(int i) {// implicit external linkage
  // i has no linkage
}
static void bar(); // internal linkage, different bar from bar.c
extern void bar() {
  // bar still has internal linkage because the initial declaration
  // was declared as static; this extern specifier has no effect
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Examples of implicit linkage</samp></p>
<p class="TX"><a href="chapter10.xhtml#Lis10-3">Listing 10-3</a> shows sample declarations with explicit linkage.</p>
<span id="Lis10-3"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">bar.c</samp></p>
<pre class="pre"><code>extern void func(int i); // explicit external linkage
static void bar() {  // internal linkage; different bar from foo.c
  func(12); // calls func from foo.c
}
int i; // external linkage; doesn’t conflict with i from foo.c or bar.c
void baz(int k) {// implicit external linkage
  bar(); // calls bar from bar.c, not foo.c
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Examples of explicit linkage</samp></p>
<p class="TX">The identifiers in your public interface should have external linkage so that they can be called from outside their translation unit. Identifiers that <span aria-label="221" epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/>are implementation details should be declared with internal or no linkage (provided they don’t need to be referenced from another translation unit). A common approach to achieving this is to declare your public interface functions in a header with or without using the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier (the declarations implicitly have external linkage, but there is no harm in explicitly declaring them with <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>) and define the public interface functions in a source file in a similar manner.</p>
<p class="TX">However, within the source file, all declarations that are implementation details should be explicitly declared <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> to keep them private—accessible to just that source file. You can include the public interface declared within the header by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> preprocessor directive to access its interface from another file. A good rule of thumb is that file-scope entities that don’t need to be visible outside the file should be declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>. This practice limits the global namespace pollution and decreases the chances of surprising interactions between translation units.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h2 class="H1" id="sec8"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">Structuring a Simple Program</samp></h2>
<p class="TNI">To learn how to structure a complex, real-world program, let’s develop a simple program to determine whether a number is prime. A <i>prime number</i> (or a <i>prime</i>) is a natural number that cannot be formed by multiplying two smaller natural numbers. We’ll write two separate components: a static library containing the testing functionality and a command line application that provides a user interface for the library.</p>
<p class="TX">The <i>primetest</i> program accepts a whitespace-delimited list of integer values as input and then outputs whether each value is a prime number. If any of the inputs are invalid, the program will output a helpful message explaining how to use the interface.</p>
<p class="TX">Before exploring how to structure the program, let’s examine the user interface. First, we print the help text for the command line program, as shown in <a href="chapter10.xhtml#Lis10-4">Listing 10-4</a>.</p>
<span id="Lis10-4"/>
<pre><code>// print command line help text
static void print_help() {
  puts("primetest num1 [num2 num3 ... numN]\n");
  puts("Tests positive integers for primality.");
  printf("Tests numbers in the range [2-%llu].\n", ULLONG_MAX);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Printing help text</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp> function prints usage information about how to use the command to the standard output.</p>
<p class="TX">Next, because the command line arguments are passed to the program as textual input, we define a utility function to convert them to integer values, as shown in <a href="chapter10.xhtml#Lis10-5">Listing 10-5</a>.</p>
<span id="Lis10-5"/>
<pre><code><span aria-label="222" epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/>// converts a string argument arg to an unsigned long long value referenced by val
// returns true if the argument conversion succeeds and false if it fails
static bool convert_arg(const char *arg, unsigned long long *val) {
  char *end;

  // strtoull returns an in-band error indicator; clear errno before the call
  errno = 0;
  *val = strtoull(arg, &amp;end, 10);

  // check for failures where the call returns a sentinel value and sets errno
  if ((*val == ULLONG_MAX) &amp;&amp; errno) return false;
  if (*val == 0 &amp;&amp; errno) return false;
  if (end == arg) return false;

  // If we got here, the argument conversion was successful.
  // However, we want to allow only values greater than one,
  // so we reject values &lt;= 1.
  if (*val &lt;= 1) return false;
  return true;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: Converting a single command line argument</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function accepts a string argument as input and uses an output parameter to report the converted argument. An <i>output parameter</i> returns a function result to the caller via a pointer, allowing multiple values to be returned in addition to the function return value. The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the argument conversion succeeds and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> if it fails. The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strtoull</samp> function to convert the string to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp> integer value and takes care to properly handle conversion errors. Additionally, because the definition of a prime number excludes 0, 1, and negative values, the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function treats those as invalid inputs.</p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> utility function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp> function, shown in <a href="chapter10.xhtml#Lis10-6">Listing 10-6</a>, which loops over all the command line arguments provided and attempts to convert each argument from a string to an integer.</p>
<span id="Lis10-6"/>
<pre><code>static unsigned long long *convert_cmd_line_args(int argc,
                                                 const char *argv[],
                                                 size_t *num_args) {
  *num_args = 0;

  if (argc &lt;= 1) {
    // no command line arguments given (the first argument is the
    // name of the program being executed)
    print_help();
    return nullptr;
  }

  // We know the maximum number of arguments the user could have passed,
  // so allocate an array large enough to hold all the elements. Subtract
  // one for the program name itself. If the allocation fails, treat it as
  // a failed conversion (it is OK to call free(nullptr)).
<span aria-label="223" epub:type="pagebreak" id="pg_223" role="doc-pagebreak"/>  unsigned long long *args =
      (unsigned long long *)malloc(sizeof(unsigned long long) * (argc - 1));
  bool failed_conversion = (args == nullptr);
  for (int i = 1; i &lt; argc &amp;&amp; !failed_conversion; ++i) {
    // Attempt to convert the argument to an integer. If we
    // couldn't convert it, set failed_conversion to true.
    unsigned long long one_arg;
    failed_conversion |= !convert_arg(argv[i], &amp;one_arg);
    args[i - 1] = one_arg;
  }

  if (failed_conversion) {
    // free the array, print the help, and bail out
    free(args);
    print_help();
    return nullptr;
  }

  *num_args = argc - 1;
  return args;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Processing all the command line arguments</samp></p>
<p class="TX">If any argument fails to convert, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp> function to report the proper command line usage to the user and then returns a null pointer. This function is responsible for allocating a sufficiently large buffer to hold the array of integers. It also handles all error conditions, such as running out of memory or failing to convert an argument. If the function succeeds, it returns an array of integers to the caller and writes the converted number of arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">num_args</samp> parameter. The returned array is allocated storage and must be deallocated when no longer needed.</p>
<p class="TX">There are several ways to determine whether a number is prime. The naive approach is to test a value <i>N</i> by determining whether it is evenly divisible by [2..<i>N</i> – 1]. This approach has poor performance characteristics as the value of <i>N</i> gets larger. Instead, we’ll use one of the many algorithms designed for testing primality. <a href="chapter10.xhtml#Lis10-7">Listing 10-7</a> shows a nondeterministic implementation of the Miller-Rabin primality test that’s suitable for quickly testing whether a value is probably prime (Schoof 2008). Please see the Schoof paper for an explanation of the mathematics behind the Miller-Rabin primality test algorithm.</p>
<span id="Lis10-7"/>
<pre><code>static unsigned long long power(unsigned long long x, unsigned long long y,
                                unsigned long long p) {
  unsigned long long result = 1;
  x %= p;

  while (y) {
    if (y &amp; 1) result = (result * x) % p;
    y &gt;&gt;= 1;
    x = (x * x) % p;
  }
<span aria-label="224" epub:type="pagebreak" id="pg_224" role="doc-pagebreak"/>  return result;
}

static bool miller_rabin_test(unsigned long long d, unsigned long long n) {
  unsigned long long a = 2 + rand() % (n - 4);
  unsigned long long x = power(a, d, n);

  if (x == 1 || x == n - 1) return true;

  while (d != n - 1) {
    x = (x * x) % n;
    d *= 2;

    if (x == 1) return false;
    if (x == n - 1) return true;
  }
  return false;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: The Miller-Rabin primality test algorithm</samp></p>
<p class="TX">The interface to the Miller-Rabin primality test is the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> function shown in <a href="chapter10.xhtml#Lis10-8">Listing 10-8</a>. This function accepts two arguments: the number to test (<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>) and the number of times to perform the test (<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>). Larger values of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> provide a more accurate result but worsen performance. We’ll place the algorithm from <a href="chapter10.xhtml#Lis10-6">Listing 10-6</a> in a static library, along with the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> function, which will provide the library’s public interface.</p>
<span id="Lis10-8"/>
<pre><code>bool is_prime(unsigned long long n, unsigned int k) {
  if (n &lt;= 1 || n == 4) return false;
  if (n &lt;= 3) return true;

  unsigned long long d = n - 1;
  while (d % 2 == 0) d /= 2;

  for (; k != 0; --k) {
    if (!miller_rabin_test(d, n)) return false;
  }
  return true;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: The interface to the Miller-Rabin primality test algorithm</samp></p>
<p class="TX">Finally, we need to compose these utility functions into a program. <a href="chapter10.xhtml#Lis10-9">Listing 10-9</a> shows the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function. It uses a fixed number of iterations of the Miller-Rabin test and reports whether the input values are probably prime or definitely not prime. It also handles deallocating the memory allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>.</p>
<span id="Lis10-9"/>
<pre><code>int main(int argc, char *argv[]) {
  size_t num_args;
  unsigned long long *vals = convert_cmd_line_args(argc, argv, &amp;num_args);

<span aria-label="225" epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>  if (!vals) return EXIT_FAILURE;

  for (size_t i = 0; i &lt; num_args; ++i) {
    printf("%llu is %s.\n", vals[i],
           is_prime(vals[i], 100) ? "probably prime" : "not prime");
  }

  free(vals);
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: The</samp> <samp class="I">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp> function to convert the command line arguments into an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp> integers. For each argument in this array, the program loops, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> to determine whether each value is probably prime or not prime using the Miller-Rabin primality test implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> function.</p>
<p class="TX">Now that we’ve implemented the program logic, we’ll produce the required build artifacts. Our goal is to produce a static library containing the Miller-Rabin implementation and a command line application driver.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h2 class="H1" id="sec9"><span id="h1-88"/><samp class="SANS_Futura_Std_Bold_B_11">Building the Code</samp></h2>
<p class="TNI">Create a new file named <i>isprime.c</i> with the code from Listings 10-8 and 10-9 (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives for <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdlib.h&gt;</samp> at the top of the file. The quotes and angle brackets surrounding the headers are important for telling the preprocessor where to search for those files, as discussed in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>. Next, create a header named <i>isprime.h</i> with the code from <a href="chapter10.xhtml#Lis10-10">Listing 10-10</a> to provide the public interface for the static library, with a header guard.</p>
<span id="Lis10-10"/>
<pre><code>#ifndef PRIMETEST_IS_PRIME_H
#define PRIMETEST_IS_PRIME_H

bool is_prime(unsigned long long n, unsigned k);

#endif // PRIMETEST_IS_PRIME_H</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: The public interface for the static library</samp></p>
<p class="TX">Create a new file named <i>driver.c</i> with the code from Listings 10-5, 10-6, 10-7, and 10-10 (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives for the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;errno.h&gt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdlib.h&gt;</samp> at the top of the file. All three files are in the same directory in our example, but in a real-world project, you would likely put the files in different directories, depending on the conventions of your build system. Create a local directory named <i>bin</i>, which is where the build artifacts from this example will be created.</p>
<p class="TX"><span aria-label="226" epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/>We use Clang to create the static library and executable program, but both GCC and Clang support the command line arguments in the example, so either compiler will work. First, compile both C source files into object files placed in the <i>bin</i> directory:</p>

<pre><code>% <b>cc -c -std=c23 -Wall -Wextra -pedantic isprime.c -o bin/isprime.o</b>
% <b>cc -c -std=c23 -Wall -Wextra -pedantic driver.c -o bin/driver.o</b></code></pre>
<p class="TX">For older compilers, it may be necessary to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp>.</p>
<p class="TX">If you execute the command and get an error such as</p>

<pre><code>unable to open output file 'bin/isprime.o': 'No such file or directory'</code></pre>
<p class="Continued">then create the local <i>bin</i> directory and try the command again. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> flag instructs the compiler to compile the source into an object file without invoking the linker to produce executable output. We’ll need the object files to create a library. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp> flag specifies the pathname of the output file.</p>
<p class="TX">After executing the commands, the <i>bin</i> directory should contain two object files: <i>isprime.o</i> and <i>driver.o</i>. These files contain the object code for each translation unit. You could link them together directly to create the executable program. However, in this case, we’ll make a static library. To do this, execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to generate the static library named <i>libPrimalityUtilities.a</i> in the <i>bin</i> directory:</p>

<pre><code>% <b>ar rcs bin/libPrimalityUtilities.a bin/isprime.o</b></code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> option instructs the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to replace any existing files in the archive with the new files, the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> option creates the archive, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> option writes an object-file index into the archive (which is equivalent to running the <samp class="SANS_TheSansMonoCd_W5Regular_11">ranlib</samp> command). This creates a single archive file that’s structured to allow retrieval of the original object files used to create the archive, like a compressed tarball or ZIP file. By convention, static libraries on Unix systems are prefixed with <i>lib</i> and have a <i>.a</i> file extension.</p>
<p class="TX">You can now link the driver object file to the <i>libPrimalityUtilities.a</i> static library to produce an executable named <i>primetest</i>. This can be accomplished either by invoking the compiler without the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> flag, which invokes the default system linker with the appropriate arguments, or by invoking the linker directly. Invoke the compiler to use the default system linker as follows:</p>

<pre><code>% <b>cc bin/driver.o -Lbin -lPrimalityUtilities -o bin/primetest</b></code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-L</samp> flag instructs the linker to look in the local <i>bin</i> directory for libraries to link, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> flag instructs the linker to link the <i>libPrimalityUtilities.a</i> library to the output. Omit the <i>lib</i> prefix and the <i>.a</i> suffix from the command line argument because the linker adds them implicitly. For example, to link against the <i>libm</i> math library, specify <samp class="SANS_TheSansMonoCd_W5Regular_11">-lm</samp> as the link target. As with compiling source files, the output of the linked files is specified by the <samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp> flag.</p>
<p class="TX"><span aria-label="227" epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>You can now test the program to see whether values are probably prime or definitely not prime. Be sure to try out cases like negative numbers, known prime and nonprime numbers, and incorrect input, as shown in <a href="chapter10.xhtml#Lis10-11">Listing 10-11</a>.</p>
<span id="Lis10-11"/>
<pre><code>% <b>./bin/primetest 899180</b>
899180 is not prime
% <b>./bin/primetest 8675309</b>
8675309 is probably prime
% <b>./bin/primetest 0</b>
primetest num1 [num2 num3 ... numN]

Tests positive integers for primality.
Tests numbers in the range [2-18446744073709551615].</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: Running the</samp> <samp class="SANS_Futura_Std_Book_11">primetest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">program with sample input</samp></p>
<p class="TX">The number 8,675,309 is prime.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h2 class="H1" id="sec10"><span id="h1-89"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about the benefits of loose coupling, high cohesion, data abstractions, and code reuse. Additionally, you learned about related language constructs such as opaque data types and linkage. You were introduced to some best practices on how to structure the code in your projects and saw an example of building a simple program with different types of executable components. These skills are important as you transition from writing practice programs to developing and deploying real-world systems.</p>
<p class="TX">In the next chapter, we’ll learn how to use various tools and techniques to create high-quality systems, including assertions, debugging, testing, and static and dynamic analysis. These skills are all necessary to develop safe, secure, and performant modern systems.</p>
</section>
</section>
</body></html>