- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 5 MODELING AND SIMULATION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 模型与仿真
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: In this chapter, we’ll venture into several mini science projects that will
    further strengthen your coding abilities in Kotlin. In addition, the mini projects
    of this chapter will enhance your problem-solving skills by showing how to apply
    basic laws of nature and mathematics to solve problems that are very difficult
    to answer without the help of a computer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行几个小型科学项目，这些项目将进一步增强你在 Kotlin 中的编码能力。此外，本章的小项目将通过展示如何应用自然法则和数学原理来解决一些没有计算机帮助就很难解答的问题，从而提高你的问题解决能力。
- en: Since visualization is a key part of scientific investigation, we’ll also use
    the graphics templates we developed in [Chapter 3](chapter3.xhtml) to visualize
    our program outputs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可视化是科学研究的关键部分，我们还将使用我们在[第3章](chapter3.xhtml)中开发的图形模板来可视化我们的程序输出。
- en: 'Project 17: Predict the Flight of a Cannonball'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 项目17：预测炮弹的飞行轨迹
- en: Imagine an old castle surrounded by thick defensive walls. The walls have notches
    where vigilant soldiers stand ready to fire cannons on any encroaching enemy.
    Typically, a castle is located on high ground to allow for better visibility over
    the surrounding area, and the cannons themselves are placed at a higher elevation
    relative to the base of the castle to maximize their firing range. Within that
    range, the soldiers can hit targets at a variety of distances by adjusting parameters
    of the cannon. Our question is, how can the soldiers aim a cannon to hit a target
    on the ground *x* distance away?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个古老的城堡，周围被厚重的防御墙包围。墙上有凹口，警觉的士兵们站在那里，随时准备向任何侵犯的敌人开火。通常，城堡建在较高的地方，以便更好地观察周围的情况，而大炮本身也被放置在较高的地方，相对于城堡的基础，以最大化它们的射程。在这个射程内，士兵们可以通过调整大炮的参数来击中不同距离的目标。我们的问题是，士兵们如何瞄准大炮以击中地面上*距离
    x*的目标？
- en: 'Assuming no air resistance for now and assuming that the impact of wind is
    negligible, the distance a cannonball travels is affected by three factors: the
    cannon’s height above ground level, its angle of fire, and the exit velocity of
    the cannonball. The soldiers can’t easily change the height of the cannon or the
    exit velocity of the cannonball, but they can adjust the angle of fire, so that’s
    where we’ll focus our efforts. [Figure 5-1](chapter5.xhtml#fig5-1) diagrams the
    nature of the problem.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设此时没有空气阻力，并且忽略风的影响，炮弹的飞行距离受到三个因素的影响：大炮的高度、发射角度和炮弹的出口速度。士兵们不能轻易改变大炮的高度或炮弹的出口速度，但他们可以调整发射角度，因此我们将把注意力集中在这里。[图5-1](chapter5.xhtml#fig5-1)展示了问题的本质。
- en: '![](../images/Figure5-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.jpg)'
- en: 'Figure 5-1: The path of a cannonball'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：炮弹的飞行路径
- en: The cannonball is fired from point A, which has an elevation of H[0] relative
    to the ground surface, and the goal is to hit point B. The exit velocity of the
    cannonball is *v*[0], and its angle of fire is *θ*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 炮弹从点A发射，点A相对于地面的高度为H[0]，目标是击中点B。炮弹的发射速度为*v*[0]，发射角度为*θ*。
- en: 'Once the cannonball is fired, it becomes a *projectile*, an object in motion
    that has only one force acting upon it: gravity. To arrive at the correct value
    for *θ*, we need to know a little bit about the science of projectiles. First,
    let’s assume that the cannonball is moving in only two dimensions: horizontally
    and vertically. We’ll place the origin of this two-dimensional coordinate system
    at point A. Given the initial velocity of the ball *v*[0], which is projected
    at an angle *θ*, we can write the corresponding x- and y-components of the initial
    velocity as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦炮弹被发射，它就变成了一个*抛射体*，即一个只受一种力作用的运动物体：重力。为了得出*θ*的正确值，我们需要了解一些关于抛射物的科学知识。首先，假设炮弹只在两个维度内运动：水平和垂直。我们将这个二维坐标系的原点设在点A。给定初始速度*v*[0]，它以角度*θ*发射，我们可以将初始速度的x分量和y分量写为：
- en: '*v*[0]x = *v*[0] cos*θ*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*v*[0]x = *v*[0] cos*θ*'
- en: '*  v*[0]y = *v*[0] sin*θ*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*  v*[0]y = *v*[0] sin*θ*'
- en: 'These velocity components tell us how fast the ball will be traveling in the
    horizontal and vertical directions solely due to its initial velocity. Again,
    disregarding the effects of air or wind resistance, no other force is acting on
    the ball horizontally. Therefore, we could say that the velocity in the x-direction,
    *v*x, remains constant:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些速度分量告诉我们炮弹在水平和垂直方向上的运动速度，完全由其初速度决定。同样，忽略空气或风的影响，水平方向上没有其他力作用于炮弹。因此，我们可以说水平方向上的速度*v*x保持不变：
- en: '*  v*x = *v*[0]x = *v*[0] cos*θ*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*  v*x = *v*[0]x = *v*[0] cos*θ*'
- en: 'In the vertical direction, however, the acceleration due to gravity will slow
    the ball’s rise and eventually bring it down to the ground. Thus, we can express
    the resultant velocity in the y-direction, *v*y, as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在垂直方向上，重力加速度会减缓球的上升，最终使其落到地面。因此，我们可以表示垂直方向的合成速度 *v*y，如下所示：
- en: '*  v*y = *v*[0]y − *g t* = *v*[0] sin*θ* − *g t*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*  v*y = *v*[0]y − *g t* = *v*[0] sin*θ* − *g t*'
- en: Here *g* is the acceleration due to gravity, and *t* is time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *g* 是重力加速度，*t* 是时间。
- en: 'Using these expressions for *v*x and *v*y, we can write the *displacement equations*
    for the projectile, which express its x- and y-coordinates, or how far the ball
    has traveled horizontally and vertically, as of a given time *t*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些 *v*x 和 *v*y 的表达式，我们可以写出投射物的 *位移方程*，它们表达了投射物在某一时刻 *t* 的 x 和 y 坐标，或者说球在水平方向和垂直方向上已行进的距离：
- en: $Equation$ (5.1)$Equation$ (5.2) ![](../images/eq5-1-2.jpg)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.1)$Equation$ (5.2) ![](../images/eq5-1-2.jpg)
- en: 'If we now assume that the time to reach the target at point B is *t*[B], then
    the horizontal distance to the target is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在假设到达目标点B所需的时间为 *t*[B]，那么到目标的水平距离为：
- en: $Equation$ (5.3) ![](../images/eq5-3.jpg)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.3) ![](../images/eq5-3.jpg)
- en: 'Over the same time period *t*[B], the projectile will also move vertically.
    It will pass through point C (shown in [Figure 5-1](chapter5.xhtml#fig5-1), the
    ball’s highest elevation, at *H* + H[0]) and then free-fall to the ground while
    continuing to move horizontally at velocity *v*x. When the projectile reaches
    point B (meaning it hits the target), its net vertical displacement *y*[B] will
    be −H[0], which can be expressed using Equation 5.2 as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的时间 *t*[B] 内，投射物还会在垂直方向上运动。它将经过点C（如[图5-1](chapter5.xhtml#fig5-1)所示），球的最高点，位于
    *H* + H[0]，然后自由下落至地面，同时继续以速度 *v*x 水平运动。当投射物到达目标点B时（意味着击中目标），其净垂直位移 *y*[B] 将为 −H[0]，可以通过方程5.2表示为：
- en: $Equation$ (5.4) ![](../images/eq5-4.jpg)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.4) ![](../images/eq5-4.jpg)
- en: 'We don’t actually know how long it will take the cannonball to reach the target,
    however, so we need a way to express *t*[B] in terms of the other variables. Equation
    5.4 is a *quadratic equation*, where the highest power of a variable is 2\. It
    can be solved for the positive value of *t*[B] as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们实际上并不知道大炮球到达目标所需的时间，因此需要找到一种方式，将 *t*[B] 以其他变量表示。方程5.4是一个 *二次方程*，其中变量的最高次方是2。可以通过求解
    *t*[B] 的正值得到：
- en: $Equation$ (5.5) ![](../images/eq5-5.jpg)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.5) ![](../images/eq5-5.jpg)
- en: 'We can now use Equation 5.5 to substitute for *t*[B] in Equation 5.3, which
    gives us the following equation for *x*[B] as a function of *θ*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用方程5.5来替代方程5.3中的 *t*[B]，得到以下关于 *θ* 的 *x*[B] 函数方程：
- en: $Equation$ (5.6) ![](../images/eq5-6.jpg)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.6) ![](../images/eq5-6.jpg)
- en: This equation establishes a relationship between the distance to the target
    *x*[B] and the firing angle *θ*, but it still doesn’t allow us to calculate *θ*
    for a given *x*[B]. What we need is an equation that expresses *θ* in terms of
    *x*[B], not the other way around.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程建立了目标距离 *x*[B] 和发射角度 *θ* 之间的关系，但它仍然无法让我们根据给定的 *x*[B] 计算 *θ*。我们需要的是一个表达 *θ*
    关于 *x*[B] 的方程，而不是反过来。
- en: We have two options to resolve this situation. One is analytical, involving
    rearranging Equation 5.6 and deriving an expression for *θ* in terms of *x*[B].
    It can be done, but it would require a significant amount of mathematical juggling.
    The other option is to use a *numerical method*, which involves solving the problem
    through an iterative process following an algorithm. A numerical method is also
    an approximate method, meaning it won’t produce the exact same solution as the
    theoretical one. However, we can choose the desired degree of precision, and often
    that’s close enough. In fact, for many real-world problems of this nature, we
    may not have any known theoretical solution, in which case a numerical method
    is the only viable option for solving the problem. This is why we’ll use a numerical
    method to answer our cannonball question.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来解决这个问题。一种是解析方法，通过重排方程5.6，推导出 *θ* 关于 *x*[B] 的表达式。虽然可以做，但需要大量的数学运算。另一种方法是使用
    *数值方法*，通过一个迭代过程，根据某个算法来解决问题。数值方法也是一种近似方法，这意味着它不会给出与理论解完全相同的结果。然而，我们可以选择所需的精度，通常这种精度足够高。事实上，对于许多这种类型的实际问题，我们可能根本没有已知的理论解，在这种情况下，数值方法是解决问题的唯一可行选项。这就是为什么我们将使用数值方法来回答我们的大炮问题。
- en: The Strategy
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略
- en: 'We need to take one additional step to make the problem amenable to a numerical
    method: getting *x*[B] onto the right-hand side of Equation 5.6 and turning it
    into a function of *θ*. In other words, we’ll define function *f*(*θ*) as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行一个额外的步骤，使问题适合数值方法：将*x*[B]移到方程 5.6 的右边，并将其转化为*θ*的函数。换句话说，我们将定义函数*f*(*θ*)如下：
- en: $Equation$ (5.7) ![](../images/eq5-7.jpg)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.7) ![](../images/eq5-7.jpg)
- en: To solve our cannonball problem, we now need to find a value of the independent
    variable *θ* that, for a given value of *x*[B], will make the right-hand side
    of Equation 5.7 equal to zero. In mathematical terms, this value is known as the
    *root* of the function. We’ve turned the projectile problem into a root-finding
    problem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的炮弹问题，我们现在需要找到一个自变量*θ*的值，对于给定的*x*[B]，它将使方程 5.7 的右边等于零。用数学术语来说，这个值被称为该函数的*根*。我们已将抛物线问题转化为求根问题。
- en: We could use a number of methods to find the root for Equation 5.7\. In this
    case, we’ll use a simple method called *bisection*, as illustrated in [Figure
    5-2](chapter5.xhtml#fig5-2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法来求解方程 5.7 的根。在本例中，我们将使用一种简单的方法，称为*二分法*，如[图 5-2](chapter5.xhtml#fig5-2)所示。
- en: '![](../images/Figure5-2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.jpg)'
- en: 'Figure 5-2: The elements of the bisection method for root finding'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：二分法求根的元素
- en: 'Let’s assume we’re trying to find the root of a simple linear function *f*(*x*),
    which is a continuous function of variable *x*, as shown in [Figure 5-2](chapter5.xhtml#fig5-2).
    The root is the value of *x* that makes the function equal zero. Here are the
    simple bisection steps for finding the root *x** so that *f*(*x**) = 0:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试找到一个简单线性函数*f*(*x*)的根，它是自变量*x*的连续函数，如[图 5-2](chapter5.xhtml#fig5-2)所示。根是使函数等于零的*x*值。以下是找到根*x*使得*f*(*x*)
    = 0 的简单二分法步骤：
- en: 1.  Locate two values x[1] and x[2] such that they are on the opposite side
    of the root, meaning f(x[1]) < 0 and f(x[2]) > 0.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  找到两个值 x[1] 和 x[2]，使它们在根的两侧，即 f(x[1]) < 0 且 f(x[2]) > 0。
- en: 2.  Find the midpoint x between x[1] and x[2] such that x = (x[1] + x[2])/2.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  找到 x[1] 和 x[2] 之间的中点 x，使得 x = (x[1] + x[2])/2。
- en: 3.  If the absolute value of f(x) is less than some tolerance factor (for example,
    0.0000001), then x is the root, so we’re done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果 f(x) 的绝对值小于某个容差因子（例如，0.0000001），则 x 就是根，我们完成了。
- en: 4.  Otherwise, if f(x) * f(x[2]) > 0, set x[2] = x, else set x[1] = x.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  否则，如果 f(x) * f(x[2]) > 0，则设置 x[2] = x，否则设置 x[1] = x。
- en: 5.  Repeat steps 2 through 4 until the condition in step 3 is met.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  重复步骤 2 到步骤 4，直到满足步骤 3 中的条件。
- en: This method is guaranteed to converge to the root if *f*(*x*) is continuous
    within the initial range [*x*[1], *x*[2]], which also includes the root or roots.
    Without further ado, let’s start coding!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f*(*x*)在初始区间[*x*[1], *x*[2]]内连续且包含根或多个根，则该方法保证会收敛到根。废话不多说，我们开始编码吧！
- en: The Code
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'The bisection method involves only a few lines of code, as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 二分法只涉及几行代码，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start by importing the math library functions ❶ and providing the global
    parameter values ❷. Notice that we import only the math functions we need, separately,
    instead of using import kotlin.math.* to import all math functions. It’s good
    coding etiquette to use only what you need, as it helps keep the namespace clean
    and reduces the chance of introducing bugs, especially when the code is reused.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入数学库函数 ❶，并提供全局参数值 ❷。请注意，我们只导入了需要的数学函数，而不是使用 import kotlin.math.* 来导入所有数学函数。好的编码习惯是只使用所需的功能，因为这有助于保持命名空间的清洁，减少引入bug的机会，尤其是在代码被重复使用时。
- en: In this example, we’ve set the target distance to 400 m, the cannon’s height
    to 25 m, and the cannonball’s initial velocity to 70 m/s. Next, we guess initial
    values for x1 and x2 for the bisection method ❸ and set the function parameter
    f to projectile. Treating projectile as a parameter allows us to reuse the code
    to find the roots of other functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将目标距离设置为400米，火炮高度为25米，炮弹的初速度为70米/秒。接下来，我们为二分法设置初始值 x1 和 x2 ❸，并将函数参数
    f 设置为 projectile。将 projectile 作为参数可以让我们重用代码来找到其他函数的根。
- en: The main() function uses an if...else block to confirm that the initial x1 and
    x2 guesses are located on opposite sides of the root ❹. If true, it calls the
    bisection() function to find the root. If the test fails, the program prints a
    message indicating that the initial guesses weren’t valid.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数使用 if...else 语句块来确认初始的 x1 和 x2 猜测位于根的两侧 ❹。如果条件成立，它调用 bisection() 函数来找到根。如果测试失败，程序会打印一条消息，表示初始猜测无效。
- en: The next code block defines the projectile() function, which calculates the
    right-hand side of Equation 5.7 for a given angle, after first converting the
    angle to radians ❺ as required for the sin() and cos() functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块定义了 projectile() 函数，该函数计算给定角度下方程 5.7 的右侧内容，首先将角度转换为弧度 ❺，以便 sin() 和 cos()
    函数使用。
- en: The final code block is the bisection() function that implements the steps outlined
    earlier. The function takes the two initial guesses as arguments, finds the midpoint
    between them ❻, and then uses a while loop ❼ to make smaller and smaller bisections
    until the midpoint is within the specified tolerance range. The function returns
    the root as x (of type Double).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码块是 bisection() 函数，执行之前概述的步骤。该函数将两个初始猜测作为参数，找到它们之间的中点 ❻，然后使用 while 循环 ❼
    进行越来越小的二分，直到中点位于指定的容差范围内。该函数返回根值作为 x（类型为 Double）。
- en: '#### The Result'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 结果'
- en: 'If you run the program, the output should look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序，输出应该如下所示：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, we have the answer to the cannonball question! For the given initial
    velocity and height of the cannon above the ground, the soldiers need to fire
    the cannon at an angle of 21.91 degrees to hit a target 400 m away.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得出了炮弹问题的答案！在给定的初始速度和大炮离地面高度的情况下，士兵们需要以 21.91 度的角度发射大炮，才能击中 400 米远的目标。
- en: Let’s think about this solution a bit more. Is this the only possible way to
    hit the target? [Figure 5-3](chapter5.xhtml#fig5-3) shows how *f*(*θ*) varies
    with *θ* (for the given parameter values).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再深入思考一下这个解决方案。这是唯一能达到目标的方式吗？[图 5-3](chapter5.xhtml#fig5-3) 显示了 *f*(*θ*) 随
    *θ* 的变化（在给定的参数值下）。
- en: '![](../images/Figure5-3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.jpg)'
- en: 'Figure 5-3: The relationship between f(θ) and θ'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：f(θ) 和 θ 之间的关系
- en: The function follows a parabolic curve, passing through the x-axis twice, so
    it has two different roots for *θ* ≥ 0\. From the given initial guesses, we’ve
    found the first root at point A, but another root is found at point B, where *θ*
    = 64.51 degrees. This is a much steeper angle than the first solution, *θ* = 21.91
    degrees. [Figure 5-4](chapter5.xhtml#fig5-4) shows the paths, or *trajectories*,
    the cannonball will take for both firing angles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数呈抛物线形曲线，穿过 x 轴两次，因此它对 *θ* ≥ 0 有两个不同的根。从给定的初始猜测中，我们已找到第一个根在 A 点，但另一个根在 B 点，那里
    *θ* = 64.51 度。这是一个比第一个解更陡峭的角度，*θ* = 21.91 度。[图 5-4](chapter5.xhtml#fig5-4) 显示了在这两个发射角度下，炮弹的路径或
    *轨迹*。
- en: '![](../images/Figure5-4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.jpg)'
- en: 'Figure 5-4: Two trajectories for the cannonball solutions'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：两个炮弹解的轨迹
- en: While cannonballs fired at either angle will hit the target, the ball will reach
    a much higher elevation and take longer to hit the target when *θ* = 64.51 degrees.
    Which option do you think the soldiers will prefer, and why?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在任何一个角度发射的炮弹都会击中目标，但当 *θ* = 64.51 度时，炮弹将达到更高的高度，且击中目标所需的时间更长。你认为士兵们会更倾向于哪种选择，为什么？
- en: 'Project 18: Design a Fountain with Water Jets'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 18：设计一个水流喷泉
- en: 'In this project, we’ll continue to explore the path of a projectile, but instead
    of chasing a cannonball, we’ll follow a jet of water. Water jets have many familiar
    applications, such as washing cars, watering lawns, and fighting fires. We’ll
    explore a more artistic example: running the water jet through a nozzle assembly
    to create a decorative fountain.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将继续探索抛射物的轨迹，但我们不会追逐炮弹，而是追踪水流。水流喷射有许多常见的应用，例如洗车、浇灌草坪和灭火。我们将探索一个更具艺术感的例子：通过喷嘴组件运行水流，创造一个装饰性喷泉。
- en: A *nozzle* is a narrow opening through which a jet of fluid comes out at a high
    velocity (the fluid can be a gas or a liquid). For a given pressure, the narrower
    the opening of the nozzle, the faster the velocity of the jet. In the nozzle assembly
    used in fountains, several nozzles of different sizes or with adjustable openings
    can be placed at different angles. Designers vary these parameters to create beautiful
    patterns with the water jets. In this case, we’ll try to adjust the nozzle to
    shoot jets into different levels of a multilevel fountain. [Figure 5-5](chapter5.xhtml#fig5-5)
    illustrates the problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*喷嘴* 是一个狭窄的开口，液体或气体以高速从其中喷出。在给定压力下，喷嘴开口越狭窄，喷流的速度越快。在喷泉使用的喷嘴装置中，多个不同大小或可调开口的喷嘴可以以不同角度布置。设计师通过调整这些参数，创造出美丽的水流图案。在这种情况下，我们将尝试调整喷嘴，将喷流射向多层喷泉的不同高度。[图
    5-5](chapter5.xhtml#fig5-5) 说明了这个问题。'
- en: '![](../images/Figure5-5.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-5.jpg)'
- en: 'Figure 5-5: Pointing a nozzle toward a multilevel water fountain'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：将喷嘴指向多层水喷泉
- en: The objective of this exercise is to estimate the velocity of a jet *v* and
    its angle of ejection *θ*, given the desired highest point of the jet’s trajectory,
    (*x*max, *y*max). This high point is set so that the jet will just pass over the
    edge of the water basin at a particular level, as shown in [Figure 5-5](chapter5.xhtml#fig5-5).
    The fountain has four levels, so we have four sets of (*x*max, *y*max), shown
    in [Table 5-1](chapter5.xhtml#tab5-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本次练习的目标是根据喷流轨迹的最高点 (*x*max, *y*max) 来估算喷流的速度 *v* 和喷射角度 *θ*。这个高点设置为喷流恰好从某一特定水平的水池边缘飞过，如[图
    5-5](chapter5.xhtml#fig5-5)所示。喷泉有四个层级，因此我们有四组 (*x*max, *y*max)，如[表 5-1](chapter5.xhtml#tab5-1)所示。
- en: 'Table 5-1: Fountain Parameters'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1：喷泉参数
- en: '| Level | xmax (meters) | ymax (meters) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 层级 | xmax（米） | ymax（米） |'
- en: '| --- | --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 2.25 | 1.5 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2.25 | 1.5 |'
- en: '| 2 | 2.55 | 3.0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2.55 | 3.0 |'
- en: '| 3 | 2.85 | 4.25 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2.85 | 4.25 |'
- en: '| 4 | 3.0 | 5.5 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3.0 | 5.5 |'
- en: The values in this table are defined relative to the nozzle at point (0, 0).
    We’ll use them to calculate the corresponding values of *v* and *θ*. Further,
    we’ll draw the trajectories of the jets by using the canvas feature of JavaFX
    so that we can visualize the solution relative to the water fountain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本表中的数值相对于喷嘴位于点 (0, 0) 定义。我们将利用这些数值来计算对应的 *v* 和 *θ* 值。此外，我们还将通过使用 JavaFX 的画布功能绘制喷流的轨迹，以便我们可以将解与水喷泉进行可视化。
- en: Notice that [Figure 5-5](chapter5.xhtml#fig5-5) shows only a cross section of
    the fountain system, which is circular in shape in three dimensions. The nozzles
    are placed at diametrically opposite positions along the base of the fountain
    system, which is made up of the ground-level basin (not shown), the nozzles, and
    the four-level middle structure. We’ll use the spacing between the nozzles as
    the base width of this fountain system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图 5-5](chapter5.xhtml#fig5-5) 仅显示了喷泉系统的一个截面，该系统在三维空间中呈圆形。喷嘴被布置在喷泉系统底部的对角线位置，该底部由地面水池（未显示）、喷嘴和四层中层结构组成。我们将使用喷嘴之间的间距作为喷泉系统的基础宽度。
- en: The Strategy
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: We need to use three specific equations to solve this problem, all of which
    can be derived from the projectile equations discussed in [Project 17](chapter5.xhtml#pre-17)
    (search online for “projectile motion” or “equations of motion” to learn about
    the derivations, or see the resources listed at the end of the chapter).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用三个特定的方程来解决这个问题，这些方程都可以从[项目 17](chapter5.xhtml#pre-17)中讨论的抛射方程推导出来（在线搜索“抛射运动”或“运动方程”以了解推导过程，或参见本章末尾列出的资源）。
- en: $Equation$ (5.8)$Equation$ (5.9)$Equation$ (5.10) ![](../images/eq5-8-10.jpg)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.8)$Equation$ (5.9)$Equation$ (5.10) ![](../images/eq5-8-10.jpg)
- en: 'We’ve already defined the variables in these equations, except for *t*max,
    which is the time needed for a water particle leaving the nozzle to reach the
    highest point (*x*max, *y*max). We can use Equations 5.9 and 5.10 to find the
    expressions for *θ* and *v* as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了这些方程中的变量，除了 *t*max，这个值表示水滴从喷嘴离开并达到最高点 (*x*max, *y*max) 所需的时间。我们可以使用方程
    5.9 和 5.10 来求解 *θ* 和 *v* 的表达式，如下所示：
- en: $Equation$ (5.11)$Equation$ (5.12) ![](../images/eq5-11-12.jpg)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.11)$Equation$ (5.12) ![](../images/eq5-11-12.jpg)
- en: We’ll use these equations to calculate the angles of ejection and velocities
    for the four levels of the fountain, based on the data provided in [Table 5-1](chapter5.xhtml#tab5-1).
    We’ll also use Equation 5.8 to calculate the trajectories to be drawn with the
    JavaFX library.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些方程来计算四个喷泉级别的喷射角度和速度，基于[表 5-1](chapter5.xhtml#tab5-1)中提供的数据。我们还将使用方程 5.8
    来计算轨迹，并利用 JavaFX 库将其绘制出来。
- en: The Code
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Our project uses the same basic JavaFX template that’s discussed in detail in
    [Chapter 3](chapter3.xhtml). We begin with some overall setup.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目使用了与[第 3 章](chapter3.xhtml)中详细讨论的相同基本 JavaFX 模板。我们从一些整体设置开始。
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first half of the import block imports the necessary graphics features from
    the JavaFX library, and the second half imports the required math functions from
    the kotlin.math library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 导入块的前半部分从 JavaFX 库中导入了必要的图形功能，后半部分从 kotlin.math 库中导入了所需的数学函数。
- en: Next, we define the global parameters and variables. The base width of the fountain
    system has been set to 6.5 m. The coordinates for the highest points of the parabolic
    jets (xMaxJet and yMaxJet) are set by using type DoubleArray. We also create arrays
    to hold the angles and velocities that we’ll be calculating. As we’re imagining
    this fountain to be on Earth, the acceleration due to gravity, g, has been set
    to 9.8 m/s². Finally, we set the required dimensions for the canvas based on the
    width and height of the fountain, with some margins on the sides.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义全局参数和变量。喷泉系统的基础宽度已设为 6.5 米。抛物线水流的最高点坐标（xMaxJet 和 yMaxJet）通过 DoubleArray
    类型进行设置。我们还创建了数组来存储我们将要计算的角度和速度。由于我们设想这个喷泉位于地球上，重力加速度 g 被设定为 9.8 m/s²。最后，根据喷泉的宽度和高度，我们设置了画布所需的尺寸，并在两侧留出了一些边距。
- en: 'The remainder of the project code has three core segments: the ShapeOfWater
    application class and two helper functions, getAngleAndVel() and getTrajectories().
    We’ll look at these in turn.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的项目代码包含三个核心部分：ShapeOfWater 应用程序类和两个辅助函数，getAngleAndVel() 和 getTrajectories()。我们将依次查看这些部分。
- en: The ShapeOfWater Application Class
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ShapeOfWater 应用程序类
- en: The ShapeOfWater application class manages the canvas and calls the helper functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ShapeOfWater 应用程序类管理画布并调用辅助函数。
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class follows the standard JavaFX block we developed in [Chapter 3](chapter3.xhtml),
    which we’ll use throughout this book. Notice the two function calls. The first
    call to getAngleAndVel() calculates the *θ* and *v* for the four sets of coordinates
    provided for the four levels of the fountain. Calling getTrajectories() calculates
    the corresponding trajectories for the water jets and draws them on the canvas.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该类遵循我们在[第 3 章](chapter3.xhtml)中开发的标准 JavaFX 模板，我们将在本书中始终使用此模板。请注意这两个函数调用。第一次调用
    getAngleAndVel() 函数，计算四组坐标点的 *θ* 和 *v*，这些坐标对应于喷泉的四个水流级别。调用 getTrajectories() 函数计算对应的水流轨迹，并将其绘制在画布上。
- en: The class declaration ends with a few lines of print statements to display the
    calculated values of *θ* and *v* (as angle and vel) for the four pairs of (*x*max,
    *y*max) provided. The values are rounded to two decimal places for ease of reading.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明的末尾有几行打印语句，用于显示计算出的 *θ* 和 *v*（作为角度和速度）对于提供的四对 (*x*max, *y*max) 值的结果。为了方便阅读，这些值被四舍五入到小数点后两位。
- en: The getAngleAndVel() Function
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: getAngleAndVel() 函数
- en: The getAngleAndVel() function uses Equations 5.11 and 5.12 to calculate *θ*
    and *v* for the four water jets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: getAngleAndVel() 函数使用方程 5.11 和 5.12 来计算四个水流的 *θ* 和 *v*。
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use zip() with a lambda expression ❶ to work through the pairs of (*x*max,
    *y*max) values, calculating theta and vel for each and storing those values in
    the appropriate arrays. We could have also used a for loop to iterate over the
    coordinates, and you might try that as an exercise. The atan() function gives
    us angles in radians, but we convert the values to degrees before storing them
    in the angles array to make the output more intuitive ❷.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 zip() 和一个 lambda 表达式 ❶ 来处理 (*x*max, *y*max) 值的对，计算每一对的 theta 和 vel，并将这些值存储在相应的数组中。我们也可以使用
    for 循环来遍历这些坐标，你可以尝试这作为一个练习。atan() 函数给出的是弧度的角度，但我们在将其存储到角度数组中之前，将其转换为度数，以使输出更加直观
    ❷。
- en: The getTrajectories() Function
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: getTrajectories() 函数
- en: The getTrajectories() function calculates the trajectories of the jets based
    on the data from getAngleAndVel() and visualizes the results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: getTrajectories() 函数根据 getAngleAndVel() 函数得到的数据计算水流的轨迹，并可视化结果。
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we calculate *t*max for each (*x*max, *y*max) pair by using Equation
    5.8\. We deliberately extend *t*max by 10 percent so that when the trajectory
    is drawn up to that time, we’ll see the jet starting to bend downward toward the
    water basin ❶. Next, we use a while loop ❷ to iterate over 50 even time steps
    between 0 and *t*max. Using while allows us to work with a real-valued (noninteger)
    increment per time step. We couldn’t do that with a for loop, whose iterator can
    only be an integer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用方程 5.8 计算每个（*x*max, *y*max）对的*t*max。我们故意将*t*max延长10％，这样当轨迹绘制到那个时刻时，我们就能看到喷射开始向下弯曲，朝着水池方向
    ❶。接下来，我们使用一个while循环 ❷，在0到*t*max之间迭代50个均匀的时间步长。使用while循环可以让我们在每个时间步长上使用实数（非整数）增量，而使用for循环则不行，因为它的迭代器只能是整数。
- en: Inside the while loop, we use the original displacement Equations 5.1 and 5.2
    introduced in [Project 17](chapter5.xhtml#pre-17) to calculate the successive
    locations of a water particle at each time step, giving us the entire trajectory
    for the water jet from the nozzle to the basin. Instead of saving the values in
    an array for future use, we use them instantly to draw small circles on the canvas
    ❸. By repeating the process for all (*θ*, *v*) pairs and for all time steps, we
    create the two-dimensional profile of the water jets. Notice that we take advantage
    of the symmetric nature of the problem to draw a second set of jets from another
    nozzle on the opposite side of the ground-level basin ❹. For this extra set of
    jets, we only need to adjust the x-coordinates by subtracting x from baseWidth.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环内，我们使用在[项目17](chapter5.xhtml#pre-17)中引入的原始位移方程 5.1 和 5.2 来计算水粒子在每个时间步长的连续位置，从而得到从喷嘴到水池的整个水流轨迹。我们没有将这些值保存在数组中以供未来使用，而是立即用它们在画布上绘制小圆圈
    ❸。通过对所有（*θ*，*v*）对和所有时间步长重复这一过程，我们创建了水流喷射的二维轮廓。注意，我们利用问题的对称性，在水池对面另一侧的喷嘴上绘制第二组喷射
    ❹。对于这一额外的喷射组，我们只需要通过从baseWidth中减去x坐标来调整x坐标。
- en: The Result
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'If you run the downloadable version of the code, the complete 2D solution should
    resemble [Figure 5-6](chapter5.xhtml#fig5-6). This version of the code includes
    two additional functions: drawFountain() and drawNozzles(). The former is used
    to draw the four-level fountain from the given arrays of *x*max and *y*max for
    the water jets, while the latter is used to display the positions of the nozzles
    as shown in [Figure 5-5](chapter5.xhtml#fig5-5). I encourage you to study these
    two functions and understand the logic used to calculate the dimensions of the
    fountain and the positions of the nozzles.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行可下载版本的代码，完整的二维解应该类似于[图 5-6](chapter5.xhtml#fig5-6)。该版本的代码包括两个额外的函数：drawFountain()和drawNozzles()。前者用于根据给定的水流喷射的*x*max和*y*max数组绘制四级喷泉，而后者用于显示喷嘴的位置，如[图
    5-5](chapter5.xhtml#fig5-5)所示。我鼓励你研究这两个函数并理解用于计算喷泉尺寸和喷嘴位置的逻辑。
- en: To change the shape of the trajectories, you can adjust the values of *x*max
    and *y*max for the water jets. The shape of the fountain will be automatically
    adjusted. However, it’s important to ensure that the values of *x*max and *y*max
    are consistent and reasonable. For example, the *x*max and *y*max for level 2
    should be greater than those of level 1, and similar conditions apply to levels
    3 and 4\. Additionally, all values must be nonnegative.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变轨迹的形状，可以调整水流喷射的*x*max和*y*max值。喷泉的形状会自动调整。然而，重要的是要确保*x*max和*y*max的值一致且合理。例如，第二级的*x*max和*y*max应该大于第一级的值，三级和四级也应遵循类似的条件。此外，所有值必须是非负的。
- en: '![](../images/Figure5-6.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-6.jpg)'
- en: 'Figure 5-6: Water jet profiles around a multilevel fountain'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：多级喷泉周围的水流喷射轮廓
- en: 'The values of the nozzle velocities (in m/s) and angles (in degrees) are directly
    printed onscreen as text output when you run the code. The output should look
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 喷嘴的速度（以米每秒为单位）和角度（以度为单位）的值会在运行代码时直接作为文本输出显示在屏幕上。输出应该如下所示：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s not difficult to use this 2D solution to build a real-world 3D fountain.
    Since we previously imagined the fountain system to be circular in shape, all
    we need to do is repeat the solution at certain intervals along the perimeter
    of the circle that passes through the nozzle assemblies. You can also play with
    the code to generate your own unique fountain designs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个二维解来构建现实世界中的三维喷泉并不困难。由于我们之前设想喷泉系统是圆形的，所以我们需要做的就是在通过喷嘴组件的圆周上按一定间隔重复这个解。你还可以修改代码，生成自己独特的喷泉设计。
- en: 'Project 19: Track a Pendulum’s Motion and Phase'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 19：追踪摆锤的运动与相位
- en: A *pendulum* is a body or weight hung from a fixed point with the help of a
    string, chain, or rod. When the pendulum is moved from the stable equilibrium
    of its vertical position, it can freely swing under the influence of gravity.
    In ideal conditions, when no friction or air resistance interferes, the pendulum
    will continue to swing indefinitely once it’s set in motion. Clockmakers have
    long used pendulums to steadily drive mechanical clocks—picture, for example,
    the swinging pendulum of an antique grandfather clock. Other examples of real-life
    pendulums include swings, wrecking balls, and church bells.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*摆锤*是通过一根绳子、链条或杆子从固定点悬挂的物体或重物。当摆锤从其垂直位置的稳定平衡状态被移动时，它会在重力的作用下自由摆动。在理想条件下，当没有摩擦或空气阻力干扰时，摆锤一旦被启动，就会无限期地继续摆动。钟表制造商长期以来使用摆锤来稳定驱动机械钟表——比如，想象一下古老的落地钟摆动的摆锤。现实生活中的摆锤还包括秋千、拆除球和教堂钟铃等。'
- en: 'Pendulums exhibit *simple harmonic motion (SHM)*, defined as the motion of
    an object that is *periodic*, or repeating, and that is driven by two opposing
    forces: an *inertial force* that moves the object away from its equilibrium position
    and a *restoring force* that tries to return the object to its equilibrium position.
    The maximum displacement of the object relative to the mean or equilibrium position
    is called the *amplitude*, and the number of cycles the object goes through per
    unit time is called the *frequency*. The inverse of frequency, which is the time
    it takes to complete one cycle or oscillation, is called the *period*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 摆锤表现出*简谐运动（SHM）*，定义为物体的运动是*周期性的*，即重复的，并且受到两种相反的力驱动：*惯性力*使物体远离其平衡位置，*恢复力*则试图将物体拉回到平衡位置。物体相对于平均或平衡位置的最大位移称为*振幅*，物体在单位时间内经过的周期数称为*频率*。频率的倒数，即完成一个周期或振荡所需的时间，称为*周期*。
- en: 'The simple harmonic motion of a pendulum provides a starting point for understanding
    the more complex periodic motions found in nature, from the vibration of an electron
    to the orbit of a planet about a star. This project introduces the equation for
    the motion of a simple pendulum. It shows you how to use a numerical method to
    solve this equation and calculate the state of the pendulum—that is, its velocity
    and displacement angle—at any given time once the pendulum is set in motion. For
    added realism, we’ll factor in the effect of air resistance to show how it gradually
    dampens the pendulum’s motion. Of course, we’ll codify our model pendulum in Kotlin
    and visualize the results by using the JavaFX tools we learned in [Chapter 3](chapter3.xhtml).
    Our visualization will consist of three charts: one showing the change of the
    pendulum’s velocity over time, one showing the change of its displacement angle
    over time, and one showing the relationship between the two.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 摆锤的简谐运动为理解自然界中更复杂的周期性运动提供了一个起点，从电子的振动到行星围绕恒星的轨道运动。本项目介绍了简单摆的运动方程。它展示了如何使用数值方法来解这个方程，并计算摆锤在任意给定时间的状态——即它的速度和位移角度——一旦摆锤开始摆动。为了增加真实感，我们将考虑空气阻力的影响，展示它如何逐渐减弱摆锤的运动。当然，我们会将我们的模型摆锤编码为
    Kotlin，并通过我们在[第3章](chapter3.xhtml)中学到的 JavaFX 工具可视化结果。我们的可视化将包括三张图表：一张展示摆锤速度随时间变化的图表，一张展示位移角度随时间变化的图表，以及一张展示两者之间关系的图表。
- en: The Motion of a Simple Pendulum
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单摆的运动
- en: A simple pendulum has a single weight, or *bob*, of mass *m* that hangs from
    a thin string of length *l* fixed at point A*.* It’s assumed that the mass of
    the string is negligible compared with the mass of the bob. It’s also assumed
    that the string doesn’t stretch due to the weight of the bob and that the bob
    can move back and forth indefinitely without any friction or loss of energy (meaning
    the total energy of the system is conserved, once set in motion). As the pendulum
    swings, its angular displacement (*θ*) changes, as measured relative to the pendulum’s
    stable equilibrium position (the vertical line passing through point A). [Figure
    5-7](chapter5.xhtml#fig5-7) shows these components of a simple pendulum.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单摆有一个单独的重物，或称为*摆球*，其质量为*m*，它悬挂在固定在A点的细绳上，绳长为*l*。假设与摆球的质量相比，绳子的质量可以忽略不计。还假设绳子不会因摆球的重量而拉伸，并且摆球可以无限期地前后摆动，而没有任何摩擦或能量损失（意味着系统的总能量在开始运动后是守恒的）。随着摆动，摆球的角位移（*θ*）会变化，相对于摆的稳定平衡位置（通过A点的垂直线）来测量。[图5-7](chapter5.xhtml#fig5-7)展示了简单摆的这些组成部分。
- en: '![](../images/Figure5-7.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-7.jpg)'
- en: 'Figure 5-7: Components of a simple pendulum'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-7：简单摆的组成部分
- en: At any point in time, the force of gravity, *mg*, acts on the bob to set it
    in motion. The gravitational force has two components. The first, *mg* cos(*θ*),
    acts along the line of the string and is countered by the tension in the string.
    The second, *mg* sin(*θ*), acts perpendicularly to the string. This is the part
    that isn’t balanced by any other force (assuming no air resistance) and is responsible
    for the harmonic motion of the pendulum.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，重力*mg*作用于摆球，使其运动。重力有两个分量。第一个是*mg* cos(*θ*)，沿着绳子的方向作用，并被绳子的张力抵消。第二个是*mg*
    sin(*θ*)，垂直于绳子作用。这个分量没有被其他任何力平衡（假设没有空气阻力），并负责摆的谐波运动。
- en: 'Let *ω* denote the rate of change of angular displacement, also called the
    *angular velocity*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 设*ω*表示角位移的变化率，也叫做*角速度*：
- en: $Equation$ (5.13) ![](../images/eq5-13.jpg)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.13) ![](../images/eq5-13.jpg)
- en: The right-hand side of Equation 5.13 is called the derivative of *θ* with respect
    to time *t*. Mathematically speaking, the time derivative of a variable gives
    us the instantaneous rate of change of that variable with respect to time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 方程5.13的右侧称为*θ*对时间*t*的导数。从数学上讲，变量的时间导数给出了该变量相对于时间的瞬时变化率。
- en: 'We can now express the equation of motion for this simple pendulum in terms
    of its angular acceleration as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用角加速度来表示这个简单摆的运动方程，如下所示：
- en: $Equation$ (5.14) ![](../images/eq5-14.jpg)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.14) ![](../images/eq5-14.jpg)
- en: An analytical solution to Equation 5.14 would give us an expression for the
    angular displacement *θ* in terms of time *t* and other parameters. However, the
    analytical solution isn’t easy to derive unless we make an additional assumption
    that the maximum displacement *θ*max is relatively small—say, less than 15 degrees.
    This would allow us to replace sin(*θ*) with *θ*, since the two are equivalent
    for small angles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 方程5.14的解析解将给出角位移*θ*相对于时间*t*和其他参数的表达式。然而，解析解不容易推导，除非我们做出一个额外的假设，即最大位移*θ*max相对较小——比如小于15度。这将允许我们用*θ*替代sin(*θ*)，因为对于小角度，二者是等价的。
- en: We don’t want to be limited to just this special case, however. Instead, we’ll
    use the Euler-Cromer numerical method to incrementally solve Equation 5.14 for
    a small time step. This method maintains the conservation of energy inherent in
    simple harmonic motion, and it yields *stable* solutions (a solution is *stable*
    when the numerical approximation doesn’t deteriorate and move away from the theoretical
    solution over time).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不想仅限于这种特殊情况。相反，我们将使用欧拉-克罗梅数值方法，通过一个小的时间步长逐步求解方程5.14。该方法保持简单谐振动中固有的能量守恒，并且能得到*稳定*的解（当数值近似解不会随着时间的推移恶化并偏离理论解时，解就是*稳定*的）。
- en: The Strategy
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'To apply the Euler-Cromer method, we need to change Equation 5.14 from its
    continuous-time form to its discrete-time form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用欧拉-克罗梅方法，我们需要将方程5.14从连续时间形式转化为离散时间形式：
- en: $Equation$ (5.15) ![](../images/eq5-15.jpg)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.15) ![](../images/eq5-15.jpg)
- en: 'Here *δt* is a small, discrete time step. Next, we’ll incorporate the impact
    of air resistance on the pendulum. Air resistance slows down the angular velocity
    as a decelerating force, which can be assumed to be proportional to the angular
    velocity. Assuming *γ* to be the proportionality constant, we can modify Equation
    5.15 as:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*δt*是一个小的离散时间步长。接下来，我们将考虑空气阻力对摆的影响。空气阻力作为一个减速力会减缓角速度，可以假设它与角速度成正比。假设*γ*是比例常数，我们可以将公式5.15修改为：
- en: $Equation$ (5.16) ![](../images/eq5-16.jpg)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.16) ![](../images/eq5-16.jpg)
- en: 'Finally, we’ll write another expression for updating the angular displacement
    *θ*, which follows directly from the definition of angular velocity *ω* in Equation
    5.13 as:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将写出另一个用于更新角位移*θ*的表达式，它直接来自公式5.13中角速度*ω*的定义，如下所示：
- en: $Equation$ (5.17) ![](../images/eq5-17.jpg)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.17) ![](../images/eq5-17.jpg)
- en: 'Here, we are assuming that over a small time interval *δt*, *θ* is changing
    from *θ*t to *θ*t [+ 1]. In reality, *ω* also continues to change over this small
    time period. We recognize this fact by denoting *ω* as a function of time—that
    is, *ω*(*t*)—in Equation 5.17\. However, in discrete-time representation, we can
    use only one discrete value of *ω*, and the Euler-Cromer method requires that
    it be *ω*t [+ 1] to ensure numerical stability. Thus, the final numerical form
    for the equation of motion of a simple pendulum is:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设在一个小的时间间隔*δt*内，*θ*从*θ*t变化到*θ*t [+ 1]。实际上，*ω*在这个小时间段内也会继续变化。我们通过在公式5.17中将*ω*表示为时间的函数——即*ω*(*t*)——来认识到这一点。然而，在离散时间表示中，我们只能使用*ω*的一个离散值，欧拉-克罗默方法要求它为*ω*t
    [+ 1]，以确保数值稳定性。因此，简单摆的运动方程的最终数值形式是：
- en: $Equation$ (5.18) ![](../images/eq5-18.jpg)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.18) ![](../images/eq5-18.jpg)
- en: By starting with initial values for *θ* and *ω*, and by repeatedly using Equations
    5.16 and 5.18, we can calculate the state of a simple pendulum and plot the changes
    of its angular displacement and velocity over time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从*θ*和*ω*的初始值开始，并反复使用公式5.16和5.18，我们可以计算一个简单摆的状态，并绘制其角位移和速度随时间的变化。
- en: The Code
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'The program for modeling our simple pendulum has three main code segments:
    the main application segment coordinating the model, a simplePendulumWithDrag()
    function implementing the equations we’ve discussed, and a singleXYChart() function
    to draw each plot. We’ll review these segments in detail in the same order, starting
    with the main application segment.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用于建模我们简单摆的程序有三个主要代码段：协调模型的主应用程序段，执行我们讨论的方程的simplePendulumWithDrag()函数，以及绘制每个图表的singleXYChart()函数。我们将按顺序详细回顾这些段落，从主应用程序段开始。
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As usual, the main application segment starts with the boilerplate import block
    required for a JavaFX-based app. This time, we’re also going to use a class called
    ScrollPane that can hold a graphics element and provide a scrollable view of it.
    This will help us view all three charts in the same window. The import block also
    includes the math functions we’ll need for this project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，主要的应用代码段以一个JavaFX应用程序所需的标准导入块开始。这次，我们还将使用一个名为ScrollPane的类，它可以容纳一个图形元素，并提供可滚动的视图。这将帮助我们在同一个窗口中查看所有三个图表。导入块还包括我们为这个项目所需的数学函数。
- en: The second code block declares two data classes. We’ll use the XYChartData class
    to hold (*x*, *y*) data points for creating the line charts and the PendulumData
    class to store the state of the pendulum (angular displacement *θ* and velocity
    *ω*) for a specific time *t*. Each XYChartData data point will be fetched from
    the values in a particular PendulumData instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码块声明了两个数据类。我们将使用XYChartData类来存储用于创建折线图的(*x*, *y*)数据点，使用PendulumData类来存储特定时间*t*下摆的状态（角位移*θ*和角速度*ω*）。每个XYChartData数据点将从特定PendulumData实例中的值中提取。
- en: Next, we provide problem-specific and global parameter values. For example,
    we’ve set the initial displacement to -PI/6 (–30 degrees) and the initial velocity
    to 0. The length of the pendulum, measured in meters, is 0.4, and n = 100 means
    we’ll determine the value of the time step (*δt*) by dividing the period of oscillation
    into 100 intervals. We’ve also set the coefficient for air resistance to 0.6 (a
    value of 0 would mean no air resistance).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供问题特定和全局的参数值。例如，我们设置初始位移为-PI/6（-30度），初始速度为0。摆长（以米为单位）为0.4，n = 100表示我们将通过将振荡周期分成100个间隔来确定时间步长(*δt*)的值。我们还将空气阻力的系数设置为0.6（0的值表示没有空气阻力）。
- en: 'Inside the SimplePendulum application class, the problem-specific part of the
    code starts with a call to simplePendulumWithDrag() ❶ that takes in the following
    arguments: the initial displacement *θ*[0], the initial velocity *ω*[0], the length
    of the pendulum *l*, the acceleration due to gravity *g*, the number of time intervals
    per period *n*, and the air resistance coefficient *γ*. As you’ll see shortly
    when we look at the inner workings of this function, it returns a list of PendulumData
    instances, one for each time step, which we store as state.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在SimplePendulum应用程序类中，特定问题的代码部分从调用simplePendulumWithDrag()❶开始，该函数接受以下参数：初始位移*θ*[0]、初始速度*ω*[0]、摆钟的长度*l*、重力加速度*g*、每个周期的时间间隔数*n*，以及空气阻力系数*γ*。如你所见，稍后我们会详细了解该函数的内部工作原理，它返回一个PendulumData实例的列表，每个时间步对应一个实例，我们将其存储为状态。
- en: Next, we create three mutable lists to hold the XYChartData instances that we’ll
    need to draw the line charts illustrating the pendulum’s state variables. We build
    these lists by extracting the elements from each PendulumData instance as needed
    for the three charts ❷. Charts 1 and 2 both show time on the x-axis and displacement
    and velocity on the y-axis, respectively; chart 3 shows displacement on the x-axis
    and velocity on the y-axis.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建三个可变列表来保存我们需要绘制的表示摆钟状态变量的折线图的XYChartData实例。通过从每个PendulumData实例中提取需要的元素来构建这些列表，以便为三个图表提供数据❷。图表1和图表2都将时间显示在x轴上，位移和速度分别显示在y轴上；图表3则将位移显示在x轴上，速度显示在y轴上。
- en: We generate the three charts by making successive calls to the singleXYChart()
    function. The function takes five arguments, four of which have default values
    assigned in the function definition. Thus, we only need to provide a list of type
    XYChartData (for example, list1) and optionally supply values of the other named
    parameters. Notice that for xyChart3, we specify sort = "NONE" so that we can
    correctly plot the (velocity, displacement) pairs without changing their sequence.
    This is a requirement when we consider the air resistance that alters the cyclic
    relationship between the two state variables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过连续调用singleXYChart()函数来生成三个图表。该函数接受五个参数，其中四个参数在函数定义中已分配了默认值。因此，我们只需要提供一个类型为XYChartData的列表（例如，list1），并可以选择提供其他命名参数的值。请注意，对于xyChart3，我们指定sort
    = "NONE"，以便正确绘制（速度，位移）对，而不改变它们的顺序。这是考虑到空气阻力时的要求，因为空气阻力会改变这两个状态变量之间的周期性关系。
- en: We plot the charts by attaching them to root ❸, which we previously assigned
    to a ScrollPane. This scheme allows us to view all three charts inside the same
    window by scrolling up and down or sideways as needed. Finally, the main() function’s
    only job in a JavaFX application is to launch the main application class—in this
    case, SimplePendulum.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将图表附加到先前分配给ScrollPane的root❸来绘制图表。这种方案允许我们通过上下或左右滚动在同一个窗口中查看所有三个图表。最后，main()函数在JavaFX应用程序中的唯一任务是启动主应用程序类——在本例中是SimplePendulum。
- en: The simplePendulumWithDrag() Function
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: simplePendulumWithDrag()函数
- en: In the simplePendulumWithDrag() function, we use the Euler-Cromer method to
    calculate the values of the pendulum’s state variables for a specified number
    of time steps, given the initial conditions and global parameter values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在simplePendulumWithDrag()函数中，我们使用欧拉-克罗梅方法来计算给定初始条件和全局参数值的指定时间步数的摆钟状态变量的值。
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our first order of business is to determine the value of the time step dt (*δt*).
    For that, we need to estimate the pendulum’s period of oscillation *T* ❶, using
    the following formula:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是确定时间步长dt（*δt*）的值。为此，我们需要估算摆钟的振荡周期*T*❶，使用以下公式：
- en: $Equation$ ![](../images/pg195-1.jpg)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ ![](../images/pg195-1.jpg)
- en: Technically, this formula is valid only for initial displacement angles under
    15 degrees, but it provides a good starting approximation. Dividing *T* by the
    number of time intervals per period n gives us the length of each time interval
    ❷.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个公式仅适用于初始位移角度小于15度的情况，但它提供了一个良好的起始近似值。将*T*除以每个周期内的时间间隔数n，可以得到每个时间间隔的长度❷。
- en: Notice that we also arbitrarily set the maximum number of time steps, Nmax,
    to 4 * n intervals to ensure that the simulation period includes at least three
    full cycles of the pendulum’s oscillation (the period of a pendulum gets longer
    as the initial displacement or amplitude gets larger). Feel free to try out other
    values for these parameters, but keep in mind that a larger n (and thus a smaller
    dt), or a longer simulation period, will increase the number of computations and
    require more memory to store all the intermediate values of the state variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还任意设置了最大时间步数 Nmax 为 4 * n 个间隔，以确保仿真周期至少包括摆动的三个完整周期（摆的周期随着初始位移或振幅的增大而变长）。你可以尝试这些参数的其他值，但请记住，较大的
    n（因此较小的 dt）或较长的仿真周期，会增加计算量并需要更多内存来存储所有状态变量的中间值。
- en: After initializing the local variables, parameters, and the mutable list pList
    that saves the state variables (including time), we implement the Euler-Cromer
    method by using a for loop ❸. Inside this loop, we use Equations 5.16 and 5.18
    to calculate omegaNew and thetaNew, along with the updated time timeNew. We store
    these in an instance of PendulumData and add it to pList ❹. Then we assign these
    “new” state variables back to the “old” state variables (for example, setting
    omegaOld = omegaNew ❺) for the next time through the loop. In all, these steps
    are repeated for each time interval, for a total of Nmax times.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化了局部变量、参数以及保存状态变量（包括时间）的可变列表 pList 后，我们通过使用 for 循环 ❸ 实现了欧拉-克罗梅方法。在这个循环内部，我们使用公式
    5.16 和 5.18 来计算 omegaNew 和 thetaNew，以及更新后的时间 timeNew。我们将这些存储在 PendulumData 的实例中，并将其添加到
    pList ❹。然后，我们将这些“新”的状态变量赋值回“旧”的状态变量（例如，将 omegaOld = omegaNew ❺）以备下一次循环使用。总的来说，这些步骤会为每个时间间隔重复
    Nmax 次。
- en: The code segment includes several print statements that summarize the global
    values and parameters used to solve the problem. Then the segment ends by returning
    pList to the calling function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段包含了几个打印语句，汇总了解决问题时使用的全局值和参数。然后，这个代码段通过将 pList 返回给调用函数来结束。
- en: The singleXYChart() Function
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: singleXYChart() 函数
- en: The singleXYChart() function creates a line chart with JavaFX. In this case,
    using the JavaFX charting tools is a more natural choice for creating our visualization
    than using the canvas feature, as we did in [Project 18](chapter5.xhtml#pre-18).
    This time we want to be able to read off the values of the state variables directly
    from the charts, and this would not be easy to do from scratch using the canvas
    (we’d essentially have to write our own charting library).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: singleXYChart() 函数使用 JavaFX 创建一个折线图。在这种情况下，使用 JavaFX 的图表工具比我们在 [第18项目](chapter5.xhtml#pre-18)
    中使用画布功能更自然，因为我们希望能够直接从图表中读取状态变量的值，而这从零开始使用画布实现并不容易（我们基本上得自己编写图表库）。
- en: Most of the code in this segment is boilerplate JavaFX code used for creating
    a line chart. Since this process was discussed in detail in [Chapter 3](chapter3.xhtml),
    we’ll focus only on the problem-specific elements in this code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码段的大部分内容是创建折线图时使用的标准 JavaFX 代码。由于这个过程在 [第3章](chapter3.xhtml) 中已经详细讨论过，因此我们只关注这段代码中的特定问题元素。
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing to notice is that the function takes five arguments, four of
    which are named arguments. We’ve provided default values for the named arguments
    in the function definition, and these defaults will be used unless we supply problem-specific
    values when calling the function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个函数有五个参数，其中四个是命名参数。我们在函数定义中为命名参数提供了默认值，除非在调用函数时提供特定于问题的值，否则这些默认值将被使用。
- en: To keep the chart clean and simple, we turn off markers ❶ and the legend ❷.
    We also turn off the default sorting of x-values when the sort parameter is set
    to "NONE" ❸. As you saw in the main application code, we use this option when
    creating the chart of angular velocity over displacement, because we need to maintain
    the order of (*ω*, *θ*) pairs to correctly capture the cyclic nature of this relationship.
    Finally, we extract the data points for the line chart from data (which is a list
    of XYChartData instances) by deconstructing each item in data into a set of x
    and y values ❹.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持图表的简洁性，我们关闭了标记 ❶ 和图例 ❷。当排序参数设置为“NONE” ❸ 时，我们还关闭了 x 值的默认排序。正如你在主应用程序代码中看到的那样，在创建位移与角速度的图表时，我们使用了这个选项，因为我们需要保持（*ω*，*θ*）对的顺序，以正确捕捉这种关系的周期性特征。最后，我们通过解构数据中的每一项，将数据点提取到折线图中，这些数据点来自数据（它是一个
    XYChartData 实例的列表） ❹。
- en: The Result
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'The program generates a few lines of text output and a scrollable window that
    contains our line charts. The text output should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会生成几行文本输出以及一个包含折线图的可滚动窗口。文本输出应该是这样的：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This output provides a reminder of the parameter values used and especially
    shows the time interval *δt* that we’ve calculated internally based on the estimated
    period of the pendulum. You need to monitor this value if accuracy is a concern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出提供了所用参数值的提示，特别是展示了我们根据摆的估计周期内部计算得到的时间间隔*δt*。如果精度是一个问题，你需要监控这个值。
- en: Regarding the content of the chart window, the first line chart shows how the
    angular displacement varies with time, and the second chart shows the same for
    angular velocity (see [Figure 5-8](chapter5.xhtml#fig5-8)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图表窗口的内容，第一张折线图展示了角位移随时间变化的情况，第二张图则展示了角速度的变化（见[图 5-8](chapter5.xhtml#fig5-8)）。
- en: '![](../images/Figure5-8.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-8.jpg)'
- en: 'Figure 5-8: The angular displacement (left) and angular velocity (right) of
    a pendulum facing air resistance'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：面临空气阻力的摆的角位移（左）和角速度（右）
- en: 'The charts show the pendulum’s periodic pattern decaying, or dampening, due
    to air resistance; otherwise, the maximum displacement and the maximum velocity
    would remain unchanged. Notice the phase difference between *θ* (displacement)
    and *ω* (velocity): *ω* lags *θ* by a fixed distance along the time axis. Specifically,
    whenever *θ* is at its most extreme, *ω* is 0, and vice versa. For example, at
    *t* = 0, *θ* is at its maximum displacement, –π/6 (to the left of the equilibrium
    position), but *ω =* 0; then, at approximately *t* = 0.32, the pendulum passes
    through its equilibrium position (*θ* = 0) and *ω* reaches its maximum magnitude.
    This is because at this location, all of the pendulum’s potential energy becomes
    kinetic energy. Beyond that point, *ω* begins to drop as the kinetic energy converts
    back into potential energy, until *ω* becomes 0 again at the point of maximum
    displacement on the opposite side.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了摆的周期性模式因空气阻力而衰减或减振；否则，最大位移和最大速度将保持不变。注意*θ*（位移）和*ω*（速度）之间的相位差：*ω*滞后*θ*一定距离沿时间轴。具体而言，每当*θ*达到最大值时，*ω*为0，反之亦然。例如，在*t*
    = 0时，*θ*达到最大位移，–π/6（位于平衡位置的左侧），但*ω* = 0；然后，大约在*t* = 0.32时，摆经过平衡位置（*θ* = 0），并且*ω*达到了最大值。这是因为在此位置，摆的所有势能都转化为动能。此后，*ω*开始下降，随着动能转回势能，直到*ω*在对侧最大位移点再次变为0。
- en: This relationship can be shown directly by plotting *ω* against *θ*, which is
    exactly what we’ve done in our third plot. This kind of visualization is known
    as a *phase-space plot*; for a dynamic system in two dimensions, it plots velocity
    *v*(*t*) over displacement *x*(*t*), the common denominator being time, *t*. Also
    called a *phase portrait*, a phase-space plot helps in studying complex system
    behaviors and uncovering relationships between the state variables that might
    otherwise remain undetected. [Figure 5-9](chapter5.xhtml#fig5-9) shows our phase-space
    plot for the pendulum, with *θ* on the x-axis and *ω* on the y-axis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系可以通过将*ω*与*θ*直接绘制出来显示，这正是我们在第三张图中所做的。这种可视化方式被称为*相空间图*；对于二维动态系统，它绘制了速度*v*（*t*）与位移*x*（*t*）的关系，时间*t*是它们的共同分母。相空间图也叫做*相位图*，它有助于研究复杂系统的行为，并揭示状态变量之间的关系，这些关系可能会被忽视。[图
    5-9](chapter5.xhtml#fig5-9)展示了我们为摆绘制的相空间图，*θ*在x轴，*ω*在y轴。
- en: '![](../images/Figure5-9.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-9.jpg)'
- en: 'Figure 5-9: A phase-space plot of a simple pendulum with damped motion'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：一个简单摆的相空间图，包含阻尼运动
- en: The main point to notice in the plot is that while *ω* and *θ* are still related
    through the parameter *t*, both are decreasing due to air resistance. With each
    time step, the pendulum gets a bit slower and its swing a bit narrower—hence the
    distinctive spiral shape of the plot. If you’re wondering what the pattern might
    look like for an undamped pendulum that isn’t experiencing any air resistance,
    you can simply set the drag coefficient *γ* to 0 and run the program again to
    investigate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中需要注意的主要点是，虽然*ω*和*θ*仍然通过参数*t*相关联，但由于空气阻力，它们都在减小。每一个时间步长，摆的运动变得更慢，摆幅也变得更窄——这就是图形呈现独特螺旋形状的原因。如果你想知道没有空气阻力的无阻尼摆的模式是什么样的，可以将阻力系数*γ*设置为0，然后重新运行程序进行探究。
- en: 'Project 20: The Physics of Coffee Cooling'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 20：咖啡降温的物理学
- en: Now we’ll turn our attention from the physics of motion to the physics of heat
    transfer. Imagine you’ve picked up a cup of coffee from your favorite coffee shop
    on your way to work in the morning. It’s a 25-minute drive from the coffee shop
    to your office, during which the coffee will get colder due to heat loss. You
    like to have milk in your coffee, but the milk is kept refrigerated, so adding
    it will further lower the temperature of the coffee. You could add milk right
    away at the coffee shop or wait to add milk from your office refrigerator. Which
    option should you use to keep your coffee as warm as possible?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把注意力从运动物理学转向热传导物理学。想象一下，你早上在去上班的路上，从你最喜欢的咖啡店买了一杯咖啡。从咖啡店到办公室的路程是 25 分钟，在这段时间内，咖啡会因热量损失而变冷。你喜欢在咖啡中加牛奶，但牛奶是冷藏的，所以加入牛奶会进一步降低咖啡的温度。你可以在咖啡店就加牛奶，或者等到在办公室的冰箱里加。为了让咖啡保持尽可能温暖，应该选择哪个选项呢？
- en: We’ll write a Kotlin application to plot the coffee’s change in temperature
    over time in both scenarios. For that, we’ll first need to review Newton’s law
    of cooling, which defines how an object cools due to the loss of heat energy to
    its surroundings. We also have to consider the science of mixing two different
    liquids so we can figure out how to calculate the change of temperature when we
    add cold milk to hot coffee.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个 Kotlin 应用程序来绘制两种情况下咖啡温度随时间变化的图表。为此，我们首先需要回顾牛顿的冷却定律，它定义了物体由于向周围环境散失热能而冷却的方式。我们还需要考虑混合两种不同液体的科学原理，以便计算将冷牛奶加入热咖啡时温度变化的情况。
- en: Newton’s Law of Cooling
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 牛顿冷却定律
- en: 'Newton’s law of cooling states that the rate of change of the temperature of
    an object is proportional to the difference between the object’s temperature and
    the ambient temperature. It can be mathematically expressed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿冷却定律指出，物体温度的变化率与物体温度与周围环境温度的差值成正比。其数学表达式如下：
- en: $Equation$ (5.19) ![](../images/eq5-19.jpg)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.19) ![](../images/eq5-19.jpg)
- en: '*T* is the temperature of the object at time *t*, *T*a is the ambient temperature,
    which is assumed to remain constant, and *k* is the heat transfer coefficient.
    For situations where *T* is greater than *T*a, the greater the value of *k*, the
    quicker the object will cool.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* 是物体在时间 *t* 时的温度，*T*a 是环境温度，假设它保持恒定，*k* 是热传导系数。对于 *T* 大于 *T*a 的情况，*k* 值越大，物体降温的速度越快。'
- en: 'The value of the coefficient *k* depends on the material and surface properties
    of the object, as well as on the temperature of the object itself. When the primary
    method of heat loss is conduction, and convective and radiative losses are negligible,
    *k* can be assumed to remain constant for a small range of temperature variations.
    Our coffee cooling problem meets these requirements well: most of the heat loss
    happens conductively through the wall of the cup, convection is minimized by keeping
    a lid on the cup, and electromagnetic radiation in this temperature range is negligible
    compared to the other two factors.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 系数 *k* 的值取决于物体的材质和表面特性，以及物体本身的温度。当热量主要通过传导方式损失，且对流和辐射损失可以忽略时，*k* 可以假定在小范围的温度变化下保持恒定。我们的咖啡降温问题非常符合这些要求：大部分的热量损失通过杯壁的传导发生，盖上杯盖可以最小化对流，而在这个温度范围内，电磁辐射与另外两个因素相比可以忽略不计。
- en: 'Let’s now look at the solution of Equation 5.19, which is a first-order ordinary
    differential equation. For the initial temperature *T*[0] (at *t* = 0) > *T*a,
    the solution can be expressed as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下方程 5.19 的解，它是一个一阶常微分方程。对于初始温度 *T*[0]（当 *t* = 0 时）> *T*a，解可以表示为：
- en: $Equation$ (5.20) ![](../images/eq5-20.jpg)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (5.20) ![](../images/eq5-20.jpg)
- en: Equation 5.20 will allow us to calculate the temperature of the coffee (with
    or without milk) given the initial coffee temperature *T*[0], the ambient temperature
    *T*a, the elapsed time *t*, and the heat transfer coefficient *k*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 5.20 允许我们计算咖啡的温度（无论是否加奶），给定初始咖啡温度 *T*[0]、环境温度 *T*a、经过的时间 *t* 和热传导系数 *k*。
- en: '#### The Effect of Mixing Liquids'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 混合液体的影响'
- en: When two liquids of different temperatures are mixed together, the hotter liquid
    gets cooler by releasing heat energy, and the colder liquid gets warmer by absorbing
    the released heat. This exchange of heat energy will continue until both liquids
    attain the same temperature.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当两种不同温度的液体混合时，较热的液体通过释放热能变冷，而较冷的液体通过吸收释放的热量变热。这种热量交换将持续，直到两种液体达到相同的温度。
- en: 'Mathematically, the amount of heat *Q* absorbed or released by one of the liquids,
    and its corresponding change in temperature *ΔT*, are related as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，液体吸收或释放的热量 *Q* 与其相应的温度变化 *ΔT* 之间的关系如下：
- en: $Equation$ (5.21) ![](../images/eq5-21.jpg)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (5.21) ![](../images/eq5-21.jpg)
- en: The term *C* in Equation 5.21 is called the *thermal mass* of the object, which
    is the product of its density *ρ*, volume *V*, and specific heat capacity *s*.
    In SI units, *Q* is measured in joules (J), temperature *T* in degrees Celsius
    (°C), *ρ* in kg/m³, *V* in m³, and *s* in J/(kg °C). As a result, the unit for
    *C* will be J/°C. For the coffee cooling problem, since we’ll be working with
    small quantities of liquids, we’ll use grams per milliliter (g/mL) for density,
    mL for volume, and J/(g °C) for specific heat capacity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 公式 5.21 中的 *C* 被称为物体的 *热容量*，它是物体的密度 *ρ*、体积 *V* 和比热容 *s* 的乘积。在国际单位制中，*Q* 的单位是焦耳（J），温度
    *T* 的单位是摄氏度（°C），*ρ* 的单位是千克每立方米（kg/m³），*V* 的单位是立方米（m³），*s* 的单位是焦耳每千克摄氏度（J/(kg °C)）。因此，*C*
    的单位将是 J/°C。对于咖啡冷却问题，由于我们处理的是小量液体，我们将使用克每毫升（g/mL）作为密度单位，毫升（mL）作为体积单位，比热容单位则为 J/(g
    °C)。
- en: 'Say we’re mixing two liquids such that *C*[1], *T*[1], and *T*f are the thermal
    mass, initial temperature, and final temperature for liquid 1, and *C*[2], *T*[2],
    and *T*f are the same for liquid 2\. (Notice that the final temperature for both
    liquids is the same.) If the mixing happens quickly, with no heat exchange with
    the surrounding environment, and if the liquids don’t chemically react and generate
    or absorb heat, the principle of conservation of energy suggests that the net
    change in energy in the system will be zero—that is, *Q*[1] + *Q*[2] = 0\. After
    substituting for *Q*[1] and *Q*[2] using Equation 5.21 and simplifying the results,
    we get the following expression for the final temperature:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们混合两种液体，使得 *C*[1]、*T*[1] 和 *T*f 分别是液体 1 的热容量、初始温度和最终温度，*C*[2]、*T*[2] 和 *T*f
    对应的是液体 2 的相同参数（注意两种液体的最终温度是相同的）。如果混合过程很快，并且没有与周围环境交换热量，同时液体之间没有发生化学反应生成或吸收热量，能量守恒原理表明系统中的净能量变化为零——即
    *Q*[1] + *Q*[2] = 0。通过使用公式 5.21 代入 *Q*[1] 和 *Q*[2] 并简化结果，我们得到以下关于最终温度的表达式：
- en: $Equation$ (5.22) ![](../images/eq5-22.jpg)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (5.22) ![](../images/eq5-22.jpg)
- en: You can use Equation 5.22 to calculate the temperature of the coffee after adding
    milk, either at the coffee shop or when you arrive at the office. Finally, we
    have all the science worked out to solve our problem and enjoy the optimal cup
    of coffee.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用公式 5.22 来计算添加牛奶后咖啡的温度，无论是在咖啡店还是到达办公室时。最终，我们已经把所有科学原理搞清楚，解决了问题，享受一杯完美的咖啡。
- en: The Strategy
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: To identify the right time for adding milk, we need some data on the properties
    of the coffee and milk, as well as the ambient temperature of the environment.
    This data is summarized in [Table 5-2](chapter5.xhtml#tab5-2).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定添加牛奶的最佳时机，我们需要一些关于咖啡和牛奶的属性数据，以及环境的周围温度。相关数据总结在[表 5-2](chapter5.xhtml#tab5-2)中。
- en: 'Table 5-2: Coffee Cooling Problem Data'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2：咖啡冷却问题数据
- en: '| Item | Value and unit |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | 数值和单位 |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Initial temperature of black coffee | 92°C |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 黑咖啡的初始温度 | 92°C |'
- en: '| Volume of black coffee | 250 mL |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 黑咖啡体积 | 250 毫升 |'
- en: '| Density of black coffee | 1 g/mL |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 黑咖啡的密度 | 1 g/mL |'
- en: '| Specific heat capacity of coffee | 4.19 J/(g °C) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 咖啡的比热容 | 4.19 J/(g °C) |'
- en: '| Initial temperature of refrigerated milk | 4°C |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 冷藏牛奶的初始温度 | 4°C |'
- en: '| Volume of milk added to the coffee | 25 mL |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 添加到咖啡中的牛奶体积 | 25 毫升 |'
- en: '| Density of milk | 1.035 g/mL |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶的密度 | 1.035 g/mL |'
- en: '| Specific heat capacity of milk | 3.89 J/(g °C) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶的比热容 | 3.89 J/(g °C) |'
- en: '| Length of the drive from the coffee shop to the office | 25 minutes |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 从咖啡店到办公室的行驶时间 | 25 分钟 |'
- en: '| Heat transfer coefficient for coffee (assumed to be the same with or without
    milk) | 0.0116/minute |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 咖啡的热传导系数（假设加不加牛奶是相同的） | 0.0116/分钟 |'
- en: '| Ambient temperature everywhere | 20°C |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 周围环境温度 | 20°C |'
- en: 'Armed with the science of coffee cooling and the data presented in [Table 5-2](chapter5.xhtml#tab5-2),
    we can now solve the problem by following these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借咖啡冷却的科学原理和[表 5-2](chapter5.xhtml#tab5-2)中呈现的数据，我们现在可以通过以下步骤来解决这个问题：
- en: '**Option 1: Add milk later**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 1：稍后加奶**'
- en: 1.  Calculate the temperature of black coffee after 25 minutes, starting with
    the initial temperature of 92°C.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  计算黑咖啡在 25 分钟后的温度，假设初始温度为 92°C。
- en: 2.  Calculate the final temperature of the coffee after adding 25 mL of milk
    (assuming that mixing and heat exchange happen instantly).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  计算咖啡在加入 25 毫升牛奶后的最终温度（假设混合和热交换瞬间发生）。
- en: '**Option 2: Add milk at the coffee shop**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 2：在咖啡店加奶**'
- en: 1.  Calculate the initial temperature of the coffee when milk is added immediately
    at the coffee shop (assuming that mixing and heat exchange happen instantly).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  计算咖啡在咖啡店立即加奶时的初始温度（假设混合和热交换瞬间发生）。
- en: 2.  Calculate the final temperature of the coffee after 25 minutes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  计算咖啡在 25 分钟后的最终温度。
- en: By comparing the final temperatures from options 1 and 2, we’ll know which option
    will keep the coffee warmer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较选项 1 和选项 2 的最终温度，我们可以知道哪种选项能使咖啡保持更温暖。
- en: The Code
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We’ll develop this program as a JavaFX application so we can plot the coffee’s
    temperature profile over time for both options. For this, we’ll use the same template
    as in [Project 19](chapter5.xhtml#pre-19), with some changes to the problem-specific
    parts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个程序开发为一个 JavaFX 应用程序，以便能够绘制两种选项下咖啡温度随时间变化的曲线。为此，我们将使用与[项目 19](chapter5.xhtml#pre-19)相同的模板，并对特定问题部分进行一些修改。
- en: Let’s start with the problem definition and global parameters, along with the
    problem-specific components in the main application class, MixCoffeeAndMilk.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从问题定义和全局参数开始，同时在主应用程序类 MixCoffeeAndMilk 中添加问题特定的组件。
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The import block for this code segment is similar to that of [Project 19](chapter5.xhtml#pre-19),
    except that we need fewer math functions. In addition to initializing the values
    from [Table 5-2](chapter5.xhtml#tab5-2), we declare a data class called State
    ❶ to save the temperature at a given time. This will help us organize the data
    to be plotted. Among the parameters, notice that we set timeStep to 0.25 minutes
    ❷. This way, we’ll track and plot the coffee’s cooling progress in 15-second intervals.
    This time step may seem surprisingly long compared to the very short time intervals
    from [Project 19](chapter5.xhtml#pre-19), but it’s adequate for this problem because
    the temperature drops smoothly and slowly. Besides, we’re using an analytical
    solution and not a numerical approximation; thus, this choice doesn’t affect the
    accuracy of the calculations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码段的导入块与[项目 19](chapter5.xhtml#pre-19)的导入块类似，不同之处在于我们需要的数学函数较少。除了初始化[表 5-2](chapter5.xhtml#tab5-2)中的值外，我们还声明了一个名为
    State ❶的数据类，用于保存给定时间的温度。这将帮助我们组织需要绘制的数据。在参数中，需要注意的是我们将 timeStep 设置为 0.25 分钟 ❷。这样，我们将以
    15 秒的间隔跟踪并绘制咖啡的降温过程。与[项目 19](chapter5.xhtml#pre-19)中非常短的时间间隔相比，这个时间步长似乎意外地长，但对于这个问题来说足够了，因为温度下降是平滑且缓慢的。此外，我们使用的是解析解，而非数值近似，因此这个选择不会影响计算的准确性。
- en: 'The problem-specific part of the code in the main application class follows
    the same order as the steps outlined in “The Strategy” on [page 211](#pg_211),
    except that we’ve added an extra step (step 5) to further track the coffee as
    it continues to cool at the office (more on that shortly). The code here relies
    on two main helper functions: the newtonCooling() function, which calculates how
    the coffee cools over time, and the tempAfterMixing() function, which calculates
    the immediate temperature after adding the milk. We deploy these functions as
    follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序类中代码的特定部分遵循与“策略”中所列的步骤相同的顺序，见[第 211 页](#pg_211)，不过我们添加了一个额外的步骤（步骤 5），用于进一步追踪咖啡在办公室继续冷却的情况（稍后会详细说明）。这里的代码依赖于两个主要的辅助函数：newtonCooling()
    函数，它计算咖啡随时间的降温过程；以及 tempAfterMixing() 函数，它计算加入牛奶后的即时温度。我们按以下方式部署这些函数：
- en: For step 1, we call newtonCooling() and save the result as state1 ❸. This produces
    a list of type State containing the data points needed to show how the black coffee
    gets colder over time between the coffee shop and the office.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第 1 步，我们调用 newtonCooling() 并将结果保存为 state1 ❸。这将生成一个 State 类型的列表，包含需要的数据点，用于展示黑咖啡在咖啡店和办公室之间随时间变冷的过程。
- en: For step 2, we call tempAfterMixing() to get the final temperature of the coffee
    when milk is added after arriving at the office ❹. This is how warm the coffee
    will be before you take the first sip if you chose option 1 (add milk later).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2步，我们调用tempAfterMixing()来获得在办公室加牛奶后咖啡的最终温度 ❹。这是你选择了选项1（稍后加牛奶）后，喝第一口之前咖啡的温度。
- en: For step 3, we call tempAfterMixing() to calculate the temperature of the coffee
    after adding milk at the coffee shop, before the drive to work ❺.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3步，我们调用tempAfterMixing()来计算在前往工作地点之前，在咖啡店加入牛奶后的咖啡温度 ❺。
- en: For step 4, we call newtonCooling() and save the resulting list of State data
    points as state2 ❻. The temperature property of the last element of this list
    will tell us how warm the coffee will be when you arrive at the office after choosing
    option 2 (add milk first).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4步，我们调用newtonCooling()并将结果列表中的State数据点保存为state2 ❻。该列表最后一个元素的温度属性将告诉我们，当你选择了选项2（先加牛奶）后，到达办公室时咖啡的温度。
- en: 'During each step, we display some output from the simulation either by using
    the println() function or by calling the custom printTimeAndTemp() function, defined
    here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们都会通过调用println()函数或自定义的printTimeAndTemp()函数来显示一些模拟输出，这个函数在此定义：
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have everything we need to solve the problem after step 4, and the results
    are printed on the console. Let’s have a look at the results first, then come
    back to step 5 and the code for visualizing the cooling process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步后，我们已经具备了解决问题所需的一切，结果将会打印在控制台上。让我们先看看结果，然后再回到第5步和可视化冷却过程的代码。
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The final temperature of the coffee is 67.75°C when you add milk at the office
    versus 68.1°C when you add milk at the coffee shop. Though the difference isn’t
    that significant (just 0.35°C), you’ll be better off adding the milk at the coffee
    shop.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在办公室加牛奶时，咖啡的最终温度为67.75°C，而在咖啡店加牛奶时，温度为68.1°C。尽管两者的差异并不显著（只有0.35°C），但你最好还是在咖啡店加牛奶。
- en: Of course, you could figure this out for yourself without any math or code by
    investing in a good-quality thermometer and brewing two cups of coffee. The benefit
    of building a mathematical model of the process, however, is that it not only
    tells us what the temperature will be after 25 minutes but also how the system
    will get there, starting from an initial state and considering interventions such
    as adding milk. Once we have the model, we can play with the parameter values
    and generate answers to many other questions, without making more coffee, adding
    more milk, and taking many temperature measurements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以不借助任何数学或代码，自己通过投资一个高质量的温度计，并泡两杯咖啡来得出结论。然而，建立一个过程的数学模型的好处在于，它不仅能告诉我们25分钟后的温度，还能告诉我们从初始状态开始，经过添加牛奶等干预措施后，系统是如何到达这个状态的。一旦我们有了模型，我们可以调整参数值，生成许多其他问题的答案，而无需再泡更多咖啡、加更多牛奶或进行多次温度测量。
- en: For example, say you get pulled into a meeting right after you arrive at work.
    You have just enough time to add milk to your coffee (if you haven’t added it
    already), but you don’t have time to enjoy said coffee until the meeting ends—another
    25 minutes later. What will the temperature of the coffee be at that point, a
    full 50 minutes after you bought it? Since we already have a mathematical model
    for how the coffee cools over time, this question is quite easy to answer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你到达工作地点后马上被拉进一个会议。你只有足够的时间给咖啡加牛奶（如果你还没加的话），但你没有时间享用这杯咖啡，直到会议结束——大约25分钟后。那么，咖啡在那个时候的温度是多少呢？也就是说，从你买咖啡起的完整50分钟后，咖啡的温度会是多少？由于我们已经有了一个关于咖啡如何随着时间降温的数学模型，这个问题其实很容易回答。
- en: This brings us to step 5, where we use the final temperatures after the first
    25 minutes as the initial temperatures for running the simulation for a further
    25 minutes. For this, we use an additional named parameter start in the newtonCooling()
    function. This parameter lets us offset the time values by 25 instead of starting
    the simulation time over at 0. We call the function twice, generating lists state3
    ❼ (for option 1—milk added at the office) and state4 ❽ (for option 2—milk added
    at the coffee shop).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了第5步，我们使用前25分钟后的最终温度作为运行模拟的初始温度，进行后续25分钟的计算。为此，我们在newtonCooling()函数中使用了一个额外的命名参数start。这个参数允许我们将时间值偏移25，而不是从0开始重新计时。我们调用该函数两次，生成列表state3
    ❼（选项1——在办公室加牛奶）和state4 ❽（选项2——在咖啡店加牛奶）。
- en: Once all four states are calculated, we create a list of type State by using
    the listOf() method and pass this list to the createCoolingChart() function for
    plotting the temperature profiles for the entire 50-minute period.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出所有四个状态，我们通过使用listOf()方法创建一个State类型的列表，并将该列表传递给createCoolingChart()函数，以便绘制整个50分钟期间的温度变化曲线。
- en: Calculating the Temperature Changes
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算温度变化
- en: Now let’s review our two helper functions for calculating the temperature changes
    in the coffee. The newtonCooling() function tracks the temperature change of the
    coffee over a period of time. The tempAfterMixing() function calculates the instantaneous
    temperature change when the milk is mixed in.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下用于计算咖啡温度变化的两个辅助函数。newtonCooling()函数跟踪咖啡在一段时间内的温度变化。tempAfterMixing()函数计算牛奶混合时的瞬时温度变化。
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the newtonCooling() function, we use Equation 5.20 to calculate the temperature
    of the coffee at point t in time ❶. We do this in a while loop, incrementing t
    by dt (set to timeStep) each iteration, until we get to tMax, giving us time and
    temperature data points in 15-second intervals, up to 25 minutes, which we store
    in a list called state ❷.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在newtonCooling()函数中，我们使用方程式5.20计算咖啡在时间点t时的温度❶。我们通过while循环实现这一点，在每次迭代中将t增加dt（设为timeStep），直到达到tMax，获得每隔15秒的时间和温度数据点，直到25分钟，并将其存储在一个名为state的列表中❷。
- en: Notice that we add start to each t before storing it in the list. When start
    isn’t set during the function call, it defaults to 0 and has no effect. However,
    when we call the function to create state3 and state4 (as part of step 5, discussed
    earlier), we set start = timeMax so the timestamps will range from 25 to 50\.
    This allows us to plot all the data in a single chart.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将每个t存储到列表之前，我们都加上了start。当在函数调用时没有设置start时，它默认值为0，不会产生任何影响。然而，当我们调用该函数以创建state3和state4（如前面第5步所讨论）时，我们将start设置为timeMax，因此时间戳将从25到50。这使得我们可以在同一个图表中绘制所有的数据。
- en: The tempAfterMixing() function takes in the separate density, volume, specific
    heat capacity, and premixing temperatures for the milk and coffee and returns
    the final equilibrium temperature once the milk is mixed in, using Equation 5.22.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: tempAfterMixing()函数接受牛奶和咖啡的分离密度、体积、比热容和预混合温度，并使用方程式5.22返回最终的平衡温度。
- en: Plotting the Temperature Profiles
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制温度变化曲线
- en: We’re now ready to plot the two temperature profiles of the cooling coffee.
    For that, we’ll define the createCoolingChart() function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备绘制两条冷却咖啡的温度曲线。为此，我们将定义createCoolingChart()函数。
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use this short function mainly to preprocess the information needed by the
    singleXYChart() function, also used in [Project 19](chapter5.xhtml#pre-19). This
    helps keep the body of the main application class less cluttered. Since we’ve
    discussed how to use singleXYChart() previously, I’ll skip that part here, except
    to mention that we’re now passing a list of lists rather than one single list
    as a collection of data points. Inside the singleXYChart() function, we therefore
    create four different series (from the list of lists, states) and plot them on
    the same chart instead of creating four separate charts. See [Chapter 3](chapter3.xhtml)
    for a review of how to plot a single series versus multiple series in the same
    chart.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个简短的函数主要是为了预处理singleXYChart()函数所需的信息，这个函数也在[项目19](chapter5.xhtml#pre-19)中使用。这样可以保持主应用类的主体部分更加简洁。由于我们之前已经讨论过如何使用singleXYChart()，所以这里就跳过这一部分，唯一需要提到的是，现在我们传递的是一个包含多个列表的列表，而不是单一的列表作为数据点的集合。在singleXYChart()函数内部，我们因此创建了四个不同的系列（来自列表的列表，states），并将它们绘制在同一个图表上，而不是创建四个单独的图表。请参见[第3章](chapter3.xhtml)回顾如何在同一个图表中绘制单一系列与多个系列。
- en: The last line of this function adds the chart object xyChart returned by the
    singleXYChart() function to the root node for display. [Figure 5-10](chapter5.xhtml#fig5-10)
    shows the result.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的最后一行将由singleXYChart()函数返回的图表对象xyChart添加到根节点中以进行显示。[图 5-10](chapter5.xhtml#fig5-10)展示了结果。
- en: '![](../images/Figure5-10.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-10.jpg)'
- en: 'Figure 5-10: The temperatures of black coffee and coffee with milk over time'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：黑咖啡和加奶咖啡的温度随时间变化
- en: The plot spans the entire 50-minute period of the simulation. We can see the
    sudden temperature drops when the milk is added either at the coffee shop (at
    time 0) or at the office (at time 25). After the latter, the temperature profiles
    appear to be almost identical. When we zoom in, however, as in [Figure 5-11](chapter5.xhtml#fig5-11),
    we find a slight difference (less than 1°C).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了整个50分钟模拟过程。我们可以看到，当牛奶加入到咖啡店（时间为0）或办公室（时间为25）时，温度急剧下降。在后者之后，温度曲线几乎完全相同。然而，当我们放大查看时，如同在[图5-11](chapter5.xhtml#fig5-11)中所示，我们发现有轻微的差异（不到1°C）。
- en: '![](../images/Figure5-11.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-11.jpg)'
- en: 'Figure 5-11: A closer look at the coffee cooling problem for t > 25 minutes'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-11：对25分钟后咖啡降温问题的更详细观察
- en: The gap between the two lines indicates that the coffee with milk added at the
    shop will always be a tad warmer. If we continue this experiment for a long time,
    will these temperature profiles still stay separate from each other? Why or why
    not?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 两条线之间的间隙表示在咖啡店加入牛奶的咖啡会始终稍微温暖一点。如果我们继续进行这个实验很长时间，这些温度曲线是否还会保持分开？为什么或为什么不？
- en: 'Project 21: Simulate a Binary Star System'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 项目21：模拟双星系统
- en: In this project, we’ll explore the moves made by “star couples”—not the latest
    objects of celebrity gossip, but rather the stars we can see when we look up at
    the night sky. Many of the bright objects in the universe that appear to the naked
    eye like a single star are in fact two stars in close proximity that “dance” or
    orbit around a common center of rotation. Depending on the stars’ mass, orbital
    velocity, and distance from each other, these *binary star systems* can create
    interesting and unique orbital patterns. We’ll visualize these patterns by creating
    a binary star system Kotlin app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将探索“星座情侣”的运动——这些并不是最新的明星八卦对象，而是我们抬头仰望夜空时能看到的恒星。许多宇宙中看起来像单颗星星的明亮物体，实际上是两颗距离很近的恒星，它们围绕一个共同的旋转中心“舞蹈”或运行。根据恒星的质量、轨道速度以及它们之间的距离，这些*双星系统*可以形成有趣且独特的轨道模式。我们将通过创建一个双星系统的Kotlin应用程序来可视化这些轨道模式。
- en: '#### The Science of Binary Star Systems'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 双星系统的科学'
- en: Binary star systems are governed by Newton’s laws of gravity and motion. Let’s
    consider the model binary system in two dimensions shown in [Figure 5-12](chapter5.xhtml#fig5-12).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 双星系统受牛顿引力定律和运动定律的支配。让我们来看一下[图5-12](chapter5.xhtml#fig5-12)中展示的二维模型双星系统。
- en: '![](../images/Figure5-12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-12.jpg)'
- en: 'Figure 5-12: A two-body system under gravity'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-12：受引力作用的双体系统
- en: 'Our binary system is made up of two astronomical bodies, shown as dark circles
    in the figure. The first body, located at (*x*[1], *y*[1]), has a mass of *M*[1],
    and the second body, located at (*x*[2], *y*[2]), has a mass of *M*[2]. The distance
    from the center of *M*[1] to the center of *M*[2] is *r*, which we can calculate
    using the Pythagorean theorem:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的双星系统由两个天体组成，如图中所示为黑色圆圈。第一个天体位于(*x*[1], *y*[1])，质量为*M*[1]，第二个天体位于(*x*[2],
    *y*[2])，质量为*M*[2]。从*M*[1]的中心到*M*[2]的中心的距离为*r*，我们可以通过勾股定理计算出这个距离：
- en: $Equation$ (5.23) ![](../images/eq5-23.jpg)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.23) ![](../images/eq5-23.jpg)
- en: 'The law of gravity says that these two bodies will be pulled toward each other.
    In this example, ***F***1 and ***F***2 are the gravitational forces acting on
    body 1 and body 2, respectively. Notice that these forces are *vectors*, meaning
    they have both magnitude and direction. (We indicate vectors with **boldface**
    type.) According to the law of gravity, the force acting on body 1 (***F***1)
    can be expressed as:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 引力定律表明，这两个天体会互相吸引。在这个例子中，***F***1和***F***2分别是作用在天体1和天体2上的引力。请注意，这些力是*向量*，即它们既有大小也有方向。（我们用**粗体**表示向量。）根据引力定律，作用在天体1上的力（***F***1）可以表示为：
- en: $Equation$ (5.24) ![](../images/eq5-24.jpg)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.24) ![](../images/eq5-24.jpg)
- en: 'In Equation 5.24, *G* is a gravitation constant, *F* is the magnitude of the
    force vector, and ***ȓ*** is a unit vector pointing from body 1 toward body 2\.
    Further, Newton’s second law of motion says that the force ***F***1 acting on
    body 1 of mass *M*[1] will create an acceleration ***a***1 along the direction
    of the force such that:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程5.24中，*G*是引力常数，*F*是力向量的大小，***ȓ***是指向天体2的单位向量。此外，牛顿的第二定律告诉我们，作用在质量为*M*[1]的天体1上的力***F***1将沿着力的方向产生加速度***a***1，使得：
- en: $Equation$ (5.25) ![](../images/eq5-25.jpg)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.25) ![](../images/eq5-25.jpg)
- en: 'We can combine Equations 5.24 and 5.25 to write expressions for the x- and
    y-components of acceleration ***a***1 as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合方程式5.24和5.25，写出加速度***a***1的x和y分量的表达式，如下所示：
- en: $Equation$ (5.26)$Equation$ (5.27) ![](../images/eq5-26-27.jpg)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.26)$Equation$ (5.27) ![](../images/eq5-26-27.jpg)
- en: 'Finally, Newton’s third law of motion requires that ***F***1 = −***F***2. Thus,
    we can add a negative sign to the right-hand side of Equations 5.26 and 5.27 and
    replace *M*[1] with *M*[2] to calculate the acceleration components acting on
    body 2 due to ***F***2 as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，牛顿的第三定律要求***F***1 = −***F***2。因此，我们可以在方程式5.26和5.27的右侧添加负号，并将*M*[1]替换为*M*[2]，以计算由于***F***2作用于物体2的加速度分量，如下所示：
- en: $Equation$ (5.28)$Equation$ (5.29) ![](../images/eq5-28-29.jpg)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.28)$Equation$ (5.29) ![](../images/eq5-28-29.jpg)
- en: To simulate the orbits of a binary system, we’ll first use these equations for
    the x- and y-components of acceleration to calculate the respective velocity components
    of the stars, then use those velocities to update the positions of the stars of
    our binary system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟双星系统的轨道，我们将首先使用这些加速度的x和y分量的方程，计算恒星的相应速度分量，然后使用这些速度来更新双星系统中恒星的位置。
- en: The Strategy
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'In this section, we’ll develop a simple algorithm to track the stars in a binary
    system once they’re set in motion. First, however, we need to consider what units
    of measurement are appropriate to the cosmic scale of our astronomical calculations.
    We’ll use the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的算法来跟踪双星系统中恒星的运动。首先，我们需要考虑适合我们天文计算的宇宙尺度的度量单位。我们将使用以下单位：
- en: For mass, we’ll use M[ʘ], which is the mass of our sun. One solar mass is approximately
    2 × 10^(30) kg, about 333,000 times the mass of Earth.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于质量，我们将使用M[ʘ]，它是我们太阳的质量。一个太阳质量大约为2 × 10^(30)千克，约为地球质量的33.3万倍。
- en: For distance, we’ll use the astronomical unit (AU), which is the average distance
    between the sun and Earth. One AU equals 149,597,870.7 km.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于距离，我们将使用天文单位（AU），它是太阳与地球之间的平均距离。1 AU等于149,597,870.7公里。
- en: For time, we’ll use the solar year (yr) as the standard unit, which is equal
    to 365 days, 5 hours, 48 minutes, and 46 seconds.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间单位我们将使用太阳年（yr），它等于365天5小时48分钟46秒。
- en: Given these basic units, the unit for velocity will be AU/yr, and the unit for
    acceleration will be AU/yr². This, in turn, gives us a gravitational constant
    *G* of 4π² AU³ yr^(–2) M[ʘ]^(–1).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些基本单位，速度的单位将是AU/yr，加速度的单位将是AU/yr²。这样，得出的引力常数*G*为4π² AU³ yr^(–2) M[ʘ]^(–1)。
- en: 'Now we’re ready to move on to the algorithm, which is similar to the algorithm
    used in [Project 19](chapter5.xhtml#pre-19). Here are the steps we’ll follow to
    calculate the positions of the binary stars:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进入算法部分，该算法与[项目19](chapter5.xhtml#pre-19)中使用的算法相似。以下是我们将用来计算双星位置的步骤：
- en: 1.  Get the initial position and velocity vectors (in terms of x- and y-components)
    for the binary stars (including their masses and the gravitation constant, G).
    Use the system of units we just discussed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  获取双星的初始位置和速度向量（按x和y分量表示），包括它们的质量和引力常数G。使用我们刚刚讨论的单位系统。
- en: 2.  Calculate the distance r between the stars at a given time t, using Equation
    5.23.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  计算在给定时间t下，恒星之间的距离r，使用方程式5.23。
- en: 3.  Calculate x- and y-components of the accelerations, using Equations 5.26
    through 5.29.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  计算加速度的x和y分量，使用方程式5.26到5.29。
- en: '4.  Choose a small enough time step *dt* and update the velocity and position
    vectors, using the Euler-Cromer rule. The components of the velocity and position
    vectors along the x-axis can be calculated as:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  选择一个足够小的时间步长*dt*并使用欧拉-克罗梅尔法则更新速度和位置向量。沿着x轴的速度和位置向量分量可以计算如下：
- en: $Equation$ (5.30)$Equation$ (5.31) ![](../images/eq5-30-31.jpg)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (5.30)$Equation$ (5.31) ![](../images/eq5-30-31.jpg)
- en: 5.  Repeat step 4 for the components along the y-axis for both stars.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个恒星的每个分量，重复步骤4，沿着y轴进行计算。
- en: 6.  Repeat steps 2 through 5 until the stopping condition is met. We’ll set
    the maximum number of iterations as the stopping condition.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  重复步骤2到5，直到满足停止条件。我们将最大迭代次数作为停止条件。
- en: Of course, the whole point of making all these calculations is to be able to
    sit back and enjoy watching the dance steps of the stars. After each cycle through
    the algorithm, we’ll animate the stars’ motion by plotting the new positions by
    using the canvas feature of JavaFX. We’ll also give each star a trail to better
    illustrate the orbital paths. A significant part of the code for this app is devoted
    to displaying and managing the moving objects on the canvas.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，进行这些计算的全部目的是能够坐下来，享受观看星体舞步的过程。在算法的每个周期后，我们将通过使用 JavaFX 的画布功能来绘制星体的新位置，从而实现星体的运动动画。我们还将给每个星体添加一条轨迹，以更好地展示其轨道路径。本应用程序的大部分代码都用于在画布上显示和管理这些移动物体。
- en: The Code
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We’ll review the code segments for this project in the same order as they appear
    in the app. Let’s start with the imports and declarations that come before the
    SimulateBinarySystem application class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照应用程序中出现的顺序回顾本项目的代码段。让我们从导入和声明开始，接着是 SimulateBinarySystem 应用程序类之前的部分。
- en: '[PRE16]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first three lines of the import block load important tools (KeyFrame, Timeline,
    and Duration) for creating frame-by-frame animations with JavaFX. The remaining
    imports are similar to what we’ve used previously in this chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 导入块的前三行加载了用于创建逐帧动画的 JavaFX 重要工具（KeyFrame、Timeline 和 Duration）。剩下的导入与本章之前使用的类似。
- en: After the imports, we declare a Star data class to hold the properties needed
    for representing a star, including its mass, x- and y-coordinates, and velocity
    components. The size property, specified in pixels, is the diameter of the circle
    that will represent a particular star; xOld and yOld will hold a copy of the star’s
    current position vector before updating it (needed to generate its trails); trailCount
    sets the number of small dots that will follow a star to mark its trail; and color
    defines the color used to draw the star and its trail. Because this book is printed
    in black and white, all figures have been generated with the default color (BLACK),
    but feel free to experiment with any color you like when you run the code on your
    device.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，我们声明了一个 Star 数据类，用于存储表示星体所需的属性，包括质量、x 和 y 坐标、以及速度分量。size 属性（以像素为单位）是表示某个星体的圆的直径；xOld
    和 yOld 会保存星体当前位置的副本，以便在更新之前使用（用于生成轨迹）；trailCount 设置将跟随星体的小点数量，以标记其轨迹；color 定义了绘制星体及其轨迹时使用的颜色。由于本书是黑白印刷的，所有图形都使用默认颜色（黑色）生成，但在你的设备上运行代码时，随意尝试任何颜色都可以。
- en: The problem definition and global declaration section starts with creating stars
    as a list of two Star objects. We initialize each with its mass, size, current
    x- and y-coordinates (x, y), components of the velocity vector along the positive
    x- and y-axes (vx, vy), and color for drawing the star on the canvas. Since we’re
    not going to draw the stars to proper scale, I’m just using two arbitrary sizes
    that might look reasonable given the size of the canvas. You could make them proportional
    to their masses if you have reason to believe that the stars have similar densities.
    Also, notice that we’ve set the gravitational constant G to 4π² because we’re
    using the astronomical units mentioned earlier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 问题定义和全局声明部分开始时，创建了一个包含两个星体对象的星体列表。我们为每个星体初始化了质量、大小、当前的 x 和 y 坐标（x, y）、沿着正 x
    轴和 y 轴的速度向量分量（vx, vy），以及用于在画布上绘制星体的颜色。由于我们不打算按正确的比例绘制星体，因此这里只使用了两个任意大小，这在画布的大小下看起来可能合理。如果你有理由相信这些星体的密度相似，也可以将它们的大小与质量成比例地调整。同时，注意我们将引力常数
    G 设置为 4π²，因为我们使用的是之前提到的天文单位。
- en: In the next part of the code, we first set the width (canvasW) and height (canvasH)
    of the canvas to 800 pixels (without any scaling, this would be equivalent to
    800 AU in both directions). The durationMillis parameter sets the duration per
    animation frame to 4.0 milliseconds. The frameCountMax = 50_000 means the app
    will stop simulating the binary system after 50,000 frames. If dt = 1 year, that
    will be equivalent to observing the system for 50,000 years! You may not need
    to simulate the system for such a long time (you can terminate the app at any
    time by closing the animation window). However, it’s a good idea to run a simulation
    for several rounds of full orbits (when the expected orbit is either a circle
    or an ellipse) to confirm that the simulated orbits are stable. Once this is confirmed,
    you can play God with the parameters and see how the movements of the stars go
    crazy!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The final code segment in this block sets parameters for the trails, allowing
    us to visualize the path traced by the stars during live simulations. By default,
    the TRAIL_CODE is set to YES, which means that trails for both stars will be drawn
    on the canvas alongside their parent stars. Each trail is composed of small dots
    or tracers that follow the parent star. The dots’ coordinates are saved in a two-dimensional
    array called trails, where each element represents x- and y-coordinates stored
    as a Pair of type <Double, Double>. To ensure that the full orbital path is traced
    out by the trails when the orbit is stable, we set the number of trail elements
    to 6500. Try to keep this number to a minimum, however; otherwise, too many dots
    in the trails can slow down the animation and force you to adjust the duration
    of the frame.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The SimulateBinarySystem Application Class
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The core part of the app is the SimulateBinarySystem application class, where
    we combine Kotlin with JavaFX to drive the key parts of the app and run the animation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first section of this code segment is boilerplate JavaFX code that we’ve
    used before. Notice that this time we’re setting the origin of the coordinate
    system to the center of the canvas ❶. Also, the positive y-axis direction is set
    to point upward ❷.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the simulation block, we first call the initialPositions() function
    ❸, which draws the x- and y-axes on the canvas, places the stars on the canvas
    based on their position vectors, and initializes an array of type Pair called
    trails if the TRAIL_CODE is set to YES. Since this function is very short, I’ll
    show it and the drawAxes() function, which is called from within the initialPositions()
    function, right here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we use a forEachIndexed structure for iteration instead of a standard
    for loop in the initialPositions() function. This is because we need the index
    property of the stars to create the respective trails in the second part of the
    function. Each star’s trail consists of trailMAX number of dots, or tracers, which
    for now we initialize to the same starting position as the star itself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`initialPositions()`函数中，我们使用了`forEachIndexed`结构进行迭代，而不是标准的`for`循环。这是因为我们需要星星的索引属性来在函数的第二部分创建相应的轨迹。每颗星星的轨迹由`trailMAX`个点或跟踪器组成，目前我们将其初始化为与星星本身相同的起始位置。
- en: Regarding the drawAxes() function, notice how all the graphics commands involving
    the graphics context gc have been grouped together using the scoping function
    with(). This saves us from having to type gc multiple times.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`drawAxes()`函数，注意所有涉及图形上下文`gc`的图形命令是如何通过使用作用域函数`with()`组合在一起的。这可以避免我们多次输入`gc`。
- en: Getting back to the application class, the animation of the binary star system
    is implemented by using a combination of Timeline and KeyFrame with a {lambda}
    expression. We first create a Timeline variable t ❹ and set a few other local
    parameters. The parameter frameCount is initially set to 0 and later incremented
    by 1 per frame. The dt parameter is the time step used in updating the velocity
    and position vectors. We’ve set it to 1, meaning each animation frame represents
    1 year (this may seem too large, but it’s all relative; the period for this star
    system is 722 Earth years long). Notice that the iterMax parameter is set to 1,
    which means the position and velocity vectors are updated only once per frame.
    If we wanted, we could use a different dt and iterMax combination to carry out
    iterMax updates of the position and velocity vectors before changing frames.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 回到应用类，二元星系统的动画通过使用`Timeline`和`KeyFrame`的组合以及{lambda}表达式来实现。我们首先创建一个`Timeline`变量`t`❹并设置其他一些局部参数。参数`frameCount`初始值为0，之后每帧递增1。参数`dt`是用于更新速度和位置向量的时间步长。我们将其设置为1，这意味着每个动画帧表示1年（这看起来可能太大，但这都是相对的；这个星系统的周期是722个地球年）。注意，`iterMax`参数设置为1，这意味着每帧只更新一次位置和速度向量。如果需要，我们可以使用不同的`dt`和`iterMax`组合，在切换帧之前对位置和速度向量进行`iterMax`次更新。
- en: 'Inside the KeyFrame class instance ❺, the {lambda} expression specifies what
    happens between the frame updates at a frequency specified by the Duration.millis()
    function. First, we call updateStarPositions() to calculate each star’s acceleration,
    velocity, and position. We then call drawStars() to update the positions of the
    stars on the canvas, and finally, we call updateAndDrawTrails() to trace out the
    trails for both stars. (We’ll review these functions separately.) Before exiting
    the KeyFrame block, we check for the stopping condition: if frameCount (the number
    of frames displayed) reaches frameCountMax, the timeline ends, and the animation
    is terminated ❻.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KeyFrame`类实例❺内部，{lambda}表达式指定了在由`Duration.millis()`函数指定的频率下，帧更新之间发生的事情。首先，我们调用`updateStarPositions()`来计算每颗星星的加速度、速度和位置。然后，我们调用`drawStars()`来更新画布上星星的位置，最后，我们调用`updateAndDrawTrails()`来绘制两颗星星的轨迹。（我们将分别回顾这些函数。）在退出`KeyFrame`块之前，我们检查停止条件：如果`frameCount`（显示的帧数）达到`frameCountMax`，则时间线结束，动画终止❻。
- en: The final three lines complete the Timeline implementation. First, we supply
    the KeyFrame instance (k) to the timeline ❼. Next, we set cycleCount to INDEFINITE,
    which means continue the timeline until a stopping condition is met inside the
    KeyFrame or elsewhere in the program. Finally, t.play() starts the animation and
    sets the stars in motion.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行完成了`Timeline`的实现。首先，我们将`KeyFrame`实例（k）提供给时间线❼。接着，我们将`cycleCount`设置为`INDEFINITE`，这意味着继续执行时间线，直到在`KeyFrame`或程序的其他部分满足停止条件。最后，`t.play()`开始动画并使星星开始运动。
- en: '##### The updateStarPositions() Function'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '##### `updateStarPositions()`函数'
- en: The updateStarPositions() function implements the physics of binary stars in
    motion by using the formulas and algorithms we’ve discussed. The function takes
    in two arguments—a list of type Star called stars and the time step dt—and doesn’t
    return anything, since the function makes its updates directly to the globally
    accessible properties of the stars.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateStarPositions()`函数通过使用我们讨论过的公式和算法实现了运动中的二元星的物理学。该函数接受两个参数——一个名为`stars`的`Star`类型的列表和时间步长`dt`——并不返回任何值，因为该函数直接更新星星的全局可访问属性。'
- en: '[PRE19]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function starts by calculating the distance between the two stars by using
    Equation 5.23\. We then use the scalar part of Equation 5.24 to calculate the
    magnitude of the gravitational force that both stars will experience ❶. Next,
    we iterate over the stars list and update the acceleration, velocity, and position
    for both stars per Equations 5.26 through 5.31 ❷. Notice that we save the current
    position vectors in the xOld and yOld properties of the stars before updating
    x and y ❸. We’ll need these so the stars’ trails will lag the stars themselves
    by one time step. Also notice how the variable sign switches from 1 to -1 at the
    end of the first iteration ❹. This inverts the direction of the force acting on
    the second star to ensure that ***F***1 = −***F***2.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The drawStars() Function
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The drawStars() function simply updates the positions of the stars on the canvas
    to make them move. It takes in one parameter, the graphics context, and returns
    nothing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function starts by clearing the canvas ❶. Then we redraw the objects in
    three stages. First, we call the drawAxes() function, which we’ve already reviewed,
    to draw the axes ❷. Since this happens first, the other objects (for example,
    the stars and the trails) will be drawn on top of the axes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Next, we connect the centers of the stars by using a dashed line ❸. The argument
    sequence (2.0, 4.0, 4.0, 2.0) means the dash lengths will be set in cycles of
    2, 4, 4, and 2 pixels. This line helps identify the center of rotation (the point
    where it intersects the x-axis) and will grow and shrink like a spring with the
    movements of the stars, making the simulation more interesting. For a circular
    and concentric orbit, this line also helps visually confirm that at any moment
    the binary stars are placed in diametrically opposite positions about the center
    of rotation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use a for loop to iterate over the stars and draw them in their
    new positions ❹. Notice the use of scaleFactor while drawing the stars. This is
    a global variable that allows us to change the scale of the simulation on the
    fly without going through more complicated rescaling schemes that we’ve used elsewhere
    in the book. For this problem, since the orbit shapes and sizes can vary significantly
    during the simulations, I suggest that you adjust this scale factor based on your
    own setup. I used scaleFactor = 4 for the first simulation (for stable circular
    orbits) and scaleFactor = 1 for the second simulation (for stable elliptical orbits).
    In the latter case, the distance between the stars *r* varies significantly during
    the simulation, and we need to allocate more space on the canvas to fully outline
    the orbits.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '##### The updateAndDrawTrails() Function'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The two-in-one updateAndDrawTrails() function updates the trails and draws them
    at the same time. It takes one parameter, gc, and doesn’t return anything, just
    like the drawStars() function.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first block in this function iterates over the stars list and updates the
    positions of the trail elements. Recall that the initialPositions() function started
    all the tracers at the same position as the star itself, but we haven’t drawn
    any of them yet. Now we move the tracers one at a time (for each star). First,
    we check to see that unassigned tracers are ready to be moved to a new location
    by ensuring that star.trailCount < trailMAX. Otherwise, we reset trailCount to
    0 ❶. Each time a star moves to a new position, we assign the star’s old position
    to the next available tracer—the one at position [index][star.trailCount] in the
    trails array ❷. This is why we always save the old positions of the stars before
    updating them in the updateStarPositions() function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This process continues as long as tracers remain to be moved from the initial
    position. Once all the tracers have been assigned new positions on the canvas
    (and the stars continue to move), resetting trailCount lets us recycle them by
    bringing the last one to the first position (right next to the star).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the tracer positions have been updated, the second block in the function
    draws the trails for both stars. For each trail, we use the same color as the
    color of the star it follows ❸ to draw the tracers. Finally, all the trails are
    drawn on the canvas, based on their most recent coordinates ❹. Once all the tracers
    are placed on the canvas, each trail will follow its parent star.  #### The Result'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: When you run the app, you should see a dynamic simulation of the binary star
    system in motion, as opposed to a static image. You’ll see the stars continuously
    dancing around each other on the screen until you close the window or wait for
    the frameCount to hit its limit. [Figure 5-13](chapter5.xhtml#fig5-13) shows screenshots
    of two different runs of the app.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-13.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-13: A binary star system with concentric, circular orbits (left) and
    a binary star system with elliptical orbits (right)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The example on the left shows a binary star system with concentric, circular
    orbits, meaning one star’s orbit is entirely contained within the other. For this,
    we used the initial conditions shown in the code listings. The example on the
    right simulates a system with elliptical orbits by using the same initial conditions,
    except x = -50.0 for star 1, x = 90.0 for star 2, and scaleFactor = 1.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to play around with the simulation by tweaking the initial conditions.
    Depending on the parameters, you may end up with an unstable system, in which
    case the stars fly off the screen or crash into each other. In fact, it’s much
    harder to create a stable system like the ones shown in the figure. This instability
    also happens with real binary star systems as they get perturbed by a variety
    of external forces that offset the delicate balance needed to maintain a stable
    orbit.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used Kotlin and laws of physics to solve a variety of science
    problems—from the projectile motion of cannonballs and water jets, to swinging
    pendulums and cooling cups of coffee, to the out-of-this-world dance of a binary
    star system. Along the way, we developed increasingly complex mathematical models
    of physical systems to study their behavior. To do so, we went beyond the basics
    of Kotlin, harnessing JavaFX’s visualization and animation tools to effectively
    display the results of our code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bate, Roger R., Donald D. Mueller, Jerry E. White, and William W. Saylor. *Fundamentals
    of Astrodynamics*. 2nd ed. Mineola, NY: Dover, 2020.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Bennett, Andrew G. “Runge-Kutta Methods.” Accessed June 15, 2024\. *[https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php](https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php)*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Cromer, Alan. “Stable Solutions Using the Euler Approximation.” *American Journal
    of Physics* 49, no. 5 (May 1981): 455–459\. *[https://doi.org/10.1119/1.12478](https://doi.org/10.1119/1.12478)*.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Demanet, Laurent. “Introduction to Numerical Analysis.” MIT OpenCourseWare,
    2012\. Accessed June 15, 2024\. *[https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/](https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/)*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Halliday, David, Robert Resnick, and Jearl Walker. *Fundamentals of Physics*.
    12th ed. New York: Wiley & Sons, 2021.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Seyr, Alexander Josef. “Numerical Simulation of the Planetary Motions in the
    Solar System with Runge Kutta Methods.” November 6, 2020\. *[https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf](https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf)*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Young, Hugh, and Roger Freedman. *University Physics*. 15th ed. New York: Pearson,
    2020.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
