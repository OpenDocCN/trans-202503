- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 5 MODELING AND SIMULATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll venture into several mini science projects that will
    further strengthen your coding abilities in Kotlin. In addition, the mini projects
    of this chapter will enhance your problem-solving skills by showing how to apply
    basic laws of nature and mathematics to solve problems that are very difficult
    to answer without the help of a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Since visualization is a key part of scientific investigation, we’ll also use
    the graphics templates we developed in [Chapter 3](chapter3.xhtml) to visualize
    our program outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 17: Predict the Flight of a Cannonball'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an old castle surrounded by thick defensive walls. The walls have notches
    where vigilant soldiers stand ready to fire cannons on any encroaching enemy.
    Typically, a castle is located on high ground to allow for better visibility over
    the surrounding area, and the cannons themselves are placed at a higher elevation
    relative to the base of the castle to maximize their firing range. Within that
    range, the soldiers can hit targets at a variety of distances by adjusting parameters
    of the cannon. Our question is, how can the soldiers aim a cannon to hit a target
    on the ground *x* distance away?
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming no air resistance for now and assuming that the impact of wind is
    negligible, the distance a cannonball travels is affected by three factors: the
    cannon’s height above ground level, its angle of fire, and the exit velocity of
    the cannonball. The soldiers can’t easily change the height of the cannon or the
    exit velocity of the cannonball, but they can adjust the angle of fire, so that’s
    where we’ll focus our efforts. [Figure 5-1](chapter5.xhtml#fig5-1) diagrams the
    nature of the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: The path of a cannonball'
  prefs: []
  type: TYPE_NORMAL
- en: The cannonball is fired from point A, which has an elevation of H[0] relative
    to the ground surface, and the goal is to hit point B. The exit velocity of the
    cannonball is *v*[0], and its angle of fire is *θ*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cannonball is fired, it becomes a *projectile*, an object in motion
    that has only one force acting upon it: gravity. To arrive at the correct value
    for *θ*, we need to know a little bit about the science of projectiles. First,
    let’s assume that the cannonball is moving in only two dimensions: horizontally
    and vertically. We’ll place the origin of this two-dimensional coordinate system
    at point A. Given the initial velocity of the ball *v*[0], which is projected
    at an angle *θ*, we can write the corresponding x- and y-components of the initial
    velocity as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*v*[0]x = *v*[0] cos*θ*'
  prefs: []
  type: TYPE_NORMAL
- en: '*  v*[0]y = *v*[0] sin*θ*'
  prefs: []
  type: TYPE_NORMAL
- en: 'These velocity components tell us how fast the ball will be traveling in the
    horizontal and vertical directions solely due to its initial velocity. Again,
    disregarding the effects of air or wind resistance, no other force is acting on
    the ball horizontally. Therefore, we could say that the velocity in the x-direction,
    *v*x, remains constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  v*x = *v*[0]x = *v*[0] cos*θ*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vertical direction, however, the acceleration due to gravity will slow
    the ball’s rise and eventually bring it down to the ground. Thus, we can express
    the resultant velocity in the y-direction, *v*y, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  v*y = *v*[0]y − *g t* = *v*[0] sin*θ* − *g t*'
  prefs: []
  type: TYPE_NORMAL
- en: Here *g* is the acceleration due to gravity, and *t* is time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these expressions for *v*x and *v*y, we can write the *displacement equations*
    for the projectile, which express its x- and y-coordinates, or how far the ball
    has traveled horizontally and vertically, as of a given time *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.1)$Equation$ (5.2) ![](../images/eq5-1-2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now assume that the time to reach the target at point B is *t*[B], then
    the horizontal distance to the target is:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.3) ![](../images/eq5-3.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the same time period *t*[B], the projectile will also move vertically.
    It will pass through point C (shown in [Figure 5-1](chapter5.xhtml#fig5-1), the
    ball’s highest elevation, at *H* + H[0]) and then free-fall to the ground while
    continuing to move horizontally at velocity *v*x. When the projectile reaches
    point B (meaning it hits the target), its net vertical displacement *y*[B] will
    be −H[0], which can be expressed using Equation 5.2 as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.4) ![](../images/eq5-4.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t actually know how long it will take the cannonball to reach the target,
    however, so we need a way to express *t*[B] in terms of the other variables. Equation
    5.4 is a *quadratic equation*, where the highest power of a variable is 2\. It
    can be solved for the positive value of *t*[B] as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.5) ![](../images/eq5-5.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use Equation 5.5 to substitute for *t*[B] in Equation 5.3, which
    gives us the following equation for *x*[B] as a function of *θ*:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.6) ![](../images/eq5-6.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: This equation establishes a relationship between the distance to the target
    *x*[B] and the firing angle *θ*, but it still doesn’t allow us to calculate *θ*
    for a given *x*[B]. What we need is an equation that expresses *θ* in terms of
    *x*[B], not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: We have two options to resolve this situation. One is analytical, involving
    rearranging Equation 5.6 and deriving an expression for *θ* in terms of *x*[B].
    It can be done, but it would require a significant amount of mathematical juggling.
    The other option is to use a *numerical method*, which involves solving the problem
    through an iterative process following an algorithm. A numerical method is also
    an approximate method, meaning it won’t produce the exact same solution as the
    theoretical one. However, we can choose the desired degree of precision, and often
    that’s close enough. In fact, for many real-world problems of this nature, we
    may not have any known theoretical solution, in which case a numerical method
    is the only viable option for solving the problem. This is why we’ll use a numerical
    method to answer our cannonball question.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to take one additional step to make the problem amenable to a numerical
    method: getting *x*[B] onto the right-hand side of Equation 5.6 and turning it
    into a function of *θ*. In other words, we’ll define function *f*(*θ*) as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.7) ![](../images/eq5-7.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: To solve our cannonball problem, we now need to find a value of the independent
    variable *θ* that, for a given value of *x*[B], will make the right-hand side
    of Equation 5.7 equal to zero. In mathematical terms, this value is known as the
    *root* of the function. We’ve turned the projectile problem into a root-finding
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a number of methods to find the root for Equation 5.7\. In this
    case, we’ll use a simple method called *bisection*, as illustrated in [Figure
    5-2](chapter5.xhtml#fig5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: The elements of the bisection method for root finding'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we’re trying to find the root of a simple linear function *f*(*x*),
    which is a continuous function of variable *x*, as shown in [Figure 5-2](chapter5.xhtml#fig5-2).
    The root is the value of *x* that makes the function equal zero. Here are the
    simple bisection steps for finding the root *x** so that *f*(*x**) = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Locate two values x[1] and x[2] such that they are on the opposite side
    of the root, meaning f(x[1]) < 0 and f(x[2]) > 0.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Find the midpoint x between x[1] and x[2] such that x = (x[1] + x[2])/2.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If the absolute value of f(x) is less than some tolerance factor (for example,
    0.0000001), then x is the root, so we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Otherwise, if f(x) * f(x[2]) > 0, set x[2] = x, else set x[1] = x.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Repeat steps 2 through 4 until the condition in step 3 is met.
  prefs: []
  type: TYPE_NORMAL
- en: This method is guaranteed to converge to the root if *f*(*x*) is continuous
    within the initial range [*x*[1], *x*[2]], which also includes the root or roots.
    Without further ado, let’s start coding!
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bisection method involves only a few lines of code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the math library functions ❶ and providing the global
    parameter values ❷. Notice that we import only the math functions we need, separately,
    instead of using import kotlin.math.* to import all math functions. It’s good
    coding etiquette to use only what you need, as it helps keep the namespace clean
    and reduces the chance of introducing bugs, especially when the code is reused.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve set the target distance to 400 m, the cannon’s height
    to 25 m, and the cannonball’s initial velocity to 70 m/s. Next, we guess initial
    values for x1 and x2 for the bisection method ❸ and set the function parameter
    f to projectile. Treating projectile as a parameter allows us to reuse the code
    to find the roots of other functions.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function uses an if...else block to confirm that the initial x1 and
    x2 guesses are located on opposite sides of the root ❹. If true, it calls the
    bisection() function to find the root. If the test fails, the program prints a
    message indicating that the initial guesses weren’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: The next code block defines the projectile() function, which calculates the
    right-hand side of Equation 5.7 for a given angle, after first converting the
    angle to radians ❺ as required for the sin() and cos() functions.
  prefs: []
  type: TYPE_NORMAL
- en: The final code block is the bisection() function that implements the steps outlined
    earlier. The function takes the two initial guesses as arguments, finds the midpoint
    between them ❻, and then uses a while loop ❼ to make smaller and smaller bisections
    until the midpoint is within the specified tolerance range. The function returns
    the root as x (of type Double).
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Result'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the program, the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have the answer to the cannonball question! For the given initial
    velocity and height of the cannon above the ground, the soldiers need to fire
    the cannon at an angle of 21.91 degrees to hit a target 400 m away.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about this solution a bit more. Is this the only possible way to
    hit the target? [Figure 5-3](chapter5.xhtml#fig5-3) shows how *f*(*θ*) varies
    with *θ* (for the given parameter values).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The relationship between f(θ) and θ'
  prefs: []
  type: TYPE_NORMAL
- en: The function follows a parabolic curve, passing through the x-axis twice, so
    it has two different roots for *θ* ≥ 0\. From the given initial guesses, we’ve
    found the first root at point A, but another root is found at point B, where *θ*
    = 64.51 degrees. This is a much steeper angle than the first solution, *θ* = 21.91
    degrees. [Figure 5-4](chapter5.xhtml#fig5-4) shows the paths, or *trajectories*,
    the cannonball will take for both firing angles.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Two trajectories for the cannonball solutions'
  prefs: []
  type: TYPE_NORMAL
- en: While cannonballs fired at either angle will hit the target, the ball will reach
    a much higher elevation and take longer to hit the target when *θ* = 64.51 degrees.
    Which option do you think the soldiers will prefer, and why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 18: Design a Fountain with Water Jets'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we’ll continue to explore the path of a projectile, but instead
    of chasing a cannonball, we’ll follow a jet of water. Water jets have many familiar
    applications, such as washing cars, watering lawns, and fighting fires. We’ll
    explore a more artistic example: running the water jet through a nozzle assembly
    to create a decorative fountain.'
  prefs: []
  type: TYPE_NORMAL
- en: A *nozzle* is a narrow opening through which a jet of fluid comes out at a high
    velocity (the fluid can be a gas or a liquid). For a given pressure, the narrower
    the opening of the nozzle, the faster the velocity of the jet. In the nozzle assembly
    used in fountains, several nozzles of different sizes or with adjustable openings
    can be placed at different angles. Designers vary these parameters to create beautiful
    patterns with the water jets. In this case, we’ll try to adjust the nozzle to
    shoot jets into different levels of a multilevel fountain. [Figure 5-5](chapter5.xhtml#fig5-5)
    illustrates the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: Pointing a nozzle toward a multilevel water fountain'
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this exercise is to estimate the velocity of a jet *v* and
    its angle of ejection *θ*, given the desired highest point of the jet’s trajectory,
    (*x*max, *y*max). This high point is set so that the jet will just pass over the
    edge of the water basin at a particular level, as shown in [Figure 5-5](chapter5.xhtml#fig5-5).
    The fountain has four levels, so we have four sets of (*x*max, *y*max), shown
    in [Table 5-1](chapter5.xhtml#tab5-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Fountain Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | xmax (meters) | ymax (meters) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2.25 | 1.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2.55 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2.85 | 4.25 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3.0 | 5.5 |'
  prefs: []
  type: TYPE_TB
- en: The values in this table are defined relative to the nozzle at point (0, 0).
    We’ll use them to calculate the corresponding values of *v* and *θ*. Further,
    we’ll draw the trajectories of the jets by using the canvas feature of JavaFX
    so that we can visualize the solution relative to the water fountain.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that [Figure 5-5](chapter5.xhtml#fig5-5) shows only a cross section of
    the fountain system, which is circular in shape in three dimensions. The nozzles
    are placed at diametrically opposite positions along the base of the fountain
    system, which is made up of the ground-level basin (not shown), the nozzles, and
    the four-level middle structure. We’ll use the spacing between the nozzles as
    the base width of this fountain system.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to use three specific equations to solve this problem, all of which
    can be derived from the projectile equations discussed in [Project 17](chapter5.xhtml#pre-17)
    (search online for “projectile motion” or “equations of motion” to learn about
    the derivations, or see the resources listed at the end of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.8)$Equation$ (5.9)$Equation$ (5.10) ![](../images/eq5-8-10.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already defined the variables in these equations, except for *t*max,
    which is the time needed for a water particle leaving the nozzle to reach the
    highest point (*x*max, *y*max). We can use Equations 5.9 and 5.10 to find the
    expressions for *θ* and *v* as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.11)$Equation$ (5.12) ![](../images/eq5-11-12.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use these equations to calculate the angles of ejection and velocities
    for the four levels of the fountain, based on the data provided in [Table 5-1](chapter5.xhtml#tab5-1).
    We’ll also use Equation 5.8 to calculate the trajectories to be drawn with the
    JavaFX library.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our project uses the same basic JavaFX template that’s discussed in detail in
    [Chapter 3](chapter3.xhtml). We begin with some overall setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first half of the import block imports the necessary graphics features from
    the JavaFX library, and the second half imports the required math functions from
    the kotlin.math library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the global parameters and variables. The base width of the fountain
    system has been set to 6.5 m. The coordinates for the highest points of the parabolic
    jets (xMaxJet and yMaxJet) are set by using type DoubleArray. We also create arrays
    to hold the angles and velocities that we’ll be calculating. As we’re imagining
    this fountain to be on Earth, the acceleration due to gravity, g, has been set
    to 9.8 m/s². Finally, we set the required dimensions for the canvas based on the
    width and height of the fountain, with some margins on the sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the project code has three core segments: the ShapeOfWater
    application class and two helper functions, getAngleAndVel() and getTrajectories().
    We’ll look at these in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: The ShapeOfWater Application Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ShapeOfWater application class manages the canvas and calls the helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class follows the standard JavaFX block we developed in [Chapter 3](chapter3.xhtml),
    which we’ll use throughout this book. Notice the two function calls. The first
    call to getAngleAndVel() calculates the *θ* and *v* for the four sets of coordinates
    provided for the four levels of the fountain. Calling getTrajectories() calculates
    the corresponding trajectories for the water jets and draws them on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The class declaration ends with a few lines of print statements to display the
    calculated values of *θ* and *v* (as angle and vel) for the four pairs of (*x*max,
    *y*max) provided. The values are rounded to two decimal places for ease of reading.
  prefs: []
  type: TYPE_NORMAL
- en: The getAngleAndVel() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The getAngleAndVel() function uses Equations 5.11 and 5.12 to calculate *θ*
    and *v* for the four water jets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use zip() with a lambda expression ❶ to work through the pairs of (*x*max,
    *y*max) values, calculating theta and vel for each and storing those values in
    the appropriate arrays. We could have also used a for loop to iterate over the
    coordinates, and you might try that as an exercise. The atan() function gives
    us angles in radians, but we convert the values to degrees before storing them
    in the angles array to make the output more intuitive ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The getTrajectories() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The getTrajectories() function calculates the trajectories of the jets based
    on the data from getAngleAndVel() and visualizes the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we calculate *t*max for each (*x*max, *y*max) pair by using Equation
    5.8\. We deliberately extend *t*max by 10 percent so that when the trajectory
    is drawn up to that time, we’ll see the jet starting to bend downward toward the
    water basin ❶. Next, we use a while loop ❷ to iterate over 50 even time steps
    between 0 and *t*max. Using while allows us to work with a real-valued (noninteger)
    increment per time step. We couldn’t do that with a for loop, whose iterator can
    only be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the while loop, we use the original displacement Equations 5.1 and 5.2
    introduced in [Project 17](chapter5.xhtml#pre-17) to calculate the successive
    locations of a water particle at each time step, giving us the entire trajectory
    for the water jet from the nozzle to the basin. Instead of saving the values in
    an array for future use, we use them instantly to draw small circles on the canvas
    ❸. By repeating the process for all (*θ*, *v*) pairs and for all time steps, we
    create the two-dimensional profile of the water jets. Notice that we take advantage
    of the symmetric nature of the problem to draw a second set of jets from another
    nozzle on the opposite side of the ground-level basin ❹. For this extra set of
    jets, we only need to adjust the x-coordinates by subtracting x from baseWidth.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the downloadable version of the code, the complete 2D solution should
    resemble [Figure 5-6](chapter5.xhtml#fig5-6). This version of the code includes
    two additional functions: drawFountain() and drawNozzles(). The former is used
    to draw the four-level fountain from the given arrays of *x*max and *y*max for
    the water jets, while the latter is used to display the positions of the nozzles
    as shown in [Figure 5-5](chapter5.xhtml#fig5-5). I encourage you to study these
    two functions and understand the logic used to calculate the dimensions of the
    fountain and the positions of the nozzles.'
  prefs: []
  type: TYPE_NORMAL
- en: To change the shape of the trajectories, you can adjust the values of *x*max
    and *y*max for the water jets. The shape of the fountain will be automatically
    adjusted. However, it’s important to ensure that the values of *x*max and *y*max
    are consistent and reasonable. For example, the *x*max and *y*max for level 2
    should be greater than those of level 1, and similar conditions apply to levels
    3 and 4\. Additionally, all values must be nonnegative.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Water jet profiles around a multilevel fountain'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of the nozzle velocities (in m/s) and angles (in degrees) are directly
    printed onscreen as text output when you run the code. The output should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s not difficult to use this 2D solution to build a real-world 3D fountain.
    Since we previously imagined the fountain system to be circular in shape, all
    we need to do is repeat the solution at certain intervals along the perimeter
    of the circle that passes through the nozzle assemblies. You can also play with
    the code to generate your own unique fountain designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 19: Track a Pendulum’s Motion and Phase'
  prefs: []
  type: TYPE_NORMAL
- en: A *pendulum* is a body or weight hung from a fixed point with the help of a
    string, chain, or rod. When the pendulum is moved from the stable equilibrium
    of its vertical position, it can freely swing under the influence of gravity.
    In ideal conditions, when no friction or air resistance interferes, the pendulum
    will continue to swing indefinitely once it’s set in motion. Clockmakers have
    long used pendulums to steadily drive mechanical clocks—picture, for example,
    the swinging pendulum of an antique grandfather clock. Other examples of real-life
    pendulums include swings, wrecking balls, and church bells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pendulums exhibit *simple harmonic motion (SHM)*, defined as the motion of
    an object that is *periodic*, or repeating, and that is driven by two opposing
    forces: an *inertial force* that moves the object away from its equilibrium position
    and a *restoring force* that tries to return the object to its equilibrium position.
    The maximum displacement of the object relative to the mean or equilibrium position
    is called the *amplitude*, and the number of cycles the object goes through per
    unit time is called the *frequency*. The inverse of frequency, which is the time
    it takes to complete one cycle or oscillation, is called the *period*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple harmonic motion of a pendulum provides a starting point for understanding
    the more complex periodic motions found in nature, from the vibration of an electron
    to the orbit of a planet about a star. This project introduces the equation for
    the motion of a simple pendulum. It shows you how to use a numerical method to
    solve this equation and calculate the state of the pendulum—that is, its velocity
    and displacement angle—at any given time once the pendulum is set in motion. For
    added realism, we’ll factor in the effect of air resistance to show how it gradually
    dampens the pendulum’s motion. Of course, we’ll codify our model pendulum in Kotlin
    and visualize the results by using the JavaFX tools we learned in [Chapter 3](chapter3.xhtml).
    Our visualization will consist of three charts: one showing the change of the
    pendulum’s velocity over time, one showing the change of its displacement angle
    over time, and one showing the relationship between the two.'
  prefs: []
  type: TYPE_NORMAL
- en: The Motion of a Simple Pendulum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A simple pendulum has a single weight, or *bob*, of mass *m* that hangs from
    a thin string of length *l* fixed at point A*.* It’s assumed that the mass of
    the string is negligible compared with the mass of the bob. It’s also assumed
    that the string doesn’t stretch due to the weight of the bob and that the bob
    can move back and forth indefinitely without any friction or loss of energy (meaning
    the total energy of the system is conserved, once set in motion). As the pendulum
    swings, its angular displacement (*θ*) changes, as measured relative to the pendulum’s
    stable equilibrium position (the vertical line passing through point A). [Figure
    5-7](chapter5.xhtml#fig5-7) shows these components of a simple pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Components of a simple pendulum'
  prefs: []
  type: TYPE_NORMAL
- en: At any point in time, the force of gravity, *mg*, acts on the bob to set it
    in motion. The gravitational force has two components. The first, *mg* cos(*θ*),
    acts along the line of the string and is countered by the tension in the string.
    The second, *mg* sin(*θ*), acts perpendicularly to the string. This is the part
    that isn’t balanced by any other force (assuming no air resistance) and is responsible
    for the harmonic motion of the pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let *ω* denote the rate of change of angular displacement, also called the
    *angular velocity*:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.13) ![](../images/eq5-13.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side of Equation 5.13 is called the derivative of *θ* with respect
    to time *t*. Mathematically speaking, the time derivative of a variable gives
    us the instantaneous rate of change of that variable with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now express the equation of motion for this simple pendulum in terms
    of its angular acceleration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.14) ![](../images/eq5-14.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An analytical solution to Equation 5.14 would give us an expression for the
    angular displacement *θ* in terms of time *t* and other parameters. However, the
    analytical solution isn’t easy to derive unless we make an additional assumption
    that the maximum displacement *θ*max is relatively small—say, less than 15 degrees.
    This would allow us to replace sin(*θ*) with *θ*, since the two are equivalent
    for small angles.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to be limited to just this special case, however. Instead, we’ll
    use the Euler-Cromer numerical method to incrementally solve Equation 5.14 for
    a small time step. This method maintains the conservation of energy inherent in
    simple harmonic motion, and it yields *stable* solutions (a solution is *stable*
    when the numerical approximation doesn’t deteriorate and move away from the theoretical
    solution over time).
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To apply the Euler-Cromer method, we need to change Equation 5.14 from its
    continuous-time form to its discrete-time form:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.15) ![](../images/eq5-15.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here *δt* is a small, discrete time step. Next, we’ll incorporate the impact
    of air resistance on the pendulum. Air resistance slows down the angular velocity
    as a decelerating force, which can be assumed to be proportional to the angular
    velocity. Assuming *γ* to be the proportionality constant, we can modify Equation
    5.15 as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.16) ![](../images/eq5-16.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll write another expression for updating the angular displacement
    *θ*, which follows directly from the definition of angular velocity *ω* in Equation
    5.13 as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.17) ![](../images/eq5-17.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are assuming that over a small time interval *δt*, *θ* is changing
    from *θ*t to *θ*t [+ 1]. In reality, *ω* also continues to change over this small
    time period. We recognize this fact by denoting *ω* as a function of time—that
    is, *ω*(*t*)—in Equation 5.17\. However, in discrete-time representation, we can
    use only one discrete value of *ω*, and the Euler-Cromer method requires that
    it be *ω*t [+ 1] to ensure numerical stability. Thus, the final numerical form
    for the equation of motion of a simple pendulum is:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.18) ![](../images/eq5-18.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: By starting with initial values for *θ* and *ω*, and by repeatedly using Equations
    5.16 and 5.18, we can calculate the state of a simple pendulum and plot the changes
    of its angular displacement and velocity over time.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program for modeling our simple pendulum has three main code segments:
    the main application segment coordinating the model, a simplePendulumWithDrag()
    function implementing the equations we’ve discussed, and a singleXYChart() function
    to draw each plot. We’ll review these segments in detail in the same order, starting
    with the main application segment.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the main application segment starts with the boilerplate import block
    required for a JavaFX-based app. This time, we’re also going to use a class called
    ScrollPane that can hold a graphics element and provide a scrollable view of it.
    This will help us view all three charts in the same window. The import block also
    includes the math functions we’ll need for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The second code block declares two data classes. We’ll use the XYChartData class
    to hold (*x*, *y*) data points for creating the line charts and the PendulumData
    class to store the state of the pendulum (angular displacement *θ* and velocity
    *ω*) for a specific time *t*. Each XYChartData data point will be fetched from
    the values in a particular PendulumData instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we provide problem-specific and global parameter values. For example,
    we’ve set the initial displacement to -PI/6 (–30 degrees) and the initial velocity
    to 0. The length of the pendulum, measured in meters, is 0.4, and n = 100 means
    we’ll determine the value of the time step (*δt*) by dividing the period of oscillation
    into 100 intervals. We’ve also set the coefficient for air resistance to 0.6 (a
    value of 0 would mean no air resistance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the SimplePendulum application class, the problem-specific part of the
    code starts with a call to simplePendulumWithDrag() ❶ that takes in the following
    arguments: the initial displacement *θ*[0], the initial velocity *ω*[0], the length
    of the pendulum *l*, the acceleration due to gravity *g*, the number of time intervals
    per period *n*, and the air resistance coefficient *γ*. As you’ll see shortly
    when we look at the inner workings of this function, it returns a list of PendulumData
    instances, one for each time step, which we store as state.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create three mutable lists to hold the XYChartData instances that we’ll
    need to draw the line charts illustrating the pendulum’s state variables. We build
    these lists by extracting the elements from each PendulumData instance as needed
    for the three charts ❷. Charts 1 and 2 both show time on the x-axis and displacement
    and velocity on the y-axis, respectively; chart 3 shows displacement on the x-axis
    and velocity on the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: We generate the three charts by making successive calls to the singleXYChart()
    function. The function takes five arguments, four of which have default values
    assigned in the function definition. Thus, we only need to provide a list of type
    XYChartData (for example, list1) and optionally supply values of the other named
    parameters. Notice that for xyChart3, we specify sort = "NONE" so that we can
    correctly plot the (velocity, displacement) pairs without changing their sequence.
    This is a requirement when we consider the air resistance that alters the cyclic
    relationship between the two state variables.
  prefs: []
  type: TYPE_NORMAL
- en: We plot the charts by attaching them to root ❸, which we previously assigned
    to a ScrollPane. This scheme allows us to view all three charts inside the same
    window by scrolling up and down or sideways as needed. Finally, the main() function’s
    only job in a JavaFX application is to launch the main application class—in this
    case, SimplePendulum.
  prefs: []
  type: TYPE_NORMAL
- en: The simplePendulumWithDrag() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the simplePendulumWithDrag() function, we use the Euler-Cromer method to
    calculate the values of the pendulum’s state variables for a specified number
    of time steps, given the initial conditions and global parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first order of business is to determine the value of the time step dt (*δt*).
    For that, we need to estimate the pendulum’s period of oscillation *T* ❶, using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg195-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Technically, this formula is valid only for initial displacement angles under
    15 degrees, but it provides a good starting approximation. Dividing *T* by the
    number of time intervals per period n gives us the length of each time interval
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we also arbitrarily set the maximum number of time steps, Nmax,
    to 4 * n intervals to ensure that the simulation period includes at least three
    full cycles of the pendulum’s oscillation (the period of a pendulum gets longer
    as the initial displacement or amplitude gets larger). Feel free to try out other
    values for these parameters, but keep in mind that a larger n (and thus a smaller
    dt), or a longer simulation period, will increase the number of computations and
    require more memory to store all the intermediate values of the state variables.
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the local variables, parameters, and the mutable list pList
    that saves the state variables (including time), we implement the Euler-Cromer
    method by using a for loop ❸. Inside this loop, we use Equations 5.16 and 5.18
    to calculate omegaNew and thetaNew, along with the updated time timeNew. We store
    these in an instance of PendulumData and add it to pList ❹. Then we assign these
    “new” state variables back to the “old” state variables (for example, setting
    omegaOld = omegaNew ❺) for the next time through the loop. In all, these steps
    are repeated for each time interval, for a total of Nmax times.
  prefs: []
  type: TYPE_NORMAL
- en: The code segment includes several print statements that summarize the global
    values and parameters used to solve the problem. Then the segment ends by returning
    pList to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: The singleXYChart() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The singleXYChart() function creates a line chart with JavaFX. In this case,
    using the JavaFX charting tools is a more natural choice for creating our visualization
    than using the canvas feature, as we did in [Project 18](chapter5.xhtml#pre-18).
    This time we want to be able to read off the values of the state variables directly
    from the charts, and this would not be easy to do from scratch using the canvas
    (we’d essentially have to write our own charting library).
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code in this segment is boilerplate JavaFX code used for creating
    a line chart. Since this process was discussed in detail in [Chapter 3](chapter3.xhtml),
    we’ll focus only on the problem-specific elements in this code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that the function takes five arguments, four of
    which are named arguments. We’ve provided default values for the named arguments
    in the function definition, and these defaults will be used unless we supply problem-specific
    values when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the chart clean and simple, we turn off markers ❶ and the legend ❷.
    We also turn off the default sorting of x-values when the sort parameter is set
    to "NONE" ❸. As you saw in the main application code, we use this option when
    creating the chart of angular velocity over displacement, because we need to maintain
    the order of (*ω*, *θ*) pairs to correctly capture the cyclic nature of this relationship.
    Finally, we extract the data points for the line chart from data (which is a list
    of XYChartData instances) by deconstructing each item in data into a set of x
    and y values ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program generates a few lines of text output and a scrollable window that
    contains our line charts. The text output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This output provides a reminder of the parameter values used and especially
    shows the time interval *δt* that we’ve calculated internally based on the estimated
    period of the pendulum. You need to monitor this value if accuracy is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the content of the chart window, the first line chart shows how the
    angular displacement varies with time, and the second chart shows the same for
    angular velocity (see [Figure 5-8](chapter5.xhtml#fig5-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: The angular displacement (left) and angular velocity (right) of
    a pendulum facing air resistance'
  prefs: []
  type: TYPE_NORMAL
- en: 'The charts show the pendulum’s periodic pattern decaying, or dampening, due
    to air resistance; otherwise, the maximum displacement and the maximum velocity
    would remain unchanged. Notice the phase difference between *θ* (displacement)
    and *ω* (velocity): *ω* lags *θ* by a fixed distance along the time axis. Specifically,
    whenever *θ* is at its most extreme, *ω* is 0, and vice versa. For example, at
    *t* = 0, *θ* is at its maximum displacement, –π/6 (to the left of the equilibrium
    position), but *ω =* 0; then, at approximately *t* = 0.32, the pendulum passes
    through its equilibrium position (*θ* = 0) and *ω* reaches its maximum magnitude.
    This is because at this location, all of the pendulum’s potential energy becomes
    kinetic energy. Beyond that point, *ω* begins to drop as the kinetic energy converts
    back into potential energy, until *ω* becomes 0 again at the point of maximum
    displacement on the opposite side.'
  prefs: []
  type: TYPE_NORMAL
- en: This relationship can be shown directly by plotting *ω* against *θ*, which is
    exactly what we’ve done in our third plot. This kind of visualization is known
    as a *phase-space plot*; for a dynamic system in two dimensions, it plots velocity
    *v*(*t*) over displacement *x*(*t*), the common denominator being time, *t*. Also
    called a *phase portrait*, a phase-space plot helps in studying complex system
    behaviors and uncovering relationships between the state variables that might
    otherwise remain undetected. [Figure 5-9](chapter5.xhtml#fig5-9) shows our phase-space
    plot for the pendulum, with *θ* on the x-axis and *ω* on the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-9: A phase-space plot of a simple pendulum with damped motion'
  prefs: []
  type: TYPE_NORMAL
- en: The main point to notice in the plot is that while *ω* and *θ* are still related
    through the parameter *t*, both are decreasing due to air resistance. With each
    time step, the pendulum gets a bit slower and its swing a bit narrower—hence the
    distinctive spiral shape of the plot. If you’re wondering what the pattern might
    look like for an undamped pendulum that isn’t experiencing any air resistance,
    you can simply set the drag coefficient *γ* to 0 and run the program again to
    investigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 20: The Physics of Coffee Cooling'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll turn our attention from the physics of motion to the physics of heat
    transfer. Imagine you’ve picked up a cup of coffee from your favorite coffee shop
    on your way to work in the morning. It’s a 25-minute drive from the coffee shop
    to your office, during which the coffee will get colder due to heat loss. You
    like to have milk in your coffee, but the milk is kept refrigerated, so adding
    it will further lower the temperature of the coffee. You could add milk right
    away at the coffee shop or wait to add milk from your office refrigerator. Which
    option should you use to keep your coffee as warm as possible?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write a Kotlin application to plot the coffee’s change in temperature
    over time in both scenarios. For that, we’ll first need to review Newton’s law
    of cooling, which defines how an object cools due to the loss of heat energy to
    its surroundings. We also have to consider the science of mixing two different
    liquids so we can figure out how to calculate the change of temperature when we
    add cold milk to hot coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s Law of Cooling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Newton’s law of cooling states that the rate of change of the temperature of
    an object is proportional to the difference between the object’s temperature and
    the ambient temperature. It can be mathematically expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.19) ![](../images/eq5-19.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '*T* is the temperature of the object at time *t*, *T*a is the ambient temperature,
    which is assumed to remain constant, and *k* is the heat transfer coefficient.
    For situations where *T* is greater than *T*a, the greater the value of *k*, the
    quicker the object will cool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the coefficient *k* depends on the material and surface properties
    of the object, as well as on the temperature of the object itself. When the primary
    method of heat loss is conduction, and convective and radiative losses are negligible,
    *k* can be assumed to remain constant for a small range of temperature variations.
    Our coffee cooling problem meets these requirements well: most of the heat loss
    happens conductively through the wall of the cup, convection is minimized by keeping
    a lid on the cup, and electromagnetic radiation in this temperature range is negligible
    compared to the other two factors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at the solution of Equation 5.19, which is a first-order ordinary
    differential equation. For the initial temperature *T*[0] (at *t* = 0) > *T*a,
    the solution can be expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.20) ![](../images/eq5-20.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Equation 5.20 will allow us to calculate the temperature of the coffee (with
    or without milk) given the initial coffee temperature *T*[0], the ambient temperature
    *T*a, the elapsed time *t*, and the heat transfer coefficient *k*.
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Effect of Mixing Liquids'
  prefs: []
  type: TYPE_NORMAL
- en: When two liquids of different temperatures are mixed together, the hotter liquid
    gets cooler by releasing heat energy, and the colder liquid gets warmer by absorbing
    the released heat. This exchange of heat energy will continue until both liquids
    attain the same temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the amount of heat *Q* absorbed or released by one of the liquids,
    and its corresponding change in temperature *ΔT*, are related as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.21) ![](../images/eq5-21.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: The term *C* in Equation 5.21 is called the *thermal mass* of the object, which
    is the product of its density *ρ*, volume *V*, and specific heat capacity *s*.
    In SI units, *Q* is measured in joules (J), temperature *T* in degrees Celsius
    (°C), *ρ* in kg/m³, *V* in m³, and *s* in J/(kg °C). As a result, the unit for
    *C* will be J/°C. For the coffee cooling problem, since we’ll be working with
    small quantities of liquids, we’ll use grams per milliliter (g/mL) for density,
    mL for volume, and J/(g °C) for specific heat capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we’re mixing two liquids such that *C*[1], *T*[1], and *T*f are the thermal
    mass, initial temperature, and final temperature for liquid 1, and *C*[2], *T*[2],
    and *T*f are the same for liquid 2\. (Notice that the final temperature for both
    liquids is the same.) If the mixing happens quickly, with no heat exchange with
    the surrounding environment, and if the liquids don’t chemically react and generate
    or absorb heat, the principle of conservation of energy suggests that the net
    change in energy in the system will be zero—that is, *Q*[1] + *Q*[2] = 0\. After
    substituting for *Q*[1] and *Q*[2] using Equation 5.21 and simplifying the results,
    we get the following expression for the final temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.22) ![](../images/eq5-22.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: You can use Equation 5.22 to calculate the temperature of the coffee after adding
    milk, either at the coffee shop or when you arrive at the office. Finally, we
    have all the science worked out to solve our problem and enjoy the optimal cup
    of coffee.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To identify the right time for adding milk, we need some data on the properties
    of the coffee and milk, as well as the ambient temperature of the environment.
    This data is summarized in [Table 5-2](chapter5.xhtml#tab5-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-2: Coffee Cooling Problem Data'
  prefs: []
  type: TYPE_NORMAL
- en: '| Item | Value and unit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Initial temperature of black coffee | 92°C |'
  prefs: []
  type: TYPE_TB
- en: '| Volume of black coffee | 250 mL |'
  prefs: []
  type: TYPE_TB
- en: '| Density of black coffee | 1 g/mL |'
  prefs: []
  type: TYPE_TB
- en: '| Specific heat capacity of coffee | 4.19 J/(g °C) |'
  prefs: []
  type: TYPE_TB
- en: '| Initial temperature of refrigerated milk | 4°C |'
  prefs: []
  type: TYPE_TB
- en: '| Volume of milk added to the coffee | 25 mL |'
  prefs: []
  type: TYPE_TB
- en: '| Density of milk | 1.035 g/mL |'
  prefs: []
  type: TYPE_TB
- en: '| Specific heat capacity of milk | 3.89 J/(g °C) |'
  prefs: []
  type: TYPE_TB
- en: '| Length of the drive from the coffee shop to the office | 25 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| Heat transfer coefficient for coffee (assumed to be the same with or without
    milk) | 0.0116/minute |'
  prefs: []
  type: TYPE_TB
- en: '| Ambient temperature everywhere | 20°C |'
  prefs: []
  type: TYPE_TB
- en: 'Armed with the science of coffee cooling and the data presented in [Table 5-2](chapter5.xhtml#tab5-2),
    we can now solve the problem by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1: Add milk later**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Calculate the temperature of black coffee after 25 minutes, starting with
    the initial temperature of 92°C.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Calculate the final temperature of the coffee after adding 25 mL of milk
    (assuming that mixing and heat exchange happen instantly).
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2: Add milk at the coffee shop**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Calculate the initial temperature of the coffee when milk is added immediately
    at the coffee shop (assuming that mixing and heat exchange happen instantly).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Calculate the final temperature of the coffee after 25 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: By comparing the final temperatures from options 1 and 2, we’ll know which option
    will keep the coffee warmer.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll develop this program as a JavaFX application so we can plot the coffee’s
    temperature profile over time for both options. For this, we’ll use the same template
    as in [Project 19](chapter5.xhtml#pre-19), with some changes to the problem-specific
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the problem definition and global parameters, along with the
    problem-specific components in the main application class, MixCoffeeAndMilk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The import block for this code segment is similar to that of [Project 19](chapter5.xhtml#pre-19),
    except that we need fewer math functions. In addition to initializing the values
    from [Table 5-2](chapter5.xhtml#tab5-2), we declare a data class called State
    ❶ to save the temperature at a given time. This will help us organize the data
    to be plotted. Among the parameters, notice that we set timeStep to 0.25 minutes
    ❷. This way, we’ll track and plot the coffee’s cooling progress in 15-second intervals.
    This time step may seem surprisingly long compared to the very short time intervals
    from [Project 19](chapter5.xhtml#pre-19), but it’s adequate for this problem because
    the temperature drops smoothly and slowly. Besides, we’re using an analytical
    solution and not a numerical approximation; thus, this choice doesn’t affect the
    accuracy of the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem-specific part of the code in the main application class follows
    the same order as the steps outlined in “The Strategy” on [page 211](#pg_211),
    except that we’ve added an extra step (step 5) to further track the coffee as
    it continues to cool at the office (more on that shortly). The code here relies
    on two main helper functions: the newtonCooling() function, which calculates how
    the coffee cools over time, and the tempAfterMixing() function, which calculates
    the immediate temperature after adding the milk. We deploy these functions as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For step 1, we call newtonCooling() and save the result as state1 ❸. This produces
    a list of type State containing the data points needed to show how the black coffee
    gets colder over time between the coffee shop and the office.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For step 2, we call tempAfterMixing() to get the final temperature of the coffee
    when milk is added after arriving at the office ❹. This is how warm the coffee
    will be before you take the first sip if you chose option 1 (add milk later).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For step 3, we call tempAfterMixing() to calculate the temperature of the coffee
    after adding milk at the coffee shop, before the drive to work ❺.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For step 4, we call newtonCooling() and save the resulting list of State data
    points as state2 ❻. The temperature property of the last element of this list
    will tell us how warm the coffee will be when you arrive at the office after choosing
    option 2 (add milk first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During each step, we display some output from the simulation either by using
    the println() function or by calling the custom printTimeAndTemp() function, defined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have everything we need to solve the problem after step 4, and the results
    are printed on the console. Let’s have a look at the results first, then come
    back to step 5 and the code for visualizing the cooling process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The final temperature of the coffee is 67.75°C when you add milk at the office
    versus 68.1°C when you add milk at the coffee shop. Though the difference isn’t
    that significant (just 0.35°C), you’ll be better off adding the milk at the coffee
    shop.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you could figure this out for yourself without any math or code by
    investing in a good-quality thermometer and brewing two cups of coffee. The benefit
    of building a mathematical model of the process, however, is that it not only
    tells us what the temperature will be after 25 minutes but also how the system
    will get there, starting from an initial state and considering interventions such
    as adding milk. Once we have the model, we can play with the parameter values
    and generate answers to many other questions, without making more coffee, adding
    more milk, and taking many temperature measurements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you get pulled into a meeting right after you arrive at work.
    You have just enough time to add milk to your coffee (if you haven’t added it
    already), but you don’t have time to enjoy said coffee until the meeting ends—another
    25 minutes later. What will the temperature of the coffee be at that point, a
    full 50 minutes after you bought it? Since we already have a mathematical model
    for how the coffee cools over time, this question is quite easy to answer.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to step 5, where we use the final temperatures after the first
    25 minutes as the initial temperatures for running the simulation for a further
    25 minutes. For this, we use an additional named parameter start in the newtonCooling()
    function. This parameter lets us offset the time values by 25 instead of starting
    the simulation time over at 0. We call the function twice, generating lists state3
    ❼ (for option 1—milk added at the office) and state4 ❽ (for option 2—milk added
    at the coffee shop).
  prefs: []
  type: TYPE_NORMAL
- en: Once all four states are calculated, we create a list of type State by using
    the listOf() method and pass this list to the createCoolingChart() function for
    plotting the temperature profiles for the entire 50-minute period.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Temperature Changes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s review our two helper functions for calculating the temperature changes
    in the coffee. The newtonCooling() function tracks the temperature change of the
    coffee over a period of time. The tempAfterMixing() function calculates the instantaneous
    temperature change when the milk is mixed in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the newtonCooling() function, we use Equation 5.20 to calculate the temperature
    of the coffee at point t in time ❶. We do this in a while loop, incrementing t
    by dt (set to timeStep) each iteration, until we get to tMax, giving us time and
    temperature data points in 15-second intervals, up to 25 minutes, which we store
    in a list called state ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we add start to each t before storing it in the list. When start
    isn’t set during the function call, it defaults to 0 and has no effect. However,
    when we call the function to create state3 and state4 (as part of step 5, discussed
    earlier), we set start = timeMax so the timestamps will range from 25 to 50\.
    This allows us to plot all the data in a single chart.
  prefs: []
  type: TYPE_NORMAL
- en: The tempAfterMixing() function takes in the separate density, volume, specific
    heat capacity, and premixing temperatures for the milk and coffee and returns
    the final equilibrium temperature once the milk is mixed in, using Equation 5.22.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the Temperature Profiles
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re now ready to plot the two temperature profiles of the cooling coffee.
    For that, we’ll define the createCoolingChart() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use this short function mainly to preprocess the information needed by the
    singleXYChart() function, also used in [Project 19](chapter5.xhtml#pre-19). This
    helps keep the body of the main application class less cluttered. Since we’ve
    discussed how to use singleXYChart() previously, I’ll skip that part here, except
    to mention that we’re now passing a list of lists rather than one single list
    as a collection of data points. Inside the singleXYChart() function, we therefore
    create four different series (from the list of lists, states) and plot them on
    the same chart instead of creating four separate charts. See [Chapter 3](chapter3.xhtml)
    for a review of how to plot a single series versus multiple series in the same
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of this function adds the chart object xyChart returned by the
    singleXYChart() function to the root node for display. [Figure 5-10](chapter5.xhtml#fig5-10)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-10: The temperatures of black coffee and coffee with milk over time'
  prefs: []
  type: TYPE_NORMAL
- en: The plot spans the entire 50-minute period of the simulation. We can see the
    sudden temperature drops when the milk is added either at the coffee shop (at
    time 0) or at the office (at time 25). After the latter, the temperature profiles
    appear to be almost identical. When we zoom in, however, as in [Figure 5-11](chapter5.xhtml#fig5-11),
    we find a slight difference (less than 1°C).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-11: A closer look at the coffee cooling problem for t > 25 minutes'
  prefs: []
  type: TYPE_NORMAL
- en: The gap between the two lines indicates that the coffee with milk added at the
    shop will always be a tad warmer. If we continue this experiment for a long time,
    will these temperature profiles still stay separate from each other? Why or why
    not?
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 21: Simulate a Binary Star System'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll explore the moves made by “star couples”—not the latest
    objects of celebrity gossip, but rather the stars we can see when we look up at
    the night sky. Many of the bright objects in the universe that appear to the naked
    eye like a single star are in fact two stars in close proximity that “dance” or
    orbit around a common center of rotation. Depending on the stars’ mass, orbital
    velocity, and distance from each other, these *binary star systems* can create
    interesting and unique orbital patterns. We’ll visualize these patterns by creating
    a binary star system Kotlin app.
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Science of Binary Star Systems'
  prefs: []
  type: TYPE_NORMAL
- en: Binary star systems are governed by Newton’s laws of gravity and motion. Let’s
    consider the model binary system in two dimensions shown in [Figure 5-12](chapter5.xhtml#fig5-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-12: A two-body system under gravity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our binary system is made up of two astronomical bodies, shown as dark circles
    in the figure. The first body, located at (*x*[1], *y*[1]), has a mass of *M*[1],
    and the second body, located at (*x*[2], *y*[2]), has a mass of *M*[2]. The distance
    from the center of *M*[1] to the center of *M*[2] is *r*, which we can calculate
    using the Pythagorean theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.23) ![](../images/eq5-23.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'The law of gravity says that these two bodies will be pulled toward each other.
    In this example, ***F***1 and ***F***2 are the gravitational forces acting on
    body 1 and body 2, respectively. Notice that these forces are *vectors*, meaning
    they have both magnitude and direction. (We indicate vectors with **boldface**
    type.) According to the law of gravity, the force acting on body 1 (***F***1)
    can be expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.24) ![](../images/eq5-24.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Equation 5.24, *G* is a gravitation constant, *F* is the magnitude of the
    force vector, and ***ȓ*** is a unit vector pointing from body 1 toward body 2\.
    Further, Newton’s second law of motion says that the force ***F***1 acting on
    body 1 of mass *M*[1] will create an acceleration ***a***1 along the direction
    of the force such that:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.25) ![](../images/eq5-25.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine Equations 5.24 and 5.25 to write expressions for the x- and
    y-components of acceleration ***a***1 as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.26)$Equation$ (5.27) ![](../images/eq5-26-27.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Newton’s third law of motion requires that ***F***1 = −***F***2. Thus,
    we can add a negative sign to the right-hand side of Equations 5.26 and 5.27 and
    replace *M*[1] with *M*[2] to calculate the acceleration components acting on
    body 2 due to ***F***2 as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.28)$Equation$ (5.29) ![](../images/eq5-28-29.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: To simulate the orbits of a binary system, we’ll first use these equations for
    the x- and y-components of acceleration to calculate the respective velocity components
    of the stars, then use those velocities to update the positions of the stars of
    our binary system.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we’ll develop a simple algorithm to track the stars in a binary
    system once they’re set in motion. First, however, we need to consider what units
    of measurement are appropriate to the cosmic scale of our astronomical calculations.
    We’ll use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For mass, we’ll use M[ʘ], which is the mass of our sun. One solar mass is approximately
    2 × 10^(30) kg, about 333,000 times the mass of Earth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For distance, we’ll use the astronomical unit (AU), which is the average distance
    between the sun and Earth. One AU equals 149,597,870.7 km.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For time, we’ll use the solar year (yr) as the standard unit, which is equal
    to 365 days, 5 hours, 48 minutes, and 46 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given these basic units, the unit for velocity will be AU/yr, and the unit for
    acceleration will be AU/yr². This, in turn, gives us a gravitational constant
    *G* of 4π² AU³ yr^(–2) M[ʘ]^(–1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to move on to the algorithm, which is similar to the algorithm
    used in [Project 19](chapter5.xhtml#pre-19). Here are the steps we’ll follow to
    calculate the positions of the binary stars:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Get the initial position and velocity vectors (in terms of x- and y-components)
    for the binary stars (including their masses and the gravitation constant, G).
    Use the system of units we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Calculate the distance r between the stars at a given time t, using Equation
    5.23.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Calculate x- and y-components of the accelerations, using Equations 5.26
    through 5.29.
  prefs: []
  type: TYPE_NORMAL
- en: '4.  Choose a small enough time step *dt* and update the velocity and position
    vectors, using the Euler-Cromer rule. The components of the velocity and position
    vectors along the x-axis can be calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (5.30)$Equation$ (5.31) ![](../images/eq5-30-31.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Repeat step 4 for the components along the y-axis for both stars.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Repeat steps 2 through 5 until the stopping condition is met. We’ll set
    the maximum number of iterations as the stopping condition.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the whole point of making all these calculations is to be able to
    sit back and enjoy watching the dance steps of the stars. After each cycle through
    the algorithm, we’ll animate the stars’ motion by plotting the new positions by
    using the canvas feature of JavaFX. We’ll also give each star a trail to better
    illustrate the orbital paths. A significant part of the code for this app is devoted
    to displaying and managing the moving objects on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll review the code segments for this project in the same order as they appear
    in the app. Let’s start with the imports and declarations that come before the
    SimulateBinarySystem application class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines of the import block load important tools (KeyFrame, Timeline,
    and Duration) for creating frame-by-frame animations with JavaFX. The remaining
    imports are similar to what we’ve used previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After the imports, we declare a Star data class to hold the properties needed
    for representing a star, including its mass, x- and y-coordinates, and velocity
    components. The size property, specified in pixels, is the diameter of the circle
    that will represent a particular star; xOld and yOld will hold a copy of the star’s
    current position vector before updating it (needed to generate its trails); trailCount
    sets the number of small dots that will follow a star to mark its trail; and color
    defines the color used to draw the star and its trail. Because this book is printed
    in black and white, all figures have been generated with the default color (BLACK),
    but feel free to experiment with any color you like when you run the code on your
    device.
  prefs: []
  type: TYPE_NORMAL
- en: The problem definition and global declaration section starts with creating stars
    as a list of two Star objects. We initialize each with its mass, size, current
    x- and y-coordinates (x, y), components of the velocity vector along the positive
    x- and y-axes (vx, vy), and color for drawing the star on the canvas. Since we’re
    not going to draw the stars to proper scale, I’m just using two arbitrary sizes
    that might look reasonable given the size of the canvas. You could make them proportional
    to their masses if you have reason to believe that the stars have similar densities.
    Also, notice that we’ve set the gravitational constant G to 4π² because we’re
    using the astronomical units mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the code, we first set the width (canvasW) and height (canvasH)
    of the canvas to 800 pixels (without any scaling, this would be equivalent to
    800 AU in both directions). The durationMillis parameter sets the duration per
    animation frame to 4.0 milliseconds. The frameCountMax = 50_000 means the app
    will stop simulating the binary system after 50,000 frames. If dt = 1 year, that
    will be equivalent to observing the system for 50,000 years! You may not need
    to simulate the system for such a long time (you can terminate the app at any
    time by closing the animation window). However, it’s a good idea to run a simulation
    for several rounds of full orbits (when the expected orbit is either a circle
    or an ellipse) to confirm that the simulated orbits are stable. Once this is confirmed,
    you can play God with the parameters and see how the movements of the stars go
    crazy!
  prefs: []
  type: TYPE_NORMAL
- en: The final code segment in this block sets parameters for the trails, allowing
    us to visualize the path traced by the stars during live simulations. By default,
    the TRAIL_CODE is set to YES, which means that trails for both stars will be drawn
    on the canvas alongside their parent stars. Each trail is composed of small dots
    or tracers that follow the parent star. The dots’ coordinates are saved in a two-dimensional
    array called trails, where each element represents x- and y-coordinates stored
    as a Pair of type <Double, Double>. To ensure that the full orbital path is traced
    out by the trails when the orbit is stable, we set the number of trail elements
    to 6500. Try to keep this number to a minimum, however; otherwise, too many dots
    in the trails can slow down the animation and force you to adjust the duration
    of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: The SimulateBinarySystem Application Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The core part of the app is the SimulateBinarySystem application class, where
    we combine Kotlin with JavaFX to drive the key parts of the app and run the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first section of this code segment is boilerplate JavaFX code that we’ve
    used before. Notice that this time we’re setting the origin of the coordinate
    system to the center of the canvas ❶. Also, the positive y-axis direction is set
    to point upward ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the simulation block, we first call the initialPositions() function
    ❸, which draws the x- and y-axes on the canvas, places the stars on the canvas
    based on their position vectors, and initializes an array of type Pair called
    trails if the TRAIL_CODE is set to YES. Since this function is very short, I’ll
    show it and the drawAxes() function, which is called from within the initialPositions()
    function, right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use a forEachIndexed structure for iteration instead of a standard
    for loop in the initialPositions() function. This is because we need the index
    property of the stars to create the respective trails in the second part of the
    function. Each star’s trail consists of trailMAX number of dots, or tracers, which
    for now we initialize to the same starting position as the star itself.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the drawAxes() function, notice how all the graphics commands involving
    the graphics context gc have been grouped together using the scoping function
    with(). This saves us from having to type gc multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the application class, the animation of the binary star system
    is implemented by using a combination of Timeline and KeyFrame with a {lambda}
    expression. We first create a Timeline variable t ❹ and set a few other local
    parameters. The parameter frameCount is initially set to 0 and later incremented
    by 1 per frame. The dt parameter is the time step used in updating the velocity
    and position vectors. We’ve set it to 1, meaning each animation frame represents
    1 year (this may seem too large, but it’s all relative; the period for this star
    system is 722 Earth years long). Notice that the iterMax parameter is set to 1,
    which means the position and velocity vectors are updated only once per frame.
    If we wanted, we could use a different dt and iterMax combination to carry out
    iterMax updates of the position and velocity vectors before changing frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the KeyFrame class instance ❺, the {lambda} expression specifies what
    happens between the frame updates at a frequency specified by the Duration.millis()
    function. First, we call updateStarPositions() to calculate each star’s acceleration,
    velocity, and position. We then call drawStars() to update the positions of the
    stars on the canvas, and finally, we call updateAndDrawTrails() to trace out the
    trails for both stars. (We’ll review these functions separately.) Before exiting
    the KeyFrame block, we check for the stopping condition: if frameCount (the number
    of frames displayed) reaches frameCountMax, the timeline ends, and the animation
    is terminated ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: The final three lines complete the Timeline implementation. First, we supply
    the KeyFrame instance (k) to the timeline ❼. Next, we set cycleCount to INDEFINITE,
    which means continue the timeline until a stopping condition is met inside the
    KeyFrame or elsewhere in the program. Finally, t.play() starts the animation and
    sets the stars in motion.
  prefs: []
  type: TYPE_NORMAL
- en: '##### The updateStarPositions() Function'
  prefs: []
  type: TYPE_NORMAL
- en: The updateStarPositions() function implements the physics of binary stars in
    motion by using the formulas and algorithms we’ve discussed. The function takes
    in two arguments—a list of type Star called stars and the time step dt—and doesn’t
    return anything, since the function makes its updates directly to the globally
    accessible properties of the stars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function starts by calculating the distance between the two stars by using
    Equation 5.23\. We then use the scalar part of Equation 5.24 to calculate the
    magnitude of the gravitational force that both stars will experience ❶. Next,
    we iterate over the stars list and update the acceleration, velocity, and position
    for both stars per Equations 5.26 through 5.31 ❷. Notice that we save the current
    position vectors in the xOld and yOld properties of the stars before updating
    x and y ❸. We’ll need these so the stars’ trails will lag the stars themselves
    by one time step. Also notice how the variable sign switches from 1 to -1 at the
    end of the first iteration ❹. This inverts the direction of the force acting on
    the second star to ensure that ***F***1 = −***F***2.
  prefs: []
  type: TYPE_NORMAL
- en: The drawStars() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The drawStars() function simply updates the positions of the stars on the canvas
    to make them move. It takes in one parameter, the graphics context, and returns
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The function starts by clearing the canvas ❶. Then we redraw the objects in
    three stages. First, we call the drawAxes() function, which we’ve already reviewed,
    to draw the axes ❷. Since this happens first, the other objects (for example,
    the stars and the trails) will be drawn on top of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we connect the centers of the stars by using a dashed line ❸. The argument
    sequence (2.0, 4.0, 4.0, 2.0) means the dash lengths will be set in cycles of
    2, 4, 4, and 2 pixels. This line helps identify the center of rotation (the point
    where it intersects the x-axis) and will grow and shrink like a spring with the
    movements of the stars, making the simulation more interesting. For a circular
    and concentric orbit, this line also helps visually confirm that at any moment
    the binary stars are placed in diametrically opposite positions about the center
    of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use a for loop to iterate over the stars and draw them in their
    new positions ❹. Notice the use of scaleFactor while drawing the stars. This is
    a global variable that allows us to change the scale of the simulation on the
    fly without going through more complicated rescaling schemes that we’ve used elsewhere
    in the book. For this problem, since the orbit shapes and sizes can vary significantly
    during the simulations, I suggest that you adjust this scale factor based on your
    own setup. I used scaleFactor = 4 for the first simulation (for stable circular
    orbits) and scaleFactor = 1 for the second simulation (for stable elliptical orbits).
    In the latter case, the distance between the stars *r* varies significantly during
    the simulation, and we need to allocate more space on the canvas to fully outline
    the orbits.
  prefs: []
  type: TYPE_NORMAL
- en: '##### The updateAndDrawTrails() Function'
  prefs: []
  type: TYPE_NORMAL
- en: The two-in-one updateAndDrawTrails() function updates the trails and draws them
    at the same time. It takes one parameter, gc, and doesn’t return anything, just
    like the drawStars() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first block in this function iterates over the stars list and updates the
    positions of the trail elements. Recall that the initialPositions() function started
    all the tracers at the same position as the star itself, but we haven’t drawn
    any of them yet. Now we move the tracers one at a time (for each star). First,
    we check to see that unassigned tracers are ready to be moved to a new location
    by ensuring that star.trailCount < trailMAX. Otherwise, we reset trailCount to
    0 ❶. Each time a star moves to a new position, we assign the star’s old position
    to the next available tracer—the one at position [index][star.trailCount] in the
    trails array ❷. This is why we always save the old positions of the stars before
    updating them in the updateStarPositions() function.
  prefs: []
  type: TYPE_NORMAL
- en: This process continues as long as tracers remain to be moved from the initial
    position. Once all the tracers have been assigned new positions on the canvas
    (and the stars continue to move), resetting trailCount lets us recycle them by
    bringing the last one to the first position (right next to the star).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the tracer positions have been updated, the second block in the function
    draws the trails for both stars. For each trail, we use the same color as the
    color of the star it follows ❸ to draw the tracers. Finally, all the trails are
    drawn on the canvas, based on their most recent coordinates ❹. Once all the tracers
    are placed on the canvas, each trail will follow its parent star.  #### The Result'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the app, you should see a dynamic simulation of the binary star
    system in motion, as opposed to a static image. You’ll see the stars continuously
    dancing around each other on the screen until you close the window or wait for
    the frameCount to hit its limit. [Figure 5-13](chapter5.xhtml#fig5-13) shows screenshots
    of two different runs of the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-13: A binary star system with concentric, circular orbits (left) and
    a binary star system with elliptical orbits (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The example on the left shows a binary star system with concentric, circular
    orbits, meaning one star’s orbit is entirely contained within the other. For this,
    we used the initial conditions shown in the code listings. The example on the
    right simulates a system with elliptical orbits by using the same initial conditions,
    except x = -50.0 for star 1, x = 90.0 for star 2, and scaleFactor = 1.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to play around with the simulation by tweaking the initial conditions.
    Depending on the parameters, you may end up with an unstable system, in which
    case the stars fly off the screen or crash into each other. In fact, it’s much
    harder to create a stable system like the ones shown in the figure. This instability
    also happens with real binary star systems as they get perturbed by a variety
    of external forces that offset the delicate balance needed to maintain a stable
    orbit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we used Kotlin and laws of physics to solve a variety of science
    problems—from the projectile motion of cannonballs and water jets, to swinging
    pendulums and cooling cups of coffee, to the out-of-this-world dance of a binary
    star system. Along the way, we developed increasingly complex mathematical models
    of physical systems to study their behavior. To do so, we went beyond the basics
    of Kotlin, harnessing JavaFX’s visualization and animation tools to effectively
    display the results of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bate, Roger R., Donald D. Mueller, Jerry E. White, and William W. Saylor. *Fundamentals
    of Astrodynamics*. 2nd ed. Mineola, NY: Dover, 2020.'
  prefs: []
  type: TYPE_NORMAL
- en: Bennett, Andrew G. “Runge-Kutta Methods.” Accessed June 15, 2024\. *[https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php](https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cromer, Alan. “Stable Solutions Using the Euler Approximation.” *American Journal
    of Physics* 49, no. 5 (May 1981): 455–459\. *[https://doi.org/10.1119/1.12478](https://doi.org/10.1119/1.12478)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Demanet, Laurent. “Introduction to Numerical Analysis.” MIT OpenCourseWare,
    2012\. Accessed June 15, 2024\. *[https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/](https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Halliday, David, Robert Resnick, and Jearl Walker. *Fundamentals of Physics*.
    12th ed. New York: Wiley & Sons, 2021.'
  prefs: []
  type: TYPE_NORMAL
- en: Seyr, Alexander Josef. “Numerical Simulation of the Planetary Motions in the
    Solar System with Runge Kutta Methods.” November 6, 2020\. *[https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf](https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Young, Hugh, and Roger Freedman. *University Physics*. 15th ed. New York: Pearson,
    2020.'
  prefs: []
  type: TYPE_NORMAL
