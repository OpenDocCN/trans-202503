<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_103"/><span class="big"><strong>6</strong></span><br/><strong>SPECIAL VALUES, CLASSES, AND COERCION</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">You’ve now learned about numeric values, logicals, character strings, and factors, as well as their unique properties and applications. Now you’ll look at some special values in R that aren’t as well-defined. You’ll see how they might come about and how to handle and test for them. Then you’ll look at different data types in R and some general object class concepts.</p>&#13;
<h3 class="h3" id="ch06lev1sec21"><strong>6.1 Some Special Values</strong></h3>&#13;
<p class="noindent">Many situations in R call for special values. For example, when a data set has missing observations or when a practically infinite number is calculated, the software has some unique terms that it reserves for these situations. These special values can be used to mark abnormal or missing values in vectors, arrays, or other data structures.</p>&#13;
<h4 class="h4" id="ch06lev2sec55"><span epub:type="pagebreak" id="page_104"/><strong><em>6.1.1 Infinity</em></strong></h4>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch02lev1sec09">Section 2.1</a>, I mentioned that R imposes limits on how extreme a number can be before the software cannot reliably represent it. When a number is too large for R to represent, the value is deemed to be <em>infinite</em>. Of course, the mathematical concept of infinity (∞) does not correspond to a specific number—R simply has to define an extreme cutoff point. The precise cutoff value varies from system to system and is governed in part by the amount of memory R has access to. This value is represented by the special object <code>Inf</code>, which is case sensitive. Because it represents a numeric value, <code>Inf</code> can be associated only with numeric vectors. Let’s create some objects to test it out.</p>&#13;
<pre>R&gt; foo &lt;- Inf<br/>R&gt; foo<br/>[1] Inf<br/>R&gt; bar &lt;- c(3401,Inf,3.1,-555,Inf,43)<br/>R&gt; bar<br/>[1] 3401.0    Inf    3.1 -555.0    Inf   43.0<br/>R&gt; baz &lt;- 90000^100<br/>R&gt; baz<br/>[1] Inf</pre>&#13;
<p class="indent">Here, you’ve defined an object <code>foo</code> that is a single instance of an infinite value. You’ve also defined a numeric vector, <code>bar</code>, with two infinite elements, and then raised 90,000 to a power of 100 in <code>baz</code> to produce a result R deems infinite.</p>&#13;
<p class="indent">R can also represent negative infinity, with <code>-Inf</code>.</p>&#13;
<pre>R&gt; qux &lt;- c(-42,565,-Inf,-Inf,Inf,-45632.3)<br/>R&gt; qux<br/>[1]    -42.0    565.0     -Inf     -Inf     Inf -45632.3</pre>&#13;
<p class="indent">This creates a vector with two negative-infinite values and one positive-infinite value.</p>&#13;
<p class="indent">Though infinity does not represent any specific value, to a certain extent you can still perform mathematical operations on infinite values in R. For example, multiplying <code>Inf</code> by any negative value will result in <code>-Inf</code>.</p>&#13;
<pre>R&gt; Inf*-9<br/>[1] -Inf</pre>&#13;
<p class="indent">If you add to or multiply infinity, you also get infinity as a result.</p>&#13;
<pre>R&gt; Inf+1<br/>[1] Inf<br/>R&gt; 4*-Inf<br/>[1] -Inf<br/>R&gt; -45.2-Inf<br/>[1] -Inf<br/><span epub:type="pagebreak" id="page_105"/>R&gt; Inf-45.2<br/>[1] Inf<br/>R&gt; Inf+Inf<br/>[1] Inf<br/>R&gt; Inf/23<br/>[1] Inf</pre>&#13;
<p class="indent">Zero and infinity go hand in hand when it comes to division. Any (finite) numeric value divided by infinity, positive or negative, will result in zero.</p>&#13;
<pre>R&gt; -59/Inf<br/>[1] 0<br/>R&gt; -59/-Inf<br/>[1] 0</pre>&#13;
<p class="indent">Though it isn’t mathematically defined, note that in R, any nonzero value divided by zero will result in infinity (positive or negative depending on the sign of the numerator).</p>&#13;
<pre>R&gt; -59/0<br/>[1] -Inf<br/>R&gt; 59/0<br/>[1] Inf<br/>R&gt; Inf/0<br/>[1] Inf</pre>&#13;
<p class="indent">Often, you’ll simply want to detect infinite values in a data structure. The functions <code>is.infinite</code> and <code>is.finite</code> take in a collection of values, typically a vector, and return for each element a logical value answering the question posed. Here’s an example using <code>qux</code> from earlier:</p>&#13;
<pre>R&gt; qux<br/>[1]    -42.0    565.0     -Inf     -Inf     Inf -45632.3<br/>R&gt; is.infinite(x=qux)<br/>[1] FALSE FALSE  TRUE  TRUE  TRUE FALSE<br/>R&gt; is.finite(x=qux)<br/>[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE</pre>&#13;
<p class="indent">Note that these functions do not distinguish between positive or negative infinity, and the result of <code>is.finite</code> will always be the opposite (the negation) of the result of <code>is.infinite</code>.</p>&#13;
<p class="indent">Finally, relational operators function as you might expect.</p>&#13;
<pre>R&gt; -Inf&lt;Inf<br/>[1] TRUE<br/>R&gt; Inf&gt;Inf<br/>[1] FALSE<br/><span epub:type="pagebreak" id="page_106"/>R&gt; qux==Inf<br/>[1] FALSE FALSE FALSE FALSE  TRUE FALSE<br/>R&gt; qux==-Inf<br/>[1] FALSE FALSE  TRUE  TRUE FALSE FALSE</pre>&#13;
<p class="indent">Here, the first line confirms that <code>-Inf</code> is indeed treated as less than <code>Inf</code>, and the second line shows that <code>Inf</code> is not greater than <code>Inf</code>. The third and fourth lines, again using <code>qux</code>, test for equality, which is a useful way to distinguish between positive and negative infinity if you need to.</p>&#13;
<h4 class="h4" id="ch06lev2sec56"><strong><em>6.1.2 NaN</em></strong></h4>&#13;
<p class="noindent">In some situations, it’s impossible to express the result of a calculation using a number, <code>Inf</code>, or <code>-Inf</code>. These difficult-to-quantify special values are labeled <code>NaN</code> in R, which stands for <em>Not a Number</em>.</p>&#13;
<p class="indent">As with infinite values, <code>NaN</code> values are associated only with numeric observations. It’s possible to define or include a <code>NaN</code> value directly, but this is rarely the way they’re encountered.</p>&#13;
<pre>R&gt; foo &lt;- NaN<br/>R&gt; foo<br/>[1] NaN<br/>R&gt; bar &lt;- c(NaN,54.3,-2,NaN,90094.123,-Inf,55)<br/>R&gt; bar<br/>[1]      NaN    54.30    -2.00      NaN 90094.12      -Inf    55.00</pre>&#13;
<p class="indent">Typically, <code>NaN</code> is the unintended result of attempting a calculation that’s impossible to perform with the specified values.</p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch06lev2sec55">Section 6.1.1</a>, you saw that adding or subtracting from <code>Inf</code> or <code>-Inf</code> will simply result again in <code>Inf</code> or <code>-Inf</code>. However, if you attempt to cancel representations of infinity in any way, the result will be <code>NaN</code>.</p>&#13;
<pre>R&gt; -Inf+Inf<br/>[1] NaN<br/>R&gt; Inf/Inf<br/>[1] NaN</pre>&#13;
<p class="indent">Here, the first line won’t result in zero because positive and negative infinity can’t be interpreted in that numeric sense, so you get <code>NaN</code> as a result. The same thing happens if you attempt to divide <code>Inf</code> by itself. In addition, although you saw earlier that a nonzero value divided by zero will result in positive or negative infinity, <code>NaN</code> results when <em>zero</em> is divided by zero.</p>&#13;
<pre>R&gt; 0/0<br/>[1] NaN</pre>&#13;
<p class="indent">Note that any mathematical operation involving <code>NaN</code> will simply result in <code>NaN</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_107"/>R&gt; NaN+1<br/>[1] NaN<br/>R&gt; 2+6*(4-4)/0<br/>[1] NaN<br/>R&gt; 3.5^(-Inf/Inf)<br/>[1] NaN</pre>&#13;
<p class="indent">In the first line, adding 1 to “not a number” is still <code>NaN</code>. In the second line, you obtain <code>NaN</code> from the <code>(4-4)/0</code>, which is clearly <code>0/0</code>, so the result is also <code>NaN</code>. In the third line, <code>NaN</code> results from <code>-Inf/Inf</code>, so the result of the remaining calculation is again <code>NaN</code>. This begins to give you an idea of how <code>NaN</code> or infinite values might unintentionally crop up. If you have a function where various values are passed to a fixed calculation and you don’t take care to prevent, for example, <code>0/0</code> from occurring, then the code will return <code>NaN</code>.</p>&#13;
<p class="indent">Like with <code>Inf</code>, a special function (<code>is.nan</code>) is used to detect the presence of <code>NaN</code> values. Unlike infinite values, however, relational operators cannot be used with <code>NaN</code>. Here’s an example using <code>bar</code>, which was defined earlier:</p>&#13;
<pre>R&gt; bar<br/>[1]      NaN    54.30    -2.00      NaN 90094.12      -Inf      55.00<br/>R&gt; is.nan(x=bar)<br/>[1]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE<br/>R&gt; !is.nan(x=bar)<br/>[1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE<br/>R&gt; is.nan(x=bar)|is.infinite(x=bar)<br/>[1]  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE<br/>R&gt; bar[-(which(is.nan(x=bar)|is.infinite(x=bar)))]<br/>[1]    54.30    -2.00 90094.12    55.00</pre>&#13;
<p class="indent">Using the <code>is.nan</code> function on <code>bar</code> flags the two <code>NaN</code> positions as <code>TRUE</code>. In the second example, you use the negation operator <code>!</code> to flag the positions where the elements are NOT <code>NaN</code>. Using the element-wise OR, <code>|</code> (see <a href="ch04.xhtml#ch04lev2sec39">Section 4.1.3</a>), you then identify elements that are either <code>NaN</code> OR infinite. Finally, the last line uses <code>which</code> to convert these logical values into numeric index positions so that you can remove them with negative indexes in square brackets (see <a href="ch04.xhtml#ch04lev2sec41">Section 4.1.5</a> for a refresher on using <code>which</code>).</p>&#13;
<p class="indent">You can find more details on the functionality and behavior of <code>NaN</code> and <code>Inf</code> in the R help file by entering <code>?Inf</code> at the prompt.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch6exc1"/><strong>Exercise 6.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Store the following vector:</p>&#13;
<pre>foo &lt;- c(13563,-14156,-14319,16981,12921,11979,9568,8833,-12968,<br/>         8133)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Output all elements of <code>foo</code> that, when raised to a power of 75, are NOT infinite.</p></li>&#13;
<li><p class="noindent">Return the elements of <code>foo</code>, excluding those that result in negative infinity when raised to a power of 75.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Store the following 3 × 4 matrix as the object <code>bar</code>:</p>&#13;
<div class="imagec"><img src="../images/f0108-01.jpg" alt="image"/></div>&#13;
<p class="indentb">Now, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Identify the coordinate-specific indexes of the entries of <code>bar</code> that are <code>NaN</code> when you raise <code>bar</code> to a power of 65 and divide by infinity.</p></li>&#13;
<li><p class="noindent">Return the values in <code>bar</code> that are NOT <code>NaN</code> when <code>bar</code> is raised to a power of 67 and infinity is added to the result. Confirm this is identical to identifying those values in <code>bar</code> that, when raised to a power of 67, are not equal to negative infinity.</p></li>&#13;
<li><p class="noindent">Identify those values in <code>bar</code> that are either negative infinity OR finite when you raise <code>bar</code> to a power of 67.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec57"><strong><em>6.1.3 NA</em></strong></h4>&#13;
<p class="noindent">In statistical analyses, data sets often contain missing values. For example, someone filling out a questionnaire may not respond to a particular item, or a researcher may record some observations from an experiment incorrectly. Identifying and handling missing values is important so that you can still use the rest of the data. R provides a standard special term to represent missing values, <code>NA</code>, which reads as <em>Not Available</em>.</p>&#13;
<p class="indent"><code>NA</code> entries are not the same as <code>NaN</code> entries. Whereas <code>NaN</code> is used only with respect to numeric operations, missing values can occur for any type of observation. As such, <code>NA</code>s can exist in both numeric and non-numeric settings. Here’s an example:</p>&#13;
<pre>R&gt; foo &lt;- c("character","a",NA,"with","string",NA)<br/>R&gt; foo<br/>[1] "character" "a"         NA          "with"      "string"    NA<br/>R&gt; bar &lt;- factor(c("blue",NA,NA,"blue","green","blue",NA,"red","red",NA,<br/>                 "green"))<br/>R&gt; bar<br/> [1] blue  &lt;NA&gt;  &lt;NA&gt;  blue  green blue  &lt;NA&gt;   red   red  &lt;NA&gt;  green<br/>Levels: blue green red<br/>R&gt; baz &lt;- matrix(c(1:3,NA,5,6,NA,8,NA),nrow=3,ncol=3)<br/>R&gt; baz<br/>     [,1] [,2] [,3]<br/>[1,]    1   NA   NA<br/>[2,]    2    5    8<br/>[3,]    3    6    NA</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>The object <code>foo</code> is a character vector with entries 3 and 6 missing; <code>bar</code> is a factor vector of length 11 with elements 2, 3, 7, and 10 missing; and <code>baz</code> is a numeric matrix with row 1, columns 2 and 3, and row 3, column 3, elements missing. In the factor vector, note that the <code>NA</code>s are printed as <code>&lt;NA&gt;</code>. This is to differentiate between bona fide levels of the factor and the missing observations, to prevent <code>NA</code> from being mistakenly interpreted as one of the levels.</p>&#13;
<p class="indent">Like the other special values so far, you can identify <code>NA</code> elements using the function <code>is.na</code>. This is often useful for removing or replacing <code>NA</code> values. Consider the following numeric vector:</p>&#13;
<pre>R&gt; qux &lt;- c(NA,5.89,Inf,NA,9.43,-2.35,NaN,2.10,-8.53,-7.58,NA,-4.58,2.01,NaN)<br/>R&gt; qux<br/> [1]    NA  5.89   Inf    NA  9.43 -2.35   NaN  2.10 -8.53 -7.58    NA -4.58<br/>[13]  2.01   NaN</pre>&#13;
<p class="indent">This vector has a total of 14 entries, including <code>NA</code>, <code>NaN</code>, and <code>Inf</code>.</p>&#13;
<pre>R&gt; is.na(x=qux)<br/> [1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE<br/>[13] FALSE  TRUE</pre>&#13;
<p class="indent">As you can see, <code>is.na</code> flags the corresponding <code>NA</code> entries in <code>qux</code> as <code>TRUE</code>. But this is not all—note that it also flags elements 7 and 14, which are <code>NaN</code>, not <code>NA</code>. Strictly speaking, <code>NA</code> and <code>NaN</code> are different entities, but numericly they are practically the same since there is almost nothing you can do with either value. Using <code>is.na</code> labels both as <code>TRUE</code>, allowing the user to remove or recode both at the same time.</p>&#13;
<p class="indent">If you want to identify <code>NA</code> and <code>NaN</code> entries separately, you can use <code>is.nan</code> in conjunction with logical operators. Here’s an example:</p>&#13;
<pre>R&gt; which(x=is.nan(x=qux))<br/>[1]  7 14</pre>&#13;
<p class="indent">This identifies the index positions whose elements are specifically <code>NaN</code>. If you want to identify <code>NA</code> entries only, try the following:</p>&#13;
<pre>R&gt; which(x=(is.na(x=qux)&amp;!is.nan(x=qux)))<br/>[1]  1  4 11</pre>&#13;
<p class="indent">This identifies the element indexes for only the <code>NA</code> entries (by checking for entries where <code>is.na</code> is <code>TRUE</code> AND where <code>is.nan</code> is NOT <code>TRUE</code>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>After locating the offending elements, you could use negative indexes in square brackets to remove them, though R offers a more direct option. The function <code>na.omit</code> will take a structure and delete all <code>NA</code>s from it; <code>na.omit</code> will also apply to <code>NaN</code>s if the elements are numeric.</p>&#13;
<pre>R&gt; quux &lt;- na.omit(object=qux)<br/>R&gt; quux<br/>[1]  5.89   Inf  9.43 -2.35  2.10 -8.53 -7.58 -4.58  2.01<br/>attr(,"na.action")<br/>[1]  1  4  7 11 14<br/>attr(,"class")<br/>[1] "omit"</pre>&#13;
<p class="indent">Note that the structure passed to <code>na.omit</code> is given as the argument <code>object</code> and that some additional output is displayed in printing the returned object. These extra details are provided to inform the user that there were elements in the original vector that were removed (in this case, the element positions provided in the attribute <code>na.action</code>). Attributes will be discussed more in <a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>.</p>&#13;
<p class="indent">Similar to <code>NaN</code>, arithmetic calculations with <code>NA</code> result in <code>NA</code>. Using relational operators with either <code>NaN</code> or <code>NA</code> will also result in <code>NA</code>.</p>&#13;
<pre>R&gt; 3+2.1*NA-4<br/>[1] NA<br/>R&gt; 3*c(1,2,NA,NA,NaN,6)<br/>[1]   3   6  NA  NA NaN  18<br/>R&gt; NA&gt;76<br/>[1] NA<br/>R&gt; 76&gt;NaN<br/>[1] NA</pre>&#13;
<p class="indent">You can find more details on the usage and finer technicalities of <code>NA</code> values by entering <code>?NA</code>.</p>&#13;
<h4 class="h4" id="ch06lev2sec58"><strong><em>6.1.4 NULL</em></strong></h4>&#13;
<p class="noindent">Finally, you’ll look at the <em>null</em> value, written as <code>NULL</code>. This value is often used to explicitly define an “empty” entity, which is quite different from a “missing” entity specified with <code>NA</code>. An instance of <code>NA</code> clearly denotes an existing position that can be accessed and/or overwritten if necessary—not so for <code>NULL</code>. You can see an indication of this if you compare the assignment of <code>NA</code> with the assignment of a <code>NULL</code>.</p>&#13;
<pre>R&gt; foo &lt;- NULL<br/>R&gt; foo<br/>NULL<br/>R&gt; bar &lt;- NA<br/><span epub:type="pagebreak" id="page_111"/>R&gt; bar<br/>[1] NA</pre>&#13;
<p class="indent">Note that <code>bar</code>, the <code>NA</code> object, is printed with an index position <code>[1]</code>. This suggests you have a vector with a single element. In contrast, you explicitly instructed <code>foo</code> to be empty with <code>NULL</code>. Printing this object doesn’t provide a position index because there is no position to access.</p>&#13;
<p class="indent">This interpretation of <code>NULL</code> also applies to vectors that have other well-defined items. Consider the following two lines of code:</p>&#13;
<pre>R&gt; c(2,4,NA,8)<br/>[1]  2  4 NA  8<br/>R&gt; c(2,4,NULL,8)<br/>[1] 2 4 8</pre>&#13;
<p class="indent">The first line creates a vector of length 4, with the third position coded as <code>NA</code>. The second line creates a similar vector but using <code>NULL</code> instead of <code>NA</code>. The result is a vector with a length of only 3. That’s because <code>NULL</code> cannot take up a position in the vector. As such, it makes no sense to assign <code>NULL</code> to multiple positions in a vector (or any other structure). Again, here’s an example:</p>&#13;
<pre>R&gt; c(NA,NA,NA)<br/>[1] NA NA NA<br/>R&gt; c(NULL,NULL,NULL)<br/>NULL</pre>&#13;
<p class="indent">The first line can be interpreted as “three possible slots with unrecorded observations.” The second line simply provides “emptiness three times,” which is interpreted as one single, unsubsettable, empty object.</p>&#13;
<p class="indent">At this point, you might wonder why there is even a need for <code>NULL</code>. If something is empty and doesn’t exist, why define it in the first place? The answer lies in the need to be able to explicitly state or check whether a certain object has been defined. This occurs often when calling functions in R. For example, when a function contains optional arguments, internally the function has to check which of those arguments have been supplied and which are missing or empty. The <code>NULL</code> value is a useful and flexible tool that the author of a function can use to facilitate such checks. You’ll see examples of this later on in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>&#13;
<p class="indent">The <code>is.null</code> function is used to check whether something is explicitly <code>NULL</code>. Suppose you have a function with an optional argument named <code>opt.arg</code> and that, if supplied, <code>opt.arg</code> should be a character vector of length 3. Let’s say a user calls this function with the following.</p>&#13;
<pre>R&gt; opt.arg &lt;- c("string1","string2","string3")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>Now if you check whether the argument was supplied using <code>NA</code>, you might call this:</p>&#13;
<pre>R&gt; is.na(x=opt.arg)<br/>[1] FALSE FALSE FALSE</pre>&#13;
<p class="indent">The position-specific nature of <code>NA</code> means that this check is element-wise and returns an answer for each value in <code>opt.arg</code>. This is problematic because you want only a single answer—is <code>opt.arg</code> empty or is it supplied? This is when <code>NULL</code> comes to the party.</p>&#13;
<pre>R&gt; is.null(x=opt.arg)<br/>[1] FALSE</pre>&#13;
<p class="indent">Quite clearly <code>opt.arg</code> is not empty, and the function can proceed as necessary. If the argument is empty, using <code>NULL</code> over <code>NA</code> for the check is again better for these purposes.</p>&#13;
<pre>R&gt; opt.arg &lt;- c(NA,NA,NA)<br/>R&gt; is.na(x=opt.arg)<br/>[1] TRUE TRUE TRUE<br/><br/>R&gt; opt.arg &lt;- c(NULL,NULL,NULL)<br/>R&gt; is.null(x=opt.arg)<br/>[1] TRUE</pre>&#13;
<p class="indent">As noted earlier, filling a vector with <code>NULL</code> isn’t usual practice; it’s done here just for illustration. But usage of <code>NULL</code> is far from specific to this particular example. It’s commonly used throughout both ready-to-use and user-contributed functionality in R.</p>&#13;
<p class="indent">The empty <code>NULL</code> has an interesting effect if it’s included in arithmetic or relational comparisons.</p>&#13;
<pre>R&gt; NULL+53<br/>numeric(0)<br/>R&gt; 53&lt;=NULL<br/>logical(0)</pre>&#13;
<p class="indent">Rather than <code>NULL</code> as you might expect, the result is an “empty” vector of a type determined by the nature of the operation attempted. <code>NULL</code> typically dominates any arithmetic, even if it includes other special values.</p>&#13;
<pre>R&gt; NaN-NULL+NA/Inf<br/>numeric(0)</pre>&#13;
<p class="indent"><code>NULL</code> also occurs naturally when examining lists and data frames. For example, define a new list <code>foo</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_113"/>R&gt; foo &lt;- list(member1=c(33,1,5.2,7),member2="NA or NULL?")<br/>R&gt; foo<br/>$member1<br/>[1] 33.0  1.0  5.2  7.0<br/><br/>$member2<br/>[1] "NA or NULL?"</pre>&#13;
<p class="indent">This list obviously doesn’t include a member called <code>member3</code>. Look at what happens when you try to access a member in <code>foo</code> by that name:</p>&#13;
<pre>R&gt; foo$member3<br/>NULL</pre>&#13;
<p class="indent">The result of <code>NULL</code> signals that a member called <code>member3</code> in <code>foo</code> doesn’t exist, or in R terms, is empty. Therefore, it can be filled with whatever you want.</p>&#13;
<pre>R&gt; foo$member3 &lt;- NA<br/>R&gt; foo<br/>$member1<br/>[1] 33.0  1.0  5.2  7.0<br/><br/>$member2<br/>[1] "NA or NULL?"<br/><br/>$member3<br/>[1] NA</pre>&#13;
<p class="indent">The same principle applies when querying a data frame for a nonexistent column or variable using the dollar operator (as in <a href="ch05.xhtml#ch05lev2sec53">Section 5.2.2</a>).</p>&#13;
<p class="indent">For more technical details on how <code>NULL</code> and <code>is.null</code> are handled by R, see the help file accessed by <code>?NULL</code>.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch6exc2"/><strong>Exercise 6.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Consider the following line of code:</p>&#13;
<pre>foo &lt;- c(4.3,2.2,NULL,2.4,NaN,3.3,3.1,NULL,3.4,NA)</pre>&#13;
<p class="indent">Decide yourself which of the following statements are true and which are false and then use R to confirm:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">The length of <code>foo</code> is 8.</p></li>&#13;
<li><p class="noindent">Calling <code>which(x=is.na(x=foo))</code> will not result in <code>4</code> and <code>8</code>.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_114"/>Checking <code>is.null(x=foo)</code> will provide you with the locations of the two <code>NULL</code> values that are present.</p></li>&#13;
<li><p class="noindent">Executing <code>is.na(x=foo[8])+4/NULL</code> will not result in <code>NA</code>.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Create and store a list containing a single member: the vector <code>c(7,7,NA,3,NA,1,1,5,NA)</code>. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Name the member <code>"alpha"</code>.</p></li>&#13;
<li><p class="noindent">Confirm that the list doesn’t have a member with the name <code>"beta"</code> using the appropriate logical valued function.</p></li>&#13;
<li><p class="noindent">Add a new member called <code>beta</code>, which is the vector obtained by identifying the index positions of <code>alpha</code> that are <code>NA</code>.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec22"><strong>6.2 Understanding Types, Classes, and Coercion</strong></h3>&#13;
<p class="noindent">By now, you’ve studied many of the fundamental features in the R language for representing, storing, and handling data. In this section, you’ll examine how to formally distinguish between different kinds of values and structures and look at some simple examples of conversion from one type to another.</p>&#13;
<h4 class="h4" id="ch06lev2sec59"><strong><em>6.2.1 Attributes</em></strong></h4>&#13;
<p class="noindent">Each R object you create has additional information about the nature of the object itself. This additional information is referred to as the object’s <em>attributes</em>. You’ve see a few attributes already. In <a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>, you identified the dimensions attribute of a matrix using <code>dim</code>. In <a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a>, you used <code>levels</code> to get the levels attribute of a factor. It was also noted that <code>names</code> can get the member names of a list in <a href="ch05.xhtml#ch05lev2sec50">Section 5.1.2</a>, and in <a href="ch06.xhtml#ch06lev2sec57">Section 6.1.3</a>, that an attribute annotates the result of applying <code>na.omit</code>.</p>&#13;
<p class="indent">In general, you can think of attributes as either <em>explicit</em> or <em>implicit</em>. Explicit attributes are immediately visible to the user, while R determines implicit attributes internally. You can print explicit attributes for a given object with the <code>attributes</code> function, which takes any object and returns a named list. Consider, for example, the following 3 × 3 matrix:</p>&#13;
<pre>R&gt; foo &lt;- matrix(data=1:9,nrow=3,ncol=3)<br/>R&gt; foo<br/>     [,1] [,2] [,3]<br/>[1,]    1    4    7<br/>[2,]    2    5    8<br/>[3,]    3    6    9<br/><br/>R&gt; attributes(foo)<br/>$dim<br/>[1] 3 3</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>Here, calling <code>attributes</code> returns a list with one member: <code>dim</code>. Of course, you can retrieve the contents of <code>dim</code> with <code>attributes(foo)$dim</code>, but if you know the name of an attribute, you can also use <code>attr</code>:</p>&#13;
<pre>R&gt; attr(x=foo,which="dim")<br/>[1] 3 3</pre>&#13;
<p class="indent">This function takes the object in as <code>x</code> and the name of the attribute as <code>which</code>. Recall that names are specified as character strings in R. To make things even more convenient, the most common attributes have their own functions (usually named after the attribute) to access the corresponding value. For the dimensions of a matrix, you’ve already seen the function <code>dim</code>.</p>&#13;
<pre>R&gt; dim(foo)<br/>[1] 3 3</pre>&#13;
<p class="indent">These attribute-specific functions are useful because they also allow access to implicit attributes, which, while still controllable by the user, are set automatically by the software as a matter of necessity. The <code>names</code> and <code>levels</code> functions mentioned earlier are also both attribute-specific functions.</p>&#13;
<p class="indent">Explicit attributes are often optional; if they aren’t specified, they are <code>NULL</code>. For example, when building a matrix with the <code>matrix</code> function, you can use the optional argument <code>dimnames</code> to annotate the rows and columns with names. You pass <code>dimnames</code> a list made up of two members, both character vectors of the appropriate lengths—the first giving row names and the second giving column names. Let’s define the matrix <code>bar</code> as follows:</p>&#13;
<pre>R&gt; bar &lt;- matrix(data=1:9,nrow=3,ncol=3,dimnames=list(c("A","B","C"),<br/>                 c("D","E","F")))<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indent">Because the dimension names are attributes, the <code>dimnames</code> appear when you call <code>attributes(bar)</code>.</p>&#13;
<pre>R&gt; attributes(bar)<br/>$dim<br/>[1] 3 3<br/><br/>$dimnames<br/>$dimnames[[1]]<br/>[1] "A" "B" "C"<br/><br/>$dimnames[[2]]<br/>[1] "D" "E" "F"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Note that <code>dimnames</code> is itself a list, nested inside the larger attributes list. Again, to extract the values of this attribute, you can use list member referencing, you can use <code>attr</code> as shown earlier, or you can use the attribute-specific function.</p>&#13;
<pre>R&gt; dimnames(bar)<br/>[[1]]<br/>[1] "A" "B" "C"<br/><br/>[[2]]<br/>[1] "D" "E" "F"</pre>&#13;
<p class="indent">Some attributes can be modified after an object has been created (as you saw already in <a href="ch05.xhtml#ch05lev2sec50">Section 5.1.2</a>, where you renamed members of a list). Here, to make <code>foo</code> match <code>bar</code> exactly, you can give <code>foo</code> some <code>dimnames</code> by assigning them to the attribute-specific function:</p>&#13;
<pre>R&gt; dimnames(foo) &lt;- list(c("A","B","C"),c("D","E","F"))<br/>R&gt; foo<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indent">I’ve used matrices in the discussion here, but optional attributes for other objects in R are treated the same way. Attributes are not restricted to built-in R objects, either. Objects you build yourself can be defined with their own attributes and attribute-specific functions. Just remember that the role of an attribute is typically to provide descriptive data about an object, or you could end up overcomplicating your object structures unnecessarily.</p>&#13;
<h4 class="h4" id="ch06lev2sec60"><strong><em>6.2.2 Object Class</em></strong></h4>&#13;
<p class="noindent">An object’s <em>class</em> is one of the most useful attributes for describing an entity in R. Every object you create is identified, either implicitly or explicitly, with at least one class. R is an <em>object-oriented</em> programming language, meaning entities are stored as objects and have methods that act upon them. In such a language, class identification is formally referred to as <em>inheritance</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This section will focus on the most common classing structure used in R, called</em> S3. <em>There is another structure,</em> S4<em>, which is essentially a more formal set of rules for the identification and treatment of different objects. For most practical intents and certainly for beginners, understanding and using S3 will be sufficient. You can find further details in R’s online documentation.</em></p>&#13;
</div>&#13;
<p class="indent">The class of an object is explicit in situations where you have user-defined object structures or an object such as a factor vector or data frame where other attributes play an important part in the handling of the object itself—for example, level labels of a factor vector, or variable names in a data <span epub:type="pagebreak" id="page_117"/>frame, are modifiable attributes that play a primary role in accessing the observations of each object. Elementary R objects such as vectors, matrices, and arrays, on the other hand, are implicitly classed, which means the class is not identified with the <code>attributes</code> function. Whether implicit or explicit, the class of a given object can always be retrieved using the attribute-specific function <code>class</code>.</p>&#13;
<h5 class="h5" id="ch06lev3sec13"><strong>Stand-Alone Vectors</strong></h5>&#13;
<p class="noindent">Let’s create some simple vectors to use as examples.</p>&#13;
<pre>R&gt; num.vec1 &lt;- 1:4<br/>R&gt; num.vec1<br/>[1] 1 2 3 4<br/>R&gt; num.vec2 &lt;- seq(from=1,to=4,length=6)<br/>R&gt; num.vec2<br/>[1] 1.0 1.6 2.2 2.8 3.4 4.0<br/>R&gt; char.vec &lt;- c("a","few","strings","here")<br/>R&gt; char.vec<br/>[1] "a"       "few"     "strings" "here"<br/>R&gt; logic.vec &lt;- c(T,F,F,F,T,F,T,T)<br/>R&gt; logic.vec<br/>[1]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE<br/>R&gt; fac.vec &lt;- factor(c("Blue","Blue","Green","Red","Green","Yellow"))<br/>R&gt; fac.vec<br/>[1] Blue   Blue   Green  Red    Green  Yellow<br/>Levels: Blue Green Red Yellow</pre>&#13;
<p class="indent">You can pass any object to the <code>class</code> function, and it returns a character vector as output. Here are examples using the vectors just created:</p>&#13;
<pre>R&gt; class(num.vec1)<br/>[1] "integer"<br/>R&gt; class(num.vec2)<br/>[1] "numeric"<br/>R&gt; class(char.vec)<br/>[1] "character"<br/>R&gt; class(logic.vec)<br/>[1] "logical"<br/>R&gt; class(fac.vec)<br/>[1] "factor"</pre>&#13;
<p class="indent">The output from using <code>class</code> on the character vector, the logical vector, and the factor vector simply match the kind of data that has been stored. The output from the number vectors is a little more intricate, however. So far, I’ve referred to any object with an arithmetically valid set of numbers as “numeric.” If all the numbers stored in a vector are whole, then R identifies the vector as <code>"integer"</code>. Numbers with decimal places (called <em>floating-point</em> numbers), on the other hand, are identified as <code>"numeric"</code>. This distinction <span epub:type="pagebreak" id="page_118"/>is necessary because some tasks strictly require integers, not floating-point numbers. Colloquially, I’ll continue to refer to both types as “numeric” and in fact, the <code>is.numeric</code> function will return <code>TRUE</code> for both integer and floatingpoint structures, as you’ll see in <a href="ch06.xhtml#ch06lev2sec61">Section 6.2.3</a>.</p>&#13;
<h5 class="h5" id="ch06lev3sec14"><strong>Other Data Structures</strong></h5>&#13;
<p class="noindent">As mentioned earlier, R’s classes are essentially designed to facilitate object-oriented programming. As such, <code>class</code> usually reports on the nature of the data <em>structure</em>, rather than the type of data that’s stored—it returns the data type only when used on stand-alone vectors. Let’s try it on some matrices.</p>&#13;
<pre>R&gt; num.mat1 &lt;- matrix(data=num.vec1,nrow=2,ncol=2)<br/>R&gt; num.mat1<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/>R&gt; num.mat2 &lt;- matrix(data=num.vec2,nrow=2,ncol=3)<br/>R&gt; num.mat2<br/>     [,1] [,2] [,3]<br/>[1,]  1.0  2.2  3.4<br/>[2,]  1.6  2.8  4.0<br/>R&gt; char.mat &lt;- matrix(data=char.vec,nrow=2,ncol=2)<br/>R&gt; char.mat<br/>     [,1]  [,2]<br/>[1,] "a"   "strings"<br/>[2,] "few" "here"<br/>R&gt; logic.mat &lt;- matrix(data=logic.vec,nrow=4,ncol=2)<br/>R&gt; logic.mat<br/>      [,1]  [,2]<br/>[1,]  TRUE  TRUE<br/>[2,] FALSE FALSE<br/>[3,] FALSE  TRUE<br/>[4,] FALSE  TRUE</pre>&#13;
<p class="indent">Note from <a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a> that factors are used only in vector form, so <code>fac.vec</code> is not included here. Now check these matrices with <code>class</code>.</p>&#13;
<pre>R&gt; class(num.mat1)<br/>[1] "matrix"<br/>R&gt; class(num.mat2)<br/>[1] "matrix"<br/>R&gt; class(char.mat)<br/>[1] "matrix"<br/>R&gt; class(logic.mat)<br/>[1] "matrix"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>You see that regardless of the data type, <code>class</code> reports the structure of the object itself—all matrices. The same is true for other object structures, like arrays, lists, and data frames.</p>&#13;
<h5 class="h5" id="ch06lev3sec15"><strong>Multiple Classes</strong></h5>&#13;
<p class="noindent">Certain objects will have multiple classes. A variant on a standard form of an object, such as an ordered factor vector, will inherit the usual factor class and also contain the additional <code>ordered</code> class. Both are returned if you use the <code>class</code> function.</p>&#13;
<pre>R&gt; ordfac.vec &lt;- factor(x=c("Small","Large","Large","Regular","Small"),<br/>                        levels=c("Small","Regular","Large"),<br/>                        ordered=TRUE)<br/>R&gt; ordfac.vec<br/>[1] Small   Large   Large   Regular Small<br/>Levels: Small &lt; Regular &lt; Large<br/>R&gt; class(ordfac.vec)<br/>[1] "ordered" "factor"</pre>&#13;
<p class="indent">Earlier, <code>fac.vec</code> was identified as <code>"factor"</code> only, but the class of <code>ordfac.vec</code> has two components. It’s still identified as <code>"factor"</code>, but it also includes <code>"ordered"</code>, which identifies the variant of the <code>"factor"</code> class also present in the object. Here, you can think of <code>"ordered"</code> as a <em>subclass</em> of <code>"factor"</code>. In other words, it is a special case that inherits from, and therefore behaves like, a <code>"factor"</code>. For further technical details on R subclasses, I recommend <a href="ch09.xhtml#ch09">Chapter 9</a> of <em>The Art of R Programming</em> by Matloff (<a href="ref.xhtml#ref44">2011</a>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I have focused on the</em> <code><span class="codeitalic">class</code></span> <em>function here because it’s directly relevant to the object-oriented programming style exercised in this text, especially in <a href="part02.xhtml#part02">Part II</a>. There are other functions that show some of the complexities of R’s classing rules. For example, the function</em> <code><span class="codeitalic">typeof</code></span> <em>reports the type of data contained within an object, not just for vectors but also for matrices and arrays. Note, however, that the terminology in the output of</em> <code><span class="codeitalic">typeof</code></span> <em>doesn’t always match the output of</em> <code><span class="codeitalic">class</code></span><em>. See the help file</em> <code><span class="codeitalic">?typeof</code></span> <em>for details on the values it returns.</em></p>&#13;
</div>&#13;
<p class="indent">To summarize, an object’s class is first and foremost a descriptor of the data structure, though for simple vectors, the <code>class</code> function reports the type of data stored. If the vector entries are exclusively whole numbers, then R classes the vector as <code>"integer"</code>, whereas <code>"numeric"</code> is used to label a vector with floating-point numbers.</p>&#13;
<h4 class="h4" id="ch06lev2sec61"><strong><em>6.2.3 Is-Dot Object-Checking Functions</em></strong></h4>&#13;
<p class="noindent">Identifying the class of an object is essential for functions that operate on stored objects, especially those that behave differently depending on the class of the object. To check whether the object is a specific class or data type, you can use the <em>is-dot</em> functions on the object and it will return a <code>TRUE</code> or <code>FALSE</code> logical value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>Is-dot functions exist for almost any sensible check you can think of. For example, consider once more the <code>num.vec1</code> vector from <a href="ch06.xhtml#ch06lev2sec60">Section 6.2.2</a> and the following six checks:</p>&#13;
<pre>R&gt; num.vec1 &lt;- 1:4<br/>R&gt; num.vec1<br/>[1] 1 2 3 4<br/>R&gt; is.integer(num.vec1)<br/>[1] TRUE<br/>R&gt; is.numeric(num.vec1)<br/>[1] TRUE<br/>R&gt; is.matrix(num.vec1)<br/>[1] FALSE<br/>R&gt; is.data.frame(num.vec1)<br/>[1] FALSE<br/>R&gt; is.vector(num.vec1)<br/>[1] TRUE<br/>R&gt; is.logical(num.vec1)<br/>[1] FALSE</pre>&#13;
<p class="indent">The first, second, and sixth is-dot functions check the kind of data stored in the object, while the others check the structure of the object itself. The results are to be expected: <code>num.vec1</code> <em>is</em> an “integer” (and <em>is</em> “numeric”), and it <em>is</em> a “vector.” It’s not a matrix or a data frame, nor is it logical.</p>&#13;
<p class="indent">Briefly, it’s worth noting that these checks use more general categories than the formal classes identified with <code>class</code>. Recall that <code>num.vec1</code> was identified solely as <code>"integer"</code> in <a href="ch06.xhtml#ch06lev2sec60">Section 6.2.2</a>, but using <code>is.numeric</code> here still returns <code>TRUE</code>. In this example, the <code>num.vec1</code> with integer data is generalized to be <code>"numeric"</code>. Similarly, for a data frame, an object of class <code>"data.frame"</code> will return <code>TRUE</code> for <code>is.data.frame</code> <em>and</em> <code>is.list</code> because a data frame is intuitively generalized to a list.</p>&#13;
<p class="indent">There’s a difference between the object is-dot functions detailed here and functions such as <code>is.na</code> discussed in <a href="ch06.xhtml#ch06lev1sec21">Section 6.1</a>. The functions to check for the special values like <code>NA</code> should be thought of as a check for equality; they exist because it is not legal syntax to write something like <code>foo==NA</code>. Those functions from <a href="ch06.xhtml#ch06lev1sec21">Section 6.1</a> thus operate in R’s element-wise fashion, whereas the object is-dot functions inspect the object <em>itself</em>, returning only a single logical value.</p>&#13;
<h4 class="h4" id="ch06lev2sec62"><strong><em>6.2.4 As-Dot Coercion Functions</em></strong></h4>&#13;
<p class="noindent">You’ve seen different ways to modify an object after it’s been created—by accessing and overwriting elements, for example. But what about the structure of the object itself and the type of data contained within?</p>&#13;
<p class="indent">Converting from one object or data type to another is referred to as <em>coercion</em>. Like other features of R you’ve met so far, coercion is performed either implicitly or explicitly. Implicit coercion occurs automatically when <span epub:type="pagebreak" id="page_121"/>elements need to be converted to another type in order for an operation to complete. In fact, you’ve come across this behavior already, in <a href="ch04.xhtml#ch04lev2sec40">Section 4.1.4</a>, for example, when you used numeric values for logical values. Remember that logical values can be thought of as integers—one for <code>TRUE</code> and zero for <code>FALSE</code>. Implicit coercion of logical values to their numeric counterparts occurs in lines of code like this:</p>&#13;
<pre>R&gt; 1:4+c(T,F,F,T)<br/>[1] 2 2 3 5</pre>&#13;
<p class="indent">In this operation, R recognizes that you’re attempting an arithmetic calculation with <code>+</code>, so it expects numeric quantities. Since the logical vector is not in this form, the software internally coerces it to ones and zeros before completing the task.</p>&#13;
<p class="indent">Another frequent example of implicit coercion is when <code>paste</code> and <code>cat</code> are used to glue together character strings, as explored in <a href="ch04.xhtml#ch04lev2sec43">Section 4.2.2</a>. Non-character entries are automatically coerced to strings before the concatenation takes place. Here’s an example:</p>&#13;
<pre>R&gt; foo &lt;- 34<br/>R&gt; bar &lt;- T<br/>R&gt; paste("Definitely foo: ",foo,"; definitely bar: ",bar,".",sep="")<br/>[1] "Definitely foo: 34; definitely bar: TRUE."</pre>&#13;
<p class="indent">Here, the integer <code>34</code> and the logical <code>T</code> are implicitly coerced to characters since R knows the output of <code>paste</code> must be a string.</p>&#13;
<p class="indent">In other situations, coercion won’t happen automatically and must be carried out by the user. This explicit coercion can be achieved with the <em>as-dot</em> functions. Like is-dot functions, as-dot functions exist for most typical R data types and object classes. The previous two examples can be coerced explicitly, as follows.</p>&#13;
<pre>R&gt; as.numeric(c(T,F,F,T))<br/>[1] 1 0 0 1<br/>R&gt; 1:4+as.numeric(c(T,F,F,T))<br/>[1] 2 2 3 5<br/>R&gt; foo &lt;- 34<br/>R&gt; foo.ch &lt;- as.character(foo)<br/>R&gt; foo.ch<br/>[1] "34"<br/>R&gt; bar &lt;- T<br/>R&gt; bar.ch &lt;- as.character(bar)<br/>R&gt; bar.ch<br/>[1] "TRUE"<br/>R&gt; paste("Definitely foo: ",foo.ch,"; definitely bar: ",bar.ch,".",sep="")<br/>[1] "Definitely foo: 34; definitely bar: TRUE."</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>Coercions are possible in most cases that “make sense.” For example, it’s easy to see why R is able to read something like this:</p>&#13;
<pre>R&gt; as.numeric("32.4")<br/>[1] 32.4</pre>&#13;
<p class="indent">However, the following conversion makes no sense:</p>&#13;
<pre>R&gt; as.numeric("g'day mate")<br/>[1] NA<br/>Warning message:<br/>NAs introduced by coercion</pre>&#13;
<p class="indent">Since there is no logical way to translate “g’day mate” into numbers, the entry is returned as <code>NA</code> (in this case, R has also issued a warning message). This means that in certain cases, multiple coercions are needed to attain the final result. Suppose, for example, you have the character vector <code>c("1","0","1","0","0")</code> and you want to coerce it to a logical-valued vector. Direct character to logical coercion is not possible, because even if all the character strings contained numbers, there is no guarantee in general that they would all be ones and zeros.</p>&#13;
<pre>R&gt; as.logical(c("1","0","1","0","0"))<br/>[1] NA NA NA NA NA</pre>&#13;
<p class="indent">However, you know that character string numbers can be converted to a numeric data type, and you know that ones and zeros are easily coerced to logicals. So, you can perform the coercion in those two steps, as follows:</p>&#13;
<pre>R&gt; as.logical(as.numeric(c("1","0","1","0","0")))<br/>[1]  TRUE FALSE  TRUE FALSE FALSE</pre>&#13;
<p class="indent">Not all data-type coercion is entirely straightforward. Factors, for example, are trickier because R treats the levels as integers. In other words, regardless of how the levels of a given factor are actually labeled, the software will refer to them internally as level 1, level 2, and so on. This is clear if you try to coerce a factor to a numeric data type.</p>&#13;
<pre>R&gt; baz &lt;- factor(x=c("male","male","female","male"))<br/>R&gt; baz<br/>[1] male   male   female male<br/>Levels: female male<br/>R&gt; as.numeric(baz)<br/>[1] 2 2 1 2</pre>&#13;
<p class="indent">Here, you see that R has assigned the numeric representation of the factor in the stored order of the factor labels (alphabetic by default). Level 1 refers to <code>female</code>, and level 2 refers to <code>male</code>. This example is simple enough, <span epub:type="pagebreak" id="page_123"/>though it’s important to be aware of the behavior since coercion from factors with numeric levels can cause confusion.</p>&#13;
<pre>R&gt; qux &lt;- factor(x=c(2,2,3,5))<br/>R&gt; qux<br/>[1] 2 2 3 5<br/>Levels: 2 3 5<br/>R&gt; as.numeric(qux)<br/>[1] 1 1 2 3</pre>&#13;
<p class="indent">The numeric representation of the factor <code>qux</code> is <code>c(1,1,2,3)</code>. This highlights again that the levels of <code>qux</code> are simply treated as level 1 (even though it has a label of <code>2</code>), level 2 (which has a label of <code>3</code>), and level 3 (which has a label of <code>5</code>).</p>&#13;
<p class="indent">Coercion between object classes and structures can also be useful. For example, you might need to store the contents of a matrix as a single vector.</p>&#13;
<pre>R&gt; foo &lt;- matrix(data=1:4,nrow=2,ncol=2)<br/>R&gt; foo<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/>R&gt; as.vector(foo)<br/>[1] 1 2 3 4</pre>&#13;
<p class="indent">Note that <code>as.vector</code> has coerced the matrix by “stacking” the columns into a single vector. The same column-wise deconstruction occurs for higher-dimensional arrays, in order of layer or block.</p>&#13;
<pre>R&gt; bar &lt;- array(data=c(8,1,9,5,5,1,3,4,3,9,8,8),dim=c(2,3,2))<br/>R&gt; bar<br/>, , 1<br/><br/>     [,1] [,2] [,3]<br/>[1,]    8    9    5<br/>[2,]    1    5    1<br/><br/>, , 2<br/><br/>     [,1] [,2] [,3]<br/>[1,]    3    3    8<br/>[2,]    4    9    8<br/><br/>R&gt; as.matrix(bar)<br/>      [,1]<br/> [1,]    8<br/> [2,]    1<br/> [3,]    9<br/> [4,]    5<br/> [5,]    5<br/> [6,]    1<br/> [7,]    3<br/> [8,]    4<br/> [9,]    3<br/>[10,]    9<br/>[11,]    8<br/>[12,]    8<br/><br/>R&gt; as.vector(bar)<br/> [1] 8 1 9 5 5 1 3 4 3 9 8 8</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>You can see that <code>as.matrix</code> stores the array as a 12 × 1 matrix, and <code>as.vector</code> stores it as a single vector. Similar commonsense rules for data types apply to coercion when working with object structures. For example, coercing the following list <code>baz</code> to a data frame produces an error:</p>&#13;
<pre>R&gt; baz &lt;- list(var1=foo,var2=c(T,F,T),var3=factor(x=c(2,3,4,4,2)))<br/>R&gt; baz<br/>$var1<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/><br/>$var2<br/>[1]  TRUE FALSE  TRUE<br/><br/>$var3<br/>[1] 2 3 4 4 2<br/>Levels: 2 3 4<br/><br/>R&gt; as.data.frame(baz)<br/>Error in data.frame(var1 = 1:4, var2 = c(TRUE, FALSE, TRUE), var3 = c(1L,  :<br/>  arguments imply differing number of rows: 2, 3, 5</pre>&#13;
<p class="indent">The error occurs because the variables do not have matching lengths. But there is no problem with coercing the list <code>qux</code>, shown here, which has equal-length members:</p>&#13;
<pre>R&gt; qux &lt;- list(var1=c(3,4,5,1),var2=c(T,F,T,T),var3=factor(x=c(4,4,2,1)))<br/>R&gt; qux<br/>$var1<br/>[1] 3 4 5 1<br/><br/>$var2<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><span epub:type="pagebreak" id="page_125"/>$var3<br/>[1] 4 4 2 1<br/>Levels: 1 2 4<br/><br/>R&gt; as.data.frame(qux)<br/>  var1  var2 var3<br/>1    3  TRUE    4<br/>2    4 FALSE    4<br/>3    5  TRUE    2<br/>4    1  TRUE    1</pre>&#13;
<p class="indent">This stores the variables as a data set in a column-wise fashion, in the order that your list supplies them as members.</p>&#13;
<p class="indent">This discussion on object classes, data types, and coercion is not exhaustive, but it serves as a useful introduction to how R deals with issues surrounding the formal identification, description, and handling of the objects you create—issues that are present for most high-level languages. Once you’re more familiar with R, the help files (such as the one accessed by entering <code>?as</code> at the prompt) provide further details about object handling in the software.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch6exc3"/><strong>Exercise 6.3</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Identify the class of the following objects. For each object, also state whether the class is explicitly or implicitly defined.</p>&#13;
<ol type="i">&#13;
<li><p class="noindent"><code>foo &lt;- array(data=1:36,dim=c(3,3,4))</code></p></li>&#13;
<li><p class="noindent"><code>bar &lt;- as.vector(foo)</code></p></li>&#13;
<li><p class="noindent"><code>baz &lt;- as.character(bar)</code></p></li>&#13;
<li><p class="noindent"><code>qux &lt;- as.factor(baz)</code></p></li>&#13;
<li><p class="noindent"><code>quux &lt;- bar+c(-0.1,0.1)</code></p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">For each object defined in (a), find the sum of the result of calling <code>is.numeric</code> and <code>is.integer</code> on it separately. For example, <code>is.numeric(foo)+is.integer(foo)</code> would compute the sum for (i). Turn the collection of five results into a factor with levels <code>0</code>, <code>1</code>, and <code>2</code>, identified by the results themselves. Compare this factor vector with the result of coercing it to a numeric vector.</p></li>&#13;
<li><p class="noindents">Turn the following:</p>&#13;
<pre>     [,1] [,2] [,3] [,4]<br/>[1,]    2    5    8   11<br/>[2,]    3    6    9   12<br/>[3,]    4    7   10   13</pre>&#13;
<p class="noindent">into the following:</p>&#13;
<pre>[1] "2"  "5"  "8"  "11" "3"  "6"  "9"  "12" "4"  "7"  "10" "13"</pre></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_126"/>Store the following matrix:</p>&#13;
<div class="imagec"><img src="../images/f0126-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Coerce the matrix to a data frame.</p></li>&#13;
<li><p class="noindent">As a data frame, coerce the second column to be logical-valued.</p></li>&#13;
<li><p class="noindent">As a data frame, coerce the third column to be factor-valued.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch06lev3sec16"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Inf</code>, <code>-Inf</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Value for ±infinity</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec55">Section 6.1.1</a>, <a href="ch06.xhtml#page_104">p. 104</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is.infinite</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Element-wise check for <code>Inf</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec55">Section 6.1.1</a>, <a href="ch06.xhtml#page_105">p. 105</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is.finite</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Element-wise check for finiteness</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec55">Section 6.1.1</a>, <a href="ch06.xhtml#page_105">p. 105</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>NaN</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Value for invalid numerics</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec56">Section 6.1.2</a>, <a href="ch06.xhtml#page_106">p. 106</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is.nan</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Element-wise check for <code>NaN</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec56">Section 6.1.2</a>, <a href="ch06.xhtml#page_107">p. 107</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>NA</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Value for missing observation</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec57">Section 6.1.3</a>, <a href="ch06.xhtml#page_108">p. 108</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is.na</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Element-wise check for <code>NA</code> OR <code>NaN</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec57">Section 6.1.3</a>, <a href="ch06.xhtml#page_109">p. 109</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>na.omit</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Delete all <code>NA</code>s and <code>NaN</code>s</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec57">Section 6.1.3</a>, <a href="ch06.xhtml#page_110">p. 110</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>NULL</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Value for “empty”</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec58">Section 6.1.4</a>, <a href="ch06.xhtml#page_110">p. 110</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is.null</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Check for <code>NULL</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec58">Section 6.1.4</a>, <a href="ch06.xhtml#page_111">p. 111</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>attributes</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">List explicit attributes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>, <a href="ch06.xhtml#page_114">p. 114</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>attr</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Obtain specific attribute</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>, <a href="ch06.xhtml#page_115">p. 115</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>dimnames</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get array dimension names</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>, <a href="ch06.xhtml#page_116">p. 116</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>class</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get object class (S3)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec60">Section 6.2.2</a>, <a href="ch06.xhtml#page_117">p. 117</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>is._</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Object-checking functions</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec61">Section 6.2.3</a>, <a href="ch06.xhtml#page_120">p. 120</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>as._</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Object-coercion functions</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch06.xhtml#ch06lev2sec62">Section 6.2.4</a>, <a href="ch06.xhtml#page_121">p. 121</a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>