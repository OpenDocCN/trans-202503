<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch29"><span epub:type="pagebreak" id="page_551"/><span class="big">29</span><br/>THE MAXWELL EQUATIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In the past several chapters, we’ve introduced electric and magnetic fields and suggested that these fields are properly part of the description of the state of a physical system, at least one in which electric charge plays a role. What we have not yet done is shown how the electric and magnetic fields evolve in time. This chapter addresses that issue by introducing the Maxwell equations.</p>&#13;
<p class="indent">The Maxwell equations describe how electric and magnetic fields are created by charge and current, how the fields are related to each other, and how the fields evolve in time. Together with the Lorentz force law, the Maxwell equations express modern electromagnetic theory.</p>&#13;
<p class="indent">We’ll begin the chapter with some introductory code, after which we’ll present the Maxwell equations. We’ll then discuss four relationships between electricity and magnetism implied by these equations and how the equations relate to our treatment of electric and magnetic fields in previous chapters. We’ll also show how the state-update technique can be applied to the Maxwell equations. Finally, we’ll present the finite difference time domain (FDTD) method for solving the Maxwell equations and use it to animate the electric field produced by oscillating charge.</p>&#13;
<h3 class="h3" id="ch29lev1"><span epub:type="pagebreak" id="page_552"/>Introductory Code</h3>&#13;
<p class="noindent"><a href="ch29.xhtml#ch29list1">Listing 29-1</a> shows the first lines of the code in the <span class="literal">Maxwell</span> module we’ll write in this chapter.</p>&#13;
<pre id="ch29list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module Maxwell where&#13;
&#13;
import SimpleVec&#13;
    ( R, Vec(..), (^/), (^+^), (^-^), (*^)&#13;
    , vec, negateV, magnitude, xComp, yComp, zComp, iHat, jHat, kHat )&#13;
import CoordinateSystems&#13;
    ( ScalarField, VectorField&#13;
    , cart, shiftPosition, rVF, magRad )&#13;
import ElectricField ( cSI, mu0 )&#13;
import qualified Data.Map.Strict as M&#13;
import qualified Diagrams.Prelude as D&#13;
import Diagrams.Prelude&#13;
    ( Diagram, Colour&#13;
    , PolyType(..), PolyOrientation(..), PolygonOpts(..), V2(..)&#13;
    , (#), rotate, deg, rad, polygon, sinA, dims, p2&#13;
    , fc, none, lw, blend )&#13;
import Diagrams.Backend.Cairo ( B, renderCairo )</pre>&#13;
<p class="listing"><em>Listing 29-1: Opening lines of code for the <span class="literal">Maxwell</span> module</em></p>&#13;
<p class="indent">We use types and functions from the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a>, the <span class="literal">CoordinateSystems</span> module of <a href="ch22.xhtml">Chapter 22</a>, and the <span class="literal">ElectricField</span> module of <a href="ch25.xhtml">Chapter 25</a>. We also do a qualified import of <span class="literal">Data.Map.Strict</span>, giving it the short name <span class="literal">M</span>, for use in the section on the FDTD method. We import several types and functions from the <span class="literal">Diagrams</span> package to do asynchronous animation at the end of the chapter.</p>&#13;
<h3 class="h3" id="ch29lev2">The Maxwell Equations</h3>&#13;
<p class="noindent">In SI units, the Maxwell equations consist of the following four equations:</p>&#13;
<div class="imagec"><img src="Images/552equ01.jpg" alt="Image" width="354" height="48"/></div>&#13;
<div class="imagec"><img src="Images/552equ02.jpg" alt="Image" width="355" height="31"/></div>&#13;
<div class="imagec"><img src="Images/552equ03.jpg" alt="Image" width="416" height="44"/></div>&#13;
<div class="imagec"><img src="Images/552equ04.jpg" alt="Image" width="438" height="45"/></div>&#13;
<p class="indent">The electric field is denoted <strong>E</strong>, the magnetic field <strong>B</strong>, the current density <strong>J</strong>, and the charge density <em>ρ</em>. Remember that <em>ϵ</em><sub>0</sub> is the permittivity of free <span epub:type="pagebreak" id="page_553"/>space, first introduced in <a href="ch21.xhtml">Chapter 21</a>. The symbol <em>∇</em> is called the <em>del operator</em>, and in Cartesian coordinates it is given by:</p>&#13;
<div class="imagec"><img src="Images/553equ01.jpg" alt="Image" width="435" height="49"/></div>&#13;
<p class="indent">The word <em>operator</em> here is used as physicists use it, meaning something that takes a function as input and produces a function as output. Functional programmers call such a thing a higher-order function.</p>&#13;
<p class="indent">The combination of the del operator followed by a dot product symbol, as in Equations 29.1 and 29.2, is called the <em>divergence</em>, a higher-order function that takes a vector field as input and produces a scalar field as output. The definition of divergence is flux per unit volume, so a place where a vector field has positive divergence is a place that the vectors point away from. Similarly, a place where a vector field has negative divergence is a place that the vectors point toward. In Cartesian coordinates, the divergence of a vector field looks like the following:</p>&#13;
<div class="imagec"><img src="Images/553equ02.jpg" alt="Image" width="456" height="51"/></div>&#13;
<p class="indent">The combination of the del operator followed by a cross product symbol, as in Equations 29.3 and 29.4, is called the <em>curl</em>, a higher-order function that takes a vector field as input and produces a vector field as output. The definition of curl is circulation per unit area, so it describes how the vectors form a pattern of circulation. A place where a vector field has curl in the z-direction is a place where the vectors point in a counterclockwise sense parallel to the xy-plane. In Cartesian coordinates, the curl of a vector field looks like the following:</p>&#13;
<div class="imagec"><img src="Images/553equ03.jpg" alt="Image" width="636" height="51"/></div>&#13;
<p class="indent">Equation 29.1 is called Gauss’s law (you may have encountered Gauss’s law in the exercises in <a href="ch25.xhtml">Chapter 25</a>). Gauss’s law says that charge dictates the divergence of the electric field. Since vectors point away from a place of positive divergence and toward a place of negative divergence, Gauss’s law says that the electric field points away from positive charge and toward negative charge.</p>&#13;
<p class="indent">Equation 29.2 is called Gauss’s law for magnetism, or “no magnetic monopoles.” Since the divergence of the magnetic field must be 0 at all points in space and time, there is no magnetic charge for the magnetic field to point toward or away from.</p>&#13;
<p class="indent">Equation 29.3 is called Faraday’s law (you may have encountered Faraday’s law in the exercises in <a href="ch27.xhtml">Chapter 27</a>). It asserts a link between the curl of the electric field and the time rate of change of the magnetic field. Faraday’s law explains electric generators and transformers.</p>&#13;
<p class="indent">Equation 29.4 is the <em>Ampere-Maxwell law</em>. It asserts a relationship among the curl of the magnetic field, the time rate of change of the electric field, and the current density.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_554"/>There are four independent variables in the Maxwell equations: three space coordinates and one time coordinate. There are six dependent variables: three electric field components and three magnetic field components. We can think of the charge and current densities as source terms. They are inputs to the Maxwell equations that determine the fields and how they change.</p>&#13;
<p class="indent">With the Maxwell equations, we have electric field and magnetic field appearing in the same equations for the first time. The Maxwell equations describe four relationships between electricity and magnetism, which we describe next.</p>&#13;
<h4 class="h4" id="ch29lev3">Relationships Between Electricity and Magnetism</h4>&#13;
<p class="noindent">Equation 29.1 is purely electric, and Equation 29.2 is purely magnetic. The remaining two Maxwell equations express four relationships between electricity and magnetism.</p>&#13;
<p class="indent">First, electric charge produces a magnetic field when it moves. This was Hans Christian Oersted’s 1820 discovery. He saw that electric current could deflect a compass needle. This relationship is described by the Ampere-Maxwell law, Equation 29.4, in that the current density <strong>J</strong> is related to the curl of the magnetic field, ∇ × <strong>B</strong>. An earlier version of this law, called Ampere’s law, omitted the time derivative of the electric field and thus expressed in a simpler, if less comprehensive, way the dependence of magnetic field on current.</p>&#13;
<p class="indent">Second, a changing magnetic field produces an electric field. This was Faraday’s discovery and goes by the name of Faraday’s law, Equation 29.3. So, there are, in a sense, two sources of electric fields: one is charge and the other is a changing magnetic field. Coulomb’s law is missing this changing magnetic field contribution to the electric field and is incompatible with relativity. Most electric generation plants today use Faraday’s law to produce alternating electric current. The rotation of a turbine produces a changing magnetic field, which produces an electric field that drives the current.</p>&#13;
<p class="indent">Third, a changing electric field produces a magnetic field. In 1865, Maxwell added the term with the time derivative of the electric field to Ampere’s law, creating the Ampere-Maxwell law, Equation 29.4. The added term is known as <em>displacement current</em> because, although it is not an electrical current, it serves a similar role in the creation of a magnetic field.</p>&#13;
<p class="indent">Finally, electric and magnetic fields constitute light. The modern theory of optics asserts that light is an electromagnetic wave. There is no such thing as an electric wave or a magnetic wave by itself. Wavelike electric fields are always accompanied by wavelike magnetic fields.</p>&#13;
<h4 class="h4" id="ch29lev4">Connection to Coulomb’s Law and Biot-Savart Law</h4>&#13;
<p class="noindent">If the Maxwell equations describe how electric and magnetic fields are created and how they evolve, why did we not use them in <a href="ch25.xhtml">Chapters 25</a> and <a href="ch27.xhtml">27</a>? <span epub:type="pagebreak" id="page_555"/>Those chapters gave methods for how an electric field is created by charge and how a magnetic field is created by current, respectively. How do the methods given in those chapters relate to the Maxwell equations?</p>&#13;
<p class="indent">Remember that <a href="ch25.xhtml">Chapter 25</a> gave methods for calculating the electric field in static situations (that is, in situations where charge is not moving or accelerating). In practice, the methods of that chapter, which are equivalent to Coulomb’s law, work reasonably well for charges moving slowly compared with the speed of light. In static situations, we can remove the two time derivative terms from the Maxwell equations, causing the equations for electricity to decouple from those for magnetism. Thus, in static situations, Equations 29.1 and 29.3 become</p>&#13;
<div class="imagec"><img src="Images/555equ01.jpg" alt="Image" width="391" height="48"/></div>&#13;
<div class="imagec"><img src="Images/555equ02.jpg" alt="Image" width="401" height="20"/></div>&#13;
<p class="noindent">and describe static electricity. Coulomb’s law is the solution to Equations 29.8 and 29.9.</p>&#13;
<p class="indent">Similarly, in static situations, Equations 29.2 and 29.4 become</p>&#13;
<div class="imagec"><img src="Images/555equ03.jpg" alt="Image" width="390" height="20"/></div>&#13;
<div class="imagec"><img src="Images/555equ04.jpg" alt="Image" width="400" height="21"/></div>&#13;
<p class="noindent">and describe the magnetic field created by steady currents. The Biot-Savart law of <a href="ch27.xhtml">Chapter 27</a> is the solution to Equations 29.10 and 29.11.</p>&#13;
<p class="indent">The static methods we introduced in <a href="ch25.xhtml">Chapters 25</a> and <a href="ch27.xhtml">27</a> are useful and substantially simpler than the Maxwell equations, but they do not account for dynamic situations where charge is moving quickly or accelerating. We turn now to the task of solving the Maxwell equations, employing a state-update similar to what we used to solve Newton’s second law in <a href="part02.xhtml">Part II</a> of the book.</p>&#13;
<h4 class="h4" id="ch29lev5">State Update</h4>&#13;
<p class="noindent">To understand how electric and magnetic fields change in time, it is helpful to rearrange Maxwell Equations 29.3 and 29.4 so that they give the rates of change of the fields in terms of the fields and the current density.</p>&#13;
<div class="imagec"><img src="Images/555equ05.jpg" alt="Image" width="442" height="44"/></div>&#13;
<div class="imagec"><img src="Images/555equ06.jpg" alt="Image" width="443" height="44"/></div>&#13;
<p class="indent">Equations 29.1 and 29.2 serve as constraints; as long as the electric and magnetic fields satisfy them at one point in time, they will continue to satisfy them as they change according to Equations 29.12 and 29.13.</p>&#13;
<p class="indent"><a href="ch29.xhtml#ch29fig1">Figure 29-1</a> shows a schematic diagram for the Maxwell equations.</p>&#13;
<div class="imagel" id="ch29fig1"><img src="Images/556fig01.jpg" alt="Image" width="491" height="572"/></div>&#13;
<p class="figcap"><em>Figure 29-1: A schematic diagram representing the Maxwell equations</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_556"/>This diagram is similar to the diagrams we made in <a href="part02.xhtml">Part II</a> of the book for Newton’s second law. The most striking difference is that the values carried by the wires here are vector fields, whereas in mechanics they were numbers or vectors. As we integrated acceleration to obtain velocity in mechanics, here we integrate the curl of the electric field to obtain the magnetic field. As a loop in this kind of schematic diagram signaled a differential equation in mechanics, the loop here also signals that the Maxwell equations are differential equations.</p>&#13;
<p class="indent">As you can see in <a href="ch29.xhtml#ch29fig1">Figure 29-1</a>, magnetic field change is controlled by the negative curl of the electric field. Electric field change is controlled by both current density and the curl of the magnetic field. This schematic diagram represents Equations 29.3 and 29.4. The integrators are with respect to time, as they have been in all of the schematic diagrams like this. The type <span class="literal">VectorField</span> below each integrator indicates the nature of the state contained in the integrator. Each integrator here contains a full vector field as state that gets updated by the vector field acting as input to the integrator. Equations 29.1 and 29.2 place constraints on the vector fields that can be held as state by the integrators. The multiplications by <em>c</em><sup>2</sup> and –<em>μ</em> <sub>0</sub><em>c</em><sup>2</sup> are appropriate for SI units.</p>&#13;
<p class="indent">As in <a href="part02.xhtml">Part II</a> of the book, our methods for solving the Maxwell equations involve treating time discretely, updating the quantities we care about over a time step that is small compared with time scales on which significant <span epub:type="pagebreak" id="page_557"/>change occurs, and then iterating this update procedure over many small time steps. For the Maxwell equations, the quantities we care about are the electric and magnetic fields. We update the electric and magnetic fields using Equations 29.12 and 29.13 to provide the rate at which electric and magnetic fields change. The updated fields change by the product of the rate with the time step.</p>&#13;
<div class="imagec"><img src="Images/557equ01.jpg" alt="Image" width="560" height="26"/></div>&#13;
<div class="imagec"><img src="Images/557equ02.jpg" alt="Image" width="747" height="42"/></div>&#13;
<p class="indent">To encode Equations 29.14 and 29.15 in Haskell, we need to take the curl of a vector field. We’ll turn next to the question of how to write the curl in Haskell.</p>&#13;
<h4 class="h4" id="ch29lev6">Spatial Derivatives and the Curl</h4>&#13;
<p class="noindent">The divergence and curl that appear in the Maxwell equations are types of spatial derivatives. Conceptually, the simplest spatial derivative is the <em>directional derivative</em>, defined to be the rate at which a field changes as we move in a specified direction. If <em>f</em> is a scalar field and <img class="inline" src="Images/ncap.jpg" alt="Image" width="12" height="15"/> is a unit vector, the directional derivative of <em>f</em> in the direction <img class="inline" src="Images/ncap.jpg" alt="Image" width="12" height="15"/> is defined to be the limit of the ratio of the difference of the values of the scalar field at two points separated by distance <em>ϵ</em> in the direction <img class="inline" src="Images/ncap.jpg" alt="Image" width="12" height="15"/>, divided by <em>ϵ</em>.</p>&#13;
<div class="imagec"><img src="Images/557equ03.jpg" alt="Image" width="508" height="45"/></div>&#13;
<p class="indent">Our computational directional derivative will not take a limit but instead will simply calculate the ratio using a small displacement <img class="inline" src="Images/557equ04.jpg" alt="Image" width="21" height="19"/>, which we call <span class="literal">d</span> in the following code:</p>&#13;
<pre>directionalDerivative :: Vec -&gt; ScalarField -&gt; ScalarField&#13;
directionalDerivative d f r&#13;
    = (f (shiftPosition (d ^/ 2) r) - f (shiftPosition (negateV d ^/ 2) r))&#13;
      / magnitude d</pre>&#13;
<p class="indent">The displacement vector <span class="literal">d</span> that serves as the first input to <span class="literal">directional</span> <span class="literal">Derivative</span> has two roles. Its direction specifies the direction in which we want the derivative. In calculus, where we take limits, this is its only role. But in computation, where our derivatives involve small but finite steps, the second role of this input is for its magnitude to specify the step size for the derivative. We evaluate the field at two points: one shifted half the displacement vector from <span class="literal">r</span> and the other shifted minus half the displacement vector from <span class="literal">r</span>. We find the difference of these two field values and divide it by the magnitude of the displacement vector.</p>&#13;
<p class="indent">Recall from Equation 29.7 that we can find the curl from partial derivatives along the three coordinate directions. The partial derivative with respect to <em>x</em> is the directional derivative in the <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> direction. The local functions <span class="literal">derivX</span>, <span class="literal">derivY</span>, and <span class="literal">derivZ</span> in the code for <span class="literal">curl</span> are partial derivatives.</p>&#13;
<p class="indent">We write the curl of a vector field in terms of Cartesian coordinates and partial derivatives, as in Equation 29.7.</p>&#13;
<pre><span epub:type="pagebreak" id="page_558"/>curl :: R -&gt; VectorField -&gt; VectorField&#13;
curl a vf r&#13;
    = let vx = xComp . vf&#13;
          vy = yComp . vf&#13;
          vz = zComp . vf&#13;
          derivX = directionalDerivative (a *^ iHat)&#13;
          derivY = directionalDerivative (a *^ jHat)&#13;
          derivZ = directionalDerivative (a *^ kHat)&#13;
      in      (derivY vz r - derivZ vy r) *^ iHat&#13;
          ^+^ (derivZ vx r - derivX vz r) *^ jHat&#13;
          ^+^ (derivX vy r - derivY vx r) *^ kHat</pre>&#13;
<p class="indent">The input <span class="literal">a</span> is a real number specifying the spatial step size to use for the curl. The input <span class="literal">vf</span> is the vector field for which we want the curl. The local variables <span class="literal">vx</span>, <span class="literal">vy</span>, and <span class="literal">vz</span> have type <span class="literal">ScalarField</span> and are the components of the vector field <span class="literal">vf</span>. The partial derivatives <span class="literal">derivX</span>, <span class="literal">derivY</span>, and <span class="literal">derivZ</span> have type <span class="literal">ScalarField -&gt; ScalarField</span>. Finally, we use Equation 29.7 to find the curl.</p>&#13;
<p class="indent">Now that we can take the curl of a vector field, we are ready to try encoding the Maxwell equations in Haskell.</p>&#13;
<h4 class="h4" id="ch29lev7">A Naive Method</h4>&#13;
<p class="noindent">The simplest encoding of the Maxwell equations uses a state space consisting of the current time, the electric field, and the magnetic field. We use the type synonym <span class="literal">FieldState</span> to describe a triple consisting of a real number for time, a vector field for electric field, and a vector field for magnetic field.</p>&#13;
<pre>type FieldState = (R            -- time t&#13;
                  ,VectorField  -- electric field E&#13;
                  ,VectorField  -- magnetic field B&#13;
                  )</pre>&#13;
<p class="indent">The function <span class="literal">maxwellUpdate</span> encodes Equations 29.14 and 29.15, which describe how the electric field and the magnetic field can be updated in time.</p>&#13;
<pre>maxwellUpdate :: R                  -- dx&#13;
              -&gt; R                  -- dt&#13;
              -&gt; (R -&gt; VectorField) -- J&#13;
              -&gt; FieldState -&gt; FieldState&#13;
maxwellUpdate dx dt j (t,eF,bF)&#13;
    = let t'    = t + dt&#13;
          eF' r = eF r ^+^ cSI**2 *^ dt *^ (curl dx bF r ^-^ mu0 *^ j t r)&#13;
          bF' r = bF r ^-^           dt *^  curl dx eF r&#13;
      in (t',eF',bF')</pre>&#13;
<p class="indent">The input <span class="literal">dx</span> to <span class="literal">maxwellUpdate</span> is a real number describing the spatial step size to use for the curl present in Equations 29.14 and 29.15. The input <span class="literal">dt</span> is a real number describing the time step. The input <span class="literal">j</span> is a time-dependent <span epub:type="pagebreak" id="page_559"/>vector field describing the current density <strong>J</strong>. <a href="ch29.xhtml#ch29tab1">Table 29-1</a> gives a correspondence between the mathematical notation of Equations 29.14 and 29.15 with the Haskell notation in <span class="literal">maxwellUpdate</span>.</p>&#13;
<p class="tabcap" id="ch29tab1"><strong>Table 29-1:</strong> Correspondence Between Mathematical Notation and Haskell Notation for the Maxwell Equations</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Mathematics</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Haskell</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">Time</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><em>t</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><span class="literal">t</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Position</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>r</strong></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Time step</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Δ<em>t</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">dt</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Speed of light</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>c</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">cSI</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Permeability of free space</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>μ</em><sub>0</sub></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">mu0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Current density</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>J</strong></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">j</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Current density</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>J</strong>(<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">j t r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Electric field</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>E</strong>(<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">eF r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Magnetic field</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>B</strong>(<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">bF r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Updated electric field</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>E</strong>(<em>t</em> + Δ<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">eF' r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Updated magnetic field</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>B</strong>(<em>t</em> + Δ<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">bF' r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Curl</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">∇×</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">curl dx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Curl of electric field</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">∇×<strong>E</strong>(<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">curl dx eF r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Curl of magnetic field</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">∇×<strong>B</strong>(<em>t</em>,<strong>r</strong>)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">curl dx bF r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Vector addition</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">+</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">^+^</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Vector subtraction</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">–</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">^-^</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot1"><p class="taba">Scalar multiplication</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot1"><p class="taba">Juxtaposition</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot1"><p class="taba"><span class="literal">*^</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We update the time by adding the time step <span class="literal">dt</span> to the current time <span class="literal">t</span> to form the updated time <span class="literal">t'</span>. We update the electric field by adding <em>c</em><sup>2</sup>[∇×<strong>B</strong>(<em>t</em>,<strong>r</strong>) – <em>μ</em><sub>0</sub><strong>J</strong>(<em>t</em>,<strong>r</strong>)]Δ<em>t</em> to the current electric field to form the updated electric field. We update the magnetic field by subtracting [∇×<strong>E</strong>(<em>t</em>,<strong>r</strong>)]Δ<em>t</em> from the current magnetic field to form the updated magnetic field.</p>&#13;
<p class="indent">To find the electric and magnetic fields as functions of time, we could iterate the <span class="literal">maxwellUpdate</span> function to produce a long list of states. The <span class="literal">maxwell</span> <span class="literal">Evolve</span> function does this.</p>&#13;
<pre>maxwellEvolve :: R                  -- dx&#13;
              -&gt; R                  -- dt&#13;
              -&gt; (R -&gt; VectorField) -- J&#13;
              -&gt; FieldState -&gt; [FieldState]&#13;
maxwellEvolve dx dt j st0 = iterate (maxwellUpdate dx dt j) st0</pre>&#13;
<p class="indent">Sadly, there is problem. While the code we have written compiles and in principle can be run, it is hopelessly inefficient. The trouble is that the computer does not automatically remember the function values it has already calculated, and it recalculates the same things over and over again. A function, to the Haskell compiler, is a rule for calculating outputs from inputs. If we know that we will need the output of a function in the future, it is up <span epub:type="pagebreak" id="page_560"/>to us as Haskell programmers to see that it is available, usually by giving it a name. The values of the electric field at various places are just such function outputs in this naive method. They are not stored anywhere and must be recalculated each time they are needed. By the time we get to the eighth time step, for example, the computer needs to know the values of the electric and magnetic fields at the seventh time step, but these were not stored, so they must be recalculated. But the values for the seventh time step depend on those for the sixth, which were not stored and therefore must be recalculated.</p>&#13;
<p class="indent">The state <span class="literal">FieldState</span> and update method <span class="literal">maxwellUpdate</span> we have written in this section, while elegant and illustrative of what we want the computer to do, are not usable in practice, which is why we call them “naive” methods. Nevertheless, I would argue that there is value in this code. It type checks, indicating that the compiler agrees we are asking for something that makes sense. It is written in a style that is readable and can help us to understand what the Maxwell equations are about. Perhaps some day compilers will be smart enough to be able to plan what values should be remembered because they will be used again.</p>&#13;
<p class="indent">However, for today, we want to write code that runs and produces results. To do that, we’ll turn to a new method.</p>&#13;
<h3 class="h3" id="ch29lev8">The FDTD Method</h3>&#13;
<p class="noindent">We saw in the naive method that using functions to describe the state of a system, while clear in meaning and elegant in exposition, is not an efficient way to solve the Maxwell equations. To get decent executable code, we want numbers describing the state of our system rather than functions. To achieve this, we will select a large but finite number of positions in space at which to keep track of the electric and magnetic field components. The method we describe in detail is called the <em>finite difference time domain</em> (<em>FDTD</em>) method for solving the Maxwell equations. It is the simplest method used by people who need to numerically solve the Maxwell equations. The FDTD method is described more fully in [<strong><a href="bib.xhtml#bib18"><span class="green">18</span></a></strong>].</p>&#13;
<p class="indent">The FDTD method is still based on Equations 29.12 and 29.13. Each of these two equations is a vector equation. It is helpful to write out the Cartesian components of these equations. Using Equation 29.7 to express the curl, Equations 29.17, 29.18, and 29.19 list the x-, y-, and z-components of Equation 29.12.</p>&#13;
<div class="imagec"><img src="Images/560equ01.jpg" alt="Image" width="476" height="52"/></div>&#13;
<div class="imagec"><img src="Images/560equ02.jpg" alt="Image" width="475" height="51"/></div>&#13;
<div class="imagec"><img src="Images/560equ03.jpg" alt="Image" width="475" height="51"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_561"/>Similarly, the x-, y-, and z-components of Equation 29.13 are as follows:</p>&#13;
<div class="imagec"><img src="Images/561equ01.jpg" alt="Image" width="444" height="52"/></div>&#13;
<div class="imagec"><img src="Images/561equ02.jpg" alt="Image" width="444" height="51"/></div>&#13;
<div class="imagec"><img src="Images/561equ03.jpg" alt="Image" width="443" height="52"/></div>&#13;
<p class="indent">The FDTD method consists of approximating each partial derivative with a symmetric finite difference. By symmetric, we mean that we can approximate the partial derivative of a field component (<em>E<sub>x</sub></em>, <em>E<sub>y</sub></em>, <em>E<sub>z</sub></em>, <em>B<sub>x</sub></em>, <em>B<sub>y</sub></em>, or <em>B<sub>z</sub></em>) at a particular point (<em>t</em>,<em>x</em>,<em>y</em>,<em>z</em>) in time and space by sampling the field component at two points equidistant from (<em>t</em>,<em>x</em>,<em>y</em>,<em>z</em>). In the case of a partial derivative with respect to time, the sample points are (<em>t</em> + Δ<em>t</em>/2,<em>x</em>,<em>y</em>,<em>z</em>) and (<em>t</em> – Δ<em>t</em>/2,<em>x</em>,<em>y</em>,<em>z</em>). In the case of a partial derivative with respect to space, say in the y-direction, the sample points are (<em>t</em>,<em>x</em>,<em>y</em> + Δ<em>y</em>/2,<em>z</em>) and (<em>t</em>,<em>x</em>,<em>y</em> – Δ<em>y</em>/2,<em>z</em>). For example, the partial derivative of <em>E<sub>x</sub></em> with respect to time is approximated as</p>&#13;
<div class="imagec"><img src="Images/561equ04.jpg" alt="Image" width="605" height="60"/></div>&#13;
<p class="noindent">and the partial derivative of <em>E<sub>z</sub></em> with respect to <em>y</em> is approximated as</p>&#13;
<div class="imagec"><img src="Images/561equ05.jpg" alt="Image" width="606" height="66"/></div>&#13;
<p class="indent">Applying this finite difference approximation to Equation 29.17 and performing a bit of algebra results in an equation that tells us how to update the value of the x-component of electric field.</p>&#13;
<div class="imagec"><img src="Images/561equ06.jpg" alt="Image" width="589" height="327"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_562"/>There are five analogous equations for <em>E<sub>y</sub></em>, <em>E<sub>z</sub></em>, <em>B<sub>x</sub></em>, <em>B<sub>y</sub></em>, and <em>B<sub>z</sub></em>. Equation 29.25 and the other five are concisely expressed in vector form as</p>&#13;
<div class="imagec"><img src="Images/562equ01.jpg" alt="Image" width="638" height="50"/></div>&#13;
<div class="imagec"><img src="Images/562equ02.jpg" alt="Image" width="639" height="51"/></div>&#13;
<p class="noindent">where components of the curl are approximated as follows:</p>&#13;
<div class="imagec"><img src="Images/562equ03.jpg" alt="Image" width="648" height="164"/></div>&#13;
<p class="indent">Notice the similarity between Equations 29.26 and 29.27 on one hand and Equations 29.14 and 29.15 on the other. The only difference is that the curls of the fields and the current density are evaluated at a time midway between the original and updated values of the fields in the FDTD Equations 29.26 and 29.27, while the curls and current density are evaluated at the time of the original values of the fields in Equations 29.14 and 29.15, which is closer to the Euler method.</p>&#13;
<p class="indent">The curl of Equation 29.28 requires values of <em>B<sub>y</sub></em> and <em>B<sub>z</sub></em> that are half a spatial step away. Updating <em>E<sub>x</sub></em> at a point in time and space depends on <em>E<sub>x</sub></em> at the same place one time step <em>Δt</em> earlier. It also depends on <em>B<sub>y</sub></em> half a spatial step to either side in the z-direction half a time step earlier, and it depends on <em>B<sub>z</sub></em> half a spatial step to either side in the y-direction half a time step earlier.</p>&#13;
<p class="indent">These half-spatial-step dependencies imply that the locations at which we keep track of the six components should be staggered. The places at which we keep track of <em>E<sub>x</sub></em> will be shifted slightly from the places where we keep track of <em>E<sub>y</sub></em> or <em>B<sub>y</sub></em>. Equation 29.25 and the five analogous equations for <em>E<sub>y</sub></em>, <em>E<sub>z</sub></em>, <em>B<sub>x</sub></em>, <em>B<sub>y</sub></em>, and <em>B<sub>z</sub></em> determine where we should track each component. We turn next to describing the locations at which we will keep track of the electric and magnetic field components.</p>&#13;
<h4 class="h4" id="ch29lev9">The Yee Cell</h4>&#13;
<p class="noindent">We will use a triple <span class="literal">(nx,ny,nz)</span> of <span class="literal">Int</span>s to specify a location where we keep track of the field components. The integer <span class="literal">nx</span> measures the number of half spatial steps in the x-direction from the origin of our coordinate system. In other words, if <span class="literal">dx</span> is the spatial step size in the x-direction, equivalent to Δ<em>x</em> in mathematical notation, then the x-coordinate of the position associated with <span class="literal">(nx,ny,nz)</span> is <span class="literal">fromIntegral nx * dx / 2</span>. Even integers denote whole steps from the origin, while odd integers denote an odd number of half steps. <a href="ch29.xhtml#ch29tab2">Table 29-2</a> shows the locations at which each of the six field components is tracked.</p>&#13;
<p class="tabcap" id="ch29tab2"><strong>Table 29-2:</strong> Locations at Which We Calculate Components of the Electric and Magnetic Fields</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Component</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><span class="literal">nx</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><span class="literal">ny</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><span class="literal">nz</span></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><em>E<sub>x</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">even</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>E<sub>y</sub></em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">even</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>E<sub>z</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">odd</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>B<sub>x</sub></em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">odd</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>B<sub>y</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">even</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">odd</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>B<sub>z</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">odd</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">even</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_563"/>The locations at which values of <em>E<sub>x</sub></em> are kept are held in a list called <span class="literal">exLocs</span>, which is formed using a list comprehension to allow the integer <span class="literal">nx</span> to range over a sequence of consecutive odd integers, <span class="literal">ny</span> to range over a sequence of consecutive even integers, and <span class="literal">nz</span> to range over a sequence of consecutive even integers, as specified in <a href="ch29.xhtml#ch29tab2">Table 29-2</a>. Other lists with similar names hold the locations of other field components.</p>&#13;
<pre>exLocs, eyLocs, ezLocs, bxLocs, byLocs, bzLocs :: [(Int,Int,Int)]&#13;
exLocs = [(nx,ny,nz) | nx &lt;- odds , ny &lt;- evens, nz &lt;- evens]&#13;
eyLocs = [(nx,ny,nz) | nx &lt;- evens, ny &lt;- odds , nz &lt;- evens]&#13;
ezLocs = [(nx,ny,nz) | nx &lt;- evens, ny &lt;- evens, nz &lt;- odds ]&#13;
bxLocs = [(nx,ny,nz) | nx &lt;- evens, ny &lt;- odds , nz &lt;- odds ]&#13;
byLocs = [(nx,ny,nz) | nx &lt;- odds , ny &lt;- evens, nz &lt;- odds ]&#13;
bzLocs = [(nx,ny,nz) | nx &lt;- odds , ny &lt;- odds , nz &lt;- evens]</pre>&#13;
<p class="indent">The constant <span class="literal">spaceStepsCE</span> (CE for center to edge) gives the number of full spatial steps from the center to the edge of our grid.</p>&#13;
<pre>spaceStepsCE :: Int&#13;
spaceStepsCE = 40</pre>&#13;
<p class="indent">We use integers to specify locations in the grid. The largest even integer, called <span class="literal">hiEven</span>, is twice the number of full steps from center to edge.</p>&#13;
<pre>hiEven :: Int&#13;
hiEven =  2 * spaceStepsCE</pre>&#13;
<p class="indent">The even numbers used to specify locations range from <span class="literal">-hiEven</span> to <span class="literal">hiEven</span>.</p>&#13;
<pre>evens :: [Int]&#13;
evens = [-hiEven, -hiEven + 2 .. hiEven]</pre>&#13;
<p class="indent">The odd numbers used to specify locations begin one above the lowest even number and end one below the highest even number.</p>&#13;
<pre>odds :: [Int]&#13;
odds = [-hiEven + 1, -hiEven + 3 .. hiEven - 1]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_564"/>The pattern of locations for storing the field components is called a <em>Yee cell</em> and is shown in <a href="ch29.xhtml#ch29fig2">Figure 29-2</a>. The Yee cell is named after Kane S. Yee, who pioneered the FDTD method in the 1960s.</p>&#13;
<div class="imagel" id="ch29fig2"><img src="Images/564fig01.jpg" alt="Image" width="618" height="438"/></div>&#13;
<p class="figcap"><em>Figure 29-2: Yee cell showing where electric and magnetic field components are calculated</em></p>&#13;
<p class="indent"><a href="ch29.xhtml#ch29fig2">Figure 29-2</a> shows a patch of three-dimensional space, with a coordinate system in which <em>x</em> increases to the right, <em>y</em> increases up the page, and <em>z</em> increases out of the page. Double-headed arrows are placed at the locations in space where field components are tracked. Black arrows are electric field components, and gray arrows are magnetic field components. The direction in which the arrow points indicates which of the three components is being shown. A left-right arrow, for example, is an x-component. <a href="ch29.xhtml#ch29fig2">Figure 29-2</a> is a visual way of expressing the information in <a href="ch29.xhtml#ch29tab2">Table 29-2</a>. For example, an <em>E<sub>x</sub></em>-component is stored at <span class="literal">(nx,ny,nz) = (1,2,0)</span> since <span class="literal">nx</span> is odd, <span class="literal">ny</span> is even, and <span class="literal">nz</span> is even.</p>&#13;
<p class="indent">One of the features of the Yee cell is that each component’s nearest neighbors contain the information needed to update that component in time.</p>&#13;
<p class="indent">Let’s talk next about how we represent the state of the electric and magnetic fields in the FDTD method and how we update that state.</p>&#13;
<h4 class="h4" id="ch29lev10">A Type for State</h4>&#13;
<p class="noindent">Instead of the <span class="literal">FieldState</span> data type we used in the naive method, which contains functions for the electric and magnetic fields, we wish to have a state that holds numbers for the components of the electric and magnetic fields at the positions identified in the Yee cell of <a href="ch29.xhtml#ch29fig2">Figure 29-2</a>.</p>&#13;
<p class="indent">One of the standard Haskell library modules, <span class="literal">Data.Map.Strict</span>, includes a data structure called a <span class="literal">Map</span> that is good for this purpose. The type <span class="literal">Map k v</span> <span epub:type="pagebreak" id="page_565"/>is the type of a lookup table of key-value pairs, with <span class="literal">k</span> being the type of the key and <span class="literal">v</span> being the type of the value. In <a href="ch09.xhtml">Chapter 9</a> we showed how a list of pairs with type <span class="literal">[(k,v)]</span> can be used as a lookup table, but the type <span class="literal">Map k v</span> is better because it will store the keys in such a way that they can be looked up quickly.</p>&#13;
<p class="indent">For the key, we will use a triple <span class="literal">(nx,ny,nz)</span> of <span class="literal">Int</span>s to describe the location of a field component, and for the value we will use a real number <span class="literal">R</span>. So, the type we want to hold our field data is <span class="literal">Map (Int,Int,Int) R</span>.</p>&#13;
<p class="indent">Since electric field components are stored at different locations from magnetic field components, we could get away with a single lookup table, but we choose to use two tables, one for electric field and one for magnetic field, to make the code easier to read.</p>&#13;
<p class="indent">Our state space, called <span class="literal">StateFDTD</span>, consists of the time, three real numbers for the spatial step size in each direction, a <span class="literal">Map (Int,Int,Int) R</span> for the electric field, and a <span class="literal">Map (Int,Int,Int) R</span> for the magnetic field. It is not strictly necessary to include the spatial step sizes in the state, but it is convenient because functions that have a state as input often need to know the spatial step sizes to do their jobs. A function that computes the curl of a field, for example, needs the spatial step size.</p>&#13;
<pre>data StateFDTD = StateFDTD {timeFDTD :: R&#13;
                           ,stepX    :: R&#13;
                           ,stepY    :: R&#13;
                           ,stepZ    :: R&#13;
                           ,eField   :: M.Map (Int,Int,Int) R&#13;
                           ,bField   :: M.Map (Int,Int,Int) R&#13;
                           } deriving Show</pre>&#13;
<p class="indent">In the introductory code, the line <span class="literal">import qualified Data.Map.Strict as M</span> allows us to access all of the functions and types defined in <span class="literal">Data.Map.Strict</span> if we prefix them with a capital <span class="literal">M</span>. Because of the way we imported the module, we need to refer to the type <span class="literal">Map (Int,Int,Int) R</span> as <span class="literal">M.Map (Int,Int,Int) R</span>, which we see above is the type we use to hold the electric field and the magnetic field.</p>&#13;
<p class="indent">The function <span class="literal">initialStateFDTD</span> takes a real number that it uses for the spatial step size in all three directions as input, and it returns a state in which the electric field and the magnetic field are 0 at all positions.</p>&#13;
<pre>initialStateFDTD :: R -&gt; StateFDTD&#13;
initialStateFDTD spatialStep&#13;
    = StateFDTD {timeFDTD  = 0&#13;
                ,stepX = spatialStep&#13;
                ,stepY = spatialStep&#13;
                ,stepZ = spatialStep&#13;
                ,eField = M.fromList [(loc,0) | loc &lt;- exLocs++eyLocs++ezLocs]&#13;
                ,bField = M.fromList [(loc,0) | loc &lt;- bxLocs++byLocs++bzLocs]&#13;
                }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_566"/>The function <span class="literal">M.fromList</span> from the <span class="literal">Data.Map.Strict</span> module turns a list-of-pairs lookup table into a <span class="literal">Map</span> lookup table. We use a list comprehension to form a list of pairs in which the key is one of the locations for a field component and the value is 0.</p>&#13;
<p class="indent">The <span class="literal">Data.Map.Strict</span> module uses strict evaluation instead of Haskell’s default lazy evaluation. When doing numerical calculations, we almost never want to use lazy evaluation. Lazy evaluation is good when we might, depending on input data, compute only a subset of the possible outputs of our program. But when we are numerically evaluating a model, we just want to compute the quantities of interest at all specified points. In this case, we don’t need to pay the price in memory space (a memory pointer to either the code to evaluate a function or the result of a previous evaluation) of lazy evaluation. A general rule of thumb is that the strict version of a function is usually what you want, unless you really know what you are doing.</p>&#13;
<p class="indent">Let’s look now at how we will compute curls in the FDTD method.</p>&#13;
<h4 class="h4" id="ch29lev11">FDTD and the Curl</h4>&#13;
<p class="noindent">Equation 29.28 showed how to compute the x-component of the curl of the magnetic field in the FDTD method. There are five other analogous equations: two for the y- and z-components of the curl of the magnetic field and three for the components of the curl of the electric field. The approximation of the curl in Equation 29.28 is based on the approximation of the partial derivative in Equation 29.24, so we’ll want to encode the partial derivative first. However, even more basic than computing the partial derivative is simply looking up values from the key-value lookup table, so let’s address that now.</p>&#13;
<h5 class="h5" id="ch29lev12">Looking Up Values in the Lookup Table</h5>&#13;
<p class="noindent">The <span class="literal">Data.Map.Strict</span> module provides the function <span class="literal">lookup</span>, which we write as <span class="literal">M.lookup</span>, to retrieve values from a lookup table. Let’s look at the type of this function.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Maxwell</span>&#13;
[ 1 of 13] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[ 2 of 13] Compiling SimpleVec        ( SimpleVec.hs, interpreted )&#13;
[ 3 of 13] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[ 4 of 13] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[ 5 of 13] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[ 6 of 13] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
[ 7 of 13] Compiling Electricity      ( Electricity.hs, interpreted )&#13;
[ 8 of 13] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )&#13;
[ 9 of 13] Compiling Geometry         ( Geometry.hs, interpreted )&#13;
[10 of 13] Compiling Integrals        ( Integrals.lhs, interpreted )&#13;
[11 of 13] Compiling Charge           ( Charge.hs, interpreted )&#13;
[12 of 13] Compiling ElectricField    ( ElectricField.hs, interpreted )&#13;
[13 of 13] Compiling Maxwell          ( Maxwell.hs, interpreted )&#13;
&#13;
<span epub:type="pagebreak" id="page_567"/>Ok, 13 modules loaded.&#13;
*Maxwell&gt; <span class="codestrong1">:t M.lookup</span>&#13;
M.lookup :: Ord k =&gt; k -&gt; M.Map k a -&gt; Maybe a</pre>&#13;
<p class="indent">If we wanted to see the type of <span class="literal">lookup</span> from <span class="literal">Data.Map.Strict</span> without loading the code in this chapter, we could do the following:</p>&#13;
<pre>*Maxwell&gt;  <span class="codestrong1">:m Data.Map.Strict</span>&#13;
Prelude Data.Map.Strict&gt;  <span class="codestrong1">:t Data.Map.Strict.lookup</span>&#13;
Data.Map.Strict.lookup :: Ord k =&gt; k -&gt; Map k a -&gt; Maybe a</pre>&#13;
<p class="indent">Here we ask for the type of <span class="literal">lookup</span> using the fully qualified name of the function, prefixing the module name before the function name to distinguish the <span class="literal">lookup</span> of <span class="literal">Data.Map.Strict</span> from the <span class="literal">lookup</span> of <span class="literal">Prelude</span>.</p>&#13;
<p class="indent">From the type, we see that <span class="literal">M.lookup</span> wants a key and a lookup table and will return something of type <span class="literal">Maybe a</span>. If it finds the key in the table, it will return the value associated with it, wrapped in the <span class="literal">Just</span> constructor of the <span class="literal">Maybe a</span> type. If it doesn’t find the key, it will return <span class="literal">Nothing</span>.</p>&#13;
<p class="indent">Our helping function <span class="literal">lookupAZ</span> uses <span class="literal">M.lookup</span> to do its work.</p>&#13;
<pre>lookupAZ :: Ord k =&gt; k -&gt; M.Map k R -&gt; R&#13;
lookupAZ key m = case M.lookup key m of&#13;
                     Nothing -&gt; 0&#13;
                     Just x  -&gt; x</pre>&#13;
<p class="indent">The function <span class="literal">lookupAZ</span> (AZ for assume zero) has a slightly simpler type than <span class="literal">M.lookup</span>. The function serves two purposes. First, it relieves us of the need to case analyze the results each time we do a lookup. Second, when we compute a curl for a location at the edge of our grid, we will be trying to look up values that don’t exist because they are just off the grid. For these two reasons, we write a function that treats nonexistent keys as if they had values of 0. This is not the safest procedure, because it will not help us find errors in our code if we are asking for nonexistent keys because of a mistake we made in programming. I’m generally a pretty careful and conservative person, but in this one case, I chose to live on the wild side.</p>&#13;
<p class="indent">The partial derivative requires that we look up values of the relevant component half a spatial step to either side of where we want to compute the derivative. Half a spatial step means one integer higher and one integer lower in the relevant direction. The functions <span class="literal">partialX</span>, <span class="literal">partialY</span>, and <span class="literal">partialZ</span> all have the same type.</p>&#13;
<pre>partialX,partialY,partialZ :: R -&gt; M.Map (Int,Int,Int) R -&gt; (Int,Int,Int) -&gt; R&#13;
partialX dx m (i,j,k) = (lookupAZ (i+1,j,k) m - lookupAZ (i-1,j,k) m) / dx&#13;
partialY dy m (i,j,k) = (lookupAZ (i,j+1,k) m - lookupAZ (i,j-1,k) m) / dy&#13;
partialZ dz m (i,j,k) = (lookupAZ (i,j,k+1) m - lookupAZ (i,j,k-1) m) / dz</pre>&#13;
<p class="indent">Each function takes a spatial step size, a lookup table (called <span class="literal">m</span> for map), and a location as input. Each works by using the <span class="literal">lookupAZ</span> function to retrieve values on either side of the given location. The difference between these <span epub:type="pagebreak" id="page_568"/>values is divided by the step size to obtain the approximation to the partial derivative.</p>&#13;
<h5 class="h5" id="ch29lev13">Computing the Curl</h5>&#13;
<p class="noindent">With partial derivative in hand, we now turn to the curl. Here are six functions that compute components of the curl of the electric field and the magnetic field. Equation 29.7 gives the components of the curl.</p>&#13;
<pre>curlEx,curlEy,curlEz,curlBx,curlBy,curlBz :: StateFDTD -&gt; (Int,Int,Int) -&gt; R&#13;
curlBx (StateFDTD _ _ dy dz _ b) loc = partialY dy b loc - partialZ dz b loc&#13;
curlBy (StateFDTD _ dx _ dz _ b) loc = partialZ dz b loc - partialX dx b loc&#13;
curlBz (StateFDTD _ dx dy _ _ b) loc = partialX dx b loc - partialY dy b loc&#13;
curlEx (StateFDTD _ _ dy dz e _) loc = partialY dy e loc - partialZ dz e loc&#13;
curlEy (StateFDTD _ dx _ dz e _) loc = partialZ dz e loc - partialX dx e loc&#13;
curlEz (StateFDTD _ dx dy _ e _) loc = partialX dx e loc - partialY dy e loc</pre>&#13;
<p class="indent">Each curl function takes a <span class="literal">StateFDTD</span> and a location as input. The function <span class="literal">curlBx</span> computes the x-component of the curl of the magnetic field. According to Equation 29.7, this is the difference between the partial derivative with respect to <em>y</em> of <em>B<sub>z</sub></em>, denoted <span class="literal">partialY dy b loc</span> in the code above, and the partial derivative with respect to <em>z</em> of <em>B<sub>y</sub></em>, denoted <span class="literal">partialZ dz b loc</span>, each evaluated at the given location. Why do we not specify in the expression <span class="literal">partialY dy b loc</span> that it is the z-component we want the derivative of? The answer is that, because of the way the Yee cell is constructed, every location at which we need to compute <span class="literal">curlBx</span> has <em>B<sub>z</sub></em> living one integer away in the y-direction. The x-component of the curl of the magnetic field is needed only to update the x-component of the electric field. We use <span class="literal">curlBx</span> only when we update <em>E<sub>x</sub></em>, and <em>B<sub>z</sub></em> is its neighbor in the y-direction, so taking <span class="literal">partialY</span> at that location automatically takes the partial of <em>B<sub>z</sub></em>.</p>&#13;
<p class="indent">Let’s look now at how we will update the state.</p>&#13;
<h4 class="h4" id="ch29lev14">State Update</h4>&#13;
<p class="noindent">The function <span class="literal">stateUpdate</span> takes a time step, a time-dependent current density, and a state as input, and it uses that information to produce an updated state as output. It passes the real work off to the functions <span class="literal">updateE</span> and <span class="literal">updateB</span>, which update the electric and magnetic fields, respectively.</p>&#13;
<pre>stateUpdate :: R                   -- dt&#13;
            -&gt; (R -&gt; VectorField)  -- current density J&#13;
            -&gt; StateFDTD -&gt; StateFDTD&#13;
stateUpdate dt j st0@(StateFDTD t _dx _dy _dz _e _b)&#13;
    = let st1 = updateE dt (j t) st0&#13;
          st2 = updateB dt st1&#13;
      in st2</pre>&#13;
<p class="indent">Updating the electric field, as Equation 29.25 shows, requires knowledge of the current density, so we include the current density at the present time, <span class="literal">j t</span>, as an input to <span class="literal">updateE</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_569"/>The role of <span class="literal">updateE</span> is to carry out Equation 29.25 and the analogous equations for <em>E<sub>y</sub></em> and <em>E<sub>z</sub></em> that come from Equations 29.18 and 29.19.</p>&#13;
<pre>updateE :: R            -- time step dt&#13;
        -&gt; VectorField  -- current density J&#13;
        -&gt; StateFDTD -&gt; StateFDTD&#13;
updateE dt jVF st&#13;
    = st { timeFDTD = timeFDTD st + dt / 2&#13;
         , eField   = M.mapWithKey (updateEOneLoc dt jVF st) (eField st) }</pre>&#13;
<p class="indent">The function <span class="literal">updateE</span> uses record syntax to update two of the items in the state: the time and the electric field. The function updates the current time, <span class="literal">timeFDTD st</span>, by adding half a time step to it. The function <span class="literal">updateB</span> adds the other half time step.</p>&#13;
<p class="indent">We update the electric field components at every place they are stored using the <span class="literal">mapWithKey</span> function from <span class="literal">Data.Map.Strict</span>. Let’s look at the type of <span class="literal">mapWithKey</span>.</p>&#13;
<pre>Prelude Data.Map.Strict&gt;  <span class="codestrong1">:m Data.Map.Strict</span>&#13;
Prelude Data.Map.Strict&gt;  <span class="codestrong1">:t mapWithKey</span>&#13;
mapWithKey :: (k -&gt; a -&gt; b) -&gt; Map k a -&gt; Map k b</pre>&#13;
<p class="indent">The <span class="literal">mapWithKey</span> function takes a higher-order function <span class="literal">k -&gt; a -&gt; b</span> as input. For us, this will be a function <span class="literal">(Int,Int,Int) -&gt; R -&gt; R</span>. It describes how to use the key and value of a key-value pair to produce a new value. The function <span class="literal">updateEOneLoc dt jVF st</span>, defined later, serves this role for us, describing how to update an electric field component at a particular position in space.</p>&#13;
<p class="indent">The function <span class="literal">updateB</span> updates the magnetic field. It does for the magnetic field what <span class="literal">updateE</span> does for the electric field. The only difference is that the current density is not required to update the magnetic field, so it is not an input to <span class="literal">updateB</span>.</p>&#13;
<pre>updateB :: R -&gt; StateFDTD -&gt; StateFDTD&#13;
updateB dt st&#13;
    = st { timeFDTD = timeFDTD st + dt / 2&#13;
         , bField   = M.mapWithKey (updateBOneLoc dt st) (bField st) }</pre>&#13;
<p class="indent">As promised, <span class="literal">updateB</span> increases the time by half a time step, so after we have used both <span class="literal">updateE</span> and <span class="literal">updateB</span>, the time has increased by one whole time step. As with <span class="literal">updateE</span>, <span class="literal">updateB</span> uses <span class="literal">mapWithKey</span> to carry out the update over all locations we are tracking in the state. For the magnetic field, the function we map across the lookup table is called <span class="literal">updateBOneLoc dt st</span>. We define it later, and it describes how to update the magnetic field at one particular location in space.</p>&#13;
<p class="indent">Now we look at the functions that update the electric and magnetic fields at one point in space. Here we finally see the Maxwell equations. The function <span class="literal">updateEOneLoc</span> is responsible for updating electric field components at one location in space.</p>&#13;
<pre><span epub:type="pagebreak" id="page_570"/>updateEOneLoc :: R -&gt; VectorField -&gt; StateFDTD -&gt; (Int,Int,Int) -&gt; R -&gt; R&#13;
updateEOneLoc dt jVF st (nx,ny,nz) ec&#13;
    = let r = cart (fromIntegral nx * stepX st / 2)&#13;
                   (fromIntegral ny * stepY st / 2)&#13;
                   (fromIntegral nz * stepZ st / 2)&#13;
          Vec jx jy jz = jVF r&#13;
      in case (odd nx, odd ny, odd nz) of&#13;
           (True , False, False)&#13;
               -&gt; ec + cSI**2 * (curlBx st (nx,ny,nz) - mu0 * jx) * dt  -- Ex&#13;
           (False, True , False)&#13;
               -&gt; ec + cSI**2 * (curlBy st (nx,ny,nz) - mu0 * jy) * dt  -- Ey&#13;
           (False, False, True )&#13;
               -&gt; ec + cSI**2 * (curlBz st (nx,ny,nz) - mu0 * jz) * dt  -- Ez&#13;
           _ -&gt; error "updateEOneLoc passed bad indices"</pre>&#13;
<p class="indent">It requires a time step, a current density, the state, a location, and a present electric field component value as inputs. It uses a <span class="literal">let</span> construction to define a few local variables. The local variable <span class="literal">r</span> holds the position described by the integer triple <span class="literal">(nx,ny,nz)</span>. The current density needs this position, and we compute it by multiplying each integer by half a spatial step in the appropriate direction. The local variables <span class="literal">jx</span>, <span class="literal">jy</span>, and <span class="literal">jz</span> are the components of the current density at the relevant location. Finally, we decide which component is being updated by examining the oddness or evenness of the three integers. As <a href="ch29.xhtml#ch29tab2">Table 29-2</a> indicates, an odd-even-even triple of integers means we are updating <em>E<sub>x</sub></em>, an even-odd-even triple of integers means we are updating <em>E<sub>y</sub></em>, and an even-even-odd triple of integers means we are updating <em>E<sub>z</sub></em>. We include a final line to catch a triple that does not fall into one of these three cases, which would indicate an error in our code since <span class="literal">updateEOneLoc</span> should only ever be used at locations that hold electric field components.</p>&#13;
<p class="indent">Depending on the case analysis, we update the electric field component, called <span class="literal">ec</span>, using one of the three Cartesian components of Equation 29.26. The local variable <span class="literal">ec</span> contains the present value of the electric field component to be updated (that is, one of <em>E<sub>x</sub></em>, <em>E<sub>y</sub></em>, or <em>E<sub>z</sub></em>).</p>&#13;
<p class="indent">The function <span class="literal">updateBOneLoc</span> does for the magnetic field what <span class="literal">updateEOneLoc</span> does for the electric field.</p>&#13;
<pre>updateBOneLoc :: R -&gt; StateFDTD -&gt; (Int,Int,Int) -&gt; R -&gt; R&#13;
updateBOneLoc dt st (nx,ny,nz) bc&#13;
    = case (odd nx, odd ny, odd nz) of&#13;
        (False, True , True ) -&gt; bc - curlEx st (nx,ny,nz) * dt  -- Bx&#13;
        (True , False, True ) -&gt; bc - curlEy st (nx,ny,nz) * dt  -- By&#13;
        (True , True , False) -&gt; bc - curlEz st (nx,ny,nz) * dt  -- Bz&#13;
        _ -&gt; error "updateBOneLoc passed bad indices"</pre>&#13;
<p class="indent">This function is simpler because it does not involve the current density. Again, there is a case analysis on the oddness or evenness of the three integers describing the location to determine which magnetic field component <span epub:type="pagebreak" id="page_571"/>we are asking the function to update. As <a href="ch29.xhtml#ch29tab2">Table 29-2</a> indicates, an even-odd-odd triple of integers means we are updating <em>B<sub>x</sub></em>, an odd-even-odd triple of integers means we are updating <em>B<sub>y</sub></em>, and an odd-odd-even triple of integers means we are updating <em>B<sub>z</sub></em>.</p>&#13;
<p class="indent">Depending on the case analysis, we update the magnetic field component, called <span class="literal">bc</span>, using one of the three Cartesian components of Equation 29.27. The local variable <span class="literal">bc</span> contains the magnetic field component to be updated, which could be <em>B<sub>x</sub></em>, <em>B<sub>y</sub></em>, or <em>B<sub>z</sub></em>, depending on the oddness or evenness of the integers in the triple.</p>&#13;
<p class="indent">This completes the description of the FDTD method. The function <span class="literal">stateUpdate</span> is the entry point for those wishing to use the method. It requires a time step, a time-dependent current density, and an initial state, and it gives back an updated state one time step later. We will likely want to iterate this <span class="literal">stateUpdate</span> function to see the fields evolve over time.</p>&#13;
<p class="indent">Let’s turn now to a use of the FDTD method by producing an animation of the fields for the radiation produced by an oscillating current density.</p>&#13;
<h3 class="h3" id="ch29lev15">Animation</h3>&#13;
<p class="noindent">An accelerating charge radiates. In other words, an accelerating charge creates wavelike electric and magnetic fields that emanate away from the source charge. We can track how the electric and magnetic fields evolve in time by solving the Maxwell equations using the FDTD method we developed.</p>&#13;
<h4 class="h4" id="ch29lev16">Current Density</h4>&#13;
<p class="noindent">In this section, we’ll produce an animation of the electric field produced by an oscillating current density. Our current density will be localized in space, and we’ll center our coordinate system on the current density. There are several ways we could produce a localized current density. Since we have discretized space in the FDTD method, one way to specify a localized current density is to allow the current density to be nonzero at a single location in the FDTD grid. Slightly more convenient for us is to specify a current density that extends over several grid points but quickly drops off with distance from its center.</p>&#13;
<p class="indent">One function that drops off in this way depends on the distance <em>r</em> from the origin as <em>e</em><sup>–<em>r</em><sup>2</sup>/<em>l</em><sup>2</sup></sup>. Such a function is called a <em>Gaussian</em>. Its largest value is at the origin, and its value decreases with distance from the origin. The parameter <em>l</em> has dimensions of length and gives a sense of the region over which the value is significant. At <em>r</em> = <em>l</em>, the Gaussian value is 36.8 percent of its value at the origin. At <em>r</em> = 2<em>l</em>, its value is only 1.8 percent of its value at the origin. And by <em>r</em> = 3<em>l</em>, its value is only about a hundredth of a percent. Equation 29.29 gives the current density we use for our radiation animation.</p>&#13;
<div class="imagec"><img src="Images/571equ01.jpg" alt="Image" width="464" height="30"/></div>&#13;
<p class="indent">We need three parameters to fully specify this current density: an amplitude <em>J</em><sub>0</sub>, a localization length <em>l</em>, and a frequency <em>f</em> . We can think of this <span epub:type="pagebreak" id="page_572"/>current density as representing a charge at the origin that is oscillating in the z-direction.</p>&#13;
<p class="indent">The function <span class="literal">jGaussian</span> describes the current density in Equation 29.29.</p>&#13;
<pre>jGaussian :: R -&gt; VectorField&#13;
jGaussian t r&#13;
    = let wavelength = 1.08             -- meters&#13;
          frequency = cSI / wavelength  -- Hz&#13;
          j0 = 77.5                     -- A/m^2&#13;
          l = 0.108                     -- meters&#13;
          rMag = magnitude (rVF r)      -- meters&#13;
      in j0 *^ exp (-rMag**2 / l**2) *^ cos (2*pi*frequency*t) *^ kHat</pre>&#13;
<p class="indent">The function <span class="literal">jGaussian</span> uses some local variables to specify its behavior. We wish for the oscillation to occur with a frequency that will produce radiation with a wavelength of 1.08 m. The frequency (in Hz) is the speed of light divided by the wavelength. We chose an amplitude of 77.5 A/m<sup>2</sup> because this radiates about 100 W of power. We chose the parameter <em>l</em> to be 0.108 m, which is the same value we will choose later for the spatial step size of the grid. This means that only grid points near the origin will contain any significant current density.</p>&#13;
<p class="indent">Having decided on a current density to serve as the source of our electric and magnetic fields, we turn to a few comments about the boundary of the grid.</p>&#13;
<h4 class="h4" id="ch29lev17">Grid Boundary</h4>&#13;
<p class="noindent">The FDTD method uses a finite grid that keeps track of the electric and magnetic fields at a finite number of places. We use neighboring grid points to calculate the curl needed by the Maxwell equations, as explained earlier. What happens at the edges of the grid? The simple choice we made is to assume that electric and magnetic fields beyond the grid are 0. This choice is enforced by the lookupAZ function, which returns 0 for any point off the grid. While this choice is simple and seems reasonable, it has some undesirable properties. An outgoing wave will reflect at the edge of the grid, bounce back, and interfere. However, if the grid is very large, the amplitude of the reflected wave may be very small and its presence may be tolerable. In our case, we display only a portion of the grid on which calculations occur. Our animation terminates before the wave hits the boundary, so we do not see any reflected wave. In general, the results obtained using our simple boundary conditions are only valid until the wave propagates to the edge of the grid. There are more sophisticated methods available for dealing with the boundary conditions at the edge of the grid. One way is to model a material that absorbs all of the radiation incident; this more or less acts like an infinite box, without requiring computing an infinite number of points. The book by Inan and Marshall [<strong><a href="bib.xhtml#bib18"><span class="green">18</span></a></strong>] has a nice discussion of boundary conditions for the FDTD method.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_573"/>Even without sophisticated boundary conditions, the calculations we are doing are computationally intensive. It could take 20 minutes or more to generate all of the PNG files that will be sewn together to produce the final animation. The files are produced as the information becomes available, so you can see on your own machine how many files are produced in a minute and estimate how long the entire batch will take.</p>&#13;
<p class="indent">Now we are ready to turn to the question of producing frames for the asynchronous animation.</p>&#13;
<h4 class="h4" id="ch29lev18">Display Function</h4>&#13;
<p class="noindent">We want a function that will produce a picture given a <span class="literal">StateFDTD</span>. The function <span class="literal">makeEpng</span> serves this role. It produces a PNG graphics file from a state of the electromagnetic field. We intend to produce one such graphics file at each time step and then sew them together into an animation. The picture we produce in <span class="literal">makeEpng</span> is that of the electric field in the xz-plane. We use shading to indicate the strength of the field, transitioning from one color (usually black or white) indicating a zero field to another color indicating some maximum strength.</p>&#13;
<pre>makeEpng :: (Colour R, Colour R) -&gt; (Int,StateFDTD) -&gt; IO ()&#13;
makeEpng (scol,zcol) (n,StateFDTD _ _ _ _ em _)&#13;
    = let threeDigitString = reverse $ take 3 $ reverse ("00" ++ show n)&#13;
          pngFilePath = "MaxVF" ++ threeDigitString ++ ".png"&#13;
          strongE = 176  -- V/m&#13;
          vs = [((fromIntegral nx, fromIntegral nz),(xComp ev, zComp ev))&#13;
               | nx &lt;- evens, nz &lt;- evens, abs nx &lt;= 50, abs nz &lt;= 50&#13;
               , let ev = getAverage (nx,0,nz) em ^/ strongE]&#13;
      in gradientVectorPNG pngFilePath (scol,zcol) vs</pre>&#13;
<p class="indent">The function <span class="literal">makeEpng</span> takes a pair of colors as input, as well as a pair containing an integer <span class="literal">n</span> and the state of the electromagnetic field. The color pair consists of a strong color <span class="literal">scol</span> for the color of the strongest fields and a zero color <span class="literal">zcol</span> for the color of a zero field. The integer <span class="literal">n</span> that is paired with the state serves as part of the name of the PNG file.</p>&#13;
<p class="indent">The function <span class="literal">makeEpng</span> uses local variables to name the PNG file, the threshold for a strong electric field, and a list of electric field values to be displayed. The local name <span class="literal">pngFilePath</span> is a <span class="literal">String</span> whose value is the name of the PNG file to be produced. This name is <em>MaxVF</em> followed by three digits from the integer <span class="literal">n</span>, followed by <em>.png</em>. We use the threshold <span class="literal">strongE</span> for a strong electric field to choose the display color for each electric field arrow. We color electric field values of 176 V/m or higher with the strong color <span class="literal">scol</span>, values of 0 with the zero color <span class="literal">zcol</span>, and values in between with a blend of the two colors.</p>&#13;
<p class="indent">The list <span class="literal">vs</span> has type <span class="literal">[((R,R),(R,R))]</span> and contains the two-dimensional locations and components of the electric field to be displayed. The function <span class="literal">getAverage</span>, defined next, takes a triple of even integers as input and averages the values on either side of the Yee cell to produce a vector at a single point <span epub:type="pagebreak" id="page_574"/>in space. Finally, we use the function <span class="literal">gradientVectorPNG</span>, defined below, to make the picture.</p>&#13;
<h4 class="h4" id="ch29lev19">Two Helping Functions</h4>&#13;
<p class="noindent">The function <span class="literal">getAverage</span>, used in <span class="literal">makeEpng</span> earlier, produces field vectors at particular locations by averaging the values around the location. Since the Yee cell stores different field components at different locations, we might ask whether there is any natural way to recombine the components into a single vector. The answer is yes, as long as we are willing to use the average of the values at two locations. At any point in the Yee cell labeled by an even-even-even triple, electric field components are stored at each adjacent location. By averaging these, we can produce an electric field vector at any even-even-even location. Similarly, we can produce a magnetic field vector at any odd-odd-odd location.</p>&#13;
<pre>getAverage :: (Int,Int,Int)  -- (even,even,even) or (odd,odd,odd)&#13;
           -&gt; M.Map (Int,Int,Int) R&#13;
           -&gt; Vec&#13;
getAverage (i,j,k) m&#13;
    = let vXl = lookupAZ (i-1,j  ,k  ) m&#13;
          vYl = lookupAZ (i  ,j-1,k  ) m&#13;
          vZl = lookupAZ (i  ,j  ,k-1) m&#13;
          vXr = lookupAZ (i+1,j  ,k  ) m&#13;
          vYr = lookupAZ (i  ,j+1,k  ) m&#13;
          vZr = lookupAZ (i  ,j  ,k+1) m&#13;
      in vec ((vXl+vXr)/2) ((vYl+vYr)/2) ((vZl+vZr)/2)</pre>&#13;
<p class="indent">The function <span class="literal">getAverage</span> takes an integer triple as input, which should be either even-even-even for an electric field or odd-odd-odd for a magnetic field, along with a lookup table, and produces a vector. It does this by sampling the six locations adjacent to the input location, averaging the values in each direction, and putting the averaged components into a vector.</p>&#13;
<p class="indent">The function <span class="literal">gradientVectorPNG</span>, used by <span class="literal">makeEpng</span> earlier, is similar to <span class="literal">vfGrad</span> from <a href="ch22.xhtml">Chapter 22</a>. It produces a gradient vector field picture.</p>&#13;
<pre>gradientVectorPNG :: FilePath&#13;
                  -&gt; (Colour R, Colour R)&#13;
                  -&gt; [((R,R),(R,R))]&#13;
                  -&gt; IO ()&#13;
gradientVectorPNG fileName (scol,zcol) vs&#13;
    = let maxX = maximum $ map fst $ map fst $ vs&#13;
          normalize (x,y) = (x/maxX,y/maxX)&#13;
          array = [(normalize (x,y), magRad v) | ((x,y),v) &lt;- vs]&#13;
          arrowMagRadColors :: R  -- magnitude&#13;
                            -&gt; R  -- angle in radians, ccw from x axis&#13;
                            -&gt; Diagram B&#13;
          <span epub:type="pagebreak" id="page_575"/>arrowMagRadColors mag th&#13;
              = let r     = sinA (15 D.@@ deg) / sinA (60 D.@@ deg)&#13;
                    myType = PolyPolar [120 D.@@ deg,  0 D.@@ deg, 45 D.@@ deg&#13;
                                       , 30 D.@@ deg, 45 D.@@ deg,  0 D.@@ deg&#13;
                                       ,120 D.@@ deg]&#13;
                             [1,1,r,1,1,r,1,1]&#13;
                    myOpts = PolygonOpts myType NoOrient (p2 (0,0))&#13;
                in D.scale 0.5 $ polygon myOpts # lw none #&#13;
                   fc (blend mag scol zcol) # rotate (th D.@@ rad)&#13;
          step = 2 / (sqrt $ fromIntegral $ length vs)&#13;
          scaledArrow m th = D.scale step $ arrowMagRadColors m th&#13;
          pic = D.position [(p2 pt, scaledArrow m th) | (pt,(m,th)) &lt;- array]&#13;
      in renderCairo fileName (dims (V2 1024 1024)) pic</pre>&#13;
<p class="indent">The function <span class="literal">gradientVectorPNG</span> takes three inputs: a name for the PNG file, a pair of colors to use, and a list of two-dimensional vector locations and components. It gives the local name <span class="literal">fileName</span> to the string given as a name for the PNG file. It gives the local names <span class="literal">scol</span> and <span class="literal">zcol</span> to the strong color and zero color to be used in the picture. The list <span class="literal">vs :: [((R,R),(R,R))]</span> gives the locations (first pair of real numbers) and components (second pair of real numbers) of the vectors to be displayed. The magnitudes of these two-dimensional vectors are expected to be in the range 0 (which will get the zero color) to 1 (which will get the strong color).</p>&#13;
<p class="indent">The function <span class="literal">gradientVectorPNG</span> assigns the local name <span class="literal">maxX</span> to the largest value of <em>x</em> describing the locations of the arrows. The local function <span class="literal">normalize</span> takes an (<em>x</em>,<em>y</em>) pair as input and returns a pair in the square from (–1, –1) to (1, 1). The function <span class="literal">normalize</span> assumes that the region to be displayed is a square patch in the xy-plane centered at the origin. The local list <span class="literal">array</span> contains the normalized locations at which arrows are to be placed, along with the magnitude and orientation of each arrow.</p>&#13;
<p class="indent">The function <span class="literal">arrowMagRadColors</span> is a helping function that produces a diagram of a single arrow. We define it as a local function because <span class="literal">gradient</span> <span class="literal">VectorPNG</span> is the only function that uses it. Since it is a local function, it can use the local colors <span class="literal">scol</span> and <span class="literal">zcol</span> without these colors being inputs to <span class="literal">arrow</span> <span class="literal">MagRadColors</span>. The function <span class="literal">arrowMagRadColors</span> expects the magnitude of arrows to be in the range from 0 to 1, assigning the zero color to 0 and the strong color to 1.</p>&#13;
<p class="indent">We use the local variable <span class="literal">step</span> to scale the size of the arrows. It is based on the number of arrows to be displayed on each horizontal row, that number being equal to the square root of the total number of arrows to be displayed over the entire square. The local variable <span class="literal">pic</span> holds the entire picture that the final line of the function renders.</p>&#13;
<h4 class="h4" id="ch29lev20"><span epub:type="pagebreak" id="page_576"/>Main Program</h4>&#13;
<p class="noindent"><a href="ch29.xhtml#ch29list2">Listing 29-2</a> sets the time step size, the number of time steps to be taken, and the spatial step size through its specification of the initial state.</p>&#13;
<pre id="ch29list2">{-# OPTIONS -Wall #-}&#13;
&#13;
import Maxwell ( makeEpng, stateUpdate, jGaussian, initialStateFDTD )&#13;
import Diagrams.Prelude ( black, yellow )&#13;
&#13;
main :: IO ()&#13;
main = let dt = 0.02e-9   -- 0.02 ns time step&#13;
           numTimeSteps = 719&#13;
       in sequence_ $ map (makeEpng (yellow,black)) $ zip [0..numTimeSteps] $&#13;
          iterate (stateUpdate dt jGaussian) (initialStateFDTD 0.108)</pre>&#13;
<p class="listing"><em>Listing 29-2: Stand-alone program to produce PNG files for an electric field animation</em></p>&#13;
<p class="indent">It uses the <span class="literal">sequence_</span> function, described in <a href="ch20.xhtml">Chapter 20</a>, to turn a list of actions into a single action. Since the function application operator <span class="literal">$</span> is right associative (recall <a href="ch01.xhtml#ch1tab2">Table 1-2</a>), it’s easiest to read the definition of <span class="literal">mainPNGs</span> from right to left. The rightmost phrase,</p>&#13;
<pre>iterate (stateUpdate dt jGaussian) (initialStateFDTD 0.108)</pre>&#13;
<p class="noindent">is an infinite list of states, starting with an initial state in which the electric and magnetic fields are 0 everywhere and the spatial step size in each direction is 0.108 m. Applying <span class="literal">zip [0..numTimeSteps]</span> to this infinite list produces a finite list, each element being a pair of an integer with a state. Applying <span class="literal">map (makeEpng (yellow,black))</span> to this list of pairs produces a finite list with type <span class="literal">[IO ()]</span>. Finally, applying <span class="literal">sequence_</span> converts the list of actions into a single action. This program will produce 720 files, named <em>MaxVF000.png</em> through <em>MaxVF719.png</em>, that we can combine into an MP4 movie with an external program such as ffmpeg.</p>&#13;
<p class="indent">The following command asks the external program ffmpeg to combine all PNG files named <em>MaxVFDDD.png</em>, where the capital Ds are digits. We ask for a frame rate of 25 frames/second. The final movie is called <em>MaxVF.mp4</em>.</p>&#13;
<pre><span class="codestrong1">$ ffmpeg -framerate 25 -i MaxVF%03d.png MaxVF.mp4</span></pre>&#13;
<p class="indent">We use a spatial step size of 0.108 m because it is one tenth of the wavelength we expect from our current density. 10 spatial steps per wavelength is about the smallest I’d like to go. More spatial steps per wavelength would produce more accurate results but would take longer to run, assuming we increase the number of grid points to allow the same number of wavelengths to fit across the grid.</p>&#13;
<p class="indent">The time step needs to be a bit smaller than the time it takes light to travel one spatial step; otherwise, the method becomes unstable. (See [<strong><a href="bib.xhtml#bib18"><span class="green">18</span></a></strong>] for details on the stability criterion.) It takes light about 0.36 ns to travel <span epub:type="pagebreak" id="page_577"/>one spatial step. Our time step of 0.02 ns is plenty small to avoid instability. Of course, a smaller time step produces more accurate results at the cost of longer computation time.</p>&#13;
<p class="indent"><a href="ch29.xhtml#ch29fig3">Figure 29-3</a> shows one of the frames of the animation, except that we used black as the strong color and white as the zero color.</p>&#13;
<div class="imagel" id="ch29fig3"><img src="Images/577fig01.jpg" alt="Image" width="521" height="521"/></div>&#13;
<p class="figcap"><em>Figure 29-3: Electric field obtained by solving the Maxwell equations using the current density <span class="literal">jGaussian</span>. The image is one of the frames produced by the main program and shows the xz-plane.</em></p>&#13;
<p class="indent">The wavelike nature of the electric field is apparent. The magnetic field, not shown in <a href="ch29.xhtml#ch29fig3">Figure 29-3</a>, points into or out of the page. The magnitude of the electric field decreases with distance from the source at the center. The radiating electric field is stronger in the <em>z</em> = 0 plane and weaker above and below the source in the z-direction.</p>&#13;
<h3 class="h3" id="ch29lev21">Summary</h3>&#13;
<p class="noindent">In this chapter, we saw how the Maxwell equations describe the evolution of electric and magnetic fields. We identified four relationships between electricity and magnetism, and we explained how the Maxwell equations relate to our description of electric and magnetic fields in previous chapters. We saw how the Maxwell equations, like Newton’s second law, can be viewed as rules for a state-update technique. We described the FDTD method for solving the Maxwell equations, and we applied it to the radiation produced by <span epub:type="pagebreak" id="page_578"/>an oscillating charge and current density. We produced an animation of the wavelike electric field generated by an oscillating current density.</p>&#13;
<p class="indent">We’ve covered a lot of ground in this book. Many of the ideas are really cool but not so easy to grasp right away. If you’re like most people, you’ve understood some things and gotten stuck on others. Patience and perseverance are my advice when you’re stuck. Patience is especially important, and it sometimes means skipping ahead to the beginning of the next section or chapter. I’ve had books on my shelves that were unreadable for years, but somehow I got the background I needed and then one day I could read them.</p>&#13;
<p class="indent">I hope you’ve enjoyed the introduction to computational physics in Haskell that this book provides. You can, of course, do computational physics in any programming language you like. You would learn a lot by translating the work we’ve done here into another language. Let’s take a brief look back at what we’ve done to recall the benefits of a functional language for physics. A pure functional language allows and encourages us to express what is central and important in a single function. The function <span class="literal">newtonSecondPS</span> from <a href="ch16.xhtml">Chapter 16</a> expresses Newton’s second law. The function <span class="literal">maxwellUpdate</span> in this chapter expresses the Maxwell equations.</p>&#13;
<p class="indent">Pure functional programming provides a simpler model of computation than imperative languages like Python since names (variables) refer to quantities that never change. This encourages the naming of verbs (functions) that change nouns, rather than giving names to nouns that change. Physics is a natural candidate to take advantage of pure functional writing because the central ideas of physics, like Newton’s second law and the Maxwell equations, are expressible as verbs.</p>&#13;
<p class="indent">Moreover, a typed functional language allows us to express with precision the nature of the verb a function describes. The type of <span class="literal">newtonSecondPS</span> expresses that we can produce a differential equation from a list of one-body forces. The type of <span class="literal">bFieldFromLineCurrent</span> from <a href="ch27.xhtml">Chapter 27</a> expresses that we can calculate a magnetic field from a curve and a current.</p>&#13;
<p class="indent">The effectful functions we’ve written, those like <span class="literal">gradientVectorPNG</span> with <span class="literal">IO ()</span> in their type that <em>do</em> something, are certainly useful for producing graphs and animations, but they are not really part of the “elegant code” promised in this book’s subtitle. Haskell is as powerful as any other language for doing these things, but the real strength of a functional language for physics lies in the elegant expression of its central ideas, which are purely functional. Programming in a functional language has allowed me to write code that parallels the organization of the subject in my mind. I find that it helps me to think about the subject.</p>&#13;
<p class="indent">The practice of writing physics in a functional language is in its infancy. Two advanced books on the subject are [<strong><a href="bib.xhtml#bib20"><span class="green">20</span></a></strong>] and [<strong><a href="bib.xhtml#bib11"><span class="green">11</span></a></strong>]. There is a lot more to discover about what physics and functional programming can offer each other. I hope you continue to explore these areas if they interest you.</p>&#13;
<h3 class="h3" id="ch29lev22"><span epub:type="pagebreak" id="page_579"/>Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 29.1.</strong> Use <span class="literal">gnuplot</span> to graph the Gaussian function</p>&#13;
<div class="imagec"><img src="Images/579equ02.jpg" alt="Image" width="111" height="28"/></div>&#13;
<p class="noindentts">for several values of <em>l</em>.</p>&#13;
<p class="noindentts"><strong>Exercise 29.2.</strong> Modify the main program and the function <span class="literal">makeEpng</span> to produce an animation of the magnetic field in the xy-plane produced by the current density <span class="literal">jGaussian</span>. Try using 10<sup>–6</sup> T as the threshold for a strong magnetic field.</p>&#13;
<p class="noindentts"><strong>Exercise 29.3.</strong> The current density</p>&#13;
<div class="imagec"><img src="Images/579equ01.jpg" alt="Image" width="466" height="29"/></div>&#13;
<p class="noindentts">has an oscillating magnetic dipole moment, while that of Equation 29.29 has an oscillating electric dipole moment. The radiation produced by the current density of Equation 29.30 is called magnetic dipole radiation. Produce an animation of the magnetic field in the xz-plane. It should look similar to the electric field animation we made for the electric dipole radiation from the current density of Equation 29.29. Try using 2 × 10<sup>–7</sup> T as the threshold for a strong magnetic field.<span epub:type="pagebreak" id="page_580"/></p>&#13;
</div></body></html>