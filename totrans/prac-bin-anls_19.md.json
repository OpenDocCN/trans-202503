["```\n➊ #include <libelf.h>\n➋ #include <gelf.h>\n```", "```\n➊ typedef struct {\n     int fd;          /* file descriptor */\n     Elf *e;          /* main elf descriptor */\n     int bits;        /* 32-bit or 64-bit */\n     GElf_Ehdr ehdr;  /* executable header */\n   } elf_data_t;\n\n➋ typedef struct {\n     size_t pidx;     /* index of program header to overwrite */\n     GElf_Phdr phdr;  /* program header to overwrite */\n     size_t sidx;     /* index of section header to overwrite */\n     Elf_Scn *scn;    /* section to overwrite */\n     GElf_Shdr shdr;  /* section header to overwrite */\n     off_t shstroff;  /* offset to section name to overwrite */\n     char *code;      /* code to inject */\n     size_t len;      /* number of code bytes */\n     long entry;      /* code buffer offset to entry point (-1 for none) */\n     off_t off;       /* file offset to injected code */\n     size_t secaddr;  /* section address for injected code */\n     char *secname;   /* section name for injected code */\n   } inject_data_t;\n```", "```\n   int\n   inject_code(int fd, inject_data_t *inject)\n   {\n➊  elf_data_t elf;\n    int ret;\n    size_t n;\n\n    elf.fd = fd;\n    elf.e = NULL;\n\n➋   if(elf_version(EV_CURRENT) == EV_NONE) {\n      fprintf(stderr, \"Failed to initialize libelf\\n\");\n      goto fail;\n    }\n\n     /* Use libelf to read the file, but do writes manually */\n➌   elf.e = elf_begin(elf.fd, ELF_C_READ, NULL);\n     if(!elf.e) {\n       fprintf(stderr, \"Failed to open ELF file\\n\");\n       goto fail;\n     }\n\n➍   if(elf_kind(elf.e) != ELF_K_ELF) {\n        fprintf(stderr, \"Not an ELF executable\\n\");\n        goto fail;\n     }\n\n➎   ret = gelf_getclass(elf.e);\n     switch(ret) {\n     case ELFCLASSNONE:\n       fprintf(stderr, \"Unknown ELF class\\n\");\n       goto fail;\n     case ELFCLASS32:\n       elf.bits = 32;\n       break;\n     default:\n       elf.bits = 64;\n       break;\n     }\n\n   ...\n```", "```\n   ...\n\n➊  if(!gelf_getehdr(elf.e, &elf.ehdr)) {\n      fprintf(stderr, \"Failed to get executable header\\n\");\n      goto fail;\n   }\n\n   /* Find a rewritable program header */\n➋  if(find_rewritable_segment(&elf, inject) < 0) {\n     goto fail;\n   }\n\n   /* Write the injected code to the binary */\n➌  if(write_code(&elf, inject) < 0) {\n     goto fail;\n   }\n\n   /* Align code address so it's congruent to the file offset modulo 4096 */\n➍  n = (inject->off % 4096) - (inject->secaddr % 4096);\n   inject->secaddr += n;\n\n   /* Rewrite a section for the injected code */\n➎  if((rewrite_code_section(&elf, inject) < 0)\n        || ➏(rewrite_section_name(&elf, inject) < 0)) {\n       goto fail;\n   }\n\n   /* Rewrite a segment for the added code section */\n➐  if(rewrite_code_segment(&elf, inject) < 0) {\n       goto fail;\n   }\n\n   /* Rewrite entry point if requested */\n➑  if((inject->entry >= 0) && (rewrite_entry_point(&elf, inject) < 0)) {\n     goto fail;\n   }\n\n   ret = 0;\n   goto cleanup;\n fail:\n     ret = -1;\n\n   cleanup:\n     if(elf.e) {\n➒      elf_end(elf.e);\n     }\n\n     return ret;\n   }\n```", "```\n   int\n   find_rewritable_segment(elf_data_t *elf, inject_data_t *inject)\n   {\n     int ret;\n     size_t i, n;\n\n➊  ret = elf_getphdrnum(elf->e, &n);\n    if(ret != 0) {\n       fprintf(stderr, \"Cannot find any program headers\\n\");\n       return -1;\n   }\n\n➋  for(i = 0; i < n; i++) {\n➌    if(!gelf_getphdr(elf->e, i, &inject->phdr)) {\n        fprintf(stderr, \"Failed to get program header\\n\");\n        return -1;\n    }\n\n➍  switch(inject->phdr.p_type) {\n    case ➎PT_NOTE:\n      ➏inject->pidx = i;\n      return 0;\n    default:\n      break;\n    }\n   }\n➐ fprintf(stderr, \"Cannot find segment to rewrite\\n\");\n   return -1;\n  }\n```", "```\n   int\n   write_code(elf_data_t *elf, inject_data_t *inject)\n   {\n     off_t off;\n     size_t n;\n➊   off = lseek(elf->fd, 0, SEEK_END);\n     if(off < 0) {\n       fprintf(stderr, \"lseek failed\\n\");\n       return -1;\n   }\n\n➋  n = write(elf->fd, inject->code, inject->len);\n    if(n != inject->len) {\n      fprintf(stderr, \"Failed to inject code bytes\\n\");\n      return -1;\n   }\n➌  inject->off = off;\n\n    return 0;\n  }\n```", "```\n    /* Align code address so it's congruent to the file offset modulo 4096 */\n➊  n = (inject->off % 4096) - (inject->secaddr % 4096);\n➋  inject->secaddr += n;\n```", "```\n  int\n  rewrite_code_section(elf_data_t *elf, inject_data_t *inject)\n  {\n    Elf_Scn *scn;\n    GElf_Shdr shdr;\n    char *s;\n    size_t shstrndx;\n\n➊   if(elf_getshdrstrndx(elf->e, &shstrndx) < 0) {\n      fprintf(stderr, \"Failed to get string table section index\\n\");\n      return -1;\n    }\n\n    scn = NULL;\n➋   while((scn = elf_nextscn(elf->e, scn))) {\n➌     if(!gelf_getshdr(scn, &shdr)) {\n        fprintf(stderr, \"Failed to get section header\\n\");\n        return -1;\n       }\n➍     s = elf_strptr(elf->e, shstrndx, shdr.sh_name);\n      if(!s) {\n        fprintf(stderr, \"Failed to get section name\\n\");\n        return -1;\n      }\n ➎     if(!strcmp(s, \".note.ABI-tag\")) {\n➏       shdr.sh_name      = shdr.sh_name;              /* offset into string table */\n        shdr.sh_type      = SHT_PROGBITS;               /* type */\n        shdr.sh_flags     = SHF_ALLOC | SHF_EXECINSTR;  /* flags */\n        shdr.sh_addr      = inject->secaddr;            /* address to load section at */\n        shdr.sh_offset    = inject->off;                /* file offset to start of section */\n        shdr.sh_size      = inject->len;                /* size in bytes */\n        shdr.sh_link      = 0;                          /* not used for code section */\n        shdr.sh_info      = 0;                          /* not used for code section */\n        shdr.sh_addralign = 16;                         /* memory alignment */\n        shdr.sh_entsize   = 0                           /* not used for code section */\n\n➐       inject->sidx = elf_ndxscn(scn);\n        inject->scn = scn;\n        memcpy(&inject->shdr, &shdr, sizeof(shdr));\n\n➑       if(write_shdr(elf, scn, &shdr, elf_ndxscn(scn)) < 0) {\n             return -1;\n        }\n\n➒       if(reorder_shdrs(elf, inject) < 0) {\n             return -1;\n        }\n\n        break;\n      }\n    }\n➓   if(!scn) {\n      fprintf(stderr, \"Cannot find section to rewrite\\n\");\n      return -1;\n     }\n\n     return 0;\n   }\n```", "```\n  int\n  write_shdr(elf_data_t *elf, Elf_Scn *scn, GElf_Shdr *shdr, size_t sidx)\n  {\n    off_t off;\n    size_t n, shdr_size;\n    void *shdr_buf;\n\n➊   if(!gelf_update_shdr(scn, shdr)) {\n      fprintf(stderr, \"Failed to update section header\\n\");\n      return -1;\n    }\n\n➋   if(elf->bits == 32) {\n➌     shdr_buf = elf32_getshdr(scn);\n       shdr_size = sizeof(Elf32_Shdr);\n    } else {\n➍     shdr_buf = elf64_getshdr(scn);\n      shdr_size = sizeof(Elf64_Shdr);\n    }\n\n    if(!shdr_buf) {\n      fprintf(stderr, \"Failed to get section header\\n\");\n      return -1;\n    }\n\n➎   off = lseek(elf->fd, elf->ehdr.e_shoff + sidx*elf->ehdr.e_shentsize, SEEK_SET);\n    if(off < 0) {\n      fprintf(stderr, \"lseek failed\\n\");\n      return -1;\n    }\n\n➏   n = write(elf->fd, shdr_buf, shdr_size);\n    if(n != shdr_size) {\n      fprintf(stderr, \"Failed to write section header\\n\");\n      return -1;\n    }\n\n    return 0;\n  }\n```", "```\n  int\n  rewrite_section_name(elf_data_t *elf, inject_data_t *inject)\n  {\n    Elf_Scn *scn;\n    GElf_Shdr shdr;\n    char *s;\n    size_t shstrndx, stroff, strbase;\n\n➊   if(strlen(inject->secname) > strlen(\".note.ABI-tag\")) {\n       fprintf(stderr, \"Section name too long\\n\");\n       return -1;\n    }\n\n➋   if(elf_getshdrstrndx(elf->e, &shstrndx) < 0) {\n       fprintf(stderr, \"Failed to get string table section index\\n\");\n       return -1;\n    }\n\n    stroff = 0;\n    strbase = 0;\n    scn = NULL;\n➌   while((scn = elf_nextscn(elf->e, scn))) {\n➍     if(!gelf_getshdr(scn, &shdr)) {\n         fprintf(stderr, \"Failed to get section header\\n\");\n         return -1;\n      }\n➎     s = elf_strptr(elf->e, shstrndx, shdr.sh_name);\n       if(!s) {\n         fprintf(stderr, \"Failed to get section name\\n\");\n         return -1;\n      }\n\n➏     if(!strcmp(s, \".note.ABI-tag\")) {\n         stroff = shdr.sh_name;    /* offset into shstrtab */\n➐      } else if(!strcmp(s, \".shstrtab\")) {\n         strbase = shdr.sh_offset; /* offset to start of shstrtab */\n       }\n    }\n ➑   if(stroff == 0) {\n      fprintf(stderr, \"Cannot find shstrtab entry for injected section\\n\");\n      return -1;\n    } else if(strbase == 0) {\n      fprintf(stderr, \"Cannot find shstrtab\\n\");\n      return -1;\n    }\n\n➒   inject->shstroff = strbase + stroff;\n\n➓   if(write_secname(elf, inject) < 0) {\n       return -1;\n    }\n\n    return 0;\n  }\n```", "```\n  int\n  rewrite_code_segment(elf_data_t *elf, inject_data_t *inject)\n  {\n➊   inject->phdr.p_type   = PT_LOAD;          /* type */\n➋   inject->phdr.p_offset = inject->off;      /* file offset to start of segment */\n    inject->phdr.p_vaddr   = inject->secaddr;  /* virtual address to load segment at */\n    inject->phdr.p_paddr   = inject->secaddr;  /* physical address to load segment at */\n    inject->phdr.p_filesz  = inject->len;      /* byte size in file */\n    inject->phdr.p_memsz   = inject->len;      /* byte size in memory */\n➌   inject->phdr.p_flags  = PF_R | PF_X;      /* flags */\n➍   inject->phdr.p_align  = 0x1000;           /* alignment in memory and file */\n\n➎   if(write_phdr(elf, inject) < 0) {\n       return -1;\n    }\n\n    return 0;\n  }\n```", "```\n   int\n   write_phdr(elf_data_t *elf, inject_data_t *inject)\n   {\n     off_t off;\n     size_t n, phdr_size;\n     Elf32_Phdr *phdr_list32;\n     Elf64_Phdr *phdr_list64;\n     void *phdr_buf;\n\n➊   if(!gelf_update_phdr(elf->e, inject->pidx, &inject->phdr)) {\n       fprintf(stderr, \"Failed to update program header\\n\");\n       return -1;\n     }\n\n     phdr_buf = NULL;\n➋   if(elf->bits == 32) {\n➌     phdr_list32 = elf32_getphdr(elf->e);\n       if(phdr_list32) {\n➍        phdr_buf = &phdr_list32[inject->pidx];\n          phdr_size = sizeof(Elf32_Phdr);\n       }\n     } else {\n       phdr_list64 = elf64_getphdr(elf->e);\n       if(phdr_list64) {\n         phdr_buf = &phdr_list64[inject->pidx];\n         phdr_size = sizeof(Elf64_Phdr);\n       }\n     }\n     if(!phdr_buf) {\n       fprintf(stderr, \"Failed to get program header\\n\");\n       return -1;\n     }\n\n➎   off = lseek(elf->fd, elf->ehdr.e_phoff + inject->pidx*elf->ehdr.e_phentsize, SEEK_SET);\n     if(off < 0) {\n       fprintf(stderr, \"lseek failed\\n\");\n       return -1;\n    }\n\n➏  n = write(elf->fd, phdr_buf, phdr_size);\n    if(n != phdr_size) {\n      fprintf(stderr, \"Failed to write program header\\n\");\n      return -1;\n    }\n\n    return 0;\n  }\n```", "```\n   int\n   rewrite_entry_point(elf_data_t *elf, inject_data_t *inject)\n   {\n➊   elf->ehdr.e_entry = inject->phdr.p_vaddr + inject->entry;\n➋   return write_ehdr(elf);\n  }\n```"]