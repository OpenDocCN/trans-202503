<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_456" aria-label="456"/>&#13;
<figure class="co-img"><img id="fig-pg456" class="img40" src="../images/pg456.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-41.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_457" aria-label="457"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch17">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SUPPORTING DYNAMIC MEMORY ALLOCATION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">Over the course of <span class="chapterintro_Xref-1"><a href="part2.xhtml">Part II</a></span>, you’ve compiled programs that call an increasingly wide range of standard library functions. At the end of <span class="chapterintro_Xref-1"><a href="part1.xhtml">Part I</a></span>, your compiler supported only functions with parameters and return values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, like <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>. Now you can compile programs that call floating-point math functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">fmax</samp> and string processing functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>. In this chapter, you’ll implement the remaining features you need to call a particularly important part of the standard library: the memory management functions. These include <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_alloc</samp>, which allocate memory dynamically; <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, which deallocates dynamically allocated memory; and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, which deallocates one block of memory and reallocates another with the same contents.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_458" aria-label="458"/>To compile programs that declare and call these functions, you’ll need to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. Up until now, we’ve used the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword only to specify an empty parameter list; now we’ll treat it as a proper type specifier. In C, <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> represents the address of a chunk of memory with no particular type; the standard library functions that allocate memory all return this type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type on its own is also useful. For instance, you can use it to declare functions that don’t return a value, like <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>. In addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we’ll implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator, which gets the size of a type or object. C programs often use <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to figure out how many bytes of memory to allocate.</p>&#13;
<p class="TX">This chapter’s not-so-secret agenda is to get you ready to implement structure types in <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span>. Real-life C programs frequently store structures in dynamically allocated memory, and so do many of that chapter’s tests. The changes we make to the type checker will also come in handy in <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span> because some of the typing rules that apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> will apply to structure types too.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-148"/><samp class="SANS_Futura_Std_Bold_B_11">The void Type</samp></h3>&#13;
<p class="TNI">The C standard (section 6.2.5, paragraph 19) gives the following rather mysterious definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: “The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type comprises an empty set of values; it is an incomplete object type that cannot be completed.” We’ll talk more about what “incomplete object type” means in a moment. For now, the main idea is that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> is a type with no values. You can’t do a whole lot with this type, but it does have a few uses.</p>&#13;
<p class="TX">You can give a function a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type if it doesn’t return anything. To leave a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with no expression, like in <a href="chapter17.xhtml#list17-1">Listing 17-1</a>.</p>&#13;
<a id="list17-1"/>&#13;
<pre><code>void return_nothing(void) {&#13;
    return;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: A function with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return type</samp></p>&#13;
<p class="TX">As <a href="chapter17.xhtml#list17-2">Listing 17-2</a> demonstrates, you can also leave out the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement entirely. In that case, the function will return once you reach the end of the function body.</p>&#13;
<a id="list17-2"/>&#13;
<pre><code>void perform_side_effect(void) {&#13;
    extern int some_variable;&#13;
    some_variable = 100;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-2: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_459" aria-label="459"/>A <i>void expression</i> is an expression whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>; it has no value, but you can evaluate it for its side effects. There are three ways to produce a void expression. First, you can call a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function. Second, you can evaluate a conditional expression whose branches are both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:</p>&#13;
<pre><code>flag ? perform_side_effect() : return_nothing();</code></pre>&#13;
<p class="TX">Third, you can cast a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:</p>&#13;
<pre><code>(void) (1 + 1);</code></pre>&#13;
<p class="TX">Here, the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> has no effect on program execution; its only purpose is to tell the compiler, and human readers, that the value of the expression should be discarded. This is a common way to silence compiler warnings about unused values.</p>&#13;
<p class="TX">If you’re particularly zealous about following C’s typing rules, you might also cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in code like that in <a href="chapter17.xhtml#list17-3">Listing 17-3</a> to get the types of two conditional branches to agree.</p>&#13;
<a id="list17-3"/>&#13;
<pre><code>int i = 0;&#13;
flag ? perform_side_effect() : (void) (i = 3);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-3: A conditional expression with type</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp></p>&#13;
<p class="TX">If we left out the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in this conditional expression, one branch would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and the other would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This would be illegal, although most compilers won’t complain about it unless you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag to enable extra warnings. Our compiler will reject conditional expressions with one <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> branch, because it’s pedantic all the time.</p>&#13;
<p class="TX">There are four places where you can use a void expression. First, it can appear as a clause in a conditional expression, as in <a href="chapter17.xhtml#list17-3">Listing 17-3</a>. Second, you can use it as a stand-alone expression:</p>&#13;
<pre><code>perform_side_effect();</code></pre>&#13;
<p class="TX">Third, it can appear as the first or third clause of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header, like in <a href="chapter17.xhtml#list17-4">Listing 17-4</a>.</p>&#13;
<a id="list17-4"/>&#13;
<pre><code>for (perform_side_effect(); i &lt; 10; perform_side_effect())&#13;
    <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-4: Using void expressions in a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop header</samp></p>&#13;
<p class="TX">And fourth, you can cast a void expression to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:</p>&#13;
<pre><code>(void) perform_side_effect();</code></pre>&#13;
<p class="TX">That last one isn’t particularly useful, but it is legal.</p>&#13;
<p class="TX">As you already know, you can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword to specify an empty parameter list in a function declaration. This is a special case, since <span role="doc-pagebreak" epub:type="pagebreak" id="pg_460" aria-label="460"/>it doesn’t actually specify an expression, object, or return value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Even once we extend the compiler to fully support the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type, we’ll handle this particular case exactly the same way as before.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-149"/><samp class="SANS_Futura_Std_Bold_B_11">Memory Management with void *</samp></h3>&#13;
<p class="TNI">Now let’s look at how the memory management functions use <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to represent allocated memory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function has the following signature:</p>&#13;
<pre><code>void *malloc(size_t size);</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument specifies the number of bytes to allocate. Its type, <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>, is an implementation-defined unsigned integer type. Under the System V x64 ABI, <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> is an alias for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. Because we don’t support type aliases, our test programs and examples use this declaration instead:</p>&#13;
<pre><code>void *malloc(unsigned long size);</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates a chunk of memory and returns its address. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> doesn’t know what type of object will be stored in this chunk of memory, it would be misleading to return a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, or any of the other types we’ve seen so far. Instead, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>. You can’t read or write memory through a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointer, though. So, before you can access the memory that you allocated with <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, you need to specify what type of object it should contain by converting its address from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to a different pointer type.</p>&#13;
<p class="TX">You can convert other pointer types to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> without an explicit cast. For example, you might use <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to allocate an array of 100 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> elements:</p>&#13;
<pre><code>int *many_ints = malloc(100 * sizeof (int));</code></pre>&#13;
<p class="TX">When you assign the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>, it’s implicitly converted from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Then, you can subscript <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> like any other pointer into an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array:</p>&#13;
<pre><code>many_ints[10] = 10;</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> argument that designates the chunk of memory to deallocate:</p>&#13;
<pre><code>void free(void *ptr);</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_461" aria-label="461"/>This pointer must be the same value that was returned earlier by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> or one of the other memory allocation functions. Here’s how you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> to deallocate the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> points to:</p>&#13;
<pre><code>free(many_ints);</code></pre>&#13;
<p class="TX">This function call implicitly converts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> back to <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, resulting in the same pointer that <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returned in the first place.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> functions provide slightly different ways to allocate memory; like <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, they return pointers to the allocated space with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function accepts a size and a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointer to previously allocated storage that should now be freed, and it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointer to a newly allocated block of storage with the new size and the original contents. For our purposes, the details of these functions aren’t important; the key idea is that they all use <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointers to identify the blocks of memory they allocate and deallocate.</p>&#13;
<p class="TX">These blocks of memory are objects that we can read and write, much like variables, but their lifetimes are managed differently. As we know, variables have either automatic storage duration (their lifetime lasts through the execution of a single block) or static storage duration (their lifetime lasts for the whole program). A block of allocated memory has <i>allocated storage duration</i>: its lifetime starts when it’s allocated and ends when it’s deallocated.</p>&#13;
<p class="TX">The compiler has to keep track of all the variables with static or automatic storage duration, record details about their size and lifetime in the symbol table, and reserve space for them in the data section or on the stack. But the compiler doesn’t need to know anything about objects with allocated storage duration, because the programmer and the memory management library are responsible for keeping track of them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1"><span id="sec3"/><span id="h1-150"/><samp class="SANS_Futura_Std_Bold_B_11">Complete and Incomplete Types</samp></h3>&#13;
<p class="TNI">An object type is <i>complete</i> if we know its size and <i>incomplete</i> if we don’t. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is the first incomplete type we’ve seen. We don’t know its size because it doesn’t <i>have</i> a size. In the next chapter, we’ll encounter incomplete structure types, whose size and members aren’t visible to the compiler. Incomplete structure types can be completed later in the program if the compiler learns more about them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type, on the other hand, can’t be completed.</p>&#13;
<p class="TX">The C standard states that “an incomplete type can only be used when the size of an object of that type is not needed” (section 6.7.2.3, footnote 132). For example, you can’t define a variable with an incomplete type, because you don’t know how much space to allocate for it. And you can’t assign to an object with an incomplete type or use its value, since you would need to know how many bytes to read or write. With a few exceptions, other incomplete types are subject to the same restrictions as <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, and the type checker will handle them the same way.</p>&#13;
<p class="TX">All pointers are complete types, even if the types they point to are incomplete; we know that the size of a pointer is always 8 bytes. That’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_462" aria-label="462"/>why you can declare variables and parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> values from functions, convert them to other pointer types, and so on. As you’ll see in the next chapter, you can use pointers to incomplete structure types in the same way.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1"><span id="sec4"/><span id="h1-151"/><samp class="SANS_Futura_Std_Bold_B_11">The sizeof Operator</samp></h3>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator accepts either an expression or the name of a type. When it takes a type name, it returns the size of that type in bytes. When it takes an expression, it returns the size of the expression’s type. <a href="chapter17.xhtml#list17-5">Listing 17-5</a> illustrates both cases.</p>&#13;
<a id="list17-5"/>&#13;
<pre><code>sizeof (long);&#13;
sizeof 10.0;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-5: The two uses of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp></p>&#13;
<p class="TX">Both of these <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions evaluate to 8 because the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> types are both 8 bytes. Note that type names in <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions must be parenthesized, but expressions don’t need to be.</p>&#13;
<p class="TX">When you use an array in a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression, it doesn’t decay to a pointer. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression in <a href="chapter17.xhtml#list17-6">Listing 17-6</a>.</p>&#13;
<a id="list17-6"/>&#13;
<pre><code>int array[3];&#13;
return sizeof array;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-6: Getting the size of an array</samp></p>&#13;
<p class="TX">This code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>, which is the size of a three-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>, the size of a pointer.</p>&#13;
<p class="TX">You can always determine an expression’s type—and therefore its size—without evaluating it. In fact, the C standard requires that we <i>don’t</i> evaluate the operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression. Instead, we infer the operand’s type and evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> at compile time. This implies that a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression won’t produce side effects. For example, the statement</p>&#13;
<pre><code>return sizeof puts("Shouting into the void");</code></pre>&#13;
<p class="BodyContinued">won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>. It will just return <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function’s return type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>&#13;
<p class="TX">You can also apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to expressions that would typically produce runtime errors, as <a href="chapter17.xhtml#list17-7">Listing 17-7</a> demonstrates.</p>&#13;
<a id="list17-7"/>&#13;
<pre><code>double *null_ptr = 0;&#13;
return sizeof *null_ptr;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-7: Getting the size of an expression without evaluating it</samp></p>&#13;
<p class="TX">Normally, dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> would lead to undefined behavior. But this example is well defined, because it will never evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_463" aria-label="463"/>Instead, it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>, because the compiler can determine that the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<p class="TX">Variable-length arrays are the one exception to this rule. The size of a variable-length array isn’t known at compile time, so it has to be evaluated at runtime. Because we don’t support variable-length arrays, we can ignore this case.</p>&#13;
<p class="TX">Now that we know how C programs use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, let’s work on the compiler. As usual, we’ll start by updating the lexer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1"><span id="sec5"/><span id="h1-152"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add one new keyword in this chapter:</p>&#13;
<p class="TX-SP"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">sizeof</samp></p>&#13;
<p class="TNI">You don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword; the lexer already recognizes it.</p>&#13;
<aside class="box" aria-label="box-55"><p class="BoxTitle" id="box-55"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 17 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">It should process all of this chapter’s tests without error.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1"><span id="sec6"/><span id="h1-153"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI"><a href="chapter17.xhtml#list17-8">Listing 17-8</a> shows this chapter’s changes to the AST.</p>&#13;
<a id="list17-8"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, initializer? init,&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
initializer = SingleInit(exp) | CompoundInit(initializer*)&#13;
type = Char | SChar | UChar | Int | Long | UInt | ULong | Double <b>|</b> <b>Void</b>&#13;
     | FunType(type* params, type ret)&#13;
     | Pointer(type referenced)&#13;
     | Array(type element, int size)&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(<b>exp?</b>)&#13;
          | Expression(exp)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_464" aria-label="464"/>          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | String(string)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
    | Dereference(exp)&#13;
    | AddrOf(exp)&#13;
    | Subscript(exp, exp)&#13;
<b>    | SizeOf(exp)</b>&#13;
<b>    | SizeOfT(type)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double) | ConstChar(int) | ConstUChar(int)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-8: The abstract syntax tree with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements with no return value</samp></p>&#13;
<p class="TX">We’ve made four small changes here. First, we added a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. Second, the expression in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> statement is now optional so that it can represent <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements with and without return values. Finally, there are two new expressions to represent the two ways you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator.</p>&#13;
<p class="TX">Next, we’ll make the corresponding changes to the grammar. The one wrinkle here is that we can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to a cast expression unless that expression is parenthesized. For example, this is a syntax error:</p>&#13;
<pre><code>sizeof (int) a;</code></pre>&#13;
<p class="TX">Wrapping the cast expression in parentheses fixes the error:</p>&#13;
<pre><code>sizeof ((int) a);</code></pre>&#13;
<p class="TX">This restriction makes it easier for the parser to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operations on type names and on expressions. To capture this restriction in the grammar, we need to break out cast expressions into a separate symbol from other unary expressions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_465" aria-label="465"/>Let’s start by refactoring type names into a symbol that we can use in both cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions:</p>&#13;
<pre><code>&lt;type-name&gt; ::= {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;]</code></pre>&#13;
<p class="TX">Next, we’ll define the new <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;cast-exp&gt;</samp> symbol, which includes one rule for cast expressions and another for all the other unary expressions:</p>&#13;
<pre><code>&lt;cast-exp&gt; ::= "(" &lt;type-name&gt; ")" &lt;cast-exp&gt;&#13;
             | &lt;unary-exp&gt;</code></pre>&#13;
<p class="TX">We’ll then update <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unary-exp&gt;</samp> to include every unary expression except for casts:</p>&#13;
<pre><code>&lt;unary-exp&gt; ::= &lt;unop&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> &lt;cast-exp&gt;&#13;
              | "sizeof" <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> &lt;unary-exp&gt;&#13;
              | "sizeof" "(" &lt;type-name&gt; ")"&#13;
              | &lt;postfix-exp&gt;</code></pre>&#13;
<p class="TX">The rule for unary operations like <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> allows cast expressions as operands <span class="CodeAnnotation" aria-label="annotation1">❶</span>, while the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> doesn’t <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Finally, we’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;cast-exp&gt;</samp> symbol, instead of the more restrictive <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unary-exp&gt;</samp>, to represent a single term in a binary or ternary expression:</p>&#13;
<pre><code>&lt;exp&gt; ::=<b> &lt;cast-exp&gt; </b>| &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;</code></pre>&#13;
<p class="TX"><a href="chapter17.xhtml#list17-9">Listing 17-9</a> gives the complete grammar for this chapter.</p>&#13;
<a id="list17-9"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; ["=" &lt;initializer&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; (&lt;block&gt; | ";")&#13;
&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;&#13;
&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;declarator-suffix&gt;]&#13;
&lt;declarator-suffix&gt; ::= &lt;param-list&gt; | {"[" &lt;const&gt; "]"}+&#13;
&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"&#13;
&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;&#13;
&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" | "double" | "char" <b>| "void"</b>&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;initializer&gt; ::= &lt;exp&gt; | "{" &lt;initializer&gt; {"," &lt;initializer&gt;} [","] "}"&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return"<b> [&lt;exp&gt;] </b>";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_466" aria-label="466"/>              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::=<b> &lt;cast-exp&gt; </b>| &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
<b>&lt;cast-exp&gt; ::= "(" &lt;type-name&gt; ")" &lt;cast-exp&gt;</b>&#13;
<b>             | &lt;unary-exp&gt;</b>&#13;
&lt;unary-exp&gt; ::= &lt;unop&gt; <b>&lt;cast-exp&gt;</b>&#13;
              <b>| "sizeof" &lt;unary-exp&gt;</b>&#13;
              <b>| "sizeof" "(" &lt;type-name&gt; ")"</b>&#13;
              | &lt;postfix-exp&gt;&#13;
<b>&lt;type-name&gt; ::= {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;]</b>&#13;
&lt;postfix-exp&gt; ::= &lt;primary-exp&gt; {"[" &lt;exp&gt; "]"}&#13;
&lt;primary-exp&gt; ::= &lt;const&gt; | &lt;identifier&gt; | "(" &lt;exp&gt; ")" | {&lt;string&gt;}+&#13;
                | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]&#13;
                        | &lt;direct-abstract-declarator&gt;&#13;
&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")" {"[" &lt;const&gt; "]"}&#13;
                               | {"[" &lt;const&gt; "]"}+&#13;
&lt;unop&gt; ::= "-" | "~" | "!" | "*" | "&amp;"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; | &lt;double&gt; | &lt;char&gt;&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;string&gt; ::= ? A string token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;char&gt; ::= ? A char token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
&lt;double&gt; ::= ? A floating-point constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-9: The grammar with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, and optional return values</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> helper function, which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node, should reject any declarations where the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> specifier appears alongside other type specifiers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. Otherwise, the parser should treat <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> like any other type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type can be modified by pointer, array, and function declarators; pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and functions returning <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> are both perfectly legal, while other ways of using <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> are syntactically valid but semantically illegal. For example, it’s a semantic error to declare an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements, define a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> variable, or declare a function with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> parameters. The parser won’t catch these semantic errors, but the type checker will.</p>&#13;
<p class="TX">You may need to change your parsing logic for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp>, even though the grammar rule itself hasn’t changed. If the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>is followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword, you’ll need to look ahead one more token. If the next token is), the parameter list is empty. Otherwise, the list is not empty, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword is the start of a parameter declaration.</p>&#13;
<p class="TX">Note that when a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword indicates an empty parameter list, we do <i>not</i> translate it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp> type in the AST. For example, given the function declaration</p>&#13;
<pre><code>int main(void);</code></pre>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_467" aria-label="467"/>the resulting AST node will have this type:</p>&#13;
<pre><code>FunType(params=[], ret=Int)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> list is empty, just like in prior chapters; it doesn’t contain <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>.</p>&#13;
<aside class="box" aria-label="box-56"><p class="BoxTitle" id="box-56"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 17 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should successfully parse the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid</samp><samp class="SANS_Futura_Std_Book_11">. It should reject the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">, which include invalid type specifiers and malformed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_11">expressions.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1"><span id="sec7"/><span id="h1-154"/><samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp></h3>&#13;
<p class="TNI">Now let’s figure out how to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>. We’ll begin with implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and the other pointer types. These are permitted in a few cases, even though most implicit conversions between pointer types are not. Next, we’ll detect all of the new and exciting type errors that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> can trigger. We’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator last.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2"><span id="sec8"/><span id="h2-176"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conversions to and from void *</samp></h4>&#13;
<p class="TNI">Implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and the other pointer types are legal in three cases. First, you can compare a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> with another pointer type using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>:</p>&#13;
<pre><code>int *a;&#13;
void *b;&#13;
<var>--snip--</var>&#13;
return a == b;</code></pre>&#13;
<p class="TX">Second, in a conditional expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause2&gt;</samp>, one clause can have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and the other clause can have another pointer type:</p>&#13;
<pre><code>int *a;&#13;
void *b;&#13;
<var>--snip--</var>&#13;
return flag ? a : b;</code></pre>&#13;
<p class="TX">In both of these cases, the non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> pointer is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_468" aria-label="468"/>Third, you can implicitly convert to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> during assignment. You can assign a value with any pointer type to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>:</p>&#13;
<pre><code>int *a = 0;&#13;
void *b = a;</code></pre>&#13;
<p class="BodyContinued">And along the same lines, you can assign a value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to an object with another pointer type.</p>&#13;
<p class="TX">This last case doesn’t just include simple assignment; it covers all the conversions “as if by assignment” that we talked about in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>. For example, it’s legal to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> arguments to a function that expects parameters of some other pointer type:</p>&#13;
<pre><code>int use_int_pointer(int *a);&#13;
void *ptr = 0;&#13;
use_int_pointer(ptr);</code></pre>&#13;
<p class="TX">Not coincidentally, these are the same three cases where you can implicitly convert a null pointer constant to some other pointer type. To support implicit conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, we’ll extend two helper functions we defined back in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.</p>&#13;
<p class="TX">Let’s revisit <span class="Xref-1"><a href="chapter14.xhtml#list14-14">Listing 14-14</a></span>, which defined <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>. It’s reproduced here as <a href="chapter17.xhtml#list17-10">Listing 17-10</a>, with this chapter’s changes bolded.</p>&#13;
<a id="list17-10"/>&#13;
<pre><code>get_common_pointer_type(e1, e2):&#13;
    e1_t = get_type(e1)&#13;
    e2_t = get_type(e2)&#13;
    if e1_t == e2_t:&#13;
        return e1_t&#13;
    else if is_null_pointer_constant(e1):&#13;
        return e2_t&#13;
    else if is_null_pointer_constant(e2):&#13;
        return e1_t&#13;
    <b>else if e1_t == Pointer(Void) and e2_t is a pointer type:</b>&#13;
        <b>return Pointer(Void)</b>&#13;
    <b>else if e2_t == Pointer(Void) and e1_t is a pointer type:</b>&#13;
        <b>return Pointer(Void)</b>&#13;
    else:&#13;
        fail("Expressions have incompatible types")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-10: Getting the common type of two expressions, where at least one has pointer type</samp></p>&#13;
<p class="TX">The bolded code permits implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and other pointer types but not between <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> and arithmetic types, array types, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Next, we’ll take another look at <span class="Xref-1"><a href="chapter14.xhtml#list14-16">Listing 14-16</a></span>, reproduced here as <a href="chapter17.xhtml#list17-11">Listing 17-11</a>, with changes bolded.</p>&#13;
<a id="list17-11"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_469" aria-label="469"/>convert_by_assignment(e, target_type):&#13;
    if get_type(e) == target_type:&#13;
        return e&#13;
    if get_type(e) is arithmetic and target_type is arithmetic:&#13;
        return convert_to(e, target_type)&#13;
    if is_null_pointer_constant(e) and target_type is a pointer type:&#13;
        return convert_to(e, target_type)&#13;
<b>    if target_type == Pointer(Void) and get_type(e) is a pointer type:</b>&#13;
<b>        return convert_to(e, target_type)</b>&#13;
<b>    if target_type is a pointer type and get_type(e) == Pointer(Void):</b>&#13;
<b>        return convert_to(e, target_type)</b>&#13;
    else:&#13;
        fail("Cannot convert type for assignment")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-11: Converting an expression to a target type as if by assignment</samp></p>&#13;
<p class="TX">The bolded additions permit us to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to other pointer types, and vice versa, during assignment. Note that nothing in this listing would prevent us from assigning a void expression to a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> target type. However, we’ll introduce other restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elsewhere in the type checker that will ensure that we never call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> with a target type of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. For instance, we’ll never try to convert a function argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, because we’ll reject function declarations with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> parameters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-177"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with void Return Types</samp></h4>&#13;
<p class="TNI">Next, we’ll type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements with and without expressions. Which <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement you should use depends on the function’s return type. A function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type must not return an expression. A function with any other return type must include an expression when it returns. Therefore, these two function definitions are legal:</p>&#13;
<pre><code>int return_int(void) {&#13;
    return 1;&#13;
}&#13;
&#13;
void return_void(void) {&#13;
    return;&#13;
}</code></pre>&#13;
<p class="TX">And these are both illegal:</p>&#13;
<pre><code>int return_int(void) {&#13;
    return;&#13;
}&#13;
&#13;
void return_void(void) {&#13;
    return 1;&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_470" aria-label="470"/>You can’t even return a void expression from a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type, which makes the following example illegal too:</p>&#13;
<pre><code>void return_void(void) {&#13;
    return (void) 1;&#13;
}</code></pre>&#13;
<p class="TX">Both GCC and Clang accept this program, but they’ll warn if you include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag. You can handle this edge case however you like; the test suite doesn’t cover it.</p>&#13;
<p class="TX">I’ll skip the pseudocode for this section, since it’s a pretty straightforward extension to our existing logic to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h2-178"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scalar and Non-scalar Types</samp></h4>&#13;
<p class="TNI">Several C constructs require scalar expressions, including the operands of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> expressions; the first operand of a conditional expression; and the controlling conditions in loops and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The common thread is that all of these language constructs compare the value of the expression to zero. Comparing a pointer or arithmetic value to zero makes sense; comparing a non-scalar value to zero does not.</p>&#13;
<p class="TX">In earlier chapters, there was no way to write a program that violated these type constraints. Arrays were our only non-scalar type, and they decay to pointers wherever scalar expressions are required. But once we throw <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> into the mix, we need to enforce these constraints explicitly. (Although <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> isn’t an aggregate type, it isn’t scalar, either. A scalar expression has a single value, but a void expression has <i>no</i> value.) <a href="chapter17.xhtml#list17-12">Listing 17-12</a> defines a tiny helper function to tell us whether a type is scalar.</p>&#13;
<a id="list17-12"/>&#13;
<pre><code>is_scalar(t):&#13;
    match t with&#13;
    | Void -&gt; return False&#13;
    | Array(elem_t, size) -&gt; return False&#13;
    | FunType(param_ts, ret_t) -&gt; return False&#13;
    | _ -&gt; return True</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-12: Checking whether a type is scalar</samp></p>&#13;
<p class="TX">We can use this helper function to validate controlling conditions and logical operands. For example, <a href="chapter17.xhtml#list17-13">Listing 17-13</a> illustrates how to validate the operand of a logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> expression.</p>&#13;
<a id="list17-13"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Unary(Not, inner) -&gt;&#13;
        typed_inner = typecheck_and_convert(inner, symbols)&#13;
        if not is_scalar(get_type(typed_inner)):&#13;
            fail("Logical operators only apply to scalar expressions")&#13;
<var>        --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-13: Validating that a logical operand is scalar</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_471" aria-label="471"/>Cast expressions are a bit different. Except for casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and pointers, which we already prohibit, you can cast a scalar expression to any scalar type. You can also cast any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. <a href="chapter17.xhtml#list17-14">Listing 17-14</a> shows how to type check cast expressions.</p>&#13;
<a id="list17-14"/>&#13;
<pre><code>    | Cast(t, inner) -&gt;&#13;
        typed_inner = typecheck_and_convert(inner, symbols)&#13;
<var>        --snip--</var>&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if t == Void:&#13;
            return set_type(Cast(t, typed_inner), Void)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if not is_scalar(t):&#13;
            fail("Can only cast to scalar type or void")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if not is_scalar(get_type(typed_inner)):&#13;
            fail("Cannot cast non-scalar expression to scalar type")&#13;
        else:&#13;
            return set_type(Cast(t, typed_inner), t)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-14: Type checking cast expressions</samp></p>&#13;
<p class="TX">First, we explicitly reject casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and pointers. That check is snipped out of <a href="chapter17.xhtml#list17-14">Listing 17-14</a>, since it’s the same as in previous chapters. Then, we check whether the target type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it is, we record that the type of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Otherwise, we validate that both the target type <span class="CodeAnnotation" aria-label="annotation2">❷</span> and the inner expression <span class="CodeAnnotation" aria-label="annotation3">❸</span> are scalar. This rejects casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> to any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. It also forbids casts to array and function types, which we already know are illegal.</p>&#13;
<p class="TX">The type checking logic in <a href="chapter17.xhtml#list17-13">Listings 17-13</a> and <a href="chapter17.xhtml#list17-14">17-14</a> will also apply to structures, which we’ll implement in the next chapter. Structures are aggregate types, but they don’t decay to pointers like arrays do. We’ll therefore need to validate that programs don’t use structures where scalar types are required.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-179"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restrictions on Incomplete Types</samp></h4>&#13;
<p class="TNI">A program will run into type errors if it uses an incomplete type where a complete type is required. For now, we’ll require complete types in three cases. First, you can’t add, subtract, or subscript pointers to incomplete types, since you can’t determine the sizes of the array elements they point to. Second, you can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to an incomplete type, since its size is unknown. Third, whenever you specify an array type, its element type must be complete.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>As a language extension, Clang and GCC permit pointer arithmetic with void pointers and sizeof operations on void. These expressions are implemented as if the size of void were 1.</i></p>&#13;
<p class="TX"><a href="chapter17.xhtml#list17-15">Listing 17-15</a> defines a couple of helper functions to support this validation.</p>&#13;
<a id="list17-15"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_472" aria-label="472"/>is_complete(t):&#13;
    return t != Void&#13;
is_pointer_to_complete(t):&#13;
    match t with&#13;
    | Pointer(t) -&gt; return is_complete(t)&#13;
    | _ -&gt; return False</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-15: Checking for incomplete types and pointers to incomplete types</samp></p>&#13;
<p class="TX">We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> whenever we need to check for a complete type. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_pointer_to_complete</samp> when we need to check for a pointer to a complete type—specifically, when we type check pointer addition, subtraction, and subscripting. For example, <a href="chapter17.xhtml#list17-16">Listing 17-16</a> demonstrates how to type check pointer addition. It reproduces <span class="Xref-1"><a href="chapter15.xhtml#list15-21">Listing 15-21</a></span>, with this chapter’s changes bolded and some unchanged code omitted.</p>&#13;
<a id="list17-16"/>&#13;
<pre><code>    | Binary(Add, e1, e2) -&gt;&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 and t2 are arithmetic:&#13;
<var>            --snip--</var>&#13;
        else if<b> is_pointer_to_complete(t1) </b>and t2 is an integer type:&#13;
<var>            --snip--</var>&#13;
        else if<b> is_pointer_to_complete(t2) </b>and t1 is an integer type:&#13;
<var>            --snip--</var>&#13;
        else:&#13;
            fail("Invalid operands for addition")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-16: Type checking pointer addition, with extra validation that the pointer’s referenced type is complete</samp></p>&#13;
<p class="TX">In the next chapter, we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> to distinguish between complete and incomplete structure types too.</p>&#13;
<p class="TX">We won’t worry about <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> just yet; we’ll type check it a little later, in <span class="Xref">“</span><samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> <span class="Xref">Expressions” on <a href="#pg_477">page 477</a></span>. That means we just have to handle our third case, by making sure that every array element type is complete. This applies to arrays nested in larger types too. The following declaration, for example, is invalid:</p>&#13;
<pre><code>void (*ptr_to_void_array)[3];</code></pre>&#13;
<p class="TX">Even though every pointer is a complete type, it’s illegal to declare a pointer to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements. In <a href="chapter17.xhtml#list17-17">Listing 17-17</a>, we define one more helper function to catch these invalid type specifiers.</p>&#13;
<a id="list17-17"/>&#13;
<pre><code>validate_type_specifier(t):&#13;
    match t with&#13;
    | Array(elem_t, size) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if not is_complete(elem_t):&#13;
            fail("Illegal array of incomplete type")&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_473" aria-label="473"/>        validate_type_specifier(elem_t)&#13;
    | Pointer(referenced_t) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> validate_type_specifier(referenced_t)&#13;
    | FunType(param_ts, ret_t) -&gt;&#13;
        for param_t in param_ts:&#13;
            validate_type_specifier(param_t)&#13;
        validate_type_specifier(ret_t)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> | _ -&gt; return</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-17: Validating type specifiers</samp></p>&#13;
<p class="TX">When we see an array type, we’ll make sure that its element type is complete <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then validate that element type recursively. This ensures that we’ll reject nested arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements, arrays of pointers to arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements, and so on. To handle another derived type, we’ll recursively validate any types it refers to <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Non-derived types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> itself, are all valid <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_type_specifier</samp> to validate type specifiers everywhere they appear: in variable declarations, function declarations, <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions, and cast expressions.</p>&#13;
<p class="TX">We’ll introduce more restrictions on incomplete types in the next chapter. For example, it’s illegal to use incomplete types besides <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in the branches of conditional expressions. It’s also illegal to assign to an lvalue with an incomplete type, but we can ignore this rule for now because there are no <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> lvalues, thanks to the rules we’ll implement next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-180"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extra Restrictions on void</samp></h4>&#13;
<p class="TNI">On top of the restrictions on all incomplete types that we just implemented, we’ll enforce two extra restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in particular: you can’t declare <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> variables or parameters, and you can’t dereference pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. (Both of these uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> are legal gray areas; see the box <span class="Xref"><a href="#box-57">“When void Is Valid: An Excessively Detailed Discussion”</a></span> for the gory details.)</p>&#13;
<p class="TX">These restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> don’t apply to other incomplete types. In the next chapter, you’ll see that you can declare—but not define—a variable with an incomplete structure type. You can then define the variable at a different point in the program, once the type is completed. Similarly, you can declare a function that uses an incomplete structure type as a parameter or return type, as long as you complete the type before you call or define that function. Finally, it’s legal to dereference a pointer to an incomplete structure type, although this isn’t terribly useful; the only thing you’re allowed to do with the result of the dereference is take its address, which just gives back the pointer you started with.</p>&#13;
<aside class="box" aria-label="box-57"><p class="BoxTitle" id="box-57"><samp class="SANS_Dogma_OT_Bold_B_11">WHEN VOID IS VALID: AN EXCESSIVELY DETAILED DISCUSSION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Very few C programmers need to declare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables or dereference</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> <samp class="SANS_Futura_Std_Book_11">expressions. Nonetheless, it’s worth digging into exactly what the C standard</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_474" aria-label="474"/><samp class="SANS_Futura_Std_Book_11">has to say about these niche cases and how a few widely used compilers handle them. This corner of the language turns out to be particularly confusing and ill defined, which makes it a fun illustration of just how difficult language standards are to write and implement.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">For starters, the C standard allows you to declare an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">extern void</samp> <samp class="SANS_Futura_Std_Book_11">variable, but it doesn’t allow you to use that variable. Assigning to it or using its value is, unsurprisingly, undefined behavior. This is true for variables with other incomplete types as well. The one thing you</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">can</samp> <samp class="SANS_Futura_Std_Book_11">do with most variables with incomplete types is take their address:</samp></p>&#13;
<pre><code>extern struct s my_incomplete_var;&#13;
struct s *ptr = &amp;my_incomplete_var;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">As Stephen Kell, this book’s technical reviewer, pointed out to me, you might want to take the address of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables too. For example, if you’re writing a program that examines the layout of memory, such as a debugger, you might need to refer to arbitrary memory locations without a specific type. Most Unix-like systems define special symbols for exactly this purpose:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">etext</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">edata</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp><samp class="SANS_Futura_Std_Book_11">, whose addresses mark the ends of the text, data, and BSS segments, respectively. Programs that need to access these symbols normally declare them as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> <samp class="SANS_Futura_Std_Book_11">or some other arbitrary type, like this:</samp></p>&#13;
<pre><code>extern char etext;&#13;
void *text_segment = &amp;etext;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It would arguably make more sense to declare them as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables, since they don’t really designate objects with values. But if you did that, it would be illegal to take their address, because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables aren’t lvalues. Section 6.3.2.1, paragraph 1, of the C standard states that “an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lvalue</samp> <samp class="SANS_Futura_Std_Book_11">is an expression (with an object type other than</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp><samp class="SANS_Futura_Std_Book_11">) that potentially designates an object.” And section 6.5.3.2, paragraph 1, lays out the constraints on the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> <samp class="SANS_Futura_Std_Book_11">operator: “The operand of the unary</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> <samp class="SANS_Futura_Std_Book_11">operator shall be either a function designator, the result of a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> <samp class="SANS_Futura_Std_Book_11">or unary</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> <samp class="SANS_Futura_Std_Book_11">operator, or an lvalue that designates an object [that satisfies a couple of other constraints].”</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Because a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variable isn’t any of these things, we can’t take its address, which means we can’t do anything with it. In practice, both Clang and GCC let you declare and take the address of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables, although they’ll warn you that your code doesn’t strictly conform to the standard. The Microsoft Visual Studio compiler (MSVC) is much less permissive; it won’t let you declare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">variables at all.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You can declare function parameters with incomplete types, and there’s no indication in the standard that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">parameters would be an exception, so this appears to be legal:</samp></p>&#13;
<pre><code>void my_sketchy_function(void a, void b);&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">But GCC warns about functions with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">parameters, while Clang and MSVC reject them outright. There are at least two good reasons to reject these</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_475" aria-label="475"/><samp class="SANS_Futura_Std_Book_11">parameters: there’s no conceivable use for them, and they potentially conflict with the special case of a single</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">parameter that specifies an empty parameter list. The fact that the standard doesn’t just prohibit</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">parameters aside from that special case seems like an oversight.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Finally, let’s try to figure out what happens when you dereference a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> <samp class="SANS_Futura_Std_Book_11">value and discard the result:</samp></p>&#13;
<pre><code>void *void_ptr = malloc(4);&#13;
(void) *void_ptr;&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">GCC warns about this, and as of version 16.0.0, Clang does as well. MSVC, still the most cantankerous of the bunch, considers it an error. The standard itself is no help at all. Section 6.5.3.2 says that the operand of the pointer dereference operator must be a pointer, but it doesn’t place any restrictions on what type it can point to. It goes on to say: “If the operand … points to an object, the result is an lvalue designating the object. If the operand has type ‘pointer to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">type</samp><samp class="SANS_Futura_Std_Book_11">’, the result has type ‘</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">type</samp><samp class="SANS_Futura_Std_Book_11">’. If an invalid value has been assigned to the pointer, the behavior of the unary</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> <samp class="SANS_Futura_Std_Book_11">operator is undefined.”</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You can’t really argue that a pointer to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">is an “invalid value.” As we’ve seen, well-formed programs use pointers to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">all the time. The next question is whether a pointer to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">can point to an object; if so, it sounds like dereferencing it should give us an lvalue. Other parts of the standard suggest that it can indeed point to an object. For example, the first paragraph of section 7.22.3, which introduces</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> <samp class="SANS_Futura_Std_Book_11">and the other memory management functions, states that “the lifetime of an allocated object extends from the allocation until the deallocation. Each such allocation shall yield a pointer to an object disjoint from any other object.”</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This all suggests that</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void_ptr</samp> <samp class="SANS_Futura_Std_Book_11">is a valid pointer to an object, so</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">*void_ptr</samp> <samp class="SANS_Futura_Std_Book_11">should return an lvalue with type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp><samp class="SANS_Futura_Std_Book_11">—except that void expressions can’t be lvalues. It’s a paradox! According to Aaron Ballman (who’s on the C standards committee), this means that dereferencing a pointer to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">and discarding the result is undefined behavior by omission (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://github.com/llvm/llvm-project/issues/53631#issuecomment-1253653888">https://<wbr/>github<wbr/>.com<wbr/>/llvm<wbr/>/llvm<wbr/>-project<wbr/>/issues<wbr/>/53631#issuecomment<wbr/>-1253653888</a></samp><samp class="SANS_Futura_Std_Book_11">). It would be nice for the C standard to actually spell this out, but I guess the standards committee has higher priorities.</samp></p>&#13;
</aside>&#13;
<p class="TX">We’re fudging one corner case here. Strictly speaking, it’s legal to take the address of <i>any</i> dereferenced pointer, whether it’s a pointer to a complete type, an incomplete structure type, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. As we saw back in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>, taking the address of a dereferenced pointer is a special case; the two operations cancel each other out and the result is well defined, even if the dereference expression by itself would be undefined. That means this code fragment is legal:</p>&#13;
<pre><code>void *void_ptr = malloc(4);&#13;
void *another_ptr = &amp;*void_ptr;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_476" aria-label="476"/>Our compiler will reject all dereference operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> operands, even in this edge case. But we’re not alone here: GCC issues a warning about this code fragment and MSVC rejects it entirely. (Of course, you can handle this edge case correctly if you want; our test suite doesn’t cover it.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-181"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions with void Operands</samp></h4>&#13;
<p class="TNI">We’ll explicitly allow <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> operands in conditional expressions, as <a href="chapter17.xhtml#list17-18">Listing 17-18</a> illustrates.</p>&#13;
<a id="list17-18"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Conditional(condition, e1, e2) -&gt;&#13;
        typed_cond = typecheck_and_convert(condition, symbols)&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if not is_scalar(get_type(typed_cond)):&#13;
            fail("Condition in conditional operator must be scalar")&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 == Void and t2 == Void:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> result_type = Void&#13;
        else if t1 and t2 are arithmetic types:&#13;
            result_type = get_common_type(t1, t2)&#13;
        else if t1 or t2 is a pointer type:&#13;
            result_type = get_common_pointer_type(typed_e1, typed_e2)&#13;
        else:&#13;
            fail("Cannot convert branches of conditional to a common type")&#13;
        <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-18: Type checking a conditional expression</samp></p>&#13;
<p class="TX">To type check a conditional expression, we first validate that its controlling condition is scalar <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we consider the types of both clauses. If they’re both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> too <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Otherwise, we find the result type as before: by applying the usual arithmetic conversions if both operands are arithmetic or finding their common pointer type if either is a pointer. If none of these cases applies—for example, because one operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and the other is a pointer or arithmetic value—we throw an error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Existing Validation for Arithmetic Expressions and Comparisons</samp></h4>&#13;
<p class="TNI">Next, we’ll make sure that our existing logic to type check arithmetic operations and comparisons works even with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in the mix. Earlier, we could assume that every expression had either arithmetic or pointer type. Now we can’t rely on that assumption. For example, let’s revisit <span class="Xref-1"><a href="chapter14.xhtml#list14-15">Listing 14-15</a></span>, which demonstrated how to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expressions. <a href="chapter17.xhtml#list17-19">Listing 17-19</a> reproduces that code with the extra validation logic that we need to add.</p>&#13;
<a id="list17-19"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_477" aria-label="477"/>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Binary(Equal, e1, e2) -&gt;&#13;
        typed_e1 = typecheck_and_convert(e1, symbols)&#13;
        typed_e2 = typecheck_and_convert(e2, symbols)&#13;
        t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        if t1 or t2 is a pointer type:&#13;
            common_type = get_common_pointer_type(typed_e1, typed_e2)&#13;
        else<b> if t1 and t2 are arithmetic types:</b>&#13;
            common_type = get_common_type(t1, t2)&#13;
<b>        else:</b>&#13;
<b>            fail("Invalid operands to equality expression")</b>&#13;
<var>        --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-19: Type checking an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression, with extra validation</samp></p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you compare this code to <a href="chapter14.xhtml#list14-15">Listing 14-15</a>, you’ll notice that we’ve replaced the recursive calls to typecheck_exp with typecheck_and_convert. We made that change back in <a href="chapter15.xhtml">Chapter 15</a>, so it’s not bolded here.</i></p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>, if neither <samp class="SANS_TheSansMonoCd_W5Regular_11">t1</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">t2</samp> was a pointer type, we knew they were both arithmetic types, so we could go ahead and perform the usual arithmetic conversions. Now we’ll explicitly check that they’re either pointer or arithmetic types; if they’re anything else, we’ll fail.</p>&#13;
<p class="TX">More broadly, we should type check each expression’s operands by accepting valid types instead of rejecting invalid ones. For example, we should validate that the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> <i>are</i> arithmetic values, instead of making sure they <i>aren’t</i> pointers. Take a moment to look over your type checking logic for all the relational and arithmetic operations, tightening up any validation that’s too permissive.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2"><span id="sec15"/><span id="h2-183"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp></h4>&#13;
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression has type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>; in our implementation, that’s just <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. To type check <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, we first validate its operand and then record <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> as the result type, as <a href="chapter17.xhtml#list17-20">Listing 17-20</a> demonstrates.</p>&#13;
<a id="list17-20"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | SizeOfT(t) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> validate_type_specifier(t)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if not is_complete(t):&#13;
            fail("Can't get the size of an incomplete type")&#13;
        return set_type(e, ULong)&#13;
    | SizeOf(inner) -&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_478" aria-label="478"/>      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> typed_inner = typecheck_exp(inner, symbols)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if not is_complete(get_type(typed_inner)):&#13;
            fail("Can't get the size of an incomplete type")&#13;
        return set_type(SizeOf(typed_inner), ULong)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-20: Type checking</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operates on a type, we enforce two rules about incomplete types that we discussed in <span class="Xref">“Restrictions on Incomplete Types” on <a href="#pg_471">page 471</a></span>: you can never specify an array with an incomplete element type <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and you can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to an incomplete type <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (You can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to a function type either, but we already catch that error in the parser.)</p>&#13;
<p class="TX">If the operand is an expression, we first infer that expression’s type <span class="CodeAnnotation" aria-label="annotation3">❸</span>. To avoid converting arrays to pointers, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>. Once we’ve determined the expression’s type, we make sure that type is complete <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<aside class="box" aria-label="box-58"><p class="BoxTitle" id="box-58"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the type checker, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 17 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The invalid test cases for this stage are broken up into several subdirectories. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_types/pointer_conversions</samp> <samp class="SANS_Futura_Std_Book_11">cover invalid conversions to and from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp><samp class="SANS_Futura_Std_Book_11">. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_types/scalar_expressions</samp> <samp class="SANS_Futura_Std_Book_11">use non-scalar expressions where scalar expressions are required, and the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_types/incomplete_types</samp> <samp class="SANS_Futura_Std_Book_11">use incomplete types where complete types are required. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/invalid_types/void</samp> <samp class="SANS_Futura_Std_Book_11">cover other invalid uses of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">(like returning a value from a function with a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">return type or comparing two void expressions). Finally,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid</samp> <samp class="SANS_Futura_Std_Book_11">contains valid programs, which your type checker should process successfully.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1"><span id="sec16"/><span id="h1-155"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">Next, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> and void expressions to TACKY. We’ll need to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instructions to account for functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type. We’ll also process casts and conditional expressions of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> slightly differently from their non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> counterparts; in particular, we won’t create any <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> temporary variables. We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions during this pass as well, replacing them with integer constants. We won’t need to change anything to support pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_479" aria-label="479"/>&#13;
<h4 class="H2"><span id="sec17"/><span id="h2-184"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with void Return Types</samp></h4>&#13;
<p class="TNI">We’ll make two changes to the TACKY IR so that we can call and return from functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type. First, we’ll make the destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction optional:</p>&#13;
<pre><code>FunCall(identifier fun_name, val* args, <b>val? dst</b>)</code></pre>&#13;
<p class="TX">For calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> functions, we’ll leave <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> empty. For calls to any other function, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> will be the temporary variable that holds the return value, like it is now. We’ll make a similar change to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction:</p>&#13;
<pre><code>Return(<b>val?</b>)</code></pre>&#13;
<p class="TX">Then, we’ll translate each <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with no expression to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction without a value.</p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function might not use an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement; in this case, it returns once control reaches the end of the function. We already handle this case correctly by adding a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to the end of every TACKY function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2"><span id="sec18"/><span id="h2-185"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Casts to void</samp></h4>&#13;
<p class="TNI"><a href="chapter17.xhtml#list17-21">Listing 17-21</a> shows how to handle a cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: just process the inner expression without emitting any other instructions.</p>&#13;
<a id="list17-21"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Cast(Void, inner) -&gt;&#13;
        emit_tacky_and_convert(inner, instructions, symbols)&#13;
        return PlainOperand(Var("DUMMY"))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-21: Converting a cast to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to TACKY</samp></p>&#13;
<p class="TX">You can return whatever operand you want here; the caller won’t use it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-186"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions with void Operands</samp></h4>&#13;
<p class="TNI"><a href="chapter17.xhtml#list17-22">Listing 17-22</a> demonstrates how we currently convert conditional expressions to TACKY.</p>&#13;
<a id="list17-22"/>&#13;
<pre><code>    | Conditional(condition, e1, e2) -&gt;&#13;
<var>        --snip--</var>&#13;
        cond = emit_tacky_and_convert(condition, instructions, symbols)&#13;
        instructions.append(JumpIfZero(cond, e2_label))&#13;
        dst = make_tacky_variable(get_type(e), symbols)&#13;
        v1 = emit_tacky_and_convert(e1, instructions, symbols)&#13;
        instructions.append_all(&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> [Copy(v1, dst),&#13;
              Jump(end),&#13;
              Label(e2_label)])&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_480" aria-label="480"/>        v2 = emit_tacky_and_convert(e2, instructions, symbols)&#13;
        instructions.append_all(&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> [Copy(v2, dst),&#13;
              Label(end)])&#13;
        return PlainOperand(dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-22: Converting a non-void conditional expression to TACKY</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp> are void expressions, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions <span class="CodeAnnotation" aria-label="annotation1">❶</span><span class="CodeAnnotation" aria-label="annotation2">❷</span> are problematic. We shouldn’t create a <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> temporary variable with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, and we definitely shouldn’t copy anything into it. To handle void expressions in conditionals, we’ll stick with the basic approach from <a href="chapter17.xhtml#list17-22">Listing 17-22</a>, but without generating <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> or emitting either <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. <a href="chapter17.xhtml#list17-23">Listing 17-23</a> shows the updated pseudocode to handle void conditional expressions.</p>&#13;
<a id="list17-23"/>&#13;
<pre><code>    | Conditional(condition, e1, e2) -&gt;&#13;
<var>        --snip--</var>&#13;
        cond = emit_tacky_and_convert(condition, instructions, symbols)&#13;
        instructions.append(JumpIfZero(cond, e2_label))&#13;
        if get_type(e) == Void:&#13;
            emit_tacky_and_convert(e1, instructions, symbols)&#13;
            instructions.append_all(&#13;
            [Jump(end),&#13;
              Label(e2_label)])&#13;
            emit_tacky_and_convert(e2, instructions, symbols)&#13;
            instructions.append(Label(end))&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> return PlainOperand(Var("DUMMY"))&#13;
        else:&#13;
<var>            --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-23: Converting a conditional expression with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">result to TACKY</samp></p>&#13;
<p class="TX">Since we don’t create the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, we need to return some other operand to the caller. We can return a dummy value <span class="CodeAnnotation" aria-label="annotation1">❶</span> because we know the caller won’t use it. To handle non-void expressions, we’ll generate the same instructions as before, so I’ve omitted the pseudocode for that case.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2"><span id="sec20"/><span id="h2-187"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp></h4>&#13;
<p class="TNI">We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions during TACKY generation and represent the results as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> constants, as <a href="chapter17.xhtml#list17-24">Listing 17-24</a> illustrates.</p>&#13;
<a id="list17-24"/>&#13;
<pre><code>    | SizeOf(inner) -&gt;&#13;
        t = get_type(inner)&#13;
        result = size(t)&#13;
        return PlainOperand(Constant(ConstULong(result)))&#13;
    | SizeOfT(t) -&gt;&#13;
        result = size(t)&#13;
        return PlainOperand(Constant(ConstULong(result)))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-24: Evaluating</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">during TACKY generation</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_481" aria-label="481"/>Since we don’t convert the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to TACKY, it won’t be evaluated at runtime.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2"><span id="sec21"/><span id="h2-188"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Latest and Greatest TACKY IR</samp></h4>&#13;
<p class="TNI"><a href="chapter17.xhtml#list17-25">Listing 17-25</a> defines the current TACKY IR, with this chapter’s two changes bolded.</p>&#13;
<a id="list17-25"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init* init_list)&#13;
          | StaticConstant(identifier, type t, static_init init)&#13;
instruction = Return(<b>val?</b>)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
            | DoubleToInt(val src, val dst)&#13;
            | DoubleToUInt(val src, val dst)&#13;
            | IntToDouble(val src, val dst)&#13;
            | UIntToDouble(val src, val dst)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | GetAddress(val src, val dst)&#13;
            | Load(val src_ptr, val dst)&#13;
            | Store(val src, val dst_ptr)&#13;
            | AddPtr(val ptr, val index, int scale, val dst)&#13;
            | CopyToOffset(val src, identifier dst, int offset)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, <b>val?</b> dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-25: Adding support for functions with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return types to the TACKY IR</samp></p>&#13;
<p class="TX">Most of the changes in this section—to support void casts, void conditional expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>—didn’t impact the TACKY IR. We’ll process the two instructions that did change in the next section.</p>&#13;
<aside class="box" aria-label="box-59"><p class="BoxTitle" id="box-59"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 17 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_482" aria-label="482"/>&#13;
<h3 class="H1"><span id="sec22"/><span id="h1-156"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">To finish off the chapter, we’ll generate assembly for <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instructions with no value and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instructions with no destination. We can handle both instructions with minor changes to the assembly generation pass.</p>&#13;
<p class="TX">Normally, an instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> is converted to the following assembly:</p>&#13;
<pre><code>Mov(<var>&lt;val type&gt;</var>, val, <var>&lt;dst register&gt;</var>)&#13;
Ret</code></pre>&#13;
<p class="TX">If the return value is absent, we’ll skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction and just generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction. Along the same lines, <a href="chapter17.xhtml#list17-26">Listing 17-26</a> summarizes how we usually convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction to assembly.</p>&#13;
<a id="list17-26"/>&#13;
<pre><code><var>&lt;fix stack alignment&gt;</var>&#13;
<var>&lt;move arguments to general-purpose registers&gt;</var>&#13;
<var>&lt;move arguments to XMM registers&gt;</var>&#13;
<var>&lt;push arguments onto the stack&gt;</var>&#13;
Call(fun_name)&#13;
<var>&lt;deallocate arguments/padding&gt;</var>&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Mov(<var>&lt;dst type&gt;</var>, <var>&lt;dst register&gt;</var>, dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-26: Converting</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">FunCall</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to assembly when the function returns a value</samp></p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is absent, we won’t generate the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but everything else will remain the same. <a href="chapter17.xhtml#tab17-1">Table 17-1</a> summarizes the latest updates to the conversion from TACKY to assembly, with these two small changes bolded.</p>&#13;
<p class="TT" id="tab17-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 17-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF graybg" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;val type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, val, Reg(AX))<br/>Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Double, val, Reg(XMM0))<br/>Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">void</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args,&#13;
        dst)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is present</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;&#13;
&lt;move arguments to general-purpose registers&gt;&#13;
&lt;move arguments to XMM registers&gt;&#13;
&lt;push arguments onto the stack&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst register&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is absent</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;fix stack alignment&gt;&#13;
&lt;move arguments to general-purpose registers&gt;&#13;
&lt;move arguments to XMM registers&gt;&#13;
&lt;push arguments onto the stack&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Call(fun_name)</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;deallocate arguments/padding&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_483" aria-label="483"/>Because the assembly AST didn’t change, we won’t touch the rest of the backend.</p>&#13;
<aside class="box" aria-label="box-60"><p class="BoxTitle" id="box-60"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 17</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid/void_pointer</samp> <samp class="SANS_Futura_Std_Book_11">perform various operations on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> <samp class="SANS_Futura_Std_Book_11">values, including assignments, comparisons, type conversions, and calls to all the memory management functions we discussed at the beginning of the chapter. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid/void</samp> <samp class="SANS_Futura_Std_Book_11">exercise your compiler’s support for void expressions, including function calls, casts, and conditional expressions. The tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid/sizeof</samp> <samp class="SANS_Futura_Std_Book_11">validate that your compiler can handle both forms of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp><samp class="SANS_Futura_Std_Book_11">, that the operand to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_11">isn’t evaluated at runtime, and that your compiler correctly calculates the size of a wide range of types. Finally, the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_17/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">validate that when you compile code that uses</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">and pointers to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp><samp class="SANS_Futura_Std_Book_11">, it will interoperate correctly with code compiled by your system’s C compiler.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1"><span id="sec23"/><span id="h1-157"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you implemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator. You learned about the difference between complete and incomplete types and the ways that C programs can use void expressions. Then, you extended the type checker to detect invalid uses of incomplete and non-scalar types, modified the TACKY generation stage to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operators without evaluating their operands, and tweaked the backend to support functions that don’t return a value. Next, we’ll finish up <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> by adding structure types. Structures are the very last language feature you’ll implement in the book, and perhaps the most challenging. Luckily, you’re well prepared to take on this challenge, thanks to the skills you learned and the groundwork you laid in previous chapters.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>