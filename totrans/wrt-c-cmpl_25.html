<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="appendix" role="doc-appendix" aria-labelledby="appA">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appA">&#13;
<span class="APPN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_675" aria-label="675"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp></span>&#13;
<span class="APPT"><samp class="SANS_Dogma_OT_Bold_B_11">DEBUGGING ASSEMBLY CODE WITH GDB OR LLDB</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">At some point, your compiler is going to generate assembly code that doesn’t behave correctly, and you’ll need to figure out why. When that happens, a command line debugger is indispensable for understanding what’s going wrong. A debugger lets you pause a running program, step through it one instruction at a time, and examine the program state at different points. You can use either GDB (the GNU debugger) or LLDB (the debugger from the LLVM Project) to debug the assembly code your compiler generates. I recommend using GDB if you’re on Linux and LLDB if you’re on macOS (I think GDB has a slightly nicer UI for working with assembly, but getting it to run on macOS can be a challenge).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_676" aria-label="676"/>This appendix is a brief guide to debugging assembly programs with GDB or LLDB. It introduces the basics that you’ll need to know if you’ve never used a debugger before. It also covers the most important commands and options that you’ll need to use to work with assembly code in particular, which may be new to you even if you’re comfortable using these tools to debug source code. I’ve included separate walk-throughs for the two debuggers; even though they have very similar functionality, the details of many commands are different. Follow the walk-through for whichever debugger you’re using.</p>&#13;
<p class="TX">Before you get started, you should be familiar with the basics of assembly code covered in <span class="Xref-1"><a href="chapter1.xhtml">Chapters 1</a></span> and <span class="Xref-1"><a href="chapter2.xhtml">2</a></span>. A few aspects of assembly from later chapters will also come up, but you can gloss over those if you haven’t gotten to them yet.</p>&#13;
<section epub:type="division">&#13;
&#13;
<h2 class="H1"><span id="h1-200"/><samp class="SANS_Futura_Std_Bold_B_11">The Program</samp></h2>&#13;
<p class="TNI">We’ll use the assembly program in <a href="#listA-1">Listing A-1</a> as a running example.</p>&#13;
<a id="listA-1"/>&#13;
<pre><code>    .data&#13;
    .align 4&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> integer:&#13;
    .long 100&#13;
    .align 8&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> dbl:&#13;
    .double 3.5&#13;
    .text&#13;
    .globl main&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> main:&#13;
    pushq   %rbp&#13;
    movq    %rsp, %rbp&#13;
    subq    $16, %rsp&#13;
    # call a function&#13;
 <span class="CodeAnnotation" aria-label="annotation4">❹</span> callq   f&#13;
 <span class="CodeAnnotation" aria-label="annotation5">❺</span> # put some stuff in registers&#13;
    movl    $0x87654321, %eax&#13;
    movsd   dbl(%rip), %xmm0&#13;
    # put some stuff on the stack&#13;
    movl    $0xdeadbeef, -4(%rbp)&#13;
    movl    $0, -8(%rbp)&#13;
    movl    $-1, -12(%rbp)&#13;
    movl    $0xfeedface, -16(%rbp)&#13;
 <span class="CodeAnnotation" aria-label="annotation6">❻</span> # initialize loop counter&#13;
    movl    $25, %ecx&#13;
.L_loop_start:&#13;
    # decrement counter&#13;
    subl    $1, %ecx&#13;
    cmpl    $0, %ecx&#13;
    # jump back to start of loop&#13;
    jne     .L_loop_start&#13;
    # return 0&#13;
    movl    $0, %eax&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_677" aria-label="677"/>    movq    %rbp, %rsp&#13;
    popq    %rbp&#13;
    ret&#13;
    .text&#13;
    .globl  f&#13;
f:&#13;
    movl    $1, %eax&#13;
    ret&#13;
    .section .note.GNU-stack,"",@progbits</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: A pointless assembly program</samp></p>&#13;
<p class="TX">This program doesn’t do anything useful; it just gives us the opportunity to try out the most important features of the debuggers. It includes a couple of static variables for us to inspect: <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, it first calls a very small function, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, so we can practice stepping into and out of function calls <span class="CodeAnnotation" aria-label="annotation4">❹</span>, then moves some data into registers and onto the stack so we can practice examining the state of the program <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It ends with a loop that decrements ECX on every iteration, stopping once it reaches 0 <span class="CodeAnnotation" aria-label="annotation6">❻</span>. We’ll use this loop to practice setting conditional breakpoints.</p>&#13;
<p class="TX">Download this program from <i><a href="https://norasandler.com/book/#appendix-a">https://<wbr/>norasandler<wbr/>.com<wbr/>/book<wbr/>/#appendix<wbr/>-a</a></i>, then save it as <i>hello_debugger.s</i>. There are two different versions of this file for Linux and macOS, so make sure to pick the right one for your operating system.</p>&#13;
<p class="TX">Once you’ve saved the file, assemble and link it and confirm that it runs:</p>&#13;
<pre><code>$ <b>gcc hello_debugger.s -o hello_debugger</b>&#13;
$ <b>./hello_debugger</b></code></pre>&#13;
<p class="TX">On macOS, include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> option when you assemble and link the file:</p>&#13;
<pre><code>$ <b>gcc -g hello_debugger.s -o hello_debugger</b></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> option generates extra debug information. Make sure to include it when assembling and linking your own compiler’s assembly output for debugging too.</p>&#13;
<p class="TX">Now you can start the walk-through. If you’re using GDB, follow the walk-through in the next section. If you’re using LLDB, skip to <span class="Xref">“Debugging with LLDB” on <a href="#pg_687">page 687</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h2 class="H1"><span id="h1-201"/><samp class="SANS_Futura_Std_Bold_B_11">Debugging with GDB</samp></h2>&#13;
<p class="TNI">Run this command to start up GDB:</p>&#13;
<pre><code>$ <b>gdb hello_debugger</b>&#13;
<var>--snip--</var>&#13;
(gdb)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_678" aria-label="678"/>This sets <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> as the executable to debug but doesn’t actually execute it. Before we start running this executable, let’s configure the UI to make working with assembly code easier.</p>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-240"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Configuring the GDB UI</samp></h3>&#13;
<p class="TNI">During a GDB session, you can open up different text windows that display different information about the running program. For our purposes, the most important of these is the <i>assembly window</i>, which displays the assembly code as we step through it. The <i>register window</i> is also useful; by default, it shows the current contents of every general-purpose register.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> command controls which windows are visible. Let’s open up the assembly and register windows:</p>&#13;
<pre><code>(gdb) <b>layout asm</b>&#13;
(gdb) <b>layout reg</b></code></pre>&#13;
<p class="TX">You should now see three windows in your terminal: the register window, the assembly window, and the command window with the <samp class="SANS_TheSansMonoCd_W5Regular_11">(gdb)</samp> prompt. It should look similar to <a href="#figA-1">Figure A-1</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="figA-1" src="../images/figA-1.jpg" alt="" width="1688" height="741"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: A GDB session with the assembly and register windows open <a href="description-89.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The register window won’t display any information until you start the program.</p>&#13;
<p class="TX">You can scroll in whichever window is currently in focus. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp> command to change the in-focus window:</p>&#13;
<pre><code>(gdb) <b>focus cmd</b>&#13;
(gdb) <b>focus asm</b>&#13;
(gdb)<b> focus regs</b></code></pre>&#13;
</section>&#13;
<section epub:type="division">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_679" aria-label="679"/>&#13;
<h3 class="H2"><span id="h2-241"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting and Stopping the Program</samp></h3>&#13;
<p class="TNI">Next, we’ll set a <i>breakpoint</i>—a location where the debugger will pause the program—and run the program up to that breakpoint. If we start the program without setting a breakpoint first, it will run all the way through without stopping, which isn’t very useful.</p>&#13;
<p class="TX">The command <samp class="SANS_TheSansMonoCd_W5Regular_11">break &lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">function name&gt;</samp> sets a breakpoint at the start of a function. Let’s set a breakpoint at the entrance to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:</p>&#13;
<pre><code>(gdb) <b>break main</b>&#13;
Breakpoint 1 at 0x112d</code></pre>&#13;
<p class="TX">Now let’s start the program:</p>&#13;
<pre><code>(gdb) <b>run</b>&#13;
Starting program: /home/ubuntu/hello_debugger&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Breakpoint 1, 0x000055555555512d in main ()</code></pre>&#13;
<p class="TX">The output of this command tells us that the program has hit the breakpoint we just set <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Notice that the current instruction is highlighted in the assembly window and the current values of the general-purpose registers are displayed in the register window, as shown in <a href="#figA-2">Figure A-2</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="figA-2" src="../images/figA-2.jpg" alt="" width="1689" height="745"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A GDB session when the program is stopped at a breakpoint <a href="description-90.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once a program is paused, there are a few commands you can use to move it forward:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> resumes the program and runs until we hit another breakpoint or exit.</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> resumes the program and pauses again when we return from the current function.</p>&#13;
<p class="ListPlain"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_680" aria-label="680"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> executes the next instruction, then pauses. It steps into <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions, pausing at the first instruction in the callee. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp> will execute <i>n</i> instructions.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> executes the next instruction, then pauses. It steps over <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions, pausing at the next instruction after <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> in the current function. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp> will execute <i>n</i> instructions.</p>&#13;
<p class="TX">Most GDB instructions can be abbreviated to one or two letters: you can type <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi</samp>, and so on. <a href="#tabA-1">Table A-1</a> on <span class="Xref"><a href="#pg_687">page 687</a></span> gives full and shortened versions of all the commands we discuss.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">WARNING</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>While the nexti and stepi commands step through assembly instructions, the next and step commands step through lines in the original source file. Since we don’t have any information about the original source file, entering one of these commands will run the program until the end of the current function. These commands are abbreviated to n and s, respectively, so it’s easy to run them by accident when you meant to use nexti or stepi.</i></p>&#13;
<p class="TX">Let’s try out our new commands. First, we’ll execute two instructions, which should take us into the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:</p>&#13;
<pre><code>(gdb) <b>stepi 2</b>&#13;
0x0000555555555176 in <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> f ()</code></pre>&#13;
<p class="TX">We can see from the command output <span class="CodeAnnotation" aria-label="annotation1">❶</span> and from the highlighted instruction in the assembly window that we’re stopped in <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Next, we’ll return from <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:</p>&#13;
<pre><code>(gdb) <b>finish</b>&#13;
Run till exit from #0  0x0000555555555176 in f ()&#13;
0x0000555555555136 in main ()</code></pre>&#13;
<p class="TX">We’re now back in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>. Let’s continue:</p>&#13;
<pre><code>(gdb) <b>continue</b>&#13;
Continuing.&#13;
[Inferior 1 (process 82326) exited normally]</code></pre>&#13;
<p class="TX">Since we didn’t hit any more breakpoints, the program ran until it exited. To keep debugging it, we’ll have to restart it:</p>&#13;
<pre><code>(gdb) <b>run</b>&#13;
Starting program: /home/ubuntu/hello_debugger&#13;
&#13;
Breakpoint 1, 0x000055555555512d in main ()</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_681" aria-label="681"/>Now we’re paused at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> again. We’ll step forward two instructions one more time, but this time we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> to step over <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of stepping into it:</p>&#13;
<pre><code>(gdb) <b>nexti 2</b>&#13;
0x0000555555555136 in main ()</code></pre>&#13;
<p class="TX">This puts us back at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.</p>&#13;
<section epub:type="division">&#13;
&#13;
<h4 class="H3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Breakpoints by Address</samp></h4>&#13;
<p class="TNI">In addition to setting breakpoints on functions, you can break on specific machine instructions. Let’s set a breakpoint on the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>. First, we’ll find this instruction in the assembly window. It should look something like this:</p>&#13;
<pre><code>    <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x555555555143 <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> &lt;main+26&gt;        movl    0xdeadbeef, -4(%rbp)</code></pre>&#13;
<p class="TX">The instruction’s address in memory is at the beginning of the line <span class="CodeAnnotation" aria-label="annotation1">❶</span>, followed by the byte offset of that address from the start of the function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The exact address may be different on your machine, but the offset should be the same. To set this breakpoint, you can type either</p>&#13;
<pre><code>(gdb) <b>break *main+26</b></code></pre>&#13;
<p class="BodyContinued">or</p>&#13;
<pre><code>(gdb) <b>break *</b><var><b>MEMORY_ADDRESS</b></var></code></pre>&#13;
<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp> is the address you found in the assembly window. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> symbol tells GDB that we’re specifying an exact address rather than a function name.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h4 class="H3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Managing Breakpoints</samp></h4>&#13;
<p class="TNI">Let’s list all the breakpoints we’ve set:</p>&#13;
<pre><code>(gdb) <b>info break</b>&#13;
Num     Type           Disp Enb Address            What&#13;
1       breakpoint     keep y   0x000055555555512d &lt;main+4&gt;&#13;
        breakpoint already hit 1 time&#13;
2       breakpoint     keep y   0x0000555555555143 &lt;main+26&gt;</code></pre>&#13;
<p class="TX">Every breakpoint has a unique number, which you can refer to if you need to delete, disable, or modify it. Let’s delete breakpoint 1:</p>&#13;
<pre><code>(gdb) <b>delete 1</b></code></pre>&#13;
<p class="TX">Next, we’ll look at a couple of different ways to examine the program’s state.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_682" aria-label="682"/>&#13;
<h3 class="H2"><span id="h2-242"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Printing Expressions</samp></h3>&#13;
<p class="TNI">You can print out expressions with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">print/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt; &lt;expr&gt;</samp>, where:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;format&gt;</samp> is a one-letter format specifier. You can use most of the same format specifiers you’d use in <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to display a value as a hexadecimal integer, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> to display it as a signed integer, and so on.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;expr&gt;</samp> is an arbitrary expression. This expression can refer to registers, memory addresses, and symbols in the running program. It can also include C operations like arithmetic, pointer dereferencing, and cast expressions.</p>&#13;
<p class="TX">Let’s try some examples. Right now, the program should be paused at the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321, %eax</samp>. We’ll step through this instruction, then print out the value of EAX in a few different formats:</p>&#13;
<pre><code>(gdb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
(gdb) <b>print $eax</b>&#13;
$1 = <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> -2023406815&#13;
(gdb) <b>print/x $eax</b>&#13;
$2 = <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> 0x87654321&#13;
(gdb) <b>print/u $eax</b>&#13;
$3 = <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> 2271560481</code></pre>&#13;
<p class="TX">By default, GDB formats the values in general-purpose registers as signed integers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Here, we also display the value in EAX in hexadecimal <span class="CodeAnnotation" aria-label="annotation2">❷</span> and as an unsigned integer <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The symbols <samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">$2</samp>, and so on are <i>convenience variables</i>, which GDB automatically generates to store the result of each expression.</p>&#13;
<p class="TX">You can find the full list of format specifiers in the documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> command, which we’ll talk more about in a moment:</p>&#13;
<pre><code>(gdb) <b>help x</b>&#13;
<var>--snip--</var>&#13;
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),&#13;
  t(binary), f(float), a(address), i(instruction), c(char), s(string)&#13;
  and z(hex, zero padded on the left).&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX"><span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span> introduces the XMM registers, which hold floating-point values. The next instruction in our program, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd dbl(%rip), %xmm0</samp>, copies the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp> from the static <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> variable into XMM0.</p>&#13;
<p class="TX">Let’s step through this instruction, then inspect XMM0:</p>&#13;
<pre><code>(gdb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
(gdb) <b>print $xmm0</b>&#13;
$4 = {v4_float = {0, 2.1875, 0, 0}, v2_double = {3.5, 0}, v16_int8 = {0, 0, 0, 0,&#13;
0, 0, 12, 64, 0, 0, 0, 0, 0, 0, 0, 0}, v8_int16 = {0, 0, 0, 16396, 0, 0, 0, 0},&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_683" aria-label="683"/>v4_int32 = {0, 1074528256, 0, 0}, v2_int64 = {4615063718147915776, 0}, uint128 =&#13;
4615063718147915776}</code></pre>&#13;
<p class="TX">GDB is showing us lots of different views of the same data: <samp class="SANS_TheSansMonoCd_W5Regular_11">v4_float</samp> displays this register’s contents as an array of four 32-bit floats, <samp class="SANS_TheSansMonoCd_W5Regular_11">v2_double</samp> displays it as an array of 64-bit doubles, and so on. Since we’ll use XMM registers only to store individual doubles, you can always examine them with a command like this:</p>&#13;
<pre><code>(gdb) <b>print $xmm0.v2_double[0]</b>&#13;
$5 = 3.5</code></pre>&#13;
<p class="TX">This prints out the value in the register’s lower 64 bits, interpreted as a double.</p>&#13;
<p class="TX">In addition to registers, we can print out the values of objects in the symbol table. Let’s inspect the two static variables in this program, <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>:</p>&#13;
<pre><code>(gdb) <b>print (long) integer</b>&#13;
$6 = 100&#13;
(gdb) <b>print (double) dbl</b>&#13;
$7 = 3.5</code></pre>&#13;
<p class="TX">Since GDB doesn’t have any information about these objects’ types, we have to cast them to the correct type explicitly.</p>&#13;
<p class="TX">Let’s look at a few examples of more complex expressions. Aside from the fact that they refer directly to hardware registers, these expressions all use ordinary C syntax.</p>&#13;
<p class="TX">We can perform basic arithmetic:</p>&#13;
<pre><code>(gdb) <b>print/x $eax + 0x10</b>&#13;
$8 = 0x87654331</code></pre>&#13;
<p class="TX">We can call functions that are defined in the current program or the standard library. Here, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, which returns <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>:</p>&#13;
<pre><code>(gdb) <b>print (int) f()</b>&#13;
$9 = 1</code></pre>&#13;
<p class="TX">We can also dereference pointers. Let’s execute the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>, then inspect the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:</p>&#13;
<pre><code>(gdb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
(gdb) <b>print/x *(int *)($rbp - 4)</b>&#13;
$10 = 0xdeadbeef</code></pre>&#13;
<p class="TX">First, we calculate the memory address we want to inspect, <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>. Then, we cast this address to the correct pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">(int *)</samp>. Finally, we <span role="doc-pagebreak" epub:type="pagebreak" id="pg_684" aria-label="684"/>dereference it with the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. This produces an integer, which we print out in hexadecimal with the <samp class="SANS_TheSansMonoCd_W5Regular_11">/x</samp> specifier.</p>&#13;
<p class="TX">Next, we’ll look at a more flexible way to inspect values in memory.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-243"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining Memory</samp></h3>&#13;
<p class="TNI">We can examine memory with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">x/&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n&gt;&lt;format&gt;&lt;unit&gt; &lt;expr&gt;</samp>, where:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;n&gt;</samp> is the number of units of memory to display (given the unit size specified by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;unit&gt;</samp>).</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;format&gt;</samp> specifies how to format each unit. These are the same format specifiers we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> command.</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;unit&gt;</samp> is a one-letter specifier for the size of a unit: <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> for a byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> for a 2-byte halfword, <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> for a 4-byte word, or <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> for an 8-byte “giant” word.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;expr&gt;</samp> is an arbitrary expression that evaluates to some valid memory address. These are the same kinds of expressions we can use in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> command.</p>&#13;
<p class="TX">Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> command to inspect the integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:</p>&#13;
<pre><code>(gdb) <b>x/1xw ($rbp - 4)</b>&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> 0x7fffffffe2ac: <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> 0xdeadbeef</code></pre>&#13;
<p class="TX">This command tells GDB to print out one 4-byte word in hexadecimal. The output includes both the memory address <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the value at that address <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The next three instructions in <a href="#listA-1">Listing A-1</a> store three more integers on the stack:</p>&#13;
<pre><code>    movl    $0, -8(%rbp)&#13;
    movl    $-1, -12(%rbp)&#13;
    movl    $0xfeedface, -16(%rbp)</code></pre>&#13;
<p class="TX">We’ll use the commands in <a href="#listA-2">Listing A-2</a> to step through these instructions, then print out the whole stack frame.</p>&#13;
<a id="listA-2"/>&#13;
<pre><code>(gdb) <b>stepi 3</b>&#13;
(gdb) <b>x/6xw $rsp</b>&#13;
0x7fffffffe2a0: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0xfeedface      0xffffffff     0x00000000     <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> 0xdeadbeef&#13;
0x7fffffffe2b0: <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> 0x00000000      0x00000000</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Stepping forward three instructions, then printing out the current stack frame</samp></p>&#13;
<p class="TX">The command <samp class="SANS_TheSansMonoCd_W5Regular_11">x/6xw $rsp</samp> tells GDB to print out six 4-byte words, starting at the address in RSP. We print out six words because the stack frame for this particular function is 24 bytes. At the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, we saved the old value of RBP onto the stack. That’s 8 bytes. Then, we allocated another 16 bytes with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $16, %rsp</samp>. Keep in mind that RSP always holds the address of the top of the stack, which is the <i>lowest</i> stack address.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_685" aria-label="685"/>This command displays the four integers we saved to the stack, with <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp> at the top <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0xdeadbeef</samp> at the bottom <span class="CodeAnnotation" aria-label="annotation2">❷</span>, followed by the old value of RBP <span class="CodeAnnotation" aria-label="annotation3">❸</span>. On some systems, this value will be 0 because we’re in the outermost stack frame; on others, it will be a valid memory address.</p>&#13;
<p class="TX">The saved value of RBP is at the bottom of the current stack frame. Right after it, on top of the <i>caller’s</i> stack frame, we’ll find the caller’s return address—that is, the address we’ll jump to when we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. (We covered this in detail when we implemented function calls in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>.) Let’s inspect this return address:</p>&#13;
<pre><code>(gdb) <b>x/4ag $rsp</b>&#13;
0x7fffffffe2a0: 0xfffffffffeedface      0xdeadbeef00000000&#13;
0x7fffffffe2b0: 0x0     <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x7ffff7dee083 &lt;__libc_start_main+243&gt;</code></pre>&#13;
<p class="TX">This command will print out four 8-byte “giant” words, starting with the value at the address in RSP. The <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> specifier tells GDB to format these values as memory addresses; this means it will print each address in hexadecimal and, if possible, print out its offset from the nearest symbol in the program. Because function and static variable names are defined in the symbol table, GDB can display the relative offsets of assembly instructions and static data. It won’t display relative offsets of stack addresses, heap addresses, or invalid addresses, because they would be completely meaningless.</p>&#13;
<p class="TX">The first line of output includes the four integers we saved onto the stack, now displayed as two 8-byte values instead of four 4-byte values. The null pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">0x0</samp> on the next line is the saved value of RBP. None of these three 8-byte values are valid addresses, so GDB can’t display their offsets from symbols. The next value on the stack is the return address <span class="CodeAnnotation" aria-label="annotation1">❶</span>. GDB tells us that this is the address of an instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">_libc_start_main</samp>, the standard library function responsible for calling <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and cleaning up after it exits.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> specifier makes it easy to spot return addresses and pointers to static variables. This is particularly useful if your program’s stack frame is corrupted; finding each stack frame’s return address can help you get your bearings.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-244"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Conditional Breakpoints</samp></h3>&#13;
<p class="TNI">To wrap up this walk-through, we’ll look at how to set <i>conditional breakpoints</i>. The program will pause at a conditional breakpoint only if the associated condition is true. This condition can be an arbitrary expression; GDB will consider it false if it evaluates to 0 and true otherwise.</p>&#13;
<p class="TX">Let’s set a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> instruction at the end of the last loop iteration in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>. First, we need to find this instruction in the assembly window. It should be 65 bytes after the start of the function:</p>&#13;
<pre><code>    0x55555555516a &lt;main+65&gt;        jne    0x555555555164 &lt;main+59&gt;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_686" aria-label="686"/>We’ll set a conditional breakpoint to pause on this instruction if ECX is 0:</p>&#13;
<pre><code>(gdb) <b>break *main+65 if $ecx == 0</b></code></pre>&#13;
<p class="TX">Since this loop repeats until ECX is 0, the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will be true only on the last iteration. Let’s continue until this breakpoint, then verify that the condition is true:</p>&#13;
<pre><code>(gdb) <b>c</b>&#13;
Continuing.&#13;
&#13;
Breakpoint 3, 0x000055555555516a in main ()&#13;
(gdb) <b>print $ecx</b>&#13;
$11 = 0</code></pre>&#13;
<p class="TX">So far, so good. If you get a different value for ECX, check whether you set the breakpoint correctly:</p>&#13;
<pre><code>(gdb) <b>info break</b>&#13;
<var>--snip--</var>&#13;
3       breakpoint     keep y   0x000055555555516a <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> &lt;main+65&gt;&#13;
        stop only if <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> $ecx == 0</code></pre>&#13;
<p class="TX">Make sure that your breakpoint is at the location <samp class="SANS_TheSansMonoCd_W5Regular_11">main+65</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and that it includes the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If your breakpoint looks different, you might have mistyped something; delete it and try again.</p>&#13;
<p class="TX">We should be on the last loop iteration, so let’s step forward one instruction and make sure that the jump isn’t taken:</p>&#13;
<pre><code>(gdb) <b>stepi</b></code></pre>&#13;
<p class="TX">Usually, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> will jump back to the start of the loop, but on the last iteration it moves forward to the next instruction.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-245"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Help</samp></h3>&#13;
<p class="TNI">To learn about commands and options that we didn’t cover here, see the GDB documentation at <i><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/index.html">https://<wbr/>sourceware<wbr/>.org<wbr/>/gdb<wbr/>/current<wbr/>/onlinedocs<wbr/>/gdb<wbr/>/index<wbr/>.html</a></i>. As you saw earlier, you can also type <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> at the prompt to learn more about any GDB command. For example, to see the documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> command, type:</p>&#13;
<pre><code>(gdb) <b>help run</b>&#13;
Start debugged program.&#13;
You may specify arguments to give it.&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_687" aria-label="687"/><a href="#tabA-1">Table A-1</a> summarizes the commands and options we covered, including full and abbreviated forms for each command (except <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, which can’t be abbreviated any further). Both forms take the same arguments.</p>&#13;
<p class="TT" id="tabA-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table A-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">A Summary of GDB Commands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Command</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp></p></td>&#13;
<td class="Basic-Table TBF graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Start the program.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Resume the program.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Resume the program and continue until the current function exits.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Execute one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">instructions), stepping into function calls.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Execute one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">instructions), stepping over function calls.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;loc&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a breakpoint at</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;loc&gt;</samp> <samp class="SANS_Futura_Std_Book_11">(conditional on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp><samp class="SANS_Futura_Std_Book_11">, if provided).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">info break</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">List all breakpoints. (Other</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">info</samp> <samp class="SANS_Futura_Std_Book_11">subcommands display other information.)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">i b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">delete [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;id&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Delete all breakpoints (or the breakpoint specified by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;id&gt;</samp><samp class="SANS_Futura_Std_Book_11">).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">print/&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">format&gt; &lt;expr&gt;</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Evaluate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;expr&gt;</samp> <samp class="SANS_Futura_Std_Book_11">and display the result according to format specifier</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;&lt;format&gt;&lt;unit&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">addr&gt;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Print out memory starting at</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp> <samp class="SANS_Futura_Std_Book_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">chunks of size</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;unit&gt;</samp><samp class="SANS_Futura_Std_Book_11">, formatted according to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;window&gt;</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;window&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">la</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">focus</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;window&gt;</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Change focus to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;window&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cmd&gt;</samp></p></td>&#13;
<td class="Basic-Table TBL graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Display help text about</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cmd&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Now you’re ready to start debugging with GDB!</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h2 class="H1"><span id="h1-202"/><samp class="SANS_Futura_Std_Bold_B_11">Debugging with LLDB</samp></h2>&#13;
<p class="TNI">Run this command to start up LLDB:</p>&#13;
<pre><code>$ <b>lldb hello_debugger</b>&#13;
(lldb) target create "hello_debugger"&#13;
Current executable set to 'hello_debugger' (x86_64).&#13;
(lldb)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_688" aria-label="688"/>This will set <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> as the executable to debug but won’t execute it yet. If prompted, enter your username and password to give LLDB permission to control <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>.</p>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-246"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting and Stopping the Program</samp></h3>&#13;
<p class="TNI">Next, we’ll set a <i>breakpoint</i>—a location where the debugger will pause the program—and run the program up to that breakpoint. If we start the program without setting a breakpoint first, it will run all the way through without stopping, which isn’t very useful.</p>&#13;
<p class="TX">Let’s set a breakpoint at the entrance to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:</p>&#13;
<pre><code>(lldb) <b>break set -n main</b>&#13;
Breakpoint 1: where = hello_debugger`main, address = 0x0000000100003f65</code></pre>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> may be at a different memory address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">break set</samp> command creates a new breakpoint; the <samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp> option specifies the name of the function where we want to break. We’ll look at other ways to set breakpoints in a moment.</p>&#13;
<p class="TX">Now let’s run the program:</p>&#13;
<pre><code>(lldb) <b>run</b>&#13;
Process 6750 launched: '/Users/me/hello_debugger' (x86_64)&#13;
Process 6750 stopped&#13;
* thread #1, queue = 'com.apple.main-thread', <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> stop reason = breakpoint 1.1&#13;
    frame #0: 0x0000000100003f65 hello_debugger`main&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> hello_debugger`main:&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> -&gt;  0x100003f65 &lt;+0&gt;: pushq  %rbp&#13;
    0x100003f66 &lt;+1&gt;: movq   %rsp, %rbp&#13;
    0x100003f69 &lt;+4&gt;: subq   $0x10, %rsp&#13;
    0x100003f6d &lt;+8&gt;: callq  0x100003fb2               ; f&#13;
Target 0: (hello_debugger) stopped.&#13;
(lldb)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">stop reason</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> tells us that the program has hit the breakpoint we just set. LLDB also helpfully tells us that we’re stopped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and prints out the next few assembly instructions <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Once a program is paused, there are a few commands we can use to keep executing it:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp> resumes the program and runs until we hit another breakpoint or exit.</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">finish</samp> resumes the program and pauses again when we return from the current function.</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">stepi</samp> executes the next instruction, then pauses. It steps into <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions, pausing at the first instruction in the callee. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">stepi -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp> steps through <i>n</i> instructions.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">nexti</samp> executes the next instruction, then pauses. It steps over <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions, pausing at the next instruction after <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> in the current function. The command <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp> steps through <i>n</i> instructions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_689" aria-label="689"/>Most LLDB commands have several aliases. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> is a shortcut for <samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp>, and it can be shortened even further to the one-letter command <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. See <a href="#tabA-2">Table A-2</a> on <span class="Xref"><a href="#pg_697">page 697</a></span> for full and abbreviated versions of all the commands we cover.</p>&#13;
<p class="TX">Let’s try out these new commands. First, we’ll execute four instructions, which should take us into the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:</p>&#13;
<pre><code>(lldb) <b>stepi -c 4</b>&#13;
<var>--snip--</var>&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> hello_debugger`f:&#13;
-&gt;  0x100003fb2 &lt;+0&gt;: movl   $0x1, %eax&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">We can see from the command output that we’re stopped in <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Now we’ll return from <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:</p>&#13;
<pre><code>(lldb) <b>finish</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This puts us back in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>. Let’s continue:</p>&#13;
<pre><code>(lldb) <b>continue</b>&#13;
Process 6750 resuming&#13;
Process 6750 exited with status = 0 (0x00000000)</code></pre>&#13;
<p class="TX">Since we didn’t hit any more breakpoints, the program ran until it exited. To keep debugging it, we have to restart it:</p>&#13;
<pre><code>(lldb) <b>run</b></code></pre>&#13;
<p class="TX">Now we’re paused at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> again. Once again, we’ll move forward four instructions, but this time we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">nexti</samp> to step over <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> instead of stepping into it:</p>&#13;
<pre><code>(lldb) <b>nexti -c 4</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This puts us back at the instruction right after <samp class="SANS_TheSansMonoCd_W5Regular_11">callq</samp>.</p>&#13;
<section epub:type="division">&#13;
&#13;
<h4 class="H3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Breakpoints by Address</samp></h4>&#13;
<p class="TNI">In addition to setting breakpoints on functions, you can break on specific machine instructions. Let’s set a breakpoint on the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>. First, we need to find this instruction’s address. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_690" aria-label="690"/>Luckily, LLDB has already given us this information. The output from the last command should look something like this:</p>&#13;
<pre><code>hello_debugger`main:&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
    0x100003f77 &lt;+18&gt;: movsd  0x181(%rip), %xmm0        ; dbl, xmm0 = mem[0],zero&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x100003f7f <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> &lt;+26&gt;: movl   $0xdeadbeef, -0x4(%rbp)   ; imm = 0xDEADBEEF&#13;
    0x100003f86 &lt;+33&gt;: movl   $0x0, -0x8(%rbp)</code></pre>&#13;
<p class="TX">This shows the next few instructions, including the one we want to break on. We can see that instruction’s memory address <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the byte offset of that address from the start of the function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The exact address may be different on your machine, but the offset should be the same. To set this breakpoint, type</p>&#13;
<pre><code>(lldb) <b>break set -a </b><var><b>MEMORY_ADDRESS</b></var></code></pre>&#13;
<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MEMORY_ADDRESS</samp> is the instruction’s address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp> option indicates that we’re specifying an address rather than a function name. We can also use more complex expressions to specify instruction addresses. Here’s another way to set a breakpoint on the same instruction:</p>&#13;
<pre><code>(lldb) <b>break set -a '(void()) main + 26'</b></code></pre>&#13;
<p class="TX">First, we cast <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> to a function type so that LLDB can use it in address calculations. (It doesn’t matter which function type we cast it to.) Then, we add a 26-byte offset to get the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction we want to break on. Since this address expression includes spaces and special characters, we have to wrap the whole thing in quotes.</p>&#13;
<p class="TX">In a minute, we’ll see how to disassemble the whole function and see every instruction’s address. First, let’s look at a couple of other useful commands for managing breakpoints.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h4 class="H3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Managing Breakpoints</samp></h4>&#13;
<p class="TNI">Let’s list all the breakpoints we’ve set:</p>&#13;
<pre><code>(lldb) <b>break list</b>&#13;
Current breakpoints:&#13;
1: name = 'main', locations = 1, resolved = 1, hit count = 1&#13;
  1.1: where = hello_debugger`main, address = 0x0000000100003f65, resolved, hit count = 1&#13;
&#13;
2: address = hello_debugger[0x0000000100003f7f], locations = 1, resolved = 1, hit count = 0&#13;
  2.1: where = hello_debugger`main + 26, address = 0x0000000100003f7f, resolved, hit count = 0&#13;
&#13;
3: address = hello_debugger[0x0000000100003f7f], locations = 1, resolved = 1, hit count = 0&#13;
  3.1: where = hello_debugger`main + 26, address = 0x0000000100003f7f, resolved, hit count = 0</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_691" aria-label="691"/>Every breakpoint has a unique number, which you can refer to if you need to delete, disable, or modify it. In the last section, we set breakpoints 2 and 3 at the same location, <samp class="SANS_TheSansMonoCd_W5Regular_11">main+26</samp>. Let’s delete one of them:</p>&#13;
<pre><code> (lldb) <b>break delete 3</b></code></pre>&#13;
<p class="TX">Next, we’ll look at how to display all the assembly instructions in a function, along with their addresses.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-247"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Displaying Assembly Code</samp></h3>&#13;
<p class="TNI">The command <samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble -n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;function name&gt;</samp> tells LLDB to print out all the assembly instructions in a function. Let’s try this out on <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>:</p>&#13;
<pre><code>(lldb) <b>disassemble -n main</b>&#13;
hello_debugger`main:&#13;
    0x100003f65 &lt;+0&gt;:  pushq  %rbp&#13;
    0x100003f66 &lt;+1&gt;:  movq   %rsp, %rbp&#13;
    0x100003f69 &lt;+4&gt;:  subq   $0x10, %rsp&#13;
    0x100003f6d &lt;+8&gt;:  callq  0x100003fb2               ; f&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
    0x100003f77 &lt;+18&gt;: movsd  0x181(%rip), %xmm0        ; dbl, xmm0 = mem[0],zero&#13;
    0x100003f7f &lt;+26&gt;: movl   $0xdeadbeef, -0x4(%rbp)   ; imm = 0xDEADBEEF&#13;
    0x100003f86 &lt;+33&gt;: movl   $0x0, -0x8(%rbp)&#13;
    0x100003f8d &lt;+40&gt;: movl   $0xffffffff, -0xc(%rbp)   ; imm = 0xFFFFFFFF&#13;
    0x100003f94 &lt;+47&gt;: movl   $0xfeedface, -0x10(%rbp)  ; imm = 0xFEEDFACE&#13;
    0x100003f9b &lt;+54&gt;: movl   $0x19, %ecx&#13;
    0x100003fa0 &lt;+59&gt;: subl   $0x1, %ecx&#13;
    0x100003fa3 &lt;+62&gt;: cmpl   $0x0, %ecx&#13;
    0x100003fa6 &lt;+65&gt;: jne    0x100003fa0               ; &lt;+59&gt;&#13;
    0x100003fa8 &lt;+67&gt;: movl   $0x0, %eax&#13;
    0x100003fad &lt;+72&gt;: movq   %rbp, %rsp&#13;
    0x100003fb0 &lt;+75&gt;: popq   %rbp&#13;
    0x100003fb1 &lt;+76&gt;: retq&#13;
(lldb)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> symbol points to the current instruction. We can also print out a fixed number of instructions, starting at a specific address. Let’s disassemble five instructions, starting with the third instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. In the disassembled code shown here, this instruction’s address is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003f69</samp>; it might have a different address on your machine. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> option specifies the address where LLDB should start disassembling, and <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> specifies how many instructions to display, so we’ll disassemble these five instructions with the following command:</p>&#13;
<pre><code>(lldb) <b>disassemble -s 0x100003f69 -c 5</b>&#13;
hello_debug`main:&#13;
    0x100003f69 &lt;+4&gt;:  subq   $0x10, %rsp&#13;
    0x100003f6d &lt;+8&gt;:  callq  0x100003fb2               ; f&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
    0x100003f77 &lt;+18&gt;: movsd  0x181(%rip), %xmm0        ; dbl, xmm0 = mem[0],zero&#13;
    0x100003f7f &lt;+26&gt;: movl   $0xdeadbeef, -0x4(%rbp)   ; imm = 0xDEADBEEF</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_692" aria-label="692"/>Finally, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp> option to start disassembling at the current instruction:</p>&#13;
<pre><code>(lldb) <b>disassemble --pc -c 3</b>&#13;
-&gt;  0x100003f72 &lt;+13&gt;: movl   $0x87654321, %eax         ; imm = 0x87654321&#13;
    0x100003f77 &lt;+18&gt;: movsd  0x181(%rip), %xmm0        ; dbl, xmm0 = mem[0],zero&#13;
    0x100003f7f &lt;+26&gt;: movl   $0xdeadbeef, -0x4(%rbp)   ; imm = 0xDEADBEEF</code></pre>&#13;
<p class="TX">This command displays three instructions, starting with the current instruction. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> option when we specify a starting address with <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--pc</samp> but not when we disassemble a whole function with <samp class="SANS_TheSansMonoCd_W5Regular_11">-n</samp>.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-248"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Printing Expressions</samp></h3>&#13;
<p class="TNI">You can evaluate expressions with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">exp -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;expr&gt;</samp>, where:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;format&gt;</samp> is a format specifier that tells LLDB how to display the result of the expression.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;expr&gt;</samp> is an arbitrary expression. This expression can refer to registers, memory addresses, and symbols in the running program. It can also include C operations like arithmetic, pointer dereferencing, and cast expressions.</p>&#13;
<p class="TX">Let’s try some examples. Right now, the program should be paused at the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0x87654321, %eax</samp>. We’ll step through this instruction, then print out the value of EAX in a few different formats:</p>&#13;
<pre><code>(lldb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f77 &lt;+18&gt;: movsd  0x181(%rip), %xmm0        ; dbl, xmm0 = mem[0],zero&#13;
<var>--snip--</var>&#13;
(lldb) <b>exp -- $eax</b>&#13;
(unsigned int) $0 = <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 2271560481&#13;
(lldb) <b>exp -f x -- $eax</b>&#13;
(unsigned int) $1 = <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> 0x87654321&#13;
(lldb) <b>exp -f d -- $eax</b>&#13;
(unsigned int) $2 = <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> -2023406815</code></pre>&#13;
<p class="TX">By default, LLDB formats the values in general-purpose registers as unsigned integers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Here, we also display the value of EAX in hexadecimal <span class="CodeAnnotation" aria-label="annotation2">❷</span> and as a signed integer <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (For a full list of formats, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">help format</samp> command.) The symbols <samp class="SANS_TheSansMonoCd_W5Regular_11">$0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">$1</samp>, and so on are <i>convenience variables</i>, which LLDB automatically generates to store the result of each expression.</p>&#13;
<p class="TX"><span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span> introduces the XMM registers, which hold floating-point values. The next instruction in our program, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd dbl(%rip), %xmm0</samp>, copies the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3.5</samp> from the static <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp> variable into XMM0. Let’s step through this instruction, then inspect XMM0. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">float64[]</samp> format, which displays the register’s contents as an array of two doubles:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_693" aria-label="693"/>(lldb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f7f &lt;+26&gt;: movl   $0xdeadbeef, -0x4(%rbp)   ; imm = 0&#13;
<var>--snip--</var>&#13;
(lldb) <b>exp -f float64[] -- $xmm0</b>&#13;
(unsigned char __attribute__((ext_vector_type(16)))) $3 = ( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 3.5, 0)</code></pre>&#13;
<p class="TX">The first array element corresponds to the register’s lower 64 bits <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which we updated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction. The second element corresponds to the register’s upper 64 bits, which we can ignore.</p>&#13;
<p class="TX">In addition to registers, we can print out the values of objects in the symbol table. Let’s inspect the two static variables in this program, <samp class="SANS_TheSansMonoCd_W5Regular_11">integer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dbl</samp>:</p>&#13;
<pre><code>(lldb) <b>exp -f d -- integer</b>&#13;
(void *) $4 = 100&#13;
(lldb) <b>exp -f f -- dbl</b>&#13;
(void *) $5 = 3.5</code></pre>&#13;
<p class="TX">Now let’s look at a few examples of more complex expressions. We can perform basic arithmetic:</p>&#13;
<pre><code>(lldb) <b>exp -f x -- $eax + 0x10</b>&#13;
(unsigned int) $6 = 0x87654331</code></pre>&#13;
<p class="TX">We can call functions from the current program or the standard library. Here we call <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, which returns <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>:</p>&#13;
<pre><code>(lldb) <b>exp -- (int) f()</b>&#13;
(int) $7 = 1</code></pre>&#13;
<p class="TX">We can also dereference pointers. Let’s execute the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movl 0xdeadbeef, -4(%rbp)</samp>, then inspect the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:</p>&#13;
<pre><code>(lldb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f86 &lt;+33&gt;: movl   $0x0, -0x8(%rbp)&#13;
<var>--snip--</var>&#13;
(lldb) <b>exp -f x -- *(int *)($rbp - 4)</b>&#13;
(int) $8 = 0xdeadbeef</code></pre>&#13;
<p class="TX">First, we calculate the memory address we want to inspect, <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>. Then, we cast this address to the correct pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">(int *)</samp>. Finally, we dereference it with the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. This produces an integer, which we print out in hexadecimal with the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp>.</p>&#13;
<p class="TX">Next, we’ll look at a more flexible way to inspect values in memory.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_694" aria-label="694"/>&#13;
<h3 class="H2"><span id="h2-249"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining Memory</samp></h3>&#13;
<p class="TNI">We can examine memory with the <samp class="SANS_TheSansMonoCd_W5Regular_11">memory read</samp> command. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, it takes an arbitrary expression, which must evaluate to a valid memory address. This gives us another way to inspect the integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:</p>&#13;
<pre><code>(lldb) <b>memory read -f x -s 4 -c 1 '$rbp - 4'</b>&#13;
0x3040bb93c: 0xdeadbeef</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-f x</samp> option says to print the output in hexadecimal; <samp class="SANS_TheSansMonoCd_W5Regular_11">-s 4</samp> says to interpret the contents of memory as a sequence of 4-byte values; and <samp class="SANS_TheSansMonoCd_W5Regular_11">-c 1</samp> says to print just one of those values. In other words, this command prints out the single 4-byte integer at <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp>, formatted as hexadecimal. We have to wrap the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">$rbp - 4</samp> in quotes because it contains spaces.</p>&#13;
<p class="TX">The next three instructions in <a href="#listA-1">Listing A-1</a> store three more integers on the stack:</p>&#13;
<pre><code>    movl    $0, -8(%rbp)&#13;
    movl    $-1, -12(%rbp)&#13;
    movl    $0xfeedface, -16(%rbp)</code></pre>&#13;
<p class="TX">Let’s step through these instructions, then print out the whole stack frame. We’ll tell LLDB to print out six 4-byte words, starting at the address in RSP. We’ll use the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-l 1</samp> to print out each word on a separate line:</p>&#13;
<pre><code>(lldb) <b>stepi -c 3</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003f9b &lt;+54&gt;: movl   $0x19, %ecx&#13;
<var>--snip--</var>&#13;
(lldb) <b>memory read -f x -s 4 -c 6 -l 1 $rsp</b>&#13;
0x3040bb930: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0xfeedface&#13;
0x3040bb934: 0xffffffff&#13;
0x3040bb938: 0x00000000&#13;
0x3040bb93c: 0xdeadbeef&#13;
0x3040bb940: <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> 0x040bba50&#13;
0x3040bb944: 0x00000003</code></pre>&#13;
<p class="TX">We print out six words because the stack is 24 bytes in this particular function. At the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, we saved the old value of RBP onto the stack. That’s 8 bytes. Then, we allocated another 16 bytes with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $16, %rsp</samp>. Keep in mind that RSP always holds the address of the top of the stack, which is the <i>lowest</i> stack address.</p>&#13;
<p class="TX">This command shows us the four integers we saved to the stack, with <samp class="SANS_TheSansMonoCd_W5Regular_11">0xfeedface</samp> at the top <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the old value of RBP at the bottom <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Since the value at <span class="CodeAnnotation" aria-label="annotation2">❷</span> is really an 8-byte address, we can read it more easily if we group the stack into 8-byte values:</p>&#13;
<pre><code>(lldb) <b>memory read -f x -s 8 -c 3 -l 1 $rsp</b>&#13;
0x3040bb930: 0xfffffffffeedface&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_695" aria-label="695"/>0x3040bb938: 0xdeadbeef00000000&#13;
0x3040bb940: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x00000003040bba50</code></pre>&#13;
<p class="TX">Now it’s clear that the bottom 8 bytes on the stack hold a single memory address <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Just below the saved value of RBP, on top of the caller’s stack frame, we’d expect to find the caller’s return address—that is, the address we’ll jump to when we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. (We cover this in detail when we implement function calls in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>.) Let’s inspect this address:</p>&#13;
<pre><code>(lldb) <b>memory read -f A -s 8 -c 4 -l 1 $rsp</b>&#13;
0x3040bb930: 0xfffffffffeedface&#13;
0x3040bb938: 0xdeadbeef00000000&#13;
0x3040bb940: 0x00000003040bba50&#13;
0x3040bb948: <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x0000000200012310 dyld`start + 2432</code></pre>&#13;
<p class="TX">This command is almost identical to the previous one, except that we use the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-c 4</samp> to print out four values instead of three and the option <samp class="SANS_TheSansMonoCd_W5Regular_11">-f A</samp> to format each value as a memory address. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> format specifier tells LLDB to print each address in hexadecimal and, if possible, print out its offset from the nearest symbol in the program. Because function and static variable names are defined in the symbol table, LLDB can display the relative offsets of assembly instructions and static data. It won’t display relative offsets of stack addresses, heap addresses, or invalid addresses, because they would be completely meaningless.</p>&#13;
<p class="TX">The first three lines of output are the same as before. The first two values aren’t valid memory addresses and the third is a stack address, so LLDB can’t display their offsets from symbols. The next value on the stack is the return address <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The label <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld`start</samp> tells us this is the address of an instruction in the <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp> shared library. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> function is responsible for calling <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and cleaning up after it exits; <samp class="SANS_TheSansMonoCd_W5Regular_11">dyld</samp> is the dynamic linker.)</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-f A</samp> option makes it easy to spot return addresses and pointers to static variables. This is particularly useful if your program’s stack frame is corrupted; finding each stack frame’s return address can help you get your bearings.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
&#13;
<h3 class="H2"><span id="h2-250"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Conditional Breakpoints</samp></h3>&#13;
<p class="TNI">To wrap up this walk-through, we’ll look at how to set <i>conditional breakpoints</i>. The program will pause at a conditional breakpoint only if the associated condition is true. This condition can be an arbitrary expression; LLDB will consider it false if it evaluates to 0 and true otherwise.</p>&#13;
<p class="TX">Let’s set a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> instruction at the end of the last loop iteration in <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger</samp>. First, we’ll find this instruction’s address in the disassembled <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function:</p>&#13;
<pre><code>(lldb) <b>disassemble -n main</b>&#13;
hello_debugger`main:&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_696" aria-label="696"/><var>    --snip--</var>&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> 0x100003fa6 &lt;+65&gt;:  jne    0x100003fa0               ; &lt;+59&gt;&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="TX">Here, the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100003fa6</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Now we’ll set a conditional breakpoint to pause on the <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> instruction if ECX is 0. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> option to specify a condition:</p>&#13;
<pre><code>(lldb) <b>break set -a </b><var><b>MEMORY_ADDRESS</b></var><b> -c '$ecx == 0'</b></code></pre>&#13;
<p class="TX">Since this loop repeats until ECX is 0, the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will be true only on the last iteration. Let’s continue until the breakpoint, then verify that this condition is true:</p>&#13;
<pre><code>(lldb) <b>continue</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003fa6 &lt;+65&gt;:  jne    0x100003fa0               ; &lt;+59&gt;&#13;
<var>--snip--</var>&#13;
(lldb) <b>exp -- $ecx</b>&#13;
(unsigned int) $9 = 0</code></pre>&#13;
<p class="TX">If you get a different value for ECX, check whether you set the breakpoint correctly:</p>&#13;
<pre><code>(lldb) <b>break list</b>&#13;
<var>--snip--</var>&#13;
4: address = hello_debugger[0x0000000100003fa6], locations = 1, resolved = 1, hit count = 0&#13;
Condition: $ecx == 0 <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
  4.1: where = <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> hello_debugger`main + 65, address = 0x0000000100003fa6, resolved, hit count&#13;
 = 0</code></pre>&#13;
<p class="TX">Make sure that your breakpoint includes the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">$ecx</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and that it’s at the location <samp class="SANS_TheSansMonoCd_W5Regular_11">hello_debugger`main</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">65</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If your breakpoint looks different, you might have mistyped something; delete it and try again.</p>&#13;
<p class="TX">We should be on the last loop iteration, so let’s step forward one instruction and make sure that the jump isn’t taken:</p>&#13;
<pre><code>(lldb) <b>stepi</b>&#13;
<var>--snip--</var>&#13;
hello_debugger`main:&#13;
-&gt;  0x100003fa8 &lt;+67&gt;:  movl   $0x0, %eax&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Usually, <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> will jump back to the start of the loop, but on the last iteration it moves forward to the next instruction.</p>&#13;
</section>&#13;
<section epub:type="division">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_697" aria-label="697"/>&#13;
<h3 class="H2"><span id="h2-251"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Help</samp></h3>&#13;
<p class="TNI">To learn more about the commands and options we didn’t cover here, see the LLDB documentation at <i><a href="https://lldb.llvm.org/index.html">https://<wbr/>lldb<wbr/>.llvm<wbr/>.org<wbr/>/index<wbr/>.html</a></i>. You can also type <samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> at the prompt to learn more about any LLDB command. For example, to see the documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp> command, type:</p>&#13;
<pre><code>(lldb) <b>help run</b>&#13;
     Launch the executable in the debugger&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX"><a href="#tabA-2">Table A-2</a> summarizes the commands and options we covered. The version of each command that we used in the walk-through is listed first, followed by a shorter abbreviation (except for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, which isn’t normally shortened further), then the full form when it differs from the one we used. All versions of each command take the same arguments.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_698" aria-label="698"/>&#13;
<p class="TT" id="tabA-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table A-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">A Summary of LLDB Commands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Command</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">run</samp></p></td>&#13;
<td class="Basic-Table TBF graybg" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Start the program.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">process launch --</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Resume the program.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">process continue</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">finish</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Resume the program and continue until the current function exits.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fin</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-out</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">stepi [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Execute one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">instructions), stepping into function calls.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-inst</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">nexti [-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;n&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Execute one instruction (or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">n</samp> <samp class="SANS_Futura_Std_Book_11">instructions), stepping over function calls.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ni</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">thread step-inst-over</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">break set [-n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fun&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">| -a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a breakpoint at start of function</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fun&gt;</samp> <samp class="SANS_Futura_Std_Book_11">or at address</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp> <samp class="SANS_Futura_Std_Book_11">(conditional on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cond&gt;</samp><samp class="SANS_Futura_Std_Book_11">, if provided).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">br s</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">break list</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">List all breakpoints.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">br l</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint list</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">break delete [</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;id&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Delete all breakpoints (or the breakpoint specified by</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;id&gt;</samp><samp class="SANS_Futura_Std_Book_11">).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">br del</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">breakpoint delete</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">exp -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;expr&gt;</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Evaluate</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;expr&gt;</samp> <samp class="SANS_Futura_Std_Book_11">and display the result in format</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">expression</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">memory read -f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;size&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;num-per-line&gt; &lt;addr&gt;</samp></p></td>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Print out memory in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp> <samp class="SANS_Futura_Std_Book_11">chunks of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;size&gt;</samp> <samp class="SANS_Futura_Std_Book_11">bytes, starting at address</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp><samp class="SANS_Futura_Std_Book_11">. Display</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;num</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">-per-line&gt;</samp> <samp class="SANS_Futura_Std_Book_11">chunks on each line in format</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;format&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">me read</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">disassemble [-n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fun&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">| -s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">| --pc -c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp></p></td>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Disassemble all instructions in function</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fun&gt;</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp> <samp class="SANS_Futura_Std_Book_11">instructions starting at address</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;addr&gt;</samp><samp class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;count&gt;</samp> <samp class="SANS_Futura_Std_Book_11">instructions starting at the current instruction.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">di</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">help</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cmd&gt;</samp></p></td>&#13;
<td class="Basic-Table TBL" rowspan="2"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Display help text about</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;cmd&gt;</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Now you’re ready to start debugging with LLDB!</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>