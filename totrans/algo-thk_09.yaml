- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: UNION-FIND**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UNION-FIND**
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: We used the adjacency list data structure—and algorithms on it—to solve graph
    problems in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml). That’s an efficient
    data structure that works no matter the graph problem. However, if we constrain
    the types of problems we want to solve, we can design an even more efficient data
    structure. Constrain the problems just a little, and we likely wouldn’t be able
    to do any better than an adjacency list. Constrain them too much, and few people
    would use our data structure because it would be unlikely to solve problems that
    they cared about solving. Constrain the problems just right and you have the union-find
    data structure, the topic of this chapter. It solves graph problems—not all, only
    some. For the ones it does solve, though, it’s much faster than a general-purpose
    graph data structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 5 章](ch05.xhtml) 和 [第 6 章](ch06.xhtml) 中使用了邻接表数据结构及其算法来解决图的问题。这是一个高效的数据结构，无论是哪种图问题都能使用。然而，如果我们限制要解决的问题类型，我们可以设计出更高效的数据结构。限制问题的范围稍微一点，我们可能就无法做得比邻接表更好。限制得太多，几乎没人会使用我们的数据结构，因为它解决不了他们关心的问题。限制问题的范围恰到好处，你就得到了合并查找（union-find）数据结构，这是本章的主题。它解决图问题——并非所有问题，只有一些。对于它能够解决的问题，它的效率远高于通用图数据结构。
- en: Keeping track of communities in a social network, maintaining groups of friends
    and enemies, and organizing items into specified drawers are all graph problems.
    Importantly, they’re special graph problems, ones that can be solved with incredible
    speed by using union-find. Let’s do this!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪社交网络中的社区、维护朋友与敌人的群体、以及将物品组织到指定的抽屉中，都是图问题。重要的是，这些问题是特殊的图问题，可以通过使用合并查找方法以惊人的速度解决。让我们开始吧！
- en: 'Problem 1: Social Network'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：社交网络
- en: This is SPOJ problem `SOCNETC`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SPOJ 问题 `SOCNETC`。
- en: '*The Problem*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: You are asked to write a program that tracks the people and communities in a
    social network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求编写一个程序，跟踪社交网络中的人和社区。
- en: There are *n* people, numbered 1, 2, . . . , *n*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 *n* 个人，编号为 1, 2, …, *n*。
- en: A *community* is a person plus that person’s friends, their friends’ friends,
    their friends’ friends’ friends, and so on. For example, if Person 1 and Person
    4 are friends, and Person 4 and Person 5 are friends, then this community consists
    of the three people, 1, 4, and 5\. People in the same community are all friends
    with each other.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*社区* 是一个人加上这个人的朋友、朋友的朋友、朋友的朋友的朋友，以此类推。例如，如果人1和人4是朋友，而人4和人5是朋友，那么这个社区就包含这三个人：1、4和5。处于同一社区的人彼此之间都是朋友。'
- en: Each person starts in a community alone; the person’s community can get bigger
    as friendships between people are made.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人从一个孤立的社区开始；随着人与人之间友谊的建立，个人的社区可以逐渐扩大。
- en: 'Your program must support three operations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序必须支持三种操作：
- en: '**Add**   Make the two provided people be friends. If this operation takes
    place, and if these people were not in the same community before, then they will
    be in the same (larger) community now.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Add**   使得两个提供的人成为朋友。如果这个操作发生，并且这些人在此之前不在同一个社区，那么现在他们将属于同一个（更大的）社区。'
- en: '**Examine**   Report whether the two provided people are in the same community.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Examine**   报告两个提供的人是否在同一个社区。'
- en: '**Size**   Report the number of people who are in the provided person’s community.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size**   报告提供的某个人所在社区中的人数。'
- en: Your program will run on a computer with limited resources, so there is a parameter
    *m* that gives the maximum number of people in a community. We’re required to
    ignore any Add operation that would result in a community with more than *m* people.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序将在资源有限的计算机上运行，因此有一个参数 *m*，给出了社区中最多可容纳的人数。我们要求忽略任何会导致社区人数超过 *m* 的 Add 操作。
- en: Input
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing *n*, the number of people in the social network, and *m*,
    the maximum number of people allowed in a community. *n* and *m* are between 1
    and 100,000.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入一行，包含 *n*，表示社交网络中的人数，以及 *m*，表示一个社区允许的最大人数。*n* 和 *m* 的取值范围是 1 到 100,000 之间。
- en: A line containing integer *q*, the number of operations to follow. *q* is between
    1 and 200,000.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *q*，表示接下来操作的数量。*q* 的取值范围是 1 到 200,000 之间。
- en: '*q* lines, one for each operation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q* 行，每行对应一个操作。'
- en: 'Each of the *q* lines can be one of the following operations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行 *q* 可以是以下操作之一：
- en: An Add operation is of the form `A` x y, where x and y are people.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Add 操作的形式是 `A` x y，其中 x 和 y 是两个人。
- en: An Examine operation is of the form `E` x y, where x and y are people.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Examine操作的格式是`E` x y，其中x和y是两个人。
- en: A Size operation is of the form `S` x, where x is a person.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Size操作的格式是`S` x，其中x是一个人。
- en: '**Output**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Output**'
- en: There is no output for an Add operation. The output for each Examine and Size
    operation is on its own line.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Add操作没有输出。每个Examine和Size操作的输出会在其单独的一行显示。
- en: '**Examine**   For an Examine operation, output `Yes` if the two people are
    in the same community, and output `No` otherwise.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Examine** 对于Examine操作，如果两个人在同一个社区中，输出`Yes`，否则输出`No`。'
- en: '**Size**   For a Size operation, output the number of people in the person’s
    community.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size** 对于Size操作，输出该人所在社区的人数。'
- en: The time limit for solving the test case is one second.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该测试用例的时间限制为一秒。
- en: '*Modeling as a Graph*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*建模为图*'
- en: In [Chapters 5](ch05.xhtml) and [6](ch06.xhtml), we practiced at length framing
    problems as graph explorations. We figured out what to use as the nodes and what
    to use as the edges and then used BFS or Dijkstra’s algorithm to explore the graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml)和[第6章](ch06.xhtml)中，我们详细地练习了如何将问题框架转化为图的探索。我们弄清楚了该用什么作为节点，什么作为边，然后使用BFS或Dijkstra算法来探索图。
- en: We can similarly model a social network as a graph. The nodes are the people
    in the social network. If the test case tells us that *x* and *y* are friends,
    then we can add an edge between node *x* and node *y*. The graph is undirected,
    because friendship between two people is mutual.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将社交网络建模为图。节点代表社交网络中的人。如果测试用例告诉我们*x*和*y*是朋友，那么我们可以在节点*x*和节点*y*之间添加一条边。图是无向的，因为两个人之间的友谊是相互的。
- en: One key difference compared to the problems that we previously solved in [Chapters
    5](ch05.xhtml) and [6](ch06.xhtml) is that the social network graph is dynamic.
    Each time we process an Add operation between two people that are not yet friends,
    we add a new edge to the graph. Compare that to [Chapter 5](ch05.xhtml)’s Book
    Translation. There, we knew all of the languages and translators at the outset,
    so we could build the graph once and never have to update it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前在[第5章](ch05.xhtml)和[第6章](ch06.xhtml)中解决的问题相比，一个关键的区别是社交网络图是动态的。每次我们处理两个尚未成为朋友的人的Add操作时，都会向图中添加一条新边。与[第5章](ch05.xhtml)中的书籍翻译问题相比，这里我们最初就知道所有语言和翻译人员，因此可以一次性构建图并且不需要更新它。
- en: 'Let’s use a test case to animate how our graph grows and to observe how the
    graph helps us implement the three required operations (Add, Examine, and Size).
    Here it is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个测试用例来演示图的增长过程，并观察图如何帮助我们实现三个必需的操作（Add、Examine和Size）。如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We start with seven people and no friendship connections, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从七个人和没有任何友谊连接开始，如下所示：
- en: '![image](../images/unch09fig01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig01.jpg)'
- en: 'The `A 1 4` operation makes People 1 and 4 friends, so we add an edge between
    those two nodes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`A 1 4`操作使人员1和4成为朋友，因此我们在这两个节点之间添加了一条边：'
- en: '![image](../images/unch09fig02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig02.jpg)'
- en: 'The `A 4 5` operation does similarly for People 4 and 5:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`A 4 5`操作同样适用于人员4和5：'
- en: '![image](../images/unch09fig03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig03.jpg)'
- en: 'For `A 3 6`, we get:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`A 3 6`，我们得到：
- en: '![image](../images/unch09fig04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig04.jpg)'
- en: 'The next operation is `E 1 5`, which asks us whether People 1 and 5 are in
    the same community. The graph answers this for us: if there is a path from Node
    1 to Node 5 (or, equivalently, from Node 5 to Node 1), then they are in the same
    community; otherwise, they are not. In this case, they are; the path from Node
    1 to Node 4 to Node 5 is a path from Node 1 to Node 5.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步操作是`E 1 5`，它询问人员1和5是否在同一个社区。图会为我们回答这个问题：如果从节点1到节点5有路径（或者从节点5到节点1也可以），那么他们在同一个社区；否则，他们不在同一个社区。在这种情况下，他们在同一个社区；从节点1到节点4再到节点5的路径就是从节点1到节点5的路径。
- en: The next operation is `E 2 5`. There’s no path between Nodes 2 and 5, so these
    two people are not in the same community.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步操作是`E 2 5`。节点2和节点5之间没有路径，因此这两个人不在同一个社区中。
- en: 'Next we have `A 1 5`, which will add an edge between Nodes 1 and 5\. (Notice
    how we’re interleaving operations that modify the graph with operations that query
    the graph.) Here’s the result:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`A 1 5`，这将在节点1和节点5之间添加一条边。（注意我们如何交替进行修改图的操作和查询图的操作。）结果如下：
- en: '![image](../images/unch09fig05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig05.jpg)'
- en: The addition of this edge caused a cycle, because it added a friendship link
    between two people who were already in the same community. Therefore, this new
    edge doesn’t have any impact on the number of communities or their size. We could
    have left it out, but I’ve decided here to include all allowed friendship links.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这条边的增加导致了一个环，因为它在两个已经属于同一社区的人之间增加了一个友谊链接。因此，这条新边对社区的数量或大小没有任何影响。我们本可以省略它，但我决定在这里包含所有允许的友谊链接。
- en: 'Now consider `A 2 5`, which does unite two communities:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑`A 2 5`，它确实将两个社区合并：
- en: '![image](../images/unch09fig06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig06.jpg)'
- en: 'Next we have `A 4 3`, which again unites two communities:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`A 4 3`，它再次将两个社区合并：
- en: '![image](../images/unch09fig07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/unch09fig07.jpg)'
- en: 'Now we have our first Size operation: `S 4`. How many people are in Person
    4’s community? This amounts to determining the number of nodes reachable from
    Node 4\. There are six such nodes, with the only unreachable node being Node 7,
    so the answer is `6`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第一个Size操作：`S 4`。在人物4的社区中有多少人？这相当于确定从节点4可达的节点数。共有六个这样的节点，唯一不可达的节点是节点7，因此答案是`6`。
- en: Now, consider `A 7 6`. We must add the edge between Nodes 7 and 6 . . . whoa
    there! This edge would cause the formation of a new community with all seven people,
    but the test case forces an upper limit of six people in any given community.
    We must ignore this Add operation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑`A 7 6`。我们必须添加节点7和6之间的边……等等！这条边会导致形成一个包含所有七个人的新社区，但测试用例强制要求任何给定社区的最大人数为六人。我们必须忽略这个Add操作。
- en: 'For that reason, the answer to the final operation, `S 4`, is the same as it
    was before: `6`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后一个操作`S 4`的答案与之前相同：`6`。
- en: 'The correct output for our test case is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试用例的正确输出是：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example shows what is needed to implement each operation. For Add, we add
    a new edge to the graph, unless that edge would produce a community with too many
    people. For Examine, we determine whether there is a path between two nodes or,
    equivalently, whether one node is reachable from the other. We can use BFS for
    that! For Size, we determine the number of nodes reachable from a given node.
    We can use BFS again!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了实现每个操作所需的内容。对于Add，我们将一条新边添加到图中，除非这条边会导致一个社区里的人数过多。对于Examine，我们确定两个节点之间是否存在路径，或者等价地，是否一个节点可以从另一个节点到达。我们可以使用BFS来实现！对于Size，我们确定从给定节点可达的节点数。我们可以再次使用BFS！
- en: '*Solution 1: BFS*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案1：BFS*'
- en: Let’s take this graph-based solution in two steps. First, I’ll show the `main`
    function that processes the operations, progressively building the graph as it
    goes. Then, I’ll show the BFS code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分两步来看这个基于图的解决方案。首先，我将展示处理操作的`main`函数，随着操作的进行逐步构建图。然后，我将展示BFS代码。
- en: The main Function
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: 'We need a constant and a struct to begin:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个常量和一个结构体来开始：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `main` function is given in [Listing 9-1](ch09.xhtml#ch09ex01). It reads
    the input, and it responds to the operations by incrementally building and querying
    the graph.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数在[清单 9-1](ch09.xhtml#ch09ex01)中给出。它读取输入，并通过逐步构建和查询图来响应操作。'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-1: The* main *function for processing operations*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：* main *函数，用于处理操作*'
- en: As we did in Book Translation in [Chapter 5](ch05.xhtml) and in the problems
    in [Chapter 6](ch06.xhtml), we use an adjacency list representation of the graph.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ch05.xhtml)的书籍翻译中以及在[第6章](ch06.xhtml)中的问题中所做的那样，我们使用图的邻接表表示法。
- en: 'Let’s see how the code handles each of the three types of operations, starting
    with Add ❶. We call the helper function `find_distances` ➋. That function, as
    we’ll see shortly, implements the BFS: it fills `min_moves` with the shortest
    path in the graph from `person1` to each person, using a value of `-1` for any
    person that is not reachable. Then, we call helper function `size` ➌, which uses
    distance information in `min_moves` to determine the size of `person1`’s community.
    We next determine whether `person1` and `person2` are in the same community: if
    `person2` is reachable from `person1`, then they’re in the same community ➍. We
    need this information to determine whether to add the edge: if the people are
    already in the same community, then the edge can be safely added without worrying
    about creating a community that violates the constraint on the maximum number
    of people in a community.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码如何处理这三种操作类型，首先从添加操作（Add ❶）开始。我们调用辅助函数`find_distances` ➋。正如我们稍后会看到的，这个函数实现了广度优先搜索（BFS）：它填充`min_moves`，找出从`person1`到每个人的图中最短路径，对于任何不可达的人，使用`-1`表示。然后，我们调用辅助函数`size`
    ➌，它使用`min_moves`中的距离信息来确定`person1`所在社区的大小。接下来，我们确定`person1`和`person2`是否在同一社区：如果`person2`可以从`person1`到达，那么它们就在同一个社区
    ➍。我们需要这些信息来决定是否添加边：如果两个人已经在同一个社区，那么可以安全地添加这条边，而无需担心创建一个违反社区最大人数限制的社区。
- en: 'Having found the size of `person1`’s community, we do the same for `person2`’s
    community: first invoking BFS for `person2` ➎ and then computing the community’s
    size ➏.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`person1`的社区大小后，我们对`person2`的社区做相同的处理：首先对`person2`调用BFS ➎，然后计算该社区的大小 ➏。
- en: Now, if there’s no new community, or if the new community is small enough ❼,
    then we add the edge to the graph. Actually, we add two edges, because, remember,
    the graph is undirected.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果没有新的社区，或者新的社区足够小 ❼，那么我们将边添加到图中。实际上，我们添加两条边，因为请记住，图是无向的。
- en: The other operations take less code. For Examine ❽, we run the BFS and check
    whether `person2` is reachable from `person1`. For Size ❾, we run the BFS and
    then count the number of nodes reachable from `person1`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作的代码较少。对于检查操作（Examine ❽），我们运行BFS并检查`person2`是否可以从`person1`到达。对于大小操作（Size
    ❾），我们运行BFS，然后计算从`person1`可达的节点数。
- en: The BFS Code
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BFS代码
- en: The BFS code we need here is very similar to the BFS code we wrote when solving
    Book Translation in [Chapter 5](ch05.xhtml), except without the book translation
    costs. See [Listing 9-2](ch09.xhtml#ch09ex02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要的BFS代码与我们在[第5章](ch05.xhtml)中解决书籍翻译问题时编写的BFS代码非常相似，除了没有书籍翻译的费用。参见[清单 9-2](ch09.xhtml#ch09ex02)。
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-2: Minimum distance to people using BFS*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：使用BFS查找最短距离*'
- en: Finding the Size of a Community
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找社区的大小
- en: The last little helper function to write is `size`, which returns the number
    of people in a given person’s community. See [Listing 9-3](ch09.xhtml#ch09ex03).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要编写的辅助函数是`size`，它返回给定人所在社区的人数。参见[清单 9-3](ch09.xhtml#ch09ex03)。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-3: The size of a person’s community*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：一个人社区的大小*'
- en: In this function, it is assumed that `min_moves` has already been filled in
    by `find_distances`. Every person whose `min_moves` value is not `-1` is therefore
    reachable. We use `total` to add up those reachable people.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，假设`min_moves`已经由`find_distances`填充。每个`min_moves`值不是`-1`的人，因此都是可达的。我们使用`total`来累加这些可达的人。
- en: 'There we have it: a graph-based solution. For each of the *q* operations, we
    run one BFS. At worst, each operation adds one edge to the graph, so each BFS
    call does work proportional to at most *q*. We therefore have an *O*(*q*²), or
    quadratic, algorithm.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：一个基于图的解决方案。对于每个*q*操作，我们运行一次BFS。最坏情况下，每个操作都会向图中添加一条边，因此每次BFS调用的工作量最多为*q*。因此，我们有一个*O*(*q*²)的算法，即二次算法。
- en: 'In [Chapter 5](ch05.xhtml), I advised you that it’s important not to run BFS
    too many times. It’s best to make just one BFS call, if you can get away with
    that. Even a few calls can be okay. After all, we got away with making a BFS call
    for each pawn position when solving Knight Chase on [page 151](ch05.xhtml#lev32).
    The same sentiment applies to Dijkstra’s algorithm from [Chapter 6](ch06.xhtml):
    make as few calls as possible. Here again, making a few calls is okay. We solved
    Mice Maze on [page 198](ch06.xhtml#lev38) using about 100 calls of Dijkstra, and
    it was fast enough. Thriftless use of graph search hasn’t bitten us yet.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml)中，我建议你不要运行太多次BFS。最好如果能做到的话只调用一次BFS。即使是少数几次调用也可以。毕竟，在解决[第151页](ch05.xhtml#lev32)的骑士追击问题时，我们通过为每个棋子位置调用一次BFS来避免了重复。相同的想法适用于[第6章](ch06.xhtml)中的Dijkstra算法：尽量少调用。在这里，少数几次调用也是可以的。我们在[第198页](ch06.xhtml#lev38)上用约100次Dijkstra调用解决了老鼠迷宫问题，速度已经足够快。过度使用图搜索还没有让我们付出代价。
- en: It does bite us now, though. If you submit your solution to the judge, you’ll
    get a “Time-Limit Exceeded” error—and it isn’t even close. I’m playing around
    with an example here on my laptop with 100,000 people in the social network and
    200,000 operations. The operations are divided equally among Add, Examine, and
    Size operations. Our graph-based solution takes over two minutes to run. You’re
    about to learn a new data structure called union-find that, on the same example,
    runs 300 times faster. Union-find is an efficiency beast.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个问题现在确实让我们吃到了苦头。如果你将解决方案提交给评审，你会收到一个“超时限制”错误——而且甚至离超时还差得远。我正在我的笔记本上玩一个示例，社交网络中有100,000个人和200,000个操作。这些操作在添加（Add）、检查（Examine）和大小（Size）操作之间平均分配。我们的基于图的解决方案需要超过两分钟才能运行。你即将学习一种名为并查集（union-find）的新数据结构，在同一个示例上，它的运行速度快了300倍。并查集是一个效率怪兽。
- en: '*Union-Find*'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*并查集（Union-Find）*'
- en: For two reasons, BFS on a graph is not a satisfactory solution to the Social
    Network problem. First, it produces too much! It determines shortest paths between
    people. For example, it might tell us that the shortest path between People 1
    and 5 is two, but who cares? All we want to know is whether or not two people
    are in the same community. How they ended up in the same community and the chain
    of friendships that connect them are not of interest.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个原因，图上的广度优先搜索（BFS）并不是解决社交网络问题的一个理想方案。首先，它生成了太多！它会确定人之间的最短路径。例如，它可能会告诉我们，人1和人5之间的最短路径是2，但谁在乎呢？我们只想知道两个人是否在同一个社区里。它们是如何最终进入同一个社区的，以及连接它们的友谊链并不重要。
- en: 'Second, it remembers too little—or, rather, it remembers nothing: BFS starts
    afresh with each call. However, think about how wasteful this is. For example,
    an Add operation adds just one edge to the graph. The communities can’t be much
    different than they were before. BFS doesn’t use past information at all, instead
    reprocessing the complete graph on the next operation.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它记住的太少——或者说，它根本不记得：BFS在每次调用时都会从头开始。但是，想一想这有多浪费。例如，添加操作仅向图中添加一条边。社区不可能与之前有太大的不同。BFS根本不利用过去的信息，而是重新处理整个图，在下一个操作时从头开始。
- en: The goal, then, is to devise a data structure that doesn’t remember anything
    about shortest paths and that does only a little work when a new friendship is
    made.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是设计一个数据结构，它不记住任何关于最短路径的信息，并且在建立新友谊时只做一点点工作。
- en: Operations
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作
- en: The Add operation unites two communities into one. (Well, it does nothing when
    the resulting community would be too big or when two people are in the same community,
    but when it does something, it unites two communities.) This kind of operation
    is referred to in the algorithms world as a *Union*. In general, a Union replaces
    two sets by one larger set containing all of their elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 添加（Add）操作将两个社区合并为一个。（嗯，当合并后的社区过大或者两个人已经在同一个社区时，它什么都不做，但如果它有作用，它会将两个社区合并。）这种操作在算法世界中被称为*并集（Union）*。通常，*并集*通过一个更大的集合替代两个集合，包含它们的所有元素。
- en: The Examine operation tells us whether the two provided people are in the same
    community. One way to implement this is to designate one element of each community
    as its *representative* element. For example, a community with People 1, 4, and
    5 might have 4 as its representative; a community with People 3 and 6 might have
    3 as its representative. Are People 1 and 5 in the same community? Yes, because
    the representative of Person 1’s community (4) is the same as the representative
    of Person 5’s community (4). Are People 4 and 6 in the same community? No, because
    the representative of Person 4’s community (4) is not the same as the representative
    of Person 6’s community (3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 检查操作告诉我们两个提供的人是否在同一个社区。实现这一点的一种方法是指定每个社区的一个元素作为其*代表*元素。例如，一个包含人物1、4和5的社区可能将4作为其代表；一个包含人物3和6的社区可能将3作为其代表。人物1和5在同一个社区吗？是的，因为人物1所在社区的代表（4）与人物5所在社区的代表（4）相同。人物4和6在同一个社区吗？不是，因为人物4所在社区的代表（4）与人物6所在社区的代表（3）不同。
- en: 'Determining the representative of a person’s community is called a *Find*.
    We can implement Examine with two Finds: find the representative of the first
    person’s community, find the representative of the second person’s community,
    and compare them.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个人的社区代表被称为*查找（Find）*。我们可以通过两个查找来实现检查（Examine）：查找第一个人的社区代表，查找第二个人的社区代表，然后进行比较。
- en: Since an Add is a Union and an Examine is a Find, data structures that implement
    these two operations are known as *union-find* data structures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Add是合并操作，Examine是查找操作，因此实现这两种操作的数据结构被称为*并查集（union-find）*数据结构。
- en: Once we have Union and Find working, we’ll be in great shape to support Size
    operations as well. All we’ll do is store the size of each community, being sure
    to keep sizes up to date whenever we do a Union. We’ll then be able to respond
    to each Size operation by returning the size of the appropriate community.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了合并和查找操作，我们就能够很好地支持大小操作了。我们所做的就是存储每个社区的大小，并确保在进行合并时更新大小。然后，我们就可以通过返回相应社区的大小来响应每个大小操作。
- en: Array-Based Approach
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于数组的方法
- en: 'One idea is to use an array `community_of` that indicates the representative
    for each person’s community. For example, if People 1, 2, 4, and 5 are in the
    same community, People 3 and 6 are in the same community, and Person 7 is in their
    own community, then the array might look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思路是使用一个数组`community_of`，该数组表示每个人所属社区的代表。例如，如果人物1、2、4和5在同一个社区，人物3和6在同一个社区，人物7有自己的社区，那么数组可能是这样的：
- en: '![Image](../images/pg341-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg341-01.jpg)'
- en: For a community of a single person, there is no choice for who is the representative.
    That’s why the representative for Person 7 is 7\. In a community with multiple
    people, the representative is allowed to be any person in the community. For example,
    we’re using 6 as a representative this time, but we could have used 3 instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个只有一个人的社区，代表没有选择的余地。这就是为什么人物7的代表是7。对于一个有多人的社区，代表可以是社区中的任何人。例如，这次我们使用6作为代表，但我们也可以使用3。
- en: 'Using this scheme, we can implement Find in constant time. All we do is look
    up the representative of the desired person, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方案，我们可以在常数时间内实现查找操作。我们所做的就是查找目标人物的代表，如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can’t do better than that!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你做不到比这更好了！
- en: 'Unfortunately, this scheme breaks down when we implement Union. Our only option
    is to change all representatives for one community to the representative of the
    other community. It would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们实现合并操作时，这个方案就会失效。我们唯一的选择是将一个社区的所有代表换成另一个社区的代表。它看起来是这样的：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I’m ignoring the maximum size restriction on social-network communities here
    so as not to distract from the essentials. The code uses `find` to set `community1`
    and `community2` to the representatives of `person1`’s community and `person2`’s
    community, respectively. It then loops through all people, changing anyone in
    `community1` to `community2`. The effect is that `community1` is gone, having
    been absorbed into `community2`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里忽略了社交网络社区的最大大小限制，以避免分散注意力。代码使用`find`将`community1`和`community2`分别设置为`person1`和`person2`所在社区的代表。然后，它遍历所有人，将`community1`中的任何人更改为`community2`。其效果是`community1`被吸收到`community2`中，`community1`消失。
- en: If you build and submit a full solution based on the code I’ve given here, you
    should see that it still receives a “Time-Limit Exceeded” error. We need a better
    way to union two communities than looping through all of the people.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你基于我在这里给出的代码构建并提交了完整的解决方案，你应该会看到它仍然会出现“超时限制”错误。我们需要一种比遍历所有人员更好的方法来联合两个社区。
- en: Tree-Based Approach
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于树的方法
- en: The most efficient union-find data structures are based on trees. Each set is
    represented as its own tree, with the root of the tree serving as that set’s representative.
    I’ll describe how this works with the help of the example shown in [Figure 9-1](ch09.xhtml#ch09fig01).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最高效的联合查找数据结构是基于树的。每个集合表示为一棵树，树的根节点作为该集合的代表。我将通过[图 9-1](ch09.xhtml#ch09fig01)中的示例来描述这如何运作。
- en: '![image](../images/ch09fig01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig01.jpg)'
- en: '*Figure 9-1: A tree-based union-find data structure*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：基于树的联合查找数据结构*'
- en: 'There are three trees here, so there are three distinct communities: one has
    People 1, 2, 4, and 5; one has People 3 and 6; and one has Person 7\. Each tree’s
    roots—People 5, 6, and 7—serve as community representatives.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三棵树，因此有三个不同的社区：一个社区有人物 1、2、4 和 5；一个社区有人物 3 和 6；一个社区有人物 7。每棵树的根节点——人物 5、6
    和 7——作为社区的代表。
- en: I’ve drawn the tree edges with an arrow pointing from child to parent. You haven’t
    seen that before in this book. The reason I’m doing it now is to emphasize the
    way that we’ll be navigating these trees. As I describe how to support Find and
    Union in trees, we’ll see that it’s necessary to move up the tree (from child
    to parent) but never down.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我用箭头表示树的边，从子节点指向父节点。你之前在本书中没见过这种表示方式。现在这么做是为了强调我们在导航这些树时的方式。当我描述如何在树中支持查找（Find）和联合（Union）时，我们会看到有必要向上移动树（从子节点到父节点），而不是向下移动。
- en: 'Let’s start with Find. Given a person, we have to return that person’s representative.
    We can do that by moving up the appropriate tree until we reach its root element.
    For example, let’s find the representative of Person 1 in [Figure 9-1](ch09.xhtml#ch09fig01).
    Since 1 is not a root, we move to 1’s parent. Person 4 is not a root, so we move
    to 4’s parent. Person 5 is a root, so we’re done: 5 is the representative of 1.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查找（Find）开始。给定一个人，我们需要返回这个人的代表。我们可以通过向上移动适当的树结构，直到到达根节点。例如，让我们在[图 9-1](ch09.xhtml#ch09fig01)中找到人物
    1 的代表。由于 1 不是根节点，我们移动到 1 的父节点。人物 4 不是根节点，所以我们继续移动到 4 的父节点。人物 5 是根节点，所以我们结束了：5
    是 1 的代表。
- en: Compare this tree-hopping to what we were able to get away with in “Array-Based
    Approach” on [page 341](ch09.xhtml#ch09lev2z). Rather than simply looking up the
    representative in a single step, we have to move up the tree until we find the
    root. That sounds dicey—what if a tree gets really, really tall?—but we’ll soon
    see that this concern is unfounded, as we’ll be able to keep tree heights under
    control.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种“跳树”方法与我们在[第 341 页](ch09.xhtml#ch09lev2z)的“基于数组的方法”进行对比。在基于数组的方法中，我们只需一步查找代表，而在树结构中，我们必须向上移动树直到找到根节点。这听起来有些危险——如果树变得非常高怎么办？——但我们很快会看到这种担忧是多余的，因为我们能够控制树的高度。
- en: Now let’s talk about Union. Given two people, we want to unite their two trees.
    In terms of correctness, it doesn’t matter how we jam the two trees together.
    However, as was just mentioned in the context of Find, it helps to keep tree heights
    small. If we insert one tree at the bottom of the other, we might unnecessarily
    increase the height of the resulting tree. To avoid that, we’ll insert one tree
    directly under the root of the other tree. To see how that looks, see [Figure
    9-2](ch09.xhtml#ch09fig02), where I’ve unioned the tree with root 5 and the tree
    with root 6.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈联合（Union）。给定两个人，我们希望将他们的两棵树合并。从正确性的角度来看，如何将两棵树合并并不重要。然而，正如在查找的上下文中提到的，保持树的高度较小是有帮助的。如果我们将一棵树插入到另一棵树的底部，可能会不必要地增加合并树的高度。为了避免这种情况，我们将一棵树直接插入到另一棵树的根节点下。想要了解这种方式的效果，请参见[图
    9-2](ch09.xhtml#ch09fig02)，我已经将根节点为 5 的树与根节点为 6 的树进行了合并。
- en: '![image](../images/ch09fig02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig02.jpg)'
- en: '*Figure 9-2: A tree-based union-find data structure after a union*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：联合后基于树的联合查找数据结构*'
- en: 'I’ve chosen to make 6 the root of the combined tree. We could have also chosen
    to make 5 the root of the combined tree. (Here’s a teaser: Why will 5 turn out
    to be the better choice? We’ll see why when we discuss union-find optimizations.)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将 6 作为合并树的根节点。我们也可以选择将 5 作为合并树的根节点。（这里有个小提示：为什么 5 会是更好的选择？我们在讨论联合查找优化时会看到原因。）
- en: We now have enough to design a union-find solution to the Social Network problem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来设计解决社交网络问题的并查集方案。
- en: '*Solution 2: Union-Find*'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法2：并查集*'
- en: Primed by our discussion of heaps and segment trees in [Chapter 8](ch08.xhtml),
    you may not be surprised that we’re going to store the union-find data structure
    in an array!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml)讨论了堆和线段树之后，你可能不会惊讶我们将把并查集数据结构存储在一个数组中！
- en: Union-find trees are not necessarily binary trees, as their nodes can have any
    number of children. So we won’t be able to move around these trees by multiplying
    and dividing by 2, as we did in [Chapter 8](ch08.xhtml). We’re in luck, though,
    because the only travel we need to support is from a child to its parent. All
    we need is an array that maps from any given node to its parent. We can do that
    with the array `parent`, where `parent[i]` gives the parent of Node `i`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并查集树不一定是二叉树，因为它们的节点可以有任意数量的子节点。所以我们不能像在[第8章](ch08.xhtml)那样通过乘2或除2来移动这些树。但幸运的是，我们只需要支持从子节点到父节点的遍历。我们所需要的只是一个数组，它将任何给定的节点映射到它的父节点。我们可以使用`parent`数组来做到这一点，其中`parent[i]`给出节点`i`的父节点。
- en: 'Recall [Figure 9-1](ch09.xhtml#ch09fig01), where we had three communities:
    one that has People 1, 2, 4, and 5; one with People 3 and 6; and one with Person
    7\. Here’s the `parent` array corresponding to that figure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[图9-1](ch09.xhtml#ch09fig01)，我们有三个社区：一个包含人物1、2、4和5；一个包含人物3和6；另一个包含人物7。下面是与该图对应的`parent`数组：
- en: '![Image](../images/pg343-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg343-01.jpg)'
- en: What if we want to find the representative of Person 1’s community? The value
    at index 1 is 4, which tells us that 4 is the parent of 1; the value at index
    4 is 5, which tells us that the parent of 4 is 5; and the value at index 5 is
    5, which means that 5 is the . . . parent of 5? Certainly not! Whenever `parent[i]`
    is the same value as `i`, it means that we’ve reached the root of the tree. (The
    other common trick to distinguish roots is to use a value of `-1`, since that
    can’t be confused with a valid array index. I won’t use that in this book, but
    you may come across it in other code that you find.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找到人物1所在社区的代表，该怎么办呢？索引1的值是4，这告诉我们4是1的父节点；索引4的值是5，这告诉我们4的父节点是5；索引5的值是5，这意味着5是……5的父节点？当然不是！每当`parent[i]`的值与`i`相同，就意味着我们已经到达了树的根节点。（区分根节点的另一种常见技巧是使用`-1`，因为它不能与有效的数组索引混淆。虽然我在本书中不会使用它，但你可能会在你找到的其他代码中遇到它。）
- en: The main Function
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: Now we’re ready for some code. Let’s start with the `main` function as given
    in [Listing 9-4](ch09.xhtml#ch09ex04). (It’s far briefer than [Listing 9-1](ch09.xhtml#ch09ex01).
    In general, union-find code is compact.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好一些代码了。让我们从[清单9-4](ch09.xhtml#ch09ex04)中给出的`main`函数开始。（它比[清单9-1](ch09.xhtml#ch09ex01)简短得多。一般来说，并查集的代码比较简洁。）
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-4: The* main *function for processing operations*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-4：处理操作的* main *函数*'
- en: In addition to the `parent` array that I’ve already described, there’s a `size`
    array ❶. For each representative `i`, `size[i]` gives the number of people in
    its community. Never look up the size of a community using a nonrepresentative
    person. Once someone isn’t a representative, we won’t keep the `size` value updated
    anymore.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我已经描述过的`parent`数组外，还有一个`size`数组 ❶。对于每个代表节点`i`，`size[i]`表示该社区中的人数。切记不要使用非代表节点查询社区的大小。一旦某人不是代表节点，我们就不会再更新`size`值了。
- en: A `for` loop is used to initialize `parent` and `size` ➋. For `parent`, we let
    each person be their own representative, which corresponds to having each person
    in their own set. Because each set has just one person, we set each `size` value
    to `1`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环来初始化`parent`和`size` ➋。对于`parent`数组，我们让每个人都是自己的代表，这相当于让每个人都在自己的集合中。由于每个集合只有一个人，我们将每个`size`值设置为1。
- en: To implement Add, we call the `union_communities` helper function ➌. It unites
    the communities of `person1` and `person2`, subject to the `num_community` size
    constraint. We’ll see its code soon.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现Add，我们调用`union_communities`辅助函数 ➌。它将`person1`和`person2`的社区联合起来，前提是遵循`num_community`的大小约束。我们很快会看到它的代码。
- en: To implement Examine, we make two calls to `find` ➍. If both calls return the
    same value, then the people are in the same community; otherwise, they are not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现Examine，我们调用两次`find` ➍。如果两次调用返回相同的值，那么这些人属于同一个社区；否则，他们不属于同一个社区。
- en: Finally, to implement Size, we use the `size` array, looking up the representative
    of the person’s set ➎.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了实现Size，我们使用`size`数组，查找该人的集合代表 ➎。
- en: I’ll next supply implementations of `find` and `union_communities`, and that
    will finish off this implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将提供 `find` 和 `union_communities` 的实现，这将完成该实现。
- en: The find Function
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: find 函数
- en: The `find` function takes a person as a parameter and returns that person’s
    representative. See [Listing 9-5](ch09.xhtml#ch09ex05).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 函数以一个人作为参数，并返回该人的代表。请参阅 [清单 9-5](ch09.xhtml#ch09ex05)。'
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-5: The* find *function*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：* find *函数*'
- en: The `while` loop keeps moving up the tree, until it finds a root. That root
    person is the representative of the community, and so it is returned.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会不断向上遍历树，直到找到根节点。这个根节点代表了该社区，因此返回该根节点。'
- en: The union Function
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: union 函数
- en: The `union_communities` function takes two people—in addition to the `parent`
    array, `size` array, and `num_community` constraint—and joins their two communities.
    (I would have called this function `union`, but that’s not allowed because `union`
    is a C reserved word.) See [Listing 9-6](ch09.xhtml#ch09ex06) for the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`union_communities` 函数接收两个人，除了 `parent` 数组、`size` 数组和 `num_community` 限制之外，还将他们的两个社区合并。（我本来想将这个函数命名为
    `union`，但因为 `union` 是 C 语言的保留字，所以不允许这么命名。）请参阅 [清单 9-6](ch09.xhtml#ch09ex06) 了解代码。'
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-6: The* union_communities *function*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：* union_communities *函数*'
- en: 'First, we find the representative for each person’s community ❶ ➋. Two conditions
    must be met for a Union to take place: first, the communities must be different;
    second, the sum of the sizes of the two communities must not exceed the maximum-allowed
    community size. If both of these conditions pass, then we perform the Union itself.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为每个人的社区找到代表 ❶ ➋。并操作需要满足两个条件：首先，两个社区必须不同；其次，两个社区的大小之和不能超过最大允许的社区大小。如果这两个条件都满足，那么我们就执行并操作。
- en: I’ve chosen to fold `community1` into `community2`. That is, `community1` will
    be gone, and `community2` will absorb `community1`. To make this happen, we must
    appropriately modify `parent` and `size`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将 `community1` 合并到 `community2` 中。也就是说，`community1` 将消失，`community2` 将吸收
    `community1`。为了实现这一点，我们必须适当修改 `parent` 和 `size`。
- en: Before this Union, `community1` was the root of a community, but now we want
    `community1` to have `community2` as its parent. So, that’s precisely what we
    do ➌! Any person whose representative was previously `community1` will now have
    `community2` as their representative.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个并操作之前，`community1` 是一个社区的根节点，但现在我们希望 `community1` 以 `community2` 作为其父节点。所以，这正是我们要做的
    ➌！任何之前以 `community1` 为代表的人，现在将以 `community2` 为代表。
- en: In terms of `size`, `community2` has all of the people it had before plus all
    of the people that it inherited from `community1`. So the size is what it was
    before with the addition of the size of `community1` ➍.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `size` 方面，`community2` 拥有它之前所有的人，以及它从 `community1` 继承来的所有人。因此，大小是之前的大小加上 `community1`
    的大小 ➍。
- en: That’s all! Feel free to submit this solution to the judge. It should finish
    within the time limit and pass all test cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！请随意将这个解决方案提交给评测系统。它应该在时间限制内完成并通过所有测试用例。
- en: Somehow, though, I maybe had hoped that it didn’t pass within the time limit—because
    I’m sitting on two ace union-find optimizations here that I really want to teach
    you.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我也许原本希望它没有在时间限制内通过——因为我手上有两个高级的并查集优化，我真的很想教给你们。
- en: Hey, let’s just do them! This may be overkill for this problem, but they offer
    such a speed boost that we’ll apply them throughout this chapter and never worry
    about time limits again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，咱们就做这些吧！虽然对于这个问题可能有点过头，但它们能提供如此大的速度提升，所以我们会在本章中贯穿使用这些优化，再也不必担心时间限制了。
- en: '*Optimization 1: Union by Size*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*优化 1：按大小合并*'
- en: 'Our union-find solution generally runs fast, but test cases can be crafted
    to make it crawl. Here’s what the worst kind of test case looks like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的并查集解决方案通常运行得很快，但也可以设计出让它运行缓慢的测试用例。以下是最糟糕的测试用例：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Communities 1 and 2 are merged, that resulting community is merged with Community
    3, that resulting community is merged with Community 4, and so on. After the six
    Unions, we have the tree as depicted in [Figure 9-3](ch09.xhtml#ch09fig03).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 社区 1 和社区 2 合并后，得到的社区与社区 3 合并，得到的社区与社区 4 合并，依此类推。经过六次并操作后，我们得到如 [图 9-3](ch09.xhtml#ch09fig03)
    所示的树形结构。
- en: '![image](../images/ch09fig03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig03.jpg)'
- en: '*Figure 9-3: A bad case of a tree-based union-find data structure*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：基于树的并查集数据结构的一个糟糕案例*'
- en: We have a long chain of nodes and, unfortunately, Finds and Unions may end up
    traversing the entire chain. For example, `E 1 2` would invoke a Find on Person
    1 and a Find on Person 2, each visiting almost every node. Of course, a seven-node
    chain is tiny, but we can replicate the unioning pattern to produce massive chains
    of whatever length we want. We can thereby force Find and Union operations to
    take linear time; with *q* operations in all, we can force our tree-based union-find
    algorithm to take *O*(*q*²) time. This means that, in the worst case, the tree-based
    solution is not theoretically better than the BFS solution. It’s better than BFS
    in practice, because most test cases will not produce long chains of nodes . .
    . but some test cases might!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一条很长的节点链，遗憾的是，Find 和 Union 操作可能最终遍历整个链条。例如，`E 1 2`会对人物 1 和人物 2 执行 Find 操作，每次都几乎访问所有节点。当然，七个节点的链条很小，但我们可以复制合并模式，生成任意长度的巨大链条。这样，我们可以迫使
    Find 和 Union 操作变为线性时间；如果总共有 *q* 次操作，我们可以迫使基于树的并查集算法花费 *O*(*q*²) 的时间。这意味着，在最坏情况下，基于树的解决方案在理论上不比
    BFS 更好。它在实践中优于 BFS，因为大多数测试用例不会生成长链条的节点……但某些测试用例可能会！
- en: Hold on! Why are we letting these officious test cases bully us into producing
    these awful trees? We don’t care what the union-find data structure looks like.
    In particular, whenever a Union is requested, we have a choice of which old representative
    becomes the representative of the unioned community. Rather than always folding
    the first community into the second, we should make the choice that produces the
    best tree. Compare the nonsense in [Figure 9-3](ch09.xhtml#ch09fig03) to the wonder
    that is [Figure 9-4](ch09.xhtml#ch09fig04).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！为什么我们要让这些专横的测试用例逼迫我们生成这些糟糕的树结构？我们不关心并查集数据结构的外观。特别是，每当执行 Union 操作时，我们可以选择哪个旧的代表节点成为合并后的社区的代表。与其总是把第一个社区并入第二个社区，我们应该做出选择，生成最佳的树形结构。将[图
    9-3](ch09.xhtml#ch09fig03)的乱象与[图 9-4](ch09.xhtml#ch09fig04)的美妙效果做比较。
- en: '![image](../images/ch09fig04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig04.jpg)'
- en: '*Figure 9-4: An optimized tree-based union-find data structure*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：一种优化过的基于树的并查集数据结构*'
- en: Person 2 is the root, and everyone else is exactly one edge away. No matter
    what Union or Find comes next, we’ll be able to perform it very efficiently.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 人物 2 是根节点，其他所有人都只与它相差一条边。不管接下来执行的是 Union 还是 Find，我们都能非常高效地完成操作。
- en: How can our code make [Figure 9-4](ch09.xhtml#ch09fig04) instead of [Figure
    9-3](ch09.xhtml#ch09fig03)? The optimization is called *union by size*. Whenever
    you’re about to union two communities together, union the community with fewer
    people into the community with more people.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让我们的代码生成[图 9-4](ch09.xhtml#ch09fig04)而不是[图 9-3](ch09.xhtml#ch09fig03)呢？这种优化叫做*按大小合并*。每当你准备合并两个社区时，应该将人数较少的社区合并到人数较多的社区中。
- en: 'In the test case that we’ve been discussing, we start with `A 1 2`. The two
    communities each have one person, so it doesn’t matter which we choose to keep;
    let’s keep Community 2\. Now Community 2 has two people: the one that it had and
    the one from Community 1\. To do `A 2 3`, we compare the size of Community 2 (two)
    to the size of Community 3 (one). We will keep Community 2 because it is larger
    than Community 3\. Now Community 2 has three people. What about `A 3 4`? This
    gives us another person for Community 2\. We then keep going, absorbing one person
    after another into Community 2.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的测试用例中，我们从`A 1 2`开始。两个社区各有一个人，所以选择保留哪一个并不重要；我们选择保留社区 2。现在社区 2 有了两个人：它原本的成员和来自社区
    1 的成员。接下来执行`A 2 3`时，我们比较社区 2（大小为 2）与社区 3（大小为 1）。我们会保留社区 2，因为它比社区 3 大。现在社区 2 有了三个人。那么`A
    3 4`呢？这给社区 2 带来了一个新成员。我们继续进行操作，将一个又一个人并入社区 2。
- en: 'Union by size certainly neutralizes the worst test cases, but there are still
    test cases whose trees need some work to go from nodes to roots. Here’s one:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按大小合并确实可以中和最糟糕的测试用例，但仍然有一些测试用例的树结构需要进一步优化，从节点到根的路径还很长。比如：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Union by size produces [Figure 9-5](ch09.xhtml#ch09fig05).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按大小合并产生了[图 9-5](ch09.xhtml#ch09fig05)。
- en: '![image](../images/ch09fig05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig05.jpg)'
- en: '*Figure 9-5: A bad case of union by size*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：按大小合并的一个糟糕案例*'
- en: Although it’s true that some nodes are right below the root, there are now nodes
    that are further away (the worst offender being Node 1). Still, the tree is quite
    balanced, and it’s certainly better than the long chain of nodes that we saw prior
    to the union-by-size optimization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些节点确实位于根节点下方，但现在还有一些节点离根更远（最严重的就是节点 1）。不过，树形结构相当平衡，显然比我们在按大小合并优化之前看到的长链结构要好。
- en: I’ll next show that the maximum height of a tree when using union by size is
    *O*(log *n*), where *n* is the total number of people. This means that a Find
    or Union takes *O*(log *n*) time, because a Find is just a traversal up the tree
    and a Union is just two Finds plus a change of parent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将展示使用按大小合并时树的最大高度是*O*(log *n*)，其中*n*是总人数。这意味着Find或Union操作需要*O*(log *n*)的时间，因为Find只是沿树向上遍历，而Union只是执行两个Find操作并更改父节点。
- en: 'Let’s choose some arbitrary node *x* and think about how many times the number
    of edges between *x* and its root can increase. When *x*’s community absorbs another
    community, the number of edges between *x* and its root doesn’t change, because
    the root of its community is the same as it was. However, when *x*’s community
    is absorbed by another community, then the number of edges between *x* and its
    new root is one more than it was before: the path from *x* to its new root is
    what it was before (to get to its old root) plus one more edge to get to its new
    root.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择一个任意节点* x *，并思考* x *与其根节点之间的边数可以增加多少次。当* x *的社区吸收另一个社区时，* x *与其根节点之间的边数不变，因为它所在社区的根节点保持不变。然而，当*
    x *的社区被另一个社区吸收时，* x *和其新根节点之间的边数比之前多一个：从* x *到新根节点的路径，就是到旧根节点的路径加上一个额外的边，连接到新根节点。
- en: Therefore, putting an upper bound on the number of edges between *x* and its
    root amounts to determining the maximum number of times that *x*’s community can
    be absorbed into another community.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将* x *和它的根节点之间的边数设置上限，实际上就是确定* x *所属的社区被吸收到另一个社区的最大次数。
- en: Say that *x* is in a community of size four. Could it be absorbed into a community
    that was size two? No way! We’re using union by size, remember. The only way *x*’s
    community can be absorbed into another community is if the other community is
    at least as large as *x*’s. In this example, the other community would have to
    be size four or greater. So we go from a community of size four to a community
    of at least size 4 + 4 = 4 × 2 = 8\. That is, the size of *x*’s community at least
    doubles when it’s absorbed into another community.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设* x *所在的社区大小为四。它是否可以被一个大小为二的社区吸收？绝对不行！记住，我们正在使用按大小合并。* x *的社区只能被另一个至少和它一样大的社区吸收。在这个例子中，另一个社区的大小必须至少为四。所以，我们从一个大小为四的社区出发，最终进入一个至少大小为
    4 + 4 = 4 × 2 = 8 的社区。也就是说，当* x *的社区被吸收到另一个社区时，它的大小至少翻倍。
- en: Starting off in a community of size one, *x*’s community gets absorbed and now
    it’s in a community of at least size two. It gets absorbed again and now it’s
    in a community of at least size four. Getting absorbed again puts it in a community
    of at least size eight. This doubling can’t continue forever. It has to stop,
    at the latest, when *x*’s community contains all *n* people. Starting from one,
    how many times can we double it before we get to *n*? That’s log *n*, and that’s
    why the number of edges between any node and its root is capped at log *n*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个大小为一的社区开始，* x *的社区被吸收，现在它所在的社区至少有两个成员。它再次被吸收，现所在的社区至少有四个成员。再一次被吸收后，它所在的社区至少有八个成员。这种增长方式不能无限进行。它必须在*
    x *的社区包含所有* n *个人时停止。从1开始，我们最多能将其翻倍多少次，直到达到*n*？答案是log *n*，这也是为什么任何节点与其根节点之间的边数被限制为log
    *n*的原因。
- en: Using union by size cuts linear runtime to logarithmic runtime. Better still,
    we don’t need much new code to implement this optimization. In fact, for the Social
    Network problem, we’re already maintaining sizes of communities—we can just use
    these sizes to decide which community gets absorbed into the other. [Listing 9-7](ch09.xhtml#ch09ex07)
    gives the new code. Compare the code to [Listing 9-6](ch09.xhtml#ch09ex06) to
    confirm that we’re doing almost the same thing as before.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按大小合并可以将线性时间减少为对数时间。更好的是，我们不需要编写太多新代码来实现此优化。实际上，对于社交网络问题，我们已经在维护社区的大小——我们只需要利用这些大小来决定哪个社区被另一个社区吸收。[清单
    9-7](ch09.xhtml#ch09ex07)给出了新的代码。与[清单 9-6](ch09.xhtml#ch09ex06)对比，你会发现我们几乎做的和之前一样。
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-7: The* union_communities *function using union by size*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：* 使用按大小合并的*union_communities*函数'
- en: By default, the code chooses `community2` to absorb `community1`. This is the
    right thing to do if `community2` is larger than or the same size as `community1`.
    If the size of `community1` is larger than `community2` ❶, then we swap `community1`
    and `community2` to reverse their roles. After that, `community2` is guaranteed
    to be the bigger community, and we can proceed by absorbing `community1` into
    `community2` ➋.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，代码选择 `community2` 来吸收 `community1`。如果 `community2` 大于或等于 `community1`
    的大小，这是正确的做法。如果 `community1` 的大小大于 `community2` ❶，那么我们交换 `community1` 和 `community2`
    的位置，反转它们的角色。之后，`community2` 一定是更大的社区，我们可以继续将 `community1` 吸收进 `community2` ➋。
- en: '*Optimization 2: Path Compression*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*优化 2：路径压缩*'
- en: 'Let’s revisit the test case that produced [Figure 9-5](ch09.xhtml#ch09fig05).
    Only this time, let’s build the tree and then keep spamming the same Examine operation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下产生了[图 9-5](ch09.xhtml#ch09fig05)的测试案例。这一次，让我们构建树并持续执行相同的 Examine 操作：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `E 1 5` operation is a little slow, each time requiring lengthy traversals
    to the root. To Find the representative of Person 1, for example, we go from Node
    1 to Node 2 to Node 4 to Node 8\. Now we know that Node 1’s representative is
    Node 8\. We would do a similar traversal for Person 5, but that knowledge is short-lived,
    because we don’t remember that anywhere. Every single `E 1 5` operation causes
    us to redo the work to Find Person 1 and Person 5, just to relearn what we learned
    last time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`E 1 5` 操作有点慢，每次都需要进行长时间的根节点遍历。例如，为了查找人员 1 的代表，我们从节点 1 到节点 2，再到节点 4，最后到节点 8。现在我们知道节点
    1 的代表是节点 8。我们也会对人员 5 进行类似的遍历，但这种知识是短暂的，因为我们不会记住它。每一次 `E 1 5` 操作都需要我们重新执行查找人员 1
    和人员 5 的工作，重新学习上次学到的内容。'
- en: 'Here we have another opportunity to benefit by controlling the structure of
    the tree. Remember that the particular shape of the tree doesn’t matter: all that
    matters is that people in the same community are present in the same tree. Hence,
    as soon as we’ve determined the root of someone’s community, we might as well
    move that person to be a child of the root. While we’re at it, we might as well
    move that person’s ancestors right below the root, too.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们又有机会通过控制树的结构来获益。记住，树的具体形状并不重要：重要的是同一社区的人位于同一棵树中。因此，一旦我们确定了某人社区的根节点，我们就可以将此人移到根节点下作为子节点。与此同时，我们也可以将该人的祖先直接移到根节点下。
- en: Consider again [Figure 9-5](ch09.xhtml#ch09fig05), and suppose we next perform
    `E 1 5`. If we were using just the Union-by-size optimization, this Examine operation
    (like any Examine operation) would not change the structure of the tree. Watch
    what happens, though, if we use an optimization called *path compression*, as
    depicted in [Figure 9-6](ch09.xhtml#ch09fig06).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑[图 9-5](ch09.xhtml#ch09fig05)，假设我们接下来执行 `E 1 5`。如果我们仅使用按大小合并优化，那么这个 Examine
    操作（就像任何 Examine 操作一样）不会改变树的结构。然而，如果我们使用一种叫做 *路径压缩* 的优化，如[图 9-6](ch09.xhtml#ch09fig06)所示，看看会发生什么。
- en: '![image](../images/ch09fig06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig06.jpg)'
- en: '*Figure 9-6: An example of path compression*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：路径压缩示例*'
- en: This is nice, right? Finding Node 1 leads to Nodes 1 and 2 becoming children
    of a root; finding Node 5 leads to Node 5 becoming a child of a root. In general,
    path compression takes every node along a path and puts it as a child of the root
    node. Finding any of those nodes will therefore be extremely fast.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样很好，对吧？查找节点 1 会导致节点 1 和节点 2 成为根节点的子节点；查找节点 5 会导致节点 5 成为根节点的子节点。通常，路径压缩会将路径上的每个节点作为根节点的子节点。因此，查找这些节点的速度会非常快。
- en: To implement path compression in the `find` function, we can make two traversals
    from the provided person to the root of the tree. The first traversal locates
    the root of the tree; that’s the traversal that any `find` function does. The
    second traversal ensures that each node along the path has the root as its parent.
    [Listing 9-8](ch09.xhtml#ch09ex08) implements the new code. Compare it to [Listing
    9-5](ch09.xhtml#ch09ex05) to see that what’s new is the second traversal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `find` 函数中实现路径压缩，我们可以从提供的人员开始，进行两次遍历到达树的根节点。第一次遍历定位树的根节点；这是任何 `find` 函数都会执行的遍历。第二次遍历确保路径上的每个节点都将根节点作为其父节点。[列表
    9-8](ch09.xhtml#ch09ex08) 实现了新的代码。与[列表 9-5](ch09.xhtml#ch09ex05)比较，可以看到新增的是第二次遍历。
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-8: The* find *function with path compression implemented*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-8：带有路径压缩实现的* find *函数*'
- en: This code works in two phases. The first phase is the first `while` loop ❶,
    which results in `community` holding the representative (the root) of the community.
    With that representative in hand, the second phase, captured by the second `while`
    loop ➋, retraces the path from `person` to just below the root of the tree, updating
    each node’s `parent` to be the tree’s root. The `temp` variable is used to store
    the old parent of the current node. In that way, we can still move to the current
    node’s old parent even after making it the root of the tree. (There’s a shockingly
    concise though cryptic way to code path compression that you might see in the
    wild. Brace yourself, and then check out “Compressing Path Compression” in [Appendix
    B](app02.xhtml).)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码分为两个阶段。第一阶段是第一个 `while` 循环 ❶，它使得 `community` 保存了社区的代表（根节点）。有了这个代表，第二阶段由第二个
    `while` 循环 ➋ 捕捉，它会从 `person` 出发，追溯到树的根节点下方的路径，并更新每个节点的 `parent` 为树的根节点。`temp`
    变量用来存储当前节点的旧父节点。通过这种方式，即使将当前节点设为树的根节点，我们仍然可以继续访问它的旧父节点。（在实际中，你可能会看到一种惊人简洁但隐晦的路径压缩编码方法。做好心理准备，然后查看
    [附录 B](app02.xhtml) 中的“压缩路径压缩”部分。）
- en: By using both union by size and path compression, it’s still possible that a
    single Union or Find operation takes *O*(log *n*) time. However, taking all Unions
    and Finds together, the average time taken per operation—while not technically
    constant—is essentially constant. The runtime analysis is based on a function
    called the *inverse Ackermann function*, which grows very, very, *very* slowly.
    I won’t define the inverse Ackermann function or show how it arises in the runtime
    analysis, but I’d like to give a sense of how strong this result is.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过同时使用按大小合并和路径压缩，仍然有可能单次并查集的 Union 或 Find 操作需要 *O*(log *n*) 时间。然而，考虑到所有 Union
    和 Find 操作的平均时间——尽管从技术上讲并不是常数——实际上是常数。运行时分析基于一个叫做 *反阿克曼函数* 的函数，它增长得非常非常，*非常* 慢。我不会定义反阿克曼函数或展示它如何在运行时分析中出现，但我想让你了解这个结果有多强大。
- en: 'The logarithm function grows slowly, so let’s start there. Taking the log of
    a huge number gives back a very small number. For example, log 1,000,000,000 is
    only about 30\. However, the log isn’t a constant: using a sufficiently large
    value of *n*, you can make log *n* as big as you want.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对数函数增长很慢，所以我们从这开始。对一个巨大的数字取对数会得到一个非常小的数字。例如，log 1,000,000,000 只有大约 30。然而，对数并不是常数：通过使用足够大的
    *n* 值，你可以使 log *n* 变得和你想的一样大。
- en: The inverse Ackermann function is similarly not constant, but, unlike the log
    function, you’ll never in practice get a value of 30 out of it. You can make *n*
    as big as you want, as big as the biggest number representable in your computer,
    and the inverse Ackermann of *n* will be at most 4\. You can think of union-find
    with union by size and path compression as taking an average of just four steps
    per operation!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 反阿克曼函数也不是常数，但与对数函数不同，你在实际应用中永远不会从中得到 30 这个值。你可以将 *n* 变得和你想的一样大，甚至大到计算机中能表示的最大数字，而反阿克曼函数的值最多也只有
    4。你可以将带有按大小合并和路径压缩的并查集看作是每次操作平均只需要四步！
- en: Union-Find
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并查集
- en: The union-find data structure turbocharges solutions to graph problems whose
    primary operations are Union and Find. This doesn’t help with problems such as
    those in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml), where we’re required to
    calculate distances between nodes. But when union-find does apply, adjacency lists
    and graph search are overkill and just too slow.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 并查集数据结构加速了图论问题的解决，尤其是那些主要操作是 Union 和 Find 的问题。这对于诸如 [第 5 章](ch05.xhtml) 和 [第
    6 章](ch06.xhtml) 中的某些问题没有帮助，因为这些问题需要计算节点之间的距离。但是，当并查集适用时，邻接表和图搜索就显得过于复杂且速度太慢。
- en: '*Relationships: Three Requirements*'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*关系：三个要求*'
- en: Union-find works on a collection of objects, where each object begins in its
    own set. At all times, objects in the same set are equivalent, whatever “equivalent”
    means for the problem that we’re solving. For example, in the Social Network problem,
    people in the same set (community) are equivalent in the sense that they are all
    friends.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并查集操作的是一个对象集合，其中每个对象最开始属于自己的集合。在任何时候，属于同一集合的对象是等价的，无论“等价”在我们正在解决的问题中意味着什么。例如，在社交网络问题中，同一集合（社区）中的人是等价的，因为他们都是朋友。
- en: Union-find requires that the relationship between our objects satisfy three
    criteria. First, objects must be related to themselves. In terms of friendships
    from the Social Network, this just means that each person is one’s own friend.
    A relationship that meets this criterion is called *reflexive*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 并查集要求对象之间的关系满足三个标准。首先，对象必须与自己有关系。在社交网络中的友谊关系，这意味着每个人都是自己的朋友。符合这一标准的关系称为*自反关系*。
- en: 'Second, the relationship has to be directionless: we can’t have *x* as a friend
    of *y* and at the same time have *y* as not a friend of *x*. A relationship that
    meets this criterion is called *symmetric*.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，关系必须是无方向的：我们不能同时有*x*是*y*的朋友，并且*y*不是*x*的朋友。符合这一标准的关系称为*对称关系*。
- en: 'Third, the relationship must cascade: if *x* is a friend of *y*, and *y* is
    a friend of *z*, then *x* is a friend of *z*. A relationship that meets this criterion
    is called *transitive*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，关系必须是传递的：如果*x*是*y*的朋友，而*y*是*z*的朋友，那么*x*也应该是*z*的朋友。符合这一标准的关系称为*传递关系*。
- en: If any of these criteria is not met, then the Union operation we’ve been discussing
    is broken. For example, suppose that we have a friendship relationship where transitivity
    does not hold. If we learn that *x* is a friend of *y*, we have no idea whether
    *x*’s friends are *y*’s friends. We’re therefore not justified in uniting *x*’s
    community and *y*’s community; that might put people in the same set that are
    not in fact friends.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些标准中的任何一个不满足，那么我们所讨论的并查操作就会失效。例如，假设我们有一个不满足传递性的友谊关系。如果我们知道*x*是*y*的朋友，我们无法确定*x*的朋友是否是*y*的朋友。因此，我们不能将*x*的社交圈和*y*的社交圈合并；这可能会把不是朋友的人错误地放在同一个集合中。
- en: A relationship that is reflexive, symmetric, and transitive is called an *equivalence
    relation*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有自反性、对称性和传递性的关系称为*等价关系*。
- en: '*Choosing Union-Find*'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*选择并查集*'
- en: 'When deciding whether union-find might apply, ask yourself this: What is the
    relationship that I need to maintain between objects? Is it reflexive, symmetric,
    and transitive? If it is, and the primary operations can be mapped to Finds and
    Unions, then you should consider union-find as a viable solution strategy.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在判断是否可以应用并查集时，你需要问自己这个问题：我需要在对象之间保持什么样的关系？它是自反的、对称的、传递的吗？如果是，并且主要操作可以映射为查找和合并，那么你应该考虑将并查集作为一个可行的解决方案策略。
- en: Beneath every union-find problem lies a graph problem that could be modeled
    (less efficiently!) using adjacency lists and graph search. Unlike what we did
    for the Social Network problem, for the remaining problems in this chapter, we
    won’t take the scenic route through graphs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个并查集问题背后都有一个图论问题，可以通过邻接表和图搜索进行建模（虽然效率较低！）。与我们在社交网络问题中所做的不同，在本章剩下的题目中，我们不会通过图论的“风景路线”来解决问题。
- en: '*Optimizations*'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*优化*'
- en: 'I introduced two union-find optimizations: union by size and path compression.
    They offer protection against bad test cases and generally increase performance
    no matter what the test case. They each take only a few lines of code, so I recommend
    using them whenever you can.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我介绍了两种并查集优化：按大小合并和路径压缩。它们能有效防止糟糕的测试用例，并且通常无论测试用例如何，都能提升性能。它们每个只需要几行代码，因此我推荐在可能的情况下使用它们。
- en: “Whenever you can” is not to be confused with “always.” Unfortunately, there
    are some union-find problems where these optimizations are not appropriate. I
    haven’t yet encountered a problem where path compression is problematic, but sometimes
    we need to remember the order in which sets are being united, and in those cases
    we can’t swap roots of trees using union by size. You’ll see in Problem 3 an example
    where we can’t use union by size.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: “只要可能”并不等同于“总是”。不幸的是，有些并查集问题并不适合这些优化。我还没有遇到路径压缩会带来问题的情形，但有时我们需要记住集合合并的顺序，在这种情况下，我们不能通过按大小合并树的根节点。你将在问题
    3 中看到一个不能使用按大小合并的例子。
- en: 'Problem 2: Friends and Enemies'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 2：朋友与敌人
- en: 'You might worry that the only kind of “Add” operation we can support is like
    that used in the Social Network problem: *x* and *y* are friends; *x* and *y*
    go to the same school; *x* and *y* live in the same city—that kind of thing. It
    turns out that we can support other types of Add information, too. *x* and *y*
    are *not* friends. Hmm . . . that one’s interesting, telling us not that *x* and
    *y* are in the same set but that they are *not* in the same set. How does union-find
    work now? Read on!'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心我们支持的“添加”操作仅限于类似社交网络问题中的操作：*x* 和 *y* 是朋友；*x* 和 *y* 上同一所学校；*x* 和 *y* 住在同一座城市——之类的情况。事实上，我们也能支持其他类型的添加信息。*x*
    和 *y* 不是朋友。嗯……这个有点意思，它告诉我们 *x* 和 *y* 不在同一集合中，而不是他们是朋友。那么并查集现在如何工作呢？继续往下看！
- en: This is UVa problem `10158`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 UVa 问题 `10158`。
- en: '*The Problem*'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: Two countries are at war. You have been granted permission to attend their peace
    meetings, during which you can listen to pairs of people talking to each other.
    There are *n* people at these meetings, numbered 0, 1, . . . , *n* – 1\. At first,
    you don’t know anything about who are friends (citizens of the same country) or
    enemies (citizens of opposing countries). Your job is to record information about
    who are friends or enemies and to respond to queries based on what you know so
    far.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个国家正在交战。你已获准参加他们的和平会议，在会议期间，你可以听到一对对的人互相交谈。会议上有 *n* 个人，编号为 0, 1, . . . , *n*
    – 1。最开始，你对谁是朋友（同一国家的公民）或敌人（敌国的公民）一无所知。你的任务是记录有关谁是朋友或敌人的信息，并根据你目前掌握的情况回答查询。
- en: 'You must support four operations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须支持四个操作：
- en: '**SetFriends**   Record that the two provided people are friends.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**SetFriends** 记录提供的两个人是朋友。'
- en: '**SetEnemies**   Record that the two provided people are enemies.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**SetEnemies** 记录提供的两个人是敌人。'
- en: '**AreFriends**   Report whether you know for sure that the two provided people
    are friends.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**AreFriends** 报告你是否确定知道提供的两个人是朋友。'
- en: '**AreEnemies**   Report whether you know for sure that the two provided people
    are enemies.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**AreEnemies** 报告你是否确定知道提供的两个人是敌人。'
- en: 'Friendship is an equivalence relation: it’s reflexive (*x* is a friend of *x*),
    symmetric (if *x* is a friend of *y*, then *y* is a friend of *x*), and transitive
    (if *x* is a friend of *y* and *y* is a friend of *z*, then *x* is a friend of
    *z*).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 友谊是一个等价关系：它是自反的（*x* 是 *x* 的朋友），对称的（如果 *x* 是 *y* 的朋友，那么 *y* 是 *x* 的朋友），且是传递的（如果
    *x* 是 *y* 的朋友，且 *y* 是 *z* 的朋友，那么 *x* 也是 *z* 的朋友）。
- en: 'Enemyship is not an equivalence relation. It’s symmetric: if *x* is an enemy
    of *y*, then *y* is likewise an enemy of *x*. It’s neither, however, reflexive
    nor transitive.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 敌对关系不是等价关系。它是对称的：如果 *x* 是 *y* 的敌人，那么 *y* 也是 *x* 的敌人。然而，它既不是自反的，也不是传递的。
- en: 'There’s a little more we need to know about friendship and enemyship. Suppose
    that *x* has some friends and enemies, *y* has some friends and enemies, and then
    we are told that *x* and *y* are enemies. What have we learned? Well, we learn
    directly that *x* and *y* are enemies—but that’s not all. We can also conclude
    that *x*’s enemies are friends with everyone in *y*’s set. (Suppose that Alice
    and Bob are enemies and that David and Eve are friends—and then we are told that
    Alice and David are enemies. We should conclude that Bob is friends with David
    and Eve.) Similarly, we can conclude that *y*’s enemies are friends with everyone
    in *x*’s set. Here’s this paragraph in one aphorism: the enemy of an enemy is
    a friend.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于友谊和敌对关系，我们需要了解更多的内容。假设 *x* 有一些朋友和敌人，*y* 也有一些朋友和敌人，然后我们得知 *x* 和 *y* 是敌人。那么我们学到了什么？我们直接知道
    *x* 和 *y* 是敌人——但这还不是全部。我们还可以得出结论：*x* 的敌人和 *y* 的所有朋友都是朋友。（假设 Alice 和 Bob 是敌人，David
    和 Eve 是朋友——然后我们得知 Alice 和 David 是敌人。我们应该得出结论，Bob 和 David 以及 Eve 是朋友。）类似地，我们也可以得出结论，*y*
    的敌人和 *x* 的所有朋友都是朋友。用一句话来总结：敌人的敌人是朋友。
- en: Now suppose that *x* has some friends and enemies and that *y* has some friends
    and enemies—but that this time, we are told that *x* and *y* are friends. Here,
    we should additionally conclude that *x*’s enemies and *y*’s enemies are friends.
    (Hang in there. We’ll make all of this concrete as we work through some examples.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *x* 有一些朋友和敌人，*y* 也有一些朋友和敌人——但这次我们得知 *x* 和 *y* 是朋友。在这种情况下，我们还应该得出结论，*x*
    的敌人和 *y* 的敌人是朋友。（坚持一下，随着一些例子的展开，我们会将这一切具体化。）
- en: Input
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing *n*, the total number of people attending the meetings. *n*
    is less than 10,000.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，即参加会议的总人数。*n* 小于 10,000。
- en: Zero or more lines, one for each operation.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零行或多行，每行对应一个操作。
- en: A line containing three integers, the first of which is 0\. This signifies the
    end of the test case.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含三个整数，第一个是 0。这表示测试用例的结束。
- en: 'Each operation line has the same format: an operation code followed by two
    people (x and y).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每行操作具有相同的格式：一个操作码，后跟两个人（x 和 y）。
- en: A SetFriends operation is of the form `1` x y.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SetFriends 操作的形式是 `1` x y。
- en: A SetEnemies operation is of the form `2` x y.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SetEnemies 操作的形式是 `2` x y。
- en: An AreFriends operation is of the form `3` x y.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AreFriends 操作的形式是 `3` x y。
- en: An AreEnemies operation is of the form `4` x y.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AreEnemies 操作的形式是 `4` x y。
- en: Output
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: The output for each operation is on its own line.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作的输出位于其单独的一行。
- en: If a SetFriends operation succeeds, then it produces no output. If it conflicts
    with information that is already known, then output `-1` and ignore the operation.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 SetFriends 操作成功，则不会产生任何输出。如果与已知信息冲突，则输出 `-1` 并忽略该操作。
- en: If a SetEnemies operation succeeds, then it produces no output. If it conflicts
    with information that is already known, then output `-1` and ignore the operation.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 SetEnemies 操作成功，则不会产生任何输出。如果与已知信息冲突，则输出 `-1` 并忽略该操作。
- en: For an AreFriends operation, output `1` if the two people are known to be friends
    and output `0` otherwise.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 AreFriends 操作，如果两个人是已知的朋友，则输出 `1`，否则输出 `0`。
- en: For an AreEnemies operation, output `1` if the two people are known to be enemies
    and output `0` otherwise.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 AreEnemies 操作，如果两个人是已知的敌人，则输出 `1`，否则输出 `0`。
- en: The time limit for solving the test case is three seconds.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是三秒。
- en: '*Augmenting Union-Find*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*增强并查集*'
- en: If all we had to deal with were the SetFriends and AreFriends operations, then
    we could directly apply union-find as we did when solving the Social Network problem.
    We’d keep one set for each group of friends. Like Add in Social Network, SetFriends
    would be implemented as a Union and bring together two sets of friends into a
    larger set. Like Examine in Social Network, AreFriends would be implemented as
    a Find on each of the two people to determine whether they’re in the same set.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要处理 SetFriends 和 AreFriends 操作，那么我们可以直接应用并查集算法，就像在解决社交网络问题时那样。我们会为每一组朋友保留一个集合。像社交网络中的
    Add 操作，SetFriends 将作为一个 Union 操作，将两组朋友合并为一个更大的集合。像社交网络中的 Examine 操作，AreFriends
    将作为 Find 操作，用于确定两人是否在同一个集合中。
- en: We could start by solving the problem for just these two operations . . . actually,
    you know what? I’m confident you could solve that restricted problem, right now,
    without anything else from me. Where I may be helpful is in explaining the technique
    for incorporating SetEnemies and AreEnemies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从只解决这两个操作的问题开始……其实，你知道吗？我相信你现在就能在没有我任何其他帮助的情况下解决这个有限的问题。我能提供帮助的地方可能是解释如何将
    SetEnemies 和 AreEnemies 合并到问题中。
- en: 'Augmentation: Enemies'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 增强：敌人
- en: '*Augmenting* a data structure refers to storing additional information in that
    data structure to support new or faster operations. Maintaining the size of each
    set in a union-find data structure is an example of augmentation: you could implement
    the data structure without it, but with it you can quickly report set sizes and
    perform union by size.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*增强*数据结构是指在数据结构中存储额外信息，以支持新的或更快的操作。在并查集数据结构中维护每个集合的大小就是增强的一个例子：你可以在没有它的情况下实现数据结构，但有了它，你可以快速报告集合的大小并执行按大小合并操作。'
- en: You should consider augmentation when an existing data structure *almost* does
    what you want. The key is to identify a suitable augmentation that adds the desired
    functionality without appreciably slowing down other operations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当现有的数据结构*几乎*可以做你想做的事时，你应该考虑增强。关键是要识别一种合适的增强方式，能够添加所需的功能，同时不显著减慢其他操作的速度。
- en: We already have a union-find data structure that supports SetFriends and AreFriends.
    It maintains the parent of each node as well as the size of each set. We’re going
    to augment that data structure to support SetEnemies and AreEnemies. Moreover,
    we’re going to do it without slowing down Set-Friends and AreFriends much at all.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个支持 SetFriends 和 AreFriends 的并查集数据结构。它维护每个节点的父节点以及每个集合的大小。我们将增强这个数据结构，以支持
    SetEnemies 和 AreEnemies。更重要的是，我们将做到这一点，而不会显著减慢 SetFriends 和 AreFriends 操作的速度。
- en: Suppose we’re told that *x* and *y* are enemies. From the problem description,
    we know that we’re going to have to union *x*’s enemies with *y*’s set and union
    *y*’s enemies with *x*’s set. Who are *x*’s enemies? Who are *y*’s enemies? With
    the standard union-find data structure, we don’t know. This is why we need to
    augment the union-find data structure.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被告知 *x* 和 *y* 是敌人。从问题描述中，我们知道我们必须将 *x* 的敌人集合与 *y* 的集合合并，并将 *y* 的敌人集合与 *x*
    的集合合并。那么，*x* 的敌人是谁？*y* 的敌人又是谁？使用标准的并查集数据结构，我们并不知道。这就是为什么我们需要扩展并查集数据结构的原因。
- en: In addition to the parent of each node and the size of each set, we’re going
    to keep track of an enemy for each set. We’ll store those enemies in an array
    called `enemy_of`. Suppose that `s` is the representative of some set. If that
    set has no enemies, then we’ll arrange for `enemy_of[s]` to hold a special value
    that can’t be confused with a person. If that set has one or more enemies, then
    `enemy_of[s]` will give us one of them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了每个节点的父节点和每个集合的大小外，我们还将跟踪每个集合的敌人。我们将这些敌人存储在一个名为 `enemy_of` 的数组中。假设 `s` 是某个集合的代表。如果该集合没有敌人，则我们将确保
    `enemy_of[s]` 存储一个无法与人混淆的特殊值。如果该集合有一个或多个敌人，则 `enemy_of[s]` 将告诉我们其中一个敌人。
- en: 'That’s right: *one* of them, not *all* of them. Knowing one enemy of each set
    is enough, because we can use that one enemy to find the representative of everyone
    in that enemy’s set.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对的：是其中的*一个*，而不是*所有*。只知道每个集合中的一个敌人就足够了，因为我们可以利用这个敌人来找到该敌人集合中每个人的代表。
- en: Let’s now work through two test cases. They’ll prepare us for the implementation
    that follows. The diagrams I will show are conceptual and do not correspond exactly
    to what an implementation might do. In particular, I won’t use union by size or
    path compression in the diagrams, but we’ll throw those optimizations into our
    implementation in the interest of performance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解决两个测试用例。它们将为接下来的实现做准备。我展示的图示是概念性的，并不完全对应于实现的具体做法。特别地，我在图示中不会使用按大小合并或路径压缩，但我们将在实现中加入这些优化以提高性能。
- en: Test Case 1
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例 1
- en: Recall that the operation code for SetFriends is `1` and the code for SetEnemies
    is `2`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，SetFriends 操作的代码是 `1`，SetEnemies 操作的代码是 `2`。
- en: 'Here’s our first test case:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个测试用例：
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first four operations are SetFriends operations. No one has any enemies
    yet, so these operations play out just as did Add operations in the Social Network
    problem. [Figure 9-7](ch09.xhtml#ch09fig07) shows the state of the data structure
    after these operations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个操作是 SetFriends 操作。由于没有人有敌人，这些操作就像社交网络问题中的 Add 操作一样执行。[图 9-7](ch09.xhtml#ch09fig07)
    显示了这些操作后的数据结构状态。
- en: '![image](../images/ch09fig07.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig07.jpg)'
- en: '*Figure 9-7: The data structure after four SetFriends operations*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：四次 SetFriends 操作后的数据结构*'
- en: 'Next we have our first SetEnemies operation ❶, and it indicates that People
    1 and 7 are enemies. This means that everyone in 1’s set is enemies with everyone
    in 7’s set. To incorporate this into the data structure, we add links between
    roots of these two sets: a link from 2 (the root of 1’s set) to 7, and a link
    from 7 (the root of 7’s set) to 1\. (You could have decided that the latter should
    instead be a link from 7 to 2; that would be fine as well.) The result of this
    operation is shown in [Figure 9-8](ch09.xhtml#ch09fig08). In this and subsequent
    figures, enemy links are realized as dashed lines; in our implementation, enemy
    links will be realized as the aforementioned `enemy_of` array.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们第一次的 SetEnemies 操作 ❶，它表示人物 1 和 7 是敌人。这意味着 1 的集合中的每个人都是 7 的集合中每个人的敌人。为了将此操作纳入数据结构，我们在这两个集合的根之间添加了连接：从
    2（1 的集合的根）到 7 的连接，以及从 7（7 的集合的根）到 1 的连接。（你也可以决定后者应该是从 7 到 2 的连接；这也是可以的。）此操作的结果见
    [图 9-8](ch09.xhtml#ch09fig08)。在本图及随后的图中，敌人连接以虚线表示；在我们的实现中，敌人连接将通过上述的 `enemy_of`
    数组来实现。
- en: '![image](../images/ch09fig08.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig08.jpg)'
- en: '*Figure 9-8: The data structure after a SetEnemies operation*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：SetEnemies 操作后的数据结构*'
- en: Next is a SetEnemies operation between People 5 and 8 ➋; performing this operation
    might result in [Figure 9-9](ch09.xhtml#ch09fig09).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是人物 5 和 8 之间的 SetEnemies 操作 ➋；执行此操作可能会得到 [图 9-9](ch09.xhtml#ch09fig09)。
- en: '![image](../images/ch09fig09.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig09.jpg)'
- en: '*Figure 9-9: The data structure after another SetEnemies operation*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：另一轮 SetEnemies 操作后的数据结构*'
- en: Now it’s time for the final operation ➌, which says that People 2 and 5 are
    friends. This unites 2’s set and 5’s set into one larger set of friends, as expected.
    The surprise, perhaps, is that we also unite two enemy sets. Specifically, we
    unite the enemies of Person 2’s set with the enemies of Person 5’s set. After
    all, if we know that two people are in the same country, then each of their enemy
    sets must be together in the other country. The result of performing these *two*
    Union operations is shown in [Figure 9-10](ch09.xhtml#ch09fig010).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行最终操作 ➌ 的时候了，这个操作表明人物 2 和人物 5 是朋友。这样，人物 2 的集合和人物 5 的集合就合并成了一个更大的朋友集合，正如预期的那样。或许令人惊讶的是，我们还合并了两个敌人集合。具体来说，我们将人物
    2 的敌人集合与人物 5 的敌人集合合并。毕竟，如果我们知道两个人在同一个国家，那么他们各自的敌人集合必定在另一个国家合并。执行这*两个* Union 操作后的结果如[图
    9-10](ch09.xhtml#ch09fig010)所示。
- en: '![image](../images/ch09fig10.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig10.jpg)'
- en: '*Figure 9-10: The data structure after a final SetFriends operation*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-10：最终执行 SetFriends 操作后的数据结构*'
- en: The reason I haven’t drawn enemy links from Person 2 to Person 7 and from Person
    7 to Person 1 is because we maintain enemy links only from root nodes. Once a
    node is no longer a root, we’ll never use it again to find enemies.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有从人物 2 到人物 7 和从人物 7 到人物 1 画出敌人链接，是因为我们仅在根节点之间维护敌人链接。一旦一个节点不再是根节点，我们就再也不会用它来寻找敌人。
- en: 'Two key things can be learned from this test case: that one enemy of a set
    is stored at that set’s root and that a SetFriends operation requires two Unions,
    not one. Now, what do we do when a set already has an enemy and then that set
    is involved in a SetEnemies operation? That’s where our next test case comes in.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个测试用例中可以学到两个关键点：一个集合的敌人存储在该集合的根节点上，且一个 SetFriends 操作需要执行两个 Union 操作，而不是一个。那么，当一个集合已经有敌人，并且该集合参与
    SetEnemies 操作时，我们该怎么做呢？这就是我们下一个测试用例的内容。
- en: Test Case 2
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例 2
- en: 'Our second test case differs from the first only in its final operation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试用例与第一个的不同之处仅在于其最终操作：
- en: '[PRE17]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Prior to the final operation, the data structure appears as depicted in [Figure
    9-9](ch09.xhtml#ch09fig09). The final operation ❶ is now a SetEnemies operation
    rather than a SetFriends operation. Person 2’s set already has an enemy, and now
    it has new enemies from Person 5’s set. Hence we need to unite Person 2’s enemies
    with Person 5’s set. Similarly, Person 5’s set already has an enemy and now has
    new enemies from Person 2’s set, so we need to unite Person 5’s enemies with Person
    2’s set.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终操作之前，数据结构如[图 9-9](ch09.xhtml#ch09fig09)所示。最终操作 ❶ 现在是 SetEnemies 操作，而不是 SetFriends
    操作。人物 2 的集合已经有一个敌人，现在它从人物 5 的集合中获得了新的敌人。因此，我们需要将人物 2 的敌人集合与人物 5 的集合合并。同样，人物 5
    的集合已经有敌人，现在又从人物 2 的集合中获得了新的敌人，所以我们需要将人物 5 的敌人集合与人物 2 的集合合并。
- en: The result of these two Unions is shown in [Figure 9-11](ch09.xhtml#ch09fig011).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 Union 操作的结果如[图 9-11](ch09.xhtml#ch09fig011)所示。
- en: '![image](../images/ch09fig11.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig11.jpg)'
- en: '*Figure 9-11: The data structure after a final SetEnemies operation*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：最终执行 SetEnemies 操作后的数据结构*'
- en: Having laid this background, we’re ready for an implementation!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这个背景后，我们准备好进行实现了！
- en: '*The main Function*'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*主要功能*'
- en: Let’s start with the `main` function, which is given in [Listing 9-9](ch09.xhtml#ch09ex09).
    It reads the input, and it calls one helper function for each of the four operations
    that we’re supporting.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `main` 函数开始，它在[列表 9-9](ch09.xhtml#ch09ex09)中给出。它读取输入，并为我们支持的四个操作调用一个辅助函数。
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 9-9: The* main *function for processing operations*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：处理操作的* 主要 *功能*'
- en: Notice that, as part of the initialization, we set each `enemy_of` value to
    `-1` ❶. That’s our special value to indicate “no enemy.”
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，作为初始化的一部分，我们将每个 `enemy_of` 值设置为 `-1` ❶。这是我们用来表示“没有敌人”的特殊值。
- en: To implement SetFriends ➋, we first check whether the two people are already
    known to be enemies. If they are, we output `-1`; if they aren’t, we call the
    `set_friends` helper function. The implementation of SetEnemies ➌ follows the
    same pattern. For AreFriends ➍ and AreEnemies ➎, we call a helper function to
    determine whether the condition is true or false, and we output `1` or `0` accordingly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 SetFriends ➋，我们首先检查这两个人是否已经是敌人。如果是，我们输出 `-1`；如果不是，我们调用 `set_friends` 辅助函数。SetEnemies
    ➌ 的实现遵循相同的模式。对于 AreFriends ➍ 和 AreEnemies ➎，我们调用一个辅助函数来确定条件是否为真，并相应地输出 `1` 或 `0`。
- en: '*Find and Union*'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*查找与合并*'
- en: I’ll present the Find and Union functions here; they’ll be called by our helper
    functions, `set_friends`, `set_enemies`, `are_friends`, and `are_enemies`. The
    Find function is given in [Listing 9-10](ch09.xhtml#ch09ex010). We’ve got path
    compression in there!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里介绍 Find 和 Union 函数；它们将由我们的辅助函数 `set_friends`、`set_enemies`、`are_friends`
    和 `are_enemies` 调用。Find 函数在[列表 9-10](ch09.xhtml#ch09ex010)中给出。我们已经在其中实现了路径压缩！
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-10: The* find *function*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10：* find *函数*'
- en: 'The Union function is given in [Listing 9-11](ch09.xhtml#ch09ex011). Union
    by size: you better believe it!'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Union 函数在 [列表 9-11](ch09.xhtml#ch09ex011) 中给出。按大小联合：你最好相信它！
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 9-11: The* union_sets *function*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-11：* union_sets *函数*'
- en: 'The Union function does have one feature not present in our prior Union code:
    it returns the representative of the resulting set ❶. We’ll turn to the SetFriends
    operation next, and you’ll see there that we use this return value.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Union 函数有一个在我们之前的 Union 代码中没有的特性：它返回结果集的代表元素 ❶。接下来我们将讨论 SetFriends 操作，您会看到我们在其中使用了这个返回值。
- en: '*SetFriends and SetEnemies*'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*SetFriends 和 SetEnemies*'
- en: The SetFriends operation is implemented in [Listing 9-12](ch09.xhtml#ch09ex012).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: SetFriends 操作在 [列表 9-12](ch09.xhtml#ch09ex012) 中实现。
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-12: Recording that two people are friends*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-12：记录两个人是朋友*'
- en: 'We begin by determining the representative of each of the two people: `set1`
    is the representative of `person1` ❶ and `set2` is the representative of `person2`
    ➋. Since these two sets of people are now supposed to be all friends with each
    other, we unite them into a bigger set ➌. We store the return value of `union_sets`
    in `bigger_set`; we’ll use that soon.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定每个人的代表元素：`set1` 是 `person1` 的代表 ❶，`set2` 是 `person2` 的代表 ➋。由于这两组人现在应该彼此成为朋友，因此我们将它们合并成一个更大的集合
    ➌。我们将 `union_sets` 的返回值存储在 `bigger_set` 中；我们很快会用到它。
- en: 'We’ve now unioned `person1`’s set and `person2`’s set, but we’re not done,
    because—remember this from our first test case—we might have to union some enemies
    together as well. Specifically, if `set1` has enemies and `set2` has enemies,
    then we need to union those enemies into a single, bigger set. That’s just what
    the code does: if both sets have enemies ➍, we union those enemy sets ➎.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `person1` 的集合和 `person2` 的集合联合起来，但这还没有完成，因为——记得我们第一次测试时说的——我们可能还需要将一些敌人联合在一起。具体来说，如果
    `set1` 有敌人，而 `set2` 也有敌人，那么我们需要将这些敌人联合成一个更大的集合。这正是代码的功能：如果两个集合都有敌人 ➍，我们将这些敌人集合
    ➎ 联合起来。
- en: It’s tempting to think that we’re done at this point. We’ve performed the required
    union of friends and union of enemies—what else is there to do? Well, imagine
    that `set1` has some enemies and that `set2` does not. The representative of `set2`
    therefore has an `enemy_of` value of `-1`. Now, maybe `set1` ends up being folded
    into `set2` so that `set2` is the bigger set. If we just call it a day here and
    do nothing else, then `set2` will not be able to find its enemies! The `enemy_of`
    value for `set2`’s representative is still `-1`—and that’s wrong, because `set2`
    *does* have enemies now.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易认为我们已经完成了。我们已经执行了所需的朋友集合联合和敌人集合联合——还有什么可做的呢？好吧，假设 `set1` 有一些敌人，而 `set2`
    没有。那么，`set2` 的代表元素的 `enemy_of` 值就是 `-1`。现在，也许 `set1` 最终会并入 `set2`，使得 `set2` 成为更大的集合。如果我们就此停手不再做任何事情，那么
    `set2` 将无法找到它的敌人！因为 `set2` 的代表元素的 `enemy_of` 值仍然是 `-1`——这显然不对，因为 `set2` 现在*确实*有敌人了。
- en: 'Here’s how we handle this in the code. We already have `bigger_set`, indicating
    which set—`set1` or `set2`—resulted from unioning `set1` and `set2`. We use an
    if–else to set `other_set` to the other set ➏: if `bigger_set` is `set1`, then
    `other_set` will be `set2`, and vice versa. Then, if `bigger_set` has no enemies
    ❼, we copy over the enemy link from `other_set`. The result is that `bigger_set`
    is guaranteed to be able to find its enemies if `set1` or `set2` or both had enemies.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在代码中处理这个问题的方式。我们已经有了 `bigger_set`，它表示是哪个集合——`set1` 还是 `set2`——通过联合 `set1`
    和 `set2` 得到的。我们使用 if–else 来将 `other_set` 设置为另一个集合 ➏：如果 `bigger_set` 是 `set1`，那么
    `other_set` 就是 `set2`，反之亦然。然后，如果 `bigger_set` 没有敌人 ❼，我们将从 `other_set` 复制敌人链接。这样，`bigger_set`
    就能确保能找到它的敌人，如果 `set1` 或 `set2` 或两者都有敌人。
- en: Now it’s time for SetEnemies. Check it out in [Listing 9-13](ch09.xhtml#ch09ex013).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行 SetEnemies 操作了。请查看 [列表 9-13](ch09.xhtml#ch09ex013)。
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 9-13: Recording that two people are enemies*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-13：记录两个人是敌人*'
- en: We again begin by finding the representatives of each set, storing them in `set1`
    and `set2`, respectively. We then look up an enemy of `set1` ❶. If `set1` has
    no enemy, then we set `person2` to be its enemy ➋. If `set1` does have an enemy,
    then we’re in the territory of our second test case. We union `set1`’s enemies
    with `person2`’s set ➌, which ensures that `person2` and all of `person2`’s friends
    are all enemies of `person1`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次通过查找每个集合的代表，分别存储在`set1`和`set2`中。然后我们查找`set1`的敌人 ❶。如果`set1`没有敌人，则将`person2`设为其敌人
    ➋。如果`set1`有敌人，那么我们进入第二个测试用例的范围。我们将`set1`的敌人集合与`person2`的集合合并 ➌，这样确保`person2`以及`person2`的所有朋友都成为`person1`的敌人。
- en: That takes care of `set1`. Now we do likewise for `set2` ➍, setting its enemy
    to be `person1` if it doesn’t have an enemy yet or otherwise unioning its enemies
    with `person1`’s set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了`set1`。现在我们对`set2`做同样的操作 ➍，如果它还没有敌人，则将其敌人设为`person1`，否则将其敌人集合与`person1`的集合合并。
- en: 'Importantly, this function maintains the symmetry of the enemy relationship:
    if from `person1` we can find enemy `person2`, then from `person2` we can find
    enemy `person1`. Consider a given call of `set_enemies` on `person1` and `person2`.
    If `person1` has no enemies, then its enemy becomes `person2`, but if `person1`
    has enemies, its enemy set grows to include `person2`. Symmetrically, if `person2`
    has no enemies, then its enemy becomes `person1`, and if `person2` has enemies,
    then its enemy set grows to include `person1`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这个函数保持了敌人关系的对称性：如果从`person1`可以找到敌人`person2`，那么从`person2`也能找到敌人`person1`。考虑`person1`和`person2`的`set_enemies`调用。如果`person1`没有敌人，那么它的敌人就是`person2`，但如果`person1`有敌人，那么它的敌人集合将增加`person2`。对称地，如果`person2`没有敌人，那么它的敌人就是`person1`，如果`person2`有敌人，那么它的敌人集合也将增加`person1`。
- en: '*AreFriends and AreEnemies*'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AreFriends 和 AreEnemies*'
- en: The AreFriends operation amounts to checking whether the two people are in the
    same set or, equivalently, whether they have the same representative. This can
    be accomplished with two calls to Find, as shown in [Listing 9-14](ch09.xhtml#ch09ex014).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: AreFriends操作实际上就是检查两个人是否在同一个集合中，或者等价地，是否有相同的代表。这可以通过两次调用Find来完成，如[清单9-14](ch09.xhtml#ch09ex014)所示。
- en: '[PRE23]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-14: Determining whether two people are friends*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-14：判断两个人是否是朋友*'
- en: We have just one more operation to go! We can implement AreEnemies by checking
    whether one person is in the other person’s set of enemies. The code is given
    in [Listing 9-15](ch09.xhtml#ch09ex015).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下最后一个操作了！我们可以通过检查一个人是否在另一个人的敌人集合中来实现AreEnemies。代码见[清单9-15](ch09.xhtml#ch09ex015)。
- en: '[PRE24]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 9-15: Determining whether two people are enemies*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-15：判断两个人是否是敌人*'
- en: Two things must be true for `person2` to be an enemy of `person1` ❶. First,
    `person1` must have an enemy. Second, `person2` must be in its set of enemies.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要让`person2`成为`person1`的敌人，必须满足两个条件 ❶。首先，`person1`必须有敌人。其次，`person2`必须在其敌人集合中。
- en: Hey! Shouldn’t we also check whether `person1` is an enemy of `person2`? No,
    that’s not needed, because the enemy relationship is symmetric. If `person2` is
    not an enemy of `person1`, then there’s no point checking whether `person1` is
    an enemy of `person2`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！我们是不是也应该检查一下`person1`是否是`person2`的敌人？不，没必要，因为敌人关系是对称的。如果`person2`不是`person1`的敌人，那么就没有必要检查`person1`是否是`person2`的敌人。
- en: That’s it! We have successfully augmented the vanilla union-find data structure
    to incorporate both friend and enemy information. If you submit your code to the
    judge, you should pass all test cases. What about exceeding the time limit? With
    union by size and path compression in there, the time limit can’t stop us.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经成功地扩展了普通的并查集数据结构，以包含朋友和敌人信息。如果你将代码提交给评测系统，应该能够通过所有测试用例。那么如果超时怎么办？通过大小合并和路径压缩，时间限制也无法阻止我们。
- en: 'Problem 3: Drawer Chore'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题3：抽屉事务
- en: In the Social Network and Friends and Enemies problems, we were able to use
    both union by size and path compression to speed up our implementations. In this
    next problem, we’ll attach more meaning to the root of each set. We won’t be able
    to use union by size, because the choice of root matters. Think about why this
    is as you read the problem description!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络和朋友与敌人问题中，我们能够使用大小合并和路径压缩来加速实现。在下一个问题中，我们将赋予每个集合的根更多的意义。我们将无法使用大小合并，因为根的选择很重要。在你阅读问题描述时，想一想为什么会这样！
- en: This is DMOJ problem `coci13c5p6`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`coci13c5p6`。
- en: '*The Problem*'
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: Mirko has *n* items strewn around his room and *d* empty drawers. The items
    are numbered 1, 2, . . . , *n*; the drawers are numbered 1, 2, . . . , *d*. Each
    drawer can hold at most one item. Mirko’s goal is to consider each item in turn,
    placing it in a drawer if possible and throwing it away if not.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 米尔科有 *n* 个物品散落在他的房间里，和 *d* 个空抽屉。这些物品编号为 1, 2, ……，*n*；抽屉编号为 1, 2, ……，*d*。每个抽屉最多能容纳一个物品。米尔科的目标是逐一考虑每个物品，如果可能将其放入一个抽屉，否则将其扔掉。
- en: 'Each item has exactly two drawers in which it is allowed to be placed: Drawer
    A and Drawer B. (It’s for organizational purposes. We wouldn’t want to put the
    Halloween candy with the ants, after all.) For example, we might be allowed to
    place item 3 in Drawer 7 (A) or Drawer 5 (B).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物品有恰好两个允许放置的抽屉：抽屉 A 和抽屉 B。（这是为了组织目的。毕竟，我们可不想把万圣节糖果和蚂蚁放在一起。）例如，我们可能允许将物品 3
    放在抽屉 7（A）或抽屉 5（B）中。
- en: 'To determine what happens with each item, we use the following five rules in
    order:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定每个物品的处理方式，我们依次使用以下五条规则：
- en: If Drawer A is empty, put the item in Drawer A and stop.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抽屉 A 是空的，将物品放入抽屉 A 并停止。
- en: If Drawer B is empty, put the item in Drawer B and stop.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抽屉 B 是空的，将物品放入抽屉 B 并停止。
- en: If Drawer A is full, move the existing item in Drawer A to its other drawer;
    if that drawer is full, too, move its existing item to its other drawer; and so
    on. If this process would terminate, place the item in Drawer A and stop.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抽屉 A 已满，将抽屉 A 中的现有物品移到它的另一个抽屉；如果那个抽屉也已满，将它的现有物品移到它的另一个抽屉；以此类推。如果这个过程会终止，将物品放入抽屉
    A 并停止。
- en: If Drawer B is full, move the existing item in Drawer B to its other drawer;
    if that drawer is full, too, move its existing item to its other drawer; and so
    on. If this process would terminate, place the item in Drawer B and stop.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抽屉 B 已满，将抽屉 B 中的现有物品移到它的另一个抽屉；如果那个抽屉也已满，将它的现有物品移到它的另一个抽屉；以此类推。如果这个过程会终止，将物品放入抽屉
    B 并停止。
- en: If we have failed to place the item using the first four rules, we throw the
    item away.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们无法通过前四条规则放置物品，我们就将物品扔掉。
- en: Because of Rules 3 and 4, placing an item may result in other items moving to
    their other drawers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规则 3 和规则 4，放置一个物品可能会导致其他物品移动到它们的其他抽屉。
- en: We need to output whether each item is kept or thrown away.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要输出每个物品是被保留还是被扔掉。
- en: Input
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，包含以下行：
- en: A line containing *n*, the number of items, and *d*, the number of drawers.
    *n* and *d* are between 1 and 300,000.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，表示物品数量，以及 *d*，表示抽屉数量。*n* 和 *d* 的值在 1 到 300,000 之间。
- en: '*n* lines, one for each item. Each line contains two integers *a* and *b*,
    indicating that this item’s Drawer A is *a* and Drawer B is *b*. *a* will not
    be the same integer as *b*.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行包含两个整数 *a* 和 *b*，表示该物品的抽屉 A 是 *a*，抽屉 B 是 *b*。*a* 不会与 *b* 相同。'
- en: Output
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'The output for each item is on its own line. For each item, output `LADICA`
    if it is placed in a drawer and `SMECE` if it is thrown away. (These words come
    from the original COCI problem description: *ladica* is the Croatian word for
    drawer and *smece* is the Croatian word for trash.)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物品的输出单独占一行。对于每个物品，若物品被放入抽屉中，输出 `LADICA`；若物品被扔掉，输出 `SMECE`。（这两个词来自原始的 COCI
    问题描述：*ladica* 是克罗地亚语中“抽屉”的意思，*smece* 是克罗地亚语中“垃圾”的意思。）
- en: The time limit for solving the test case is one second.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此测试用例的时间限制为 1 秒。
- en: '*Equivalent Drawers*'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*等效抽屉*'
- en: 'Here’s an interesting scenario: We place a new item in Drawer 1—but, uh-oh,
    Drawer 1 happens to be full. Its existing item’s other drawer is Drawer 2\. So
    we move that existing item to Drawer 2 and, uh-oh again, Drawer 2 is full. Its
    existing item’s other drawer is Drawer 6\. Ugh—Drawer 6 is full, too! We move
    its existing item to its other drawer, Drawer 4\. Phew! Drawer 4 is empty, so
    we stop.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的场景：我们把一个新物品放入抽屉 1——但是，哎呀，抽屉 1 已经满了。它的现有物品的另一个抽屉是抽屉 2。于是我们将现有物品移到抽屉 2，哎呀，又满了。它的现有物品的另一个抽屉是抽屉
    6。唉——抽屉 6 也满了！我们将它的现有物品移到它的另一个抽屉，抽屉 4。呼！抽屉 4 是空的，所以我们停止。
- en: 'In the process of ultimately filling Drawer 4, we moved three existing items:
    from Drawer 1 to 2, from Drawer 2 to 6, and finally from Drawer 6 to 4\. However,
    those particular moves won’t matter to us. All we’ll need to know is that Drawer
    4 ends up filled.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终填满抽屉 4 的过程中，我们移动了三个现有物品：从抽屉 1 移到抽屉 2，从抽屉 2 移到抽屉 6，最后从抽屉 6 移到抽屉 4。然而，这些特定的移动对我们来说并不重要。我们只需要知道抽屉
    4 最终是满的。
- en: Prior to adding the new item, what Drawers 1, 2, 6, and 4 had in common is that
    if you try to place an item in any one of them, Drawer 4 ends up getting filled.
    This is the sense in which these four drawers are equivalent. For example, if
    you place an item in Drawer 4 directly, then Drawer 4 is filled right away. If
    you place an item in Drawer 6, Drawer 6’s existing item moves to Drawer 4 and
    again Drawer 4 is filled. This pattern also holds if you place an item in Drawer
    2 and, as we saw at the start of this example, if you place an item in Drawer
    1\. Drawer 4 is an empty drawer where the chain of drawers terminates and, thinking
    ahead to our union-find data structure, we see that this will be the representative
    of its set. Our set representatives will always be empty drawers; every other
    drawer in a set will be full.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新项目之前，抽屉 1、2、6 和 4 有一个共同点：如果你试图把一个物品放入其中任何一个抽屉，最终抽屉 4 会被填满。这就是这四个抽屉等价的含义。例如，如果你直接把物品放入抽屉
    4，抽屉 4 会立刻被填满。如果你把物品放入抽屉 6，抽屉 6 中原有的物品会移动到抽屉 4，再次导致抽屉 4 被填满。如果你把物品放入抽屉 2，或者如我们在这个示例开始时看到的，如果你把物品放入抽屉
    1，抽屉 4 会被填满。抽屉 4 是一个空抽屉，链条在此终止，考虑到我们的并查集数据结构，我们可以看到它将作为其集合的代表。我们的集合代表总是空抽屉；集合中的其他每个抽屉都会被填满。
- en: 'To make all of this concrete, let’s work through two test cases. In the first
    one, we’ll have `LADICA` everywhere: we’ll be able to place each item in a drawer.
    In the second, we’ll see some `SMECE`: there are some items that we will not be
    able to place.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一切更具实际意义，我们通过两个测试用例来演示。在第一个测试用例中，我们将看到每个物品都能被放入抽屉。第二个测试用例中，我们会看到一些 `SMECE`：有些物品我们无法放入抽屉。
- en: Test Case 1
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例 1
- en: 'Here’s our first test case:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个测试用例：
- en: '[PRE25]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have seven drawers, each of which starts empty and in its own set. I’ll
    place each set on its own line and highlight each set’s representative in italics:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有七个抽屉，每个抽屉开始时都是空的，并且属于自己的集合。我将每个集合列在自己的行上，并用斜体标出每个集合的代表：
- en: '*1*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*1*'
- en: '*2*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*2*'
- en: '*3*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*4*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*4*'
- en: '*5*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*6*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*6*'
- en: '*7*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: It’s a good time to refresh your memory of the rules from the problem description
    before continuing.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，最好回顾一下问题描述中的规则。
- en: 'The first item is `1 2`; that’s a Drawer A of 1 and a Drawer B of 2\. Since
    Drawer 1 is empty, this item is placed in Drawer 1 (using Rule 1). In addition,
    Drawers 1 and 2 end up in the same set: placing a new item into Drawer 1 or Drawer
    2 would result in the same drawer, Drawer 2, being filled. Here’s our next snapshot
    of the sets:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个物品是 `1 2`；这是抽屉 A 的 1 和抽屉 B 的 2。由于抽屉 1 是空的，这个物品会被放入抽屉 1（使用规则 1）。此外，抽屉 1 和
    2 会被合并到同一个集合中：将新物品放入抽屉 1 或抽屉 2 会导致同一个抽屉——抽屉 2 被填满。这里是我们集合的下一个快照：
- en: 1 *2*
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 1 *2*
- en: '*3*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*4*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*4*'
- en: '*5*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*6*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*6*'
- en: '*7*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'Notice the new set has Drawer 2 as its representative. Using Drawer 1 as its
    representative would be incorrect: it would erroneously indicate that Drawer 1
    is empty! This is why we won’t use union by size: it might choose the wrong root
    to be the representative of the resulting set.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新集合的代表是抽屉 2。使用抽屉 1 作为代表是不正确的：这会错误地表明抽屉 1 是空的！这就是为什么我们不会使用按大小合并的方法：它可能会选择错误的根节点作为结果集合的代表。
- en: 'Now consider the second item: `2 6`. Drawer 2 is empty, so we place this item
    there (using Rule 1 again). Now placing an item in Drawer 1, 2, or 6 would result
    in Drawer 6 being filled, so we union Drawers 1 and 2 with Drawer 6:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二个项目：`2 6`。抽屉 2 是空的，所以我们将物品放入其中（再次使用规则 1）。现在，将物品放入抽屉 1、2 或 6 会导致抽屉 6 被填满，因此我们将抽屉
    1 和 2 与抽屉 6 合并：
- en: 1 2 *6*
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 *6*
- en: '*3*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*4*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*4*'
- en: '*5*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*7*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: Drawer 6 is empty, so placing an item in Drawer 6 fills it immediately. Placing
    an item in Drawer 2 causes that drawer’s existing item to move to Drawer 6, again
    filling Drawer 6\. Placing an item in Drawer 1 causes its existing item to move
    to Drawer 2, and Drawer 2’s existing item to move to Drawer 6 . . . , so Drawer
    6 is filled again. That’s why we’re justified in putting all three of these drawers
    in the same set, with Drawer 6 as its representative.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉 6 是空的，所以将物品放入抽屉 6 会立刻填满它。将物品放入抽屉 2 会导致该抽屉的现有物品移动到抽屉 6，再次填满抽屉 6。将物品放入抽屉 1
    会导致其现有物品移动到抽屉 2，抽屉 2 中现有的物品会移动到抽屉 6……，因此抽屉 6 再次被填满。这就是为什么我们可以将这三个抽屉放在同一个集合中，并将抽屉
    6 作为其代表。
- en: 'The next item is `6 4`. We know what to do (using Rule 1 again):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个物品是 `6 4`。我们知道该怎么做（再次使用规则 1）：
- en: 1 2 6 *4*
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 *4*
- en: '*3*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*5*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*7*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'The next item is `5 3`. Again, this poses no problem (using Rule 1):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个物品是 `5 3`。同样，这没有问题（使用规则 1）：
- en: 1 2 6 *4*
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 *4*
- en: 5 *3*
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 5 *3*
- en: '*7*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'Every item we’ve processed so far has succeeded by using Rule 1\. Of course,
    that need not be the case, as is evinced by the next item: `5 7`. Rule 1 does
    not apply, because Drawer 5 is already full. Rule 2 does apply, though, because
    Drawer 7 is empty. This item is therefore placed in Drawer 7\. The empty drawer
    of the unioned set is Drawer 3, so that’s our representative, as shown in the
    next snapshot:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理的每个物品都通过使用规则 1 成功了。当然，情况不必总是这样，正如下一个物品 `5 7` 所示：规则 1 不适用，因为抽屉 5 已经满了。然而规则
    2 适用，因为抽屉 7 是空的。因此，这个物品被放入抽屉 7。合并后的集合的空抽屉是抽屉 3，因此它就是我们的代表，如下一个快照所示：
- en: 1 2 6 *4*
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 *4*
- en: 5 7 *3*
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 5 7 *3*
- en: 'We have one more item to go, and it’s a fun one: `2 5`. Does Rule 1 apply?
    No, because Drawer 2 is full. Does Rule 2 apply? No, because Drawer 5 is full.
    Does Rule 3 apply? Yes! It applies because Drawer 2’s set has an empty drawer
    (Drawer 4). How do we proceed?'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个物品要处理，而且它挺有趣的：`2 5`。规则 1 适用吗？不适用，因为抽屉 2 已满。规则 2 适用吗？不适用，因为抽屉 5 已满。规则 3
    适用吗？适用！它适用是因为抽屉 2 的集合中有一个空抽屉（抽屉 4）。我们该怎么做？
- en: 'The argument in this case is that Drawer 2’s set and Drawer 5’s set should
    be unioned, like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的论点是，抽屉 2 的集合和抽屉 5 的集合应该合并，像这样：
- en: 1 2 6 4 5 7 *3*
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 4 5 7 *3*
- en: 'I’ll explain why this works. The `2 5` item ends up placed in Drawer 2: existing
    items move from Drawer 2 to Drawer 6 and move from Drawer 6 to Drawer 4\. Drawer
    4 is now filled, so it can’t be the representative of its set anymore. In fact,
    the only relevant, empty drawer is Drawer 3, so we’re really hoping that Drawer
    3 can serve as the set representative. Drawers 5, 7, and 3 should certainly be
    in the same set: placing an item in any of them ultimately fills Drawer 3, because
    they were in the same set prior to us introducing the `2 5` item.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我来解释一下为什么这样可行。物品 `2 5` 最终被放入抽屉 2：原有的物品从抽屉 2 移到抽屉 6，再从抽屉 6 移到抽屉 4。抽屉 4 现在被填满，因此它不能再作为其集合的代表。事实上，唯一相关的空抽屉是抽屉
    3，所以我们实际上希望抽屉 3 能作为集合的代表。抽屉 5、7 和 3 肯定属于同一个集合：将物品放入其中任何一个最终都会填满抽屉 3，因为在我们引入 `2
    5` 物品之前，它们就已经在同一个集合中。
- en: 'It remains to explain why Drawers 1, 2, 6, and 4 should be in Drawer 3’s set,
    as well. Drawer 2 is fine: placing an item in Drawer 2 moves its existing item
    to Drawer 5\. Drawer 5 is in Drawer 3’s set, so we know what happens from here:
    Drawer 3 will end up filled.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要解释为什么抽屉 1、2、6 和 4 也应该在抽屉 3 的集合中。抽屉 2 没问题：将物品放入抽屉 2 会把其原有物品移到抽屉 5。抽屉 5 在抽屉
    3 的集合中，所以我们知道接下来会发生什么：抽屉 3 最终会被填满。
- en: 'Drawer 1 is fine, too: placing an item in Drawer 1 moves its existing item
    to Drawer 2, and from here we can use the previous paragraph to argue that Drawer
    3 will be filled. Similar logic applies to Drawers 6 and 4\. For example, if we
    place an item in Drawer 4 and then we “undo” the moves that occurred when we filled
    Drawer 2, Drawer 4’s existing item moves back to Drawer 6, Drawer 6’s existing
    item moves back to Drawer 2, and now we’re back in the case in the previous paragraph.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉 1 也没问题：将一个物品放入抽屉 1 会把其原有的物品移到抽屉 2，从这里我们可以使用前一段中的论证来说明抽屉 3 会被填满。类似的逻辑适用于抽屉
    6 和 4。例如，如果我们将物品放入抽屉 4，然后“撤销”填充抽屉 2 时发生的移动，抽屉 4 的原有物品会移回抽屉 6，抽屉 6 的原有物品会移回抽屉 2，现在我们回到了前一段中的情况。
- en: 'Each item in this test case is placed in a drawer, so the correct output is
    as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物品都被放入了一个抽屉，因此正确的输出如下：
- en: '[PRE26]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s extract a general principle from this test case. Say we’re processing
    item `x y` and that the item ends up in `x`’s set. Then we union `x`’s set and
    `y`’s set, keeping `y`’s representative as the representative of the union.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个测试案例中提取一个一般性原则。假设我们正在处理物品 `x y`，并且该物品最终位于 `x` 的集合中。然后我们将 `x` 的集合和 `y`
    的集合合并，保持 `y` 的代表作为合并集合的代表。
- en: Why is this correct? Think about what happens when we try to place an item in
    the unioned set, whose components are `x`’s old set and `y`’s old set. Placing
    it in some drawer of `y`’s set still fills `y`’s representative, because we haven’t
    messed with `y`’s set at all. Placing it in drawer `x` fills `y`’s representative,
    too, because we move `x`’s existing item to `y`, and then we’re back in the case
    of placing an item in a drawer of `y`’s set. The only remaining option is that
    the new item is placed in drawer `z` (which is different from `x`) in `x`’s set.
    There is a chain of drawers from drawer `z` to drawer `x`; moving items along
    that chain will fill drawer `x`, and from there `y`’s representative will be filled.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是正确的？想一想当我们试图把一个项目放入并集的集合中时，这个集合的组成部分是`x`的旧集合和`y`的旧集合。将它放入`y`的集合中的某个抽屉依然会填充`y`的代表，因为我们根本没有改变`y`的集合。将它放入`x`的抽屉也会填充`y`的代表，因为我们把`x`的现有项目移到`y`，然后我们就回到了将项目放入`y`集合的抽屉的情况。唯一剩下的选择是将新项目放入`x`集合中的抽屉`z`（与`x`不同）。从抽屉`z`到抽屉`x`有一条抽屉链；沿着这条链移动物品会填充抽屉`x`，然后`y`的代表也会被填充。
- en: What if we’re processing item `x y`, and the item ends up in `y`’s set? In this
    case, the roles of the two sets are reversed. In particular, we’ll keep the representative
    of `x`’s set as the representative of the union set.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理项目`x y`，而该项目最终进入了`y`的集合呢？在这种情况下，两个集合的角色会反转。特别地，我们将保持`x`的集合的代表作为并集集合的代表。
- en: Test Case 2
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例 2
- en: 'Now let’s see how some `SMECE` can arise. Here’s our second test case:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何产生`SMECE`。这是我们的第二个测试用例：
- en: '[PRE27]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first three items are `LADICA`s and result in a familiar state:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个项目是`LADICA`，并且结果呈现出一个熟悉的状态：
- en: 1 2 6 *4*
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 *4*
- en: '*3*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*5*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*7*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'Now, here’s something different: item `1 4` ❶. For the first time, we see an
    item whose Drawer A and Drawer B are in the *same* set. It therefore provides
    no new empty drawer for this set. That is, using Rule 2 fills Drawer 4 (so it’s
    a `LADICA`), but it gives us no set to union. Drawers 1, 2, 6, and 4 enter a new
    kind of state, whereby it becomes impossible to successfully place an item in
    any of them! If you try, you will cycle items around forever. For example, try
    to place an item in Drawer 1\. We can push Drawer 1’s existing item to Drawer
    2, then push Drawer 2’s existing item to Drawer 6, then push Drawer 6’s existing
    item to Drawer 4, Drawer 4’s existing item gets pushed to Drawer 1, Drawer 1’s
    existing item to Drawer 2, Drawer 2’s existing item to Drawer 6, and so on and
    so on, until I hit my book’s page limit.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有个不同的情况：项目`1 4` ❶。第一次，我们看到一个抽屉A和抽屉B在*同一个*集合中。它因此不会为这个集合提供新的空抽屉。也就是说，使用规则2填充抽屉4（所以它是一个`LADICA`），但是它不会给我们任何可以并集的集合。抽屉1、2、6和4进入了一种新的状态，在这种状态下，任何物品都无法成功放入它们！如果你尝试，你将永远在其中循环。例如，尝试将物品放入抽屉1。我们可以把抽屉1的现有物品推到抽屉2，然后把抽屉2的现有物品推到抽屉6，然后把抽屉6的现有物品推到抽屉4，抽屉4的现有物品被推到抽屉1，抽屉1的现有物品推到抽屉2，抽屉2的现有物品推到抽屉6，依此类推，直到我撞到我的书的页面限制。
- en: 'In our implementation, we’re going to flag this state by giving this set a
    representative of 0:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们将通过为该集合指定代表0来标记这一状态：
- en: 1 2 6 4 *0*
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 4 *0*
- en: '*3*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*5*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: '*7*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*7*'
- en: 'Now we’re dangerously close to a `SMECE`. If any item comes along, both of
    whose drawers are in this set, then there’s no way to place it. Look at our next
    item: `2 4`. Can we place it in Drawer 2? No; it’s full. What about Drawer 4?
    No; it’s also full. Can we follow a chain of drawers from Drawer 2 to find an
    empty drawer? No. Is there a chain of drawers from Drawer 4 to an empty drawer?
    No. Four strikes. `SMECE`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经非常接近一个`SMECE`了。如果有任何项目，其中的两个抽屉都在这个集合中，那么就无法放置它。看看我们下一个项目：`2 4`。我们能把它放入抽屉2吗？不行；它已经满了。那抽屉4呢？也不行；它也满了。我们能沿着抽屉2的链找到一个空抽屉吗？不行。有没有从抽屉4到空抽屉的链？不行。四次失败。`SMECE`。
- en: 'Moving on, we have item `1 7`. This will be processed by using Rule 2\. We
    therefore perform a Union (because it’s a `LADICA`)—but watch out: because it’s
    another Union that gives us a set without an empty drawer! Here’s the result:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理项目`1 7`。这个将通过使用规则2来处理。因此我们执行一个并集（因为它是一个`LADICA`）——但要注意：因为这是另一个并集，它会给我们一个没有空抽屉的集合！这是结果：
- en: 1 2 6 4 7 *0*
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 6 4 7 *0*
- en: '*3*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*3*'
- en: '*5*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*5*'
- en: 'The final item is `7 6`, and that’s another `SMECE` because none of the four
    `LADICA` rules apply: Drawers 7 and 6 are in the same set, and that set has no
    empty drawer.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的项目是`7 6`，这又是一个`SMECE`，因为没有四条`LADICA`规则适用：抽屉7和6在同一个集合中，而且这个集合没有空抽屉。
- en: 'The correct output for this test case is:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的正确输出是：
- en: '[PRE28]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only rule we haven’t explored in our test cases is Rule 4\. I encourage
    you to play around with Rule 4 a bit before continuing. In particular, you can
    verify that whenever you apply Rule 4, the representative of the unioned set will
    be 0.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试用例中，唯一没有探讨的规则是规则4。我建议你在继续之前先玩一下规则4。特别是，你可以验证每次应用规则4时，合并后集合的代表将是0。
- en: Now it’s implementation time!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实现阶段了！
- en: '*The main Function*'
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*主函数*'
- en: Let’s start with the `main` function, which reads each item from the input and
    processes it. The code is given in [Listing 9-16](ch09.xhtml#ch09ex016).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main`函数开始，它从输入中读取每个项目并进行处理。代码在[清单9-16](ch09.xhtml#ch09ex016)中给出。
- en: '[PRE29]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 9-16: The* main *function for processing items*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-16：处理项目的*主*函数*'
- en: As usual, the `parent` array records the parent of each node in the union-find
    data structure. Items are numbered starting from 1, so it’s safe for us to use
    a representative of 0 for the drawers that can never have a new item placed in
    them. We give 0 a representative of 0 ❶ to indicate that this set, like all other
    sets, starts out empty.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，`parent`数组记录了并查集数据结构中每个节点的父节点。项目的编号从1开始，因此我们可以安全地使用0作为那些永远不能放入新项目的抽屉的代表。我们将0的代表设置为0
    ❶，以表示这个集合像其他所有集合一样，最初是空的。
- en: Now, let’s look at those five rules. We implement each of the four `LADICA`
    rules with one call to `find` and one call to `union`. If none of these rules
    applies, then we’re in the `SMECE` case. Let’s go through each `LADICA` rule in
    turn.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这五个规则。我们通过一次`find`调用和一次`union`调用来实现四个`LADICA`规则。如果这些规则都不适用，那么我们就在`SMECE`的情况下。我们逐一来看每个`LADICA`规则。
- en: For Rule 1, we need to know whether `drawer_a` is empty. Remember that each
    set of drawers (not including the “0” set) has exactly one empty drawer and that
    this empty drawer is the representative of the set. The `find` function returns
    the representative of the given set. Putting these two facts together, we see
    that `find` returns `drawer_a` exactly when `drawer_a` is empty ➋.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规则1，我们需要知道`drawer_a`是否为空。记住，每个抽屉集合（不包括“0”集合）都有且只有一个空抽屉，而这个空抽屉是该集合的代表。`find`函数返回给定集合的代表。将这两个事实结合起来，我们可以得出结论，只有当`drawer_a`为空时，`find`才会返回`drawer_a`
    ➋。
- en: 'If we are in the Rule 1 case, then we need to union `drawer_a`’s set with `drawer_b`’s
    set. We therefore call `union_sets` ➌. Careful, though: remember that we must
    make `drawer_b`’s representative be the representative of the new set, because
    `drawer_a`’s set has no empty drawers now that `drawer_a` is full. To make that
    happen, we’ll use an implementation of `union_sets` that does not perform union
    by size. It guarantees that the representative of the second parameter that we
    pass—`drawer_b` here—will be the representative of the unioned set. It’s also
    responsible for outputting the `LADICA` message. We’ll see that code in the next
    subsection.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于规则1的情况，那么我们需要将`drawer_a`的集合与`drawer_b`的集合合并。因此，我们调用`union_sets` ➌。不过要小心：记住，我们必须使`drawer_b`的代表成为新集合的代表，因为`drawer_a`的集合已经没有空抽屉了，`drawer_a`已经满了。为了实现这一点，我们将使用一种不按照大小进行并查集合并的`union_sets`实现。它保证我们传递的第二个参数（在这里是`drawer_b`）将成为合并后集合的代表。它还负责输出`LADICA`消息。我们将在下一小节中看到这段代码。
- en: For Rule 2, we need to know if `drawer_b` is empty. We again use `find` to check
    this ➍, and we perform the Union operation if this rule applies ➎. This time,
    we call `union_sets` with the drawers in the opposite order so that `drawer_a`’s
    representative becomes the representative of the unioned set.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规则2，我们需要知道`drawer_b`是否为空。我们再次使用`find`来检查这个 ➍，如果适用这个规则，就执行并查集操作 ➎。这一次，我们以相反的顺序调用`union_sets`，使得`drawer_a`的代表成为合并后集合的代表。
- en: 'For Rule 3, we need to know whether `drawer_a`’s set has an empty drawer. A
    set has an empty drawer unless the set’s representative is 0\. We use `find` to
    check this condition ➏: if `find` returns a representative other than 0, then
    this set has an empty drawer. If this rule applies, then we perform the expected
    Union ❼. We’ll see in the next subsection how `union_sets` is responsible for
    appropriately moving sets to the “0” set.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规则3，我们需要知道`drawer_a`的集合是否有空抽屉。一个集合只有在其代表元素为0时才没有空抽屉。我们使用`find`来检查这个条件 ➏：如果`find`返回的代表不是0，那么这个集合就有空抽屉。如果适用这个规则，我们就执行预期的并查集操作
    ❼。在下一小节中，我们将看到`union_sets`如何负责将集合适当地移到“0”集合。
- en: 'Finally, for Rule 4, we need to know whether `drawer_b`’s set has an empty
    drawer. The logic is the same as that for Rule 3: use `find` to check whether
    this set has an empty drawer ❽; if it does, perform the Union ❾.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于规则 4，我们需要知道 `drawer_b` 的集合是否有空的抽屉。逻辑与规则 3 相同：使用 `find` 检查该集合是否有空的抽屉 ❽；如果有，则执行
    Union ❾。
- en: '*Find and Union*'
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Find 和 Union*'
- en: 'The Find function is given in [Listing 9-17](ch09.xhtml#ch09ex017). It uses
    path compression. That’s a good thing, because I just submitted a solution without
    path compression and I received a “Time-Limit Exceeded” error. #PathCompressionWins.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Find 函数见 [Listing 9-17](ch09.xhtml#ch09ex017)。它使用了路径压缩。这是件好事，因为我刚提交了一个没有路径压缩的解法，并收到了“超时”错误。#PathCompressionWins。
- en: '[PRE30]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 9-17: The* find *function*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-17：*find*函数*'
- en: The Union function is given in [Listing 9-18](ch09.xhtml#ch09ex018).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Union 函数见 [Listing 9-18](ch09.xhtml#ch09ex018)。
- en: '[PRE31]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 9-18: The* union_sets *function*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-18：*union_sets*函数*'
- en: 'As promised, there’s no union by size here: we always use `set2`, the set of
    `drawer2`, as the new set ❶.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前承诺的，这里没有按大小合并：我们总是使用 `set2`，即 `drawer2` 的集合，作为新的集合 ❶。
- en: In addition, whenever an item is placed whose drawers are in the same set ➋,
    we set the representative of the resulting set to `0` ➌. Whenever `find` is later
    called on any element of this resulting set, `0` will be returned, correctly indicating
    that no item can ever be placed in this set again.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每当放置一个物品且其抽屉属于同一集合 ➋ 时，我们将结果集合的代表设置为 `0` ➌。以后每当对这个结果集合的任何元素调用 `find` 时，将返回
    `0`，正确地表示该集合再也不能放置任何物品。
- en: 'There we have it: a 50-line union-find solution to one of the most challenging
    problems in this book. Please submit your code to the judge!'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：这是一个 50 行的并查集解决方案，解决了本书中最具挑战性的问题之一。请将你的代码提交给评测系统！
- en: '**Summary**'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we’ve learned how to efficiently implement the union-find data
    structure. Of all the data structures in this book, the union-find data structure
    is the one that surprises me most with the breadth of its applications. “Really?
    This is a union-find problem?” I frequently have that thought. Perhaps you similarly
    had that thought when we solved Friends and Enemies or Drawer Chore. In any case,
    you’re likely to encounter other problems, seemingly quite different from those
    that I presented here, where union-find nevertheless applies.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何高效地实现并查集数据结构。在本书所有数据结构中，并查集是令我最惊讶的一个，因为它的应用范围非常广泛。“真的吗？这是一个并查集问题？”我经常有这样的想法。当我们解决《朋友与敌人》或《Drawer
    Chore》问题时，也许你也有过这样的想法。无论如何，你很可能会遇到其他看似与这里的例子完全不同的问题，但并查集依然适用。
- en: 'Happily, given its wide applicability and speedy performance, we don’t need
    huge amounts of code to implement union-find: just a few lines for Union and a
    few lines for Find. In addition, you may find that the code isn’t too tricky,
    once we’ve learned about the array representation for the trees. Even the optimizations,
    union by size and path compression, require little code.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，考虑到其广泛的适用性和快速的性能，我们不需要大量的代码来实现并查集：只需要为 Union 写几行代码，为 Find 写几行代码。此外，你可能会发现，一旦我们了解了树的数组表示法，代码并不难理解。即使是优化，比如按大小合并和路径压缩，也需要很少的代码。
- en: Notes
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Drawer Chore is originally from the 2013 Croatian Open Competition in Informatics,
    Round 5\. I found the “0 representative” idea from the COCI website (see *[http://hsin.hr/coci/archive/2013_2014](http://hsin.hr/coci/archive/2013_2014)*).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Drawer Chore 最初来源于 2013 年克罗地亚开放信息学竞赛的第五轮。我在 COCI 网站上找到了“0 代表”这一概念（见 *[http://hsin.hr/coci/archive/2013_2014](http://hsin.hr/coci/archive/2013_2014)*）。
