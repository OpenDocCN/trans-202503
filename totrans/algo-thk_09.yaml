- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNION-FIND**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We used the adjacency list data structure—and algorithms on it—to solve graph
    problems in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml). That’s an efficient
    data structure that works no matter the graph problem. However, if we constrain
    the types of problems we want to solve, we can design an even more efficient data
    structure. Constrain the problems just a little, and we likely wouldn’t be able
    to do any better than an adjacency list. Constrain them too much, and few people
    would use our data structure because it would be unlikely to solve problems that
    they cared about solving. Constrain the problems just right and you have the union-find
    data structure, the topic of this chapter. It solves graph problems—not all, only
    some. For the ones it does solve, though, it’s much faster than a general-purpose
    graph data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of communities in a social network, maintaining groups of friends
    and enemies, and organizing items into specified drawers are all graph problems.
    Importantly, they’re special graph problems, ones that can be solved with incredible
    speed by using union-find. Let’s do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Social Network'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is SPOJ problem `SOCNETC`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You are asked to write a program that tracks the people and communities in a
    social network.
  prefs: []
  type: TYPE_NORMAL
- en: There are *n* people, numbered 1, 2, . . . , *n*.
  prefs: []
  type: TYPE_NORMAL
- en: A *community* is a person plus that person’s friends, their friends’ friends,
    their friends’ friends’ friends, and so on. For example, if Person 1 and Person
    4 are friends, and Person 4 and Person 5 are friends, then this community consists
    of the three people, 1, 4, and 5\. People in the same community are all friends
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Each person starts in a community alone; the person’s community can get bigger
    as friendships between people are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program must support three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add**   Make the two provided people be friends. If this operation takes
    place, and if these people were not in the same community before, then they will
    be in the same (larger) community now.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examine**   Report whether the two provided people are in the same community.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**   Report the number of people who are in the provided person’s community.'
  prefs: []
  type: TYPE_NORMAL
- en: Your program will run on a computer with limited resources, so there is a parameter
    *m* that gives the maximum number of people in a community. We’re required to
    ignore any Add operation that would result in a community with more than *m* people.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of people in the social network, and *m*,
    the maximum number of people allowed in a community. *n* and *m* are between 1
    and 100,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing integer *q*, the number of operations to follow. *q* is between
    1 and 200,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* lines, one for each operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the *q* lines can be one of the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: An Add operation is of the form `A` x y, where x and y are people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Examine operation is of the form `E` x y, where x and y are people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Size operation is of the form `S` x, where x is a person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no output for an Add operation. The output for each Examine and Size
    operation is on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examine**   For an Examine operation, output `Yes` if the two people are
    in the same community, and output `No` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**   For a Size operation, output the number of people in the person’s
    community.'
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is one second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modeling as a Graph*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapters 5](ch05.xhtml) and [6](ch06.xhtml), we practiced at length framing
    problems as graph explorations. We figured out what to use as the nodes and what
    to use as the edges and then used BFS or Dijkstra’s algorithm to explore the graph.
  prefs: []
  type: TYPE_NORMAL
- en: We can similarly model a social network as a graph. The nodes are the people
    in the social network. If the test case tells us that *x* and *y* are friends,
    then we can add an edge between node *x* and node *y*. The graph is undirected,
    because friendship between two people is mutual.
  prefs: []
  type: TYPE_NORMAL
- en: One key difference compared to the problems that we previously solved in [Chapters
    5](ch05.xhtml) and [6](ch06.xhtml) is that the social network graph is dynamic.
    Each time we process an Add operation between two people that are not yet friends,
    we add a new edge to the graph. Compare that to [Chapter 5](ch05.xhtml)’s Book
    Translation. There, we knew all of the languages and translators at the outset,
    so we could build the graph once and never have to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a test case to animate how our graph grows and to observe how the
    graph helps us implement the three required operations (Add, Examine, and Size).
    Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with seven people and no friendship connections, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `A 1 4` operation makes People 1 and 4 friends, so we add an edge between
    those two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `A 4 5` operation does similarly for People 4 and 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For `A 3 6`, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next operation is `E 1 5`, which asks us whether People 1 and 5 are in
    the same community. The graph answers this for us: if there is a path from Node
    1 to Node 5 (or, equivalently, from Node 5 to Node 1), then they are in the same
    community; otherwise, they are not. In this case, they are; the path from Node
    1 to Node 4 to Node 5 is a path from Node 1 to Node 5.'
  prefs: []
  type: TYPE_NORMAL
- en: The next operation is `E 2 5`. There’s no path between Nodes 2 and 5, so these
    two people are not in the same community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have `A 1 5`, which will add an edge between Nodes 1 and 5\. (Notice
    how we’re interleaving operations that modify the graph with operations that query
    the graph.) Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The addition of this edge caused a cycle, because it added a friendship link
    between two people who were already in the same community. Therefore, this new
    edge doesn’t have any impact on the number of communities or their size. We could
    have left it out, but I’ve decided here to include all allowed friendship links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider `A 2 5`, which does unite two communities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we have `A 4 3`, which again unites two communities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/unch09fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our first Size operation: `S 4`. How many people are in Person
    4’s community? This amounts to determining the number of nodes reachable from
    Node 4\. There are six such nodes, with the only unreachable node being Node 7,
    so the answer is `6`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider `A 7 6`. We must add the edge between Nodes 7 and 6 . . . whoa
    there! This edge would cause the formation of a new community with all seven people,
    but the test case forces an upper limit of six people in any given community.
    We must ignore this Add operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, the answer to the final operation, `S 4`, is the same as it
    was before: `6`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct output for our test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example shows what is needed to implement each operation. For Add, we add
    a new edge to the graph, unless that edge would produce a community with too many
    people. For Examine, we determine whether there is a path between two nodes or,
    equivalently, whether one node is reachable from the other. We can use BFS for
    that! For Size, we determine the number of nodes reachable from a given node.
    We can use BFS again!
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: BFS*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take this graph-based solution in two steps. First, I’ll show the `main`
    function that processes the operations, progressively building the graph as it
    goes. Then, I’ll show the BFS code.
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We need a constant and a struct to begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function is given in [Listing 9-1](ch09.xhtml#ch09ex01). It reads
    the input, and it responds to the operations by incrementally building and querying
    the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: The* main *function for processing operations*'
  prefs: []
  type: TYPE_NORMAL
- en: As we did in Book Translation in [Chapter 5](ch05.xhtml) and in the problems
    in [Chapter 6](ch06.xhtml), we use an adjacency list representation of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the code handles each of the three types of operations, starting
    with Add ❶. We call the helper function `find_distances` ➋. That function, as
    we’ll see shortly, implements the BFS: it fills `min_moves` with the shortest
    path in the graph from `person1` to each person, using a value of `-1` for any
    person that is not reachable. Then, we call helper function `size` ➌, which uses
    distance information in `min_moves` to determine the size of `person1`’s community.
    We next determine whether `person1` and `person2` are in the same community: if
    `person2` is reachable from `person1`, then they’re in the same community ➍. We
    need this information to determine whether to add the edge: if the people are
    already in the same community, then the edge can be safely added without worrying
    about creating a community that violates the constraint on the maximum number
    of people in a community.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having found the size of `person1`’s community, we do the same for `person2`’s
    community: first invoking BFS for `person2` ➎ and then computing the community’s
    size ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if there’s no new community, or if the new community is small enough ❼,
    then we add the edge to the graph. Actually, we add two edges, because, remember,
    the graph is undirected.
  prefs: []
  type: TYPE_NORMAL
- en: The other operations take less code. For Examine ❽, we run the BFS and check
    whether `person2` is reachable from `person1`. For Size ❾, we run the BFS and
    then count the number of nodes reachable from `person1`.
  prefs: []
  type: TYPE_NORMAL
- en: The BFS Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The BFS code we need here is very similar to the BFS code we wrote when solving
    Book Translation in [Chapter 5](ch05.xhtml), except without the book translation
    costs. See [Listing 9-2](ch09.xhtml#ch09ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: Minimum distance to people using BFS*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Size of a Community
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last little helper function to write is `size`, which returns the number
    of people in a given person’s community. See [Listing 9-3](ch09.xhtml#ch09ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: The size of a person’s community*'
  prefs: []
  type: TYPE_NORMAL
- en: In this function, it is assumed that `min_moves` has already been filled in
    by `find_distances`. Every person whose `min_moves` value is not `-1` is therefore
    reachable. We use `total` to add up those reachable people.
  prefs: []
  type: TYPE_NORMAL
- en: 'There we have it: a graph-based solution. For each of the *q* operations, we
    run one BFS. At worst, each operation adds one edge to the graph, so each BFS
    call does work proportional to at most *q*. We therefore have an *O*(*q*²), or
    quadratic, algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.xhtml), I advised you that it’s important not to run BFS
    too many times. It’s best to make just one BFS call, if you can get away with
    that. Even a few calls can be okay. After all, we got away with making a BFS call
    for each pawn position when solving Knight Chase on [page 151](ch05.xhtml#lev32).
    The same sentiment applies to Dijkstra’s algorithm from [Chapter 6](ch06.xhtml):
    make as few calls as possible. Here again, making a few calls is okay. We solved
    Mice Maze on [page 198](ch06.xhtml#lev38) using about 100 calls of Dijkstra, and
    it was fast enough. Thriftless use of graph search hasn’t bitten us yet.'
  prefs: []
  type: TYPE_NORMAL
- en: It does bite us now, though. If you submit your solution to the judge, you’ll
    get a “Time-Limit Exceeded” error—and it isn’t even close. I’m playing around
    with an example here on my laptop with 100,000 people in the social network and
    200,000 operations. The operations are divided equally among Add, Examine, and
    Size operations. Our graph-based solution takes over two minutes to run. You’re
    about to learn a new data structure called union-find that, on the same example,
    runs 300 times faster. Union-find is an efficiency beast.
  prefs: []
  type: TYPE_NORMAL
- en: '*Union-Find*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For two reasons, BFS on a graph is not a satisfactory solution to the Social
    Network problem. First, it produces too much! It determines shortest paths between
    people. For example, it might tell us that the shortest path between People 1
    and 5 is two, but who cares? All we want to know is whether or not two people
    are in the same community. How they ended up in the same community and the chain
    of friendships that connect them are not of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, it remembers too little—or, rather, it remembers nothing: BFS starts
    afresh with each call. However, think about how wasteful this is. For example,
    an Add operation adds just one edge to the graph. The communities can’t be much
    different than they were before. BFS doesn’t use past information at all, instead
    reprocessing the complete graph on the next operation.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal, then, is to devise a data structure that doesn’t remember anything
    about shortest paths and that does only a little work when a new friendship is
    made.
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add operation unites two communities into one. (Well, it does nothing when
    the resulting community would be too big or when two people are in the same community,
    but when it does something, it unites two communities.) This kind of operation
    is referred to in the algorithms world as a *Union*. In general, a Union replaces
    two sets by one larger set containing all of their elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Examine operation tells us whether the two provided people are in the same
    community. One way to implement this is to designate one element of each community
    as its *representative* element. For example, a community with People 1, 4, and
    5 might have 4 as its representative; a community with People 3 and 6 might have
    3 as its representative. Are People 1 and 5 in the same community? Yes, because
    the representative of Person 1’s community (4) is the same as the representative
    of Person 5’s community (4). Are People 4 and 6 in the same community? No, because
    the representative of Person 4’s community (4) is not the same as the representative
    of Person 6’s community (3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining the representative of a person’s community is called a *Find*.
    We can implement Examine with two Finds: find the representative of the first
    person’s community, find the representative of the second person’s community,
    and compare them.'
  prefs: []
  type: TYPE_NORMAL
- en: Since an Add is a Union and an Examine is a Find, data structures that implement
    these two operations are known as *union-find* data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have Union and Find working, we’ll be in great shape to support Size
    operations as well. All we’ll do is store the size of each community, being sure
    to keep sizes up to date whenever we do a Union. We’ll then be able to respond
    to each Size operation by returning the size of the appropriate community.
  prefs: []
  type: TYPE_NORMAL
- en: Array-Based Approach
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One idea is to use an array `community_of` that indicates the representative
    for each person’s community. For example, if People 1, 2, 4, and 5 are in the
    same community, People 3 and 6 are in the same community, and Person 7 is in their
    own community, then the array might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg341-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For a community of a single person, there is no choice for who is the representative.
    That’s why the representative for Person 7 is 7\. In a community with multiple
    people, the representative is allowed to be any person in the community. For example,
    we’re using 6 as a representative this time, but we could have used 3 instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this scheme, we can implement Find in constant time. All we do is look
    up the representative of the desired person, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can’t do better than that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this scheme breaks down when we implement Union. Our only option
    is to change all representatives for one community to the representative of the
    other community. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I’m ignoring the maximum size restriction on social-network communities here
    so as not to distract from the essentials. The code uses `find` to set `community1`
    and `community2` to the representatives of `person1`’s community and `person2`’s
    community, respectively. It then loops through all people, changing anyone in
    `community1` to `community2`. The effect is that `community1` is gone, having
    been absorbed into `community2`.
  prefs: []
  type: TYPE_NORMAL
- en: If you build and submit a full solution based on the code I’ve given here, you
    should see that it still receives a “Time-Limit Exceeded” error. We need a better
    way to union two communities than looping through all of the people.
  prefs: []
  type: TYPE_NORMAL
- en: Tree-Based Approach
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The most efficient union-find data structures are based on trees. Each set is
    represented as its own tree, with the root of the tree serving as that set’s representative.
    I’ll describe how this works with the help of the example shown in [Figure 9-1](ch09.xhtml#ch09fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: A tree-based union-find data structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three trees here, so there are three distinct communities: one has
    People 1, 2, 4, and 5; one has People 3 and 6; and one has Person 7\. Each tree’s
    roots—People 5, 6, and 7—serve as community representatives.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve drawn the tree edges with an arrow pointing from child to parent. You haven’t
    seen that before in this book. The reason I’m doing it now is to emphasize the
    way that we’ll be navigating these trees. As I describe how to support Find and
    Union in trees, we’ll see that it’s necessary to move up the tree (from child
    to parent) but never down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with Find. Given a person, we have to return that person’s representative.
    We can do that by moving up the appropriate tree until we reach its root element.
    For example, let’s find the representative of Person 1 in [Figure 9-1](ch09.xhtml#ch09fig01).
    Since 1 is not a root, we move to 1’s parent. Person 4 is not a root, so we move
    to 4’s parent. Person 5 is a root, so we’re done: 5 is the representative of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this tree-hopping to what we were able to get away with in “Array-Based
    Approach” on [page 341](ch09.xhtml#ch09lev2z). Rather than simply looking up the
    representative in a single step, we have to move up the tree until we find the
    root. That sounds dicey—what if a tree gets really, really tall?—but we’ll soon
    see that this concern is unfounded, as we’ll be able to keep tree heights under
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s talk about Union. Given two people, we want to unite their two trees.
    In terms of correctness, it doesn’t matter how we jam the two trees together.
    However, as was just mentioned in the context of Find, it helps to keep tree heights
    small. If we insert one tree at the bottom of the other, we might unnecessarily
    increase the height of the resulting tree. To avoid that, we’ll insert one tree
    directly under the root of the other tree. To see how that looks, see [Figure
    9-2](ch09.xhtml#ch09fig02), where I’ve unioned the tree with root 5 and the tree
    with root 6.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: A tree-based union-find data structure after a union*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve chosen to make 6 the root of the combined tree. We could have also chosen
    to make 5 the root of the combined tree. (Here’s a teaser: Why will 5 turn out
    to be the better choice? We’ll see why when we discuss union-find optimizations.)'
  prefs: []
  type: TYPE_NORMAL
- en: We now have enough to design a union-find solution to the Social Network problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Union-Find*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Primed by our discussion of heaps and segment trees in [Chapter 8](ch08.xhtml),
    you may not be surprised that we’re going to store the union-find data structure
    in an array!
  prefs: []
  type: TYPE_NORMAL
- en: Union-find trees are not necessarily binary trees, as their nodes can have any
    number of children. So we won’t be able to move around these trees by multiplying
    and dividing by 2, as we did in [Chapter 8](ch08.xhtml). We’re in luck, though,
    because the only travel we need to support is from a child to its parent. All
    we need is an array that maps from any given node to its parent. We can do that
    with the array `parent`, where `parent[i]` gives the parent of Node `i`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall [Figure 9-1](ch09.xhtml#ch09fig01), where we had three communities:
    one that has People 1, 2, 4, and 5; one with People 3 and 6; and one with Person
    7\. Here’s the `parent` array corresponding to that figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg343-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if we want to find the representative of Person 1’s community? The value
    at index 1 is 4, which tells us that 4 is the parent of 1; the value at index
    4 is 5, which tells us that the parent of 4 is 5; and the value at index 5 is
    5, which means that 5 is the . . . parent of 5? Certainly not! Whenever `parent[i]`
    is the same value as `i`, it means that we’ve reached the root of the tree. (The
    other common trick to distinguish roots is to use a value of `-1`, since that
    can’t be confused with a valid array index. I won’t use that in this book, but
    you may come across it in other code that you find.)
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we’re ready for some code. Let’s start with the `main` function as given
    in [Listing 9-4](ch09.xhtml#ch09ex04). (It’s far briefer than [Listing 9-1](ch09.xhtml#ch09ex01).
    In general, union-find code is compact.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: The* main *function for processing operations*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `parent` array that I’ve already described, there’s a `size`
    array ❶. For each representative `i`, `size[i]` gives the number of people in
    its community. Never look up the size of a community using a nonrepresentative
    person. Once someone isn’t a representative, we won’t keep the `size` value updated
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop is used to initialize `parent` and `size` ➋. For `parent`, we let
    each person be their own representative, which corresponds to having each person
    in their own set. Because each set has just one person, we set each `size` value
    to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: To implement Add, we call the `union_communities` helper function ➌. It unites
    the communities of `person1` and `person2`, subject to the `num_community` size
    constraint. We’ll see its code soon.
  prefs: []
  type: TYPE_NORMAL
- en: To implement Examine, we make two calls to `find` ➍. If both calls return the
    same value, then the people are in the same community; otherwise, they are not.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to implement Size, we use the `size` array, looking up the representative
    of the person’s set ➎.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll next supply implementations of `find` and `union_communities`, and that
    will finish off this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The find Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `find` function takes a person as a parameter and returns that person’s
    representative. See [Listing 9-5](ch09.xhtml#ch09ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: The* find *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop keeps moving up the tree, until it finds a root. That root
    person is the representative of the community, and so it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The union Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `union_communities` function takes two people—in addition to the `parent`
    array, `size` array, and `num_community` constraint—and joins their two communities.
    (I would have called this function `union`, but that’s not allowed because `union`
    is a C reserved word.) See [Listing 9-6](ch09.xhtml#ch09ex06) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: The* union_communities *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we find the representative for each person’s community ❶ ➋. Two conditions
    must be met for a Union to take place: first, the communities must be different;
    second, the sum of the sizes of the two communities must not exceed the maximum-allowed
    community size. If both of these conditions pass, then we perform the Union itself.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen to fold `community1` into `community2`. That is, `community1` will
    be gone, and `community2` will absorb `community1`. To make this happen, we must
    appropriately modify `parent` and `size`.
  prefs: []
  type: TYPE_NORMAL
- en: Before this Union, `community1` was the root of a community, but now we want
    `community1` to have `community2` as its parent. So, that’s precisely what we
    do ➌! Any person whose representative was previously `community1` will now have
    `community2` as their representative.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of `size`, `community2` has all of the people it had before plus all
    of the people that it inherited from `community1`. So the size is what it was
    before with the addition of the size of `community1` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all! Feel free to submit this solution to the judge. It should finish
    within the time limit and pass all test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Somehow, though, I maybe had hoped that it didn’t pass within the time limit—because
    I’m sitting on two ace union-find optimizations here that I really want to teach
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Hey, let’s just do them! This may be overkill for this problem, but they offer
    such a speed boost that we’ll apply them throughout this chapter and never worry
    about time limits again.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimization 1: Union by Size*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our union-find solution generally runs fast, but test cases can be crafted
    to make it crawl. Here’s what the worst kind of test case looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Communities 1 and 2 are merged, that resulting community is merged with Community
    3, that resulting community is merged with Community 4, and so on. After the six
    Unions, we have the tree as depicted in [Figure 9-3](ch09.xhtml#ch09fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: A bad case of a tree-based union-find data structure*'
  prefs: []
  type: TYPE_NORMAL
- en: We have a long chain of nodes and, unfortunately, Finds and Unions may end up
    traversing the entire chain. For example, `E 1 2` would invoke a Find on Person
    1 and a Find on Person 2, each visiting almost every node. Of course, a seven-node
    chain is tiny, but we can replicate the unioning pattern to produce massive chains
    of whatever length we want. We can thereby force Find and Union operations to
    take linear time; with *q* operations in all, we can force our tree-based union-find
    algorithm to take *O*(*q*²) time. This means that, in the worst case, the tree-based
    solution is not theoretically better than the BFS solution. It’s better than BFS
    in practice, because most test cases will not produce long chains of nodes . .
    . but some test cases might!
  prefs: []
  type: TYPE_NORMAL
- en: Hold on! Why are we letting these officious test cases bully us into producing
    these awful trees? We don’t care what the union-find data structure looks like.
    In particular, whenever a Union is requested, we have a choice of which old representative
    becomes the representative of the unioned community. Rather than always folding
    the first community into the second, we should make the choice that produces the
    best tree. Compare the nonsense in [Figure 9-3](ch09.xhtml#ch09fig03) to the wonder
    that is [Figure 9-4](ch09.xhtml#ch09fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: An optimized tree-based union-find data structure*'
  prefs: []
  type: TYPE_NORMAL
- en: Person 2 is the root, and everyone else is exactly one edge away. No matter
    what Union or Find comes next, we’ll be able to perform it very efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: How can our code make [Figure 9-4](ch09.xhtml#ch09fig04) instead of [Figure
    9-3](ch09.xhtml#ch09fig03)? The optimization is called *union by size*. Whenever
    you’re about to union two communities together, union the community with fewer
    people into the community with more people.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test case that we’ve been discussing, we start with `A 1 2`. The two
    communities each have one person, so it doesn’t matter which we choose to keep;
    let’s keep Community 2\. Now Community 2 has two people: the one that it had and
    the one from Community 1\. To do `A 2 3`, we compare the size of Community 2 (two)
    to the size of Community 3 (one). We will keep Community 2 because it is larger
    than Community 3\. Now Community 2 has three people. What about `A 3 4`? This
    gives us another person for Community 2\. We then keep going, absorbing one person
    after another into Community 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Union by size certainly neutralizes the worst test cases, but there are still
    test cases whose trees need some work to go from nodes to roots. Here’s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Union by size produces [Figure 9-5](ch09.xhtml#ch09fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: A bad case of union by size*'
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s true that some nodes are right below the root, there are now nodes
    that are further away (the worst offender being Node 1). Still, the tree is quite
    balanced, and it’s certainly better than the long chain of nodes that we saw prior
    to the union-by-size optimization.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll next show that the maximum height of a tree when using union by size is
    *O*(log *n*), where *n* is the total number of people. This means that a Find
    or Union takes *O*(log *n*) time, because a Find is just a traversal up the tree
    and a Union is just two Finds plus a change of parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s choose some arbitrary node *x* and think about how many times the number
    of edges between *x* and its root can increase. When *x*’s community absorbs another
    community, the number of edges between *x* and its root doesn’t change, because
    the root of its community is the same as it was. However, when *x*’s community
    is absorbed by another community, then the number of edges between *x* and its
    new root is one more than it was before: the path from *x* to its new root is
    what it was before (to get to its old root) plus one more edge to get to its new
    root.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, putting an upper bound on the number of edges between *x* and its
    root amounts to determining the maximum number of times that *x*’s community can
    be absorbed into another community.
  prefs: []
  type: TYPE_NORMAL
- en: Say that *x* is in a community of size four. Could it be absorbed into a community
    that was size two? No way! We’re using union by size, remember. The only way *x*’s
    community can be absorbed into another community is if the other community is
    at least as large as *x*’s. In this example, the other community would have to
    be size four or greater. So we go from a community of size four to a community
    of at least size 4 + 4 = 4 × 2 = 8\. That is, the size of *x*’s community at least
    doubles when it’s absorbed into another community.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off in a community of size one, *x*’s community gets absorbed and now
    it’s in a community of at least size two. It gets absorbed again and now it’s
    in a community of at least size four. Getting absorbed again puts it in a community
    of at least size eight. This doubling can’t continue forever. It has to stop,
    at the latest, when *x*’s community contains all *n* people. Starting from one,
    how many times can we double it before we get to *n*? That’s log *n*, and that’s
    why the number of edges between any node and its root is capped at log *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Using union by size cuts linear runtime to logarithmic runtime. Better still,
    we don’t need much new code to implement this optimization. In fact, for the Social
    Network problem, we’re already maintaining sizes of communities—we can just use
    these sizes to decide which community gets absorbed into the other. [Listing 9-7](ch09.xhtml#ch09ex07)
    gives the new code. Compare the code to [Listing 9-6](ch09.xhtml#ch09ex06) to
    confirm that we’re doing almost the same thing as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: The* union_communities *function using union by size*'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the code chooses `community2` to absorb `community1`. This is the
    right thing to do if `community2` is larger than or the same size as `community1`.
    If the size of `community1` is larger than `community2` ❶, then we swap `community1`
    and `community2` to reverse their roles. After that, `community2` is guaranteed
    to be the bigger community, and we can proceed by absorbing `community1` into
    `community2` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimization 2: Path Compression*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s revisit the test case that produced [Figure 9-5](ch09.xhtml#ch09fig05).
    Only this time, let’s build the tree and then keep spamming the same Examine operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `E 1 5` operation is a little slow, each time requiring lengthy traversals
    to the root. To Find the representative of Person 1, for example, we go from Node
    1 to Node 2 to Node 4 to Node 8\. Now we know that Node 1’s representative is
    Node 8\. We would do a similar traversal for Person 5, but that knowledge is short-lived,
    because we don’t remember that anywhere. Every single `E 1 5` operation causes
    us to redo the work to Find Person 1 and Person 5, just to relearn what we learned
    last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have another opportunity to benefit by controlling the structure of
    the tree. Remember that the particular shape of the tree doesn’t matter: all that
    matters is that people in the same community are present in the same tree. Hence,
    as soon as we’ve determined the root of someone’s community, we might as well
    move that person to be a child of the root. While we’re at it, we might as well
    move that person’s ancestors right below the root, too.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider again [Figure 9-5](ch09.xhtml#ch09fig05), and suppose we next perform
    `E 1 5`. If we were using just the Union-by-size optimization, this Examine operation
    (like any Examine operation) would not change the structure of the tree. Watch
    what happens, though, if we use an optimization called *path compression*, as
    depicted in [Figure 9-6](ch09.xhtml#ch09fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: An example of path compression*'
  prefs: []
  type: TYPE_NORMAL
- en: This is nice, right? Finding Node 1 leads to Nodes 1 and 2 becoming children
    of a root; finding Node 5 leads to Node 5 becoming a child of a root. In general,
    path compression takes every node along a path and puts it as a child of the root
    node. Finding any of those nodes will therefore be extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: To implement path compression in the `find` function, we can make two traversals
    from the provided person to the root of the tree. The first traversal locates
    the root of the tree; that’s the traversal that any `find` function does. The
    second traversal ensures that each node along the path has the root as its parent.
    [Listing 9-8](ch09.xhtml#ch09ex08) implements the new code. Compare it to [Listing
    9-5](ch09.xhtml#ch09ex05) to see that what’s new is the second traversal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: The* find *function with path compression implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: This code works in two phases. The first phase is the first `while` loop ❶,
    which results in `community` holding the representative (the root) of the community.
    With that representative in hand, the second phase, captured by the second `while`
    loop ➋, retraces the path from `person` to just below the root of the tree, updating
    each node’s `parent` to be the tree’s root. The `temp` variable is used to store
    the old parent of the current node. In that way, we can still move to the current
    node’s old parent even after making it the root of the tree. (There’s a shockingly
    concise though cryptic way to code path compression that you might see in the
    wild. Brace yourself, and then check out “Compressing Path Compression” in [Appendix
    B](app02.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: By using both union by size and path compression, it’s still possible that a
    single Union or Find operation takes *O*(log *n*) time. However, taking all Unions
    and Finds together, the average time taken per operation—while not technically
    constant—is essentially constant. The runtime analysis is based on a function
    called the *inverse Ackermann function*, which grows very, very, *very* slowly.
    I won’t define the inverse Ackermann function or show how it arises in the runtime
    analysis, but I’d like to give a sense of how strong this result is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logarithm function grows slowly, so let’s start there. Taking the log of
    a huge number gives back a very small number. For example, log 1,000,000,000 is
    only about 30\. However, the log isn’t a constant: using a sufficiently large
    value of *n*, you can make log *n* as big as you want.'
  prefs: []
  type: TYPE_NORMAL
- en: The inverse Ackermann function is similarly not constant, but, unlike the log
    function, you’ll never in practice get a value of 30 out of it. You can make *n*
    as big as you want, as big as the biggest number representable in your computer,
    and the inverse Ackermann of *n* will be at most 4\. You can think of union-find
    with union by size and path compression as taking an average of just four steps
    per operation!
  prefs: []
  type: TYPE_NORMAL
- en: Union-Find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The union-find data structure turbocharges solutions to graph problems whose
    primary operations are Union and Find. This doesn’t help with problems such as
    those in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml), where we’re required to
    calculate distances between nodes. But when union-find does apply, adjacency lists
    and graph search are overkill and just too slow.
  prefs: []
  type: TYPE_NORMAL
- en: '*Relationships: Three Requirements*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Union-find works on a collection of objects, where each object begins in its
    own set. At all times, objects in the same set are equivalent, whatever “equivalent”
    means for the problem that we’re solving. For example, in the Social Network problem,
    people in the same set (community) are equivalent in the sense that they are all
    friends.
  prefs: []
  type: TYPE_NORMAL
- en: Union-find requires that the relationship between our objects satisfy three
    criteria. First, objects must be related to themselves. In terms of friendships
    from the Social Network, this just means that each person is one’s own friend.
    A relationship that meets this criterion is called *reflexive*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the relationship has to be directionless: we can’t have *x* as a friend
    of *y* and at the same time have *y* as not a friend of *x*. A relationship that
    meets this criterion is called *symmetric*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, the relationship must cascade: if *x* is a friend of *y*, and *y* is
    a friend of *z*, then *x* is a friend of *z*. A relationship that meets this criterion
    is called *transitive*.'
  prefs: []
  type: TYPE_NORMAL
- en: If any of these criteria is not met, then the Union operation we’ve been discussing
    is broken. For example, suppose that we have a friendship relationship where transitivity
    does not hold. If we learn that *x* is a friend of *y*, we have no idea whether
    *x*’s friends are *y*’s friends. We’re therefore not justified in uniting *x*’s
    community and *y*’s community; that might put people in the same set that are
    not in fact friends.
  prefs: []
  type: TYPE_NORMAL
- en: A relationship that is reflexive, symmetric, and transitive is called an *equivalence
    relation*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Choosing Union-Find*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When deciding whether union-find might apply, ask yourself this: What is the
    relationship that I need to maintain between objects? Is it reflexive, symmetric,
    and transitive? If it is, and the primary operations can be mapped to Finds and
    Unions, then you should consider union-find as a viable solution strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: Beneath every union-find problem lies a graph problem that could be modeled
    (less efficiently!) using adjacency lists and graph search. Unlike what we did
    for the Social Network problem, for the remaining problems in this chapter, we
    won’t take the scenic route through graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimizations*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I introduced two union-find optimizations: union by size and path compression.
    They offer protection against bad test cases and generally increase performance
    no matter what the test case. They each take only a few lines of code, so I recommend
    using them whenever you can.'
  prefs: []
  type: TYPE_NORMAL
- en: “Whenever you can” is not to be confused with “always.” Unfortunately, there
    are some union-find problems where these optimizations are not appropriate. I
    haven’t yet encountered a problem where path compression is problematic, but sometimes
    we need to remember the order in which sets are being united, and in those cases
    we can’t swap roots of trees using union by size. You’ll see in Problem 3 an example
    where we can’t use union by size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Friends and Enemies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might worry that the only kind of “Add” operation we can support is like
    that used in the Social Network problem: *x* and *y* are friends; *x* and *y*
    go to the same school; *x* and *y* live in the same city—that kind of thing. It
    turns out that we can support other types of Add information, too. *x* and *y*
    are *not* friends. Hmm . . . that one’s interesting, telling us not that *x* and
    *y* are in the same set but that they are *not* in the same set. How does union-find
    work now? Read on!'
  prefs: []
  type: TYPE_NORMAL
- en: This is UVa problem `10158`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two countries are at war. You have been granted permission to attend their peace
    meetings, during which you can listen to pairs of people talking to each other.
    There are *n* people at these meetings, numbered 0, 1, . . . , *n* – 1\. At first,
    you don’t know anything about who are friends (citizens of the same country) or
    enemies (citizens of opposing countries). Your job is to record information about
    who are friends or enemies and to respond to queries based on what you know so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must support four operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SetFriends**   Record that the two provided people are friends.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SetEnemies**   Record that the two provided people are enemies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AreFriends**   Report whether you know for sure that the two provided people
    are friends.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AreEnemies**   Report whether you know for sure that the two provided people
    are enemies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Friendship is an equivalence relation: it’s reflexive (*x* is a friend of *x*),
    symmetric (if *x* is a friend of *y*, then *y* is a friend of *x*), and transitive
    (if *x* is a friend of *y* and *y* is a friend of *z*, then *x* is a friend of
    *z*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enemyship is not an equivalence relation. It’s symmetric: if *x* is an enemy
    of *y*, then *y* is likewise an enemy of *x*. It’s neither, however, reflexive
    nor transitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a little more we need to know about friendship and enemyship. Suppose
    that *x* has some friends and enemies, *y* has some friends and enemies, and then
    we are told that *x* and *y* are enemies. What have we learned? Well, we learn
    directly that *x* and *y* are enemies—but that’s not all. We can also conclude
    that *x*’s enemies are friends with everyone in *y*’s set. (Suppose that Alice
    and Bob are enemies and that David and Eve are friends—and then we are told that
    Alice and David are enemies. We should conclude that Bob is friends with David
    and Eve.) Similarly, we can conclude that *y*’s enemies are friends with everyone
    in *x*’s set. Here’s this paragraph in one aphorism: the enemy of an enemy is
    a friend.'
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose that *x* has some friends and enemies and that *y* has some friends
    and enemies—but that this time, we are told that *x* and *y* are friends. Here,
    we should additionally conclude that *x*’s enemies and *y*’s enemies are friends.
    (Hang in there. We’ll make all of this concrete as we work through some examples.)
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the total number of people attending the meetings. *n*
    is less than 10,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more lines, one for each operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing three integers, the first of which is 0\. This signifies the
    end of the test case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each operation line has the same format: an operation code followed by two
    people (x and y).'
  prefs: []
  type: TYPE_NORMAL
- en: A SetFriends operation is of the form `1` x y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SetEnemies operation is of the form `2` x y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AreFriends operation is of the form `3` x y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AreEnemies operation is of the form `4` x y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The output for each operation is on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: If a SetFriends operation succeeds, then it produces no output. If it conflicts
    with information that is already known, then output `-1` and ignore the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a SetEnemies operation succeeds, then it produces no output. If it conflicts
    with information that is already known, then output `-1` and ignore the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an AreFriends operation, output `1` if the two people are known to be friends
    and output `0` otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an AreEnemies operation, output `1` if the two people are known to be enemies
    and output `0` otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test case is three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Augmenting Union-Find*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If all we had to deal with were the SetFriends and AreFriends operations, then
    we could directly apply union-find as we did when solving the Social Network problem.
    We’d keep one set for each group of friends. Like Add in Social Network, SetFriends
    would be implemented as a Union and bring together two sets of friends into a
    larger set. Like Examine in Social Network, AreFriends would be implemented as
    a Find on each of the two people to determine whether they’re in the same set.
  prefs: []
  type: TYPE_NORMAL
- en: We could start by solving the problem for just these two operations . . . actually,
    you know what? I’m confident you could solve that restricted problem, right now,
    without anything else from me. Where I may be helpful is in explaining the technique
    for incorporating SetEnemies and AreEnemies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Augmentation: Enemies'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Augmenting* a data structure refers to storing additional information in that
    data structure to support new or faster operations. Maintaining the size of each
    set in a union-find data structure is an example of augmentation: you could implement
    the data structure without it, but with it you can quickly report set sizes and
    perform union by size.'
  prefs: []
  type: TYPE_NORMAL
- en: You should consider augmentation when an existing data structure *almost* does
    what you want. The key is to identify a suitable augmentation that adds the desired
    functionality without appreciably slowing down other operations.
  prefs: []
  type: TYPE_NORMAL
- en: We already have a union-find data structure that supports SetFriends and AreFriends.
    It maintains the parent of each node as well as the size of each set. We’re going
    to augment that data structure to support SetEnemies and AreEnemies. Moreover,
    we’re going to do it without slowing down Set-Friends and AreFriends much at all.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’re told that *x* and *y* are enemies. From the problem description,
    we know that we’re going to have to union *x*’s enemies with *y*’s set and union
    *y*’s enemies with *x*’s set. Who are *x*’s enemies? Who are *y*’s enemies? With
    the standard union-find data structure, we don’t know. This is why we need to
    augment the union-find data structure.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the parent of each node and the size of each set, we’re going
    to keep track of an enemy for each set. We’ll store those enemies in an array
    called `enemy_of`. Suppose that `s` is the representative of some set. If that
    set has no enemies, then we’ll arrange for `enemy_of[s]` to hold a special value
    that can’t be confused with a person. If that set has one or more enemies, then
    `enemy_of[s]` will give us one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s right: *one* of them, not *all* of them. Knowing one enemy of each set
    is enough, because we can use that one enemy to find the representative of everyone
    in that enemy’s set.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now work through two test cases. They’ll prepare us for the implementation
    that follows. The diagrams I will show are conceptual and do not correspond exactly
    to what an implementation might do. In particular, I won’t use union by size or
    path compression in the diagrams, but we’ll throw those optimizations into our
    implementation in the interest of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Test Case 1
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall that the operation code for SetFriends is `1` and the code for SetEnemies
    is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first four operations are SetFriends operations. No one has any enemies
    yet, so these operations play out just as did Add operations in the Social Network
    problem. [Figure 9-7](ch09.xhtml#ch09fig07) shows the state of the data structure
    after these operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: The data structure after four SetFriends operations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have our first SetEnemies operation ❶, and it indicates that People
    1 and 7 are enemies. This means that everyone in 1’s set is enemies with everyone
    in 7’s set. To incorporate this into the data structure, we add links between
    roots of these two sets: a link from 2 (the root of 1’s set) to 7, and a link
    from 7 (the root of 7’s set) to 1\. (You could have decided that the latter should
    instead be a link from 7 to 2; that would be fine as well.) The result of this
    operation is shown in [Figure 9-8](ch09.xhtml#ch09fig08). In this and subsequent
    figures, enemy links are realized as dashed lines; in our implementation, enemy
    links will be realized as the aforementioned `enemy_of` array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: The data structure after a SetEnemies operation*'
  prefs: []
  type: TYPE_NORMAL
- en: Next is a SetEnemies operation between People 5 and 8 ➋; performing this operation
    might result in [Figure 9-9](ch09.xhtml#ch09fig09).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: The data structure after another SetEnemies operation*'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time for the final operation ➌, which says that People 2 and 5 are
    friends. This unites 2’s set and 5’s set into one larger set of friends, as expected.
    The surprise, perhaps, is that we also unite two enemy sets. Specifically, we
    unite the enemies of Person 2’s set with the enemies of Person 5’s set. After
    all, if we know that two people are in the same country, then each of their enemy
    sets must be together in the other country. The result of performing these *two*
    Union operations is shown in [Figure 9-10](ch09.xhtml#ch09fig010).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: The data structure after a final SetFriends operation*'
  prefs: []
  type: TYPE_NORMAL
- en: The reason I haven’t drawn enemy links from Person 2 to Person 7 and from Person
    7 to Person 1 is because we maintain enemy links only from root nodes. Once a
    node is no longer a root, we’ll never use it again to find enemies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two key things can be learned from this test case: that one enemy of a set
    is stored at that set’s root and that a SetFriends operation requires two Unions,
    not one. Now, what do we do when a set already has an enemy and then that set
    is involved in a SetEnemies operation? That’s where our next test case comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: Test Case 2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our second test case differs from the first only in its final operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Prior to the final operation, the data structure appears as depicted in [Figure
    9-9](ch09.xhtml#ch09fig09). The final operation ❶ is now a SetEnemies operation
    rather than a SetFriends operation. Person 2’s set already has an enemy, and now
    it has new enemies from Person 5’s set. Hence we need to unite Person 2’s enemies
    with Person 5’s set. Similarly, Person 5’s set already has an enemy and now has
    new enemies from Person 2’s set, so we need to unite Person 5’s enemies with Person
    2’s set.
  prefs: []
  type: TYPE_NORMAL
- en: The result of these two Unions is shown in [Figure 9-11](ch09.xhtml#ch09fig011).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: The data structure after a final SetEnemies operation*'
  prefs: []
  type: TYPE_NORMAL
- en: Having laid this background, we’re ready for an implementation!
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the `main` function, which is given in [Listing 9-9](ch09.xhtml#ch09ex09).
    It reads the input, and it calls one helper function for each of the four operations
    that we’re supporting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: The* main *function for processing operations*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, as part of the initialization, we set each `enemy_of` value to
    `-1` ❶. That’s our special value to indicate “no enemy.”
  prefs: []
  type: TYPE_NORMAL
- en: To implement SetFriends ➋, we first check whether the two people are already
    known to be enemies. If they are, we output `-1`; if they aren’t, we call the
    `set_friends` helper function. The implementation of SetEnemies ➌ follows the
    same pattern. For AreFriends ➍ and AreEnemies ➎, we call a helper function to
    determine whether the condition is true or false, and we output `1` or `0` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Find and Union*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll present the Find and Union functions here; they’ll be called by our helper
    functions, `set_friends`, `set_enemies`, `are_friends`, and `are_enemies`. The
    Find function is given in [Listing 9-10](ch09.xhtml#ch09ex010). We’ve got path
    compression in there!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: The* find *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Union function is given in [Listing 9-11](ch09.xhtml#ch09ex011). Union
    by size: you better believe it!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: The* union_sets *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Union function does have one feature not present in our prior Union code:
    it returns the representative of the resulting set ❶. We’ll turn to the SetFriends
    operation next, and you’ll see there that we use this return value.'
  prefs: []
  type: TYPE_NORMAL
- en: '*SetFriends and SetEnemies*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SetFriends operation is implemented in [Listing 9-12](ch09.xhtml#ch09ex012).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12: Recording that two people are friends*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by determining the representative of each of the two people: `set1`
    is the representative of `person1` ❶ and `set2` is the representative of `person2`
    ➋. Since these two sets of people are now supposed to be all friends with each
    other, we unite them into a bigger set ➌. We store the return value of `union_sets`
    in `bigger_set`; we’ll use that soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now unioned `person1`’s set and `person2`’s set, but we’re not done,
    because—remember this from our first test case—we might have to union some enemies
    together as well. Specifically, if `set1` has enemies and `set2` has enemies,
    then we need to union those enemies into a single, bigger set. That’s just what
    the code does: if both sets have enemies ➍, we union those enemy sets ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to think that we’re done at this point. We’ve performed the required
    union of friends and union of enemies—what else is there to do? Well, imagine
    that `set1` has some enemies and that `set2` does not. The representative of `set2`
    therefore has an `enemy_of` value of `-1`. Now, maybe `set1` ends up being folded
    into `set2` so that `set2` is the bigger set. If we just call it a day here and
    do nothing else, then `set2` will not be able to find its enemies! The `enemy_of`
    value for `set2`’s representative is still `-1`—and that’s wrong, because `set2`
    *does* have enemies now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we handle this in the code. We already have `bigger_set`, indicating
    which set—`set1` or `set2`—resulted from unioning `set1` and `set2`. We use an
    if–else to set `other_set` to the other set ➏: if `bigger_set` is `set1`, then
    `other_set` will be `set2`, and vice versa. Then, if `bigger_set` has no enemies
    ❼, we copy over the enemy link from `other_set`. The result is that `bigger_set`
    is guaranteed to be able to find its enemies if `set1` or `set2` or both had enemies.'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time for SetEnemies. Check it out in [Listing 9-13](ch09.xhtml#ch09ex013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13: Recording that two people are enemies*'
  prefs: []
  type: TYPE_NORMAL
- en: We again begin by finding the representatives of each set, storing them in `set1`
    and `set2`, respectively. We then look up an enemy of `set1` ❶. If `set1` has
    no enemy, then we set `person2` to be its enemy ➋. If `set1` does have an enemy,
    then we’re in the territory of our second test case. We union `set1`’s enemies
    with `person2`’s set ➌, which ensures that `person2` and all of `person2`’s friends
    are all enemies of `person1`.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of `set1`. Now we do likewise for `set2` ➍, setting its enemy
    to be `person1` if it doesn’t have an enemy yet or otherwise unioning its enemies
    with `person1`’s set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Importantly, this function maintains the symmetry of the enemy relationship:
    if from `person1` we can find enemy `person2`, then from `person2` we can find
    enemy `person1`. Consider a given call of `set_enemies` on `person1` and `person2`.
    If `person1` has no enemies, then its enemy becomes `person2`, but if `person1`
    has enemies, its enemy set grows to include `person2`. Symmetrically, if `person2`
    has no enemies, then its enemy becomes `person1`, and if `person2` has enemies,
    then its enemy set grows to include `person1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*AreFriends and AreEnemies*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AreFriends operation amounts to checking whether the two people are in the
    same set or, equivalently, whether they have the same representative. This can
    be accomplished with two calls to Find, as shown in [Listing 9-14](ch09.xhtml#ch09ex014).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14: Determining whether two people are friends*'
  prefs: []
  type: TYPE_NORMAL
- en: We have just one more operation to go! We can implement AreEnemies by checking
    whether one person is in the other person’s set of enemies. The code is given
    in [Listing 9-15](ch09.xhtml#ch09ex015).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-15: Determining whether two people are enemies*'
  prefs: []
  type: TYPE_NORMAL
- en: Two things must be true for `person2` to be an enemy of `person1` ❶. First,
    `person1` must have an enemy. Second, `person2` must be in its set of enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Hey! Shouldn’t we also check whether `person1` is an enemy of `person2`? No,
    that’s not needed, because the enemy relationship is symmetric. If `person2` is
    not an enemy of `person1`, then there’s no point checking whether `person1` is
    an enemy of `person2`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We have successfully augmented the vanilla union-find data structure
    to incorporate both friend and enemy information. If you submit your code to the
    judge, you should pass all test cases. What about exceeding the time limit? With
    union by size and path compression in there, the time limit can’t stop us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Drawer Chore'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Social Network and Friends and Enemies problems, we were able to use
    both union by size and path compression to speed up our implementations. In this
    next problem, we’ll attach more meaning to the root of each set. We won’t be able
    to use union by size, because the choice of root matters. Think about why this
    is as you read the problem description!
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `coci13c5p6`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mirko has *n* items strewn around his room and *d* empty drawers. The items
    are numbered 1, 2, . . . , *n*; the drawers are numbered 1, 2, . . . , *d*. Each
    drawer can hold at most one item. Mirko’s goal is to consider each item in turn,
    placing it in a drawer if possible and throwing it away if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item has exactly two drawers in which it is allowed to be placed: Drawer
    A and Drawer B. (It’s for organizational purposes. We wouldn’t want to put the
    Halloween candy with the ants, after all.) For example, we might be allowed to
    place item 3 in Drawer 7 (A) or Drawer 5 (B).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine what happens with each item, we use the following five rules in
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: If Drawer A is empty, put the item in Drawer A and stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If Drawer B is empty, put the item in Drawer B and stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If Drawer A is full, move the existing item in Drawer A to its other drawer;
    if that drawer is full, too, move its existing item to its other drawer; and so
    on. If this process would terminate, place the item in Drawer A and stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If Drawer B is full, move the existing item in Drawer B to its other drawer;
    if that drawer is full, too, move its existing item to its other drawer; and so
    on. If this process would terminate, place the item in Drawer B and stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have failed to place the item using the first four rules, we throw the
    item away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of Rules 3 and 4, placing an item may result in other items moving to
    their other drawers.
  prefs: []
  type: TYPE_NORMAL
- en: We need to output whether each item is kept or thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of items, and *d*, the number of drawers.
    *n* and *d* are between 1 and 300,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one for each item. Each line contains two integers *a* and *b*,
    indicating that this item’s Drawer A is *a* and Drawer B is *b*. *a* will not
    be the same integer as *b*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The output for each item is on its own line. For each item, output `LADICA`
    if it is placed in a drawer and `SMECE` if it is thrown away. (These words come
    from the original COCI problem description: *ladica* is the Croatian word for
    drawer and *smece* is the Croatian word for trash.)'
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is one second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Equivalent Drawers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s an interesting scenario: We place a new item in Drawer 1—but, uh-oh,
    Drawer 1 happens to be full. Its existing item’s other drawer is Drawer 2\. So
    we move that existing item to Drawer 2 and, uh-oh again, Drawer 2 is full. Its
    existing item’s other drawer is Drawer 6\. Ugh—Drawer 6 is full, too! We move
    its existing item to its other drawer, Drawer 4\. Phew! Drawer 4 is empty, so
    we stop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of ultimately filling Drawer 4, we moved three existing items:
    from Drawer 1 to 2, from Drawer 2 to 6, and finally from Drawer 6 to 4\. However,
    those particular moves won’t matter to us. All we’ll need to know is that Drawer
    4 ends up filled.'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to adding the new item, what Drawers 1, 2, 6, and 4 had in common is that
    if you try to place an item in any one of them, Drawer 4 ends up getting filled.
    This is the sense in which these four drawers are equivalent. For example, if
    you place an item in Drawer 4 directly, then Drawer 4 is filled right away. If
    you place an item in Drawer 6, Drawer 6’s existing item moves to Drawer 4 and
    again Drawer 4 is filled. This pattern also holds if you place an item in Drawer
    2 and, as we saw at the start of this example, if you place an item in Drawer
    1\. Drawer 4 is an empty drawer where the chain of drawers terminates and, thinking
    ahead to our union-find data structure, we see that this will be the representative
    of its set. Our set representatives will always be empty drawers; every other
    drawer in a set will be full.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make all of this concrete, let’s work through two test cases. In the first
    one, we’ll have `LADICA` everywhere: we’ll be able to place each item in a drawer.
    In the second, we’ll see some `SMECE`: there are some items that we will not be
    able to place.'
  prefs: []
  type: TYPE_NORMAL
- en: Test Case 1
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s our first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seven drawers, each of which starts empty and in its own set. I’ll
    place each set on its own line and highlight each set’s representative in italics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*4*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good time to refresh your memory of the rules from the problem description
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first item is `1 2`; that’s a Drawer A of 1 and a Drawer B of 2\. Since
    Drawer 1 is empty, this item is placed in Drawer 1 (using Rule 1). In addition,
    Drawers 1 and 2 end up in the same set: placing a new item into Drawer 1 or Drawer
    2 would result in the same drawer, Drawer 2, being filled. Here’s our next snapshot
    of the sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 *2*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*4*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*6*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the new set has Drawer 2 as its representative. Using Drawer 1 as its
    representative would be incorrect: it would erroneously indicate that Drawer 1
    is empty! This is why we won’t use union by size: it might choose the wrong root
    to be the representative of the resulting set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the second item: `2 6`. Drawer 2 is empty, so we place this item
    there (using Rule 1 again). Now placing an item in Drawer 1, 2, or 6 would result
    in Drawer 6 being filled, so we union Drawers 1 and 2 with Drawer 6:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 *6*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*4*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: Drawer 6 is empty, so placing an item in Drawer 6 fills it immediately. Placing
    an item in Drawer 2 causes that drawer’s existing item to move to Drawer 6, again
    filling Drawer 6\. Placing an item in Drawer 1 causes its existing item to move
    to Drawer 2, and Drawer 2’s existing item to move to Drawer 6 . . . , so Drawer
    6 is filled again. That’s why we’re justified in putting all three of these drawers
    in the same set, with Drawer 6 as its representative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next item is `6 4`. We know what to do (using Rule 1 again):'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 *4*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next item is `5 3`. Again, this poses no problem (using Rule 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 *4*
  prefs: []
  type: TYPE_NORMAL
- en: 5 *3*
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every item we’ve processed so far has succeeded by using Rule 1\. Of course,
    that need not be the case, as is evinced by the next item: `5 7`. Rule 1 does
    not apply, because Drawer 5 is already full. Rule 2 does apply, though, because
    Drawer 7 is empty. This item is therefore placed in Drawer 7\. The empty drawer
    of the unioned set is Drawer 3, so that’s our representative, as shown in the
    next snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 *4*
  prefs: []
  type: TYPE_NORMAL
- en: 5 7 *3*
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more item to go, and it’s a fun one: `2 5`. Does Rule 1 apply?
    No, because Drawer 2 is full. Does Rule 2 apply? No, because Drawer 5 is full.
    Does Rule 3 apply? Yes! It applies because Drawer 2’s set has an empty drawer
    (Drawer 4). How do we proceed?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument in this case is that Drawer 2’s set and Drawer 5’s set should
    be unioned, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 4 5 7 *3*
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll explain why this works. The `2 5` item ends up placed in Drawer 2: existing
    items move from Drawer 2 to Drawer 6 and move from Drawer 6 to Drawer 4\. Drawer
    4 is now filled, so it can’t be the representative of its set anymore. In fact,
    the only relevant, empty drawer is Drawer 3, so we’re really hoping that Drawer
    3 can serve as the set representative. Drawers 5, 7, and 3 should certainly be
    in the same set: placing an item in any of them ultimately fills Drawer 3, because
    they were in the same set prior to us introducing the `2 5` item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It remains to explain why Drawers 1, 2, 6, and 4 should be in Drawer 3’s set,
    as well. Drawer 2 is fine: placing an item in Drawer 2 moves its existing item
    to Drawer 5\. Drawer 5 is in Drawer 3’s set, so we know what happens from here:
    Drawer 3 will end up filled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawer 1 is fine, too: placing an item in Drawer 1 moves its existing item
    to Drawer 2, and from here we can use the previous paragraph to argue that Drawer
    3 will be filled. Similar logic applies to Drawers 6 and 4\. For example, if we
    place an item in Drawer 4 and then we “undo” the moves that occurred when we filled
    Drawer 2, Drawer 4’s existing item moves back to Drawer 6, Drawer 6’s existing
    item moves back to Drawer 2, and now we’re back in the case in the previous paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item in this test case is placed in a drawer, so the correct output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s extract a general principle from this test case. Say we’re processing
    item `x y` and that the item ends up in `x`’s set. Then we union `x`’s set and
    `y`’s set, keeping `y`’s representative as the representative of the union.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this correct? Think about what happens when we try to place an item in
    the unioned set, whose components are `x`’s old set and `y`’s old set. Placing
    it in some drawer of `y`’s set still fills `y`’s representative, because we haven’t
    messed with `y`’s set at all. Placing it in drawer `x` fills `y`’s representative,
    too, because we move `x`’s existing item to `y`, and then we’re back in the case
    of placing an item in a drawer of `y`’s set. The only remaining option is that
    the new item is placed in drawer `z` (which is different from `x`) in `x`’s set.
    There is a chain of drawers from drawer `z` to drawer `x`; moving items along
    that chain will fill drawer `x`, and from there `y`’s representative will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: What if we’re processing item `x y`, and the item ends up in `y`’s set? In this
    case, the roles of the two sets are reversed. In particular, we’ll keep the representative
    of `x`’s set as the representative of the union set.
  prefs: []
  type: TYPE_NORMAL
- en: Test Case 2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s see how some `SMECE` can arise. Here’s our second test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three items are `LADICA`s and result in a familiar state:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 *4*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here’s something different: item `1 4` ❶. For the first time, we see an
    item whose Drawer A and Drawer B are in the *same* set. It therefore provides
    no new empty drawer for this set. That is, using Rule 2 fills Drawer 4 (so it’s
    a `LADICA`), but it gives us no set to union. Drawers 1, 2, 6, and 4 enter a new
    kind of state, whereby it becomes impossible to successfully place an item in
    any of them! If you try, you will cycle items around forever. For example, try
    to place an item in Drawer 1\. We can push Drawer 1’s existing item to Drawer
    2, then push Drawer 2’s existing item to Drawer 6, then push Drawer 6’s existing
    item to Drawer 4, Drawer 4’s existing item gets pushed to Drawer 1, Drawer 1’s
    existing item to Drawer 2, Drawer 2’s existing item to Drawer 6, and so on and
    so on, until I hit my book’s page limit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our implementation, we’re going to flag this state by giving this set a
    representative of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 4 *0*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re dangerously close to a `SMECE`. If any item comes along, both of
    whose drawers are in this set, then there’s no way to place it. Look at our next
    item: `2 4`. Can we place it in Drawer 2? No; it’s full. What about Drawer 4?
    No; it’s also full. Can we follow a chain of drawers from Drawer 2 to find an
    empty drawer? No. Is there a chain of drawers from Drawer 4 to an empty drawer?
    No. Four strikes. `SMECE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we have item `1 7`. This will be processed by using Rule 2\. We
    therefore perform a Union (because it’s a `LADICA`)—but watch out: because it’s
    another Union that gives us a set without an empty drawer! Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 6 4 7 *0*
  prefs: []
  type: TYPE_NORMAL
- en: '*3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final item is `7 6`, and that’s another `SMECE` because none of the four
    `LADICA` rules apply: Drawers 7 and 6 are in the same set, and that set has no
    empty drawer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct output for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only rule we haven’t explored in our test cases is Rule 4\. I encourage
    you to play around with Rule 4 a bit before continuing. In particular, you can
    verify that whenever you apply Rule 4, the representative of the unioned set will
    be 0.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s implementation time!
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the `main` function, which reads each item from the input and
    processes it. The code is given in [Listing 9-16](ch09.xhtml#ch09ex016).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-16: The* main *function for processing items*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the `parent` array records the parent of each node in the union-find
    data structure. Items are numbered starting from 1, so it’s safe for us to use
    a representative of 0 for the drawers that can never have a new item placed in
    them. We give 0 a representative of 0 ❶ to indicate that this set, like all other
    sets, starts out empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at those five rules. We implement each of the four `LADICA`
    rules with one call to `find` and one call to `union`. If none of these rules
    applies, then we’re in the `SMECE` case. Let’s go through each `LADICA` rule in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: For Rule 1, we need to know whether `drawer_a` is empty. Remember that each
    set of drawers (not including the “0” set) has exactly one empty drawer and that
    this empty drawer is the representative of the set. The `find` function returns
    the representative of the given set. Putting these two facts together, we see
    that `find` returns `drawer_a` exactly when `drawer_a` is empty ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are in the Rule 1 case, then we need to union `drawer_a`’s set with `drawer_b`’s
    set. We therefore call `union_sets` ➌. Careful, though: remember that we must
    make `drawer_b`’s representative be the representative of the new set, because
    `drawer_a`’s set has no empty drawers now that `drawer_a` is full. To make that
    happen, we’ll use an implementation of `union_sets` that does not perform union
    by size. It guarantees that the representative of the second parameter that we
    pass—`drawer_b` here—will be the representative of the unioned set. It’s also
    responsible for outputting the `LADICA` message. We’ll see that code in the next
    subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: For Rule 2, we need to know if `drawer_b` is empty. We again use `find` to check
    this ➍, and we perform the Union operation if this rule applies ➎. This time,
    we call `union_sets` with the drawers in the opposite order so that `drawer_a`’s
    representative becomes the representative of the unioned set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Rule 3, we need to know whether `drawer_a`’s set has an empty drawer. A
    set has an empty drawer unless the set’s representative is 0\. We use `find` to
    check this condition ➏: if `find` returns a representative other than 0, then
    this set has an empty drawer. If this rule applies, then we perform the expected
    Union ❼. We’ll see in the next subsection how `union_sets` is responsible for
    appropriately moving sets to the “0” set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for Rule 4, we need to know whether `drawer_b`’s set has an empty
    drawer. The logic is the same as that for Rule 3: use `find` to check whether
    this set has an empty drawer ❽; if it does, perform the Union ❾.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Find and Union*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Find function is given in [Listing 9-17](ch09.xhtml#ch09ex017). It uses
    path compression. That’s a good thing, because I just submitted a solution without
    path compression and I received a “Time-Limit Exceeded” error. #PathCompressionWins.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-17: The* find *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The Union function is given in [Listing 9-18](ch09.xhtml#ch09ex018).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-18: The* union_sets *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As promised, there’s no union by size here: we always use `set2`, the set of
    `drawer2`, as the new set ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, whenever an item is placed whose drawers are in the same set ➋,
    we set the representative of the resulting set to `0` ➌. Whenever `find` is later
    called on any element of this resulting set, `0` will be returned, correctly indicating
    that no item can ever be placed in this set again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There we have it: a 50-line union-find solution to one of the most challenging
    problems in this book. Please submit your code to the judge!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned how to efficiently implement the union-find data
    structure. Of all the data structures in this book, the union-find data structure
    is the one that surprises me most with the breadth of its applications. “Really?
    This is a union-find problem?” I frequently have that thought. Perhaps you similarly
    had that thought when we solved Friends and Enemies or Drawer Chore. In any case,
    you’re likely to encounter other problems, seemingly quite different from those
    that I presented here, where union-find nevertheless applies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Happily, given its wide applicability and speedy performance, we don’t need
    huge amounts of code to implement union-find: just a few lines for Union and a
    few lines for Find. In addition, you may find that the code isn’t too tricky,
    once we’ve learned about the array representation for the trees. Even the optimizations,
    union by size and path compression, require little code.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawer Chore is originally from the 2013 Croatian Open Competition in Informatics,
    Round 5\. I found the “0 representative” idea from the COCI website (see *[http://hsin.hr/coci/archive/2013_2014](http://hsin.hr/coci/archive/2013_2014)*).
  prefs: []
  type: TYPE_NORMAL
