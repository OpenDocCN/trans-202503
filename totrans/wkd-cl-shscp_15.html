<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_313"/><span class="big"><strong>14</strong></span><br/><strong>IMAGEMAGICK AND WORKING WITH GRAPHICS FILES</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">The command line has an extraordinary range of capabilities in the Linux world, but because it’s text based, there’s not much you can do with graphics. Or is there?</p>&#13;
<p class="indent">It turns out that a hugely powerful suite of command line utilities, ImageMagick, is available for just about every command line environment, from OS X to Linux to many more. To use the scripts in this chapter, you’ll need to download and install the suite from <em><a href="http://www.imagemagick.org/">http://www.imagemagick.org/</a></em> or from a package manager such as <code>apt</code>, <code>yum</code>, or <code>brew</code>, if you didn’t already do so in <a href="ch13.xhtml#ch13lev1sec03">Script #91</a> on <a href="ch13.xhtml#page_304">page 304</a>.</p>&#13;
<p class="indent">Because the utilities are designed to work on the command line, they require very little disk space, coming in at 19MB or so (for the Windows release). You can also get the source code if you want to dive into some powerful and flexible software. Open source for the win, again.</p>&#13;
<h3 class="h3" id="ch14lev1sec01"><span epub:type="pagebreak" id="page_314"/><strong>#94 A Smarter Image Size Analyzer</strong></h3>&#13;
<p class="noindenta">The <code>file</code> command offers the ability to ascertain the file type and, in some cases, the dimensions of an image. But too often it fails:</p>&#13;
<pre class="programs">$ <span class="codestrong">file * | head -4</span>&#13;
100_0399.png:    PNG image data, 1024 x 768, 8-bit/color RGBA, non-interlaced&#13;
8t grade art1.jpeg:  JPEG image data, JFIF standard 1.01&#13;
99icon.gif:          GIF image data, version 89a, 143 x 163&#13;
Angel.jpg:           JPEG image data, JFIF standard 1.01</pre>&#13;
<p class="indent">PNG and GIF files work, but what about the more common JPEG? The <code>file</code> command can’t figure out the image’s dimensions. Annoying!</p>&#13;
<h4 class="h4" id="ch14lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">Let’s fix that with a script (<a href="ch14.xhtml#ch14ex1">Listing 14-1</a>) that uses the <code>identify</code> tool from ImageMagick to far more accurately ascertain image dimensions.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # imagesize--Displays image file information and dimensions using the&#13;
   #   identify utility from ImageMagick&#13;
&#13;
   for name&#13;
   do&#13;
<span class="ent">➊</span>   identify -format "%f: %G with %k colors.\n" "$name"&#13;
   done&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch14ex1"/><em>Listing 14-1: The</em> <code><em>imagesize</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">When you use the <code>-verbose</code> flag, the <code>identify</code> tool extracts an extraordinary amount of information about each image analyzed, as shown in its output for just one PNG graphic:</p>&#13;
<pre class="programs">$ <span class="codestrong">identify -verbose testimage.png</span>&#13;
Image: testimage.png&#13;
  Format: PNG (Portable Network Graphics)&#13;
  Class: DirectClass&#13;
  Geometry: 1172x158+0+0&#13;
  Resolution: 72x72&#13;
  Print size: 16.2778x2.19444&#13;
  Units: Undefined&#13;
&#13;
  --<span class="codeitalic">snip</span>--&#13;
&#13;
  Profiles:&#13;
    Profile-icc: 3144 bytes&#13;
      IEC 61966-2.1 Default RGB colour space - sRGB&#13;
  Artifacts:&#13;
    verbose: true&#13;
  Tainted: False&#13;
  Filesize: 80.9KBB&#13;
  Number pixels: 185KB&#13;
  Pixels per second: 18.52MB&#13;
  User time: 0.000u&#13;
  Elapsed time: 0:01.009&#13;
  Version: ImageMagick 6.7.7-10 2016-06-01 Q16 http://www.imagemagick.org&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>That’s a lot of data. Too much data, you might think. But without the <code>-verbose</code> flag, the output is rather cryptic:</p>&#13;
<pre class="programs">$ <span class="codestrong">identify testimage.png</span>&#13;
testimage.png PNG 1172x158 1172x158+0+0 8-bit DirectClass 80.9KB 0.000u&#13;
0:00.000</pre>&#13;
<p class="indent">We want a happy medium, and getting there is where the output format string is helpful. Let’s look more closely at <a href="ch14.xhtml#ch14ex1">Listing 14-1</a>, focusing on the only meaningful line in the script <span class="ent">➊</span>.</p>&#13;
<p class="indent">The <code>-format</code> string has almost 30 options, allowing you to extract specific data you want from one or many images in exactly the format desired. We’re tapping into <code>%f</code> for the original filename, <code>%G</code> as a shortcut for width × height, and <code>%k</code> as a calculated value for the maximum number of colors used in the image.</p>&#13;
<p class="indent">You can learn more about the <code>-format</code> options at <em><a href="http://www.imagemagick.org/script/escape.php">http://www.imagemagick.org/script/escape.php</a></em>.</p>&#13;
<h4 class="h4" id="ch14lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">ImageMagick does all the work, so this script is mostly just a way to encode the specific output format desired. Getting info on your images is fast and easy, as <a href="ch14.xhtml#ch14ex2">Listing 14-2</a> shows.</p>&#13;
<h4 class="h4" id="ch14lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">imagesize * | head -4</span>&#13;
100_0399.png: 1024x768 with 120719 colors.&#13;
8t grade art1.jpeg: 480x554 with 11548 colors.&#13;
dticon.gif: 143x163 with 80 colors.&#13;
Angel.jpg: 532x404 with 80045 colors.&#13;
$</pre>&#13;
<p class="listcap"><a id="ch14ex2"/><em>Listing 14-2: Running the</em> <code><em>imagesize</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Currently, we see the pixel size and available color set of the image, but a very useful addition would be the file size. However, any more information would be hard to read unless a little reformatting of the output is done.</p>&#13;
<h3 class="h3" id="ch14lev1sec02"><span epub:type="pagebreak" id="page_316"/><strong>#95 Watermarking Images</strong></h3>&#13;
<p class="noindenta">If you’re looking to protect your images and other content when you post online, you’re bound to be disappointed. Anything online is open to copying, no matter if you have a password, use a strong copyright notice, or even add code to your website that tries to inhibit users from saving individual images. The fact is that for a computer to be able to render anything online, it has to use the image buffer on the device, and that buffer can then be duplicated through a screen capture or similar tool.</p>&#13;
<p class="indent">But all is not lost. You can do two things to protect your online images. One is to only post small image sizes. Look at professional photographers’ sites and you’ll see what we mean. Usually they share only thumbnails because they want you to buy the larger image file.</p>&#13;
<p class="indent">Watermarking is another solution, though some artists balk at the work of adding a copyright image or other identifying information directly to the photograph. But with ImageMagick, adding watermarks is easy, even in bulk, as shown in <a href="ch14.xhtml#ch14ex3">Listing 14-3</a>.</p>&#13;
<h4 class="h4" id="ch14lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # watermark--Adds specified text as a watermark on the input image,&#13;
   #   saving the output as image+wm&#13;
&#13;
   wmfile="/tmp/watermark.$$.png"&#13;
   fontsize="44"                          # Should be a starting arg&#13;
&#13;
   trap "$(which rm) -f $wmfile" 0 1 15    # No temp file left behind&#13;
&#13;
   if [ $# -ne 2 ] ; then&#13;
     echo "Usage: $(basename $0) imagefile \"watermark text\"" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -r "$1" ] ; then&#13;
     echo "$(basename $0): Can't read input image $1" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # To start, get the dimensions of the image.&#13;
&#13;
<span class="ent">➊</span> dimensions="$(identify -format "%G" "$1")"&#13;
&#13;
   # Let's create the temporary watermark overlay.&#13;
&#13;
<span class="ent">➋</span> convert -size $dimensions xc:none -pointsize $fontsize -gravity south \&#13;
     -draw "fill black text 1,1 '$2' text 0,0 '$2' fill white text 2,2 '$2'" \&#13;
     $wmfile&#13;
&#13;
   # Now let's composite the overlay and the original file.&#13;
<span class="ent">➌</span> suffix="$(echo $1 | rev | cut -d. -f1 | rev)"&#13;
   prefix="$(echo $1 | rev | cut -d. -f2- | rev)"&#13;
&#13;
   newfilename="$prefix+wm.$suffix"&#13;
<span class="ent">➍</span> composite -dissolve 75% -gravity south $wmfile "$1" "$newfilename"&#13;
&#13;
   echo "Created new watermarked image file $newfilename."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_317"/><a id="ch14ex3"/><em>Listing 14-3: The</em> <code><em>watermark</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Just about all the confusing code in this script is courtesy of ImageMagick. Yes, it’s doing complicated things, but even then, there’s something about how it’s designed and documented that makes ImageMagick a challenge to work with. Still, don’t be tempted to throw out the proverbial baby with the bathwater because the features and functionality of the various ImageMagick tools are amazing and well worth the learning curve.</p>&#13;
<p class="indent">The first step is to get the dimensions of the image <span class="ent">➊</span> so that the water-mark overlay will have exactly the same dimensions. Bad things happen if they don’t match!</p>&#13;
<p class="indent">The <code>"%G"</code> produces width × height, which is then given to the <code>convert</code> program as the size of the new canvas to produce. The <code>convert</code> line at <span class="ent">➋</span> is one we copied from the ImageMagick documentation because, quite frankly, it’s tricky to get just right from scratch. (To learn more about the specifics of the <code>convert -draw</code> parameter language, we encourage you to do a quick online search. Or you can just copy our code!)</p>&#13;
<p class="indent">The new filename should be the base filename with <code>"+wm"</code> added, and that’s what the three lines at <span class="ent">➌</span> accomplish. The <code>rev</code> command reverses its input character by character so that the <code>cut -d. -f1</code> gets the filename suffix, since we don’t know how many dots are going to appear in the filename. Then the suffix is reordered the right way and <code>"+wm."</code> is added.</p>&#13;
<p class="indent">Finally, we use the <code>composite</code> utility <span class="ent">➍</span> to pull the pieces together and make our watermarked image. You can experiment with different <code>-dissolve</code> values to make the overlay more or less opaque.</p>&#13;
<h4 class="h4" id="ch14lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The script takes two arguments: the name of the image to watermark and the text of the watermarking sequence itself. If the watermark will be more than a single word, make sure the entire phrase is in quotes so it transfers properly, as <a href="ch14.xhtml#ch14ex4">Listing 14-4</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">watermark test.png "(C) 2016 by Dave Taylor"</span>&#13;
Created new watermarked image file test+wm.png.</pre>&#13;
<p class="listcap"><a id="ch14ex4"/><em>Listing 14-4: Running the</em> <code><em>watermark</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec09"><span epub:type="pagebreak" id="page_318"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The result is shown in <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>.</p>&#13;
<div class="image"><img src="../images/f14-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch14fig1"/><em>Figure 14-1: Image with automatically applied watermark</em></p>&#13;
<p class="indent">If you run into an <code>unable to read font</code> error, then you are likely missing the Ghostscript software suite (common on OS X). To remedy this, install Ghostscript with your package manager. For example, use this command to install the <code>brew</code> package manager on OS X:</p>&#13;
<pre class="programs">$ <span class="codestrong">brew install ghostscript</span></pre>&#13;
<h4 class="h4" id="ch14lev2sec10"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">The font size used for the watermark should be a function of the size of the image. If the image is 280 pixels wide, a 44-point watermark would be too big, but if the image is 3800 pixels wide, 44 points might be too small. Choosing an appropriate font size or text placement can be left to the user by adding it to the script as another parameter.</p>&#13;
<p class="indent">ImageMagick also knows the fonts on your system, so it would be helpful to allow users to specify a font by name to use as the watermark.</p>&#13;
<h3 class="h3" id="ch14lev1sec03"><strong>#96 Framing Images</strong></h3>&#13;
<p class="noindenta">It’s often useful to be able to wrap a border or fancy frame around an image, and ImageMagick has a lot of capabilities in this regard through the <code>convert</code> utility. The problem is, as with the rest of the suite, it’s hard to figure out how to use this tool from the ImageMagick documentation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>For example, here’s the explanation of the <code>-frame</code> parameter:</p>&#13;
<div class="blockquote">&#13;
<p class="noindent">The size portion of the <em>geometry</em> argument indicates the amount of extra width and height that is added to the dimensions of the image. If no offsets are given in the <em>geometry</em> argument, then the border added is a solid color. Offsets <em>x</em> and <em>y</em>, if present, specify that the width and height of the border is partitioned to form an outer bevel of thickness <em>x</em> pixels and an inner bevel of thickness <em>y</em> pixels.</p>&#13;
</div>&#13;
<p class="indent">Got it?</p>&#13;
<p class="indent">Maybe it would be easier to just see an example. In fact, that’s exactly what we’ll do with the <code>usage()</code> function in this script, as shown in <a href="ch14.xhtml#ch14ex5">Listing 14-5</a>.</p>&#13;
<h4 class="h4" id="ch14lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # frameit--Makes it easy to add a graphical frame around&#13;
   #   an image file, using ImageMagick&#13;
&#13;
   usage()&#13;
   {&#13;
   cat &lt;&lt; EOF&#13;
   Usage: $(basename $0) -b border -c color imagename&#13;
      or  $(basename $0) -f frame  -m color imagename&#13;
&#13;
   In the first case, specify border parameters as size x size or&#13;
   percentage x percentage followed by the color desired for the&#13;
   border (RGB or color name).&#13;
&#13;
   In the second instance, specify the frame size and offset,&#13;
   followed by the matte color.&#13;
&#13;
   EXAMPLE USAGE:&#13;
     $(basename $0) -b 15x15 -c black imagename&#13;
     $(basename $0) -b 10%x10% -c gray imagename&#13;
&#13;
     $(basename $0) -f 10x10+10+0 imagename&#13;
     $(basename $0) -f 6x6+2+2 -m tomato imagename&#13;
   EOF&#13;
   exit 1&#13;
   }&#13;
&#13;
   #### MAIN CODE BLOCK&#13;
&#13;
   # Most of this is parsing starting arguments!&#13;
&#13;
   while getopts "b:c:f:m:" opt; do&#13;
     case $opt in&#13;
     b ) border="$OPTARG";                ;;&#13;
     c ) bordercolor="$OPTARG";           ;;&#13;
     f ) frame="$OPTARG";                 ;;&#13;
     m ) mattecolor="$OPTARG";            ;;&#13;
     ? ) usage;                           ;;&#13;
     esac&#13;
   done&#13;
   shift $(($OPTIND - 1))    # Eat all the parsed arguments.&#13;
&#13;
   if [ $# -eq 0 ] ; then    # No images specified?&#13;
     usage&#13;
   fi&#13;
&#13;
   # Did we specify a border and a frame?&#13;
&#13;
   if [ ! -z "$bordercolor" -a ! -z "$mattecolor" ] ; then&#13;
     echo "$0: You can't specify a color and matte color simultaneously." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -z "$frame" -a ! -z "$border" ] ; then&#13;
     echo "$0: You can't specify a border and frame simultaneously." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -z "$border" ] ; then&#13;
     args="-bordercolor $bordercolor -border $border"&#13;
   else&#13;
     args="-mattecolor $mattecolor -frame $frame"&#13;
   fi&#13;
&#13;
&#13;
<span class="ent">➊</span> for name&#13;
   do&#13;
     suffix="$(echo $name | rev | cut -d. -f1 | rev)"&#13;
     prefix="$(echo $name | rev | cut -d. -f2- | rev)"&#13;
<span class="ent">➋</span>   newname="$prefix+f.$suffix"&#13;
     echo "Adding a frame to image $name, saving as $newname"&#13;
<span class="ent">➌</span>   convert $name $args $newname&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_320"/><a id="ch14ex5"/><em>Listing 14-5: The</em> <code><em>frameit</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Since we’ve already explored <code>getopts</code> as a way to gracefully parse complex parameters to a script, this wrapper script is pretty straightforward, with most of the work happening in the last few lines. In the <code>for</code> loop <span class="ent">➊</span>, a new version of the filename specified is created with a <code>"+f"</code> suffix (prior to the file type suffix).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_321"/>For a filename like <em>abandoned-train.png</em>, the suffix would be <code>png</code> and the prefix would be <code>abandoned-train</code>. Notice we lost the period (<code>.</code>), but we’ll add that back in when we build the new filename <span class="ent">➋</span>. Once that’s accomplished, it’s just a matter of invoking the <code>convert</code> program with all the parameters <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Specify the type of frame you want—either with <code>-frame</code> (for more elaborate, 3D effects) or with <code>-border</code> (for a simple border)—along with the appropriate ImageMagick geometry values, a preferred color for the border or matte portion, and the input filename (or filenames). <a href="ch14.xhtml#ch14ex6">Listing 14-6</a> shows an example.</p>&#13;
<pre class="programs">$ <span class="codestrong">frameit -f 15%x15%+10+10 -m black abandoned-train.png</span>&#13;
Adding a frame to image abandoned-train.png, saving as abandoned-train+f.png</pre>&#13;
<p class="listcap"><a id="ch14ex6"/><em>Listing 14-6: Running the</em> <code><em>frameit</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The result of this invocation is shown in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>.</p>&#13;
<div class="image"><img src="../images/f14-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch14fig2"/><em>Figure 14-2: A museum-style 3D matte frame</em></p>&#13;
<h4 class="h4" id="ch14lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If you forget a parameter, ImageMagick issues a typically baffling error:</p>&#13;
<pre class="programs">$ <span class="codestrong">frameit -f 15%x15%+10+10 alcatraz.png</span>&#13;
Adding a frame to image alcatraz.png, saving as alcatraz+f.png&#13;
convert: option requires an argument '-mattecolor' @ error/convert.c/&#13;
ConvertImageCommand/1936.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_322"/>A smart hack would be to add additional error testing in the script to save the user from these ugly things, don’t you think?</p>&#13;
<p class="indent">It’s possible that this script might hiccup with filenames that include spaces. Of course, spaces should never be included in a filename that’s intended to go on a web server, but you should still fix the script to remove this problem.</p>&#13;
<h3 class="h3" id="ch14lev1sec04"><strong>#97 Creating Image Thumbnails</strong></h3>&#13;
<p class="noindenta">We’re surprised how often this problem crops up: someone either includes a ridiculously large image on a web page or emails a photograph far larger than the computer screen. It’s not only annoying but also a waste of bandwidth and computer resources.</p>&#13;
<p class="indent">This script we will implement creates a thumbnail image from any picture you give it, allowing you to specify detailed height and width parameters or simply indicate that the resultant smaller image must fit within certain dimensions. Indeed, creating thumbnails is an officially recommended use of the cool <code>mogrify</code> utility:</p>&#13;
<pre class="programs">$ <span class="codestrong">mkdir thumbs</span>&#13;
$ <span class="codestrong">mogrify -format gif -path thumbs -thumbnail 100x100 *.jpg</span></pre>&#13;
<p class="indent">Note that generally you want to create your thumbnails in a parallel directory rather than in the same directory as the original images. In fact, the <code>mogrify</code> utility can be quite dangerous if misused, as it can overwrite all the images in a directory with a thumbnail version, destroying the original copy. To alleviate this concern, the <code>mogrify</code> command creates 100 × 100 thumbnail images in the <em>thumbs</em> subdirectory, converting them from JPEG to GIF along the way.</p>&#13;
<p class="indent">This is useful but still narrow in application. Let’s create a more general purpose thumbnail-processing script, like the one shown in <a href="ch14.xhtml#ch14ex7">Listing 14-7</a>. It could certainly be used to accomplish the above task, but it can also be used for a lot of other image reduction tasks.</p>&#13;
<h4 class="h4" id="ch14lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # thumbnails--Creates thumbnail images for the graphics file specified,&#13;
   #   matching exact dimensions or not-to-exceed dimensions&#13;
&#13;
   convargs="<span class="ent">➊</span>-unsharp 0x.5 -resize"&#13;
   count=0; exact=""; fit=""&#13;
&#13;
   usage()&#13;
   {&#13;
     echo "Usage: $0 (-e|-f) thumbnail-size image [image] [image]" &gt;&amp;2&#13;
     echo "-e  resize to exact dimensions, ignoring original proportions" &gt;&amp;2&#13;
     echo "-f  fit image into specified dimensions, retaining proportion" &gt;&amp;2&#13;
<span epub:type="pagebreak" id="page_323"/>     echo "-s  strip EXIF information (make ready for web use)" &gt;&amp;2&#13;
     echo "    please use WIDTHxHEIGHT for requested size (e.g., 100x100)"&#13;
     exit 1&#13;
   }&#13;
&#13;
   #############&#13;
   ## BEGIN MAIN&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     usage&#13;
   fi&#13;
&#13;
   while getopts "e:f:s" opt; do&#13;
     case $opt in&#13;
      e ) exact="$OPTARG";                ;;&#13;
      f ) fit="$OPTARG";                  ;;&#13;
      s ) strip="<span class="ent">➋</span>-strip";               ;;&#13;
      ? ) usage;                          ;;&#13;
     esac&#13;
   done&#13;
   shift $(($OPTIND - 1))  # Eat all the parsed arguments.&#13;
&#13;
   rwidth="$(echo $exact $fit | cut -dx -f1)"    # Requested width&#13;
   rheight="$(echo $exact $fit | cut -dx -f2)"   # Requested height&#13;
&#13;
   for image&#13;
   do&#13;
     width="$(identify -format "%w" "$image")"&#13;
     height="$(identify -format "%h" "$image")"&#13;
&#13;
     # Building thumbnail for image=$image, width=$width, and height=$height&#13;
     if [ $width -le $rwidth -a $height -le $rheight ] ; then&#13;
       echo "Image $image is already smaller than requested dimensions. Skipped."&#13;
     else&#13;
       # Build new filename.&#13;
&#13;
       suffix="$(echo $image | rev | cut -d. -f1 | rev)"&#13;
       prefix="$(echo $image | rev | cut -d. -f2- | rev)"&#13;
       newname="$prefix-thumb.$suffix"&#13;
&#13;
       # Add the "!" suffix to ignore proportions as needed.&#13;
&#13;
<span class="ent">➌</span>     if [ -z "$fit" ] ; then&#13;
         size="$exact!"&#13;
         echo "Creating ${rwidth}x${rheight} (exact size) thumb for file $image"&#13;
       else&#13;
         size="$fit"&#13;
         echo "Creating ${rwidth}x${rheight} (max size) thumb for file $image"&#13;
       fi&#13;
&#13;
       convert "$image" $strip $convargs "$size" "$newname"&#13;
     fi&#13;
     count=$(( $count + 1 ))&#13;
   done&#13;
&#13;
   if [ $count -eq 0 ] ; then&#13;
     echo "Warning: no images found to process."&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_324"/><a id="ch14ex7"/><em>Listing 14-7: The</em> <code><em>thumbnails</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec17"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">ImageMagick is so complicated, it just begs for scripts like this one that can simplify common tasks. In this script, we’re tapping into a couple of additional features, including the <code>-strip</code> <span class="ent">➋</span> parameter to remove the exchangeable image file format (EXIF) information that’s useful for photo archives but unnecessary for online use (for example, camera used, ISO speed of photograph, f-stop, geolocation data, and so on).</p>&#13;
<p class="indent">The other new flag is <code>-unsharp</code> <span class="ent">➊</span>, a filter that ensures the shrunk thumbnails don’t end up blurry from the processing. Explaining the potential values for this parameter and how they would affect the result would involve a whole lotta science, so in the spirit of keeping things simple, we’re using the parameter <code>0x.5</code> without explanation. Want to know more? A web search will pull up the details quickly.</p>&#13;
<p class="indent">The best way to understand the difference between thumbnails of an exact size and those that fit within certain dimensions is to see examples, as in <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>.</p>&#13;
<div class="image"><img src="../images/f14-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch14fig3"/><em>Figure 14-3: Difference between a thumbnail of an exact given size (</em><code><em>-e</em></code> <em>argument) and one set to fit certain dimensions proportionally (</em><code><em>-f</em></code> <em>argument)</em></p>&#13;
<p class="indent">The difference between creating an exact thumbnail and a fitted thumbnail internally is just a single exclamation mark. That’s what’s going on at <span class="ent">➌</span>.</p>&#13;
<p class="indent">Other than that, you’ve seen everything in this script before, from the breakdown and reassembly of filenames to the use of the <code>-format</code> flag to get the height or width of the current image.</p>&#13;
<h4 class="h4" id="ch14lev2sec18"><span epub:type="pagebreak" id="page_325"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta"><a href="ch14.xhtml#ch14ex8">Listing 14-8</a> shows the script at work, creating new thumbnails in different sizes for a photo of Hawaii.</p>&#13;
<h4 class="h4" id="ch14lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">thumbnails</span>&#13;
Usage: thumbnails (-e|-f) thumbnail-size image [image] [image]&#13;
-e  resize to exact dimensions, ignoring original proportions&#13;
-f  fit image into specified dimensions, retaining proportion&#13;
-s  strip EXIF information (make ready for web use)&#13;
    please use WIDTHxHEIGHT for requested size (e.g., 100x100)&#13;
$ <span class="codestrong">thumbnails -s -e 300x300 hawaii.png</span>&#13;
Creating 300x300 (exact size) thumb for file hawaii.png&#13;
$ <span class="codestrong">thumbnails -f 300x300 hawaii.png</span>&#13;
Creating 300x300 (max size) thumb for file hawaii.png&#13;
$</pre>&#13;
<p class="listcap"><a id="ch14ex8"/><em>Listing 14-8: Running the</em> <code><em>thumbnails</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A neat addition to this script would be the ability to make an assortment of thumbnails based on multiple size ranges passed in, so for example, you could create a 100 × 100, 500 × 500, and wallpaper-sized 1024 × 768 image all in one go. On the other hand, perhaps such a task is better left to another shell script.</p>&#13;
<h3 class="h3" id="ch14lev1sec05"><strong>#98 Interpreting GPS Geolocation Information</strong></h3>&#13;
<p class="noindenta">Most photographs nowadays are taken with cell phones or other smart digital devices that know their latitude and longitude. There’s a privacy issue with this, of course, but there’s also something interesting about being able to pinpoint where a photograph was taken. Unfortunately, while ImageMagick’s <code>identify</code> tool lets you extract that GPS information, the format of the data makes it hard to read:</p>&#13;
<pre class="programs">exif:GPSLatitude: 40/1, 4/1, 1983/100&#13;
exif:GPSLatitudeRef: N&#13;
exif:GPSLongitude: 105/1, 12/1, 342/100&#13;
exif:GPSLongitudeRef: W</pre>&#13;
<p class="indent">The information shown is in degrees, minutes, and seconds—which makes sense—but the format is nonintuitive, particularly since the format that a site like Google Maps or Bing Maps expects is more akin to this:</p>&#13;
<pre class="programs">40 4' 19.83" N, 105 12' 3.42" W</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_326"/>This script translates the EXIF information into the latter format so you can copy and paste the data directly into a mapping program. As part of that process, the script has to solve some rudimentary equations (notice that the seconds value of the latitude provided by the <code>identify</code> tool is 1983/100, which equals 19.83).</p>&#13;
<h4 class="h4" id="ch14lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">The idea of latitude and longitude is older than you might think. In fact, Portuguese mapmaker Pedro Reinel first drew latitude lines on his maps back in 1504. The calculations also involve some peculiar math. Fortunately, we don’t have to work them out. Instead, we just need to know how to convert the EXIF latitude and longitude values into those that modern mapping applications expect, as you’ll see in <a href="ch14.xhtml#ch14ex9">Listing 14-9</a>. This script also makes use of the <code>echon</code> script from <a href="ch01.xhtml#ch01lev1sec09">Script #8</a> on <a href="ch01.xhtml#page_33">page 33</a>.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # geoloc--For images that have GPS information, converts that data into&#13;
   #   a string that can be fed to Google Maps or Bing Maps&#13;
&#13;
   tempfile="/tmp/geoloc.$$"&#13;
&#13;
   trap "$(which rm) -f $tempfile" 0 1 15&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $(basename $0) image" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   for filename&#13;
   do&#13;
     identify -format<span class="ent">➊</span> "%[EXIF:*]" "$filename" | grep GPSL &gt; $tempfile&#13;
&#13;
&#13;
<span class="ent">➋</span>   latdeg=$(head -1 $tempfile | cut -d, -f1 | cut -d= -f2)&#13;
     latdeg=$(scriptbc -p 0 $latdeg)&#13;
     latmin=$(head -1 $tempfile | cut -d, -f2)&#13;
     latmin=$(scriptbc -p 0 $latmin)&#13;
     latsec=$(head -1 $tempfile | cut -d, -f3)&#13;
     latsec=$(scriptbc $latsec)&#13;
     latorientation=$(sed -n '2p' $tempfile | cut -d= -f2)&#13;
&#13;
     longdeg=$(sed -n '3p' $tempfile | cut -d, -f1 | cut -d= -f2)&#13;
     longdeg=$(scriptbc -p 0 $longdeg)&#13;
     longmin=$(sed -n '3p' $tempfile | cut -d, -f2)&#13;
     longmin=$(scriptbc -p 0 $longmin)&#13;
     longsec=$(sed -n '3p' $tempfile | cut -d, -f3)&#13;
     longsec=$(scriptbc $longsec)&#13;
     longorientation=$(sed -n '4p' $tempfile | cut -d= -f2)&#13;
&#13;
<span class="ent">➌</span>   echon "Coords: $latdeg ${latmin}' ${latsec}\" $latorientation, "&#13;
     echo "$longdeg ${longmin}' ${longsec}\" $longorientation"&#13;
&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_327"/><a id="ch14ex9"/><em>Listing 14-9: The</em> <code><em>geoloc</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Every time we explore using ImageMagick, we find that there’s another parameter and another way to utilize its capabilities. In this case, it turns out that you can use the <code>-format</code> argument at <span class="ent">➊</span> to extract only specific matching parameters from the EXIF information associated with an image.</p>&#13;
<p class="indent">Note that we use <code>GPSL</code> as the pattern to <code>grep</code> for, not <code>GPS</code>. That’s so we won’t have to pick through the additional GPS-related information that would be reported. Try removing the <code>L</code> and see how much other EXIF data is printed!</p>&#13;
<p class="indent">After that, it’s a matter of extracting specific fields of information and solving the mathematical equations with <code>scriptbc</code> to convert the data to a meaningful format, as demonstrated by the <code>latdeg</code> lines at <span class="ent">➋</span>.</p>&#13;
<p class="indent">By this point, pipes with <code>cut</code> used more than once should be familiar to you. These are a super useful scripting tool!</p>&#13;
<p class="indent">Once all the data is extracted and all the equations solved, we need to reassemble the information in a manner consistent with the standard notation for latitude and longitude, as we do at <span class="ent">➌</span>. And we’re done!</p>&#13;
<h4 class="h4" id="ch14lev2sec23"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Give the script an image, and if the file includes latitude and longitude information, the script will convert it to a format that’s ready to be analyzed by Google Maps, Bing Maps, or any other major mapping program, as <a href="ch14.xhtml#ch14ex10">Listing 14-10</a> shows.</p>&#13;
<h4 class="h4" id="ch14lev2sec24"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">geoloc parking-lot-with-geotags.jpg</span>&#13;
Coords: 40 3' 19.73" N, 103 12' 3.72" W&#13;
$</pre>&#13;
<p class="listcap"><a id="ch14ex10"/><em>Listing 14-10: Running the</em> <code><em>geoloc</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch14lev2sec25"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">What happens if you input a photograph that doesn’t have EXIF information? That’s something that the script should address gracefully, not just output an ugly error message from a failed call to <code>bc</code> or print empty coordinates, don’t you think? Adding some more defensive code that ensures the GPS location values pulled from ImageMagick are sane would be a useful addition.<span epub:type="pagebreak" id="page_328"/></p>&#13;
</body></html>