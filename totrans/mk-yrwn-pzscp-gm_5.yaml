- en: '![image](../images/pg101-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg101-01.jpg)'
- en: '5'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: 'Robot Heist: Creating Consequences for Losing'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人抢劫：失误的后果
- en: Now that our game has lasers, danger is a possibility, which means there’s the
    potential for the player to *lose*. What does losing mean in a game?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的游戏中有了激光，危险成为一种可能性，这意味着玩家有可能*失败*。在游戏中，失败意味着什么？
- en: In *Herding Cats*, the player could get stuck and have to restart the level,
    which was a form of losing. In that case, when players make a mistake, they need
    to try again. So one way to think of losing is as a process by which the player
    learns. Every time the player makes a mistake, they learn what not to do next
    time. We used the same thought process when we were figuring out how to make our
    lasers work. A good game always makes it clear to the player what they did wrong.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *放养猫咪* 中，玩家可能会卡住，不得不重新开始关卡，那就是一种失败的表现。在这种情况下，当玩家犯错时，他们需要重新尝试。所以，可以把失败看作是玩家学习的一个过程。每次玩家犯错，他们就学到下次不该做什么。当我们思考如何让激光工作时，也使用了同样的思维方式。一款好的游戏总是清晰地告诉玩家他们做错了什么。
- en: Do all games need to let the player lose? Not at all! Some games are just about
    exploring, telling a story, or petting a dog. Can you lose the experience of petting
    a dog? Losing doesn’t make sense in some contexts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏都需要让玩家失败吗？完全不！有些游戏只是关于探索、讲故事或者抚摸狗。抚摸狗的体验能失败吗？在某些情境下，失败是没有意义的。
- en: '![image](../images/pg102-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg102-01.jpg)'
- en: '*Robot Heist*, on the other hand, is about trying to break into a bank without
    being detected. The possibility of getting caught makes the game more exciting
    and tense. Because the players can lose if they’re not careful, they can also
    feel like they’ve outsmarted the game when they succeed. Feeling challenged gives
    the player the opportunity to overcome obstacles, which can motivate them to beat
    the game. Let’s look at how to make losing feel like losing.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器人抢劫* 则是关于尝试在不被发现的情况下闯入银行。被抓住的可能性让游戏变得更加激动人心和紧张。由于玩家如果不小心可能会失败，因此当他们成功时，也会有种自己智胜游戏的感觉。面对挑战给玩家提供了克服障碍的机会，这可以激励他们击败游戏。我们来看看如何让失败看起来像是失败。'
- en: Getting Caught
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被抓住
- en: What does getting caught look like in *Robot Heist*? Remember that losing is
    the process of making mistakes and learning from them. We should make sure that
    when the player loses, they understand that they made a mistake and they should
    understand what the mistake is. That’s the only way they’ll learn.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *机器人抢劫* 中，被抓住是什么样的呢？记住，失败是犯错并从中学习的过程。我们应该确保当玩家失败时，他们明白自己犯了什么错，并理解这个错误是什么。只有这样，他们才能从中学习。
- en: Click **Rebuild** and try moving a robot through a laser. What happens? *Nothing!*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**并尝试让机器人穿过激光。会发生什么？*什么都不发生！*
- en: We need to decide what losing looks and sounds like when a laser hits a robot.
    Perhaps an alarm should go off when the robots trip a security laser? We can play
    an alarm noise to let the player know they did something wrong.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定当激光击中机器人时，失败的表现和声音是什么样的。或许当机器人触发安全激光时，应该响起警报？我们可以播放警报声来提醒玩家他们做错了什么。
- en: The player also needs to know what they did wrong so they can change their strategy.
    We’ll let the players know by making them stop in their tracks when they’re caught.
    That way, if they were caught stepping into a laser, the player can see *that*
    was the mistake. We’ll turn both robots red (because they’ve been caught *red-handed*)
    to show they can no longer move. Even if only one robot is spotted, when the alarm
    goes off, the jig is up for both of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家还需要知道自己做错了什么，以便能够改变策略。我们会通过让他们在被捕时停下来来让玩家意识到这一点。这样，如果他们是在踩到激光时被捕，玩家就能看到*那*是错误所在。我们将把两个机器人都变成红色（因为他们是*当场被抓住*的），以显示他们无法再移动。即使只有一个机器人被发现，当警报响起时，两个机器人都会被抓住。
- en: We’ll need to add two new objects to the game to serve as the caught, red versions
    of each robot, as shown here.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在游戏中添加两个新对象，作为每个机器人被捕后的红色版本，如下所示。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`VertibotCaught` and `HoribotCaught` are just `Vertibot` and `Horibot` colored
    red. We don’t need to worry about adding these new objects to the legend, because
    the robots will never start a level already caught: that would be a very hard
    game to win!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertibotCaught` 和 `HoribotCaught` 只是将 `Vertibot` 和 `Horibot` 变成了红色。我们不需要担心将这些新对象添加到图例中，因为机器人永远不会在已经被捕获的状态下开始游戏：那将是一个非常难赢的游戏！'
- en: Let’s think about whether we can add any groups to the legend at this point
    to make writing our rules easier. If the awake robot walks into a laser, the sleeping
    robot should get caught too. Therefore, it shouldn’t matter whether the robot
    is awake or asleep. So let’s make groups that let us refer to each robot regardless
    of what state they’re in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下，是否可以在此时将一些组添加到图例中，以便更容易编写我们的规则。如果醒着的机器人走进激光，睡着的机器人也应该被抓住。因此，不管机器人是醒着还是睡着都不应该有影响。让我们创建一些组，让我们能够引用每个机器人，而不管它们处于什么状态。
- en: 'Add these two groups to the `LEGEND` section:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个组添加到`LEGEND`部分：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We call the groups `Vbot` and `Hbot` because `Vertibot` and `Horibot` are already
    being used; they refer to the awake robots. Here, we tell PuzzleScript that `Vertibot`
    and `VertibotSleeping` count as `Vbot`, and `Horibot` and `HoribotSleeping` count
    as `Hbot`. Now we can use `Vbot` and `Hbot` to check whether the robots are caught
    and whether they’re awake.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些组命名为`Vbot`和`Hbot`，因为`Vertibot`和`Horibot`已经被使用了；它们指的是醒着的机器人。在这里，我们告诉PuzzleScript，`Vertibot`和`VertibotSleeping`算作`Vbot`，而`Horibot`和`HoribotSleeping`算作`Hbot`。现在我们可以使用`Vbot`和`Hbot`来检查机器人是否被抓住以及它们是否醒着。
- en: Next, we need an alarm sound.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个警报声音。
- en: '![image](../images/pg104-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg104-01.jpg)'
- en: Adding Sound Effects
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加声音效果
- en: 'Our “You got caught!” sound doesn’t need to sound exactly like an alarm, but
    it *should* sound menacing! When a player hears it, they should immediately know
    there’s *trouble*. Click the sound effects buttons until you find a sound you
    like (try the *, :(, or ? button). Then copy and paste the sound into the `SOUNDS`
    section of your script. Alternatively, you can copy the numbers as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“你被抓住了！”的声音不需要完全像警报，但它*应该*听起来很有威胁感！当玩家听到这个声音时，他们应该立刻意识到有*麻烦*发生了。点击声音效果按钮直到找到你喜欢的声音（试试*、:(或?按钮）。然后将声音复制并粘贴到脚本的`SOUNDS`部分。或者，你可以复制下面显示的数字：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In PuzzleScript, each sound is a set of numbers. We have to give our sound a
    name before we can use it. We’ll call this sound `sfx0`, and when we add this
    name to a rule, the sound should play whenever the rule runs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在PuzzleScript中，每个声音都是一组数字。在使用它之前，我们必须给声音命名。我们将这个声音命名为`sfx0`，当我们将这个名字添加到规则中时，声音就会在规则运行时播放。
- en: Adding Caught Robots to the Collision Layers
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将被捕获的机器人添加到碰撞层
- en: Now we’re ready to put the caught robot objects on collision layers. Try doing
    that on your own! Make sure you add them to the same collision layer as the other
    robot objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将被捕获的机器人对象放到碰撞层上。试着自己完成这一步！确保它们与其他机器人对象在同一碰撞层上。
- en: 'Click **Rebuild**, and just to be safe, make sure there are no errors! If you
    forgot to add the new objects to the `COLLISIONLAYERS` section, you might see
    an error message like this below the game window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**，为了安全起见，请确保没有错误！如果你忘记将新对象添加到`COLLISIONLAYERS`部分，你可能会看到类似下面的错误信息：
- en: '![image](../images/pg105-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg105-01.jpg)'
- en: '*An error message*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*错误信息*'
- en: Usually, an error message tells you what you forgot to do. In this case, it’s
    clear that the error is caused by the objects not being assigned to a collision
    layer. If this is what you see, go to the `COLLISIONLAYERS` section and make sure
    to add the objects!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，错误信息会告诉你忘记做了什么。在这种情况下，很明显错误是由于对象没有分配到碰撞层所导致的。如果你看到这个错误，进入`COLLISIONLAYERS`部分，确保将对象添加进去！
- en: Writing the Rules for Getting Caught
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写被捕获的规则
- en: 'Let’s write some rules to make the robots turn into their caught forms if they
    touch a laser. Keep in mind that you can show that two objects are in the same
    space by putting them both in square brackets with no vertical bar dividing them.
    Because it doesn’t matter whether the robots are asleep or awake when they get
    caught, we’ll simply use the `Vbot` and `Hbot` groups that we created earlier.
    Add the following lines under your existing code in the `RULES` section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些规则，让机器人在触碰到激光时变成被捕获的状态。请记住，你可以通过将两个对象都放在方括号中并且不使用竖线分隔来表示它们在同一空间中。因为无论机器人是醒着还是睡着被抓住都没有关系，所以我们将简单地使用我们之前创建的`Vbot`和`Hbot`组。在`RULES`部分的现有代码下方添加以下行：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The rules are marked as *late* because we want them to happen after the robot
    has walked into a laser, not before. Be sure to put `sfx0` at the end of each
    rule to make your cool sound effect play when the rules run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则被标记为*晚*，因为我们希望它们发生在机器人走进激光之后，而不是之前。确保在每条规则的末尾加上`sfx0`，这样当规则执行时，你的酷炫音效就会播放。
- en: Click **Rebuild** and try the program. When you move a robot into a laser, it
    should turn red like this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**并尝试程序。当你将一个机器人移入激光时，它应该像这样变红。
- en: '![image](../images/pg106-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg106-01.jpg)'
- en: '*Testing the rules for getting caught*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试被抓住的规则*'
- en: Try using one robot to push the other sleeping robot into the laser. The sleeping
    robot should also turn red when it touches the laser beam. Because the caught
    forms of the characters don’t count as players according to the legend, you shouldn’t
    be able to move them after they turn red. *Caught red-handed!*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一个机器人推另一个正在睡觉的机器人进入激光。睡着的机器人应该在接触到激光束时也变红。因为根据规则，角色的被抓状态不算作玩家，所以它们变红后，你不应该能够移动它们。*当场被抓！*
- en: Right now, only the robot that touches the laser gets caught. But we want them
    both to get caught, even when only one messes up. Let’s add a rule that makes
    sure that both robots get caught.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有触碰到激光的机器人会被抓住。但我们希望它们都被抓住，即使只有一个犯错了。让我们添加一个规则，确保两个机器人都会被抓住。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this rule, when PuzzleScript sees that `Vertibot` has been caught, `Horibot`
    becomes caught too, and vice versa. Because you have two different pairs of square
    brackets on the same side of the arrow, both of those objects can be *anywhere*
    in the room. Recall that when we wrote the rules for switching earlier, having
    two objects in their own sets of square brackets means they don’t need to be next
    to each other. This rule makes sure that if the alarm goes off, it doesn’t matter
    where the robots are: they’re both busted.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个规则，当PuzzleScript检测到`Vertibot`被抓住时，`Horibot`也会被抓住，反之亦然。因为你在箭头的同一侧使用了两个不同的方括号对，所以这两个对象可以出现在房间的*任何地方*。回想一下，当我们早先编写切换规则时，两个对象各自拥有方括号意味着它们不需要靠在一起。这个规则确保了如果警报响起，机器人在哪里都无关紧要：它们都会被抓住。
- en: Click **Rebuild** to test this new rule! Now both characters should get caught
    at the same time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**来测试这个新规则！现在两个角色应该同时被抓住。
- en: '![image](../images/pg107-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg107-01.jpg)'
- en: '*Both robots get caught*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*两个机器人都被抓住了*'
- en: You can see that when `Horibot` triggers the alarm by crossing a laser, both
    `Horibot` and `Vertibot` turn red to show that they’re caught.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当`Horibot`触发警报，穿过激光时，`Horibot`和`Vertibot`都会变红，表示它们被抓住了。
- en: But notice that something weird happened. The characters get caught, but you
    also get a `Win Condition Satisfied` message and the level ends! This is the opposite
    of what we want to happen. Winning is the opposite of losing! Why do we win *instead*
    of losing?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，发生了一些奇怪的事情。角色被抓住了，但你也收到了`Win Condition Satisfied`（获胜条件满足）消息，关卡结束了！这正是我们不希望发生的情况。赢得胜利是与失败相反的！为什么我们会*赢*而不是失败呢？
- en: Updating the Win Conditions
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新获胜条件
- en: 'Let’s put our detective hats on again to figure out why the win condition is
    met when `Vertibot` and `Horibot` get caught. Because PuzzleScript gave us the
    `Win Condition Satisfied` message, maybe we should check our `WINCONDITIONS` section,
    which currently looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再戴上侦探帽，弄明白为什么当`Vertibot`和`Horibot`被抓住时，获胜条件会被满足。由于PuzzleScript给了我们`Win Condition
    Satisfied`（获胜条件满足）消息，也许我们应该检查一下`WINCONDITIONS`部分，它现在看起来是这样的：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `Buddy` group currently contains `Horibot`, `Vertibot`, `HoribotSleeping`,
    and `VertibotSleeping`. Recall that `all Buddy on Exit` means all the buddies
    on the screen, regardless of how many there are, should be on the `Exit` objects
    for the player to win the level. The `Buddy` grouping should still hold true even
    if there are *no* buddies on the screen. The problem is that when `Vertibot` and
    `Horibot` become `VertibotCaught` and `HoribotCaught`, they no longer count as
    buddies because `VertibotCaught` and `HoribotCaught` don’t belong to the `Buddy`
    group.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Buddy`组目前包含`Horibot`、`Vertibot`、`HoribotSleeping`和`VertibotSleeping`。回想一下，`all
    Buddy on Exit`意味着屏幕上的所有伙伴，不管有多少，都应该在`Exit`对象上，玩家才能完成这一关。即使屏幕上*没有*伙伴，`Buddy`分组也应成立。问题是，当`Vertibot`和`Horibot`变成`VertibotCaught`和`HoribotCaught`时，它们不再算作伙伴，因为`VertibotCaught`和`HoribotCaught`不属于`Buddy`组。
- en: This means that when the robots are caught, there are no objects that could
    possibly meet the win condition. And because there are no buddies *not* on exits,
    PuzzleScript decides that the win condition is met. Computers are more logical
    than we are, but they’re way less smart. When PuzzleScript checks the win condition
    `all Buddy on Exit`, it’s making sure that there are *no* buddies anywhere other
    than on exits. If there are no buddies at all, then as far as PuzzleScript is
    concerned, all the buddies on the screen (that is, zero!) are on exits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can have multiple win conditions in our game. Let’s add new
    win conditions to the `WINCONDITIONS` section that specify the player can’t win
    when both robots are caught, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code `no VertibotCaught` checks that there are no `VertibotCaught` objects
    in the level. To win a level, all the win conditions need to be satisfied at the
    same time, so the level can’t be won if PuzzleScript finds any caught robots,
    even if they are all on the exit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'This new win condition should work fine (try it and see!). But we could simplify
    this even further by making a group that contains both caught robots, which we’ll
    call `Trouble`. Add this line to the `LEGEND` section:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So we’ll finish the level with `no Trouble`. The player wins if they’ve gotten
    both buddies onto the exit without running into any `Trouble`. Now we can use
    the `Trouble` group to streamline our `WINCONDITIONS` section code, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we’ve written rules for how the robots should interact with lasers
    and how that should affect the outcome of the game, let’s add a few more threats
    to make our game more exciting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Adding Robot Guards
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second threat we’ll add to the game are robot security guards that patrol
    the Data Bank. If the robot guards find Vertibot or Horibot, the player will lose!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The challenge will be to make the guards move on their own, because this can
    be a very complicated process to program. Have you ever played *Hide and Seek*?
    A lot of decisions go into finding your friends when they’re hidden. You probably
    know the best hiding spots in the area in which you’re playing. You know your
    friends. You know which friend always surprises you by trying to pick the cleverest
    hiding spot. You remember which places you’ve already looked in. You look over
    your shoulder sometimes in case someone is sneaking around behind you. Somehow
    a human being can synthesize all of this information to make decisions quickly.
    How can we possibly program a video game guard that’s as smart as a person?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we don’t have to, because this is only a robot guard. It’s okay
    if it follows a very simple pattern. In fact, it’s probably better if the guard’s
    actions are predictable. For example, if it covers the same ground over and over,
    the player can anticipate its path and sneak around it. If the guards were as
    smart as real humans, our game would be impossible to win.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way we can code this kind of patrolling movement is to have the
    guard move in a straight line and then turn when it reaches a wall. We can have
    it continue moving forward and turning in the same direction until it eventually
    returns to the point where it started and then starts over again.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写最简单的代码来实现这种巡逻运动，即让守卫沿直线移动，然后在撞到墙壁时转弯。我们可以让它继续向前移动并保持转向，直到最终返回到起点并重新开始。
- en: Creating Guard Objects
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建守卫物体
- en: 'Let’s start by creating the objects. We’ll need four guard objects: one for
    each direction the guard can move in (up, down, left, and right). We start with
    one of the objects and then change it into the next type of object when it runs
    into a wall. A benefit of using four distinct objects is that we can change each
    object to look different depending on the direction in which it’s moving. That
    way, the player can look at the screen and see where the guards are going.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建物体开始。我们需要四个守卫物体：每个守卫可以移动的方向（上、下、左和右）各一个。我们从一个物体开始，当它撞到墙壁时，再将其转换成下一个类型的物体。使用四个不同物体的好处是，我们可以根据守卫移动的方向改变每个物体的外观。这样，玩家可以通过观察屏幕来看到守卫的移动方向。
- en: Let’s add four new objects to the game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向游戏中添加四个新物体。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll name them `GuardUp`, `GuardRight`, `GuardDown`, and `GuardLeft`. As you
    can see, the red pixel should signal to the player which direction each object
    can move in.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们命名为`GuardUp`、`GuardRight`、`GuardDown`和`GuardLeft`。如你所见，红色像素应该向玩家指示每个物体可以移动的方向。
- en: Adding Guards to the Legend and the Collision Layers
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将守卫添加到图例和碰撞层
- en: 'Now we need to put these guards into the legend. We also need to assign a symbol
    for each direction, so we can use it to choose which direction the guards start
    in. Add the following lines to your existing code in the `LEGEND` section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些守卫添加到图例中。我们还需要为每个方向分配一个符号，以便我们可以使用它来选择守卫的起始方向。将以下代码添加到`LEGEND`部分的现有代码中：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I chose those numbers as symbols because of their placement on the keyboard’s
    keypad (the part that looks like a calculator). An up arrow is on the 8, a right
    arrow is on the 6, and so on. When I see these numbers in a level and forget which
    direction it is, I can just glance at the keypad on my keyboard to remind myself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这些数字作为符号，是因为它们在键盘数字键区（看起来像计算器部分）的位置。上箭头在8号键，右箭头在6号键，依此类推。当我在关卡中看到这些数字并忘记它们代表哪个方向时，我只需看一下键盘上的数字键区来提醒自己。
- en: 'Let’s also add a `Guard` group to the legend that will let us refer to all
    guard objects regardless of which direction a guard is facing, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在图例中添加一个`Guard`组，这样我们就可以引用所有守卫物体，而不管守卫面朝哪个方向，像这样：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the `Guard` group should come before the `Depresser` group in your
    script. The reason is that we want guards to be able to step on panels like the
    other depresser objects and be able to block lasers as a blocker. Before we can
    add `Guard` to the `Depresser` and `Blocker` groups, we first need to tell PuzzleScript
    what a guard is. Only *then* can we tell PuzzleScript that a guard can be a depresser
    and a blocker.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Guard`组应当在脚本中的`Depresser`组之前。原因是我们希望守卫能够像其他压板物体一样踩在面板上，并能作为阻挡物阻挡激光。在我们将`Guard`添加到`Depresser`和`Blocker`组之前，我们需要先告诉PuzzleScript守卫是什么。只有*那时*，我们才能告诉PuzzleScript守卫既可以是压板物体，也可以是阻挡物。
- en: Last but not least, be sure to add all four guard objects to a collision layer.
    Put them on the same layer as the robots and all the other solid objects. Then
    click **Rebuild** to make sure there aren’t any errors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，确保将所有四个守卫物体添加到碰撞层中。将它们放在与机器人以及所有其他固体物体相同的层上。然后点击**重建**以确保没有任何错误。
- en: Now let’s write the rules that make our guards patrol.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写使守卫巡逻的规则。
- en: Writing Rules to Move Guards Forward
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写使守卫向前移动的规则
- en: 'A guard’s motion has two parts: it moves forward, and then, when it bumps into
    a wall, it turns to the right.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫的运动有两个部分：它先向前移动，然后当它撞到墙壁时，向右转。
- en: '![image](../images/pg113-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg113-01.jpg)'
- en: 'Let’s add the forward movement first by adding the following to the `RULES`
    section:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们通过向`RULES`部分添加以下内容来添加向前移动：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At every turn, we just change our guards into moving guards. Because the four
    rules are directional, the `>` simply matches the direction of the rule. For example,
    `GuardLeft` always moves left, `GuardDown` always moves down, and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每次转弯时，我们只需将守卫转换为移动中的守卫。由于这四条规则是有方向性的，`>`符号简单地匹配规则的方向。例如，`GuardLeft`总是向左移动，`GuardDown`总是向下移动，依此类推。
- en: 'Put together a simple test level to check that this script works now. Be sure
    to include all four objects on your test level, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个简单的测试关卡，检查这个脚本现在是否有效。确保你的测试关卡中包括所有四个对象，如下所示：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try playing your level! You should see something like this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩一下你的关卡！你应该会看到类似的情况。
- en: '![image](../images/pg114-01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg114-01.jpg)'
- en: '*Guard test level*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*守卫测试关卡*'
- en: If your guards start one space forward from where you put them, it’s because
    of `run_rules_on_level_start`! Don’t worry—this won’t be an issue when we turn
    on realtime mode shortly. The guards should move only when the player moves. Wiggle
    the player back and forth and watch how the guards behave. They’ll move forward
    until they hit the wall. Then they’ll get stuck because we haven’t told them what
    to do when they run into a wall. Let’s tell them to turn to the right after bumping
    into something.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的守卫从你放置它们的位置前进一步，那是因为`run_rules_on_level_start`的作用！别担心——当我们稍后启用实时模式时，这不会是问题。守卫应该仅在玩家移动时才会移动。来回摆动玩家并观察守卫的行为。它们会向前移动，直到撞到墙壁。然后它们会卡住，因为我们还没有告诉它们碰到墙壁时该怎么办。让我们告诉它们在碰到东西后转向右边。
- en: '**NOTE:** If you get an error message that says, “Trying to access a level
    that doesn’t exist,” try pressing **Rebuild** and start a new game.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 如果你收到“尝试访问一个不存在的关卡”的错误信息，请尝试点击**重新构建**并开始一局新游戏。'
- en: Writing Rules for Turning Right
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写向右转的规则
- en: 'Before we can make the guards turn, let’s define a new group in the legend
    called `Obstacle` for every object that could get in a guard’s way. Add the following
    to the `LEGEND` section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让守卫转向之前，先在图例中定义一个新的组，名为`Obstacle`，用于所有可能阻碍守卫的物体。将以下内容添加到`LEGEND`部分：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new `Obstacle` group includes all the solid objects a guard can run into.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Obstacle`组包括所有守卫可能撞到的固体物体。
- en: 'Now we can add rules to make the guards turn when they bump into any obstacle.
    Guards turn clockwise (to the right) whenever they bump into something. We’ll
    make guards turn by replacing them entirely with another object that points in
    the new direction. Add the following to the `RULES` section to do this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加规则，让守卫在碰到任何障碍物时转向。守卫每当碰到东西时都会顺时针（向右）转向。我们通过用另一个指向新方向的物体完全替换守卫来使其转向。要实现这一点，请将以下内容添加到`RULES`部分：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When a guard tries to move into an obstacle, it instead is turned into the guard
    object facing the next direction clockwise. `GuardLeft` turns into `GuardUp`,
    `GuardUp` turns into `GuardRight`, `GuardRight` turns into `GuardDown`, and `GuardDown`
    turns into `GuardLeft`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当守卫试图移动到障碍物上时，它会被转变成朝下一个顺时针方向的守卫对象。`GuardLeft`变成`GuardUp`，`GuardUp`变成`GuardRight`，`GuardRight`变成`GuardDown`，`GuardDown`变成`GuardLeft`。
- en: Note that I’ve grouped the rules so all the guards move forward at the same
    time and then all the guards turn at the same time, because rules are run in order
    from top to bottom. Click **Save** now. To see what can happen when you change
    the order of the rules, try moving the `[ > GuardLeft | Obstacle ] -> [ GuardUp
    | Obstacle ]` rule before the `up [ GuardUp ] -> [ > GuardUp ]` rule. Then try
    grouping the rules so each guard object’s move and turn rules are together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经将规则分组，以便所有守卫同时向前移动，然后所有守卫同时转向，因为规则是按从上到下的顺序执行的。现在点击**保存**。要看看改变规则顺序时会发生什么，尝试将`[
    > GuardLeft | Obstacle ] -> [ GuardUp | Obstacle ]`规则移到`up [ GuardUp ] -> [ >
    GuardUp ]`规则之前。然后尝试将规则分组，使每个守卫对象的移动和转向规则在一起。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Click **Rebuild** and try playing the game with this updated code. You should
    see that one of the guards moves differently than the others. In this example,
    `GuardLeft` turns into `GuardUp` after it runs into a wall. But because of the
    misplaced code, `GuardUp` moves one step forward immediately after turning instead
    of turning in place and waiting a turn to move like the others. This is why it’s
    important to always think about the order in which your rules execute. When `GuardLeft`
    hits a wall, it turns into `GuardUp` and immediately moves up; the other guards
    wait a turn after turning to move. Can you read through the rules one by one and
    see why?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重新构建**并尝试使用这个更新的代码玩游戏。你应该会发现其中一个守卫与其他守卫的行为不同。在这个例子中，`GuardLeft`在碰到墙壁后变成了`GuardUp`。但是由于代码的位置错误，`GuardUp`在转向后立即向前移动了一步，而不是像其他守卫一样在原地转向并等待下一步。这就是为什么在编写规则时，考虑规则执行的顺序非常重要的原因。当`GuardLeft`撞到墙壁时，它变成`GuardUp`并立即向上移动；而其他守卫在转向后需要等待一个回合才能移动。你能逐条阅读这些规则，看看为什么会这样吗？
- en: Early in the rules, `GuardLeft` becomes `GuardUp`. But a later rule moves `GuardUp`
    up. Because the turning rule for `GuardLeft` happens before the moving rule for
    `GuardUp`, the guard turns and moves on the same turn!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则的早期，`GuardLeft`变成了`GuardUp`。但后面的规则将`GuardUp`向上移动。因为`GuardLeft`的转向规则发生在`GuardUp`的移动规则之前，所以守卫在同一回合内就转向并移动了！
- en: Click the **Load** menu and return to the game you last saved.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**加载**菜单并返回到你上次保存的游戏。
- en: Catching the Intruders
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抓住入侵者
- en: 'Let’s create rules that let the guards actually *catch* Horibot and Vertibot
    by adding these two lines to the guardbots section in the `RULES` section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些规则，通过在`RULES`部分的guardbots区块中添加这两行，来让守卫真正地*抓住*Horibot和Vertibot：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if a guard tries to move into either robot, the robot turns into its caught
    equivalent, setting off the alarm sound at the same time. (I know the guards are
    robot guards, but whenever I mention “robots,” I’m referring to just Vertibot
    and Horibot.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个守卫试图进入任一机器人，机器人会变成被抓住的等效状态，并同时触发警报声音。（我知道守卫是机器人守卫，但每当我提到“机器人”时，我指的只是Vertibot和Horibot。）
- en: 'Notice how grouping helps us write fewer rules. The `Guard` group includes
    four different guard objects, and `Hbot` and `Vbot` include two objects each:
    the sleeping and awake versions of the robots. Without groups, we’d need to write
    16 different rules to cover all the different combinations!'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分组如何帮助我们编写更少的规则。`Guard`组包括四种不同的守卫对象，而`Hbot`和`Vbot`分别包括两个对象：机器人睡着和清醒的版本。如果没有分组，我们需要编写16个不同的规则来覆盖所有不同的组合！
- en: Click **Rebuild** to test your game. Try moving a robot in front of a guard’s
    patrol path. Then try putting an asleep robot in front of a guard’s patrol path.
    When the guard bumps into the robot, the robot should turn red just like it would
    when it walks into a laser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**来测试你的游戏。试着把一个机器人移动到守卫的巡逻路径前面。然后尝试把一个睡着的机器人放在守卫的巡逻路径前。当守卫撞到机器人时，机器人应该像走进激光时一样变成红色。
- en: '![image](../images/pg117-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg117-01.jpg)'
- en: Testing the Guards
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试守卫
- en: Earlier, we put guards in `Depresser` and `Blocker` groups in the legend. Let’s
    make some test levels to test those features.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们把守卫放在了`Depresser`和`Blocker`组中。让我们创建一些测试关卡来测试这些功能。
- en: Here’s a level that tests how guards work with panels.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个测试守卫如何与面板互动的关卡。
- en: '![image](../images/pg118-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg118-01.jpg)'
- en: '*Testing guards and panels*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试守卫和面板*'
- en: Because a guard is a depresser, the gates should open when the guard moves onto
    the panel and close when the guard moves off the panel. If you want the gate to
    stay open for a longer time, try putting a bunch of panels in a row, so it will
    take the guard longer to get past them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为守卫是一个“压下”器，所以当守卫移动到面板上时，门应该打开，而当守卫离开面板时，门应该关闭。如果你希望门保持打开更长时间，试着将多个面板排成一排，这样守卫就需要更长时间才能通过它们。
- en: Next, try making a level to test whether guards will block lasers. Can you come
    up with a level where the robots need to time their movements with the guards
    to sneak past lasers?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试制作一个关卡来测试守卫是否会阻挡激光。你能想出一个关卡，让机器人需要与守卫的行动配合，才能躲过激光吗？
- en: As a last test, let’s see what happens when a guard runs into a dead end. Make
    a level shaped like the following.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的测试，让我们看看当守卫撞到死胡同时会发生什么。制作一个像下面这样的关卡。
- en: '![image](../images/pg119-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg119-01.jpg)'
- en: '*Testing guards at a dead end*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试守卫在死胡同中的表现*'
- en: When the guard bumps into the dead end in the upper left, it turns to the right.
    Then it immediately bumps into another wall and turns right again. Now it should
    head back down. What do you think will happen when it gets back to the bottom
    and bumps into the wall there? You should see something like this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当守卫撞到左上角的死胡同时，它会转向右边。接着它立即撞到另一面墙并再次转向右边。现在它应该开始向下走。当它返回到底部并撞到那里的墙时，你认为会发生什么？你应该会看到类似这样的情景。
- en: '![image](../images/pg119-02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg119-02.jpg)'
- en: '*Guard stuck in a dead-end path*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*守卫卡在死胡同路径中*'
- en: It should turn right again, just like we told it to. It should turn around and
    start heading back up. This guard will keep going up and down this pathway forever
    and never return to its original patrol path. Keep this example in mind when you
    design your levels so you won’t make the same mistake!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该再次转向右边，正如我们所要求的那样。它应该转身并开始向上走。这个守卫将会永远上下移动，不会返回到原来的巡逻路径。在你设计关卡时，请牢记这个例子，以免犯同样的错误！
- en: Realtime Mode
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时模式
- en: All the games we’ve made so far are called *turn-based* games. In a turn-based
    game, one player has a turn and then the next player takes a turn, as in a game
    of *Checkers*. In *Herding Cats*, the cats move only when the player moves.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们制作的所有游戏都叫做*回合制*游戏。在回合制游戏中，一位玩家进行一轮，然后下一位玩家接着进行一轮，就像在玩*跳棋*一样。在* Herding
    Cats *中，猫只在玩家移动时才会移动。
- en: In *Robot Heist*, we want characters that move on their own. Right now, the
    security guards in our game move only when the player moves. But if we switch
    our game into realtime mode, they’ll move on their own, even when the player isn’t
    moving. Realtime refers to basing the movements of game objects on the amount
    of time that has passed in the real world, not the movements of the player character.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Robot Heist*中，我们希望角色能自动移动。目前，游戏中的保安只有在玩家移动时才会移动。但如果我们将游戏切换到实时模式，它们将会自己移动，即使玩家没有移动。实时模式指的是基于现实世界中已经过去的时间来控制游戏对象的移动，而不是基于玩家角色的移动。
- en: How does realtime feel different than a turn-based game? First, there’s an element
    of *time pressure*. Even when the player is not moving, the guards are patrolling.
    That means the player won’t be able to sit and think about their next move for
    as long as they want. As in a real heist, the player has to think and act quickly.
    It also helps create the sense that these guards have a life of their own, outside
    the player. After all, real security guards wouldn’t wait for an intruder’s permission
    to move, would they?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实时模式与回合制游戏有什么不同？首先，存在一个*时间压力*的元素。即使玩家没有移动，守卫也在巡逻。这意味着玩家无法长时间坐着思考下一步该怎么走。就像在一次真正的盗窃中，玩家必须迅速思考和行动。它还有助于营造这些守卫有自己生活的感觉，超越了玩家的存在。毕竟，现实中的保安可不会等待入侵者的许可再行动吧？
- en: Making Objects Move in Realtime
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实时移动物体
- en: Let’s make objects move by themselves by turning on realtime mode in PuzzleScript.
    We can tell PuzzleScript how often we want objects to move, such as once every
    second. Then, every time a second passes, PuzzleScript runs all the rules whether
    or not the player has moved.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过开启 PuzzleScript 的实时模式，让物体自动移动。我们可以告诉 PuzzleScript 我们希望物体多频繁地移动，比如每秒一次。然后，每经过一秒，PuzzleScript
    就会运行所有规则，无论玩家是否已经移动。
- en: 'To turn on realtime mode, simply add the following line to the beginning of
    your PuzzleScript code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要开启实时模式，只需在你的 PuzzleScript 代码开头添加以下一行：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The number after `realtime_interval` tells PuzzleScript how often to run the
    game rules, in seconds. So `realtime_interval 1` would be once every second. And
    `0.5` would be once every half a second, or two moves per second. Our example
    has `realtime_interval 0.2`, which is two-tenths of a second, or five moves every
    second.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`realtime_interval` 后面的数字告诉 PuzzleScript 游戏规则应多频繁运行，单位是秒。所以 `realtime_interval
    1` 表示每秒运行一次。`0.5` 则表示每半秒一次，即每秒两次。我们的示例中是 `realtime_interval 0.2`，即每 0.2 秒运行一次，相当于每秒五次。'
- en: 'Realtime works best if you add a couple more of PuzzleScript’s optional features,
    like `throttle_movement` and `norepeat_action` (the latter of which was added
    in [Chapter 4](ch04.xhtml)). Add both below realtime mode, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实时模式最好在添加 PuzzleScript 的一些可选功能时使用，比如`throttle_movement`和`norepeat_action`（后者在[第
    4 章](ch04.xhtml)中添加）。将它们都加在实时模式下方，如下所示：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `throttle_movement` feature limits the player’s movement speed. Without
    it, pressing an arrow key a bunch of times can make you move faster than just
    holding down the arrow key. That’s not a big deal if everything in the world moves
    at the same speed as you, but it’s important if everything else is moving at its
    own speed. And it isn’t a big deal if everyone else in the game moves whenever
    the player moves. But if guards are moving at their own speed, the player can
    move way faster than them by mashing buttons. And because this game is about planning
    and strategy, not about button mashing, we’ll use `throttle_movement` to keep
    the player from mashing buttons in order to win.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle_movement`功能限制玩家的移动速度。如果没有它，连续按下箭头键可能会让你比只按住箭头键时移动得更快。如果世界上所有事物都以和玩家相同的速度移动，这倒也没什么大不了的，但如果其他一切都按自己的速度运动，那就很重要了。如果游戏中的每个人物在玩家移动时都一起移动也没什么问题。但如果守卫按自己的速度行动，玩家就能通过快速按键比他们移动得更快。由于这款游戏是关于计划和策略的，而不是关于狂按按钮的，我们将使用`throttle_movement`来防止玩家通过狂按按钮来获胜。'
- en: Without `norepeat_action`, holding down the action key will continue switching
    between both robots, meaning it’s easier to accidentally switch more times than
    you want to. Also, `norepeat_action` makes sure the player releases the action
    key before they can press it again. Adding both features makes the game more user-friendly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`norepeat_action`时，按住动作键将会在两个机器人之间持续切换，这意味着很容易不小心切换次数比预期的更多。此外，`norepeat_action`确保玩家在重新按下动作键之前先松开它。添加这两个功能使得游戏更加用户友好。
- en: Click **Rebuild** and watch your guards go! They should start moving on their
    own in a beautiful, synchronized ballet, even when your robots aren’t moving.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**，看守卫们如何运动！即使你的机器人没有移动，它们也应该开始独立移动，形成一个优美的同步芭蕾舞。
- en: Now try moving the robots. *Whoa!*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试移动机器人。*哇！*
- en: '![image](../images/pg122-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg122-01.jpg)'
- en: When you move the robots, you should see that the guards speed up and move super
    fast whenever you move! Yikes! What’s going on?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动机器人时，你应该能看到守卫们会加速并且每当你移动时就会迅速移动！哇！这是怎么回事？
- en: Checking for a Stationary Player
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查静止的玩家
- en: Instead of calling a turn as normal (running the rules, then moving objects,
    and then running late moves) PuzzleScript’s realtime mode calls a turn every 0.2
    seconds. So the rules for guards are run even when the player hasn’t pressed any
    keys. But we haven’t accounted for the fact that PuzzleScript still calls a turn
    whenever the player presses a key. This means that the guards move on their own
    every 0.2 seconds and move *again* when the player moves. We want the guards to
    move independently of the player, not to move faster when the player moves.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常调用回合（运行规则、然后移动对象、再运行延迟移动）不同，PuzzleScript的实时模式每0.2秒就会调用一次回合。所以即使玩家没有按下任何键，守卫的规则也会被执行。但我们没有考虑到当玩家按下一个键时，PuzzleScript仍然会调用回合。这意味着守卫每0.2秒独立移动一次，并且在玩家移动时*再次*移动。我们希望守卫独立于玩家移动，而不是在玩家移动时更快地移动。
- en: 'We need the guards to move *only* every 0.2 seconds, but *not* when the player
    moves. To do that, we just need to check that the player is *stationary* whenever
    we try to move the guards. Go back to the rules for moving guards in the `RULES`
    section, and add `[ stationary Player ]` to both sides of each arrow, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让守卫每0.2秒*仅*移动一次，但*不*在玩家移动时移动。为此，我们只需要在尝试移动守卫时检查玩家是否处于*静止*状态。回到`RULES`部分的守卫移动规则，像这样在每个箭头的两侧添加`[
    stationary Player ]`：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding `[ stationary Player ]` lets guards move forward only when there’s a
    stationary (non-moving) player somewhere in the level. Note that this doesn’t
    change the player at all. These rules just make sure that guards move every 0.2
    seconds, but *not* when the player robots move.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`[ stationary Player ]`使得守卫仅在某个地方有一个静止（不移动的）玩家时才会向前移动。请注意，这不会改变玩家的任何行为。这些规则仅确保守卫每0.2秒移动一次，但*不*在玩家机器人移动时移动。
- en: Click **Rebuild** and try moving around. The guards’ speed should remain constant
    no matter what the player does.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**并尝试移动。无论玩家做什么，守卫的速度应该保持不变。
- en: 'Extra Challenges: Make It Look Good'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外挑战：让它看起来更好
- en: Here are some extra touches I added to the finished version of *Robot Heist*
    to make the game look more appealing. The challenges are listed in order of difficulty.
    Can you figure out how to script them? If you need help, hack my finished *Robot
    Heist* game and look at how I did it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我在《机器人抢劫》的完成版本中添加的一些额外细节，使游戏看起来更具吸引力。挑战按照难度排序。你能弄明白怎么编写这些脚本吗？如果你需要帮助，可以破解我完成的《机器人抢劫》游戏，看看我是怎么做的。
- en: '**Challenge 1: Make characters bigger than a single space** If you look closely
    at the player robots in *Robot Heist*, you’ll see that they’re slightly larger
    than the 5 × 5 pixel size of most PuzzleScript objects. In fact, each player robot
    is made up of three separate objects that all move together.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**挑战 1：让角色比一个单一空间更大** 如果你仔细观察《机器人抢劫》中的玩家机器人，你会发现它们稍微大于大多数PuzzleScript对象的5 ×
    5像素大小。事实上，每个玩家机器人是由三个独立的对象组成的，这些对象一起移动。'
- en: '**Challenge 2: Randomize the walls** One way to keep the walls from looking
    too similar is to create a bunch of slightly different wall objects. When the
    level starts, each wall changes its appearance at random. These walls all behave
    in the same way, but they add visual variety to the levels.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**挑战 2：随机化墙壁** 防止墙壁看起来过于相似的一种方法是创建一些稍微不同的墙壁对象。每当关卡开始时，每堵墙都会随机改变外观。这些墙壁的行为是相同的，但它们为关卡增添了视觉多样性。'
- en: '**Challenge 3: Add animation** In a realtime game, we can make objects change
    appearance over time and animate them. For example, the solid gold superconductor—the
    treasure the robots are trying to steal—shines and gleams by changing between
    three different objects, each representing a single frame of animation.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**挑战 3：添加动画** 在实时游戏中，我们可以让物体随着时间变化而改变外观并进行动画处理。例如，坚固的金色超导体——机器人试图偷走的宝藏——通过在三个不同的物体之间切换，每个物体代表一个动画帧，闪闪发光。'
- en: '**Challenge 4: Wire paths** To make it easier for the player to make the connection
    between panels and the gates they open, I drew wires leading from the panels to
    the gates. These work a lot like the lasers do: at the beginning of the level,
    the player looks around for adjacent wires and then draws connections between
    them.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**挑战 4：电线连接** 为了让玩家更容易将面板与它们控制的门连接起来，我画了从面板到门的电线。这些电线的工作方式与激光非常相似：在关卡开始时，玩家环顾四周寻找相邻的电线，并在它们之间画出连接。'
- en: What You Learned
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, you added the ability to *lose* the game. You gave lasers and
    robot guards the ability to catch the player, adding an element of tension to
    the game. You learned what losing looks like and why you might want to give the
    player the possibility of losing. And you made the guards move in realtime, patrolling
    for the robots instead of waiting for them to move.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你增加了*输掉*游戏的功能。你让激光和机器人守卫能够抓住玩家，为游戏增添了紧张感。你学会了什么是失败，以及为什么你可能想让玩家有输掉的可能性。你还让守卫实时移动，巡逻寻找机器人，而不是等待它们移动。
- en: 'Now you have a complete cast of objects: the robot protagonists, crates to
    push, gates to open and close, security lasers, and patrolling guards. You’re
    ready to combine all these objects into action-packed levels. In the next chapter,
    you’ll do just that.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了一组完整的物体：机器人主角、可推的箱子、可以打开和关闭的门、安全激光以及巡逻的守卫。你准备将所有这些物体结合成充满动作的关卡。在下一章中，你将实现这一目标。
