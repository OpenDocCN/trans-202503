<html><head></head><body>
<span epub:type="pagebreak" id="page_159"/>&#13;
<h2 class="h2"><strong><span class="big">9</span><br/>HIGH-LEVEL PROGRAMMING</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">In the last chapter, we looked at the fundamentals of software: machine code that runs on processors, and assembly language, a human-readable representation of machine code. Although eventually all software must take the form of machine code, most software developers work at a higher, more abstract level. In this chapter, you learn about high-level programming. We cover an overview of high-level programming, discuss common elements found across various programming languages, and look at example programs.</p>&#13;
<h3 class="h3" id="lev1_54"><strong><span epub:type="pagebreak" id="page_160"/>High-Level Programming Overview</strong></h3>&#13;
<p class="noindent">Although it’s possible to write software in assembly language (or even machine code!), doing so is time-consuming and error-prone, and it results in software that is hard to maintain. Furthermore, assembly language is specific to a CPU architecture, so if an assembly developer wishes to run their program on another type of CPU, the code must be rewritten. To address these shortcomings, <em>high-level programming languages</em> were developed; these allow programs to be written in a language that is independent from a specific CPU and is syntactically closer to human language. Many of these languages require a <em>compiler</em>, a program that converts high-level program statements to machine code for a specific processor. Using a high-level language, a software developer can write a program once and then compile it for multiple types of processors, sometimes with little or no change to the source code.</p>&#13;
<p class="indent">The output of a compiler is an object file that contains machine code for a specific processor. As we covered in <a href="ch08.xhtml#proj12">Project #12</a>, object files aren’t in the correct format for a computer to execute. Another program, called a <em>linker</em>, is used to convert one or more object files into an executable file that the operating system can then run. The linker can also bring in other libraries of compiled code when needed. The process of compiling and linking is illustrated in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>.</p>&#13;
<div class="image" id="ch9fig1"><img src="../images/fig9-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Building executable software from source code</em></p>&#13;
<p class="indent">The process of compiling and linking is referred to as <em>building</em> software. However, in common usage, software developers sometimes speak of <em>compiling</em> their code when they really mean the entire process of compiling, linking, and any other steps required to get their code into its final form. Compilers often invoke the linking step automatically, making it less visible to the software developer.</p>&#13;
<h3 class="h3" id="lev1_55"><strong>Introduction to C and Python</strong></h3>&#13;
<p class="noindent">The best way to learn about high-level programming is to examine programming languages and write some programs in those languages. For this chapter, I’ve chosen two high-level languages: C and Python. Both are powerful and useful, and they illustrate how programming languages tend to provide similar functionality but in different ways. Let’s begin with a brief introduction to each.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>The <em>C</em> programming language dates back to the early 1970s, when it was used to write a version of the Unix operating system. Despite being a high-level language, C isn’t that far removed from underlying machine code, making it a great choice for operating system development or other software that interfaces directly with hardware. An updated version of C known as <em>C++</em> came about in the 1980s. C and C++ are powerful languages that can be used to accomplish nearly anything. However, these languages are complex and don’t provide many safeguards against programmer mistakes. They remain a popular choice for programs that need to interface with hardware and those that require high performance, such as games. C is also useful for educational purposes, providing a straightforward mapping between low-level and high-level concepts, which is why I chose it for this chapter.</p>&#13;
<p class="indent">Compared to C, the <em>Python</em> programming language is further removed from underlying hardware. Initially released in the 1990s, Python has grown in popularity over the years. It’s known for being easy to read and simple for beginners, while still providing everything necessary to support complex software projects. Python has a “batteries included” philosophy, meaning a standard distribution of Python includes a library of helpful capabilities that developers can easily use in their projects. The straightforward nature of Python makes it a good choice for teaching concepts of programming.</p>&#13;
<p class="indent">Let’s now look at elements found across most high-level programming languages. The goal isn’t to teach you to be a programmer in a specific language, but to instead familiarize you with the ideas commonly found in programming languages. Remember that the capabilities found in high-level programming languages are abstractions of CPU instructions. As you know, CPUs provide instructions for memory access, math and logic operations, and control of program flow. Let’s look at how high-level languages expose these underlying capabilities.</p>&#13;
<h3 class="h3" id="lev1_56"><strong>Comments</strong></h3>&#13;
<p class="noindent">Let’s begin with a feature of programming languages that doesn’t actually instruct the CPU to do anything! Nearly all programming languages provide a way to include comments in code. A <em>comment</em> is text in source code that provides some insight into the code. Comments are intended to be read by other developers and are typically ignored by the compiler; they have no effect on the compiled software. In the C programming language, comments are specified like so:</p>&#13;
<p class="programs">/* <br/>&#13;
  This is a C-style comment.<br/>&#13;
  It can span multiple lines.<br/>&#13;
*/<br/><br/>&#13;
// This is a single-line C comment, originally introduced in C++.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Python uses the hash character for comments, like this:</p>&#13;
<p class="programs"># This is a comment in Python.</p>&#13;
<p class="indent">Python doesn’t provide any particular support for multiline comments; a programmer can simply use multiple single-line comments, one after another.</p>&#13;
<h3 class="h3" id="lev1_57"><strong>Variables</strong></h3>&#13;
<p class="noindent">Memory access is a fundamental capability of processors, and therefore it must be a feature of high-level languages as well. The most basic way that programming languages expose memory is through variables. A <em>variable</em> is a named storage location in memory. Variables allow programmers to give a <em>name</em> to a memory address (or range of memory addresses) and then access data at that address. In most programming languages, variables have a <em>type</em>, indicating what sort of data they hold. For example, a variable may be an integer type or a text string type. Variables also have a <em>value</em>, which is the data stored in memory. Although it’s often hidden from the programmer, variables also have an <em>address</em>, the location in memory where the variable’s value is stored. Lastly, variables have <em>scope</em>, meaning they can only be accessed from certain parts of the program, the parts where they are “in scope.”</p>&#13;
<h4 class="h4" id="lev2_20"><strong><em>Variables in C</em></strong></h4>&#13;
<p class="noindent">Let’s look at an example of a variable in the C programming language.</p>&#13;
<p class="programs">// Declare a variable and assign it a value in C.<br/>&#13;
int points = 27;</p>&#13;
<p class="indent">This code <em>declares</em> a variable named <span class="literal">points</span> with a type of <span class="literal">int</span>, which in the C language means the variable holds an integer. The variable is then <em>assigned</em> a value of <span class="literal">27</span>. When this code runs, the value of <span class="literal">27</span> decimal is stored at a memory address, but the developer doesn’t need to worry about the specific address where the variable is stored. Most C compilers today treat an <span class="literal">int</span> as a 32-bit number, so at <em>runtime</em> (the time when a program executes) 4 bytes are allocated for this variable (4 bytes × 8 bits per byte = 32 bits), and the memory address of the variable refers to the first byte.</p>&#13;
<p class="indent">Let’s now declare a second variable and assign it a value; then we can look at how the two variables are allocated in memory.</p>&#13;
<p class="programs">// Two variables in C<br/>&#13;
int points = 27;<br/>&#13;
int year = 2020;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_163"/>Now we have two variables, <span class="literal">points</span> and <span class="literal">year</span>, declared one after another. Both are integers, so they each require 4 bytes for storage. The variables can be stored in memory as shown in <a href="ch09.xhtml#ch9tab1">Table 9-1</a>.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> Variables Stored in Memory</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Address</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Variable name</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Variable value</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">0x7efff1cc</span></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">?</span></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">?</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">0x7efff1d0</span></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">year</span></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">2020</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">0x7efff1d4</span></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">points</span></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">27</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">0x7efff1d8</span></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">?</span></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">?</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The memory addresses used in <a href="ch09.xhtml#ch9tab1">Table 9-1</a> are just examples; the actual addresses vary depending on the hardware, operating system, compiler, and so forth. Note that the addresses increment by four, since we’re storing 4-byte integers. The addresses before and after the known variables have a question mark for the variable name and value, since based on the preceding code, we don’t know what might be stored there.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj14">Project #14</a> on <a href="ch09.xhtml#page_184">page 184</a>, where you can look at variables in memory</em>.</p>&#13;
</div>&#13;
<p class="indent">As the name <em>variable</em> implies, the value of a variable can change. If our earlier C program needed to set the value of <span class="literal">points</span> to another value, we could simply do this later in the program:</p>&#13;
<p class="programs">// Setting a new points value in C<br/>&#13;
points = 31;</p>&#13;
<p class="indent">Note that unlike our previous code snippet in C, this code does not specify <span class="literal">int</span> or any other type before the variable name. We only need to specify the type when the variable is initially declared. In this case, the variable was declared earlier, so here we just assign it a value. However, the C language requires that the variable’s type remain the same, so once <span class="literal">points</span> is declared as an <span class="literal">int</span>, only integers can be assigned to that variable. Attempting to assign another type, such as a text string, results in a failure when the code is compiled.</p>&#13;
<h4 class="h4" id="lev2_21"><strong><em>Variables in Python</em></strong></h4>&#13;
<p class="noindent">Not all languages require a declaration of type. Python, for example, allows a variable to be declared and assigned like so:</p>&#13;
<p class="programs"># Python allows new variables without specifying a type.<br/>&#13;
age = 22</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_164"/>Now, in this case, Python recognizes that the type of data is an integer, but the programmer doesn’t have to specify this. Unlike in C, the variable’s type can change over time, so the following is valid in Python:</p>&#13;
<p class="programs"># Assiging a variable a value of a different type is valid in Python.<br/>&#13;
age = 22<br/>&#13;
age = 'twenty-two'</p>&#13;
<p class="indent">Let’s take a closer look at what is actually happening in this example. A Python variable has no type, but the value to which it refers does have a type. This is an important distinction: the type is associated with the value, not the variable. A Python variable can refer to a value of any type. So when the variable is assigned a new value, it isn’t really that the variable’s type is changing, but rather that the variable has been bound to a value of a different type. Contrast this with C, where the variable itself has a type and can only hold values of that type. This difference explains why a variable in Python can be assigned values of different types, whereas a variable in C cannot.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj15">Project #15</a> on <a href="ch09.xhtml#page_186">page 186</a>, where you can change the type of value referenced by a variable in Python</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_58"><strong>Stack and Heap Memory</strong></h3>&#13;
<p class="noindent">When a programmer uses a high-level language to access memory, the details of how that memory is managed behind the scenes is somewhat obscured, depending on the programming language in use. A programming language like Python makes the details of memory allocation nearly invisible to the programmer, whereas a language like C exposes some of the underlying memory management mechanisms. Whether the details are exposed to the programmer or not, programs commonly make use of two types of memory: stack and heap.</p>&#13;
<h4 class="h4" id="lev2_22"><strong><em>The Stack</em></strong></h4>&#13;
<p class="noindent">The <em>stack</em> is an area of memory that operates on a <em>last-in first-out (LIFO)</em> model. That is, the last item put on the stack is the first item that comes off the stack. You can think of a memory stack as being like a stack of plates. When you add to a stack of plates, you add the newest plate to the top. When the time comes to take a plate from the stack, you remove the top plate first. This does not mean that the items on the stack can only be <em>accessed</em> (read or modified) in LIFO order. In fact, any item currently on the stack can be read or modified at any time. However, when it comes time to remove unneeded items from the stack, the items are discarded from the top down, meaning the last item placed on the stack is the first to go.</p>&#13;
<p class="indent">The memory address of the value on the top of the stack is stored in a processor register known as the <em>stack pointer</em>. When a value is added to the top of the stack, the stack pointer’s value is adjusted to increase the size of the stack and make room for the new value. When a value is removed from the top of the stack, the stack pointer is adjusted to decrease the size of the stack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_165"/>The compiler generates code that uses the stack to track the state of a program’s execution and as a place to store local variables. The mechanics of this are transparent to a programmer in a high-level language. <a href="ch09.xhtml#ch9fig2">Figure 9-2</a> provides a look at how a C program uses the stack to hold the two local variables that we covered earlier in <a href="ch09.xhtml#ch9tab1">Table 9-1</a>.</p>&#13;
<div class="image" id="ch9fig2"><img src="../images/fig9-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-2: Stack memory is used to hold variable values in a program written in C.</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>, the <span class="literal">points</span> variable is declared first and assigned a value of <span class="literal">27</span>, a value that is stored on the stack. Next, the <span class="literal">year</span> variable is declared and assigned a value of <span class="literal">2020</span>. This second value is placed “above” the prior value on the stack. Additional values will continue to be added to the top of the stack until they are no longer needed, at which point they will be removed from the stack. Keep in mind that each slot in the diagram is just a location in memory with an assigned memory address, although the addresses aren’t shown in the diagram. You may be surprised to hear that in many architectures, the memory addresses assigned to the stack actually <em>decrease</em> as the stack grows. In this example, that means that the <span class="literal">year</span> variable has a lower memory address than the <span class="literal">points</span> variable.</p>&#13;
<p class="indent">Stack memory is fast and well suited for small memory allocations that have limited scope. A separate stack is made available to each thread of execution in a program. We’ll cover threads in more detail in <a href="ch10.xhtml">Chapter 10</a>, but for now you can think of threads as parallel tasks within a program. The stack is a limited resource; there’s a limit to how much memory is allocated to the stack. Putting too many values on the stack results in a failure known as a <em>stack overflow</em>.</p>&#13;
<h4 class="h4" id="lev2_23"><strong><em>The Heap</em></strong></h4>&#13;
<p class="noindent">The stack is meant to hold small values that only need to be temporarily available. For memory allocations that are large or need to persist for a longer time, the heap is a better fit. The <em>heap</em> is a pool of memory that’s available to a program. Unlike the stack, heap memory doesn’t work on a LIFO model; there is no standard model for how heap memory is allocated. Whereas stack memory is specific to a thread, allocations made from the heap can be accessed by any of the program’s threads.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/>Programs allocate memory from the heap, and that memory usage persists until it’s freed by the program or the program terminates. To <em>free</em> a memory allocation simply means to release it back to the pool of available memory. Some programming languages automatically free heap memory when an allocation is no longer referenced; one common approach for doing this is known as <em>garbage collection</em>. Other programming languages, like C, require the programmer to write code to free heap memory. A <em>memory leak</em> occurs when unused memory isn’t freed.</p>&#13;
<p class="indent">In the C programming language, a special kind of variable called a <em>pointer</em> is used to track memory allocations. A pointer is simply a variable that holds a memory address. The pointer value (a memory address) can be stored in a local variable on the stack, and that value can refer to a location in the heap, as illustrated in <a href="ch09.xhtml#ch9fig3">Figure 9-3</a>.</p>&#13;
<div class="image" id="ch9fig3"><img src="../images/fig9-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-3: The pointer variable named <span class="literal">data</span> is on the stack and points to an address in the heap.</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9fig3">Figure 9-3</a> we have a code snippet that declares a variable called <span class="literal">data</span>. This variable is of type <span class="literal">void *</span>, which means it’s a pointer (indicated by <span class="literal">*</span>) that points to a memory address that can hold any type of data (<span class="literal">void</span> means the type isn’t specified). Because <span class="literal">data</span> is a local variable, it is allocated on the stack. The next line of code makes a call to <span class="literal">malloc</span>, a function in C that allocates memory from heap. The program is asking for 512 bytes of memory, and the <span class="literal">malloc</span> function returns the address of the first byte of the newly allocated memory. That address is stored in the <span class="literal">data</span> variable, on the stack. So we end up with a local variable at an address on the stack that holds the address of an allocation on the heap.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj16">Project #16</a> on <a href="ch09.xhtml#page_187">page 187</a>, where you can see for yourself how variables are allocated in a running program</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_59"><strong>Math</strong></h3>&#13;
<p class="noindent">Since processors provide instructions for performing mathematical operations, high-level languages do too. In contrast to programming in assembly language, where specific named instructions are required for math (such as the <span class="literal">subs</span> instruction for subtraction on ARM processors), high-level <span epub:type="pagebreak" id="page_167"/>languages generally include symbols that represent common mathematical operations, making it simple to perform math in code. A large number of programming languages, including C and Python, use the same operators for addition, subtraction, multiplication, and division, as shown in <a href="ch09.xhtml#ch9tab2">Table 9-2</a>.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2:</strong> Common Math Operators</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Operation</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Operator</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Addition</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">+</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">Subtraction</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">-</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Multiplication</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">Division</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">/</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Another common convention across multiple programming languages is to use the equals sign (<span class="literal">=</span>) to represent an assignment rather than equality. That is, a statement like <span class="literal">x = 5</span> means to <em>set</em> the value of x to 5. Assigning the result of a mathematical operation is represented in a natural way, such as in these statements:</p>&#13;
<p class="programs">// Addition is easy in C.<br/>&#13;
cost = price + tax;</p>&#13;
<p class="programs"># Addition is easy in Python too.<br/>&#13;
cost = price + tax</p>&#13;
<p class="indent">So far, we’ve focused on integer math, which is common in computing. However, computers and high-level languages also support something called <em>floating-point arithmetic</em>. Unlike integers that represent whole numbers, floating-point values can represent fractions. Some programming languages hide the details of this, but internally CPUs use different instructions for floating-point math than for integer math. In C, floating-point variables are declared using a floating-point type such as <span class="literal">float</span> or <span class="literal">double</span>, as shown here:</p>&#13;
<p class="programs">// Declaring a floating-point variable in C<br/>&#13;
double price = 1.99;</p>&#13;
<p class="indent">On the other hand, Python infers type for its variables, so both integers and floating-point values are declared in the same way:</p>&#13;
<p class="programs"># Declaring integer and floating-point varibles in Python<br/>&#13;
year  = 2020 # year is an int<br/>&#13;
price = 1.99 # price is a float</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>The differences in integers verses floating-point numbers can lead to unexpected results sometimes. For example, let’s say you have the following C code:</p>&#13;
<p class="programs">// Dividing integers in C<br/>&#13;
int x = 5;<br/>&#13;
int y = 2;<br/>&#13;
int z = x / y;</p>&#13;
<p class="indent">What would you expect the value of <span class="literal">z</span> to be? It turns out that since all the numbers involved are integers, <span class="literal">z</span> ends up with a value of <span class="literal">2</span>. Not <span class="literal">2.5</span>, but <span class="literal">2</span>. As an integer, <span class="literal">z</span> cannot hold fractional values.</p>&#13;
<p class="indent">Now what if we changed the code slightly, like so:</p>&#13;
<p class="programs">// Dividing integers in C, result stored in a float<br/>&#13;
int x = 5;<br/>&#13;
int y = 2;<br/>&#13;
float z = x / y;</p>&#13;
<p class="indent">Note that <span class="literal">z</span> now has a type of <span class="literal">float</span>. Now what would you expect the value of <span class="literal">z</span> to be? Interestingly, <span class="literal">z</span> is now equal to <span class="literal">2.0</span>; it still isn’t <span class="literal">2.5</span>! This is because the division operation occurred with two integers, so the result was an integer too. The division result was <span class="literal">2</span>, and when it was assigned to floating-point variable <span class="literal">z</span>, it was given the value <span class="literal">2.0</span>. The C language is very literal; it’s compiled into instructions that closely mirror what the programmer said to do. This is great for programmers who need fine-grained control of processing, but not always so great for programmers who expect more intuitive behavior from their programming language.</p>&#13;
<p class="indent">Python tries to be more helpful, automatically assigning a type that allows for fractional results in a situation like this. If we write an equivalent version of this code in Python, the result stored in <span class="literal">z</span> will be <span class="literal">2.5</span>.</p>&#13;
<p class="programs"># Dividing integers in Python<br/>&#13;
# z will be 2.5 and its inferred type is float<br/>&#13;
x = 5<br/>&#13;
y = 2<br/>&#13;
z = x / y</p>&#13;
<p class="indent">Some languages provide mathematical operators that are abbreviated ways of stating an operation. For example, C provides increment (add 1) and decrement (subtract 1) operators, as shown here:</p>&#13;
<p class="programs">// In C, we can add one to a variable the long way,<br/>&#13;
x = x + 1;<br/>&#13;
// or we can use this shortcut to increment x.<br/>&#13;
x++;<br/>&#13;
// On the other hand, this will decrement x.<br/>&#13;
x--;</p>&#13;
<span epub:type="pagebreak" id="page_169"/>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Fun fact: the name of the programming language C++ is meant to convey the idea that it’s an improvement upon, or an increment of, the C programming language</em>.</p>&#13;
</div>&#13;
<p class="indent">Python also provides some shortcut operators for math. The <span class="literal">+=</span> and <span class="literal">-=</span> operators allow programmers to add to or subtract from a variable. For example:</p>&#13;
<p class="programs"># In Python, we can add 3 to a variable like this...<br/>&#13;
cats = cats + 3<br/><br/>&#13;
# Or we can do the same thing with this shortcut...<br/>&#13;
cats += 3</p>&#13;
<p class="indent">The <span class="literal">+=</span> and <span class="literal">-=</span> operators work in C as well.</p>&#13;
<h3 class="h3" id="lev1_60"><strong>Logic</strong></h3>&#13;
<p class="noindent">As we covered earlier, processors are very good at performing logical operations, since logic is the foundation for digital circuits. As you’d expect, programming languages also provide the capability to handle logic. Most high-level languages provide two kinds of operators that deal in logic: bitwise operators, which deal with the bits of integers, and Boolean operators, which deal with Boolean (true/false) values. The terminology here can be confusing, since different programming languages use different terms. Python uses “bitwise” and “Boolean,” whereas C uses “bitwise” and “logical,” and other languages use still other terms. Let’s stick with “bitwise” and “Boolean” here.</p>&#13;
<h4 class="h4" id="lev2_24"><strong><em>Bitwise Operators</em></strong></h4>&#13;
<p class="noindent"><em>Bitwise operators</em> act on the individual bits of integer values and result in an integer value. A bitwise operator is like a mathematical operator, but instead of adding or subtracting, it performs an AND, OR, or other logical operation on the bits of integers. These operators work according to the truth tables covered in <a href="ch02.xhtml">Chapter 2</a>, performing the operation on all the bits in the integer in parallel.</p>&#13;
<p class="indent">Many programming languages, including C and Python, use the set of operators shown in <a href="ch09.xhtml#ch9tab3">Table 9-3</a> for bitwise operations.</p>&#13;
<p class="tabcap" id="ch9tab3"><strong>Table 9-3:</strong> Bitwise Operations as Commonly Expressed in Programming Languages</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Bitwise operation</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Bitwise operator</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">AND</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">&amp;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">OR</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">|</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">XOR</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">^</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">NOT (complement)</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">~</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Let’s look at a bitwise example in Python.</p>&#13;
<p class="programs"># Python does bitwise logic.<br/>&#13;
x = 5<br/>&#13;
y = 3<br/>&#13;
a = x &amp; y<br/>&#13;
b = x | y</p>&#13;
<p class="indent">The result of the code above is that <span class="literal">a</span> is 1 and <span class="literal">b</span> is 7. Let’s look at those operations in binary (<a href="ch09.xhtml#ch9fig4">Figure 9-4</a>) to make it clear why this is so.</p>&#13;
<div class="image" id="ch9fig4"><img src="../images/fig9-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-4: Bitwise AND, OR operations on 5 and 3</em></p>&#13;
<p class="indent">Take a look at the AND operation in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a> first; recall from <a href="ch02.xhtml">Chapter 2</a> that AND means that the result is 1 when both inputs are 1. Here we look at the bits one column at a time, and as you can see, only the rightmost bit is 1 for both inputs. Therefore, the AND result is 0001 binary, or 1 decimal. Therefore, <span class="literal">a</span> is assigned a value of 1 in the preceding code.</p>&#13;
<p class="indent">On the other hand, OR means that the result is 1 if either input (or both inputs) is 1. In this example, the rightmost three bits are all 1 in one input or the other, so the result is 0111 binary, or 7 decimal. Therefore, <span class="literal">b</span> is assigned a value of 7 in the preceding code.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch9ex1"><strong>EXERCISE 9-1: BITWISE OPERATORS</strong></p>&#13;
<p class="exercise-para">Consider the following Python statements. What will be the values of <span class="literal">a</span>, <span class="literal">b</span>, and <span class="literal">c</span> after this code executes?</p>&#13;
<p class="programs">x = 11<br/>&#13;
y = 5<br/>&#13;
a = x &amp; y<br/>&#13;
b = x | y<br/>&#13;
c = x ^ y</p>&#13;
<p class="exercise-parai">The answer can be found in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_25"><strong><em>Boolean Operators</em></strong></h4>&#13;
<p class="noindent">The other kind of logical operator in high-level programming languages is the <em>Boolean operator</em>. These operators work on Boolean values and result in a Boolean value.</p>&#13;
<p class="indent">Let’s take a moment to talk about Boolean values. A <em>Boolean value</em> is either true or false. Different programming languages represent true or <span epub:type="pagebreak" id="page_171"/>false in different ways. A <em>Boolean variable</em> is a named memory address that holds a Boolean value of true or false. For example, we could have a variable in Python that tracks whether an item is on sale: <span class="literal">item_on_sale = True</span>.</p>&#13;
<p class="indent">An expression can evaluate to true or false without the result being stored in a variable. For example, the expression <span class="literal">item_cost &gt; 5</span> evaluates to either true or false at runtime depending on the value of the <span class="literal">item_cost</span> variable.</p>&#13;
<p class="indent">Boolean operators allow us to perform a logical operation like AND, OR, or NOT on Boolean values. For example, we can check if two conditions are both true using Python’s Boolean AND operator: <span class="literal">item_on_sale</span> and <span class="literal">item_cost &gt; 5</span>. The expressions to the left and right of <span class="literal">and</span> evaluate to Boolean values, and in turn, the entire expression evaluates to a Boolean value. Here C and Python use different operators, as shown in <a href="ch09.xhtml#ch9tab4">Table 9-4</a>.</p>&#13;
<p class="tabcap" id="ch9tab4"><strong>Table 9-4:</strong> Boolean Operators in C and Python Programming Languages</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Boolean operation</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>C operator</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Python operator</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">AND</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">&amp;</span>&amp;</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">and</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">OR</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">||</span></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">or</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">NOT</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">!</span></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">not</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">While we’re on the subject of operators that return Boolean values, a <em>comparison operator</em> compares two values and evaluates to true or false as the result of the comparison. For example, the <em>greater than operator</em> allows us to compare two numbers and determine if one is larger than the other. <a href="ch09.xhtml#ch9tab5">Table 9-5</a> shows comparison operators used in both C and Python.</p>&#13;
<p class="tabcap" id="ch9tab5"><strong>Table 9-5:</strong> Comparison Operators in C and Python Programming Languages</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Comparison operation</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Comparison operator</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">EQUALITY</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">==</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">NOT EQUAL</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">!=</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">GREATER THAN</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">&gt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">LESS THAN</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">&lt;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">GREATER THAN OR EQUAL</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><span class="literal">&gt;=</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">LESS THAN OR EQUAL</p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><span class="literal">&lt;=</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You’ve already seen one of these in use, in our earlier example of <span class="literal">item_cost &gt; 5</span>. Pay attention to the equality operator. Both C and Python use a double equals sign to represent an equality comparison, and they use a single equals sign to represent an assignment. That means <span class="literal">x == 5</span> is a comparison that returns true or false (is <span class="literal">x</span> equal to <span class="literal">5</span>?), whereas <span class="literal">x = 5</span> is an assignment that sets the value of <span class="literal">x</span> to <span class="literal">5</span>.</p>&#13;
<h3 class="h3" id="lev1_61"><strong><span epub:type="pagebreak" id="page_172"/>Program Flow</strong></h3>&#13;
<p class="noindent">Boolean and comparison operators allow us to evaluate the truth of an expression, but that alone isn’t very useful. We need a way to do something in response! <em>Program flow</em>, or <em>control flow</em>, statements allow us to do just that, altering the behavior of a program in response to some condition. Let’s look at some common program flow constructs found across programming languages.</p>&#13;
<h4 class="h4" id="lev2_26"><strong><em>If Statements</em></strong></h4>&#13;
<p class="noindent">An <em>if statement</em>, often coupled with an <em>else statement</em>, allows the programmer to do something if some condition is true. In turn, the <span class="literal">else</span> statement allows the program to do something different if the condition is false. Here’s an example in Python:</p>&#13;
<p class="programs">  # Age check in Python<br/>&#13;
<span class="ent">❶</span> if age &lt; 18:<br/>&#13;
    <span class="ent">❷</span> print('You are a youngster!')<br/>&#13;
<span class="ent">❸</span> else:<br/>&#13;
    <span class="ent">❹</span> print('You are an adult.')</p>&#13;
<p class="indent">In this example, the first <span class="literal">if</span> statement <span class="ent">❶</span> checks if the <span class="literal">age</span> variable refers to a value that’s less than 18. If so, it prints a message indicating that the user is young <span class="ent">❷</span>. The <span class="literal">else</span> statement <span class="ent">❸</span> tells the program to print a different message if <span class="literal">age</span> is 18 or greater <span class="ent">❹</span>.</p>&#13;
<p class="indent">Here is the same “age check” logic, this time written in C:</p>&#13;
<p class="programs">  // Age check in C<br/>&#13;
  if (age &lt; 18)<br/>&#13;
<span class="ent">❶</span> {<br/>&#13;
    printf("You are a youngster!");<br/>&#13;
<span class="ent">❷</span> }<br/>&#13;
  else<br/>&#13;
  {<br/>&#13;
    printf("You are an adult.");<br/>&#13;
  }</p>&#13;
<p class="indent">In the C example, note the curly braces used after the <span class="literal">if</span> statement <span class="ent">❶❷</span>. These mark off a block of code that should execute in response to the <span class="literal">if</span>. In C, a code block can consist of multiple lines of code, although the braces can be omitted when the block consists of a single line. Python doesn’t use braces to delimit a block of code; it uses indentation instead. In Python, contiguous lines at the same level of indentation (say, four spaces) are considered part of the same block.</p>&#13;
<p class="indent">Python also includes an <span class="literal">elif</span> statement, which means “else if.” An <span class="literal">elif</span> statement is only evaluated if the preceding <span class="literal">if</span> or <span class="literal">elif</span> statement was false.</p>&#13;
<p class="programs"># A better age check in Python<br/>&#13;
if age &lt; 13:<br/>&#13;
    print('You are a youngster!')<br/>&#13;
<span epub:type="pagebreak" id="page_173"/>elif age &lt; 20:<br/>&#13;
    print('You are a teenager.')<br/>&#13;
else:<br/>&#13;
    print('You are older than a teen.')</p>&#13;
<p class="indent">The same thing can be accomplished in C by using an <span class="literal">else</span> coupled with an <span class="literal">if</span>:</p>&#13;
<p class="programs">// A better age check in C<br/>&#13;
if (age &lt; 13)<br/>&#13;
  printf("You are a youngster!");<br/>&#13;
else if (age &lt; 20)<br/>&#13;
  printf("You are a teenager!");<br/>&#13;
else<br/>&#13;
  printf("You are older than a teen.");</p>&#13;
<p class="indent">Note that I’ve also omitted the curly braces since all my code blocks are single lines.</p>&#13;
<h4 class="h4" id="lev2_27"><strong><em>Looping</em></strong></h4>&#13;
<p class="noindent">Sometimes a program needs to perform a certain action over and over. A <em>while loop</em> allows code to run repeatedly until some condition is met. In the following Python example, a <span class="literal">while</span> loop is used to print the numbers from 1 to 20.</p>&#13;
<p class="programs"># Count to 20 in Python.<br/>&#13;
n = 1<br/>&#13;
while n &lt;= 20:<br/>&#13;
    print(n)<br/>&#13;
    n = n + 1</p>&#13;
<p class="indent">Initially, the variable <span class="literal">n</span> is set to <span class="literal">1</span>. The <span class="literal">while</span> loop begins, indicating that the loop should run while <span class="literal">n</span> is less than or equal to <span class="literal">20</span>. Since <span class="literal">n</span> is <span class="literal">1</span>, it meets that requirement, so the body of the <span class="literal">while</span> loop runs, printing the value of <span class="literal">n</span> and adding 1 to it. Now <span class="literal">n</span> is equal to <span class="literal">2</span>, and the code goes back to the top of the <span class="literal">while</span> loop. This process continues until <span class="literal">n</span> is equal to <span class="literal">21</span>, at which point it no longer meets the requirements of the <span class="literal">while</span> loop, so the loop ends.</p>&#13;
<p class="indent">The following is the same thing implemented in C.</p>&#13;
<p class="programs">// Count to 20 in C.<br/>&#13;
int n = 1;<br/>&#13;
while(n &lt;= 20)<br/>&#13;
{<br/>&#13;
  printf("%d\n", n);<br/>&#13;
  n++;<br/>&#13;
}</p>&#13;
<p class="indent">In both examples, the body of the <span class="literal">while</span> loop increments the value of <span class="literal">n</span>. There’s actually a cleaner way to do this. A <em>for loop</em> allows iteration over a <span epub:type="pagebreak" id="page_174"/>range of numbers or a collection of values so that the programmer can perform some operation on each. Here we have an example in C that prints 1 through 10.</p>&#13;
<p class="programs">  // C uses a for loop to iterate over a numeric range.<br/>&#13;
  // This will print 1 through 10.<br/>&#13;
  for(<span class="ent">❶</span>int x = 1; <span class="ent">❷</span>x &lt;= 10; <span class="ent">❸</span>x++)<br/>&#13;
  {<br/>&#13;
<span class="ent">❹</span> printf("%d\n", x);<br/>&#13;
  }</p>&#13;
<p class="indent">The <span class="literal">for</span> loop declares <span class="literal">x</span> and sets its initial value to <span class="literal">1</span> <span class="ent">❶</span>, states that the loop will continue while <span class="literal">x</span> is less than or equal to <span class="literal">10</span> <span class="ent">❷</span>, and finally declares that <span class="literal">x</span> should be incremented after the body of the loop runs <span class="ent">❸</span>. By putting all of this information in a <span class="literal">for</span> statement on a single line, we can more easily see the conditions under which the loop will run. The body of the <span class="literal">for</span> loop simply prints the value of <span class="literal">x</span> <span class="ent">❹</span>.</p>&#13;
<p class="indent">Python takes a different approach with its <span class="literal">for</span> loops, allowing the program to take an action repeatedly on every item in a collection of values. The following Python example prints out the names of animals in a list.</p>&#13;
<p class="programs"># Python uses a for loop to iterate over a collection.<br/>&#13;
# This will print each animal name in animal_list.<br/>&#13;
animal_list = ['cat', 'dog', 'mouse']<br/>&#13;
for animal in animal_list:<br/>&#13;
    print(animal)</p>&#13;
<p class="indent">First, a list of animal names is declared and assigned to a variable named <span class="literal">animal_list</span>. In Python, a list is an ordered collection of values. Next, the <span class="literal">for</span> loop states that the code block runs once for each item in <span class="literal">animal_list</span>, and each time the code runs, the current value in the list is assigned to the <span class="literal">animal</span> variable. So the first time the body of the loop runs, <span class="literal">animal</span> is equal to <span class="literal">cat</span>, and the program prints <span class="literal">cat</span>. The next time through <span class="literal">dog</span> prints, and the final time <span class="literal">mouse</span> prints.</p>&#13;
<h3 class="h3" id="lev1_62"><strong>Functions</strong></h3>&#13;
<p class="noindent">Looping allows a set of instructions to run multiple times in a row. However, it’s also common for a program to run a particular set of instructions multiple times, but not necessarily in a loop. Instead, such instructions may need to be invoked from different parts of the program, at different times, and with varying inputs and outputs. When a programmer realizes that the same code is needed in multiple places, they may write that code as a function. A <em>function</em> is a set of program instructions that may be invoked, or called, by other code. Functions optionally take inputs (known as <em>parameters</em>) and return an output (known as a <em>return value</em>). Different high-level languages use different terms for a function, including <em>subroutine</em>, <em>procedure</em>, or <em>method</em>. In some cases, these various names actually convey slightly different meanings, but for our purposes, let’s just stick with function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_175"/>Converting a character string to lowercase, printing text to the screen, and downloading a file from the internet are all examples of what you can do with reusable code in the form of a function. Programmers want to avoid typing out the same code multiple times. Doing so means maintaining several copies of the same code and increasing the overall size of a program. This violates a software engineering principle known as <em>don’t repeat yourself (DRY)</em> that encourages a reduction of duplicative code.</p>&#13;
<p class="indent">Functions are another example of encapsulation. We saw encapsulation earlier in the context of hardware, and here we see it again, this time in software. Functions encapsulate the internal details of a block of code while providing an interface for making use of that code. A developer who wants to use a function only needs to understand its inputs and outputs; a full understanding of the function’s internal workings isn’t needed.</p>&#13;
<h4 class="h4" id="lev2_28"><strong><em>Defining Functions</em></strong></h4>&#13;
<p class="noindent">A function must be defined before it can be used. Once defined, you use a function by calling it. A <em>function definition</em> includes the name of the function, the input parameters, the program statements for the function (called the <em>body</em> of the function), and in some languages, the return value type. Here we have a sample C function that calculates the area of a circle, given its radius.</p>&#13;
<p class="programs">  // C function to calculate the area of a circle<br/>&#13;
<span class="ent">❶</span> double <span class="ent">❷</span>areaOfCircle(<span class="ent">❸</span>double radius)<br/>&#13;
  {<br/>&#13;
    double area = 3.14 * radius * radius;<br/>&#13;
  <span class="ent">❹</span> return area;<br/>&#13;
  }</p>&#13;
<p class="indent">The <span class="literal">double</span> type at the beginning <span class="ent">❶</span> indicates that the function returns a floating-point number (<span class="literal">double</span> is one of the floating-point types in C). The function has a name, <span class="literal">areaOfCircle</span> <span class="ent">❷</span>, meant to convey what the function does—in this case, calculate the area of a circle. The function takes one input parameter named <span class="literal">radius</span> <span class="ent">❸</span>, also of type <span class="literal">double</span>.</p>&#13;
<p class="indent">Between the opening and closing curly braces we have the body of the function, which defines exactly how the function works. We declare a local variable named <span class="literal">area</span>. It’s also of type <span class="literal">double</span>. The area is calculated as <span class="literal">π</span> × radius<sup>2</sup> and assigned to the <span class="literal">area</span> variable. Finally, the function returns the value of the <span class="literal">area</span> variable <span class="ent">❹</span>. Note that the <span class="literal">area</span> variable’s scope is limited; it cannot be accessed outside of this function. When the function returns, the local variable <span class="literal">area</span> is discarded (it was probably stored on the stack), but its value is returned to the caller, likely via a processor register.</p>&#13;
<p class="indent">The following is a similar area function, this time written in Python.</p>&#13;
<p class="programs"># Python function to calculate the area of a circle<br/>&#13;
def area_of_circle(radius)<br/>&#13;
    area = 3.14 * radius * radius<br/>&#13;
    return area</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Let’s compare the two function examples. Both calculate the <span class="literal">area</span> as <span class="literal">π</span> × radius<sup>2</sup> and then return that value. Both take one input parameter named <span class="literal">radius</span>. The C version explicitly defines the return type as <span class="literal">double</span> and the type of radius as <span class="literal">double</span>, while the Python version doesn’t require the types to be declared. Python indicates that a function definition is about to begin with the <span class="literal">def</span> keyword.</p>&#13;
<h4 class="h4" id="lev2_29"><strong><em>Calling Functions</em></strong></h4>&#13;
<p class="noindent">Defining a function in a program isn’t enough to ensure that function will run. A function definition simply makes the code available for other code to invoke when needed. Such an invocation is known as a <em>function call</em>. The calling code passes any needed parameters and hands control over to the function. The function then executes its code and returns control (and any output) back to the caller. The following demonstrates calling our example function in C:</p>&#13;
<p class="programs">// Calling a function twice in C, each time with a different input<br/>&#13;
double area1 = areaOfCircle(2.0);<br/>&#13;
double area2 = areaOfCircle(38.6);</p>&#13;
<p class="noindent">and in Python:</p>&#13;
<p class="programs"># Calling a function twice in Python<br/>&#13;
area1 = area_of_circle(2.0)<br/>&#13;
area2 = area_of_circle(38.6)</p>&#13;
<p class="indent">Once the function returns, it’s up to the calling code to store the returned value somewhere. Variables <span class="literal">area1</span> and <span class="literal">area2</span> are declared in both examples to hold the return values from the function calls. In both languages, <span class="literal">area1</span> is 12.56 and <span class="literal">area2</span> is 4,678.4744. Actually, the calling code can just ignore the returned value and not assign it to a variable, but that is not very useful, considering this function’s purpose. <a href="ch09.xhtml#ch9fig5">Figure 9-5</a> illustrates how calling a function temporarily cedes control to that function.</p>&#13;
<div class="image" id="ch9fig5"><img src="../images/fig9-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-5: Calling a function</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9fig5">Figure 9-5</a>, the Python code on the left calls the <span class="literal">area_of_circle</span> function, passing it an input <span class="literal">radius</span> parameter value of <span class="literal">2.0</span>. The code on the left then waits until the function on the right completes its work. Once the function returns, the code on the left stores the returned value in variable <span class="literal">area1</span>, and it then resumes execution.</p>&#13;
<h4 class="h4" id="lev2_30"><strong><em><span epub:type="pagebreak" id="page_177"/>Using Libraries</em></strong></h4>&#13;
<p class="noindent">Although programmers do define functions for their own use, an important part of programming is knowing how to best leverage functions that other people have already written. Programming languages usually include a large set of functions known as the <em>standard library</em> for that language. In this context, a <em>library</em> is a collection of code intended to be used by other software. Both C and Python include standard libraries that provide functions for things such as printing to the console, working with files, and text processing. Python’s standard library is particularly extensive and well-regarded. Although not always the case, most implementations of a language include that language’s standard library, so programmers can rely on those functions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj17">Project #17</a> on <a href="ch09.xhtml#page_189">page 189</a>, where you can use what you’ve learned to write a simple guessing game in Python. This includes using the Python standard library</em>.</p>&#13;
</div>&#13;
<p class="indent">Outside of the standard library, additional libraries of functions are also available for many programming languages. Developers write libraries for others to use and share them in the form of source code or as compiled files. These libraries are sometimes shared informally, and certain programming languages have a well-known, accepted mechanism for publishing libraries. A shared set of libraries is known as a <em>package</em>, and a system for sharing such packages is known as a <em>package manager</em>. Several package managers are available for C, but none of them is universally accepted as a standard by C programmers. Python’s included package manager is called <span class="literal">pip</span>. <span class="literal">pip</span> makes it easy to install community-developed software libraries for Python, and it’s commonly used by Python developers.</p>&#13;
<h3 class="h3" id="lev1_63"><strong>Object-Oriented Programming</strong></h3>&#13;
<p class="noindent">Programming languages are designed to support specific <em>paradigms</em>, or approaches, to programming. Examples include procedural programming, functional programming, and object-oriented programming. A language may be designed to support one or multiple paradigms, and it is up to the software developer to use the language in a way that fits a certain paradigm. Let’s take a look at one popular paradigm: <em>object-oriented programming</em>, an approach to programming in which code and data are grouped together in a construct known as an <em>object</em>. Objects are meant to represent a logical grouping of data and functionality in a way that models real-world concepts.</p>&#13;
<p class="indent">Object-oriented programming languages commonly use a class-based approach. A <em>class</em> is a blueprint for an object. An object created from a class is said to be an <em>instance</em> of that class. Functions defined in a class are known as <em>methods</em>, and variables declared in a class are known as <em>fields</em>. In <span epub:type="pagebreak" id="page_178"/>Python, fields that have different values for each instance of a class are called <em>instance variables</em>, whereas fields that have the same value across all instances of the class are called <em>class variables</em>.</p>&#13;
<p class="indent">For example, a class could be written that describes a bank account. The bank account class might have a field for the balance, a field for the holder’s name, and methods for withdrawing and depositing money. The class describes a generic bank account, but no specific instance of a bank account exists until a bank account object is created from that class. This is illustrated in <a href="ch09.xhtml#ch9fig6">Figure 9-6</a>.</p>&#13;
<div class="image" id="ch9fig6"><img src="../images/fig9-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-6: Bank account objects are created from a bank account class.</em></p>&#13;
<p class="indent">As you can see in <a href="ch09.xhtml#ch9fig6">Figure 9-6</a>, the <span class="literal">BankAccount</span> class describes the fields and methods of the bank account, providing us with an understanding of what a bank account is like. Two objects, instances of the <span class="literal">BankAccount</span> class, have been created. These objects are specific bank accounts, with names and balances assigned. We can use each object’s <span class="literal">withdraw</span> or <span class="literal">deposit</span> method to modify its <span class="literal">balance</span> field. In Python, depositing into a bank account object named <span class="literal">myAccount</span> would look like this, resulting in an increase of 25 to its <span class="literal">balance</span> field:</p>&#13;
<p class="programs">myAccount.deposit(25)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj18">Project #18</a> on <a href="ch09.xhtml#page_190">page 190</a>, where you can try a Python implementation of the bank account class just described</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_64"><strong><span epub:type="pagebreak" id="page_179"/>Compiled or Interpreted</strong></h3>&#13;
<p class="noindent">As mentioned earlier, source code is the text of a program as originally written by developers, and it usually isn’t written in a programming language that CPUs understand directly. CPUs only understand machine language, so additional steps are required: source code must be either compiled to machine code or interpreted by other code at runtime.</p>&#13;
<p class="indent">In a <em>compiled language</em>, like C, source code is converted into machine instructions that can be directly executed by a processor. That process was described earlier in this chapter in “High-Level Programming Overview” on <a href="ch09.xhtml#page_160">page 160</a>. Source code is compiled during the development process, and the compiled executable files (sometimes called <em>binaries</em>) are delivered to end users. When end users run binaries, they don’t need access to the source code. Compiled code tends to be fast, but it only runs on the architecture for which it was compiled. <a href="ch09.xhtml#ch9fig7">Figure 9-7</a> shows an example of how a developer would compile and run a C program from a command line using the GNU C Compiler (<span class="literal">gcc</span>).</p>&#13;
<div class="image" id="ch9fig7"><img src="../images/fig9-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-7: Compiling a C source file to an executable file that can run on its own</em></p>&#13;
<p class="indent">In an <em>interpreted language</em>, like Python, the source code is not compiled ahead of time. Instead, it is read by a program called an <em>interpreter</em> that reads and executes the program’s instructions. It’s the interpreter’s machine code that actually runs on the CPU. Developers of code in interpreted languages can distribute their source code and end users can run it directly, without the need for a potentially complex compilation step. In this scenario, the developers don’t need to worry about compiling their code for lots of different platforms—as long as the user has the appropriate interpreter on their system, they can run the code. In this way, the distributed code is platform-independent.</p>&#13;
<p class="indent">Interpreted code tends to run more slowly than compiled code due to the overhead of interpreting the code as it runs. Distributing interpreted code works best when the user already has the required interpreter installed or the user is technically proficient enough that installing an interpreter isn’t a barrier. Otherwise, the developer needs to either bundle the interpreter with their software or guide the user through installing the interpreter. <span epub:type="pagebreak" id="page_180"/><a href="ch09.xhtml#ch9fig8">Figure 9-8</a> shows an example of running a Python program from a command line, assuming the Python version 3 interpreter is already installed. Note how the Python source code in <em>hello.py</em> is given directly to the interpreter—no intermediate step required.</p>&#13;
<div class="image" id="ch9fig8"><img src="../images/fig9-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-8: The Python interpreter runs Python source code.</em></p>&#13;
<p class="indent">Some languages use a system that’s a hybrid of these two approaches. Such languages compile to an <em>intermediate language</em>, or <em>bytecode</em>. Bytecode is similar to machine code, but rather than targeting a specific hardware architecture, bytecode is designed to run on a virtual machine, as illustrated in <a href="ch09.xhtml#ch9fig9">Figure 9-9</a>.</p>&#13;
<div class="image" id="ch9fig9"><img src="../images/fig9-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 9-9: A bytecode compiler turns source code into bytecode that runs inside a virtual machine.</em></p>&#13;
<p class="indent">In this context, a <em>virtual machine</em> is a software platform designed to run other software. The virtual machine provides a virtual CPU and execution environment, abstracting the details of the real underlying hardware and operating system. For example, Java source code is compiled to Java bytecode, which then runs within the Java virtual machine. Similarly, C# source code is compiled to Common Intermediate Language and runs in the .NET Common Language Runtime (CLR) virtual machine. CPython, the original implementation of Python, actually converts Python source code to bytecode before running it, although this is an implementation detail of the CPython interpreter and mostly hidden from Python developers. Programming languages that use bytecode retain the platform-independence of interpreted languages while preserving some of the performance gains of compiled code.</p>&#13;
<h3 class="h3" id="lev1_65"><strong>Calculating a Factorial in C</strong></h3>&#13;
<p class="noindent">To wrap up our look at high-level programming, let’s now examine an implementation of the factorial algorithm, this time in the C language. We did this before in ARM assembly, so seeing the same logic in C should serve as a good comparison between assembly language and a high-level language. This C code uses several of the concepts we just covered. I chose <span epub:type="pagebreak" id="page_181"/>to use C rather than Python because it’s a compiled language, and we can examine the compiled machine code. Here’s a simple C function that calculates the factorial of a number:</p>&#13;
<p class="programs">// Calculate the factorial of n.<br/>&#13;
int factorial(int n)<br/>&#13;
{<br/>&#13;
  int result = n;<br/>&#13;
<br/>&#13;
  while(--n &gt; 0)<br/>&#13;
  {<br/>&#13;
    result = result * n;<br/>&#13;
  }<br/>&#13;
<br/>&#13;
  return result;<br/>&#13;
}</p>&#13;
<p class="indent">Other code can call this function, passing the <span class="literal">n</span> parameter as the value whose factorial should be calculated. The function then internally calculates the factorial value, storing it in the local variable <span class="literal">result</span> and returning the calculated value to the caller. As we did with the assembly code in <a href="ch08.xhtml">Chapter 8</a>, let’s again use an exercise to explore this code in depth.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch9ex2"><strong>EXERCISE 9-2: RUN A C PROGRAM IN YOUR MIND</strong></p>&#13;
<p class="exercise-para">Try running the preceding factorial function in your head or use pencil and paper. Assume an input value of <span class="literal">n</span> = 4. When the function returns, the returned result should be the expected value of 24. I recommend that for each line, you keep track of the values of <span class="literal">n</span> and <span class="literal">result</span> before and after the statement completes. Work through the code until you reach the end of the <span class="literal">while</span> loop and see if you get the expected result. The answer is in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
<p class="exercise-parai">Note that the condition of the <span class="literal">while</span> loop (<span class="literal">--n</span> &gt; 0) places the decrement operator (<span class="literal">--</span>) before the variable <span class="literal">n</span>. This means that <span class="literal">n</span> is decremented <em>before</em> its value is compared to 0. This happens each time the <span class="literal">while</span> loop condition is evaluated.</p>&#13;
</div>&#13;
<p class="indent">I hope that you find the C version of our algorithm more readable than the ARM assembly version! The other major advantage of this version of our factorial code is that it isn’t tied to a specific processor type. It could be compiled for any processor, given an appropriate compiler. If you compile the earlier C code for an ARM processor, you see machine code generated that’s similar to the ARM assembly we examined earlier. You’ll get a chance to do that in <a href="ch09.xhtml#proj19">Project #19</a>, but for now I’ve compiled and disassembled the code for you:</p>&#13;
<p class="programs">Address   Assembly<br/>&#13;
0001051c  sub     r3, r0, #1<br/>&#13;
00010520  cmp     r3, #0<br/>&#13;
00010524  bxle    lr<br/>&#13;
<span epub:type="pagebreak" id="page_182"/>00010528  mul     r0, r3, r0<br/>&#13;
0001052c  subs    r3, r3, #1<br/>&#13;
00010530  bne     00010528<br/>&#13;
00010534  bx      lr</p>&#13;
<p class="indent">As you can see, the code generated from the C source is quite similar to the assembly factorial example we covered in <a href="ch08.xhtml">Chapter 8</a>. There are some differences, but the specifics aren’t relevant to our discussion. The thing to note here is that a program can be written in a high-level language like C, and a compiler can do the hard work of translating the high-level statements to machine code. You can see how working in a high-level language can simplify things for a developer, but in the end, we still end up with bytes of machine code, because that’s what a processor needs.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch09.xhtml#proj19">Project #19</a> on <a href="ch09.xhtml#page_191">page 191</a>, where you can try compiling and then disassembling a factorial program in C</em>.</p>&#13;
</div>&#13;
<p class="indent">Something interesting happened here, and I want to make sure you didn’t miss it. We started with source code written in the C programming language, compiled it into machine code, and then disassembled it into assembly language. The implication of this is that if you have a compiled program or software library on your computer, you can examine its code as assembly language! You may not have access to the original source code, but the assembly version of the program is within your grasp.</p>&#13;
<p class="indent">We’ve been looking at machine code and assembly language for the ARM processor specifically, but as mentioned earlier, one of the advantages of developing in a high-level language like C is that the same code can be compiled for a different processor. In fact, the same code can even be compiled for another operating system, as long as the code in question doesn’t use functionality that’s specific to a particular operating system. To illustrate this point, I’ve compiled the same factorial C code for a 32-bit x86 processor, this time on Windows rather than Linux. Here’s the generated machine code, shown as assembly language:</p>&#13;
<p class="programs">Address   Assembly<br/>&#13;
00406c35  mov     ecx,dword ptr [esp+4]<br/>&#13;
00406c39  mov     eax,ecx<br/>&#13;
00406c3b  jmp     00406c40<br/>&#13;
00406c3d  imul    eax,ecx<br/>&#13;
00406c40  dec     ecx<br/>&#13;
00406c41  test    ecx,ecx<br/>&#13;
00406c43  jg      00406c3d<br/>&#13;
00406c45  ret</p>&#13;
<p class="indent">I won’t elaborate on the details of this code, but feel free to research the x86 instruction set and interpret the code yourself. The main thing I hope you take away from this example is that high-level languages, like C, allow developers to write code that’s easier to understand than assembly and that can be easily compiled for various processors.</p>&#13;
<h3 class="h3" id="lev1_66"><strong><span epub:type="pagebreak" id="page_183"/>Summary</strong></h3>&#13;
<p class="noindent">In this chapter we covered high-level programming languages. Such languages are independent from a specific CPU and syntactically closer to human language. You learned about common elements found across programming languages, such as comments, variables, functions, and looping capabilities. You saw how these elements are expressed in two programming languages: C and Python. Finally, we examined an example program in C, and you saw the disassembled machine code generated by compiling high-level code.</p>&#13;
<p class="indent">In the next chapter, we’ll cover operating systems. We’ll start with an overview of the capabilities provided by operating systems, learn about the various families of operating systems, and dive deeper into how operating systems work. Along the way you’ll have the opportunity to explore Raspberry Pi OS, a version of Linux tailored for the Raspberry Pi.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_184"/>&#13;
<p class="exercise" id="proj14"><strong><span class="black1">PROJECT #14: EXAMINE VARIABLES</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to <a href="appb.xhtml">Appendix B</a> and read the entire “Raspberry Pi” section on <a href="appb.xhtml#page_341">page 341</a> if you haven’t already.</p>&#13;
<p class="exercise-parai">In this project, you’ll write high-level code that uses variables and examine how this works in memory. Use the text editor of your choice to create a new file called <em>vars.c</em> in the root of your home folder. Enter the following C code into your text editor (you don’t have to preserve indentation and empty lines, but be sure to maintain line breaks).</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<span class="ent">❶</span><br/>&#13;
#include &lt;signal.h&gt;<br/>&#13;
 <br/>&#13;
int main()<span class="ent">❷</span><br/>&#13;
{<br/>&#13;
  int points = 27;<span class="ent">❸</span><br/>&#13;
  int year = 2020;<span class="ent">❹</span><br/>&#13;
 <br/>&#13;
  printf("points is %d and is stored at 0x%08x\n", points, &amp;points);<span class="ent">❺</span><br/>&#13;
  printf("year is %d and is stored at 0x%08x\n", year, &amp;year);<br/>&#13;
 <br/>&#13;
  raise(SIGINT);<span class="ent">❻</span><br/>&#13;
 <br/>&#13;
  return 0;<br/>&#13;
}</p>&#13;
<p class="exercise-parai">Before continuing, let’s examine the source code. It begins by including a couple of header files <span class="ent">❶</span>. These files include details required by the C compiler about the <span class="literal">printf</span> and <span class="literal">raise</span> functions that are used later in the program. Next you see the <span class="literal">main</span> function defined <span class="ent">❷</span>; this is the entry point of the program where execution begins. The program then declares two integer variables, <span class="literal">points</span> <span class="ent">❸</span> and <span class="literal">year</span> <span class="ent">❹</span>, and assigns values to them. It then prints out both the values of the variables and their memory addresses (in hexadecimal) <span class="ent">❺</span>. The <span class="literal">raise(SIGINT)</span> statement causes the program to halt execution <span class="ent">❻</span>. This is not something you normally do in code that end users run; it’s a technique we use here to assist with debugging.</p>&#13;
<p class="exercise-parai">Once the file is saved, use the GNU C Compiler (<span class="literal">gcc</span>) to compile your code into an executable file. Open a terminal on your Raspberry Pi and enter the following command to invoke the compiler. This command takes <em>vars.c</em> as an input, compiles and links the code, and outputs an executable file named <em>vars</em>.</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o vars vars.c</span></p>&#13;
<p class="exercise-parai">Now try running the compiled code using the following command. The program should print out the values and addresses of the program’s two variables.</p>&#13;
<p class="programs">$ <span class="codestrong1">./vars</span></p>&#13;
<p class="exercise-parai">Once you’ve confirmed that the program works, run it under the GNU Debugger (<span class="literal">gdb</span>) and examine the variables in memory.</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb vars</span></p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_185"/>At this point <span class="literal">gdb</span> has loaded the file but no instructions have run yet. From the <span class="literal">(gdb)</span> prompt, type the following to run the program, which will continue until the <span class="literal">raise(SIGINT)</span> statement is executed.</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">run</span></p>&#13;
<p class="exercise-parai">Once the program returns to a <span class="literal">(gdb)</span> prompt, you should see a couple of lines where the values and memory addresses of the variables were printed. Following those lines, you may also see a potentially worrisome statement about “no such file or directory”—you can ignore it. It’s just the debugger trying to find some source code that isn’t on your system. The output you do need to pay attention to should look something like this:</p>&#13;
<p class="programs">Starting program: /home/pi/vars<br/>&#13;
points is 27 and is stored at 0x7efff1d4<br/>&#13;
year is 2020 and is stored at 0x7efff1d0</p>&#13;
<p class="exercise-parai">Now you know the memory addresses, and since you’re conveniently in the debugger, you’re ready to examine what’s stored at those addresses. In this output, you can see that <span class="literal">year</span> is stored at the lower address, and <span class="literal">points</span> is stored 4 bytes later, so you’ll dump out memory starting at the address of the <span class="literal">year</span> variable, <span class="literal">0x7efff1d0</span> in my case. Your address may be different. The following command dumps out three 32-bit values in memory, in hexadecimal, starting at address <span class="literal">0x7efff1d0</span>. Replace <span class="literal">0x7efff1d0</span> with the address of <span class="literal">year</span> on your system if they differ.</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">x/3xw 0x7efff1d0</span><br/>&#13;
0x7efff1d0:     0x000007e4      0x0000001b      0x00000000</p>&#13;
<p class="exercise-parai">You can see here that the value stored at <span class="literal">0x7efff1d0</span> is <span class="literal">0x000007e4</span>. That’s 2020 in decimal, the expected <span class="literal">year</span> value. And the value stored 4 bytes later is <span class="literal">0x0000001b</span>, or 27 decimal, the expected <span class="literal">points</span> value. The next value in memory happens to be 0 and isn’t one of our variables. Memory is usually examined in hexadecimal, but if you want to see these values in decimal, you can use the following command instead:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">x/3dw 0x7efff1d0</span><br/>&#13;
0x7efff1d0:     2020    27      0</p>&#13;
<p class="exercise-parai">You’re looking at memory in 32-bit (4-byte) chunks, since that’s the size of the variables used in this program. But memory is actually byte addressable, meaning each byte has its own address. That’s why <span class="literal">points</span> has an address 4 bytes greater than the address of <span class="literal">year</span>. Let’s look at the same memory range as a series of bytes instead:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">x/12xb 0x7efff1d0</span><br/>&#13;
0x7efff1d0:     <span class="codestrong1">0xe4</span>    <span class="codestrong1">0x07</span>    <span class="codestrong1">0x00</span>    <span class="codestrong1">0x00</span>    0x1b    0x00    0x00    0x00<br/>&#13;
0x7efff1d8:     0x00    0x00    0x00    0x00</p>&#13;
<p class="exercise-parai">Look at the value for <span class="literal">year</span>, emphasized here. Note how the least significant byte (<span class="literal">0xe4</span>) comes first. This is due to little-endian data storage, as discussed on <a href="ch08.xhtml#page_156">page 156</a> in <a href="ch08.xhtml#proj13">Project #13</a>. You can exit <span class="literal">gdb</span> with <span class="literal">q</span> (it will ask you if you want to quit even though a debugging session is active; answer <span class="literal">y</span>).</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_186"/>&#13;
<p class="exercise" id="proj15"><strong><span class="black1">PROJECT #15: CHANGE THE TYPE OF VALUE REFERENCED BY A VARIABLE IN PYTHON</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to <a href="appb.xhtml">Appendix B</a> and read the entire “Raspberry Pi” section on <a href="appb.xhtml#page_341">page 341</a> if you haven’t already.</p>&#13;
<p class="exercise-parai">In this project, you'll write code that sets a Python variable to a value of a certain type and then updates that variable to reference a value of a different type. Use the text editor of your choice to create a new file called <em>vartype.py</em> in the root of your home folder. Enter the following Python code into your text editor:</p>&#13;
<p class="programs">age = 22<br/>&#13;
print('What is the type?')<br/>&#13;
print(type(age))<br/><br/>&#13;
age = 'twenty-two'<br/>&#13;
print('Now what is the type?')<br/>&#13;
print(type(age))</p>&#13;
<p class="exercise-parai">This code sets the variable named <span class="literal">age</span> to an integer value and then prints the type of that value. It then sets <span class="literal">age</span> to a string value and prints the type again.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run the file from a terminal window using the Python interpreter, like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 vartype.py</span></p>&#13;
<p class="exercise-parai">You should see output like the following:</p>&#13;
<p class="programs">What is the type?<br/>&#13;
&lt;class 'int'&gt;<br/>&#13;
Now what is the type?<br/>&#13;
&lt;class 'str'&gt;</p>&#13;
<p class="exercise-parai">You can see how the type changes from an integer to a string by simply assigning the variable a new value. Don't let the term <span class="literal">class</span> confuse you; in Python 3, built-in types such as <span class="literal">int</span> and <span class="literal">str</span> are considered classes (covered in “Object-Oriented Programming” on <a href="ch09.xhtml#page_177">page 177</a>). Setting a variable to a value of a different type is easy in Python but not allowed at all in C.</p>&#13;
<p class="exercise-parac"><strong><em>VERSIONS OF PYTHON</em></strong></p>&#13;
<p class="exercise-para">Two major versions of Python are in use today, Python 2 and Python 3. As of January 1, 2020, Python 2 is no longer supported, meaning no new bug fixes will be made to it. Python developers are encouraged to migrate old projects to Python 3, and new projects should target Python 3. Accordingly, the projects in this book use Python 3. On Raspberry Pi OS and some other Linux distributions, running <span class="codestrong">python</span> from a command line will invoke the Python 2 interpreter, while running <span class="codestrong">python3</span> will invoke the Python 3 interpreter. That’s why the projects in this book have you <span epub:type="pagebreak" id="page_187"/>specifically run <span class="codestrong">python3</span> rather than <span class="codestrong">python</span>. That said, on other platforms, or even on future versions of Raspberry Pi OS, this may not hold true, and entering <span class="codestrong">python</span> may actually invoke Python 3. You can check the invoked version of Python like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python --version</span></p>&#13;
<p class="exercise-para">or</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 --version</span></p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj16"><strong><span class="black1">PROJECT #16: STACK OR HEAP</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: <a href="ch09.xhtml#proj14">Project #14</a>.</p>&#13;
<p class="exercise-parai">In this project, you'll look at whether variables are allocated in stack or heap memory in a running program. Open a terminal on your Raspberry Pi, and begin by debugging the <span class="literal">vars</span> program you previously compiled in <a href="ch09.xhtml#proj14">Project #14</a>:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb vars</span></p>&#13;
<p class="exercise-parai">At this point <span class="literal">gdb</span> has loaded the file but no instructions have run yet. From the <span class="literal">gdb</span> prompt, type the following to run the program, which continues until the <span class="literal">SIGINT</span> statement is executed.</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">run</span></p>&#13;
<p class="exercise-parai">Again, look at the memory addresses of the <span class="literal">points</span> and <span class="literal">year</span> variables. In my case, these variables were found at <span class="literal">0x7efff1d4</span> and <span class="literal">0x7efff1d0</span>, but your addresses may vary. Now use the following command to see all the mapped memory locations for your running program:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">info proc mappings</span></p>&#13;
<p class="exercise-parai">The output lists the start and end address of the various memory ranges in use by this program. Find the one that includes the addresses of your variables. Both variable addresses should fall within a single range. For me, this entry matched:</p>&#13;
<p class="programs">    0x7efdf000 0x7f000000   0x21000       0x0 [stack]</p>&#13;
<p class="exercise-parai">As you can see, <span class="literal">gdb</span> indicates that this memory range is allocated for the stack, which is exactly where we would expect local variables to be. You can exit <span class="literal">gdb</span> with <span class="literal">q</span> (it will ask you if you want to quit even though a debugging session is active; answer <span class="literal">y</span>).</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_188"/>Let’s now look at memory allocated on the heap. You need to modify <em>vars.c</em> and rebuild it so that the program allocates some heap memory. Use the text editor of your choice to open the existing <em>vars.c</em> file. Add the following line of code as the very first line:</p>&#13;
<p class="programs">#include &lt;stdlib.h&gt;</p>&#13;
<p class="exercise-parai">Then add these two lines immediately before the <span class="literal">SIGINT</span> line:</p>&#13;
<p class="programs">void * data = malloc(512);<br/>&#13;
printf("data is 0x%08x and is stored at 0x%08x\n", data, &amp;data);</p>&#13;
<p class="exercise-parai">Let’s cover what these changes mean. We call the memory allocation function <span class="literal">malloc</span> to allocate 512 bytes of memory from the heap. The <span class="literal">malloc</span> function returns the address of the newly allocated memory. That address is stored in a new local variable called <span class="literal">data</span>. The program then prints two memory addresses: the address of the new heap allocation and the address of the data variable itself, which should be on the stack.</p>&#13;
<p class="exercise-parai">Once the file is saved, use <span class="literal">gcc</span> to compile your code:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o vars vars.c</span></p>&#13;
<p class="exercise-parai">Now run the program again:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb vars</span><br/>&#13;
(gdb) <span class="codestrong1">run</span></p>&#13;
<p class="exercise-parai">Check the newly printed values. For me, the values are as follows:</p>&#13;
<p class="programs">data is 0x00022410 and is stored at 0x7efff1ac</p>&#13;
<p class="exercise-parai">We expect that the first address, the address that came back from <span class="literal">malloc</span>, to be on the heap. The second value, the address of the <span class="literal">data</span> local variable, should be on the stack. Again, run the following to see this program’s memory ranges and see where these two addresses fall.</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">info proc mappings</span><br/>&#13;
<br/>&#13;
...<br/>&#13;
           0x22000    0x43000    0x21000        0x0 [heap]<br/>&#13;
...<br/>&#13;
        0x7efdf000 0x7f000000    0x21000        0x0 [stack]</p>&#13;
<p class="exercise-parai">Find the matching address ranges on your system and confirm that the addresses fall in the expected ranges of heap and stack. You can exit <span class="literal">gdb</span> with <span class="literal">q</span>.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_189"/>&#13;
<p class="exercise" id="proj17"><strong><span class="black1">PROJECT #17: WRITE A GUESSING GAME</span></strong></p>&#13;
<p class="exercise-para">In this project, you'll write a guessing game in Python, building on what we’ve covered in this chapter. Use the text editor of your choice to create a new file named <em>guess.py</em> in the root of your home folder. Enter the following Python code into your text editor. In Python, indentation matters, so make sure you indent appropriately.</p>&#13;
<p class="programs">from random import randint<span class="ent">❶</span><br/><br/>&#13;
secret = randint(1, 10)<span class="ent">❷</span><br/>&#13;
guess = 0<span class="ent">❸</span><br/>&#13;
count = 0<span class="ent">❹</span><br/><br/>&#13;
print('Guess the secret number between 1 and 10')<br/><br/>&#13;
while guess != secret:<span class="ent">❺</span><br/>&#13;
    guess = int(input())<span class="ent">❻</span><br/>&#13;
    count += 1<br/><br/>&#13;
    if guess == secret:<span class="ent">❼</span><br/>&#13;
        print('You got it! Nice job.')<br/>&#13;
    elif guess &lt; secret:<br/>&#13;
        print('Too low. Try again.')<br/>&#13;
    else:<br/>&#13;
        print('Too high. Try again.')<br/><br/>&#13;
print('You guessed {0} times.'.format(count))<span class="ent">❽</span></p>&#13;
<p class="exercise-parai">Let’s examine how this program works. This code starts by importing a function called <span class="literal">randint</span> that generates random integers <span class="ent">❶</span>. This is an example of using a function that was written by someone else; <span class="literal">randint</span> is a part of the Python standard library. This call to the <span class="literal">randint</span> function returns a random integer in the range of <span class="literal">1</span> to <span class="literal">10</span>, which we’ve stored in a variable named <span class="literal">secret</span> <span class="ent">❷</span>. The code then sets a variable called <span class="literal">guess</span> to <span class="literal">0</span> <span class="ent">❸</span>. This variable holds the player’s guess, and it’s assigned an initial value of <span class="literal">0</span>, a value we can be sure won’t match the secret value. A third variable named <span class="literal">count</span> <span class="ent">❹</span> keeps track of the number of times that the player guessed so far.</p>&#13;
<p class="exercise-parai">The <span class="literal">while</span> loop runs as long as the player’s <span class="literal">guess</span> doesn’t match the <span class="literal">secret</span> <span class="ent">❺</span>. The code within the loop calls the built-in function <span class="literal">input</span> to get the user’s guess from the console <span class="ent">❻</span>, and the result is converted to an integer and stored in the <span class="literal">guess</span> variable. Each time a guess is entered, it’s checked against the <span class="literal">secret</span> variable to see whether it’s a match, too low, or too high <span class="ent">❼</span>. Once the player’s <span class="literal">guess</span> matches the <span class="literal">secret</span>, the loop exits, and the program prints the number of times that the player guessed <span class="ent">❽</span>.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run it using the Python interpreter like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 guess.py</span></p>&#13;
<p class="exercise-parai">Try out the program several times; the secret number should change each time you run it. You may want to try modifying the program so that the range of allowed integers is larger, or maybe you want to put in your own custom messages. As a challenge, try modifying the program so that when the guess is really close, the program prints a different message.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_190"/>&#13;
<p class="exercise" id="proj18"><strong><span class="black1">PROJECT #18: USE A BANK ACCOUNT CLASS IN PYTHON</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll write a bank account class in Python and then create an object based on that class. Use the text editor of your choice to create a new file named <em>bank.py</em> in the root of your home folder. Enter the following Python code into your text editor. You can skip typing in the comments (lines that begin with <span class="literal">#</span>) if you prefer. Note that <span class="literal">__init__</span> has two underscore characters at its beginning and end.</p>&#13;
<p class="programs"># Define a bank account class in Python.<br/>&#13;
class BankAccount:<span class="ent">❶</span><br/>&#13;
    def __init__(self, balance, name):<span class="ent">❷</span><br/>&#13;
        self.balance = balance<span class="ent">❸</span><br/>&#13;
        self.name = name<span class="ent">❹</span><br/><br/>&#13;
    def withdraw(self, amount):<span class="ent">❺</span><br/>&#13;
        self.balance = self.balance - amount<br/><br/>&#13;
    def deposit(self, amount):<span class="ent">❻</span><br/>&#13;
        self.balance = self.balance + amount<br/><br/>&#13;
# Create a bank account object based on the class.<br/>&#13;
smithAccount = BankAccount(10.0, 'Harriet Smith')<span class="ent">❼</span><br/><br/>&#13;
# Deposit some additional money to the account.<br/>&#13;
smithAccount.deposit(5.25)<span class="ent">❽</span><br/><br/>&#13;
# Print the account balance.<br/>&#13;
print(smithAccount.balance)<span class="ent">❾</span></p>&#13;
<p class="exercise-parai">This code defines a new class called <span class="literal">BankAccount</span> <span class="ent">❶</span>. Its <span class="literal">__init__</span> function <span class="ent">❷</span> is automatically invoked when an instance of the class is created. This function sets instance variables <span class="literal">balance</span> <span class="ent">❸</span> and <span class="literal">name</span> <span class="ent">❹</span> to the values passed into the initializer function. The variables are unique to each object instance of the class that’s created. The class definition also includes two methods: <span class="literal">withdraw</span> <span class="ent">❺</span> and <span class="literal">deposit</span> <span class="ent">❻</span>, which simply modify the balance. After the class is defined, the code proceeds to create an instance of the class <span class="ent">❼</span>. This bank account object can now be used by accessing its variables and methods. Here a deposit is made <span class="ent">❽</span>, followed by a retrieval of the new balance, which is printed <span class="ent">❾</span>.</p>&#13;
<p class="exercise-parai">Once the file is saved, you can run it using the Python interpreter like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python3 bank.py</span></p>&#13;
<p class="exercise-parai">You should see the account balance of 15.25 print to the terminal window. In truth, this was an overly complicated way of calculating this bank balance! The numbers are all hard coded in the program, and we really didn’t need to use an object-oriented approach to solve this problem. However, I hope this example helps you understand how classes and objects work.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_191"/>&#13;
<p class="exercise" id="proj19"><strong><span class="black1">PROJECT #19: FACTORIAL IN C</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: Projects #12 and #13</p>&#13;
<p class="exercise-parai">In this project, you’ll build a factorial program in the C programming language, like the one we covered earlier in this chapter. You’ll then examine the machine code that was generated when the code was compiled. Use the text editor of your choice to create a new file named <em>fac2.c</em> in the root of your home folder. Enter the following C code:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
 <br/>&#13;
// Calculate the factorial of n.<br/>&#13;
int factorial(int n)<span class="ent">❶</span><br/>&#13;
{<br/>&#13;
  int result = n;<br/>&#13;
 <br/>&#13;
  while(--n &gt; 0)<br/>&#13;
  {<br/>&#13;
    result = result * n;<br/>&#13;
  }<br/>&#13;
 <br/>&#13;
  return result;<br/>&#13;
}<br/>&#13;
 <br/>&#13;
int main()<span class="ent">❷</span><br/>&#13;
{<br/>&#13;
  int answer = factorial(4);<span class="ent">❸</span><br/>&#13;
  printf("%d\n", answer);<span class="ent">❹</span><br/>&#13;
}</p>&#13;
<p class="exercise-parai">You can see that the <span class="literal">factorial</span> function <span class="ent">❶</span> is exactly the same as the C example given earlier in the chapter; this is the core code for calculating the factorial. However, to make this a usable program, we also have a <span class="literal">main</span> function <span class="ent">❷</span> that serves as the entry point—this is where the program begins execution. From <span class="literal">main</span>, the program calls the <span class="literal">factorial</span> function with a value of 4, storing the result in a local variable named <span class="literal">answer</span> <span class="ent">❸</span>. The program then prints the value of <span class="literal">answer</span> to the terminal <span class="ent">❹</span>.</p>&#13;
<p class="exercise-parai">Once the file is saved, use <span class="literal">gcc</span> to compile your code into an executable file. The following command takes <em>fac2.c</em> as an input and outputs an executable file named <em>fac2</em>. No separate linking step is required. Also note the <span class="literal">-O</span> (that is a capital letter O) command line option: this means enable compiler optimizations. I added this option here because in this case it produces code that’s more similar to the assembly code from <a href="ch08.xhtml#proj12">Project #12</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -O -o fac2 fac2.c</span></p>&#13;
<p class="exercise-parai">Now try running the code using the following command. If everything works as expected, the program should print the calculated result of 24 on the next line.</p>&#13;
<p class="programs">$ <span class="codestrong1">./fac2</span></p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_192"/>Now that you have a <span class="literal">fac2</span> executable file, use the same techniques you used in Projects #12 and #13 to inspect the compiled file. I won’t walk you through all the details again, but the same approaches you used before will work here as well. Here are a few commands to get you started:</p>&#13;
<p class="programs">$ <span class="codestrong1">hexdump -C fac2</span><br/>&#13;
$ <span class="codestrong1">objdump -s fac2</span><br/>&#13;
$ <span class="codestrong1">objdump -d fac2</span><br/>&#13;
$ <span class="codestrong1">gdb fac2</span></p>&#13;
<p class="exercise-parai">You should see right away that there’s a lot of stuff in the <span class="literal">fac2</span> file! The compiled ELF binary carries some overhead required for a program written in C. On my computer, the original <span class="literal">fac</span> ELF file was 940 bytes, whereas the <span class="literal">fac2</span> ELF file is 8,364 bytes, a 9X increase! Of course, the C version does include additional functionality to print out the value, so some size increase is expected.</p>&#13;
<p class="exercise-parai">When looking at disassembled code, it’s the <span class="literal">factorial</span> function you want to initially examine. Compare it to the factorial code that you wrote in assembly language back in <a href="ch08.xhtml">Chapter 8</a>. You may notice <span class="literal">gdb</span> shows a different entry point than <span class="literal">main</span>. This is because C programs have some initialization code that’s called before your <span class="literal">main</span> entry point is called. If you want to skip this code and go right to the <span class="literal">factorial</span> function, you can set a breakpoint (<span class="codestrong">break factorial</span>) then <span class="codestrong">run</span>, and then <span class="codestrong">disassemble</span>.</p>&#13;
<p class="exercise-parai">The machine instructions generated on your machine may differ somewhat, but here’s the <span class="literal">factorial</span> function machine code and corresponding assembly language generated on my computer. This is output from <span class="codestrong">objdump -d fac2</span>:</p>&#13;
<p class="programs">00010408 &lt;factorial&gt;:<br/>&#13;
    10408:       e2403001        sub     r3, r0, #1<span class="ent">❶</span><br/>&#13;
    1040c:       e3530000        cmp     r3, #0<span class="ent">❷</span><br/>&#13;
    10410:       d12fff1e        bxle    lr<span class="ent">❸</span><br/>&#13;
    10414:       e0000093        mul     r0, r3, r0<span class="ent">❹</span><br/>&#13;
    10418:       e2533001        subs    r3, r3, #1<span class="ent">❺</span><br/>&#13;
    1041c:       1afffffc        bne     10414 &lt;factorial+0xc&gt;<span class="ent">❻</span><br/>&#13;
    10420:       e12fff1e        bx      lr<span class="ent">❼</span></p>&#13;
<p class="exercise-parai">Before this function is called, the value of <span class="literal">n</span> has been stored in <span class="literal">r0</span>. When the function begins, right away it decrements <span class="literal">n</span> and stores the result in <span class="literal">r3</span> <span class="ent">❶</span>. The program then compares <span class="literal">r3</span> (that is, <span class="literal">n</span>) to zero <span class="ent">❷</span>. If <span class="literal">n</span> is less than or equal to zero <span class="ent">❸</span>, then the program returns from the function. Otherwise, <span class="literal">result</span>, stored in <span class="literal">r0</span>, is calculated as <span class="literal">result</span> × <span class="literal">n</span> <span class="ent">❹</span>. Next <span class="literal">n</span> is decremented <span class="ent">❺</span>, and if <span class="literal">n</span> is not zero <span class="ent">❻</span>, the program goes through the loop again, branching back to address <span class="literal">10414</span> <span class="ent">❹</span>. Once <span class="literal">n</span> reaches zero, the loop ends and the function returns <span class="ent">❼</span>.</p>&#13;
</div>&#13;
</body></html>