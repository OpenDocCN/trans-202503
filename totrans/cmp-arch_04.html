<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_73"/><strong>3</strong></h2>&#13;
<h2 class="cht"><strong>BASIC CPU-BASED ARCHITECTURE</strong></h2>&#13;
<div class="image1"><img src="../images/f0073-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">Modern CPUs are some of the most complex structures known to humanity, but the basic concepts underlying them, such as executing instructions sequentially or jumping forward or backward to different instructions, are actually quite simple and haven’t changed for over 150 years. To ease our way into the study of CPU architecture, this chapter introduces these fundamental concepts by looking at a related but simpler system: a mechanical music player. You’ll then see how the same concepts, together with RAM, form the basis of Charles Babbage’s Analytical Engine. Studying—and programming—this mechanical system will make it easier to understand what’s going on when we turn our attention to electronic systems in <a href="ch04.xhtml">Chapter 4</a>.</p>&#13;
<h3 class="h3" id="lev77"><span epub:type="pagebreak" id="page_74"/>A Musical Processing Unit</h3>&#13;
<p class="noindent">For a machine to be a computer, it needs to be <em>general purpose</em>, meaning it must be able to perform different tasks according to a user specification. One way to arrange for this is to have the user write a sequence of instructions—a program—and have the machine carry them out. A musical score can be viewed as a program, and so we can think of a machine that reads and performs musical scores as a kind of musical computer. We’ll call such a device a <em>musical processing unit</em>.</p>&#13;
<p class="indent">In <a href="ch01.xhtml">Chapter 1</a> we looked briefly at musical processing units such as barrel organs and music boxes. After Babbage, musical automata and their programs continued to evolve. Around 1890, “book organs” replaced barrels with continuous, joined decks of punch cards (“book music”), which could accommodate arbitrarily longer compositions without the size limit imposed by a barrel. By 1900 these had evolved to pianolas, or player pianos (<a href="ch03.xhtml#ch03fig1">Figure 3-1</a>), which used punched paper <em>piano rolls</em> instead of cards to drive domestic pianos, rather than church organs. Player pianos are still found today; you might hear one providing background jazz in a mid-range hotel that can afford a piano but not a pianist.</p>&#13;
<div class="image"><img id="ch03fig1" src="../images/f0074-01.jpg" alt="Image" width="565" height="473"/></div>&#13;
<p class="figcap"><em>Figure 3-1: A player piano (1900)</em></p>&#13;
<p class="indent">Let’s think about some of the types of instructions found in musical scores that might be playable on these machines. These will be similar to but perhaps more familiar than concepts that we’ll need later to make computers. We’ll consider only a monophonic instrument here, meaning it can only play one note at a time.</p>&#13;
<p class="indent">The set of possible instructions that we can give to an automated musical instrument usually contains one instruction per available note. This might be an instruction to “play middle C” or “play the G above middle C,” for example. Each row of a player piano’s paper roll represents a time and contains one column per musical pitch, which is specified to be either on (punched) or off (not punched) at that time. Modern computer music software such as Ardour 5, released in 2018, continues to use this type of <span epub:type="pagebreak" id="page_75"/>piano roll notation (turned on its side for human viewers, so time scrolls more intuitively from left to right) to generate electronic music (<a href="ch03.xhtml#ch03fig2">Figure 3-2</a>).</p>&#13;
<div class="image"><img id="ch03fig2" src="../images/f0075-01.jpg" alt="Image" width="982" height="316"/></div>&#13;
<p class="figcap"><em>Figure 3-2: An Ardour 5 piano roll interface (2018)</em></p>&#13;
<p class="indent">When a player piano reads a piano roll, one row at a time is placed into a reader device. Let’s call this <em>fetching</em> the instruction. The instruction is then <em>decoded</em> by some machinery that looks at the punch-hole coding and turns it into a physical activation of some machinery that is going to play the note, such as by opening a tube for air to flow into an organ pipe. Then this machinery actually <em>executes</em> the performance of the note.</p>&#13;
<p class="indent">Usually when a human or mechanical music player is following a music program (score), they will execute (play) each instruction (note) and then move on to the next one, advancing their position in the program by one instruction. But sometimes there will also be special additional instructions that tell them to <em>jump</em> to another place in the program rather than advancing to the next instruction. For example, <em>repeats</em> and <em>dal segno (D.S.)</em> are used to jump back to an earlier instruction and continue execution from there, while <em>codas</em> are instructions to jump forward to a special ending section. <a href="ch03.xhtml#ch03fig3">Figure 3-3</a> shows a musical program.</p>&#13;
<div class="image"><img id="ch03fig3" src="../images/f0075-02.jpg" alt="Image" width="864" height="65"/></div>&#13;
<p class="figcap"><em>Figure 3-3: A musical program with notes G, A, B, high C, and low C, as well as jumps shown by repeats, dal segno, and coda</em></p>&#13;
<p class="indent">You can build a barrel organ or player piano that encodes these jump instructions using extra, non-note columns in their punch cards. When one of these is punched, it might be interpreted as an instruction to fast-forward or rewind the barrel or punch cards to a previous or later line. <a href="ch03.xhtml#ch03fig3">Figure 3-3</a> could then be coded with punches representing something like:</p>&#13;
<pre>1.  play note: G&#13;
2.  play note: A&#13;
3.  check if you have been here before&#13;
4.  if so, jump to instruction 10&#13;
5.  play note: B&#13;
6.  check if you haven't been here before&#13;
7.  if so, jump to instruction 5&#13;
8.  play note: high C&#13;
9.  jump to instruction: 2&#13;
10. play note: low C&#13;
11. halt</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>If you don’t read music, this program explains exactly what the musical score does!</p>&#13;
<h4 class="h4" id="lev78"><em>From Music to Calculation</em></h4>&#13;
<p class="noindent">It’s a small conceptual step from this musical processing unit to building a machine that performs arithmetical, rather than musical, operations.</p>&#13;
<p class="indent">Suppose you’ve already built several small mechanical devices that each perform some arithmetic operation. For example, Pascal’s calculator is a machine that performs integer addition. With some thought, we could similarly construct machines like Pascal’s calculator to perform integer multiplication, subtraction, division, and column shifting. We could then write a program, much like a musical score, that would specify the sequence in which we’d like each of these simple machines to be activated.</p>&#13;
<p class="indent">Assuming that your arithmetic machines all share a single accumulator where the result of each operation is stored, you could describe calculations similarly to sequences of instructions for pressing buttons on a calculator, such as:</p>&#13;
<pre>1. enter 24 into the accumulator&#13;
2. add 8&#13;
3. multiply by 3&#13;
4. subtract 2&#13;
5. halt</pre>&#13;
<p class="indent">This program would halt with the result 94 in the accumulator. The program could be executed by a human, activating the simple machines in sequence, or we could use a player piano–style roll of punch cards to specify the sequence of instructions, and a Jacquard loom–style mechanical reader to read them and automatically activate the corresponding simple machines in turn.</p>&#13;
<h4 class="h4" id="lev79"><em>From Calculation to Computation</em></h4>&#13;
<p class="noindent">To make a Church computer, it’s not enough to run programs of fixed sequences of arithmetic instructions. Computation theory tells us that some functions can only be computed using decisions and jumps, so we need to add similar instructions to those of our musical processing unit, facilitating repeats, codas, and the like. This would enable programs such as:</p>&#13;
<pre>1. enter 24 into the accumulator&#13;
2. add 8&#13;
3. multiply by 3&#13;
4. subtract 2&#13;
5. check if the result is less than 100&#13;
6. if so, jump to instruction 2&#13;
7. halt</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_77"/>Computation theory also tells us that some computations require memory to store intermediate results. To distinguish between these results, we’ll give each value an <em>address</em>, which for now is just an integer identifier. Memory that is addressable in this way is widely called <em>random-access memory (RAM)</em>. (This is not quite the correct definition of RAM, but you’ll get to that in <a href="ch10.xhtml">Chapter 10</a>.)</p>&#13;
<p class="indent">Having RAM available means that we can add instructions to <em>load</em> (read) and <em>store</em> (write) to addresses, as in this program:</p>&#13;
<pre>1. store the number 24 into address 1&#13;
2. store the number 3 into address 2&#13;
3. load the number from address 1 into the accumulator&#13;
4. add 8&#13;
3. multiply by the number in address 2&#13;
4. subtract 2&#13;
5. check if the result is less than 100&#13;
6. if so, jump to instruction 4&#13;
7. halt</pre>&#13;
<p class="indent">Computation theory tells us that we can simulate any machine if we have the three kinds of instructions I just demonstrated: those that do the actual work of the arithmetic operations; those that make decisions and jumps; and those that store and load from RAM. This is exactly how Babbage’s Analytical Engine was designed.</p>&#13;
<h3 class="h3" id="lev80">Babbage’s Central Processing Unit</h3>&#13;
<p class="noindent">Despite its age, Babbage’s Analytical Engine is a striking modern design: its basic architecture is still used in all modern CPUs. At the same time, it has only the most essential CPU features, so studying it provides a simplified introduction to the basic concepts underlying more modern CPUs. The motion of the Analytical Engine’s mechanical parts also makes it easier to visualize how it works compared to today’s electronic computers.</p>&#13;
<p class="indent">In this section I use modern terminology to describe the Analytical Engine’s parts and functions. These aren’t the terms Babbage used, but they’ll help later when I transfer the concepts to modern machines. (Some of Babbage’s original terms are included in parentheses in case they’re of interest.) Babbage and Lovelace never left documentation for their instruction set, but it’s been largely inferred or fantasized from other documents. I assume the instruction set and assembly language notation used by the Fourmilab emulator, an online re-creation of the Analytical Engine (<em><a href="https://www.fourmilab.ch/babbage/">https://www.fourmilab.ch/babbage/</a></em>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>Both my presentation and the Fourmilab emulator take some liberties with the historical truth. This is easy to do because the original source documents are messy and often contradictory. There was never a single definitive design, so we can pick the versions that best suit our story. Our purpose here is really to understand <em>modern</em> CPU concepts, so I sometimes simplify, modernize, or outright lie about some of the engine’s details to make this study easier.</p>&#13;
<h4 class="h4" id="lev81"><em>High-Level Architecture</em></h4>&#13;
<p class="noindent">The Analytical Engine consists of three things: a CPU, which executes programs; RAM, which stores data and allows the CPU to read and write it; and a bus that connects them. If that sounds similar to the overall architecture of a modern, single-core computer, that’s because it is! This isn’t a coincidence: the Analytical Engine’s architecture was explicitly used in ENIAC (after translating its mechanics into electronics), and ENIAC then became the template for our modern electronic machines.</p>&#13;
<p class="indent">Physically, the Analytical Engine is made of 50 copies of the slice (what Babbage called a “cage”) shown in <a href="ch03.xhtml#ch03fig4">Figure 3-4</a>, stacked vertically, one on top of the other, as in <a href="ch01.xhtml#ch01fig14">Figure 1-14</a>.</p>&#13;
<div class="image"><img id="ch03fig4" src="../images/f0078-01.jpg" alt="Image" width="1025" height="569"/></div>&#13;
<p class="figcap"><em>Figure 3-4: Babbage’s Analytical Engine architecture (1836)</em></p>&#13;
<p class="indent">The circles are mechanical gears. The CPU, RAM, and bus each extend through all slices, and we can see each of them in <a href="ch03.xhtml#ch03fig4">Figure 3-4</a>. For each number represented in each structure of the machine, the slice shows and handles one of its many digits. The stack of all the slices together handles all digits.</p>&#13;
<p class="indent">The RAM (“store axes”) consists of 100 stacks of gears, with each stack representing one 50-digit decimal integer number. It appears on the slice as <span epub:type="pagebreak" id="page_79"/>the large homogeneous area on the right side of <a href="ch03.xhtml#ch03fig4">Figure 3-4</a>. Each of these locations in the RAM has an address, numbered from 0 to 99 inclusive; this address distinguishes the location from the other locations and is used to identify it.</p>&#13;
<p class="indent">The RAM locations are all physically close to, but not usually touching, a mechanical bus (“rack”). The bus is a rack gear—exactly like the one found in modern car steering racks and LEGO Technic sets (<a href="ch03.xhtml#ch03fig5">Figure 3-5</a>).</p>&#13;
<div class="image"><img id="ch03fig5" src="../images/f0079-01.jpg" alt="Image" width="394" height="296"/></div>&#13;
<p class="figcap"><em>Figure 3-5: A rack (linear gear) and pinion (rotating gear)</em></p>&#13;
<p class="indent">The rack gear can <em>physically</em> shift left and right. Each of the RAM locations can be brought into contact with the rack by levers. The gears in that RAM location then act as pinions so that giving off the number from the location makes the bus physically shift to the left by that amount. Or, acting in the opposite direction, shifting the bus to the right from elsewhere adds numbers into the memory location.</p>&#13;
<p class="indent">The CPU (“mill”) is the active part of the machine. It requests data from and sends data to the RAM on the bus, and then processes it in various ways.</p>&#13;
<h4 class="h4" id="lev82"><em>Programmer Interface</em></h4>&#13;
<p class="noindent">Unlike the Difference Engine, the Analytical Engine was designed as a general-purpose computer. This means we can ask it to perform different operations in different orders. To do this, we need a way to specify what these operations and orders are.</p>&#13;
<p class="indent">Let’s clarify some terms I’ve been using loosely. An ordered list of <em>instructions</em> to perform operations is called a <em>program</em>. The act of carrying out a program is called <em>execution</em> or a <em>run</em>. The set of all available instructions is the <em>instruction set</em>.</p>&#13;
<p class="indent">Programs are stored as codes on punched cards, like those of the Jacquard loom seen previously in <a href="ch01.xhtml#ch01fig11">Figure 1-11</a>. Each card contains one row of holes and non-holes, which together code for one instruction. Usually the instructions are executed in order, with the cards advancing in sequence, but some instructions make the cards rewind or fast-forward to jump around in the program. Let’s look at what particular instructions are available.</p>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_80"/><strong>Constants</strong></h4>&#13;
<p class="noindent">One basic instruction is to set one of the RAM addresses to a given integer. For example, “Put the integer 534 into RAM address 27.” This will move the gears in the 27th RAM location’s column to the (decimal) digits 534, with zeros on the gears for the thousands place and higher. Let’s first denote this using a human-readable notation:</p>&#13;
<pre>N27 534</pre>&#13;
<p class="indent">Here, <code>N</code> (for <em>number</em>) tells us that this is a RAM integer-setting instruction. The following number (<code>27</code>) tells us which RAM location is to be set, and the final number (<code>534</code>) is the value we’re setting it to. A typical program begins by setting many RAM addresses to specific values in this manner. For example:</p>&#13;
<pre>N27 534&#13;
N15 123&#13;
N99 58993254235&#13;
N0  10&#13;
N2  5387</pre>&#13;
<p class="indent">Once we have some starting values, we can then use further instructions to compute with them, as in the next sections.</p>&#13;
<h4 class="h4a"><strong>Load and Store</strong></h4>&#13;
<p class="noindent">To process values from RAM, they must be moved into the CPU. To load a value from RAM into the CPU, we write <code>L</code> for <em>load</em>, followed by the RAM address where the value is stored. For example, this program sets the 27th RAM location to the value 534, then loads the value from this location into the CPU:</p>&#13;
<pre>N27 534&#13;
L27</pre>&#13;
<p class="indent">To store the CPU’s latest result to RAM address 35, we write <code>S</code> for <em>store</em> followed by the desired address:</p>&#13;
<pre>S35</pre>&#13;
<p class="indent">Storing (<code>S</code>) is different from setting RAM to a constant (<code>N</code>) because it involves the CPU’s accumulator. It transfers whatever value is in the accumulator to the RAM, rather than putting a fixed constant into RAM.</p>&#13;
<p class="indent">Now that we can move data around, we would like to perform calculations in the form of arithmetic on it.</p>&#13;
<h4 class="h4a"><strong>Arithmetic</strong></h4>&#13;
<p class="noindent">The Analytical Engine is able to perform elementary arithmetical operations: addition, subtraction, multiplication, and division, all on integers. These are denoted by the instructions <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>To do arithmetic, you first have to set the <em>mode</em>, which tells the engine which of these operations you want to do. For example, to add two numbers, you put it into adding mode and then load the two arguments in order into the CPU. Consider the following program:</p>&#13;
<pre>N0 7&#13;
N1 3&#13;
+&#13;
L0&#13;
L1&#13;
S2</pre>&#13;
<p class="indent">This program first puts the integers <code>7</code> and <code>3</code> into addresses 0 and 1, respectively. It then puts the CPU into adding mode with the <code>+</code> instruction and loads the number from these addresses. It finally stores the result of the addition into address 2.</p>&#13;
<p class="indent">Now that we have arithmetic, we finally need to move from calculation to computation by adding jumps and branches.</p>&#13;
<h4 class="h4a"><strong>Jumps</strong></h4>&#13;
<p class="noindent">If you want part of a program to repeat forever, a simple method is to glue the end of the last punch card to the top of the first one to create a physical loop, as in <a href="ch01.xhtml#ch01fig15">Figure 1-15</a>. However, this doesn’t generalize well, so it’s useful instead to have an instruction to rewind or fast-forward the cards to jump to any other line of the program when needed. Call this <code>C</code> for <em>control</em>. We’ll then say whether we want to go backward (<code>B</code>) or forward (<code>F</code>) in the cards, and by how many. We’ll also include the symbol <code>+</code> before the number (for reasons you’ll see in the next section). Putting it all together, <code>CB+4</code>, for example, is a control instruction to go backward by four cards.</p>&#13;
<p class="indent">The following program uses <code>CB+4</code> to loop forever:</p>&#13;
<pre>N46 0&#13;
N37 1&#13;
+&#13;
L46&#13;
L37&#13;
S46&#13;
CB+4</pre>&#13;
<p class="indent">Here we use address 46 as a counter, adding 1 to its value every time we go around the loop.</p>&#13;
<h4 class="h4a"><strong>Branches</strong></h4>&#13;
<p class="noindent">Looping forever often isn’t very useful; we usually want to loop <em>until</em> something has happened, then stop looping and move on to the next part of the program. This is done with a conditional <em>branch</em>, which asks whether a condition holds and jumps only if it does.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>We’ll use the same <code>CF</code> and <code>CB</code> notation we used for jumps, but with the symbol<code>?</code> replacing the <code>+</code> to denote that the jump is conditional. For example, <code>CB?4</code> is the control instruction to go backward by four cards only if some condition is true.</p>&#13;
<p class="indent">The following program uses a conditional branch and an unconditional jump together to compute the absolute value (always positive) of the sum of two numbers.</p>&#13;
<pre>N1 -2&#13;
N2 -3&#13;
N99 0&#13;
+&#13;
L1&#13;
L2&#13;
S3&#13;
+&#13;
L99&#13;
L3&#13;
CF?1&#13;
CF+4&#13;
-&#13;
L99&#13;
L3&#13;
S3</pre>&#13;
<p class="indent">This program uses the <code>+</code> instruction to add the two numbers in RAM locations 1 and 2, storing the result at location 3. It then adds zero (loaded from address 99) to that result, loaded back from location 3. Behind the scenes this addition operation also sets a special <em>status flag</em> to a 1 if the sign of the result differs from the sign of the first input (zero is considered positive). The conditional instruction <code>(CF?1)</code> then uses this status flag to decide what to do. If the flag is a 1, we skip over the next instruction, and so we arrive at the <code>-</code> instruction and perform a subtraction of the result from 0 to swap its sign. If the status flag is a 0, the conditional jump doesn’t occur, so we simply move on to the next instruction <code>(CF+4)</code>. This is an unconditional jump that skips over the four lines of subtraction code so as not to swap the sign. The final result is stored in address 3.</p>&#13;
<p class="indent">Branching completes the instruction set of the Analytical Engine and (assuming enough memory is always available) makes it into a Church computer. You can try tackling the end-of-chapter exercises and programming the Analytical Engine now—or, if you’re interested to see how the machine works on the inside, read on.</p>&#13;
<h4 class="h4" id="lev83"><em>Internal Subcomponents</em></h4>&#13;
<p class="noindent">Let’s look at the subcomponents <em>within</em> the CPU that are needed to execute these programs. This section describes their static structure; we’ll bring the <span epub:type="pagebreak" id="page_83"/>subcomponents to life in the next section when we cover how they move and interact with one another.</p>&#13;
<p class="indent">A CPU is formed from many independent simple machines, each made from several number representations and the machinery that acts upon them. The simple machines are grouped into three types: registers, an arithmetic logic unit, and a control unit.</p>&#13;
<p class="indent">As shown in <a href="ch03.xhtml#ch03fig4">Figure 3-4</a>, all of these simple machines are arranged in a circle around a single large gear called the central wheel. Like the bus, the central wheel makes and breaks arbitrary data connections between components, in this case between the simple machines inside the CPU. These connections are made and removed by levers that put small additional gears into contact between the central wheel and the various machines.</p>&#13;
<h4 class="h4a"><strong>Registers</strong></h4>&#13;
<p class="noindent"><em>Registers</em> (what Babbage called “axes”) are small units of memory location inside the CPU itself, rather than in the main RAM. There are only a few registers in the CPU, while there are many RAM addresses.</p>&#13;
<p class="indent">Recall from <a href="ch02.xhtml">Chapter 2</a> that integers are represented in the Analytical Engine by digital, decimal gears. A digit <em>d</em> is read off a gear by rotating a shaft by a full circle, which results in the gear rotating by <em>d</em> tenths of a circle. To represent an <em>N</em>-digit integer, we simply stack <em>N</em> of these gears vertically, spanning the <em>N</em> cages of the machine. A register is one of these stacks.</p>&#13;
<p class="indent">The input register (“ingress axle”) receives incoming data from RAM. The output register (“egress axle”) temporarily stores (or <em>buffers</em>) results from the CPU’s work, which are then transferred out to RAM. Other registers are used during computations for other purposes.</p>&#13;
<h4 class="h4a"><strong>Arithmetic Logic Unit</strong></h4>&#13;
<p class="noindent">The <em>arithmetic logic unit (ALU)</em> is a collection of independent simple machines that each perform a single arithmetic operation. For example, a simple machine similar to Pascal’s calculator is used to do addition. Multiplying by <em>m</em> can be done by a machine that triggers <em>m</em> repetitions of this adder. Multiplying or dividing by the <em>n</em>th power of 10 can be done by an especially simple machine that shifts all of its digits by <em>n</em> columns, the mechanical equivalent of “putting a zero on the end.”</p>&#13;
<p class="indent">In addition to sending the result to an output register, some ALU operations can also set a single <em>status flag</em> as an extra, side-effect output. The status flag in the Analytical Engine is a single mechanical lever that is in either the up (1) or down (0) position. It might have had an actual red fabric flag on it to visually alert human as well as mechanical observers that “something interesting just happened” in the ALU.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_84"/><strong>ALU MECHANISMS</strong></p>&#13;
<p class="stext">A digit <em>d</em> is given off from a gear <em>D</em> when it’s read by physically rotating the gear by <em>d</em> tenths of a full circle. This digit can be added to another digit <em>a</em> stored on gear <em>A</em> by placing the gears next to one another so that their teeth mesh together, then giving off from <em>D</em>. As gear <em>D</em> rotates <em>d</em> tenths of a circle, gear <em>A</em> will be caused to rotate by the same amount, so gear <em>A</em> will end up storing the digit <em>a</em> + <em>d</em>. We say that <em>A</em> acts as an <em>accumulator</em> because we can go on adding many digits into it, and it accumulates their sum—that is, until the total goes above 9.</p>&#13;
<p class="stext">Integers larger than 9 are represented on stacks of gears, such as in registers. Adding them together is done similarly to adding in columns with pen and paper: the two digits in each column need to be added, but we also need to keep track of carrying when a digit goes above 9 by passing a 1 to the next column. Pascal had already developed a basic mechanical ripple carry system in his calculator, which allowed numbers to be added into an accumulator, and Babbage’s carries are based on this. The following figure shows part of Babbage’s design.</p>&#13;
<div class="imagec"><img src="../images/f0084-01.jpg" alt="Image" width="394" height="431"/></div>&#13;
<p class="stext">When a gear reaches the number 9 and is rotated by one more position in an addition, such as by an incoming carry (c), a tappet (f) connects to another tappet (e). The latter connects to a rod (m) that transfers the carry “upstairs” to the next cage, where it appears as (c) for the next column. Getting the timing right for long ripples of carries is very difficult, and this is where Babbage spent most of his design time.</p>&#13;
</div>&#13;
<h4 class="h4a"><strong>Control Unit</strong></h4>&#13;
<p class="noindent">The <em>control unit (CU)</em> reads instructions from the program in memory, decodes them, and passes control to the ALU or elsewhere to carry the instructions out. Then it updates the position in the program according to either normal sequential execution or a jump. The CU is like the conductor of an orchestra, coordinating the actions of all the other components at the right times. Babbage’s CU is shown in <a href="ch03.xhtml#ch03fig6">Figure 3-6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><img id="ch03fig6" src="../images/f0085-01.jpg" alt="Image" width="552" height="475"/></div>&#13;
<p class="figcap"><em>Figure 3-6: The Analytical Engine control unit</em></p>&#13;
<p class="indent">A mechanical barrel, just like that of a barrel organ, rotates over time, and each column of the barrel has several sockets for pins that may or may not be present. The pins trigger tappets that activate the other simple machines in the CPU through a complex system of mechanical levers. This enables each phase of the control unit’s work to be triggered in sequence, much like a barrel organ playing a sequence of notes. The speed of rotation of the barrel can be controlled by feedback mechanisms, so the next step doesn’t commence until the current step has been completed.</p>&#13;
<p class="indent">The configuration of the barrel’s pins is <em>not</em> the user’s program, but rather a lower-level <em>microprogram</em> that defines the sequencing of the CPU itself: the fetch-decode-execute cycle that we’ll discuss next. As the microprogram runs, it causes individual commands from the user’s higher-level program to be read into registers from punched cards, then causes those commands to be executed via the simple machines in the rest of the CPU.</p>&#13;
<h4 class="h4" id="lev84"><em>Internal Operation</em></h4>&#13;
<p class="noindent">The CU—in Babbage’s case the rotating barrel—triggers a regular cycle of activities. These are usually grouped into three main stages: fetch, decode, and execute. All of the CU’s operations must be carefully timed to occur in the right order. Let’s look at these three stages in turn.</p>&#13;
<h4 class="h4a"><strong>Fetch</strong></h4>&#13;
<p class="noindent"><em>Fetching</em> means reading the machine code for the next instruction into the CPU. Recall that the human-readable assembly language instructions such as <code>N37 1</code> and <code>CB+4</code> are actually represented as binary machine code on the punched cards. For the Analytical Engine, fetching could be done exactly as on the Jacquard loom, by attempting to insert a set of physical pins into the locations on the card. Where there’s a punched hole, the pin can pass through, but where there isn’t a hole the pin gets stuck on the card and <span epub:type="pagebreak" id="page_86"/>doesn’t move as far. The physical positions of these pins can then be amplified and transmitted into the CPU by metal levers.</p>&#13;
<p class="indent">The card reader is a physical device, rather like a typewriter, in which there’s a current line accessible to the pins. To read from any other line, it’s necessary to pull the string of punch cards through this reader until the desired line is positioned in it. The current physical state of the punch cards—which one is currently in the reader—thus acts as a form of memory. We’ll call this physical state the <em>program counter</em>.</p>&#13;
<p class="indent">The physical positions of the metal levers can also be considered as a form of memory that contains a copy of the current instruction inside the CPU. We’ll call this the <em>instruction memory</em>.</p>&#13;
<h4 class="h4a"><strong>Decode</strong></h4>&#13;
<p class="noindent">It isn’t immediately obvious what the binary encodings on the punch cards mean, either to a human or a machine: at this stage, they’re just patterns of 0s and 1s. <em>Decoding</em> means figuring out what this code means. The card-reading levers traveling into the CPU can activate different pieces of machinery there, depending on what <em>combinations</em> of levers are up or down. For example, if the load instruction <code>(L)</code> is represented as binary 010, a machine could be set to respond only if three fetch levers are down, up, and down, respectively. Similarly, numerical addresses included in instructions need to be decoded, from decimal codes to mechanical activations of the addresses they represent. The decoder is a bank of machines that each look for a specific pattern in the fetched signal and activate something when they see it.</p>&#13;
<h4 class="h4a"><strong>Execute: Load and Store</strong></h4>&#13;
<p class="noindent"><em>Execution</em> means carrying out the decoded instruction. How this is done will depend on what type of instruction it is. Each form of execution is implemented by a different simple machine, and the decoder will select and activate the appropriate one.</p>&#13;
<p class="indent">Values can be <em>loaded</em> into the CPU registers from RAM when the CPU needs to use them—for example, as part of a calculation. The results of the CPU’s work are also placed in registers, whose values can then be <em>stored</em> by copying them out to RAM addresses.</p>&#13;
<p class="indent">To load a value, the CU makes mechanical connections between the gears at the RAM address and the bus, and between the bus and input register at the CPU end. It then triggers a giving off at the RAM address, spinning the gears by a full circle so that they make the bus physically shift toward the CPU by <em>n</em> steps, where <em>n</em> is the digit represented. This occurs in parallel, with each column of the number having its own RAM gear, bus, and input register gear.</p>&#13;
<p class="indent">When a value is to be stored, the CU triggers the opposite set of steps. Storing assumes that the value to be stored is already in the output register. First, it clears the RAM at the target address by rotating all the digits to zero. Then it makes mechanical connections from the output register to the bus, and from the bus to the required address in RAM. Then it spins the output register by a full circle, which physically shifts the bus by <em>n</em> steps toward the <span epub:type="pagebreak" id="page_87"/>RAM, which in turn rotates the RAM gear by <em>n</em> steps so that the number is stored there.</p>&#13;
<h4 class="h4a"><strong>Execute: Arithmetic Instructions</strong></h4>&#13;
<p class="noindent">When an arithmetic instruction, such as an addition, is required, the appropriate simple machine, such as an adder, is brought into mechanical contact with the input and output registers and activated. In the Analytical Engine this is done mechanically by inserting gears (cogs) that physically link the registers to the simple machine, then transmitting power to the simple machine to make it run. Babbage’s adder was similar to a Pascal calculator, loading in the first argument, adding the second argument to, and then transferring the result to the output register. When the calculation is done, these gears are pulled away to disable the simple machine.</p>&#13;
<p class="indent">In addition to affecting the output register, the ALU’s simple machines may also raise or lower the status flag if something interesting happens during the arithmetic. The different simple machines in the ALU each have their own definition of “interesting” and can each set the flag according to these interests: <code>+</code> and <code>-</code> set the status flag to true if and only if the sign of their result differs from the sign of their first input, while <code>/</code> sets the status flag to true if a division by zero was attempted.</p>&#13;
<h4 class="h4a"><strong>Execute: Program Flow</strong></h4>&#13;
<p class="noindent">At the end of each instruction, the CU must complete the fetch-decode-execute cycle and prepare for the start of the next one. How this is done differs depending on whether we have a normal instruction (such as load and store or ALU instructions) or one whose purpose is to alter the program flow—that is, jumps and branches.</p>&#13;
<p class="indent">In <em>normal execution</em>, when an instruction completes, we want to advance to the next instruction in the program, which for Babbage is the one on the punch card whose top is attached by string to the bottom of the current instruction’s punch card. This will prepare the system for the next fetch, which will be on the new instruction. To do this, the CU needs to trigger and increment the program counter. For the Analytical Engine, this is done by making mechanical connections that supply power to the punch card reader to perform a line feed, pulling the card deck through the reader by one card.</p>&#13;
<p class="indent"><em>Jump instructions</em> mean fast-forwarding or rewinding the program as requested. Consider the instruction <code>CF+4</code>, which means forward by four lines. When the CU sees this instruction, it will again modify the program counter, but rather than simply incrementing it, it will advance or rewind it by the number of lines requested. In the Analytical Engine, this is done by sending power to the line feeder for a longer time than a single line advancement, and also by mechanically switching the direction of line feed between forward and backward.</p>&#13;
<p class="indent"><em>Branch instructions</em> such as <code>CB?4</code> are executed differently, depending on the state of the status flag. This instruction, for example, tells the CU to jump, decreasing the program counter by four, if and only if the status flag is up. Otherwise, the instruction has no effect, and normal execution is used <span epub:type="pagebreak" id="page_88"/>to increment the program counter and move to the next instruction. This branching is the important difference that separates the Analytical Engine from previous barrel and punch card program machines such as music players and the Jacquard loom. Unless historians discover any previous machines that could do it, this engine marked the first time that a machine was designed to modify the execution of its own program rather than always follow it in the same sequence. This ability to look at the state of things and make decisions based on it is a key requirement of a Church computer.</p>&#13;
<h3 class="h3" id="lev85">Summary</h3>&#13;
<p class="noindent">We’ve studied Babbage’s Analytical Engine in this chapter because it was and still is the blueprint for all computers that came after it, including modern PCs. Its high-level architecture includes a CPU, RAM, and a bus connecting them. Inside the CPU is an ALU, registers, and a CU that conducts a fetch-decode-execute cycle. The instruction set includes load and store, arithmetic, and jump and branch instructions. There’s a program counter storing the current program line number, and a status flag that gets set if something interesting happened in the latest arithmetic operation. All of these features are found essentially unchanged in a modern PC.</p>&#13;
<p class="indent">As a mechanical system, the Analytical Engine can be much more concrete to visualize and understand than electronics. But electronic computers are based on simply translating each of Babbage’s components into a faster and smaller implementation based on electronic switches grouped into logic gates. In the second part of this book, you’ll see how this is done by building up the modern electronic hierarchy from switches to CPUs. Now that you’ve seen what a CPU needs to do, you should have a clearer picture of where this electronic hierarchy is heading.</p>&#13;
<h3 class="h3" id="lev86">Exercises</h3>&#13;
<h4 class="h4a"><strong>Programming the Analytical Engine</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Install the Fourmilab Analytical Engine emulator from <em><a href="https://www.fourmilab.ch/babbage">https://www.fourmilab.ch/babbage</a></em>, or use its web interface.</li>&#13;
<li class="tm">Enter and run the Analytical Engine programs discussed in this chapter. If you run the programs using the <span class="codestrong">java aes -t test.card</span> command, then the <code>-t</code> option will print out a trace of changes to the machine state at each step.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Lovelace’s Factorial Function</strong></h4>&#13;
<p class="noindent">Write a factorial function for the Analytical Engine. Ada Lovelace wrote one of these, and it has since become the standard “Hello, world!” exercise to try whenever you meet a new architecture. (Actually printing “Hello, world!” tends to be more complicated, as it requires ASCII and screen output—you’ll see how to do this in <a href="ch11.xhtml">Chapter 11</a>.)</p>&#13;
<h3 class="h3" id="lev87"><span epub:type="pagebreak" id="page_89"/>Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">For a more historically accurate description of the Analytical Engine, see A. Bromley, “Charles Babbage’s Analytical Engine, 1838,” <em>Annals of the History of Computing</em> 4, no. 3 (1982): 196–217.</li>&#13;
<li class="tm">For a more fictional version, see William Gibson and Bruce Sterling, <em>The Difference Engine</em> (London: Victor Gollancz, 1990). This is the original steampunk novel, featuring Babbage, Lovelace, and a working Analytical Engine.<span epub:type="pagebreak" id="page_90"/></li>&#13;
</ul>&#13;
</div>
</div>
</body></html>