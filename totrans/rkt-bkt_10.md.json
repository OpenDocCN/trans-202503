["```\nseg000:7C00 ; Segment type: Pure code\n\nseg000:7C00 seg000          segment byte public 'CODE' use16\n\nseg000:7C00                 assume cs:seg000\n\nseg000:7C00                 ;org 7C00h\n\nseg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\n\nseg000:7C00                 xor     ax, ax\n\nseg000:7C02               ➊ mov     ss, ax\n\nseg000:7C04                 mov     sp, 7C00h\n\nseg000:7C07                 mov     es, ax\n\nseg000:7C09                 mov     ds, ax\n\nseg000:7C0B                 sti\n\nseg000:7C0C                 pusha\n\nseg000:7C0D                 mov     cx, 0CFh\n\nseg000:7C10                 mov     bp, 7C19h\n\nseg000:7C13\n\nseg000:7C13 loc_7C13:                               ; CODE XREF: seg000:7C17\n\nseg000:7C13               ➋ ror     byte ptr [bp+0], cl\n\nseg000:7C16                 inc     bp\n\nseg000:7C17                 loop    loc_7C13\n\nseg000:7C17 ; ---------------------------------------------------------------------------\n\nseg000:7C19 encrypted_code  db 44h, 85h, 1Dh, 0C7h, 1Ch, 0B8h, 26h, 4, 8, 68h, 62h\n\nseg000:7C19               ➌ db 40h, 0Eh, 83h, 0Ch, 0A3h, 0B1h, 1Fh, 96h, 84h, 0F5h\n```", "```\n➊ import idaapi\n\n   # beginning of the encrypted code and its size in memory\n\n   start_ea = 0x7C19\n\n   encr_size = 0xCF\n\n➋ for ix in xrange(encr_size):\n\n  ➌ byte_to_decr = idaapi.get_byte(start_ea + ix)\n\n     to_rotate = (0xCF - ix) % 8\n\n     byte_decr = (byte_to_decr >> to_rotate) | (byte_to_decr << (8 - to_rotate))\n\n  ➍ idaapi.patch_byte(start_ea + ix, byte_decr)\n```", "```\nseg000:7C19               ➊ mov     ds:drive_no, dl\n\nseg000:7C1D               ➋ sub     word ptr ds:413h, 10h\n\nseg000:7C22                 mov     ax, ds:413h\n\nseg000:7C25                 shl     ax, 6\n\nseg000:7C28               ➌ mov     ds:buffer_segm, ax\n```", "```\nseg000:7C2B               ➊ mov     ah, 48h\n\nseg000:7C2D               ➋ mov     si, 7CF9h\n\nseg000:7C30                 mov     ds:drive_param.bResultSize, 1Eh\n\nseg000:7C36                 int     13h         ; DISK - IBM/MS Extension\n\n                                             ➌ ; GET DRIVE PARAMETERS\n\n                                                ; (DL - drive, DS:SI - buffer)\n```", "```\ntypedef struct _EXTENDED_GET_PARAMS {\n\n   WORD bResultSize;             // Size of the result\n\n   WORD InfoFlags;               // Information flags\n\n   DWORD CylNumber;              // Number of physical cylinders on drive\n\n   DWORD HeadNumber;             // Number of physical heads on drive\n\n   DWORD SectorsPerTrack;        // Number of sectors per track\n\n➊ QWORD TotalSectors;           // Total number of sectors on drive\n\n➋ WORD BytesPerSector;          // Bytes per sector\n\n} EXTENDED_GET_PARAMS, *PEXTENDED_GET_PARAMS;\n```", "```\nseg000:7C4C read_loop:                              ; CODE XREF: seg000:7C5Dj\n\nseg000:7C4C              ➊ call    read_sector\n\nseg000:7C4F                 mov     si, 7D1Dh\n\nseg000:7C52                 mov     cx, ds:word_7D1B\n\nseg000:7C56                 rep movsb\n\nseg000:7C58                 mov     ax, ds:word_7D19\n\nseg000:7C5B                 test    ax, ax\n\nseg000:7C5D                 jnz     short read_loop\n\nseg000:7C5F                 popa\n\nseg000:7C60              ➋ jmp     far boot_loader\n```", "```\nseg000:7C65 read_sector     proc near\n\nseg000:7C65                 pusha\n\nseg000:7C66               ➊ mov     ds:disk_address_packet.PacketSize, 10h\n\nseg000:7C6B               ➋ mov     byte ptr ds:disk_address_packet.SectorsToTransfer, 1\n\nseg000:7C70                 push    cs\n\nseg000:7C71                 pop     word ptr ds:disk_address_packet.TargetBuffer+2\n\nseg000:7C75               ➌ mov     word ptr ds:disk_address_packet.TargetBuffer, 7D17h\n\nseg000:7C7B                 push    large [dword ptr ds:drive_param.TotalSectors_l]\n\nseg000:7C80               ➍ pop     large [ds:disk_address_packet.StartLBA_l]\n\nseg000:7C85                 push    large [dword ptr ds:drive_param.TotalSectors_h]\n\nseg000:7C8A               ➎ pop     large [ds:disk_address_packet.StartLBA_h]\n\nseg000:7C8F                 inc     eax\n\nseg000:7C91                 sub     ds:disk_address_packet.StartLBA_l, eax\n\nseg000:7C96                 sbb     ds:disk_address_packet.StartLBA_h, 0\n\nseg000:7C9C                 mov     ah, 42h\n\nseg000:7C9E               ➏ mov     si, 7CE9h\n\nseg000:7CA1                 mov     dl, ds:drive_no\n\nseg000:7CA5               ➐ int     13h             ; DISK - IBM/MS Extension\n\n                                                    ; EXTENDED READ\n\n                                                    ; (DL - drive, DS:SI - disk address packet)\n\nseg000:7CA7                 popa\n\nseg000:7CA8                 retn\n\nseg000:7CA8 read_sector     endp\n```", "```\ntypedef struct _DISK_ADDRESS_PACKET {\n\n   BYTE PacketSize;                 // Size of the structure\n\n   BYTE Reserved;\n\n   WORD SectorsToTransfer;          // Number of sectors to read/write\n\n   DWORD TargetBuffer;              // segment:offset of the data buffer\n\n   QWORD StartLBA;                  // LBA address of the starting sector\n\n} DISK_ADDRESS_PACKET, *PDISK_ADDRESS_PACKET;\n```", "```\nseg000:000B bpb     dw 200h      ; SectorSize\n\nseg000:000D         db 8         ; SectorsPerCluster\n\nseg000:001E         db 3 dup(0)  ; reserved\n\nseg000:0011         dw 0         ; RootDirectoryIndex\n\nseg000:0013         dw 0         ; NumberOfSectorsFAT\n\nseg000:0015         db 0F8h      ; MediaId\n\nseg000:0016         db 2 dup(0)  ; Reserved2\n\nseg000:0018         dw 3Fh       ; SectorsPerTrack\n\nseg000:001A         dw 0FFh      ; NumberOfHeads\n\nseg000:001C         dd 800h      ; HiddenSectors➊\n```", "```\ndef accept_file(li, n):\n\n   # check size of the file\n\n   file_size = li.size()\n\n   if file_size < 512:\n\n    ➊ return 0\n\n   # check MBR signature\n\n   li.seek(510, os.SEEK_SET)\n\n   mbr_sign = li.read(2)\n\n   if mbr_sign[0] != '\\x55' or mbr_sign[1] != '\\xAA':\n\n    ➋ return 0\n\n   # all the checks are passed\n\n➌ return 'MBR'\n```", "```\ndef load_file(li):\n\n    # Select the PC processor module\n\n ➊ idaapi.set_processor_type(\"metapc\", SETPROC_ALL|SETPROC_FATAL)\n\n    # read MBR into buffer\n\n ➋ li.seek(0, os.SEEK_SET); buf = li.read(li.size())\n\n    mbr_start = 0x7C00       # beginning of the segment\n\n    mbr_size = len(buf)      # size of the segment\n\n    mbr_end  = mbr_start + mbr_size\n\n    # Create the segment\n\n ➌ seg = idaapi.segment_t()\n\n    seg.startEA = mbr_start\n\n    seg.endEA   = mbr_end\n\n    seg.bitness = 0 # 16-bit\n\n ➍ idaapi.add_segm_ex(seg, \"seg0\", \"CODE\", 0)\n\n    # Copy the bytes\n\n ➎ idaapi.mem2base(buf, mbr_start, mbr_end)\n\n    # add entry point\n\n    idaapi.add_entry(mbr_start, mbr_start, \"start\", 1)\n\n    # parse partition table\n\n ➏ struct_id = add_struct_def()\n\n    struct_size = idaapi.get_struc_size(struct_id)\n\n ➐ idaapi.doStruct(start + 0x1BE, struct_size, struct_id)\n```", "```\ndef add_struct_def(li, neflags, format):\n\n    # add structure PARTITION_TABLE_ENTRY to IDA types\n\n    sid_partition_entry = AddStrucEx(-1, \"PARTITION_TABLE_ENTRY\", 0)\n\n    # add fields to the structure\n\n    AddStrucMember(sid_partition_entry, \"status\", 0, FF_BYTE, -1, 1)\n\n    AddStrucMember(sid_partition_entry, \"chsFirst\", 1, FF_BYTE, -1, 3)\n\n    AddStrucMember(sid_partition_entry, \"type\", 4, FF_BYTE, -1, 1)\n\n    AddStrucMember(sid_partition_entry, \"chsLast\", 5, FF_BYTE, -1, 3)\n\n    AddStrucMember(sid_partition_entry, \"lbaStart\", 8, FF_DWRD, -1, 4)\n\n    AddStrucMember(sid_partition_entry, \"size\", 12, FF_DWRD, -1, 4)\n\n    # add structure PARTITION_TABLE to IDA types\n\n    sid_table = AddStrucEx(-1, \"PARTITION_TABLE\", 0)\n\n    AddStrucMember(sid_table, \"partitions\", 0, FF_STRU, sid, 64)\n\n    return sid_table\n```"]