<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch10"><span epub:type="pagebreak" id="page_105"/><strong>10  STM32F0 SWD Word Leak</strong></h2>&#13;
<p class="noindent">Many microcontrollers allow for some sort of partial locking mode, in which a debugger may be attached but code is still protected. On the STM32 family, this corresponds to RDP Level 1, where flash memory is disconnected after the debugger connects. This chapter describes a vulnerability in the STM32F0 series, in which flash memory is disconnected two clock cycles too late. A carefully orchestrated debugger can dump one word per connection.</p>&#13;
<p class="indent">This vulnerability was first described at Usenix WOOT, near the end of Obermaier and Tatschner (2017).</p>&#13;
<h3 class="h3" id="ch00lev1sec36"><strong>The Bug</strong></h3>&#13;
<p class="noindent">As we discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>, STM32’s readout device protection (RDP) feature has three levels. Level 0 is unprotected, while Level 2 is a total JTAG lockout, rejecting all connection attempts. Level 1 is the in-between setting that most commercial devices are locked with; it works by disconnecting flash memory from the bus when JTAG is connected. The intent was to allow for failure analysis or reprogramming, while still preventing extraction of flash memory for cloning or reverse engineering.</p>&#13;
<p class="indent">You can verify this with OpenOCD or another JTAG debugger. The description holds: connecting to a locked chip works, but nothing useful can be read from flash memory. You can read out RAM, or write something into RAM, but code there cannot read or execute code from flash memory.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_106"/><img id="ch10fig1" src="../images/f0106-01.jpg" alt="Image" width="777" height="737"/></div>&#13;
<p class="figcap">Figure 10.1: STM32F042</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_107"/>Obermaier’s unique observation is that most JTAG debuggers perform multiple transactions when connecting, and that the <em>very first</em> memory access is responsible for locking out flash memory, but that the read often completes before the lock is applied!</p>&#13;
<p class="indent">Why <em>often</em> and not always? The details don’t matter much for exploitation, but the original paper makes a convincing argument that it’s some sort of a bus contention issue. As a workaround, it seems sufficient to retry after failed accesses, and it might help in stubborn situations to add a random delay.</p>&#13;
<h3 class="h3" id="ch00lev1sec37"><strong>The Exploit</strong></h3>&#13;
<p class="noindent">Obermaier’s exploit runs as standalone firmware in one STM32, which implements the SWD protocol to dump the contents of the target chip. Full source code is available, and the following is his function in C to dump one 32-bit word from protected memory. SWD is simpler to implement than JTAG, and in this exploit you’ll see that the SWD implementation is less than six hundred lines.</p>&#13;
<p class="indent">Note that the code must reconnect in a new debugging session for every attempt, as flash memory becomes disconnected after the read. Because individual attempts often fail, it must retry until the transaction succeeds.</p>&#13;
<div class="imagel"><img src="../images/f0107-01.jpg" alt="Image" width="821" height="289"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_108"/><img src="../images/f0108-01.jpg" alt="Image" width="823" height="1056"/></div>&#13;
</div>
</div>
</body></html>