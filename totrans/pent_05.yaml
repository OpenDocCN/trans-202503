- en: Chapter 3. Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we will look at some basic examples of computer programming.
    We will look at writing programs to automate various useful tasks in multiple
    programming languages. Even though we use prebuilt software for the majority of
    this book, it is useful to be able to create your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Bash Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we’ll look at using Bash scripts to run several commands at
    once. *Bash scripts*, or *shell scripts*, are files that include multiple terminal
    commands to be run. Any command we can run in a terminal can be run in a script.
  prefs: []
  type: TYPE_NORMAL
- en: Ping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll call our first script *pingscript.sh*. When it runs, this script will
    perform a *ping sweep* on our local network that sends Internet Control Message
    Protocol (ICMP) messages to remote systems to see if they respond.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the ping tool to determine which hosts are reachable on a network.
    (Although some hosts may not respond to ping requests and may be up despite not
    being “pingable,” a ping sweep is still a good place to start.) By default, we
    supply the IP address or hostname to ping. For example, to ping our Windows XP
    target, enter the bold code in [Example 3-1](ch03.xhtml#pinging_a_remote_host
    "Example 3-1. Pinging a remote host").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1. Pinging a remote host
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can tell from the ping output that the Windows XP target is up and responding
    to ping probes because we received replies to our ICMP requests. (The trouble
    with ping is that it will keep running forever unless you stop it with ctrl-C.)
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Bash Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin writing a simple Bash script to ping hosts on the network. A good
    place to start is by adding some help information that tells your users how to
    run your script correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this script tells the terminal to use the Bash interpreter.
    The next two lines that begin with *echo* simply tell the user that our ping script
    will take a command line argument (network), telling the script which network
    to ping sweep (for example, 192.168.20). The `echo` command will simply print
    the text in quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script implies we are working with a class C network, where the first three
    octets of the IP address make up the network.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the script, use `chmod` to make it executable so we can run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running Our Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, when entering Linux commands, we typed the command name at the prompt.
    The filesystem location of built-in Linux commands as well as pentest tools added
    to Kali Linux are part of our `PATH` environmental variable. The `PATH` variable
    tells Linux which directories to search for executable files. To see which directories
    are included in our `PATH`, enter **`echo $PATH`**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the output that the */root* directory is not listed. That means that
    we won’t be able to simply enter `pingscript.sh` to run our Bash script. Instead
    we’ll enter **`./pingscript.sh`** to tell the terminal to run the script from
    our current directory. As shown next, the script prints the usage information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding Functionality with if Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s add in a bit more functionality with an `if` statement, as shown in
    [Example 3-2](ch03.xhtml#adding_an_if_statement "Example 3-2. Adding an if statement").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2. Adding an `if` statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Typically a script needs to print usage information only if the user uses it
    incorrectly. In this case, the user needs to supply the network to scan as a command
    line argument. If the user fails to do so, we want to inform the user how to run
    our script correctly by printing the usage information.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we can use an `if` statement to see if a condition is met.
    By using an `if` statement, we can have our script echo the usage information
    only under certain conditions—for example, if the user does not supply a command
    line argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement is available in many programming languages, though the syntax
    varies from language to language. In Bash scripting, an `if` statement is used
    like this: `if [`*`condition`*`]`, where *`condition`* is the condition that must
    be met.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our script, we first see whether the first command line argument
    is null ❶. The symbol `$1` represents the first command line argument in a Bash
    script, and double equal signs (`==`) check for equality. After the `if` statement,
    we have a `then` statement ❷. Any commands between the `then` statement and the
    `fi` (`if` backward) ❸ are executed only if the conditional statement is true—in
    this case, when the first command line argument to the script is null.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our new script with no command line argument, the `if` statement
    evaluates as true, because the first command line argument is indeed null, as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As expected we see usage information echoed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: A for Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we run the script again with a command line argument, nothing happens. Now
    let’s add some functionality that is triggered when the user runs the script with
    the proper arguments, as shown in [Example 3-3](ch03.xhtml#adding_a_for_loop "Example 3-3. Adding
    a for loop").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3. Adding a `for` loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After our `then` statement, we use an `else` statement ❶ to instruct the script
    to run code when the `if` statement evaluates as false—in this case, if the user
    supplies a command line argument. Because we want this script to ping all possible
    hosts on the local network, we need to loop through the numbers 1 through 254
    (the possibilities for the final octet of an IP version 4 address) and run the
    `ping` command against each of these possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: An ideal way to run through sequential possibilities is with a `for` loop ❷.
    Our `for` loop, ``for x in `seq 1 254`; do``, tells the script to run the code
    that follows for each number from 1 to 254\. This will allow us to run one set
    of instructions 254 times rather than writing out code for each instance. We denote
    the end of a `for` loop with the instruction `done` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop, we want to ping each of the IP addresses in the network.
    Using ping’s man page, we find that the `-c` option will allow us to limit the
    number of times we ping a host. We set `-c` to `1` so that each host will be pinged
    just once.
  prefs: []
  type: TYPE_NORMAL
- en: To specify which host to ping, we want to concatenate the first command line
    argument (which denotes the first three octets) with the current iteration of
    the `for` loop. The full command to use is `ping -c 1 $1.$x`. Recall that the
    `$1` denotes the first command line argument, and `$x` is the current iteration
    of the `for` loop. The first time our `for` loop runs, it will ping 192.168.20.1,
    then 192.168.20.2, all the way to 192.168.20.254\. After iteration 254, our `for`
    loop finishes.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our script with the first three octets of our IP address as the
    command line argument, the script pings each IP address in the network as shown
    in [Example 3-4](ch03.xhtml#running_the_ping_sweep_script "Example 3-4. Running
    the ping sweep script").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4. Running the ping sweep script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Your results will vary based on the systems in your local network. Based on
    this output, I can tell that in my network, the host 192.168.20.1 is up, and I
    received an ICMP reply ❶. On the other hand, the host 192.168.20.3 is not up,
    so I received a host unreachable notification ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlining the Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All this information printed to screen is not very nice to look at, and anyone
    who uses our script will need to sift through a lot of information to determine
    which hosts in the network are up. Let’s add some additional functionality to
    streamline our results.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter we covered `grep`, which searches for and matches specific
    patterns. Let’s use `grep` to filter the script’s output, as shown in [Example 3-5](ch03.xhtml#using_grep_to_filter_results
    "Example 3-5. Using grep to filter results").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5. Using `grep` to filter results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we look for all instances of the string `64 bytes` ❶, which occurs when
    an ICMP reply is received when pinging a host. If we run the script with this
    change, we see that only lines that include the text `64 bytes` are printed to
    the screen, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We get indicators only for live hosts; hosts that do not answer are not printed
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: But we can make this script even nicer to work with. The point of our ping sweep
    is to get a list of live hosts. By using the `cut` command discussed in [Chapter 2](ch02.xhtml
    "Chapter 2. Using Kali Linux"), we can print the IP addresses of only the live
    hosts, as shown in [Example 3-6](ch03.xhtml#using_cut_to_further_filter_results
    "Example 3-6. Using cut to further filter results").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6. Using `cut` to further filter results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can use a space as the delimiter and grab the fourth field, our IP address,
    as shown at ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now we run the script again as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we see a trailing colon at the end of each line. The results
    would be clear enough to a user, but if we want to use these results as input
    for any other programs, we need to delete the trailing colon. In this case, `sed`
    is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: The `sed` command that will delete the final character from each line is `sed
    's/.$//'`, as shown in [Example 3-7](ch03.xhtml#using_sed_to_drop_the_trailing_colon
    "Example 3-7. Using sed to drop the trailing colon").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7. Using `sed` to drop the trailing colon
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now when we run the script, everything looks perfect, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, if we want to output the results to a file instead of to the screen,
    we can use the `>>` operator, covered in [Chapter 2](ch02.xhtml "Chapter 2. Using
    Kali Linux"), to append each live IP address to a file. Try automating other tasks
    in Linux to practice your Bash scripting skills.
  prefs: []
  type: TYPE_NORMAL
- en: Python Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux systems typically come with interpreters for other scripting languages
    such as Python and Perl. Interpreters for both languages are included in Kali
    Linux. In [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in
    Linux") through [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits,
    and Metasploit Modules"), we’ll use Python to write our own exploit code. For
    now, let’s write a simple Python script and run it in Kali Linux just to demonstrate
    the basics of Python scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example we’ll do something similar to our first Netcat example in
    [Chapter 2](ch02.xhtml "Chapter 2. Using Kali Linux"): We’ll attach to a port
    on a system and see if the port is listening. A starting point for our script
    is shown here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous section, the first line of our script told the terminal to use
    Bash to interpret the script. We do the same thing here, pointing to the Python
    interpreter installed on Kali Linux at */usr/bin/python* ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by prompting the user for data and recording input into variables.
    The variables will store the input for use later in the script. To take input
    from the user, we can use the Python function `raw_input` ❷. We want to save our
    port as an integer, so we use a similar built-in Python function, `input`, at
    ❸. Now we ask the user to input an IP address and a port to test.
  prefs: []
  type: TYPE_NORMAL
- en: After saving the file, use `chmod` to make the script executable before running
    the script, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script, you’re prompted for an IP address and a port, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will add in some functionality to allow us to use the user’s input to
    connect to the chosen system on the selected port to see if it is open ([Example 3-8](ch03.xhtml#adding_port-scanning_functionality
    "Example 3-8. Adding port-scanning functionality")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8. Adding port-scanning functionality
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To perform networking tasks in Python, we can include a library called *socket*
    using the command `import socket` ❶. The socket library does the heavy lifting
    for setting up a network socket.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for creating a TCP network socket is `socket.socket(socket.AF_INET,
    socket.SOCK_STREAM)`. We set a variable equal to this network socket at ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a Port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating a socket to connect to a remote port, the first candidate available
    from Python is the socket function `connect`. However, there is a better candidate
    for our purposes in the similar function, `connect_ex`. According to the Python
    documentation, `connect_ex` is like `connect` except that it returns an error
    code instead of raising an exception if the connection fails. If the connection
    succeeds, `connect_ex` will return the value `0`. Because we want to know whether
    the function can connect to the port, this return value seems ideal to feed into
    an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: if Statements in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building `if` statements in Python, we enter `if` *`condition`*`:`. In
    Python the statements that are part of a conditional `or` loop are denoted with
    indentations rather than ending markers, as we saw in Bash scripting. We can instruct
    our `if` statement to evaluate the returned value of the connection of our TCP
    socket to the user-defined IP address and port with the command `if s.connect_ex((ip,
    port)):` ❸. If the connection succeeds, `connect_ex` will return `0`, which will
    be evaluated by the `if` statement as false. If the connection fails, `connect_ex`
    will return a positive integer, or true. Thus, if our `if` statement evaluates
    as true, it stands to reason that the port is closed, and we can present this
    to the user using the Python `print` command at ❹. And, as in the Bash scripting
    example, if `connect_ex` returns `0` at ❺, we can use an `else` statement (the
    syntax is `else:` in Python) to instead inform the user that the tested port is
    open.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the updated script to test whether TCP port 80 is running on the Windows
    XP target host as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: According to our script, port 80 is open. Now run the script again against port
    81.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, the script reports that port 81 is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will look at checking open ports in [Chapter 5](ch05.xhtml "Chapter 5. Information
    Gathering"), and we will return to Python scripting when we study exploit development.
    Kali Linux also has interpreters for the Perl and Ruby languages. We will learn
    a little bit of Ruby in [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting
    Exploits, and Metasploit Modules"). It never hurts to know a little bit of multiple
    languages. If you are up for a challenge, see if you can re-create this script
    in Perl and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and Compiling C Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time for one more simple programming example, this time in the C programming
    language. Unlike scripting languages such as Bash and Python, C code must be compiled
    and translated into machine language that the CPU can understand before it is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux includes the GNU Compiler Collection (GCC), which will allow us to
    compile C code to run on the system. Let’s create a simple C program that says
    hello to a command line argument, as shown in [Example 3-9](ch03.xhtml#quotation_markhello_worldquotation_mark
    "Example 3-9. “Hello World” C program").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9. “Hello World” C program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for C is a bit different from that of Python and Bash. Because our
    code will be compiled, we don’t need to tell the terminal which interpreter to
    use at the beginning of our code. First, as with our Python example, we import
    a C library. In this case we’ll import the *stdio* (short for standard input and
    output) library, which will allow us to accept input and print output to the terminal.
    In C, we import *stdio* with the command `#include <stdio.h>` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Every C program has a function called `main` ❷ that is run when the program
    starts. Our program will take a command line argument, so we pass an integer `argc`
    and a character array `argv` to `main`. `argc` is the argument count, and `argv`
    is the argument vector, which includes any command line arguments passed to the
    program. This is just standard syntax for C programs that accept command line
    arguments. (In C, the beginning and end of functions, loops, and so on are denoted
    by braces `{}`.)
  prefs: []
  type: TYPE_NORMAL
- en: First, our program checks to see if a command line argument is present. The
    `argc` integer is the length of the argument array; if it is less than two (the
    program name itself and the command line argument), then a command line argument
    has not been given. We can use an `if` statement to check ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for `if` is also a little different in C. As with our Bash script,
    if a command line argument is not given, we can prompt the user with usage information
    ❹. The `printf` function allows us to write output to the terminal. Also note
    that statements in C are finished with a semicolon (`;`). Once we’re through with
    our program, we use a `return` statement ❺ to finish the function `main`. If a
    command line argument is supplied, our `else` statement instructs the program
    to say hello ❻. (Be sure to use braces to close all of your loops and the `main`
    function.)
  prefs: []
  type: TYPE_NORMAL
- en: Before we can run our program, we need to compile it with GCC as shown here.
    Save the program as *cprogram.c*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Use the `-o` option to specify the name for the compiled program and feed your
    C code to GCC. Now run the program from your current directory. If the program
    is run with no arguments, you should see usage information as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If instead we pass it an argument, in this case our name, the program tells
    us hello.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will look at another C programming example in [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux"), where a little bit of sloppy C coding
    leads to a buffer overflow condition, which we will exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve looked at simple programs in three different languages.
    We looked at basic constructs, such as saving information in variables for later
    use. Additionally, we learned how to use conditionals, such as `if` statements,
    and iterations, such as `for` loops, to have the program make decisions based
    on the provided information. Though the syntax used varies from programming language
    to programming language, the ideas are the same.
  prefs: []
  type: TYPE_NORMAL
