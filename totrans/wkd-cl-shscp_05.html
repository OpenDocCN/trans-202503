<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_97"/><span class="big"><strong>4</strong></span><br/><strong>TWEAKING UNIX</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">An outsider might imagine Unix as a nice, uniform command line experience across many different systems, helped by their compliance with the POSIX standards. But anyone who’s ever used more than one Unix system knows how much they can vary within these broad parameters. You’d be hard-pressed to find a Unix or Linux box that doesn’t have <span class="literal">ls</span> as a standard command, for example, but does your version support the <span class="literal">--color</span> flag? Does your version of the Bourne shell support variable slicing (like <span class="literal">${var:0:2}</span>)?</p>&#13;
<p class="indent">Perhaps one of the most valuable uses of shell scripts is tweaking your particular flavor of Unix to make it more like other systems. Although most modern GNU utilities run just fine on non-Linux Unixes (for example, you can replace clunky old <span class="literal">tar</span> with the newer GNU <span class="literal">tar</span>), often the system updates involved in tweaking Unix don’t need to be so drastic, and it’s possible to avoid the potential problems inherent in adding new binaries to a <span epub:type="pagebreak" id="page_98"/>supported system. Instead, shell scripts can be used to map popular flags to their local equivalents, to use core Unix capabilities to create a smarter version of an existing command, or even to address the longtime lack of certain functionality.</p>&#13;
<h3 class="h3" id="ch04lev1sec01"><strong>#27 Displaying a File with Line Numbers</strong></h3>&#13;
<p class="noindenta">There are several ways to add line numbers to a displayed file, many of which are quite short. For example, here’s one solution using <span class="literal">awk</span>:</p>&#13;
<pre class="programs">awk '{ print NR": "$0 }' &lt; inputfile</pre>&#13;
<p class="indent">On some Unix implementations, the <span class="literal">cat</span> command has an <span class="literal">-n</span> flag, and on others, the <span class="literal">more</span> (or <span class="literal">less</span>, or <span class="literal">pg</span>) pager has a flag for specifying that each line of output should be numbered. But on some Unix flavors, none of these methods will work, in which case the simple script in <a href="ch04.xhtml#ch4ex1">Listing 4-1</a> can do the job.</p>&#13;
<h4 class="h4" id="ch04lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # numberlines--A simple alternative to cat -n, etc.&#13;
&#13;
   for filename in "$@"&#13;
   do&#13;
     linecount="1"&#13;
<span class="ent">➊</span>   while IFS="\n" read line&#13;
     do&#13;
       echo "${linecount}: $line"&#13;
<span class="ent">➋</span>     linecount="$(( $linecount + 1 ))"&#13;
<span class="ent">➌</span>   done &lt; $filename&#13;
   done&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch4ex1"/><em>Listing 4-1: The</em> <span class="literal"><em>numberlines</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s a trick to the main loop in this program: it looks like a regular <span class="literal">while</span> loop, but the important part is actually <span class="literal">done &lt; $filename</span> <span class="ent">➌</span>. It turns out that every major block construct acts as its own virtual subshell, so this file redirection is not only valid but also an easy way to have a loop that iterates line by line with the content of <span class="literal">$filename</span>. Couple that with the <span class="literal">read</span> statement at <span class="ent">➊</span>—an inner loop that loads each line, iteration by iteration, into the <span class="literal">line</span> variable—and it’s then easy to output the line with its line number as a preface and increment the <span class="literal">linecount</span> variable <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec03"><span epub:type="pagebreak" id="page_99"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">You can feed as many filenames as you want into this script. You can’t feed it input via a pipe, though that wouldn’t be too hard to fix by invoking a <span class="literal">cat -</span> sequence if no starting parameters are given.</p>&#13;
<h4 class="h4" id="ch04lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch04.xhtml#ch4ex2">Listing 4-2</a> shows a file displayed with line numbers using the <span class="literal">numberlines</span> script.</p>&#13;
<pre class="programs">$ <span class="codestrong">numberlines alice.txt</span>&#13;
1: Alice was beginning to get very tired of sitting by her sister on the&#13;
2: bank, and of having nothing to do: once or twice she had peeped into the&#13;
3: book her sister was reading, but it had no pictures or conversations in&#13;
4: it, 'and what is the use of a book,' thought Alice 'without pictures or&#13;
5: conversations?'&#13;
6:&#13;
7: So she was considering in her own mind (as well as she could, for the&#13;
8: hot day made her feel very sleepy and stupid), whether the pleasure&#13;
9: of making a daisy-chain would be worth the trouble of getting up and&#13;
10: picking the daisies, when suddenly a White Rabbit with pink eyes ran&#13;
11: close by her.</pre>&#13;
<p class="listcap"><a id="ch4ex2"/><em>Listing 4-2: Testing the</em> <span class="literal"><em>numberlines</em></span> <em>script on an excerpt from</em> Alice in Wonderland</p>&#13;
<h4 class="h4" id="ch04lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Once you have a file with numbered lines, you can reverse the order of all the lines in the file, like this:</p>&#13;
<pre class="programs">cat -n filename | sort -rn | cut -c8-</pre>&#13;
<p class="indent">This does the trick on systems supporting the <span class="literal">-n</span> flag to <span class="literal">cat</span>, for example. Where might this be useful? One obvious situation is when displaying a log file in newest-to-oldest order.</p>&#13;
<h3 class="h3" id="ch04lev1sec02"><strong>#28 Wrapping Only Long Lines</strong></h3>&#13;
<p class="noindenta">One limitation of the <span class="literal">fmt</span> command and its shell script equivalent, <a href="ch02.xhtml#ch02lev1sec01">Script #14</a> on <a href="ch02.xhtml#page_53">page 53</a>, is that they wrap and fill every line they encounter, whether or not it makes sense to do so. This can mess up email (wrapping your <span class="literal">.signature</span> is not good, for example) and any input file format where line breaks matter.</p>&#13;
<p class="indent">What if you have a document in which you want to wrap just the long lines but leave everything else intact? With the default set of commands available to a Unix user, there’s only one way to accomplish this: explicitly step through each line in an editor, feeding the long ones to <span class="literal">fmt</span> individually. (You could accomplish this in <span class="literal">vi</span> by moving the cursor onto the line in question and using <span class="literal">!$fmt</span>.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>The script in <a href="ch04.xhtml#ch4ex3">Listing 4-3</a> automates that task, making use of the shell <span class="literal">${#<em>varname</em>}</span> construct, which returns the length of the contents of the data stored in the variable <span class="literal"><em>varname</em></span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # toolong--Feeds the fmt command only those lines in the input stream&#13;
   #   that are longer than the specified length&#13;
&#13;
   width=72&#13;
&#13;
   if [ ! -r "$1" ] ; then&#13;
     echo "Cannot read file $1" &gt;&amp;2&#13;
     echo "Usage: $0 filename" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➊</span> while read input&#13;
   do&#13;
     if [ ${#input} -gt $width ] ; then&#13;
       echo "$input" | fmt&#13;
     else&#13;
       echo "$input"&#13;
     fi&#13;
<span class="ent">➋</span> done &lt; $1&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch4ex3"/><em>Listing 4-3: The</em> <span class="literal"><em>toolong</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Notice that the file is fed to the <span class="literal">while</span> loop with a simple <span class="literal">&lt; $1</span> associated with the end of the loop <span class="ent">➋</span> and that each line can then be analyzed by reading it with <span class="literal">read input</span> <span class="ent">➊</span>, which assigns each line of the file to the <span class="literal">input</span> variable, line by line.</p>&#13;
<p class="indent">If your shell doesn’t have the <span class="literal">${#<em>var</em>}</span> notation, you can emulate its behavior with the super useful “word count” command <span class="literal">wc</span>:</p>&#13;
<pre class="programs">varlength="$(echo "$var" | wc -c)"</pre>&#13;
<p class="indent">However, <span class="literal">wc</span> has an annoying habit of prefacing its output with spaces to get values to align nicely in the output listing. To sidestep that pesky problem, a slight modification is necessary to let only digits through the final pipe step, as shown here:</p>&#13;
<pre class="programs">varlength="$(echo "$var" | wc -c | sed 's/[^[:digit:]]//g')"</pre>&#13;
<h4 class="h4" id="ch04lev2sec08"><span epub:type="pagebreak" id="page_101"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script accepts exactly one filename as input, as <a href="ch04.xhtml#ch4ex4">Listing 4-4</a> shows.</p>&#13;
<h4 class="h4" id="ch04lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">toolong ragged.txt</span>&#13;
So she sat on, with closed eyes, and half believed herself in&#13;
Wonderland, though she knew she had but to open them again, and&#13;
all would change to dull reality--the grass would be only rustling&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling teacups would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the&#13;
sneeze&#13;
of the baby, the shriek of the Gryphon, and all the other queer&#13;
noises, would change (she knew) to the confused clamour of the busy&#13;
farm-yard--while the lowing of the cattle in the distance would&#13;
take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch4ex4"/><em>Listing 4-4: Testing the</em> <span class="literal"><em>toolong</em></span> <em>script</em></p>&#13;
<p class="indent">Notice that unlike a standard invocation of <span class="literal">fmt</span>, <span class="literal">toolong</span> has retained line breaks where possible, so the word <em>sneeze</em>, which is on a line by itself in the input file, is also on a line by itself in the output.</p>&#13;
<h3 class="h3" id="ch04lev1sec03"><strong>#29 Displaying a File with Additional Information</strong></h3>&#13;
<p class="noindenta">Many of the most common Unix and Linux commands were originally designed for slow, barely interactive output environments (we did talk about Unix being an ancient OS, right?) and therefore offer minimal output and interactivity. An example is <span class="literal">cat</span>: when used to view a short file, it doesn’t give much helpful output. It would be nice to have more information about the file, though, so let’s get it! <a href="ch04.xhtml#ch4ex5">Listing 4-5</a> details the <span class="literal">showfile</span> command, an alternative to <span class="literal">cat</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # showfile--Shows the contents of a file, including additional useful info&#13;
&#13;
   width=72&#13;
&#13;
   for input&#13;
   do&#13;
     lines="$(wc -l &lt; $input | sed 's/ //g')"&#13;
     chars="$(wc -c &lt; $input | sed 's/ //g')"&#13;
     owner="$(ls -ld $input | awk '{print $3}')"&#13;
     echo "-----------------------------------------------------------------"&#13;
     echo "File $input ($lines lines, $chars characters, owned by $owner):"&#13;
     echo "-----------------------------------------------------------------"&#13;
     while read line&#13;
     do&#13;
       if [ ${#line} -gt $width ] ; then&#13;
         echo "$line" | fmt | sed -e '1s/^/ /' -e '2,$s/^/+ /'&#13;
       else&#13;
         echo "  $line"&#13;
       fi&#13;
<span class="ent">➊</span>   done &lt; $input&#13;
&#13;
     echo "-----------------------------------------------------------------"&#13;
&#13;
<span class="ent">➋</span> done | ${PAGER:more}&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_102"/><a id="ch4ex5"/><em>Listing 4-5: The</em> <span class="literal"><em>showfile</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec11"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To simultaneously read the input line by line and add head and foot information, this script uses a handy shell trick: near the end of the script, it redirects the input to the <span class="literal">while</span> loop with the snippet <span class="literal">done &lt; $input</span> <span class="ent">➊</span>. Perhaps the most complex element in this script, however, is the invocation of <span class="literal">sed</span> for lines longer than the specified length:</p>&#13;
<pre class="programs">echo "$line" | fmt | sed -e '1s/^/ /' -e '2,$s/^/+ /'</pre>&#13;
<p class="indent">Lines greater than the maximum allowable length are wrapped with <span class="literal">fmt</span> (or its shell script replacement, <a href="ch02.xhtml#ch02lev1sec01">Script #14</a> on <a href="ch02.xhtml#page_53">page 53</a>). To visually denote which lines are continuations and which are retained intact from the original file, the first output line of the excessively long line has the usual two-space indent, but subsequent lines are prefixed with a plus sign and a single space instead. Finally, piping the output into <span class="literal">${PAGER:more}</span> displays the file with the pagination program set with the system variable <span class="literal">$PAGER</span> or, if that’s not set, the <span class="literal">more</span> program <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec12"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">You can run <span class="literal">showfile</span> by specifying one or more filenames when the program is invoked, as <a href="ch04.xhtml#ch4ex6">Listing 4-6</a> shows.</p>&#13;
<h4 class="h4" id="ch04lev2sec13"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">showfile ragged.txt</span>&#13;
-----------------------------------------------------------------&#13;
File ragged.txt (7 lines, 639 characters, owned by taylor):&#13;
-----------------------------------------------------------------&#13;
  So she sat on, with closed eyes, and half believed herself in&#13;
  Wonderland, though she knew she had but to open them again, and&#13;
  all would change to dull reality--the grass would be only rustling&#13;
+ in the wind, and the pool rippling to the waving of the reeds--the&#13;
  rattling teacups would change to tinkling sheep-bells, and the&#13;
  Queen's shrill cries to the voice of the shepherd boy--and the&#13;
  sneeze&#13;
  of the baby, the shriek of the Gryphon, and all the other queer&#13;
+ noises, would change (she knew) to the confused clamour of the busy&#13;
+ farm-yard--while the lowing of the cattle in the distance would&#13;
+ take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_103"/><a id="ch4ex6"/><em>Listing 4-6: Testing the</em> <span class="literal"><em>showfile</em></span> <em>script</em></p>&#13;
<h3 class="h3" id="ch04lev1sec04"><strong>#30 Emulating GNU-Style Flags with quota</strong></h3>&#13;
<p class="noindenta">The inconsistency across the command flags of various Unix and Linux systems is a perpetual problem that causes lots of grief for users who switch between any of the major releases, particularly between a commercial Unix system (SunOS/Solaris, HP-UX, and so on) and an open source Linux system. One command that demonstrates this problem is <span class="literal">quota</span>, which supports full-word flags on some Unix systems but accepts only one-letter flags on others.</p>&#13;
<p class="indent">A succinct shell script (shown in <a href="ch04.xhtml#ch4ex7">Listing 4-7</a>) solves the problem by mapping any full-word flags specified to the equivalent single-letter alternatives.</p>&#13;
<h4 class="h4" id="ch04lev2sec14"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # newquota--A frontend to quota that works with full-word flags a la GNU&#13;
&#13;
   # quota has three possible flags, -g, -v, and -q, but this script&#13;
   #   allows them to be '--group', '--verbose', and '--quiet' too.&#13;
&#13;
   flags=""&#13;
   realquota="$(which quota)"&#13;
&#13;
   while [ $# -gt 0 ]&#13;
   do&#13;
     case $1&#13;
     in&#13;
       --help)      echo "Usage: $0 [--group --verbose --quiet -gvq]" &gt;&amp;2&#13;
                          exit 1 ;;&#13;
       --group)     flags="$flags -g";   shift ;;&#13;
       --verbose)   flags="$flags -v";   shift ;;&#13;
       --quiet)     flags="$flags -q";   shift ;;&#13;
       --)          shift;               break ;;&#13;
       *)           break;          # Done with 'while' loop!&#13;
     esac&#13;
&#13;
   done&#13;
&#13;
<span class="ent">➊</span> exec $realquota $flags "$@"</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_104"/><a id="ch4ex7"/><em>Listing 4-7: The</em> <span class="literal"><em>newquota</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec15"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script really boils down to a <span class="literal">while</span> statement that steps through every argument specified to the script, identifying any of the matching full-word flags and adding the associated one-letter flag to the <span class="literal">flags</span> variable. When done, it simply invokes the original quota program <span class="ent">➊</span> and adds the user-specified flags as needed.</p>&#13;
<h4 class="h4" id="ch04lev2sec16"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">There are a couple of ways to integrate a wrapper of this nature into your system. The most obvious is to rename this script <span class="literal">quota</span>, then place this script in a local directory (say, <em>/usr/local/bin</em>), and ensure that users have a default <span class="literal">PATH</span> that looks in this directory before looking in the standard Linux binary distro directories (<em>/bin</em> and <em>/usr/bin</em>). Another way is to add system-wide aliases so that a user entering <span class="literal">quota</span> actually invokes the <span class="literal">newquota</span> script. (Some Linux distros ship with utilities for managing system aliases, such as Debian’s <span class="literal">alternatives</span> system.) This last strategy could be risky, however, if users call <span class="literal">quota</span> with the new flags in their own shell scripts: if those scripts don’t use the user’s interactive login shell, they might not see the specified alias and will end up calling the base <span class="literal">quota</span> command rather than <span class="literal">newquota</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec17"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch04.xhtml#ch4ex8">Listing 4-8</a> details running <span class="literal">newquota</span> with the <span class="literal">--verbose</span> and <span class="literal">--quiet</span> arguments.</p>&#13;
<pre class="programs">$ <span class="codestrong">newquota --verbose</span>&#13;
Disk quotas for user dtint (uid 24810):&#13;
     Filesystem   usage   quota   limit   grace   files   quota   limit   grace&#13;
           /usr  338262  614400  675840           10703  120000  126000&#13;
$ <span class="codestrong">newquota --quiet</span></pre>&#13;
<p class="listcap"><a id="ch4ex8"/><em>Listing 4-8: Testing the</em> <span class="literal"><em>newquota</em></span> <em>script</em></p>&#13;
<p class="indent">The <span class="literal">--quiet</span> mode emits output only if the user is over quota. You can see that this is working correctly from the last result, where we’re not over quota. Phew!</p>&#13;
<h3 class="h3" id="ch04lev1sec05"><strong>#31 Making sftp Look More Like ftp</strong></h3>&#13;
<p class="noindenta">The secure version of the File Transfer Protocol <span class="literal">ftp</span> program is included as part of <span class="literal">ssh</span>, the Secure Shell package, but its interface can be a bit confusing for users who are making the switch from the crusty old <span class="literal">ftp</span> client. The basic problem is that <span class="literal">ftp</span> is invoked as <span class="literal">ftp remotehost</span> and it then prompts <span epub:type="pagebreak" id="page_105"/>for account and password information. By contrast, <span class="literal">sftp</span> wants to know the account and remote host on the command line and won’t work properly (or as expected) if only the host is specified.</p>&#13;
<p class="indent">To address this, the simple wrapper script detailed in <a href="ch04.xhtml#ch4ex9">Listing 4-9</a> allows users to invoke <span class="literal">mysftp</span> exactly as they would have invoked the <span class="literal">ftp</span> program and be prompted for the necessary fields.</p>&#13;
<h4 class="h4" id="ch04lev2sec18"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # mysftp--Makes sftp start up more like ftp&#13;
&#13;
   /bin/echo -n "User account: "&#13;
   read account&#13;
&#13;
   if [ -z $account ] ; then&#13;
     exit 0;       # Changed their mind, presumably&#13;
   fi&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     /bin/echo -n "Remote host: "&#13;
     read host&#13;
     if [ -z $host ] ; then&#13;
       exit 0&#13;
     fi&#13;
   else&#13;
     host=$1&#13;
   fi&#13;
&#13;
   # End by switching to sftp. The -C flag enables compression here.&#13;
&#13;
<span class="ent">➊</span> exec sftp -C $account@$host</pre>&#13;
<p class="listcap"><a id="ch4ex9"/><em>Listing 4-9: The</em> <span class="literal"><em>mysftp</em></span> <em>script, a friendlier version of</em> <span class="literal"><em>sftp</em></span></p>&#13;
<h4 class="h4" id="ch04lev2sec19"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s a trick in this script worth mentioning. It’s actually something we’ve done in previous scripts, though we haven’t highlighted it for you before: the last line is an <span class="literal">exec</span> call <span class="ent">➊</span>. What this does is <em>replace</em> the currently running shell with the application specified. Because you know there’s nothing left to do after calling the <span class="literal">sftp</span> command, this method of ending our script is much more resource efficient than having the shell hanging around waiting for <span class="literal">sftp</span> to finish using a separate subshell, which is what would happen if we just invoked <span class="literal">sftp</span> instead.</p>&#13;
<h4 class="h4" id="ch04lev2sec20"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">As with the <span class="literal">ftp</span> client, if users omit the remote host, the script continues by prompting for a remote host. If the script is invoked as <span class="literal">mysftp remotehost</span>, the <span class="literal">remotehost</span> provided is used instead.</p>&#13;
<h4 class="h4" id="ch04lev2sec21"><span epub:type="pagebreak" id="page_106"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Let’s see what happens when you invoke this script without any arguments versus invoking <span class="literal">sftp</span> without any arguments. <a href="ch04.xhtml#ch4ex10">Listing 4-10</a> shows running <span class="literal">sftp</span>.</p>&#13;
<pre class="programs">$ <span class="codestrong">sftp</span>&#13;
usage: sftp [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]&#13;
          [-D sftp_server_path] [-F ssh_config] [-i identity_file] [-l limit]&#13;
          [-o ssh_option] [-P port] [-R num_requests] [-S program]&#13;
          [-s subsystem | sftp_server] host&#13;
       sftp [user@]host[:file ...]&#13;
       sftp [user@]host[:dir[/]]&#13;
       sftp -b batchfile [user@]host</pre>&#13;
<p class="listcap"><a id="ch4ex10"/><em>Listing 4-10: Running the</em> <span class="literal"><em>sftp</em></span> <em>utility with no arguments yields very cryptic help output.</em></p>&#13;
<p class="indent">That’s useful but confusing. By contrast, with the <span class="literal">mysftp</span> script you can proceed to make an actual connection, as <a href="ch04.xhtml#ch4ex11">Listing 4-11</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">mysftp</span>&#13;
User account: <span class="codestrong">taylor</span>&#13;
Remote host: <span class="codestrong">intuitive.com</span>&#13;
Connecting to intuitive.com...&#13;
taylor@intuitive.com's password:&#13;
sftp&gt; <span class="codestrong">quit</span></pre>&#13;
<p class="listcap"><a id="ch4ex11"/><em>Listing 4-11: Running the</em> <span class="literal"><em>mysftp</em></span> <em>script with no arguments is much clearer.</em></p>&#13;
<p class="indent">Invoke the script as if it were an <span class="literal">ftp</span> session by supplying the remote host, and it’ll prompt for the remote account name (detailed in <a href="ch04.xhtml#ch4ex12">Listing 4-12</a>) and then invisibly invoke <span class="literal">sftp</span>.</p>&#13;
<pre class="programs">$ <span class="codestrong">mysftp intuitive.com</span>&#13;
User account: <span class="codestrong">taylor</span>&#13;
Connecting to intuitive.com...&#13;
taylor@intuitive.com's password:&#13;
sftp&gt; <span class="codestrong">quit</span></pre>&#13;
<p class="listcap"><a id="ch4ex12"/><em>Listing 4-12: Running the</em> <span class="literal"><em>mysftp</em></span> <em>script with a single argument: the host to connect to</em></p>&#13;
<h4 class="h4" id="ch04lev2sec22"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One thing to always think about when you have a script like this is whether it can be the basis of an automated backup or sync tool, and <span class="literal">mysftp</span> is a perfect candidate. So a great hack would be to designate a directory on your system, for example, then write a wrapper that would create a ZIP archive of key files, and use <span class="literal">mysftp</span> to copy them up to a server or cloud storage system. In fact, we’ll do just that later in the book with <a href="ch09.xhtml#ch09lev1sec04">Script #72</a> on <a href="ch09.xhtml#page_229">page 229</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec06"><span epub:type="pagebreak" id="page_107"/><strong>#32 Fixing grep</strong></h3>&#13;
<p class="noindenta">Some versions of <span class="literal">grep</span> offer a remarkable range of capabilities, including the particularly useful ability to show the context (a line or two above and below) of a matching line in the file. Additionally, some versions of <span class="literal">grep</span> can highlight the region in the line (for simple patterns, at least) that matches the specified pattern. You might already have such a version of <span class="literal">grep</span>. Then again, you might not.</p>&#13;
<p class="indent">Fortunately, both of these features can be emulated with a shell script, so you can still use them even if you’re on an older commercial Unix system with a relatively primitive <span class="literal">grep</span> command. To specify the number of lines of context both above and below the line matching the pattern that you specified, use <span class="literal">-c <em>value</em></span>, followed by the pattern to match. This script (shown in <a href="ch04.xhtml#ch4ex13">Listing 4-13</a>) also borrows from the ANSI color script, <a href="ch01.xhtml#ch01lev1sec12">Script #11</a> on <a href="ch01.xhtml#page_40">page 40</a>, to do region highlighting.</p>&#13;
<h4 class="h4" id="ch04lev2sec23"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # cgrep--grep with context display and highlighted pattern matches&#13;
&#13;
   context=0&#13;
   esc="^["&#13;
   boldon="${esc}[1m" boldoff="${esc}[22m"&#13;
   sedscript="/tmp/cgrep.sed.$$"&#13;
   tempout="/tmp/cgrep.$$"&#13;
&#13;
   function showMatches&#13;
   {&#13;
     matches=0&#13;
&#13;
<span class="ent">➊</span>   echo "s/$pattern/${boldon}$pattern${boldoff}/g" &gt; $sedscript&#13;
&#13;
<span class="ent">➋</span>   for lineno in $(grep -n "$pattern" $1 | cut -d: -f1)&#13;
     do&#13;
       if [ $context -gt 0 ] ; then&#13;
<span class="ent">➌</span>       prev="$(( $lineno - $context ))"&#13;
&#13;
         if [ $prev -lt 1 ] ; then&#13;
           # This results in "invalid usage of line address 0."&#13;
           prev="1"&#13;
         fi&#13;
<span class="ent">➍</span>       next="$(( $lineno + $context ))"&#13;
&#13;
         if [ $matches -gt 0 ] ; then&#13;
           echo "${prev}i\\" &gt;&gt; $sedscript&#13;
           echo "----" &gt;&gt; $sedscript&#13;
         fi&#13;
         echo "${prev},${next}p" &gt;&gt; $sedscript&#13;
       else&#13;
         echo "${lineno}p" &gt;&gt; $sedscript&#13;
       fi&#13;
       matches="$(( $matches + 1 ))"&#13;
     done&#13;
&#13;
     if [ $matches -gt 0 ] ; then&#13;
       sed -n -f $sedscript $1 | uniq | more&#13;
     fi&#13;
   }&#13;
&#13;
<span class="ent">➎</span> trap "$(which rm) -f $tempout $sedscript" EXIT&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     echo "Usage: $0 [-c X] pattern {filename}" &gt;&amp;2&#13;
     exit 0&#13;
   fi&#13;
&#13;
   if [ "$1" = "-c" ] ; then&#13;
     context="$2"&#13;
     shift; shift&#13;
   elif [ "$(echo $1|cut -c1-2)" = "-c" ] ; then&#13;
     context="$(echo $1 | cut -c3-)"&#13;
     shift&#13;
   fi&#13;
&#13;
   pattern="$1"; shift&#13;
&#13;
   if [ $# -gt 0 ] ; then&#13;
     for filename ; do&#13;
       echo "----- $filename -----"&#13;
       showMatches $filename&#13;
     done&#13;
   else&#13;
     cat - &gt; $tempout      # Save stream to a temp file.&#13;
     showMatches $tempout&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_108"/><a id="ch4ex13"/><em>Listing 4-13: The</em> <span class="literal"><em>cgrep</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec24"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script uses <span class="literal">grep -n</span> to get the line numbers of all matching lines in the file <span class="ent">➋</span> and then, using the specified number of lines of context to include, identifies a starting <span class="ent">➌</span> and ending <span class="ent">➍</span> line for displaying each match. These are written out to the temporary <span class="literal">sed</span> script defined at <span class="ent">➊</span>, which executes a word substitution command that wraps the specified pattern in bold-on and bold-off ANSI sequences. That’s 90 percent of the script, in a nutshell.</p>&#13;
<p class="indent">The other thing worth mentioning in this script is the useful <span class="literal">trap</span> command <span class="ent">➎</span>, which lets you tie events into the shell’s script execution <span epub:type="pagebreak" id="page_109"/>system itself. The first argument is the command or sequence of commands you want invoked, and all subsequent arguments are the specific signals (events). In this case, we’re telling the shell that when the script exits, invoke <span class="literal">rm</span> to remove the two temp files.</p>&#13;
<p class="indent">What’s particularly nice about working with <span class="literal">trap</span> is that it works regardless of where you exit the script, not just at the very bottom. In subsequent scripts, you’ll see that <span class="literal">trap</span> can be tied to a wide variety of signals, not just <span class="literal">SIGEXIT</span> (or <span class="literal">EXIT</span>, or the numeric equivalent of <span class="literal">SIGEXIT</span>, which is <span class="literal">0</span>). In fact, you can have different <span class="literal">trap</span> commands associated with different signals, so you might output a “cleaned-up temp files” message if someone sends a <span class="literal">SIGQUIT</span> (<small>CTRL</small>-C) to a script, while that wouldn’t be displayed on a regular (<span class="literal">SIGEXIT</span>) event.</p>&#13;
<h4 class="h4" id="ch04lev2sec25"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script works either with an input stream, in which case it saves the input to a temp file and then processes the temp file as if its name had been specified on the command line, or with a list of one or more files on the command line. <a href="ch04.xhtml#ch4ex14">Listing 4-14</a> shows passing a single file via the command line.</p>&#13;
<h4 class="h4" id="ch04lev2sec26"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">cgrep -c 1 teacup ragged.txt</span>&#13;
----- ragged.txt -----&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling <span class="codestrong">teacups</span> would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the</pre>&#13;
<p class="listcap"><a id="ch4ex14"/><em>Listing 4-14: Testing the</em> <span class="literal"><em>cgrep</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec27"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A useful refinement to this script would return line numbers along with the matched lines.</p>&#13;
<h3 class="h3" id="ch04lev1sec07"><strong>#33 Working with Compressed Files</strong></h3>&#13;
<p class="noindenta">Throughout the years of Unix development, few programs have been reconsidered and redeveloped more times than <span class="literal">compress</span>. On most Linux systems, three significantly different compression programs are available: <span class="literal">compress</span>, <span class="literal">gzip</span>, and <span class="literal">bzip2</span>. Each uses a different suffix (<em>.z</em>, <em>.gz</em>, and <em>.bz2</em>, respectively), and the degree of compression can vary among the three programs, depending on the layout of data within a file.</p>&#13;
<p class="indent">Regardless of the level of compression, and regardless of which compression programs you have installed, working with compressed files on many Unix systems requires decompressing them by hand, accomplishing the desired tasks, and recompressing them when finished. Tedious, and thus a <span epub:type="pagebreak" id="page_110"/>perfect job for a shell script! The script detailed in <a href="ch04.xhtml#ch4ex15">Listing 4-15</a> acts as a convenient compression/decompression wrapper for three functions you’ll often find yourself wanting to use on compressed files: <span class="literal">cat</span>, <span class="literal">more</span>, and <span class="literal">grep</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec28"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # zcat, zmore, and zgrep--This script should be either symbolically&#13;
   #   linked or hard linked to all three names. It allows users to work with&#13;
   #   compressed files transparently.&#13;
&#13;
    Z="compress";  unZ="uncompress"  ;  Zlist=""&#13;
   gz="gzip"    ; ungz="gunzip"      ; gzlist=""&#13;
   bz="bzip2"   ; unbz="bunzip2"     ; bzlist=""&#13;
&#13;
   # First step is to try to isolate the filenames in the command line.&#13;
   #   We'll do this lazily by stepping through each argument, testing to&#13;
   #   see whether it's a filename. If it is and it has a compression&#13;
   #   suffix, we'll decompress the file, rewrite the filename, and proceed.&#13;
   #   When done, we'll recompress everything that was decompressed.&#13;
&#13;
   for arg&#13;
   do&#13;
     if [ -f "$arg" ] ; then&#13;
       case "$arg" in&#13;
          *.Z) $unZ "$arg"&#13;
               arg="$(echo $arg | sed 's/\.Z$//')"&#13;
               Zlist="$Zlist \"$arg\""&#13;
               ;;&#13;
&#13;
         *.gz) $ungz "$arg"&#13;
               arg="$(echo $arg | sed 's/\.gz$//')"&#13;
               gzlist="$gzlist \"$arg\""&#13;
               ;;&#13;
&#13;
        *.bz2) $unbz "$arg"&#13;
               arg="$(echo $arg | sed 's/\.bz2$//')"&#13;
               bzlist="$bzlist \"$arg\""&#13;
               ;;&#13;
       esac&#13;
     fi&#13;
     newargs="${newargs:-""} \"$arg\""&#13;
   done&#13;
&#13;
   case $0 in&#13;
      *zcat* ) eval cat $newargs                   ;;&#13;
     *zmore* ) eval more $newargs                  ;;&#13;
     *zgrep* ) eval grep $newargs                  ;;&#13;
           * ) echo "$0: unknown base name. Can't proceed." &gt;&amp;2&#13;
               exit 1&#13;
   esac&#13;
&#13;
   # Now recompress everything.&#13;
&#13;
   if [ ! -z "$Zlist"  ] ; then&#13;
<span class="ent">➊</span>   eval $Z $Zlist&#13;
   fi&#13;
   if [ ! -z "$gzlist"] ; then&#13;
<span class="ent">➋</span>   eval $gz $gzlist&#13;
   fi&#13;
   if [ ! -z "$bzlist" ] ; then&#13;
<span class="ent">➌</span>   eval $bz $bzlist&#13;
   fi&#13;
&#13;
   # And done!&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_111"/><a id="ch4ex15"/><em>Listing 4-15: The</em> <span class="literal"><em>zcat</em></span><em>/</em><span class="literal"><em>zmore</em></span><em>/</em><span class="literal"><em>zgrep</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec29"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">For any given suffix, three steps are necessary: decompress the file, rename the filename to remove the suffix, and add it to the list of files to recompress at the end of the script. By keeping three separate lists, one for each compression program, this script also lets you easily <span class="literal">grep</span> across files compressed using different compression utilities.</p>&#13;
<p class="indent">The most important trick is the use of the <span class="literal">eval</span> directive when recom-pressing the files <span class="ent">➊</span><span class="ent">➋</span><span class="ent">➌</span>. This is necessary to ensure that filenames with spaces are treated properly. When the <span class="literal">Zlist</span>, <span class="literal">gzlist,</span> and <span class="literal">bzlist</span> variables are instantiated, each argument is surrounded by quotes, so a typical value might be <span class="literal">""sample.c" "test.pl" "penny.jar""</span>. Because the list has nested quotes, invoking a command like <span class="literal">cat $Zlist</span> results in <span class="literal">cat</span> complaining that file <span class="literal">"sample.c"</span> wasn’t found. To force the shell to act as if the command were typed at a command line (where the quotes are stripped once they have been utilized for <span class="literal">arg</span> parsing), use <span class="literal">eval</span>, and all will work as desired.</p>&#13;
<h4 class="h4" id="ch04lev2sec30"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To work properly, this script should have three names. How do you do that in Linux? Simple: links. You can use either symbolic links, which are special files that store the names of link destinations, or hard links, which are actually assigned the same inode as the linked file. We prefer symbolic links. These can easily be created (here the script is already called <span class="literal">zcat</span>), as <a href="ch04.xhtml#ch4ex16">Listing 4-16</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">ln -s zcat zmore</span>&#13;
$ <span class="codestrong">ln -s zcat zgrep</span></pre>&#13;
<p class="listcap"><a id="ch4ex16"/><em>Listing 4-16: Symbolically linking the</em> <span class="literal"><em>zcat</em></span> <em>script to the</em> <span class="literal"><em>zmore</em></span> <em>and</em> <span class="literal"><em>zgrep</em></span> <em>commands</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>Once that’s done, you have three new commands that have the same actual (shared) contents, and each accepts a list of files to process as needed, decompressing and then recompressing them when done.</p>&#13;
<h4 class="h4" id="ch04lev2sec31"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The ubiquitous <span class="literal">compress</span> utility quickly shrinks down <em>ragged.txt</em> and gives it a <em>.z</em> suffix:</p>&#13;
<pre class="programs">$ <span class="codestrong">compress ragged.txt</span></pre>&#13;
<p class="indent">With <em>ragged.txt</em> in its compressed state, we can view the file with <span class="literal">zcat</span>, as <a href="ch04.xhtml#ch4ex17">Listing 4-17</a> details.</p>&#13;
<pre class="programs">$ <span class="codestrong">zcat ragged.txt.Z</span>&#13;
So she sat on, with closed eyes, and half believed herself in&#13;
Wonderland, though she knew she had but to open them again, and&#13;
all would change to dull reality--the grass would be only rustling&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling teacups would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the&#13;
sneeze of the baby, the shriek of the Gryphon, and all the other&#13;
queer noises, would change (she knew) to the confused clamour of&#13;
the busy farm-yard--while the lowing of the cattle in the distance&#13;
would take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch4ex17"/><em>Listing 4-17: Using</em> <span class="literal"><em>zcat</em></span> <em>to print the compressed text file</em></p>&#13;
<p class="indent">And then search for <em>teacup</em> again.</p>&#13;
<pre class="programs">$ <span class="codestrong">zgrep teacup ragged.txt.Z</span>&#13;
rattling teacups would change to tinkling sheep-bells, and the</pre>&#13;
<p class="indent">All the while, the file starts and ends in its original compressed state, shown in <a href="ch04.xhtml#ch4ex18">Listing 4-18</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l ragged.txt*</span>&#13;
-rw-r--r-- 1 taylor staff 443 Jul 7 16:07 ragged.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex18"/><em>Listing 4-18: The results of</em> <span class="literal"><em>ls</em></span><em>, showing only that the compressed file exists</em></p>&#13;
<h4 class="h4" id="ch04lev2sec32"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Probably the biggest weakness of this script is that if it is canceled in midstream, the file isn’t guaranteed to recompress. A nice addition would be to fix this with a smart use of the <span class="literal">trap</span> capability and a recompress function that does error checking.</p>&#13;
<h3 class="h3" id="ch04lev1sec08"><span epub:type="pagebreak" id="page_113"/><strong>#34 Ensuring Maximally Compressed Files</strong></h3>&#13;
<p class="noindenta">As highlighted in <a href="ch04.xhtml#ch04lev1sec07">Script #33</a> on <a href="ch04.xhtml#page_109">page 109</a>, most Linux implementations include more than one compression method, but the onus is on the user to figure out which one does the best job of compressing a given file. As a result, users typically learn how to work with just one compression program without realizing that they could attain better results with a different one. Even more confusing is the fact that some files compress better with one algorithm than with another, and there’s no way to know which is better without experimentation.</p>&#13;
<p class="indent">The logical solution is to have a script that compresses files using each of the tools and then selects the smallest resultant file as the best. That’s exactly what <span class="literal">bestcompress</span> does, shown in <a href="ch04.xhtml#ch4ex19">Listing 4-19</a>!</p>&#13;
<h4 class="h4" id="ch04lev2sec33"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # bestcompress--Given a file, tries compressing it with all the available&#13;
   #   compression tools and keeps the compressed file that's smallest,&#13;
   #   reporting the result to the user. If -a isn't specified, bestcompress&#13;
   #   skips compressed files in the input stream.&#13;
&#13;
   Z="compress"     gz="gzip"     bz="bzip2"&#13;
   Zout="/tmp/bestcompress.$$.Z"&#13;
   gzout="/tmp/bestcompress.$$.gz"&#13;
   bzout="/tmp/bestcompress.$$.bz"&#13;
   skipcompressed=1&#13;
&#13;
   if [ "$1" = "-a" ] ; then&#13;
     skipcompressed=0 ; shift&#13;
   fi&#13;
&#13;
   if [ $# -eq 0 ]; then&#13;
     echo "Usage: $0 [-a] file or files to optimally compress" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   trap "/bin/rm -f $Zout $gzout $bzout" EXIT&#13;
&#13;
   for name in "$@"&#13;
   do&#13;
     if [ ! -f "$name" ] ; then&#13;
       echo "$0: file $name not found. Skipped." &gt;&amp;2&#13;
       continue&#13;
     fi&#13;
&#13;
     if [ "$(echo $name | egrep '(\.Z$|\.gz$|\.bz2$)')" != "" ] ; then&#13;
       if [ $skipcompressed -eq 1 ] ; then&#13;
         echo "Skipped file ${name}: It's already compressed."&#13;
         continue&#13;
       else&#13;
         echo "Warning: Trying to double-compress $name"&#13;
       fi&#13;
     fi&#13;
&#13;
   # Try compressing all three files in parallel.&#13;
<span class="ent">➊</span>   $Z  &lt; "$name" &gt; $Zout  &amp;&#13;
     $gz &lt; "$name" &gt; $gzout &amp;&#13;
     $bz &lt; "$name" &gt; $bzout &amp;&#13;
&#13;
     wait  # Wait until all compressions are done.&#13;
&#13;
   # Figure out which compressed best.&#13;
<span class="ent">➋</span>   smallest="$(ls -l "$name" $Zout $gzout $bzout | \&#13;
       awk '{print $5"="NR}' | sort -n | cut -d= -f2 | head -1)"&#13;
&#13;
     case "$smallest" in&#13;
<span class="ent">➌</span>     1 ) echo "No space savings by compressing $name. Left as is."&#13;
           ;;&#13;
       2 ) echo Best compression is with compress. File renamed ${name}.Z&#13;
           mv $Zout "${name}.Z" ; rm -f "$name"&#13;
           ;;&#13;
       3 ) echo Best compression is with gzip. File renamed ${name}.gz&#13;
           mv $gzout "${name}.gz" ; rm -f "$name"&#13;
           ;;&#13;
       4 ) echo Best compression is with bzip2. File renamed ${name}.bz2&#13;
           mv $bzout "${name}.bz2" ; rm -f "$name"&#13;
     esac&#13;
&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_114"/><a id="ch4ex19"/><em>Listing 4-19: The</em> <span class="literal"><em>bestcompress</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec34"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The most interesting line in this script is at <span class="ent">➋</span>. This line has <span class="literal">ls</span> output the size of each file (the original and the three compressed files, in a known order), chops out just the file sizes with <span class="literal">awk</span>, sorts these numerically, and ends up with the line number of the smallest resultant file. If the compressed versions are all bigger than the original file, the result is <span class="literal">1</span>, and an appropriate message is printed out <span class="ent">➌</span>. Otherwise, <span class="literal">smallest</span> will indicate which of <span class="literal">compress</span>, <span class="literal">gzip</span>, or <span class="literal">bzip2</span> did the best job. Then it’s just a matter of moving the appropriate file into the current directory and removing the original file.</p>&#13;
<p class="indent">The three compression calls starting at <span class="ent">➊</span> are also worth pointing out. These calls are done in parallel by using the trailing <span class="literal">&amp;</span> to drop each of them into its own subshell, followed by the call to <span class="literal">wait</span>, which stops the script until all the calls are completed. On a uniprocessor, this might not offer much performance benefit, but with multiple processors, it should spread the task out and potentially complete quite a bit faster.</p>&#13;
<h4 class="h4" id="ch04lev2sec35"><span epub:type="pagebreak" id="page_115"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script should be invoked with a list of filenames to compress. If some of them are already compressed and you want to try compressing them further, use the <span class="literal">-a</span> flag; otherwise they’ll be skipped.</p>&#13;
<h4 class="h4" id="ch04lev2sec36"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The best way to demonstrate this script is with a file that needs to be compressed, as <a href="ch04.xhtml#ch4ex20">Listing 4-20</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l alice.txt</span>&#13;
-rw-r--r--  1 taylor  staff  154872 Dec  4  2002 alice.txt</pre>&#13;
<p class="listcap"><a id="ch4ex20"/><em>Listing 4-20: Showing the</em> <span class="literal"><em>ls</em></span> <em>output of a copy of</em> Alice in Wonderland<em>. Note the file size of 154872 bytes.</em></p>&#13;
<p class="indent">The script hides the process of compressing the file with each of the three compression tools and instead simply displays the results, shown in <a href="ch04.xhtml#ch4ex21">Listing 4-21</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">bestcompress alice.txt</span>&#13;
Best compression is with compress. File renamed alice.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex21"/><em>Listing 4-21: Running the</em> <span class="literal"><em>bestcompress</em></span> <em>script on</em> alice.txt</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4ex22">Listing 4-22</a> demonstrates that the file is now quite a bit smaller.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l alice.txt.Z</span>&#13;
-rw-r--r--  1 taylor  wheel  66287 Jul  7 17:31 alice.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex22"/><em>Listing 4-22: Demonstrating the much-reduced file size of the compressed file (66287 bytes) compared to <a href="ch04.xhtml#ch4ex20">Listing 4-20</a></em><span epub:type="pagebreak" id="page_116"/></p>&#13;
</body></html>