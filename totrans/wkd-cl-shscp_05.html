<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_97"/><span class="big"><strong>4</strong></span><br/><strong>TWEAKING UNIX</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">An outsider might imagine Unix as a nice, uniform command line experience across many different systems, helped by their compliance with the POSIX standards. But anyone who’s ever used more than one Unix system knows how much they can vary within these broad parameters. You’d be hard-pressed to find a Unix or Linux box that doesn’t have <code>ls</code> as a standard command, for example, but does your version support the <code>--color</code> flag? Does your version of the Bourne shell support variable slicing (like <code>${var:0:2}</code>)?</p>&#13;
<p class="indent">Perhaps one of the most valuable uses of shell scripts is tweaking your particular flavor of Unix to make it more like other systems. Although most modern GNU utilities run just fine on non-Linux Unixes (for example, you can replace clunky old <code>tar</code> with the newer GNU <code>tar</code>), often the system updates involved in tweaking Unix don’t need to be so drastic, and it’s possible to avoid the potential problems inherent in adding new binaries to a <span epub:type="pagebreak" id="page_98"/>supported system. Instead, shell scripts can be used to map popular flags to their local equivalents, to use core Unix capabilities to create a smarter version of an existing command, or even to address the longtime lack of certain functionality.</p>&#13;
<h3 class="h3" id="ch04lev1sec01"><strong>#27 Displaying a File with Line Numbers</strong></h3>&#13;
<p class="noindenta">There are several ways to add line numbers to a displayed file, many of which are quite short. For example, here’s one solution using <code>awk</code>:</p>&#13;
<pre class="programs">awk '{ print NR": "$0 }' &lt; inputfile</pre>&#13;
<p class="indent">On some Unix implementations, the <code>cat</code> command has an <code>-n</code> flag, and on others, the <code>more</code> (or <code>less</code>, or <code>pg</code>) pager has a flag for specifying that each line of output should be numbered. But on some Unix flavors, none of these methods will work, in which case the simple script in <a href="ch04.xhtml#ch4ex1">Listing 4-1</a> can do the job.</p>&#13;
<h4 class="h4" id="ch04lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # numberlines--A simple alternative to cat -n, etc.&#13;
&#13;
   for filename in "$@"&#13;
   do&#13;
     linecount="1"&#13;
<span class="ent">➊</span>   while IFS="\n" read line&#13;
     do&#13;
       echo "${linecount}: $line"&#13;
<span class="ent">➋</span>     linecount="$(( $linecount + 1 ))"&#13;
<span class="ent">➌</span>   done &lt; $filename&#13;
   done&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch4ex1"/><em>Listing 4-1: The</em> <code><em>numberlines</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s a trick to the main loop in this program: it looks like a regular <code>while</code> loop, but the important part is actually <code>done &lt; $filename</code> <span class="ent">➌</span>. It turns out that every major block construct acts as its own virtual subshell, so this file redirection is not only valid but also an easy way to have a loop that iterates line by line with the content of <code>$filename</code>. Couple that with the <code>read</code> statement at <span class="ent">➊</span>—an inner loop that loads each line, iteration by iteration, into the <code>line</code> variable—and it’s then easy to output the line with its line number as a preface and increment the <code>linecount</code> variable <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec03"><span epub:type="pagebreak" id="page_99"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">You can feed as many filenames as you want into this script. You can’t feed it input via a pipe, though that wouldn’t be too hard to fix by invoking a <code>cat -</code> sequence if no starting parameters are given.</p>&#13;
<h4 class="h4" id="ch04lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch04.xhtml#ch4ex2">Listing 4-2</a> shows a file displayed with line numbers using the <code>numberlines</code> script.</p>&#13;
<pre class="programs">$ <span class="codestrong">numberlines alice.txt</span>&#13;
1: Alice was beginning to get very tired of sitting by her sister on the&#13;
2: bank, and of having nothing to do: once or twice she had peeped into the&#13;
3: book her sister was reading, but it had no pictures or conversations in&#13;
4: it, 'and what is the use of a book,' thought Alice 'without pictures or&#13;
5: conversations?'&#13;
6:&#13;
7: So she was considering in her own mind (as well as she could, for the&#13;
8: hot day made her feel very sleepy and stupid), whether the pleasure&#13;
9: of making a daisy-chain would be worth the trouble of getting up and&#13;
10: picking the daisies, when suddenly a White Rabbit with pink eyes ran&#13;
11: close by her.</pre>&#13;
<p class="listcap"><a id="ch4ex2"/><em>Listing 4-2: Testing the</em> <code><em>numberlines</em></code> <em>script on an excerpt from</em> Alice in Wonderland</p>&#13;
<h4 class="h4" id="ch04lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Once you have a file with numbered lines, you can reverse the order of all the lines in the file, like this:</p>&#13;
<pre class="programs">cat -n filename | sort -rn | cut -c8-</pre>&#13;
<p class="indent">This does the trick on systems supporting the <code>-n</code> flag to <code>cat</code>, for example. Where might this be useful? One obvious situation is when displaying a log file in newest-to-oldest order.</p>&#13;
<h3 class="h3" id="ch04lev1sec02"><strong>#28 Wrapping Only Long Lines</strong></h3>&#13;
<p class="noindenta">One limitation of the <code>fmt</code> command and its shell script equivalent, <a href="ch02.xhtml#ch02lev1sec01">Script #14</a> on <a href="ch02.xhtml#page_53">page 53</a>, is that they wrap and fill every line they encounter, whether or not it makes sense to do so. This can mess up email (wrapping your <code>.signature</code> is not good, for example) and any input file format where line breaks matter.</p>&#13;
<p class="indent">What if you have a document in which you want to wrap just the long lines but leave everything else intact? With the default set of commands available to a Unix user, there’s only one way to accomplish this: explicitly step through each line in an editor, feeding the long ones to <code>fmt</code> individually. (You could accomplish this in <code>vi</code> by moving the cursor onto the line in question and using <code>!$fmt</code>.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>The script in <a href="ch04.xhtml#ch4ex3">Listing 4-3</a> automates that task, making use of the shell <code>${#<em>varname</em>}</code> construct, which returns the length of the contents of the data stored in the variable <code><em>varname</em></code>.</p>&#13;
<h4 class="h4" id="ch04lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # toolong--Feeds the fmt command only those lines in the input stream&#13;
   #   that are longer than the specified length&#13;
&#13;
   width=72&#13;
&#13;
   if [ ! -r "$1" ] ; then&#13;
     echo "Cannot read file $1" &gt;&amp;2&#13;
     echo "Usage: $0 filename" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➊</span> while read input&#13;
   do&#13;
     if [ ${#input} -gt $width ] ; then&#13;
       echo "$input" | fmt&#13;
     else&#13;
       echo "$input"&#13;
     fi&#13;
<span class="ent">➋</span> done &lt; $1&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch4ex3"/><em>Listing 4-3: The</em> <code><em>toolong</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Notice that the file is fed to the <code>while</code> loop with a simple <code>&lt; $1</code> associated with the end of the loop <span class="ent">➋</span> and that each line can then be analyzed by reading it with <code>read input</code> <span class="ent">➊</span>, which assigns each line of the file to the <code>input</code> variable, line by line.</p>&#13;
<p class="indent">If your shell doesn’t have the <code>${#<em>var</em>}</code> notation, you can emulate its behavior with the super useful “word count” command <code>wc</code>:</p>&#13;
<pre class="programs">varlength="$(echo "$var" | wc -c)"</pre>&#13;
<p class="indent">However, <code>wc</code> has an annoying habit of prefacing its output with spaces to get values to align nicely in the output listing. To sidestep that pesky problem, a slight modification is necessary to let only digits through the final pipe step, as shown here:</p>&#13;
<pre class="programs">varlength="$(echo "$var" | wc -c | sed 's/[^[:digit:]]//g')"</pre>&#13;
<h4 class="h4" id="ch04lev2sec08"><span epub:type="pagebreak" id="page_101"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script accepts exactly one filename as input, as <a href="ch04.xhtml#ch4ex4">Listing 4-4</a> shows.</p>&#13;
<h4 class="h4" id="ch04lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">toolong ragged.txt</span>&#13;
So she sat on, with closed eyes, and half believed herself in&#13;
Wonderland, though she knew she had but to open them again, and&#13;
all would change to dull reality--the grass would be only rustling&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling teacups would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the&#13;
sneeze&#13;
of the baby, the shriek of the Gryphon, and all the other queer&#13;
noises, would change (she knew) to the confused clamour of the busy&#13;
farm-yard--while the lowing of the cattle in the distance would&#13;
take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch4ex4"/><em>Listing 4-4: Testing the</em> <code><em>toolong</em></code> <em>script</em></p>&#13;
<p class="indent">Notice that unlike a standard invocation of <code>fmt</code>, <code>toolong</code> has retained line breaks where possible, so the word <em>sneeze</em>, which is on a line by itself in the input file, is also on a line by itself in the output.</p>&#13;
<h3 class="h3" id="ch04lev1sec03"><strong>#29 Displaying a File with Additional Information</strong></h3>&#13;
<p class="noindenta">Many of the most common Unix and Linux commands were originally designed for slow, barely interactive output environments (we did talk about Unix being an ancient OS, right?) and therefore offer minimal output and interactivity. An example is <code>cat</code>: when used to view a short file, it doesn’t give much helpful output. It would be nice to have more information about the file, though, so let’s get it! <a href="ch04.xhtml#ch4ex5">Listing 4-5</a> details the <code>showfile</code> command, an alternative to <code>cat</code>.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # showfile--Shows the contents of a file, including additional useful info&#13;
&#13;
   width=72&#13;
&#13;
   for input&#13;
   do&#13;
     lines="$(wc -l &lt; $input | sed 's/ //g')"&#13;
     chars="$(wc -c &lt; $input | sed 's/ //g')"&#13;
     owner="$(ls -ld $input | awk '{print $3}')"&#13;
     echo "-----------------------------------------------------------------"&#13;
     echo "File $input ($lines lines, $chars characters, owned by $owner):"&#13;
     echo "-----------------------------------------------------------------"&#13;
     while read line&#13;
     do&#13;
       if [ ${#line} -gt $width ] ; then&#13;
         echo "$line" | fmt | sed -e '1s/^/ /' -e '2,$s/^/+ /'&#13;
       else&#13;
         echo "  $line"&#13;
       fi&#13;
<span class="ent">➊</span>   done &lt; $input&#13;
&#13;
     echo "-----------------------------------------------------------------"&#13;
&#13;
<span class="ent">➋</span> done | ${PAGER:more}&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_102"/><a id="ch4ex5"/><em>Listing 4-5: The</em> <code><em>showfile</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec11"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To simultaneously read the input line by line and add head and foot information, this script uses a handy shell trick: near the end of the script, it redirects the input to the <code>while</code> loop with the snippet <code>done &lt; $input</code> <span class="ent">➊</span>. Perhaps the most complex element in this script, however, is the invocation of <code>sed</code> for lines longer than the specified length:</p>&#13;
<pre class="programs">echo "$line" | fmt | sed -e '1s/^/ /' -e '2,$s/^/+ /'</pre>&#13;
<p class="indent">Lines greater than the maximum allowable length are wrapped with <code>fmt</code> (or its shell script replacement, <a href="ch02.xhtml#ch02lev1sec01">Script #14</a> on <a href="ch02.xhtml#page_53">page 53</a>). To visually denote which lines are continuations and which are retained intact from the original file, the first output line of the excessively long line has the usual two-space indent, but subsequent lines are prefixed with a plus sign and a single space instead. Finally, piping the output into <code>${PAGER:more}</code> displays the file with the pagination program set with the system variable <code>$PAGER</code> or, if that’s not set, the <code>more</code> program <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec12"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">You can run <code>showfile</code> by specifying one or more filenames when the program is invoked, as <a href="ch04.xhtml#ch4ex6">Listing 4-6</a> shows.</p>&#13;
<h4 class="h4" id="ch04lev2sec13"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">showfile ragged.txt</span>&#13;
-----------------------------------------------------------------&#13;
File ragged.txt (7 lines, 639 characters, owned by taylor):&#13;
-----------------------------------------------------------------&#13;
  So she sat on, with closed eyes, and half believed herself in&#13;
  Wonderland, though she knew she had but to open them again, and&#13;
  all would change to dull reality--the grass would be only rustling&#13;
+ in the wind, and the pool rippling to the waving of the reeds--the&#13;
  rattling teacups would change to tinkling sheep-bells, and the&#13;
  Queen's shrill cries to the voice of the shepherd boy--and the&#13;
  sneeze&#13;
  of the baby, the shriek of the Gryphon, and all the other queer&#13;
+ noises, would change (she knew) to the confused clamour of the busy&#13;
+ farm-yard--while the lowing of the cattle in the distance would&#13;
+ take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_103"/><a id="ch4ex6"/><em>Listing 4-6: Testing the</em> <code><em>showfile</em></code> <em>script</em></p>&#13;
<h3 class="h3" id="ch04lev1sec04"><strong>#30 Emulating GNU-Style Flags with quota</strong></h3>&#13;
<p class="noindenta">The inconsistency across the command flags of various Unix and Linux systems is a perpetual problem that causes lots of grief for users who switch between any of the major releases, particularly between a commercial Unix system (SunOS/Solaris, HP-UX, and so on) and an open source Linux system. One command that demonstrates this problem is <code>quota</code>, which supports full-word flags on some Unix systems but accepts only one-letter flags on others.</p>&#13;
<p class="indent">A succinct shell script (shown in <a href="ch04.xhtml#ch4ex7">Listing 4-7</a>) solves the problem by mapping any full-word flags specified to the equivalent single-letter alternatives.</p>&#13;
<h4 class="h4" id="ch04lev2sec14"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # newquota--A frontend to quota that works with full-word flags a la GNU&#13;
&#13;
   # quota has three possible flags, -g, -v, and -q, but this script&#13;
   #   allows them to be '--group', '--verbose', and '--quiet' too.&#13;
&#13;
   flags=""&#13;
   realquota="$(which quota)"&#13;
&#13;
   while [ $# -gt 0 ]&#13;
   do&#13;
     case $1&#13;
     in&#13;
       --help)      echo "Usage: $0 [--group --verbose --quiet -gvq]" &gt;&amp;2&#13;
                          exit 1 ;;&#13;
       --group)     flags="$flags -g";   shift ;;&#13;
       --verbose)   flags="$flags -v";   shift ;;&#13;
       --quiet)     flags="$flags -q";   shift ;;&#13;
       --)          shift;               break ;;&#13;
       *)           break;          # Done with 'while' loop!&#13;
     esac&#13;
&#13;
   done&#13;
&#13;
<span class="ent">➊</span> exec $realquota $flags "$@"</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_104"/><a id="ch4ex7"/><em>Listing 4-7: The</em> <code><em>newquota</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec15"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script really boils down to a <code>while</code> statement that steps through every argument specified to the script, identifying any of the matching full-word flags and adding the associated one-letter flag to the <code>flags</code> variable. When done, it simply invokes the original quota program <span class="ent">➊</span> and adds the user-specified flags as needed.</p>&#13;
<h4 class="h4" id="ch04lev2sec16"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">There are a couple of ways to integrate a wrapper of this nature into your system. The most obvious is to rename this script <code>quota</code>, then place this script in a local directory (say, <em>/usr/local/bin</em>), and ensure that users have a default <code>PATH</code> that looks in this directory before looking in the standard Linux binary distro directories (<em>/bin</em> and <em>/usr/bin</em>). Another way is to add system-wide aliases so that a user entering <code>quota</code> actually invokes the <code>newquota</code> script. (Some Linux distros ship with utilities for managing system aliases, such as Debian’s <code>alternatives</code> system.) This last strategy could be risky, however, if users call <code>quota</code> with the new flags in their own shell scripts: if those scripts don’t use the user’s interactive login shell, they might not see the specified alias and will end up calling the base <code>quota</code> command rather than <code>newquota</code>.</p>&#13;
<h4 class="h4" id="ch04lev2sec17"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta"><a href="ch04.xhtml#ch4ex8">Listing 4-8</a> details running <code>newquota</code> with the <code>--verbose</code> and <code>--quiet</code> arguments.</p>&#13;
<pre class="programs">$ <span class="codestrong">newquota --verbose</span>&#13;
Disk quotas for user dtint (uid 24810):&#13;
     Filesystem   usage   quota   limit   grace   files   quota   limit   grace&#13;
           /usr  338262  614400  675840           10703  120000  126000&#13;
$ <span class="codestrong">newquota --quiet</span></pre>&#13;
<p class="listcap"><a id="ch4ex8"/><em>Listing 4-8: Testing the</em> <code><em>newquota</em></code> <em>script</em></p>&#13;
<p class="indent">The <code>--quiet</code> mode emits output only if the user is over quota. You can see that this is working correctly from the last result, where we’re not over quota. Phew!</p>&#13;
<h3 class="h3" id="ch04lev1sec05"><strong>#31 Making sftp Look More Like ftp</strong></h3>&#13;
<p class="noindenta">The secure version of the File Transfer Protocol <code>ftp</code> program is included as part of <code>ssh</code>, the Secure Shell package, but its interface can be a bit confusing for users who are making the switch from the crusty old <code>ftp</code> client. The basic problem is that <code>ftp</code> is invoked as <code>ftp remotehost</code> and it then prompts <span epub:type="pagebreak" id="page_105"/>for account and password information. By contrast, <code>sftp</code> wants to know the account and remote host on the command line and won’t work properly (or as expected) if only the host is specified.</p>&#13;
<p class="indent">To address this, the simple wrapper script detailed in <a href="ch04.xhtml#ch4ex9">Listing 4-9</a> allows users to invoke <code>mysftp</code> exactly as they would have invoked the <code>ftp</code> program and be prompted for the necessary fields.</p>&#13;
<h4 class="h4" id="ch04lev2sec18"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # mysftp--Makes sftp start up more like ftp&#13;
&#13;
   /bin/echo -n "User account: "&#13;
   read account&#13;
&#13;
   if [ -z $account ] ; then&#13;
     exit 0;       # Changed their mind, presumably&#13;
   fi&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     /bin/echo -n "Remote host: "&#13;
     read host&#13;
     if [ -z $host ] ; then&#13;
       exit 0&#13;
     fi&#13;
   else&#13;
     host=$1&#13;
   fi&#13;
&#13;
   # End by switching to sftp. The -C flag enables compression here.&#13;
&#13;
<span class="ent">➊</span> exec sftp -C $account@$host</pre>&#13;
<p class="listcap"><a id="ch4ex9"/><em>Listing 4-9: The</em> <code><em>mysftp</em></code> <em>script, a friendlier version of</em> <code><em>sftp</em></code></p>&#13;
<h4 class="h4" id="ch04lev2sec19"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s a trick in this script worth mentioning. It’s actually something we’ve done in previous scripts, though we haven’t highlighted it for you before: the last line is an <code>exec</code> call <span class="ent">➊</span>. What this does is <em>replace</em> the currently running shell with the application specified. Because you know there’s nothing left to do after calling the <code>sftp</code> command, this method of ending our script is much more resource efficient than having the shell hanging around waiting for <code>sftp</code> to finish using a separate subshell, which is what would happen if we just invoked <code>sftp</code> instead.</p>&#13;
<h4 class="h4" id="ch04lev2sec20"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">As with the <code>ftp</code> client, if users omit the remote host, the script continues by prompting for a remote host. If the script is invoked as <code>mysftp remotehost</code>, the <code>remotehost</code> provided is used instead.</p>&#13;
<h4 class="h4" id="ch04lev2sec21"><span epub:type="pagebreak" id="page_106"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Let’s see what happens when you invoke this script without any arguments versus invoking <code>sftp</code> without any arguments. <a href="ch04.xhtml#ch4ex10">Listing 4-10</a> shows running <code>sftp</code>.</p>&#13;
<pre class="programs">$ <span class="codestrong">sftp</span>&#13;
usage: sftp [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]&#13;
          [-D sftp_server_path] [-F ssh_config] [-i identity_file] [-l limit]&#13;
          [-o ssh_option] [-P port] [-R num_requests] [-S program]&#13;
          [-s subsystem | sftp_server] host&#13;
       sftp [user@]host[:file ...]&#13;
       sftp [user@]host[:dir[/]]&#13;
       sftp -b batchfile [user@]host</pre>&#13;
<p class="listcap"><a id="ch4ex10"/><em>Listing 4-10: Running the</em> <code><em>sftp</em></code> <em>utility with no arguments yields very cryptic help output.</em></p>&#13;
<p class="indent">That’s useful but confusing. By contrast, with the <code>mysftp</code> script you can proceed to make an actual connection, as <a href="ch04.xhtml#ch4ex11">Listing 4-11</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">mysftp</span>&#13;
User account: <span class="codestrong">taylor</span>&#13;
Remote host: <span class="codestrong">intuitive.com</span>&#13;
Connecting to intuitive.com...&#13;
taylor@intuitive.com's password:&#13;
sftp&gt; <span class="codestrong">quit</span></pre>&#13;
<p class="listcap"><a id="ch4ex11"/><em>Listing 4-11: Running the</em> <code><em>mysftp</em></code> <em>script with no arguments is much clearer.</em></p>&#13;
<p class="indent">Invoke the script as if it were an <code>ftp</code> session by supplying the remote host, and it’ll prompt for the remote account name (detailed in <a href="ch04.xhtml#ch4ex12">Listing 4-12</a>) and then invisibly invoke <code>sftp</code>.</p>&#13;
<pre class="programs">$ <span class="codestrong">mysftp intuitive.com</span>&#13;
User account: <span class="codestrong">taylor</span>&#13;
Connecting to intuitive.com...&#13;
taylor@intuitive.com's password:&#13;
sftp&gt; <span class="codestrong">quit</span></pre>&#13;
<p class="listcap"><a id="ch4ex12"/><em>Listing 4-12: Running the</em> <code><em>mysftp</em></code> <em>script with a single argument: the host to connect to</em></p>&#13;
<h4 class="h4" id="ch04lev2sec22"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One thing to always think about when you have a script like this is whether it can be the basis of an automated backup or sync tool, and <code>mysftp</code> is a perfect candidate. So a great hack would be to designate a directory on your system, for example, then write a wrapper that would create a ZIP archive of key files, and use <code>mysftp</code> to copy them up to a server or cloud storage system. In fact, we’ll do just that later in the book with <a href="ch09.xhtml#ch09lev1sec04">Script #72</a> on <a href="ch09.xhtml#page_229">page 229</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec06"><span epub:type="pagebreak" id="page_107"/><strong>#32 Fixing grep</strong></h3>&#13;
<p class="noindenta">Some versions of <code>grep</code> offer a remarkable range of capabilities, including the particularly useful ability to show the context (a line or two above and below) of a matching line in the file. Additionally, some versions of <code>grep</code> can highlight the region in the line (for simple patterns, at least) that matches the specified pattern. You might already have such a version of <code>grep</code>. Then again, you might not.</p>&#13;
<p class="indent">Fortunately, both of these features can be emulated with a shell script, so you can still use them even if you’re on an older commercial Unix system with a relatively primitive <code>grep</code> command. To specify the number of lines of context both above and below the line matching the pattern that you specified, use <code>-c <em>value</em></code>, followed by the pattern to match. This script (shown in <a href="ch04.xhtml#ch4ex13">Listing 4-13</a>) also borrows from the ANSI color script, <a href="ch01.xhtml#ch01lev1sec12">Script #11</a> on <a href="ch01.xhtml#page_40">page 40</a>, to do region highlighting.</p>&#13;
<h4 class="h4" id="ch04lev2sec23"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # cgrep--grep with context display and highlighted pattern matches&#13;
&#13;
   context=0&#13;
   esc="^["&#13;
   boldon="${esc}[1m" boldoff="${esc}[22m"&#13;
   sedscript="/tmp/cgrep.sed.$$"&#13;
   tempout="/tmp/cgrep.$$"&#13;
&#13;
   function showMatches&#13;
   {&#13;
     matches=0&#13;
&#13;
<span class="ent">➊</span>   echo "s/$pattern/${boldon}$pattern${boldoff}/g" &gt; $sedscript&#13;
&#13;
<span class="ent">➋</span>   for lineno in $(grep -n "$pattern" $1 | cut -d: -f1)&#13;
     do&#13;
       if [ $context -gt 0 ] ; then&#13;
<span class="ent">➌</span>       prev="$(( $lineno - $context ))"&#13;
&#13;
         if [ $prev -lt 1 ] ; then&#13;
           # This results in "invalid usage of line address 0."&#13;
           prev="1"&#13;
         fi&#13;
<span class="ent">➍</span>       next="$(( $lineno + $context ))"&#13;
&#13;
         if [ $matches -gt 0 ] ; then&#13;
           echo "${prev}i\\" &gt;&gt; $sedscript&#13;
           echo "----" &gt;&gt; $sedscript&#13;
         fi&#13;
         echo "${prev},${next}p" &gt;&gt; $sedscript&#13;
       else&#13;
         echo "${lineno}p" &gt;&gt; $sedscript&#13;
       fi&#13;
       matches="$(( $matches + 1 ))"&#13;
     done&#13;
&#13;
     if [ $matches -gt 0 ] ; then&#13;
       sed -n -f $sedscript $1 | uniq | more&#13;
     fi&#13;
   }&#13;
&#13;
<span class="ent">➎</span> trap "$(which rm) -f $tempout $sedscript" EXIT&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     echo "Usage: $0 [-c X] pattern {filename}" &gt;&amp;2&#13;
     exit 0&#13;
   fi&#13;
&#13;
   if [ "$1" = "-c" ] ; then&#13;
     context="$2"&#13;
     shift; shift&#13;
   elif [ "$(echo $1|cut -c1-2)" = "-c" ] ; then&#13;
     context="$(echo $1 | cut -c3-)"&#13;
     shift&#13;
   fi&#13;
&#13;
   pattern="$1"; shift&#13;
&#13;
   if [ $# -gt 0 ] ; then&#13;
     for filename ; do&#13;
       echo "----- $filename -----"&#13;
       showMatches $filename&#13;
     done&#13;
   else&#13;
     cat - &gt; $tempout      # Save stream to a temp file.&#13;
     showMatches $tempout&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_108"/><a id="ch4ex13"/><em>Listing 4-13: The</em> <code><em>cgrep</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec24"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script uses <code>grep -n</code> to get the line numbers of all matching lines in the file <span class="ent">➋</span> and then, using the specified number of lines of context to include, identifies a starting <span class="ent">➌</span> and ending <span class="ent">➍</span> line for displaying each match. These are written out to the temporary <code>sed</code> script defined at <span class="ent">➊</span>, which executes a word substitution command that wraps the specified pattern in bold-on and bold-off ANSI sequences. That’s 90 percent of the script, in a nutshell.</p>&#13;
<p class="indent">The other thing worth mentioning in this script is the useful <code>trap</code> command <span class="ent">➎</span>, which lets you tie events into the shell’s script execution <span epub:type="pagebreak" id="page_109"/>system itself. The first argument is the command or sequence of commands you want invoked, and all subsequent arguments are the specific signals (events). In this case, we’re telling the shell that when the script exits, invoke <code>rm</code> to remove the two temp files.</p>&#13;
<p class="indent">What’s particularly nice about working with <code>trap</code> is that it works regardless of where you exit the script, not just at the very bottom. In subsequent scripts, you’ll see that <code>trap</code> can be tied to a wide variety of signals, not just <code>SIGEXIT</code> (or <code>EXIT</code>, or the numeric equivalent of <code>SIGEXIT</code>, which is <code>0</code>). In fact, you can have different <code>trap</code> commands associated with different signals, so you might output a “cleaned-up temp files” message if someone sends a <code>SIGQUIT</code> (<small>CTRL</small>-C) to a script, while that wouldn’t be displayed on a regular (<code>SIGEXIT</code>) event.</p>&#13;
<h4 class="h4" id="ch04lev2sec25"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script works either with an input stream, in which case it saves the input to a temp file and then processes the temp file as if its name had been specified on the command line, or with a list of one or more files on the command line. <a href="ch04.xhtml#ch4ex14">Listing 4-14</a> shows passing a single file via the command line.</p>&#13;
<h4 class="h4" id="ch04lev2sec26"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">cgrep -c 1 teacup ragged.txt</span>&#13;
----- ragged.txt -----&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling <span class="codestrong">teacups</span> would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the</pre>&#13;
<p class="listcap"><a id="ch4ex14"/><em>Listing 4-14: Testing the</em> <code><em>cgrep</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec27"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A useful refinement to this script would return line numbers along with the matched lines.</p>&#13;
<h3 class="h3" id="ch04lev1sec07"><strong>#33 Working with Compressed Files</strong></h3>&#13;
<p class="noindenta">Throughout the years of Unix development, few programs have been reconsidered and redeveloped more times than <code>compress</code>. On most Linux systems, three significantly different compression programs are available: <code>compress</code>, <code>gzip</code>, and <code>bzip2</code>. Each uses a different suffix (<em>.z</em>, <em>.gz</em>, and <em>.bz2</em>, respectively), and the degree of compression can vary among the three programs, depending on the layout of data within a file.</p>&#13;
<p class="indent">Regardless of the level of compression, and regardless of which compression programs you have installed, working with compressed files on many Unix systems requires decompressing them by hand, accomplishing the desired tasks, and recompressing them when finished. Tedious, and thus a <span epub:type="pagebreak" id="page_110"/>perfect job for a shell script! The script detailed in <a href="ch04.xhtml#ch4ex15">Listing 4-15</a> acts as a convenient compression/decompression wrapper for three functions you’ll often find yourself wanting to use on compressed files: <code>cat</code>, <code>more</code>, and <code>grep</code>.</p>&#13;
<h4 class="h4" id="ch04lev2sec28"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # zcat, zmore, and zgrep--This script should be either symbolically&#13;
   #   linked or hard linked to all three names. It allows users to work with&#13;
   #   compressed files transparently.&#13;
&#13;
    Z="compress";  unZ="uncompress"  ;  Zlist=""&#13;
   gz="gzip"    ; ungz="gunzip"      ; gzlist=""&#13;
   bz="bzip2"   ; unbz="bunzip2"     ; bzlist=""&#13;
&#13;
   # First step is to try to isolate the filenames in the command line.&#13;
   #   We'll do this lazily by stepping through each argument, testing to&#13;
   #   see whether it's a filename. If it is and it has a compression&#13;
   #   suffix, we'll decompress the file, rewrite the filename, and proceed.&#13;
   #   When done, we'll recompress everything that was decompressed.&#13;
&#13;
   for arg&#13;
   do&#13;
     if [ -f "$arg" ] ; then&#13;
       case "$arg" in&#13;
          *.Z) $unZ "$arg"&#13;
               arg="$(echo $arg | sed 's/\.Z$//')"&#13;
               Zlist="$Zlist \"$arg\""&#13;
               ;;&#13;
&#13;
         *.gz) $ungz "$arg"&#13;
               arg="$(echo $arg | sed 's/\.gz$//')"&#13;
               gzlist="$gzlist \"$arg\""&#13;
               ;;&#13;
&#13;
        *.bz2) $unbz "$arg"&#13;
               arg="$(echo $arg | sed 's/\.bz2$//')"&#13;
               bzlist="$bzlist \"$arg\""&#13;
               ;;&#13;
       esac&#13;
     fi&#13;
     newargs="${newargs:-""} \"$arg\""&#13;
   done&#13;
&#13;
   case $0 in&#13;
      *zcat* ) eval cat $newargs                   ;;&#13;
     *zmore* ) eval more $newargs                  ;;&#13;
     *zgrep* ) eval grep $newargs                  ;;&#13;
           * ) echo "$0: unknown base name. Can't proceed." &gt;&amp;2&#13;
               exit 1&#13;
   esac&#13;
&#13;
   # Now recompress everything.&#13;
&#13;
   if [ ! -z "$Zlist"  ] ; then&#13;
<span class="ent">➊</span>   eval $Z $Zlist&#13;
   fi&#13;
   if [ ! -z "$gzlist"] ; then&#13;
<span class="ent">➋</span>   eval $gz $gzlist&#13;
   fi&#13;
   if [ ! -z "$bzlist" ] ; then&#13;
<span class="ent">➌</span>   eval $bz $bzlist&#13;
   fi&#13;
&#13;
   # And done!&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_111"/><a id="ch4ex15"/><em>Listing 4-15: The</em> <code><em>zcat</em></code><em>/</em><code><em>zmore</em></code><em>/</em><code><em>zgrep</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec29"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">For any given suffix, three steps are necessary: decompress the file, rename the filename to remove the suffix, and add it to the list of files to recompress at the end of the script. By keeping three separate lists, one for each compression program, this script also lets you easily <code>grep</code> across files compressed using different compression utilities.</p>&#13;
<p class="indent">The most important trick is the use of the <code>eval</code> directive when recom-pressing the files <span class="ent">➊</span><span class="ent">➋</span><span class="ent">➌</span>. This is necessary to ensure that filenames with spaces are treated properly. When the <code>Zlist</code>, <code>gzlist,</code> and <code>bzlist</code> variables are instantiated, each argument is surrounded by quotes, so a typical value might be <code>""sample.c" "test.pl" "penny.jar""</code>. Because the list has nested quotes, invoking a command like <code>cat $Zlist</code> results in <code>cat</code> complaining that file <code>"sample.c"</code> wasn’t found. To force the shell to act as if the command were typed at a command line (where the quotes are stripped once they have been utilized for <code>arg</code> parsing), use <code>eval</code>, and all will work as desired.</p>&#13;
<h4 class="h4" id="ch04lev2sec30"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To work properly, this script should have three names. How do you do that in Linux? Simple: links. You can use either symbolic links, which are special files that store the names of link destinations, or hard links, which are actually assigned the same inode as the linked file. We prefer symbolic links. These can easily be created (here the script is already called <code>zcat</code>), as <a href="ch04.xhtml#ch4ex16">Listing 4-16</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">ln -s zcat zmore</span>&#13;
$ <span class="codestrong">ln -s zcat zgrep</span></pre>&#13;
<p class="listcap"><a id="ch4ex16"/><em>Listing 4-16: Symbolically linking the</em> <code><em>zcat</em></code> <em>script to the</em> <code><em>zmore</em></code> <em>and</em> <code><em>zgrep</em></code> <em>commands</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>Once that’s done, you have three new commands that have the same actual (shared) contents, and each accepts a list of files to process as needed, decompressing and then recompressing them when done.</p>&#13;
<h4 class="h4" id="ch04lev2sec31"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The ubiquitous <code>compress</code> utility quickly shrinks down <em>ragged.txt</em> and gives it a <em>.z</em> suffix:</p>&#13;
<pre class="programs">$ <span class="codestrong">compress ragged.txt</span></pre>&#13;
<p class="indent">With <em>ragged.txt</em> in its compressed state, we can view the file with <code>zcat</code>, as <a href="ch04.xhtml#ch4ex17">Listing 4-17</a> details.</p>&#13;
<pre class="programs">$ <span class="codestrong">zcat ragged.txt.Z</span>&#13;
So she sat on, with closed eyes, and half believed herself in&#13;
Wonderland, though she knew she had but to open them again, and&#13;
all would change to dull reality--the grass would be only rustling&#13;
in the wind, and the pool rippling to the waving of the reeds--the&#13;
rattling teacups would change to tinkling sheep-bells, and the&#13;
Queen's shrill cries to the voice of the shepherd boy--and the&#13;
sneeze of the baby, the shriek of the Gryphon, and all the other&#13;
queer noises, would change (she knew) to the confused clamour of&#13;
the busy farm-yard--while the lowing of the cattle in the distance&#13;
would take the place of the Mock Turtle's heavy sobs.</pre>&#13;
<p class="listcap"><a id="ch4ex17"/><em>Listing 4-17: Using</em> <code><em>zcat</em></code> <em>to print the compressed text file</em></p>&#13;
<p class="indent">And then search for <em>teacup</em> again.</p>&#13;
<pre class="programs">$ <span class="codestrong">zgrep teacup ragged.txt.Z</span>&#13;
rattling teacups would change to tinkling sheep-bells, and the</pre>&#13;
<p class="indent">All the while, the file starts and ends in its original compressed state, shown in <a href="ch04.xhtml#ch4ex18">Listing 4-18</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l ragged.txt*</span>&#13;
-rw-r--r-- 1 taylor staff 443 Jul 7 16:07 ragged.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex18"/><em>Listing 4-18: The results of</em> <code><em>ls</em></code><em>, showing only that the compressed file exists</em></p>&#13;
<h4 class="h4" id="ch04lev2sec32"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Probably the biggest weakness of this script is that if it is canceled in midstream, the file isn’t guaranteed to recompress. A nice addition would be to fix this with a smart use of the <code>trap</code> capability and a recompress function that does error checking.</p>&#13;
<h3 class="h3" id="ch04lev1sec08"><span epub:type="pagebreak" id="page_113"/><strong>#34 Ensuring Maximally Compressed Files</strong></h3>&#13;
<p class="noindenta">As highlighted in <a href="ch04.xhtml#ch04lev1sec07">Script #33</a> on <a href="ch04.xhtml#page_109">page 109</a>, most Linux implementations include more than one compression method, but the onus is on the user to figure out which one does the best job of compressing a given file. As a result, users typically learn how to work with just one compression program without realizing that they could attain better results with a different one. Even more confusing is the fact that some files compress better with one algorithm than with another, and there’s no way to know which is better without experimentation.</p>&#13;
<p class="indent">The logical solution is to have a script that compresses files using each of the tools and then selects the smallest resultant file as the best. That’s exactly what <code>bestcompress</code> does, shown in <a href="ch04.xhtml#ch4ex19">Listing 4-19</a>!</p>&#13;
<h4 class="h4" id="ch04lev2sec33"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # bestcompress--Given a file, tries compressing it with all the available&#13;
   #   compression tools and keeps the compressed file that's smallest,&#13;
   #   reporting the result to the user. If -a isn't specified, bestcompress&#13;
   #   skips compressed files in the input stream.&#13;
&#13;
   Z="compress"     gz="gzip"     bz="bzip2"&#13;
   Zout="/tmp/bestcompress.$$.Z"&#13;
   gzout="/tmp/bestcompress.$$.gz"&#13;
   bzout="/tmp/bestcompress.$$.bz"&#13;
   skipcompressed=1&#13;
&#13;
   if [ "$1" = "-a" ] ; then&#13;
     skipcompressed=0 ; shift&#13;
   fi&#13;
&#13;
   if [ $# -eq 0 ]; then&#13;
     echo "Usage: $0 [-a] file or files to optimally compress" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   trap "/bin/rm -f $Zout $gzout $bzout" EXIT&#13;
&#13;
   for name in "$@"&#13;
   do&#13;
     if [ ! -f "$name" ] ; then&#13;
       echo "$0: file $name not found. Skipped." &gt;&amp;2&#13;
       continue&#13;
     fi&#13;
&#13;
     if [ "$(echo $name | egrep '(\.Z$|\.gz$|\.bz2$)')" != "" ] ; then&#13;
       if [ $skipcompressed -eq 1 ] ; then&#13;
         echo "Skipped file ${name}: It's already compressed."&#13;
         continue&#13;
       else&#13;
         echo "Warning: Trying to double-compress $name"&#13;
       fi&#13;
     fi&#13;
&#13;
   # Try compressing all three files in parallel.&#13;
<span class="ent">➊</span>   $Z  &lt; "$name" &gt; $Zout  &amp;&#13;
     $gz &lt; "$name" &gt; $gzout &amp;&#13;
     $bz &lt; "$name" &gt; $bzout &amp;&#13;
&#13;
     wait  # Wait until all compressions are done.&#13;
&#13;
   # Figure out which compressed best.&#13;
<span class="ent">➋</span>   smallest="$(ls -l "$name" $Zout $gzout $bzout | \&#13;
       awk '{print $5"="NR}' | sort -n | cut -d= -f2 | head -1)"&#13;
&#13;
     case "$smallest" in&#13;
<span class="ent">➌</span>     1 ) echo "No space savings by compressing $name. Left as is."&#13;
           ;;&#13;
       2 ) echo Best compression is with compress. File renamed ${name}.Z&#13;
           mv $Zout "${name}.Z" ; rm -f "$name"&#13;
           ;;&#13;
       3 ) echo Best compression is with gzip. File renamed ${name}.gz&#13;
           mv $gzout "${name}.gz" ; rm -f "$name"&#13;
           ;;&#13;
       4 ) echo Best compression is with bzip2. File renamed ${name}.bz2&#13;
           mv $bzout "${name}.bz2" ; rm -f "$name"&#13;
     esac&#13;
&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_114"/><a id="ch4ex19"/><em>Listing 4-19: The</em> <code><em>bestcompress</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch04lev2sec34"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The most interesting line in this script is at <span class="ent">➋</span>. This line has <code>ls</code> output the size of each file (the original and the three compressed files, in a known order), chops out just the file sizes with <code>awk</code>, sorts these numerically, and ends up with the line number of the smallest resultant file. If the compressed versions are all bigger than the original file, the result is <code>1</code>, and an appropriate message is printed out <span class="ent">➌</span>. Otherwise, <code>smallest</code> will indicate which of <code>compress</code>, <code>gzip</code>, or <code>bzip2</code> did the best job. Then it’s just a matter of moving the appropriate file into the current directory and removing the original file.</p>&#13;
<p class="indent">The three compression calls starting at <span class="ent">➊</span> are also worth pointing out. These calls are done in parallel by using the trailing <code>&amp;</code> to drop each of them into its own subshell, followed by the call to <code>wait</code>, which stops the script until all the calls are completed. On a uniprocessor, this might not offer much performance benefit, but with multiple processors, it should spread the task out and potentially complete quite a bit faster.</p>&#13;
<h4 class="h4" id="ch04lev2sec35"><span epub:type="pagebreak" id="page_115"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script should be invoked with a list of filenames to compress. If some of them are already compressed and you want to try compressing them further, use the <code>-a</code> flag; otherwise they’ll be skipped.</p>&#13;
<h4 class="h4" id="ch04lev2sec36"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The best way to demonstrate this script is with a file that needs to be compressed, as <a href="ch04.xhtml#ch4ex20">Listing 4-20</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l alice.txt</span>&#13;
-rw-r--r--  1 taylor  staff  154872 Dec  4  2002 alice.txt</pre>&#13;
<p class="listcap"><a id="ch4ex20"/><em>Listing 4-20: Showing the</em> <code><em>ls</em></code> <em>output of a copy of</em> Alice in Wonderland<em>. Note the file size of 154872 bytes.</em></p>&#13;
<p class="indent">The script hides the process of compressing the file with each of the three compression tools and instead simply displays the results, shown in <a href="ch04.xhtml#ch4ex21">Listing 4-21</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">bestcompress alice.txt</span>&#13;
Best compression is with compress. File renamed alice.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex21"/><em>Listing 4-21: Running the</em> <code><em>bestcompress</em></code> <em>script on</em> alice.txt</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4ex22">Listing 4-22</a> demonstrates that the file is now quite a bit smaller.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l alice.txt.Z</span>&#13;
-rw-r--r--  1 taylor  wheel  66287 Jul  7 17:31 alice.txt.Z</pre>&#13;
<p class="listcap"><a id="ch4ex22"/><em>Listing 4-22: Demonstrating the much-reduced file size of the compressed file (66287 bytes) compared to <a href="ch04.xhtml#ch4ex20">Listing 4-20</a></em><span epub:type="pagebreak" id="page_116"/></p>&#13;
</body></html>