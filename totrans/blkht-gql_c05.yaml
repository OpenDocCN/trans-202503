- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Denial of Service
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: DoS issues are one of the most prevalent vulnerability classes in GraphQL today.
    In this chapter, you’ll learn how GraphQL’s declarative query language can also
    become its Achilles’ heel. We’ll identify opportunities to carry out DoS attacks
    that could exhaust server resources if the application developers don’t implement
    effective security countermeasures.
  prefs: []
  type: TYPE_NORMAL
- en: While DoS vulnerabilities aren’t often classified as a critical vulnerability
    in penetration testing reports or bounty programs, they’re common enough in GraphQL
    applications that it’s important to become familiar with them, both from an attacker
    standpoint and as a defender.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL DoS Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of GraphQL’s flagship features is its declarative query language, which
    allows clients to request very complex data structures from the server. This capability
    puts the client in a powerful position, because the client can choose the response
    that a server should return. Given this power, GraphQL servers must have the ability
    to protect themselves against malicious queries coming from untrusted clients.
    If a client can construct a query that the server would find expensive to fulfill,
    it could starve the server for resources. Such attacks could impact the availability
    of the application by causing downtime or degrading the server’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GraphQL world, several DoS vectors could lead to resource exhaustion
    conditions: circular queries (also known as *recursive queries*), field duplication,
    alias overloading, directive overloading, circular fragments, and object limit
    overriding. In this chapter, you’ll learn about each vulnerability, how to test
    for them during a penetration test, and how to use DoS exploit code to abuse them.
    Toward the end of the chapter, we’ll discuss the security controls that attempt
    to mitigate some of these threats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Common Weakness Enumeration (CWE)* system categorizes these types of DoS
    vectors as *Uncontrolled Resource Consumption*. The abuse of these vectors might
    result in excessive consumption of central processing unit (CPU) cycles, significant
    server memory usage, or the filling up of the disk space, which could prevent
    other processes from writing to the filesystem. The following are a few examples
    of how a client could craft queries to trigger these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a single request containing one complex query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends a single request containing multiple complex queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends multiple parallel requests, each containing a single complex
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends multiple parallel requests, each containing multiple complex
    queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client requests a large number of objects from the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain DoS vectors are possible partially because of add-on features in some
    GraphQL implementations, introduced either as part of the base installation package
    or as additional libraries, while other vectors exist in native GraphQL capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also known as *recursive queries*, *circular queries* occur when two nodes in
    a GraphQL schema are bidirectionally referenced using an edge. This circular reference
    could allow a client to build a complex query that forces the server to return
    an exponentially large response each time the query completes a “circle.”
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll dive into circular relationships and what they look like
    in a GraphQL schema. We’ll use multiple tools, such as the schema visualizer GraphQL
    Voyager, Altair, InQL, and GraphQL Cop to identify risky design patterns and test
    our target application for these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Relationships in GraphQL Schemas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL’s SDL allows us to define multiple types to represent an application’s
    data model. These types can be interconnected in such a way that allows a client
    to “jump” from one type to another if they are linked together. This condition
    is called a *circular relationship* or a *circular reference*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in earlier chapters, we mentioned that the DVGA target application
    allows users to create code snippets (called *pastes*) and upload them to the
    application. A single paste might contain a title and some content (like code
    or other arbitrary text). In GraphQL’s SDL, this information can be represented
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This information is pretty limited as it stands. What if we want to extend our
    application so that when a client uploads a paste to the application, we can identify
    which client did so? For example, we could capture some metadata about the uploader,
    such as their IP address or User-Agent string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our data model isn’t structured in a way that allows us to represent
    this type of information in the API, but extending it is a fairly easy process.
    We could add additional fields to the `Paste` object in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to structure the SDL to accomplish this goal is to decouple the
    client metadata from the `Paste` object. We might want to do this for multiple
    reasons, such as for better separation of concerns and the ability to extend GraphQL
    types independently of one another. We could create a separate type, called `Owner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two object types, `Paste` and `Owner`. If we wanted to reveal the
    owner of a given paste, we could link the two types together. We might make a
    schema adjustment such as the following, to add a field named `owner` to the `Paste`
    type that references the `Owner` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now a client could request owner information about a paste, such as the owner’s
    IP address or User-Agent. [Listing 5-1](#listing5-1) shows the complete example
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: A circular reference in a schema'
  prefs: []
  type: TYPE_NORMAL
- en: The two object types, `Paste` and `Owner`, have fields that cross-reference
    the other. The `Paste` object type has an `owner` field that references the `Owner`
    object, and the `Owner` type has a `pastes` field that references the `Paste`
    type. This creates a circular condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A malicious client could cause a recursion by forcing the GraphQL server’s
    function resolver to loop. This could potentially impact the server’s performance.
    The following query example shows what such a circular query looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This query is simple to execute yet causes an exponentially large response from
    the GraphQL server. The more loops in the query, the larger the response becomes.
  prefs: []
  type: TYPE_NORMAL
- en: Circular relationships are common in GraphQL APIs. While not an anti-pattern
    when it comes to schema design, they should be avoided unless the application
    is able to gracefully handle complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: How to Identify Circular Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying circular queries typically requires insight into the GraphQL schema.
    In white-box penetration tests, we may have access to the SDL files. In black-box
    penetration tests, we may get lucky and find that the application’s developer
    has left introspection enabled.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, you should review the schema files for bidirectional relationships
    between objects using static code analysis approaches or by importing the result
    of the introspection query into a schema visualizer such as GraphQL Voyager. Additionally,
    certain dedicated GraphQL security tools, such as InQL, attempt to discover the
    existence of circular relationships in a more dynamic fashion, by discovering
    the schema and analyzing its types and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Using Schema Definition Language Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s perform a security review of an example SDL file to identify anomalies.
    Consider the schema file in the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/sdl.graphql).
    This SDL file is a schema representation of DVGA that defines all queries, mutations,
    and subscriptions, which also includes object types and fields.
  prefs: []
  type: TYPE_NORMAL
- en: Download the schema file onto your lab machine by copying it and saving it to
    a file named *sdl.graphql*. Then open the file in a text editor to review it.
    Before we highlight where the problems lie, try to spot any relational fields
    that result in bidirectional object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following excerpts show the objects that have bidirectional references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The schema defines the `owner` field in the `PasteObject` of custom type `OwnerObject`
    ❶. Then it defines the `paste` field of type `[PasteObject]` ❷. The square brackets
    in `[PasteObject]` indicate an array of objects of type `PasteObject`. As you
    can see, these objects cross-reference each other, and clients using these types
    could potentially abuse them for DoS purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL Voyager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Small SDL files are easy to review. The larger an SDL file is, the more challenging
    it becomes to identify anti-patterns and manually audit for security issues. Let’s
    visualize a schema, a technique that could assist us during audits of larger applications
    with more complex schema definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Upload the SDL file you downloaded earlier to GraphQL Voyager (hosted on [http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000)
    or, alternatively, [https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager))
    by clicking the **Change Schema** button and copying the SDL file into the box
    under the **SDL** tab. [Figure 5-1](#figure5-1) shows how Voyager illustrates
    the circular reference between the `PasteObject` and `OwnerObject` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Object relationships in GraphQL Voyager'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Voyager highlights custom object types, such as `OwnerObject` and `PasteObject`,
    and uses arrows to indicate object relationships. When you identify such a relationship,
    assume the application is vulnerable until you’ve performed a test to check its
    ability to protect against circular queries.
  prefs: []
  type: TYPE_NORMAL
- en: You can also paste the introspection response output in Voyager to generate
    the same visual representation of the schema, as we did in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using InQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to identify circular queries is with the InQL security auditing
    tool. We installed InQL in our lab in Chapter 2. One of InQL’s main features is
    its ability to automatically detect circular relationships. InQL can read JSON
    files generated by an introspection query via the command line. Alternatively,
    it can directly send an introspection query to the target GraphQL server if it
    supports Introspection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run an introspection query using Altair. We’ll save the response to a
    JSON file on our filesystem so InQL can read it, parse it, and traverse the schema
    to find circular relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In your lab machine, open Altair and set the URL in the address bar to ***http://localhost:5013/graphql***.
    Copy the introspection query located at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    and paste it into Altair ([Figure 5-2](#figure5-2)). Then click **Send Request**
    to send the query to DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: An introspection query in Altair'
  prefs: []
  type: TYPE_NORMAL
- en: Once a successful response is returned, download the response in JSON format
    by clicking the **Download** button at the bottom-right corner of Altair. Save
    the file as *introspection_query.json* under the home folder */home/kali*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the terminal. To execute the circular query check, we’ll pass three
    flags to InQL: the `-f` flag, to use the JSON file we downloaded; the `--generate-cycles`
    flag, to perform the circular query detection check; and the `-o` flag, to write
    the output to a dedicated folder. The following command combines these flags to
    perform the circular query detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the check is complete, you’ll notice that a *dvga_cycles* folder was
    created by InQL. Within this folder, look for a text file that starts with the
    word *cycles*; this file will contain the result of the script’s execution. You
    can run this command to see the outcome of the check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'InQL was able to find paths in the schema where a circular relationship exists
    between the `PasteObject` and `OwnerObject` nodes. Under the hood, InQL traversed
    the JSON file using two main graph algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Tarjan algorithm*, named after its inventor Robert Tarjan, is used to find
    circular relationships in graphs in which nodes are connected by edges and each
    edge has a direction associated with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Johnson algorithm*, named after its inventor Donald B. Johnson, is used
    to find the shortest path between every pair of nodes in a graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'InQL can also run the same check by connecting directly to the GraphQL API
    and obtaining the introspection information. To do this, use the flag `-t` to
    specify the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` option allows us to scale this check when we have a list of hosts to
    test. [Listing 5-2](#listing5-2) shows how to add hosts to a file named *hosts.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: A file containing target GraphQL servers'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-3](#listing5-3) shows how to write a Bash loop to test multiple
    hosts by reading the *hosts.txt* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: A Bash `for` loop to iterate through the target hosts and run
    InQL against each'
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop will read the *hosts.txt* file line by line and assign each line
    to the `host` variable. InQL will then use this variable as its target. This technique
    lets us test dozens of URLs in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to run InQL against large applications, consider using the `--cycles-timeout`
    flag to set a timeout on the circular check. This will ensure that the application
    doesn’t hang while looking for circular queries, if the target schema is of significant
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Query Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to identify circular queries by using multiple tools,
    let’s see how sending a circular query would impact the DVGA application. We’ll
    craft a special GraphQL query that uses the circular relationship we’ve discovered
    to perform a deeply recursive request.
  prefs: []
  type: TYPE_NORMAL
- en: A successful cyclical query will cause heavy load on the server and possibly
    crash it. As a result, testing circular queries can be risky. To be on the safe
    side, we’ll provide both a safe and an unsafe version of a circular query. The
    safe version will have less circularity than the unsafe one, so you can safely
    experiment with it in the lab without crashing the target.
  prefs: []
  type: TYPE_NORMAL
- en: Open Altair and copy in the *safe-circular-query.graphql* file from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/safe-circular-query.graphql).
    [Listing 5-4](#listing5-4) shows this query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: A recursive query in GraphQL'
  prefs: []
  type: TYPE_NORMAL
- en: As the name indicates, *safe-circular-query.graphql* is the safer version of
    a circular query. In this query, we ask for the owners’ names of all pastes on
    the application, except we’re doing so in circles, which exponentially increases
    the number of objects the GraphQL server has to load. Paste the query into Altair
    and run it against the server to prove the concept of circular queries.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Introspection Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A circular relationship exists in GraphQL’s built-in introspection system. Therefore,
    when introspection is enabled, you could potentially have access to a circular
    query right out of the gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introspection system has its own schema, defined in the official GraphQL
    specification document. Here is an excerpt of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At ❶, the `types` field is defined for the `__Schema` object type. You can see
    that `types` is set to `[__Type!]`, which means that it’s using the `__Type` object
    defined at ❷. The square brackets and exclamation point mean that the `types`
    field will return a non-nullable array of `__Type` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `__Type` object has a `fields` field, set at ❸, of type `[__Field!]`. This
    will return a non-nullable array containing `__Field` objects. At ❹, the `__Field`
    type is defined. This type has a field named `type` at ❺ referencing the `__Type`
    object. As you can see, we have a circular relationship between `__Type.fields`
    and `__Field.type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily test this circular relationship by running the following query
    with Altair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Such circular queries can be fairly easily exploited. While a single query may
    not be able to take down a server, a series of complex queries could have the
    potential to impact it.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Fragment Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GraphQL operations can share logic through the use of fragments, as explained
    in Chapter 3. Fragments are defined by the client, and as such, clients can build
    any logic they desire into them. That said, the GraphQL specification documentation
    contains rules about how fragments should be implemented, including this one:'
  prefs: []
  type: TYPE_NORMAL
- en: The graph of fragment spreads must not form any cycles including spreading itself.
    Otherwise, an operation could infinitely spread or infinitely execute on cycles
    in the underlying data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s explore how fragments can be constructed to form a cycle and lead to
    a DoS. In DVGA, run the following query, which uses a fragment named `Start` on
    the object `PasteObject`. The `pastes` field utilizes this fragment using the
    `...Start` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the query is executed, it returns the `field` and `content` fields of
    `pastes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what if we add another fragment named `End` that uses the `Start` fragment,
    and modify the `Start` fragment to use the `End` fragment? An interesting condition
    will occur here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This condition leads to an infinite execution, just as the GraphQL specification
    suggests. Try experimenting with this query in the lab.
  prefs: []
  type: TYPE_NORMAL
- en: If you ran the query, you should have seen a pretty immediate crash! You might
    be wondering, are all GraphQL servers vulnerable to this attack? The short answer
    is no, if the GraphQL server is spec compliant. A GraphQL server is supposed to
    reject such queries before they get executed. Still, you never know when you might
    run into a completely custom implementation in a penetration test, so knowing
    about this technique is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Field Duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Field duplication* vulnerabilities concern queries that contain repeating
    fields. They are simple to execute, yet less effective than circular queries.'
  prefs: []
  type: TYPE_NORMAL
- en: While circular queries are small queries that result in abnormally large responses,
    field duplications are large queries that exhaust the server because of the amount
    of time they take to process and resolve. To effectively abuse GraphQL APIs by
    using field duplications, you must send a constant stream of queries to keep the
    server’s resources continuously busy.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding How Field Duplication Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand how field duplication works, consider the following GraphQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This query returns the `title` and `content` fields of all pastes in the application.
    When GraphQL receives this query, it will use its query resolvers to provide each
    field requested.
  prefs: []
  type: TYPE_NORMAL
- en: If we “stuff” additional fields in the query, GraphQL will be forced to resolve
    each field separately. This behavior could introduce additional load on the server,
    cause performance degradation, or completely crash it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy here is fairly simple: choose a field that you think might be
    expensive to resolve, and stuff the query with additional copies of that field’s
    name. [Listing 5-5](#listing5-5) shows an example query.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: A GraphQL query with repeating fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a query contains multiple repeating fields, such as in [Listing 5-5](#listing5-5),
    where `content` is repeated five times, you might expect to see the same five
    fields in the response. In reality, GraphQL will consolidate the response and
    display only a single `content` JSON field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From a client perspective, it might seem like GraphQL is ignoring our repeating
    fields. Fortunately, this is not the case. Through response time analysis, you
    can see the query’s impact on the server. Unless the server has implemented specific
    security defenses, such as query cost analysis (covered later in this chapter),
    you should expect to see these vulnerabilities in most GraphQL implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for Field Duplication Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test field duplication attacks in our lab, we’ll write a simple query and
    attempt to repeat a few selected fields to see how our target responds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Altair and ensure that the address bar is set to *http://localhost:5013/graphql*.
    In the left pane, enter the following query, which will serve as a baseline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Click **Send** to query GraphQL. In the response section, you’ll notice that
    Altair provides the total time it took for the server to respond in milliseconds,
    as shown in [Figure 5-3](#figure5-3).
  prefs: []
  type: TYPE_NORMAL
- en: It took 26 milliseconds for DVGA to respond to the query, which is a normal
    response time. The time you might see in your lab could differ but should be in
    the same ballpark.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The Altair response time indicator'
  prefs: []
  type: TYPE_NORMAL
- en: Next, copy the query from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/field-duplication.graphql),
    paste it into Altair, and run it. This query contains approximately 1,000 `content`
    fields. [Figure 5-4](#figure5-4) shows that processing this query took 958 milliseconds,
    which is 36 times slower!
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: A slower response time to a query with repeating fields'
  prefs: []
  type: TYPE_NORMAL
- en: Some fields will require more resources to resolve, so the performance impact
    might vary depending on the chosen field.
  prefs: []
  type: TYPE_NORMAL
- en: This attack requires the client to continuously send large payloads. Attempting
    to manually exploit field duplication can be cumbersome. As an alternative method,
    you can use a special Python exploit that attempts to perform a field duplication
    attack at a far larger scale. [Listing 5-6](#listing5-6) shows a snippet of such
    an exploit. It sends a continuous stream of queries to a remote server in order
    to exhaust its resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: A field duplication exploit'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates a dynamic `payload` variable ❶ with two duplicated fields:
    `content` and `title`. Each is repeated 1,000 times. At ❷ it concatenates the
    payload with the `query` JSON variable. It then defines a function named `DoS`
    that is responsible for sending the HTTP POST request containing our malicious
    GraphQL query ❸. We run an infinite `while` loop that executes the `DoS` function
    using 50 threads every two seconds ❹. The full exploit code can be found on GitHub
    at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_threaded_field_dup.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download this exploit and run it against DVGA with the following command.
    Keep in mind that performance could degrade on your machine while it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since the exploit uses an infinite loop, it won’t stop its operations on its
    own; you can halt it by pressing CTRL-C to send the *SIGINT* signal.
  prefs: []
  type: TYPE_NORMAL
- en: Alias Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 3, you learned how to use aliases to rename duplicate fields so that
    the GraphQL server treats them as two different queries. The ability to run multiple
    queries in a single HTTP request is quite powerful. Security analysts could easily
    overlook these single requests when hunting for suspicious traffic (as could WAFs).
    After all, they might think, what harm can a single HTTP request possibly cause?
  prefs: []
  type: TYPE_NORMAL
- en: By default, GraphQL servers won’t limit the number of aliases that can be used
    in a single request. The GraphQL application maintainer could implement custom
    protections, such as counting the aliases and restricting them in some middleware,
    but since aliases are part of the specification, it’s uncommon to remove support
    for them or limit their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing Aliases for Denial of Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When performing a penetration test, you may run into queries that seem to take
    the server longer to process than others. If you identify such a query, you can
    hog system resources by calling the same query over and over again. If the server
    struggles to quickly return a response, flooding the server with the same query
    could result in system overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'In DVGA, one specific query is slower than others: `systemUpdate`. This query
    is designed to simulate long-running commands, such as those that perform system
    updates. Unauthorized clients should never be allowed to perform queries that
    change system state, but nothing is impossible in real-life penetration testing
    scenarios! Let’s run the `systemUpdate` query in Altair to see how long this command
    takes to fully process. It takes no arguments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Send this query to the server and observe the time it takes for the server to
    return a response ([Figure 5-5](#figure5-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: The `systemUpdate` query response time'
  prefs: []
  type: TYPE_NORMAL
- en: The `systemUpdate` took 50,361 milliseconds to complete. That’s around 50 seconds,
    a significant amount of time by today’s web standards. This is an example of a
    query that we might be able to leverage for DoS purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL aliases, we can attempt to run `systemUpdate` a few times to see
    how the server behaves. [Listing 5-7](#listing5-7) shows how you can run `systemUpdate`
    more than once, using aliases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Aliasing the `systemUpdate` query'
  prefs: []
  type: TYPE_NORMAL
- en: Running this query in Altair should take longer than normal to complete.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to generate hundreds of queries, you can use a short Python script
    in the terminal to craft a query programmatically, as shown in [Listing 5-8](#listing5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: Generating aliases with Python'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: there are no limits to the number of aliases a client can provide
    by default, unless the application maintainer has implemented specific protections
    against these types of attacks or the web server has set HTTP body length limits.
    That means we could specify dozens of aliases and hog server resources in a single
    HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: Other interesting, non-DoS use cases exist for aliases when it comes to penetration
    testing, such as defeating authentication mechanisms. You’ll learn more about
    those in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Aliases and Circular Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since aliases are part of the GraphQL specification, any other vulnerability
    you identify can be combined with aliases. The query in [Listing 5-9](#listing5-9)
    shows how we can run a circular query with an alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: Circular queries with aliases'
  prefs: []
  type: TYPE_NORMAL
- en: This query is not recursive enough to cause any harm to a GraphQL server, but
    it illustrates the possibility of making more than one circular query in a single
    GraphQL document.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of aliases is that they allow aliasing only queries of the
    same root type. You can alias queries only with queries, or mutations only with
    mutations, but not queries and mutations together.
  prefs: []
  type: TYPE_NORMAL
- en: Directive Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chapter 3 covered GraphQL directives, which are a way to decorate a field or
    object in GraphQL by using the at (`@`) symbol. While directives are part of the
    GraphQL specification, the specification does not discuss security controls that
    should be implemented for directives. In general, GraphQL implementations check
    whether the client repeats a query directive; if so, the server rejects the query.
    Typical checks on directives are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UniqueDirectivesPerLocation` ensures that unique directives are in each document
    location, such as a field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UniqueDirectiveNames` ensures that directives have unique names if more than
    one is supplied in a location such as a field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, nonexistent queries can be supplied many times. There are effectively
    no limits to the number of nonexistent directives a client can supply in most
    of the popular GraphQL implementations today.
  prefs: []
  type: TYPE_NORMAL
- en: Our research has shown that it’s possible to exhaust GraphQL servers’ query
    parsers by passing a large number of nonexistent directives in a single query.
    During our responsible disclosure process for this directive overloading vulnerability,
    we engaged with multiple GraphQL developers on the matter. Opinions on whether
    it’s the maintainers’ or consumers’ responsibility to address the flaw varied
    quite a bit. Companies that were part of the disclosure process and chose to address
    it did so by limiting the number of directives a server will accept or blocking
    the query based on its HTTP request body’s size.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing Directives for Denial of Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The directive overloading vulnerability is somewhat similar to field duplication
    in that it requires us to send many directives via several continuous requests.
    Despite requiring more computing power than a vulnerability like circular queries,
    we’ve found it to be effective at degrading the server’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attack is quite simple: stuff directives in multiple parts of a query and
    send it to the server, as shown in [Listing 5-10](#listing5-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: An example of directive overloading'
  prefs: []
  type: TYPE_NORMAL
- en: The impact on the server can vary depending on its hardware specifications.
    We’ve seen different server behaviors when using this exploitation technique,
    such as GraphQL server crashes (due to database memory errors) or service performance
    degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for Directive Overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exploit in the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/exploit_directive_overloading.py)
    abuses this type of vulnerability and can be used against DVGA to perform a directive
    overloading attack.
  prefs: []
  type: TYPE_NORMAL
- en: At any point while running this script, you can halt its operation by pressing
    CTRL-Cto send the *SIGINT* signal. Note that while the script is running, DVGA
    will likely be slow or unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command runs the exploit from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 5-11](#listing5-11) shows the main exploit code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: The exploit code to abuse the directive overloading vulnerability'
  prefs: []
  type: TYPE_NORMAL
- en: The exploit takes two arguments from the command line, one to identify the target
    API and the other for the number of directives that will be stuffed into the query
    during exploitation. As part of the `start_attack` function, we multiply the `dos`
    directive by the number of directives provided. We then build the GraphQL query
    that will use the malicious payload and create 300 threads, each running the `start_attack`
    function in parallel. This keeps the server resources busy for as long as the
    exploit is running by using an infinite `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Object Limit Overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GraphQL servers can implement limits on the amount of data they return to a
    client by default. This is especially important for fields that return arrays.
    For example, recall that, in DVGA, the `pastes` query returns an array of paste
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The exclamation mark means that `pastes` is non-nullable, so the array must
    have zero or more items. Unless the query is explicitly limited, GraphQL will
    return all objects in response to a request for `pastes`. If the database has
    10,000 objects, for example, GraphQL could return all 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: A response containing 10,000 objects is a lot of data for the server (and client)
    to process. Servers could implement logic to limit the number of returned objects
    to a more restricted number, such as 100\. For example, they might sort objects
    by their creation time and return only the most recent pastes. This filtering
    can happen at the database level, the GraphQL level, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some GraphQL applications may allow a client to override this server-side object
    limit by passing a special argument such as `limit`, as in this example. Go ahead
    and run this query in Altair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing this query, GraphQL could convert it to a SQL query behind the
    scenes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: On a small-scale database such as DVGA’s, this won’t do a whole lot of harm.
    However, on very large databases, controlling the number of rows a server returns
    could be powerful and may allow us to perform database-level DoS.
  prefs: []
  type: TYPE_NORMAL
- en: If introspection is enabled, GraphQL will auto-complete arguments as you type
    them, making it easy to discover those that the queries support. If introspection
    is disabled, try common keywords such as `limit`, `offset`, `first`, `after`,
    `last`, `max`, and `total`. These keywords are often associated with *API pagination*,
    a way to control the amount of data returned in HTTP responses. Pagination divides
    a large dataset into smaller parts, which allows the client to both request and
    receive data in chunks.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth testing how many objects the server allows a client to request. Having
    the ability to request an arbitrary number of records from the server could become
    another DoS vector in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Array-Based Query Batching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll explore a feature that very conveniently allows us to scale the attacks
    you’ve learned about so far. *Query batching* is any method used to group multiple
    queries and send them to the GraphQL API in parallel. Aliases are one form of
    query batching.
  prefs: []
  type: TYPE_NORMAL
- en: While useful, aliases have a clear disadvantage, as they can batch only queries
    that are of the same operation root type. For instance, you can’t alias a mutation
    and a query together. The technique of *array-based batching* allows us to mix
    queries and mutations. However, arrays aren’t part of the specification and therefore
    may not be available to you during all penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding How Array-Based Query Batching Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array-based query batching is a feature that allows a client to send multiple
    GraphQL queries of any root type in an array as part of a JSON payload. Imagine
    that we want to send a query more than once and receive the same response multiple
    times. Using array-based query batching, we can easily do this by essentially
    duplicating this query and adding the copies as elements to an array. Here is
    a pseudo-query example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When GraphQL receives an array of queries from a client, it will process them
    sequentially and refrain from returning a response until the very last array element
    is processed and resolved. Once all queries are resolved, it will return a response
    containing an array of all query responses in a single HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your hacker senses might be kicking in at this very moment, because there is
    a clear risk here. It’s assumed that the client will send a reasonable number
    of queries in an array. But what happens if a client sends thousands of queries
    in a single array instead? Let’s find out. Spoiler: bad things will happen.'
  prefs: []
  type: TYPE_NORMAL
- en: As with aliasing, identifying the abuse of array-based batch queries can be
    difficult, because all a security analyst will see in their logs is a single HTTP
    request. This may not immediately stand out as a malicious pattern. Thus, this
    technique could circumvent traditional rate-limiting controls, which may restrict
    clients to a certain number of requests per second (RPS) or requests per minute
    (RPM).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we’ll discuss some potential mitigations for batched
    queries an application could implement.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for Array-Based Query Batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL IDEs such as Altair, GraphQL Playground, and GraphiQL Explorer do not
    support array-based queries directly from the interface. So, to test whether array-based
    query batching is enabled on the DVGA, we’ll need to use an HTTP client such as
    cURL or a scripting language such as Python. We’ll show how to use both methods
    in our lab.
  prefs: []
  type: TYPE_NORMAL
- en: Using cURL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command in [Listing 5-12](#listing5-12) sends an array of queries using
    cURL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: Array-based batch queries using cURL'
  prefs: []
  type: TYPE_NORMAL
- en: In this cURL command, we’re using the `-d` flag to send an array of GraphQL
    queries to the server. The array, which is defined using square brackets `[]`,
    surrounds two similar GraphQL queries. In each query, we’re using the `systemHealth`
    object. The GraphQL server returns two separate responses.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an array containing two GraphQL queries will result in an equal number
    of query responses if the GraphQL server supports array-based query batching.
    You can tell that this is the case by the `data` JSON field we received in the
    response. When the `-d` flag is used, cURL uses the HTTP POST method under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The same query can be performed using Python, as shown in [Listing 5-13](#listing5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: Array-based batch queries using Python'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `queries` array containing our two `systemHealth` queries. We then
    send them in a batch to DVGA and print the response. This should return an array
    containing two elements, each of which is a response to a single query. You can
    find this code in the GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_batch_query.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file to your desktop and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'GraphQL servers that don’t support array-based batching may throw HTML errors
    because they don’t implement logic to handle an array payload. Servers that do
    support arrays but have disabled them may return an error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll explore how to perform DoS attacks by combining circular queries
    and array-based query batching.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Circular Queries and Array-Based Query Batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using circular queries with array-based batching can wreak havoc on a GraphQL
    server and potentially knock it out. Consider the circular query in [Listing 5-14](#listing5-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: A circular query'
  prefs: []
  type: TYPE_NORMAL
- en: This recursive query has a depth level of five. On its own, it may not be enough
    to take down the target server, but we could modify it to make it much deeper.
    Each level creates an additional node that a server needs to process and resolve,
    consuming more server resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment with circular queries, we’ve coded a custom exploit for your
    arsenal of hacking tools. This exploit can dynamically extend its circularity
    by letting you specify the number of circles that should be performed. The query
    is also capable of batching queries using arrays. The following code is a snippet
    from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch05/array_based_circular_queries.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code builds on the query in [Listing 5-14](#listing5-14) by dynamically
    generating a circular query and adding it to an array based on two main script
    inputs: `ARRAY_LENGTH` and `FIELD_REPEAT`. The `ARRAY_LENGTH` is the number of
    queries to be grouped together. A value of `5` means that the array will have
    five queries. `FIELD_REPEAT` indicates the number of times the script will append
    the circular fields (`pastes` and `owner`) into the query.'
  prefs: []
  type: TYPE_NORMAL
- en: The script then uses a `for` loop to construct the query based on the value
    of `FIELD_REPEAT` and assigns it to the `query` variable. We initialize an empty
    array named `queries` and run another `for` loop to add the query we constructed
    into the `queries` array. To put it simply, we construct a circular query, add
    it to an array based on predefined values, and send it to the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to run this script in the lab to see how it works! Download
    the script to your lab and set the executable (`+x`) permissions before running
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The script will output the query and some information about it, such as the
    number of times the fields were repeated, the depth level of the query, and the
    length of the array sent to the server. You can alter `FIELD_REPEAT` and `ARRAY_LENGTH`
    to see the change in impact on the server’s responsiveness by dynamically growing
    the query and array.
  prefs: []
  type: TYPE_NORMAL
- en: There are no magic numbers here; you will want to gradually increase the numbers
    of fields until the target server becomes noticeably slower. Based on our lab
    experiments, setting `FIELD_REPEAT` to at least `500` should result in DVGA crashing
    with a segmentation fault error. In that case, start it up again by following
    the lab setup guidelines in Chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Query Batching by Using BatchQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Certain GraphQL tools attempt to detect when batching is available on a target
    GraphQL server. For instance, BatchQL is a small Python utility that scans for
    GraphQL weaknesses. It is able to detect both alias-based batching and array-based
    batching by sending a preflight request and observing the errors returned by the
    server. The following code demonstrates the logic it uses to detect array-based
    batching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, BatchQL creates a GraphQL query by using the field `hacktheplanet`.
    It then creates an array containing two copies of the query. BatchQL sends the
    array to a target server and counts the number of errors returned in the response.
    If the number of errors is greater than one, it means that the server processed
    both queries.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it looks for the number of errors returned is that the query contains
    the `hacktheplanet` field, which will likely not exist on any real target. Therefore,
    GraphQL will return an error for each query it wasn’t able to process. BatchQL
    uses the same error-counting logic for its detection of alias-based batching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now attempt to run BatchQL against DVGA and see the kind of output we
    get. Use the `-e` flag to specify the GraphQL endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: BatchQL was able to detect that both array-based batching and alias-based batching
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a DoS Audit with GraphQL Cop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*GraphQL Cop* is a Python-based security auditing utility capable of finding
    DoS and information disclosure weaknesses in GraphQL applications. It can identify
    most DoS classes covered in this chapter. Let’s use this tool against DVGA to
    see what vulnerabilities we can quickly find without a lot of effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL Cop takes very few parameters to do its work. To perform an audit,
    run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get output containing a description of each vulnerability
    and its predefined severity. The tool was able to identify four DoS vectors in
    DVGA. If you need to parse this information programmatically during a penetration
    test, you may need a more script-friendly output. To achieve this, use the `-o`
    `json` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-Service Defenses in GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve explored various techniques for performing DoS attacks against GraphQL
    targets. While most GraphQL implementations don’t include comprehensive DoS mitigations
    by default (with some exceptions), it’s possible to protect against the attacks
    we’ve discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Query Cost Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complex queries are costly for servers to process, especially when many of them
    are sent simultaneously. When performing a penetration test, you may run into
    a GraphQL server that implements a *cost analyzer*. This term refers to any system
    that assigns a numerical value to GraphQL fields based on how much they “cost”
    to process. Processing involves CPU, input/output (I/O), memory, and network resource
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Query cost analysis can be achieved in multiple ways, such as by evaluating
    the query structure pre-execution using static analysis or by observing the query
    response after it’s fully resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Statically Assigning Cost to the Query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The more common form of cost analysis is *static analysis*. For instance, consider
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We’re using the `pastes` top-level field and specifying some fields, such as
    `title`, `content`, and `owner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With static analysis, you can assign the query a cost in different ways. One
    common way is using a dedicated schema directive to specify values per field or
    per object type. The following example schema illustrates how cost assignment
    can be achieved through the use of schema directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, a special `cost` directive accepts a `complexity` argument, and the `complexity`
    argument accepts an integer value. If no value is provided to the `complexity`
    argument, it defaults to `1`. In the schema, the fields in `PasteObject` have
    some cost values assigned to them based on how resource heavy they are to resolve.
    (Imagine a field that requires the server to perform upstream checks against multiple
    third-party services, as opposed to a field that can be resolved by reading directly
    from a local database.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this schema definition, we can add directives to our query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The total cost of this query is `12`. Knowing the total cost allows the GraphQL
    server to decide whether it should accept the query or reject it because it’s
    deemed too expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Many static cost assignment libraries don’t persist the cost information to
    any database or cache. Therefore, in practice, each query is evaluated per query.
    To illustrate the dangers of failing to track cost usage, consider the diagram
    in [Figure 5-6](#figure5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: The dangers of stateless cost analysis'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a GraphQL server has set the maximum cost allowed (`MAX_COST`) to `200`.
    In this example, queries that have a cost of 200 and below are accepted, which
    means that if a client is sending multiple parallel queries, all with a cost of
    200, all will be accepted. This might introduce risks if the application’s backend
    is not able or ready to sustain parallel queries with such cost. Imagine an attacker
    using the maximum cost allowed to send thousands of requests; if the limit is
    too forgiving, this could choke an application.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Assigning Cost to the Server Response
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cost analysis can also be performed on the server response to a query after
    it is fully resolved. The server must first process the query in order to understand
    its cost. However, looking at the actual resolved query can provide a more accurate
    cost estimation than the static technique.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this dynamic method over the static method is that dynamic
    cost assignment takes into account the response complexity as it is returned by
    the server. Think of a client requesting a single field that results in the server
    returning an array containing 1,000 elements. In this case, the response indicates
    a level of complexity that cannot be inferred by just looking at the query.
  prefs: []
  type: TYPE_NORMAL
- en: Using Credits-Based Rate Limiting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GraphQL servers can be designed to keep track of the cost of queries made throughout
    a client session’s lifetime. Tracking this information allows servers to set hourly
    or daily quota limits, and reject queries after a certain limit is exceeded, as
    part of a credit-based system. For example, a server may set an hourly credit
    allowance (such as 1,000) per user session or per source IP address. If a query
    had a static cost of 200, a client could make only five of these queries per hour.
    To query again, they would have to wait until the credit allowance quota renews.
  prefs: []
  type: TYPE_NORMAL
- en: For this mechanism to work, however, the server must track and store a client’s
    API usage data in a database. Otherwise, query limits based on cost would have
    to be stateless, which is common in GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering a Query’s Cost in Responses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you’ve learned, there are a few ways to implement cost-analysis controls
    in GraphQL APIs. In some implementations, you may see cost-related metadata in
    the response to a query. Consider the following GraphQL response example, which
    uses the `extensions` response field to provide cost-related information to the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `extensions` field is used to return some metadata to the client. This metadata
    is often related to query tracing, query cost calculation, or other debugging
    information. In this example, `credits_total` is the total number of available
    credits, and `credits_remaining` is the current number of credits left.
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself why a GraphQL server would share this information
    with the client in the first place. Clients can use it to determine when queries
    may start getting throttled by the server and potentially fail. This helps clients
    build better error-handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the availability of cost information is also valuable to hackers.
    If we have a way to know when our queries will be accepted by the server (as in
    the case of hourly credits), we have a way to determine when to launch a new attack
    the next time credits become available to us, instead of repeatedly sending requests
    that will get blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Query Depth Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, we discussed circular queries and how recursive queries
    in GraphQL could starve a server for resources. To protect a GraphQL server from
    recursive queries, applications can set query depth limits. For example, setting
    a `max_depth` configuration to a value of `10` would allow up to only 10 levels
    of depth. Any query that exceeds the allowed depth would get rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more mature GraphQL implementations support depth analysis out of
    the box or by leveraging external libraries written specifically for this purpose.
    Let’s take a look at how to implement query depth limits in graphql-ruby (Ruby)
    and Graphene (Python).
  prefs: []
  type: TYPE_NORMAL
- en: 'In graphql-ruby, it is possible to set a maximum depth limit within the `MySchema`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In Graphene, a maximum depth limit can be set in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Depth is typically calculated per query. If an attacker sends multiple recursive
    queries simultaneously, this can still impact the server quite drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Alias and Array-Based Batching Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because GraphQL aliases are part of the GraphQL specification, developers can’t
    disable them easily. Preventing aliases from being abused requires custom middleware
    code that parses the incoming query, counts the number of specified aliases, and
    rejects the request if the number appears high enough that it could be dangerous
    to process. For this type of control to even exist in a GraphQL application, its
    developers need to be aware of the security weaknesses caused by aliases in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike aliases, array-based batching is not part of the specification document.
    It often requires installing additional packages or enabling the feature in the
    code. Let’s take a look at what disabling array-based batching looks like in Graphene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `batch` argument accepts a Boolean value of either `True` or `False`. If
    we toggle it to `False`, Graphene will reject any arrays from being processed.
    This is an example of how the GraphQL server implementation natively supports
    disabling batching and doesn’t require custom code.
  prefs: []
  type: TYPE_NORMAL
- en: In penetration tests, use GraphQL fingerprinting tools such as Graphw00f to
    identify the target server implementation. You can then use the GraphQL Threat
    Matrix project we’ve put together ([https://github.com/nicholasaleks/graphql-threat-matrix](https://github.com/nicholasaleks/graphql-threat-matrix))
    to identify whether features such as array-based batching are available. If they
    exist, figure out whether they can be disabled. These insights will be useful
    to document in a penetration test report as part of the remediation section.
  prefs: []
  type: TYPE_NORMAL
- en: Field Duplication Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, GraphQL resolves any field specified in a query, even if it’s specified
    more than once. Even so, we can mitigate against field duplication attacks in
    multiple ways.
  prefs: []
  type: TYPE_NORMAL
- en: While it doesn’t directly address the field duplication problem, query cost
    analysis protects GraphQL applications whenever a large number of fields are specified
    in a single query (whether they are duplicated or not). Cost analysis is an effective
    mitigation against any form of attack that involves specifying many fields in
    a single query.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of protection is using a middleware security analyzer to inspect
    the incoming query and take action if any fields are repeated more than once.
    The application might choose to implement multiple actions, such as completely
    rejecting a query or *normalizing* the query by consolidating any repeated fields
    to eliminate the duplications. This would essentially reconstruct the original
    query as a safer version. Currently, no feature in GraphQL does this. Application
    developers will need to develop middleware themselves or use a third-party security
    tool to do it for them.
  prefs: []
  type: TYPE_NORMAL
- en: Another way applications might go about defending themselves against field duplication
    is by calculating the query’s field “height.” Consider the query in [Figure 5-7](#figure5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: An example GraphQL query height'
  prefs: []
  type: TYPE_NORMAL
- en: This query requests the `owner` field, and then the `owner` field’s `id` (once)
    and `name` (four times). As you can see, the height altogether is 5\. An application
    might limit any query that exceeds a certain allowed height. Keep in mind that,
    by default, GraphQL does not implement this type of control.
  prefs: []
  type: TYPE_NORMAL
- en: Limits on the Number of Returned Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GraphQL servers could limit the number of objects they return when a client
    requests an array field. To do so, they could set a maximum number of items to
    return on the server side and keep the client from overriding it. Here is an example
    of how this can be achieved in Graphene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example resolver function is for the `pastes` query. The limit ensures
    that no matter how many pastes exist in the database, the maximum number of pastes
    returned is 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to limit the number of records returned in a response is by introducing
    API pagination, which controls the number of records a client can retrieve in
    a single request.
  prefs: []
  type: TYPE_NORMAL
- en: Query Allow Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another defense technique an application might implement is an allow-list approach.
    The concept of *allow lists* is simple: you define the GraphQL queries that an
    application can accept, and you reject any queries that aren’t on the list. You
    can consider this to be a safe list of trusted queries.'
  prefs: []
  type: TYPE_NORMAL
- en: The allow-list approach is typically safer than the use of a deny list, which
    tends to be prone to more errors. A malicious payload can be constructed in a
    variety of ways, and if you don’t take all of those variations into consideration
    when building a deny list, attackers might find ways to bypass it.
  prefs: []
  type: TYPE_NORMAL
- en: Query allow lists do not normally exist in GraphQL server implementations, nor
    do many external libraries implement them. To leverage such a feature, GraphQL
    application developers must seek a compatible library for their implementation
    or create one from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Persisted Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Query allow lists are often used in conjunction with a caching mechanism called
    *automatic persisted queries* *(APQ*), which is used for improving the performance
    of GraphQL queries. Instead of using the normal GraphQL query structure, a GraphQL
    server that implements APQ can accept hashes that represent these queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an APQ interaction between a GraphQL client and server, the client first
    attempts to send a hash of a query (such as a SHA-256 hash). The server performs
    a hash lookup in its cache. If the hash doesn’t exist, the server returns an error.
    The client can then follow up with another request containing the raw GraphQL
    query, along with its hash, which will get stored in the server’s database. The
    client can use this hash on any subsequent requests instead of providing the full
    query. The hash might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a SHA-256 hash of any query, you can use the `sha256sum` command,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The advantage here is that hashing algorithms produce fixed-length values (for
    example, SHA-256 hashes are 64 characters in length), no matter how large a query
    might be. This eliminates the need for clients to send HTTP requests containing
    large queries over the network and reduces the overall bandwidth consumption.
    [Figure 5-8](#figure5-8) illustrates what a GraphQL deployment with APQ might
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: The APQ architecture'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed a weakness. What if the client is an attacker and forces
    the server to cache a malicious query? Will the attacker be able to use it in
    subsequent queries? That is a great question to ask, and also why a mechanism
    like APQ should coexist with a function such as an allow list. The server should
    reject malicious queries before they get cached so that only trusted queries can
    be inserted into the cache.
  prefs: []
  type: TYPE_NORMAL
- en: APQ is designed as a caching mechanism first, but it can also play as a security
    control to protect GraphQL servers from accepting malicious queries. APQ isn’t
    yet widely used but is supported in some of the mature GraphQL implementations
    on the market, such as Apollo GraphQL. You can refer to the GraphQL Threat Matrix
    project to find out which implementations support APQ.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Timeouts* are another form of protection against long-running and resource-consuming
    tasks. When a GraphQL server is bombarded with many queries, it may take minutes
    to completely fulfill the request. To mitigate these cases, servers can introduce
    application timeouts, which define how long a request can take to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some GraphQL implementations, such as graphql-ruby, allow setting a timeout
    on the query execution in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However, not all GraphQL implementations support setting query timeouts this
    way. Those GraphQL applications could use timeouts at the web server layer, such
    as in Nginx or Apache, which support setting timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the right application timeout intervals tends to be a tricky task; a
    too-short timeout configuration could mean dropping legitimate client requests
    and impacting the client’s user experience, which is why applications usually
    have a high timeout value set by default. Both Nginx and Apache set their request
    timeout value at around the 60-second range.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts can be effective, but they shouldn’t be the only mitigation strategy
    a GraphQL application implements.
  prefs: []
  type: TYPE_NORMAL
- en: Web Application Firewalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Web application firewalls (WAFs)* are useful for blocking malicious traffic
    before it reaches the application. They allow security teams to respond quickly
    to attacks and vulnerabilities by creating signatures and rules that block traffic
    based on various patterns, such as HTTP payloads, URLs, or a client’s geographical
    location.'
  prefs: []
  type: TYPE_NORMAL
- en: WAFs have been battle tested in production environments for many years, protecting
    web applications and APIs such as REST and SOAP across many industries. However,
    commercial and open source WAFs are still adapting to the way GraphQL works, and
    the ways attackers might abuse GraphQL for nefarious purposes, so some gaps remain
    in the protections WAFs can offer GraphQL applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although some WAFs are not “GraphQL-aware,” the way they inspect traffic still
    allows them to detect many malicious payloads. They can block suspicious payloads,
    such as SQL injections, operating system injections, cross-site scripting (XSS),
    and so on, even when embedded within GraphQL queries or mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following XSS example in a GraphQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Even WAFs without native GraphQL support will likely identify and reject requests
    containing such common exploit payloads. Additionally, WAFs can provide other
    forms of protection, such as body size restrictions (in the form of byte limits)
    to prevent DoS attacks, or throttling to slow DoS attempts.
  prefs: []
  type: TYPE_NORMAL
- en: However, WAFs without GraphQL support will struggle to defend against many of
    the attacks you learned about in this chapter. For instance, WAFs typically don’t
    block single HTTP requests if they don’t contain any malicious patterns, such
    as dangerous JavaScript payloads (like XSS), or SQL commands (in the case of SQL
    injection). Although we can send thousands of queries in a single HTTP request
    by using aliases or array-based batching, WAFs without native GraphQL support
    won’t understand the danger in accepting such requests.
  prefs: []
  type: TYPE_NORMAL
- en: Gateway Proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL *gateways* merge multiple GraphQL schemas into one unified schema, either
    by stitching them together or by connecting to each individual GraphQL service
    to fetch its schema content. This schema is then exposed at the gateway layer
    for clients to consume. [Figure 5-9](#figure5-9) shows how such an application
    deployment model might look.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c05/f05009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-9: A GraphQL gateway proxying traffic to other services'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL gateways are becoming more popular in the security space as a network
    choke point that can enforce policies and perform rate limiting. They often act
    as reverse proxies, forwarding traffic to other internal API servers, and can
    manage multiple API schemas. Gateways also provide features such as auditability,
    schema version control, authorization controls, Layer 7 DoS protection, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed several ways an attacker might introduce load
    on GraphQL servers for the purpose of carrying out DoS attacks. We used several
    dedicated GraphQL security tools to test for DoS conditions and dissected custom
    exploits to understand how they work under the hood. You also learned how query
    batching works in GraphQL and how to make DoS attacks even more powerful by using
    arrays and aliases. Finally, we explored the types of security defenses GraphQL
    applications could implement to protect themselves against DoS attacks.
  prefs: []
  type: TYPE_NORMAL
