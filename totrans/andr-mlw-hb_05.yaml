- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: STATIC ANALYSIS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter and the next present a hands-on approach to Android malware analysis
    by walking through an examination of two Android malware samples from 2022, a
    toll fraud app and a phishing app. In this chapter, we focus on static malware
    analysis and code reading. In [Chapter 4](ch04.xhtml), we discuss dynamic analysis,
    or running a malware sample in a controlled environment to observe its behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章通过对两个2022年Android恶意软件样本（一个收费欺诈应用和一个钓鱼应用）的分析，提供了一种实践性的Android恶意软件分析方法。在本章中，我们重点关注静态恶意软件分析和代码阅读。在[第4章](ch04.xhtml)中，我们讨论动态分析，即在受控环境中运行恶意软件样本以观察其行为。
- en: Rather than treating these chapters as references, you should consider them
    to be examples of real malware analyses through which we introduce Android reverse
    engineering tools and highlight certain best practices. Collectively, the authors
    of this book have examined more than 100,000 Android malware samples over the
    last 10 years. Here, we share some of what we have learned to give your own analyses
    a jump start.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将这些章节视为参考资料，不如将它们看作是实际恶意软件分析的示例，通过这些示例我们介绍了 Android 逆向工程工具并强调了一些最佳实践。本书的作者在过去10年中分析了超过100,000个
    Android 恶意软件样本。在这里，我们分享一些我们所学到的东西，帮助你为自己的分析提供启示。
- en: '**What Is Static Code Analysis?**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是静态代码分析？**'
- en: The term *static code analysis*, or simply *static analysis*, refers to the
    process of analyzing a program to discover its properties without actually executing
    it. This strategy contrasts with *dynamic analysis*, introduced in the next chapter,
    where the program under observation is run to observe its runtime behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态代码分析*（简称 *静态分析*）指的是在不实际执行程序的情况下分析程序以发现其属性的过程。这一策略与接下来章节中介绍的*动态分析*形成对比，在动态分析中，观察的程序会被运行，以观察其运行时行为。'
- en: Static analysis encompasses many techniques. You can think of it as a set of
    approaches to reasoning about programs, including reading program code as well
    as automated strategies like control flow analysis and data flow analysis aimed
    at understanding the order in which a program executes instructions and how data
    flows through its variables and memory. There are also more advanced static analysis
    techniques, such as model checking (used to confirm or disprove properties of
    a piece of code) and abstract interpretation (a way to explore program states
    through simulated execution), but we won’t cover these advanced techniques in
    this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析包括多种技术。你可以将其视为一组推理程序的方式，包括阅读程序代码以及像控制流分析和数据流分析这样的自动化策略，目的是理解程序执行指令的顺序以及数据如何在变量和内存中流动。还有更高级的静态分析技术，如模型检查（用于确认或否定一段代码的属性）和抽象解释（通过模拟执行来探索程序状态），但本书不会涉及这些高级技术。
- en: The following subsections provide some general guidelines for making static
    analysis more efficient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节提供了一些提高静态分析效率的通用指南。
- en: '***Guided vs. Unguided Analysis***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***引导分析与非引导分析***'
- en: In professional malware analysis, it is rare to examine a random app sample
    that you don’t know anything about. Instead, reverse engineers usually look at
    a particular app to confirm or disprove previously collected assumptions about
    its properties. This information can come from malware scanners that flag an app
    on your system, random X chatter, the output of a quick run in an analysis engine,
    or analysis of related samples. In these *guided* scenarios, reverse engineers
    generally know where to start looking. The malware walkthroughs in this and the
    next chapter are *unguided*, meaning we embark without any prior information about
    the samples. All discoveries must be made by inspecting the apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业的恶意软件分析中，很少会分析一个你完全不了解的随机应用样本。相反，逆向工程师通常会查看特定的应用，以确认或否定之前收集的关于其属性的假设。这些信息可能来自恶意软件扫描器标记你系统上的应用、随机的X聊天、分析引擎快速运行的输出，或是相关样本的分析。在这些*引导*场景中，逆向工程师通常知道从哪里开始查看。这里和下一章中的恶意软件分析是*非引导*的，意味着我们在没有任何关于样本的先验信息的情况下开始分析。所有的发现都必须通过检查应用来完成。
- en: Even though unguided reverse engineering is less common in a professional context,
    it can still happen. In these scenarios, reverse engineers should find ways to
    avoid doing full code reviews, as these are costly and take too long for all but
    the most important malware samples. At the same time, the reverse engineer must
    remain confident that no significant part of the malware remains undiscovered,
    even when the code analysis is partial.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在专业环境中，未受指导的反向工程较为少见，但仍然可能发生。在这些情况下，反向工程师应找到避免进行全面代码审查的方法，因为这些方法成本高昂且耗时过长，除非是最重要的恶意软件样本。同时，反向工程师必须保持信心，确保没有重要的恶意软件部分未被发现，即使代码分析是部分进行的。
- en: The easiest way to avoid full code reviews is to develop an understanding of
    the SDKs used in apps. We estimate that about 80 percent of the code in an average
    app comes from third-party SDKs. Android reverse engineers must have tools for
    identifying SDKs; otherwise, they will find themselves painstakingly rediscovering
    information they could have learned by reading publicly available SDK documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 避免全面代码审查的最简单方法是了解应用程序中使用的 SDK。我们估计，平均每个应用程序中约有 80% 的代码来自第三方 SDK。Android 反向工程师必须具备识别
    SDK 的工具；否则，他们将不得不艰难地重新发现本可以通过阅读公开可用的 SDK 文档获得的信息。
- en: '***Knowing When You’re Done***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***知道何时完成***'
- en: In a professional setting, the goal of the analysis determines when you are
    done. If the goal is to classify an app as malware and protect users as fast as
    possible, malware analysis can be extremely superficial. For a phishing app, for
    example, you can look through a sample for less than a minute, find evidence that
    it targets banking apps, record this, and move on. If the goal is to document
    the malicious functionality in a report, or if the analysis is in response to
    an incident at a customer site, you may have to go deeper and spend days or weeks
    on the sample. This chapter and the next will aim to describe the most important
    functionality of the presented malware samples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中，分析的目标决定了你何时完成。如果目标是尽快将应用程序分类为恶意软件并保护用户，恶意软件分析可以非常表面化。例如，对于一个钓鱼应用，你可以在不到一分钟的时间里查看样本，找到它针对银行应用的证据，记录下来，然后继续。如果目标是将恶意功能记录在报告中，或者如果分析是响应客户现场的事件，你可能需要深入分析，花费数天或数周的时间。接下来的章节将着重描述所呈现的恶意软件样本的最重要功能。
- en: Experience has shown that malware analysts should either move quickly, to rapidly
    confirm that an app is malware so steps can be taken to disable it, or move slowly
    in order to investigate it in depth and, along the way, learn how to improve their
    tools and processes. Avoid lengthy malware analysis in cases when you aren’t likely
    to learn any lessons for making future analysis easier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，恶意软件分析师应该迅速行动，以便快速确认应用程序是恶意软件，从而采取措施禁用它，或者行动缓慢，深入调查，并在此过程中学习如何改进他们的工具和流程。在那些不太可能为未来分析提供任何有价值教训的情况下，应避免进行冗长的恶意软件分析。
- en: '**Loading the Malware Sample into jadx**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将恶意软件样本加载到 jadx 中**'
- en: The Android malware sample we analyze in this chapter is *com.bp.statis.bloodsugar*
    (v20, adcf). This app, which masquerades as a blood sugar statistics tracker,
    was uploaded to Google Play in February 2022 and is fairly representative of modern
    Android malware. It contains many anti-analysis techniques, downloads remote components
    from a command-and-control server, and abuses mobile carrier billing options to
    run up fraudulent charges. You can download the file from [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章分析的 Android 恶意软件样本是 *com.bp.statis.bloodsugar*（v20，adcf）。该应用伪装成血糖统计跟踪器，于
    2022 年 2 月上传到 Google Play，且相当具有现代 Android 恶意软件的代表性。它包含许多反分析技术，从指挥和控制服务器下载远程组件，并滥用移动运营商计费选项进行欺诈性收费。你可以从
    [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book)
    下载该文件。
- en: To read the app’s code, we use the open source Android reverse engineering tool
    *jadx*. This tool can take Android code files in formats like APK, DEX, JAR, and
    others and turn them into decompiled Java code that we can understand. Additionally,
    jadx has handy features such as the ability to rename variables and locate the
    places where variables and methods appear in the code. It even has advanced tools
    like a debugger, automated code deobfuscation, and integration with Quark Engine,
    an open source malware analysis engine. You can download jadx from [*https://github.com/skylot/jadx*](https://github.com/skylot/jadx).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阅读应用的代码，我们使用开源的 Android 反向工程工具 *jadx*。该工具可以将 APK、DEX、JAR 等格式的 Android 代码文件转换为可供理解的反编译
    Java 代码。此外，jadx 还有许多方便的功能，如重命名变量以及定位变量和方法在代码中出现的位置。它甚至具有高级工具，如调试器、自动化代码去混淆工具和与开源恶意软件分析引擎
    Quark Engine 的集成。你可以从 [*https://github.com/skylot/jadx*](https://github.com/skylot/jadx)
    下载 jadx。
- en: In the GUI version of jadx, use **File** ▸ **Open Files** to open the malware
    sample to analyze. You should then see the app’s Java package structure in the
    navigation tree on the left-hand side of the interface ([Figure 3-1](ch03.xhtml#ch3fig1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jadx 的图形界面版本中，使用 **文件** ▸ **打开文件** 来打开恶意软件样本进行分析。然后，你应该能在界面左侧的导航树中看到应用的 Java
    包结构（[图 3-1](ch03.xhtml#ch3fig1)）。
- en: The large window on the right-hand side shows the decompiled code for the selected
    Java class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的大窗口显示了选定 Java 类的反编译代码。
- en: '![Image](../images/ch03fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch03fig01.jpg)'
- en: '*Figure 3-1: The jadx main window looks like a code IDE.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：jadx 主窗口看起来像一个代码 IDE。*'
- en: '**Malicious Code in the Permissions**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**权限中的恶意代码**'
- en: The first step of a static analysis should be to locate the malicious parts
    of the app as quickly as possible. Analysts each have their preferences about
    how to do this, as it is not an exact science. We will introduce you to four options
    that we use regularly. The first, described in this section, is to look at the
    permissions the app declares its intention to use and figure out how it might
    use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的第一步应该是尽快定位到应用中的恶意部分。分析师各有偏好，因为这并不是一门精确的科学。我们将在本节中介绍四种我们常用的选项。第一种方法是查看应用声明将要使用的权限，并弄清楚它可能如何使用这些权限。
- en: 'Permissions are often the first thing on people’s minds when they consider
    the security of Android apps. Apps must declare permissions in order to use sensitive
    Android APIs, and users must grant the necessary permissions to the apps before
    they can access those APIs. As this permission model relies on user interaction
    and consent, it is highly visible to everybody using Android phones. However,
    users and reverse engineers alike often draw the wrong conclusions about apps
    based on their permissions. The permission system is ultimately a gentleman’s
    agreement between the app and the user: the app declares that it will use a permission
    for an advertised purpose, but the operating system can’t check what the app actually
    does with it.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们考虑 Android 应用的安全性时，权限往往是首先想到的。应用必须声明权限才能使用敏感的 Android API，用户必须在应用访问这些 API
    之前授予必要的权限。由于这一权限模型依赖于用户互动和同意，它对所有使用 Android 手机的人来说都非常显眼。然而，无论是用户还是逆向工程师，往往会根据应用声明的权限得出错误的结论。权限系统最终是应用与用户之间的一种绅士协议：应用声明它会为了某个宣传的目的使用某个权限，但操作系统无法检查应用实际上如何使用该权限。
- en: Moreover, getting an accurate view of how an app uses permissions can be complicated.
    Apps can hide this information through techniques like reflection, as we show
    later in this chapter. Apps can also collude with each other to indirectly access
    more permissions than the user granted them. If an app doesn’t have permission
    to send SMS messages, it may ask another installed app to send messages on its
    behalf. In the worst case, malware could even use exploits to elevate its privileges
    outside the boundaries of the permission system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，准确地了解应用如何使用权限可能很复杂。应用可以通过反射等技术隐藏这些信息，正如我们在本章稍后所展示的那样。应用还可以通过相互协作，间接访问用户未授予的更多权限。如果一个应用没有发送短信的权限，它可能会请求另一个已安装的应用代表它发送短信。在最坏的情况下，恶意软件甚至可以利用漏洞提升其权限，超出权限系统的边界。
- en: Nevertheless, permissions still provide a reasonable way to gain insight into
    unknown malware. Malware that colludes with other apps or uses exploits to elevate
    its permission privileges is rare. Without any indicators that you’re dealing
    with such malware, it’s reasonable to treat the permissions declared by an app
    as the limits of its capabilities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，权限仍然是获得未知恶意软件洞察的一种合理方式。与其他应用串通或利用漏洞提升权限的恶意软件比较少见。在没有任何迹象表明你遇到这种恶意软件的情况下，合理的做法是将应用声明的权限视为其能力的限制。
- en: '***Viewing the Permissions***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看权限***'
- en: Apps must declare all permissions they want to use in their *Android Manifest.xml*
    file, found in the root folder of an Android app’s APK. [Figure 3-2](ch03.xhtml#ch3fig2)
    shows the beginning of the manifest file for our sample, which you can view in
    jadx by navigating to **Resources** ▸ **AndroidManifest.xml**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用必须在其 *Android Manifest.xml* 文件中声明它们要使用的所有权限，该文件位于 Android 应用 APK 的根文件夹中。[图
    3-2](ch03.xhtml#ch3fig2) 显示了我们示例的清单文件的开头，你可以在 jadx 中通过 **Resources** ▸ **AndroidManifest.xml**
    来查看它。
- en: '![Image](../images/ch03fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch03fig02.jpg)'
- en: '*Figure 3-2: Viewing app permissions in jadx*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：在 jadx 中查看应用权限*'
- en: 'Here, you can see some of the app’s requested permissions. Others, declared
    later in the file, are not visible in the screenshot. The sample uses `<uses-permission>`
    tags to declare its intent to use the following permissions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一些应用请求的权限。文件中稍后声明的其他权限在截图中不可见。示例使用 `<uses-permission>` 标签声明其使用以下权限的意图：
- en: '`INTERNET`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNET`'
- en: '`WAKE_LOCK`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAKE_LOCK`'
- en: '`RECEIVE_BOOT_COMPLETED`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECEIVE_BOOT_COMPLETED`'
- en: '`READ_CONTACTS`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_CONTACTS`'
- en: '`READ_PHONE_STATE`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_PHONE_STATE`'
- en: '`CHANGE_NETWORK_STATE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGE_NETWORK_STATE`'
- en: '`ACCESS_NETWORK_STATE`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_NETWORK_STATE`'
- en: '`BIND_GET_INSTALL_REFERRER_SERVICE`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_GET_INSTALL_REFERRER_SERVICE`'
- en: 'Using `<service>` tags, it also declares its intent to use these permissions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<service>` 标签，它还声明了使用这些权限的意图：
- en: '`BIND_NOTIFICATION_LISTENER_SERVICE`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_NOTIFICATION_LISTENER_SERVICE`'
- en: '`BIND_JOB_SERVICE`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_JOB_SERVICE`'
- en: For malware analysis, not all permissions are equally important. For example,
    the `WAKE_LOCK` permission doesn’t seem particularly interesting, as it refers
    to APIs for keeping devices awake or waking them up from sleep. The `INTERNET`
    permission is also not useful; nearly every app uses it, so it doesn’t help us
    differentiate between malicious and benign apps. On the other hand, any of the
    data access permissions, whose names start with `READ_`, are potentially interesting.
    For example, why would a blood sugar metrics app need access to your contact list?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于恶意软件分析，并非所有权限都同样重要。例如，`WAKE_LOCK` 权限似乎并不特别有趣，因为它涉及的是保持设备唤醒或从睡眠状态唤醒设备的 API。`INTERNET`
    权限也没有什么用处；几乎每个应用都在使用它，因此它不能帮助我们区分恶意应用和良性应用。另一方面，任何以 `READ_` 开头的数据访问权限都可能是值得关注的。例如，为什么一款血糖监测应用需要访问你的联系人列表？
- en: '***Finding the APIs Gated by Permissions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找权限控制的 API***'
- en: To find malicious code based on an app’s declared permissions, you also need
    to know which Android APIs the permissions protect, or *gate*. Figuring this out
    is a surprisingly complex process, because no official reference for this information
    exists. Over the years, several academic research teams have tried to create Android
    API permission maps. This has also proved complicated—each new Android version
    introduces changes to the permission system, so keeping API maps up-to-date is
    a chore—but these maps can help you locate the permission-gated APIs. In 2016,
    researchers from Saarland University and Pennsylvania State University created
    such a map, which you can find at [*https://github.com/reddr/axplorer*](https://github.com/reddr/axplorer).
    Another option is the map created by researchers at Purdue University in 2018,
    which you can find at [*https://arcade-android.github.io/arcade*](https://arcade-android.github.io/arcade).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据应用声明的权限查找恶意代码，你还需要了解这些权限保护或*控制*哪些 Android API。弄清楚这一点是一个出乎意料的复杂过程，因为目前没有官方的参考资料。多年来，多个学术研究团队尝试创建
    Android API 权限图谱，但这也证明很复杂——每个新的 Android 版本都会对权限系统进行更改，因此保持 API 图谱的更新是一项繁琐的工作——不过，这些图谱可以帮助你定位由权限控制的
    API。2016年，萨尔大学和宾夕法尼亚州立大学的研究人员创建了这样的一个图谱，你可以在 [*https://github.com/reddr/axplorer*](https://github.com/reddr/axplorer)
    找到它。另一个选项是2018年由普渡大学研究人员创建的图谱，你可以在 [*https://arcade-android.github.io/arcade*](https://arcade-android.github.io/arcade)
    找到它。
- en: Unfortunately, jadx cannot automatically show the APIs gated by permissions.
    To quickly locate them in the app, you could use the command line version of jadx
    and then write a script that parses one of the permission maps to compare it with
    the app’s decompiled code. Over time, serious Android reverse engineers should
    build a more robust solution for this task.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，jadx无法自动显示由权限保护的API。为了快速定位它们，你可以使用命令行版本的jadx，然后编写一个脚本来解析其中一个权限映射并将其与应用程序的反编译代码进行比较。随着时间的推移，经验丰富的Android逆向工程师应该为这个任务构建一个更强大的解决方案。
- en: Another approach to locating permission-protected APIs in well-developed apps
    is to look for code that asks the user for consent to use these permissions. For
    example, you could search for strings containing *permission*, or for APIs used
    to request permission access. Well-written apps should ask users for consent right
    before they want to use an API, so the relevant code should be nearby.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定位在成熟应用中受权限保护的API的方法是，寻找要求用户同意使用这些权限的代码。例如，你可以搜索包含*permission*的字符串，或者搜索请求权限访问的API。编写良好的应用应该在准备使用API之前请求用户同意，因此相关代码应该就在附近。
- en: '***Analyzing the READ_CONTACTS Permission***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析READ_CONTACTS权限***'
- en: 'The `READ_CONTACTS` permission showcases another problem with permission maps:
    in Android, permissions don’t protect just APIs. They also protect the content
    providers that are the sources of sensitive data. While the permission maps mentioned
    in the previous section show some very obscure APIs behind the `READ_CONTACTS`
    permission, this permission usually just provides access to the user’s contact
    list through the content providers `content://contacts` or `content://com.android.contacts`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`READ_CONTACTS`权限展示了权限映射的另一个问题：在Android中，权限不仅仅保护API。它们还保护作为敏感数据源的内容提供者。虽然上一节提到的权限映射展示了一些在`READ_CONTACTS`权限下非常晦涩的API，但这个权限通常只是通过内容提供者`content://contacts`或`content://com.android.contacts`提供访问用户的联系人列表。'
- en: Thus, upon spotting this permission, you might first think that it might be
    used to steal someone’s contact list information. However, why wouldn’t a spyware
    app also request `READ_SMS`, `READ_CALENDAR`, and `READ_CALL_LOGS` permissions
    to steal SMS, calendar, and call information? Spyware that targets only contact
    list information certainly exists, but it’s much rarer than spyware that grabs
    more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看到这个权限时，你可能首先会认为它是用来窃取某人的联系人列表信息的。但是，为什么间谍软件应用程序不会同时请求`READ_SMS`、`READ_CALENDAR`和`READ_CALL_LOGS`权限，以窃取短信、日历和通话信息呢？只窃取联系人列表信息的间谍软件确实存在，但它比起窃取更多信息的间谍软件要稀少得多。
- en: In jadx, you can use the hotkey CTRL-SHIFT-F to search through all of an app’s
    code and resource files. But searching for *contact* and disabling case sensitivity
    in our sample returns only a few results, including the permission declaration
    in the manifest file. A couple of code lines, in classes in packages whose names
    start with *androidx.activity* or *com.google.android.gms*, appear to be APIs
    provided by Google. Using `READ_CONTACTS` to find malicious functionality didn’t
    work out for this sample.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在jadx中，你可以使用快捷键CTRL-SHIFT-F来搜索应用程序的所有代码和资源文件。但是，在我们的示例中，搜索*contact*并禁用大小写敏感性后，仅返回了少数几个结果，包括清单文件中的权限声明。几行代码，位于类中的包名以*androidx.activity*或*com.google.android.gms*开头，看起来是Google提供的API。使用`READ_CONTACTS`来查找恶意功能对于此示例并没有成功。
- en: Again, though, there are caveats to concluding that this permission *isn’t*
    used maliciously. The malicious code using `READ_CONTACTS` could be in an encrypted
    code section or otherwise hidden from our manual analysis. Or the code files described
    as Google APIs could have been injected with malicious code. Or maybe those code
    files have nothing to do with Google SDKs and are malicious code files that have
    adopted the standard Google class naming pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，得出这个权限*不是*恶意使用的结论时，仍然需要注意一些警告。使用`READ_CONTACTS`的恶意代码可能位于加密的代码段中，或者以其他方式隐藏，无法通过我们的手动分析检测到。或者，被描述为Google
    API的代码文件可能已经被注入恶意代码。又或者，这些代码文件与Google SDKs无关，而是采用了标准的Google类命名模式的恶意代码文件。
- en: Any of these could be true, but we recommend going broad first and deep later.
    As long as you have other ways to progress through an app, chase those leads down
    before delving into possible but unlikely scenarios like manipulated Google SDKs
    (which definitely exist in real malware but are rarely encountered in any individual
    malware sample). Later in this chapter, we will discover that this malware uses
    `READ_CONTACTS` after all. Its use is hidden from casual analysis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况中的任何一种都有可能发生，但我们建议先广泛搜寻，再深入分析。只要你有其他方式在应用中推进，就应该先追踪那些线索，再去探讨那些可能但不太可能的情况，比如被篡改的
    Google SDK（尽管它们确实存在于真实的恶意软件中，但在任何单独的恶意软件样本中很少遇到）。本章后面我们将发现，事实上，这个恶意软件最终还是使用了 `READ_CONTACTS`
    权限。其使用方式对普通分析是隐藏的。
- en: '***Analyzing the BIND_NOTIFICATION_LISTENER_SERVICE Permission***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析 BIND_NOTIFICATION_LISTENER_SERVICE 权限***'
- en: Another interesting permission in the sample is `BIND_NOTIFICATION_LISTENER_SERVICE`,
    which allows apps to access the notifications shown to the user by all other apps.
    Despite its seemingly harmless functionality, malware often abuses this permission,
    as app notifications can contain sensitive information that malware likes to steal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的另一个有趣权限是 `BIND_NOTIFICATION_LISTENER_SERVICE`，它允许应用访问所有其他应用向用户展示的通知。尽管这个功能看似无害，但恶意软件常常滥用这个权限，因为应用的通知可能包含敏感信息，而恶意软件喜欢窃取这些信息。
- en: This permission is always tied to a service that receives updates about new
    notifications. [Listing 3-1](ch03.xhtml#ch3lis1) shows how our sample app declares
    the use of the permission and its associated service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个权限总是与一个接收新通知更新的服务相关联。[清单 3-1](ch03.xhtml#ch3lis1) 展示了我们的示例应用如何声明该权限及其相关服务的使用。
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: The declaration of the notification listener service, which receives
    information about incoming notifications*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：声明通知监听服务，该服务接收关于传入通知的信息*'
- en: The name of the service class is declared as `com.bp.statis.bloodsugar.PE`,
    but if you look for this class in the jadx file browser, you won’t be able to
    find it. That’s noteworthy. Why would the app declare a service for which no code
    is available? It could be a bug in the app, but later in this chapter we will
    discover that the class is in fact hidden from analysis. For now there is little
    we can do, as we are unable to locate the service code. For brevity, we leave
    a similar analysis of the other declared permissions as an exercise for the reader.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类的名称声明为 `com.bp.statis.bloodsugar.PE`，但是如果你在 jadx 文件浏览器中搜索这个类，你将无法找到它。这一点值得注意。为什么应用会声明一个没有代码可用的服务？这可能是应用的
    bug，但在本章后面，我们会发现这个类实际上是隐藏在分析之外的。现在我们暂时无法做什么，因为我们无法找到服务代码。为了简洁起见，其他声明的权限的类似分析留给读者练习。
- en: '**Malicious Code in App Entry Points**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用入口点中的恶意代码**'
- en: Android applications have a surprisingly large number of *entry points*, or
    parts of the code where the Android operating system starts executing the app.
    Common entry points are exported activities (including the app’s main activity);
    broadcast receivers, which handle messages sent by the operating system or other
    apps; services defined by the app to execute long-running operations; and subclasses
    of the `android.app.Application` class. Looking at code at these entry points
    can be a fruitful way to find malicious code, as harmful functionality likes to
    run sooner rather than later. Why wait for the user to interact with an app for
    10 minutes when you can steal their information right away, when they launch the
    app?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序有大量的*入口点*，即 Android 操作系统开始执行应用程序的代码部分。常见的入口点包括导出的活动（包括应用的主活动）；广播接收器，用于处理操作系统或其他应用发送的消息；由应用定义的服务，用于执行长时间运行的操作；以及
    `android.app.Application` 类的子类。查看这些入口点的代码可以是发现恶意代码的有效途径，因为有害功能通常喜欢尽早执行，而不是晚些时候。为什么要等用户与应用互动
    10 分钟后再窃取他们的信息呢？只要用户启动应用，恶意代码就可以立即开始工作。
- en: Still, not all entry points are equally likely to harbor malicious code, and
    we should first consider those that are more commonly used in malware. For example,
    while every malicious and benign app has a main activity, looking there for malicious
    functionality is likely not a good start. On the other hand, looking at the broadcast
    receiver for the `BOOT_COMPLETED` events may be more promising. Malware likes
    to gain persistence on devices, and having the system execute the malware every
    time the device reboots is a common way to achieve that goal.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有入口点都有同等的可能性藏有恶意代码，我们应该首先考虑那些在恶意软件中更常见的入口点。例如，尽管每个恶意应用和良性应用都有一个主活动，但在主活动中寻找恶意功能可能不是一个好的开始。另一方面，查看用于`BOOT_COMPLETED`事件的广播接收器可能更有前景。恶意软件喜欢在设备上获得持久性，并且让系统在每次设备重启时执行恶意软件是实现这一目标的常见方式。
- en: '***Exported Activities***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导出活动***'
- en: In Android apps, *activities* are the key mechanism for presenting user interfaces.
    They’re best thought of as screens or dialogs. When a user launches an app, the
    first thing they usually see is the main activity. User interactions with the
    current activity may trigger new activities, like the next step in a workflow,
    a settings activity, or a file sharing activity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 应用中，*活动*是呈现用户界面的关键机制。它们最好被认为是屏幕或对话框。当用户启动应用时，他们通常首先看到的是主活动。用户与当前活动的互动可能会触发新的活动，比如工作流中的下一步、设置活动或文件共享活动。
- en: Not all activities are entry points into applications. To identify those, we
    need to distinguish between so-called *exported* and *non-exported* activities.
    Activities marked in the manifest file as `android:exported=”true”` can be started
    from outside the current app and so are considered entry points. Activities marked
    as `android:exported=”false”` can only be started from within the current app
    and are not entry points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有活动都是应用程序的入口点。为了识别这些活动，我们需要区分所谓的*导出活动*和*非导出活动*。在清单文件中标记为`android:exported="true"`的活动可以从应用外部启动，因此被视为入口点。标记为`android:exported="false"`的活动只能从应用内部启动，不能作为入口点。
- en: However, finding exported activities can be tricky. Before Android 12, developers
    could omit the `android:exported` tag from activity declarations. In those cases,
    whether the activity’s default value was `true` or `false` depended on other configuration
    properties. This proved confusing to app developers and led to mistakes and security
    vulnerabilities due to accidentally exported activities, which is why Android
    versions 12 and beyond require explicit declarations for all activities of an
    app. For analysis of apps developed for earlier versions (prior to Android API
    31), our recommendation is to learn the rules once and encode them in a small
    helper tool that can highlight exported activities. Otherwise, reverse engineers
    may make the same mistakes that app developers made.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，找到导出活动可能会很棘手。在 Android 12 之前，开发者可以省略活动声明中的`android:exported`标签。在这些情况下，活动的默认值是`true`还是`false`取决于其他配置属性。这让应用开发者感到困惑，并导致了错误和安全漏洞，因为活动可能会意外地被导出，这也是为什么
    Android 12 及更高版本要求所有应用活动都必须明确声明的原因。对于为早期版本（Android API 31 之前）开发的应用，我们的建议是学习这些规则，并将其编码到一个小的辅助工具中，以便高亮显示导出活动。否则，逆向工程师可能会犯与应用开发者相同的错误。
- en: 'Our sample declares only one interesting activity: its main activity, shown
    in [Listing 3-2](ch03.xhtml#ch3lis2). The other activities are activities from
    Google SDKs, and for now, we consider them legitimate and not maliciously manipulated.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例只声明了一个有趣的活动：它的主活动，如[列表 3-2](ch03.xhtml#ch3lis2)所示。其他活动是来自 Google SDK 的活动，目前我们认为它们是合法的，并没有被恶意篡改。
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: The declaration of our sample’s main activity*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：我们示例的主活动声明*'
- en: The XML declaration code of main activities is full of boilerplate code. For
    us, the only important part is the name of the activity, `com.bp.statis.bloodsugar.MainActivity`.
    Double-clicking this name in jadx takes you straight to its definition. Unfortunately,
    it consists of more than 600 lines of user interface code without any interesting
    features. As the app doesn’t have any other exported activities, there’s nothing
    more to look for in this section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 主活动的 XML 声明代码充满了模板代码。对我们来说，唯一重要的部分是活动的名称，`com.bp.statis.bloodsugar.MainActivity`。在
    jadx 中双击这个名称会直接带你到它的定义。不幸的是，它由超过 600 行的用户界面代码组成，没有任何有趣的功能。由于该应用没有其他导出活动，因此这一部分没有什么值得进一步查看的内容。
- en: '***Broadcast Receivers***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***广播接收器***'
- en: Another key concept in Android is *broadcast receivers*, part of Android’s messaging
    system. All Android apps can send messages (broadcasts) to each other or themselves,
    and broadcast receivers receive and handle incoming messages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Android 中的另一个关键概念是*广播接收器*，它是 Android 消息系统的一部分。所有 Android 应用程序都可以相互或向自己发送消息（广播），而广播接收器负责接收和处理这些传入的消息。
- en: 'For reverse engineering, broadcast receivers fall into two distinct categories:
    they can either be declared in the manifest file (so-called *manifest-registered
    receivers*) or registered programmatically when an app is running (*context-registered
    receivers*). The ones declared in the manifest are easy to spot, as they cannot
    be hidden from malware analysts. The ones registered at runtime are not so easy
    to locate, as they can be hidden by encrypted or obfuscated code that makes the
    API calls necessary to set up the receivers.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逆向工程，广播接收器分为两种不同的类别：它们可以是在清单文件中声明的（所谓的*清单注册接收器*），也可以是在应用程序运行时通过编程注册的（*上下文注册接收器*）。在清单中声明的接收器很容易被发现，因为它们无法被恶意软件分析师隐藏。运行时注册的接收器则不那么容易定位，因为它们可能被加密或混淆的代码隐藏，而这些代码会执行设置接收器所需的
    API 调用。
- en: Starting with Android API 26, the system uses only manifest-declared receivers
    to wake up apps. Context-registered receivers can operate only when an app is
    already running. Thus, to find entry points into applications, we should consider
    only manifest-declared receivers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android API 26 开始，系统只使用清单声明的接收器来唤醒应用程序。上下文注册的接收器只能在应用程序已经运行时操作。因此，为了寻找应用程序的入口点，我们应该只考虑清单声明的接收器。
- en: While our sample’s manifest file declares eight broadcast receivers using the
    `<receiver>` tag, they all point to classes that seem to come from standard Google
    SDKs. Even though broadcast receivers don’t appear to provide any useful entry
    points here, many malware samples do use them. For example, registering to receive
    `BOOT_COMPLETED` messages is a popular way for malware to start running again
    after a system reboot. Later in this chapter, you’ll also see that our sample
    sets up context-registered receivers for which no trace can be found in the manifest
    file. In particular, the malware registers a `RECEIVE_SMS` receiver to intercept
    incoming SMS messages and steal one-time passwords.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们示例的清单文件使用 `<receiver>` 标签声明了八个广播接收器，但它们都指向看似来自标准 Google SDK 的类。即使广播接收器在这里似乎没有提供任何有用的入口点，许多恶意软件样本仍然会使用它们。例如，注册接收
    `BOOT_COMPLETED` 消息是一种常见的恶意软件在系统重启后重新运行的方式。在本章后面，你还会看到我们的示例为上下文注册的接收器设置了没有在清单文件中找到的痕迹。特别是，恶意软件注册了一个
    `RECEIVE_SMS` 接收器，用于拦截传入的短信并窃取一次性密码。
- en: '***Services***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***服务***'
- en: '*Services* are the default way for apps to execute long-running operations
    in the background. Developers must declare all services in an app’s manifest file,
    making them easily discoverable. While services are not entry points into apps
    (all services must be launched by the running app itself), they are great entry
    points into reverse engineering as the service class declarations cannot be hidden
    or obfuscated and their code forms distinct units of functionality that can be
    analyzed in isolation. Many malware samples use these to perform malicious operations,
    so looking for service entry points is a quick way to find such code.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*是应用程序在后台执行长时间运行操作的默认方式。开发人员必须在应用程序的清单文件中声明所有服务，使它们容易被发现。尽管服务不是应用程序的入口点（所有服务必须由正在运行的应用程序本身启动），但它们是逆向工程的良好入口点，因为服务类声明无法被隐藏或混淆，并且它们的代码形成了可以单独分析的独立功能单元。许多恶意软件样本使用这些服务执行恶意操作，因此寻找服务入口点是发现此类代码的快速方式。'
- en: Our sample declares nine services, of which eight once again seem to belong
    to Google SDKs. The one remaining service is `com.bp.statis.bloodsugar.PE`, which
    we previously discussed when analyzing the permissions. This service receives
    and intercepts incoming notifications from all apps on the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例声明了九个服务，其中八个似乎仍属于 Google SDK。剩下的一个服务是 `com.bp.statis.bloodsugar.PE`，我们在分析权限时曾讨论过。该服务接收并拦截系统中所有应用程序的传入通知。
- en: '***Application Subclasses***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用程序子类***'
- en: Other legitimate entry points into Android apps, though a little obscure, are
    subclasses of the `android.app.Application` class. By default, all Android apps
    have an implementation of this Java class. Apps that need to deviate from default
    app behavior can subclass this default class. If an app uses such a subclass,
    you can find its name in the `<application>` tag in the manifest file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他合法的Android应用入口点，虽然有些晦涩，是`android.app.Application`类的子类。默认情况下，所有Android应用都有这个Java类的实现。需要偏离默认应用行为的应用可以继承这个默认类。如果一个应用使用了这样的子类，你可以在清单文件的`<application>`标签中找到它的名称。
- en: 'Our sample does declare a subclass of the default `android.app.Application`
    implementation. Within the `<application>` tag, you should see the following declaration,
    where the fully qualified name specified as the value of the `android:name` attribute
    overrides the default class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例确实声明了默认`android.app.Application`实现的一个子类。在`<application>`标签中，你应该看到如下声明，其中`android:name`属性指定的完全限定名覆盖了默认类：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on its path name, this `androidx.multidex.MultiDexApplication` class seems
    to come from a default Google SDK. Digging into the official documents, one can
    learn that it was introduced to get around size limits for large apps. In our
    experience, apps today increasingly make use of this attribute, so seeing it is
    fairly common.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其路径名，`androidx.multidex.MultiDexApplication`类似乎来自一个默认的Google SDK。通过深入官方文档，可以了解到它是为了绕过大型应用的大小限制而引入的。根据我们的经验，现在越来越多的应用程序使用这个属性，所以看到它是非常常见的。
- en: However, our sample has maliciously modified this class. Double-clicking the
    class name in jadx opens the code in [Listing 3-3](ch03.xhtml#ch3lis3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的示例已经恶意地修改了这个类。在jadx中双击类名会打开[清单 3-3](ch03.xhtml#ch3lis3)中的代码。
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-3: Malicious code is started from an android.app.Application subclass.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：恶意代码从一个android.app.Application子类启动。*'
- en: Most of the code is boilerplate, except for the line `new b(this).o()`. The
    instantiation of an object of class `d.b` and the calling of its method `o` is
    highly unusual. Double-clicking either `d` or `o` in jadx takes you to heavily
    obfuscated code. We will revisit that code later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是模板代码，只有`new b(this).o()`这一行比较特殊。创建`d.b`类的对象并调用它的方法`o`是非常不寻常的。在jadx中双击`d`或`o`会带你到严重混淆的代码。我们稍后将回顾这段代码。
- en: '**Hiding Malicious Code**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏恶意代码**'
- en: If we hadn’t already found a hook into the malicious code, another option could
    be to look for anti-analysis techniques and attempts to hide code from malware
    analysts. This technique is useful partly because malicious code often tries to
    hide and partly because such analysis broadens our understanding of an app and
    ensures that we don’t miss any of its key functionality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有找到进入恶意代码的钩子，另一种选择是寻找反分析技术和试图隐藏代码的手段。这项技术有用，部分原因是恶意代码通常试图隐藏，以及因为这种分析可以拓宽我们对应用的理解，确保我们不会遗漏其关键功能。
- en: 'At a high level, we recommend looking for the following common strategies:
    dynamic and static anti-analysis techniques, reflection and other dynamic code
    loading techniques, non-Java code usage, and encryption and obfuscation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，我们建议寻找以下常见的策略：动态和静态反分析技术、反射及其他动态代码加载技术、非Java代码的使用，以及加密和混淆。
- en: '***Anti-Analysis Techniques***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反分析技术***'
- en: Anti-analysis techniques try to throw off static or dynamic analysis and can
    take many forms. Most malware includes at least a few of these measures to make
    it harder for malware analysts to understand the specimen, as well as to determine
    whether it is probably under observation or running on a real user’s device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 反分析技术旨在让静态或动态分析变得困难，并且有多种形式。大多数恶意软件都包含至少几种这些措施，以使恶意软件分析师更难理解样本，以及判断它是否可能在被监视或运行在真实用户的设备上。
- en: Discovering and understanding anti-analysis techniques is a science in itself.
    One way to get started is to read the “Defense Evasion” section of the MITRE ATT&CK
    framework for Android, a freely available standard to document malware techniques.
    Over time, we recommend that reverse engineers build tools to pinpoint anti-analysis
    techniques in apps. Doing this work manually is difficult and time-consuming,
    as hundreds of individual anti-analysis techniques exist and are publicly documented.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 发现并理解反分析技术本身就是一门学问。一个入门的方式是阅读MITRE ATT&CK框架中的“防御规避”部分，这是一个免费的标准，用于记录恶意软件技术。随着时间的推移，我们建议逆向工程师构建工具来识别应用中的反分析技术。手动做这项工作是困难且耗时的，因为有成百上千种反分析技术存在，并且它们已经公开记录。
- en: Static analysis can be particularly helpful in detecting dynamic anti-analysis
    techniques. Anti-analysis techniques designed to thwart dynamic analysis commonly
    focus on understanding the environment in which the malware runs. Some try to
    detect analysis tools, such as emulators, debuggers, or sandboxes, and avoid running
    if those tools are detected. Others use environmental properties of the device
    to try to figure out whether they are running in a security analysis system. For
    example, they might wait a certain amount of time before executing malicious functionality.
    They might also focus on geographic properties of the device, for example to find
    out whether it’s located in a certain country or connected to a certain mobile
    carrier. Some malware checks for the device’s language or the user’s time zone.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析在检测动态反分析技术方面尤其有用。旨在破坏动态分析的反分析技术通常聚焦于理解恶意软件运行的环境。有些技术试图检测分析工具，如模拟器、调试器或沙箱，并避免在检测到这些工具时运行。另一些技术则利用设备的环境属性，尝试判断它们是否在安全分析系统中运行。例如，它们可能会等待一段时间后再执行恶意功能。它们也可能关注设备的地理属性，例如找出设备是否位于某个特定国家或连接到某个特定的移动运营商。一些恶意软件会检查设备的语言或用户的时区。
- en: Smarter malware apps use more sophisticated methods that consider information
    from outside the device. For example, we have seen apps that check whether they
    are still published on Google Play or whether a connection to their servers comes
    from the IP range of a given country. A particularly common technique these days
    is to check whether an app was installed through an ad click that the malware
    author paid for. The app will execute malicious functionality only if the user
    installed the app from this ad; automated security tools that didn’t install the
    app by clicking on the ad won’t be able to trigger its malicious payload. This
    technique can get tricky if parts of the ad campaign’s properties are used as
    decryption keys for later stages of code. If you don’t have information from the
    ad click, you may not be able to decrypt parts of the malicious code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更智能的恶意软件应用使用更复杂的方法，考虑来自设备外部的信息。例如，我们曾见过一些应用会检查它们是否仍然在 Google Play 上发布，或者它们的服务器连接是否来自某个特定国家的
    IP 范围。如今，尤其常见的一种技术是检查应用是否通过恶意软件作者支付的广告点击安装。如果用户是通过这个广告安装的应用，应用才会执行恶意功能；那些没有通过点击广告安装该应用的自动化安全工具将无法触发其恶意负载。如果广告活动的某些属性被用作后续阶段代码的解密密钥，这项技术可能会变得复杂。如果没有广告点击的信息，你可能无法解密部分恶意代码。
- en: Static anti-analysis techniques focus on denying static analysis tools the ability
    to inspect and understand code. In Android malware, this commonly means hiding
    code, encrypting code, or loading code in later stages to make sure that it is
    not even available for static analysis at all. In addition, Android malware commonly
    uses commercial or freely available *app packers*, which take an app and encrypt
    or compress its original code. Many off-the-shelf app packers exist for Android,
    usually marketed as tools to protect intellectual property. Their use to protect
    Android apps is particularly widespread in China, and many available app packers
    originate from there.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 静态反分析技术的重点是拒绝静态分析工具检查和理解代码。在 Android 恶意软件中，这通常意味着隐藏代码、加密代码或在后期阶段加载代码，以确保代码完全无法进行静态分析。此外，Android
    恶意软件通常使用商业或免费提供的 *应用打包工具*，这些工具可以对应用进行加密或压缩其原始代码。市场上有许多现成的 Android 应用打包工具，通常以保护知识产权为目的进行营销。在中国，这些工具用于保护
    Android 应用的情况尤其广泛，许多可用的应用打包工具也源自中国。
- en: These tools often apply sophisticated static anti-analysis techniques. To make
    the original code harder to understand, they might implement control flow obfuscation
    (garbling the original flow of code through an app) or data flow obfuscation (making
    it harder to follow how variables interact with each other). The most sophisticated
    app packers even take original app code and recompile it into their own custom
    code. Understanding such transformed code requires knowledge of the bytecode defined
    by the packer and the abstract machine that interprets it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具通常应用复杂的静态反分析技术。为了使原始代码更难理解，它们可能会实现控制流混淆（通过应用程序混淆代码的原始流向）或数据流混淆（让跟踪变量之间如何交互变得更加困难）。最复杂的应用打包工具甚至会将原始应用代码重新编译成它们自己的自定义代码。理解这种转化后的代码需要了解由打包工具定义的字节码及其解释器的抽象机器。
- en: '***Reflection***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反思***'
- en: Reflection is another common anti-analysis technique. Many modern Android malware
    samples split malicious functionality across multiple dynamically loaded stages
    that operate like plug-ins. Usually, the first stage, directly embedded in the
    app, is small and benign. It often does nothing but observe its runtime environment.
    If it doesn’t detect any analysis tools, it loads the second stage, which contains
    more malicious functionality.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是另一种常见的反分析技术。许多现代 Android 恶意软件样本将恶意功能分割成多个动态加载的阶段，这些阶段像插件一样运行。通常，第一阶段直接嵌入到应用程序中，体积小且无害。它通常什么也不做，只是观察它的运行时环境。如果它没有检测到任何分析工具，它就会加载第二阶段，第二阶段包含更多的恶意功能。
- en: The Java reflection APIs, defined in the Java package *java.lang.reflect*, are
    used to dynamically look up, instantiate, and invoke classes and methods. They
    allow apps to dynamically load code that may not be present at compile time, such
    as plug-ins. Benign apps often use these APIs, too. For instance, they might load
    benign plug-ins, select between different APIs depending on the current operating
    system version, or access private APIs that are supposed to be hidden from apps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Java 反射 API，定义在 Java 包 *java.lang.reflect* 中，用于动态查找、实例化和调用类和方法。它们允许应用程序动态加载在编译时可能不存在的代码，例如插件。良性的应用程序也常常使用这些
    API。例如，它们可能加载良性的插件，或根据当前的操作系统版本在不同的 API 之间进行选择，或访问本应对应用程序隐藏的私有 API。
- en: Nevertheless, looking for reflection APIs is effective in malware analysis because
    the use of reflection cannot be hidden. Moreover, distinguishing between benign
    and malicious uses of reflection is often easy. In nearly all cases, benign reflection
    supplies constant arguments to the reflection APIs. For example, apps might look
    up private Android APIs by name. Malicious reflection typically uses non-constant
    arguments that are stitched together at runtime, or encrypted or obfuscated strings
    that it decodes right before passing them to the reflection APIs. That makes it
    very easy for human reviewers to quickly sort through uses of reflection and find
    the ones that are most likely malicious.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在恶意软件分析中，寻找反射 API 是有效的，因为反射的使用无法被隐藏。而且，区分反射的良性和恶意使用通常是很容易的。在几乎所有情况下，良性的反射都会提供恒定的参数给反射
    API。例如，应用程序可能通过名称查找私有的 Android API。恶意反射通常使用非恒定参数，这些参数在运行时拼接在一起，或者是加密或混淆的字符串，它会在传递给反射
    API 之前解码。这使得人工审查员可以很容易地快速筛选出反射的使用，并找到最有可能是恶意的那些。
- en: In decompiled jadx code, all classes that use reflection begin with an import
    statement for the reflection API, so using the search dialog to look for `import
    java.lang.reflect` should return all of these classes. In the case of our sample
    app, the search dialog returns 293 results, showing just how common reflection
    is. Assuming once again that standard SDK classes haven’t been maliciously modified,
    we can discard all results in Java packages *androidx.**, *kotlin.**, and *com.google.**.
    That leaves a few hits in packages starting with *b.**, *d.**, and *e.**. We already
    identified the package *d.** as a likely candidate for malicious code, so let’s
    look at the other two packages first.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在反编译的 jadx 代码中，所有使用反射的类都以导入反射 API 的语句开始，因此使用搜索对话框查找 `import java.lang.reflect`
    应该能返回所有这些类。在我们的示例应用程序中，搜索对话框返回了 293 个结果，显示出反射的常见程度。假设标准 SDK 类没有被恶意修改，我们可以丢弃所有位于
    Java 包 *androidx.**、*kotlin.** 和 *com.google.** 下的结果。这时剩下的几个结果则出现在以 *b.**、*d.**
    和 *e.** 开头的包中。我们已经将 *d.** 包识别为可能含有恶意代码的候选包，所以先查看另外两个包。
- en: The randomly selected class `b.j.k` shows an example of reflection code that
    is probably benign. As shown in [Listing 3-4](ch03.xhtml#ch3lis4), the reflection
    code tries to load some class whose name contains the string `_LifecycleAdapter`.
    This code does not seem obfuscated or dynamic enough for malicious reflection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择的类 `b.j.k` 展示了一个可能是良性的反射代码示例。如 [清单 3-4](ch03.xhtml#ch3lis4) 所示，反射代码尝试加载一个类，其名称包含字符串
    `_LifecycleAdapter`。这段代码看起来没有混淆或足够动态，因此不太可能是恶意反射。
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-4: A benign use of reflection in the app*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-4：应用程序中良性的反射使用*'
- en: 'More importantly, the class has two significant strings: `_LifecycleAdapter`
    and `The observer class has some methods that use newer...`, the latter of which
    we have omitted from the listing for brevity. A quick web search shows that these
    strings are taken from a standard Android class called `androidx.lifecycle.ClassesInfoCache`,
    meaning this code is likely benign.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，该类包含两个重要字符串：`_LifecycleAdapter`和`The observer class has some methods that
    use newer...`，后者为了简洁起见我们在列表中省略了。快速的网络搜索显示，这些字符串来自一个标准的 Android 类`androidx.lifecycle.ClassesInfoCache`，意味着这段代码很可能是无害的。
- en: Most code obfuscators leave the package hierarchy intact when transforming original
    code into obfuscated code. Thus, sibling packages in obfuscated code are likely
    sibling packages in the original code. If the class `b.j.k` is `androidx.lifecycle.ClassesInfoCache`,
    it is highly likely that all classes in the package *b.j* belong to `androidx.lifecycle`
    and that all classes in *b.** belong to `androidx.*`. We’ll make this assumption
    for now, declaring all uses of reflection in *b.** safe and moving on. Similar
    analysis of the reflection code found in the *e.** package shows that this is
    likely a standard library, too.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码混淆器在将原始代码转化为混淆代码时，保持了包层次结构不变。因此，在混淆代码中的兄弟包很可能也是原始代码中的兄弟包。如果类`b.j.k`是`androidx.lifecycle.ClassesInfoCache`，那么所有属于包*b.j*的类很可能都属于`androidx.lifecycle`，并且包*b.**中的所有类也很可能都属于`androidx.*`。我们现在假设这一点，声明在*b.**中使用反射的所有代码是安全的，然后继续进行。对在*e.**包中发现的反射代码进行类似分析，表明这也很可能是一个标准库。
- en: In addition to the Java reflection APIs in the *java.lang.reflect* package,
    Android provides some other code loading APIs often used by benign and malicious
    apps alike. The two most common of these are `dalvik.system.DexClassLoader` and
    `dalvik.system.DexFile` (deprecated in Android API 26). These APIs can load entire
    Android code files and are frequently used to load plug-ins. Java and Android
    have other related APIs, commonly referred to as *ClassLoader APIs*. We recommend
    developing an understanding of these, or even better, an automated tool to surface
    them in apps. In particular, APIs for loading code from byte arrays in memory
    rather than files on disk are becoming more popular in Android malware. Using
    this technique, they can avoid leaving behind artifacts that security researchers
    could discover.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*java.lang.reflect*包中的 Java 反射 API，Android 还提供了一些其他的代码加载 API，这些 API 被良性和恶意应用程序都常常使用。最常见的两个
    API 是`dalvik.system.DexClassLoader`和`dalvik.system.DexFile`（在 Android API 26 中已废弃）。这些
    API 可以加载整个 Android 代码文件，并且经常用于加载插件。Java 和 Android 还有其他相关的 API，通常被称为*ClassLoader
    API*。我们建议开发者理解这些 API，或者更好的是，开发一个自动化工具来在应用中检测它们。尤其是从内存中的字节数组而非磁盘文件加载代码的 API 在 Android
    恶意软件中变得越来越流行。通过这种技术，恶意软件可以避免留下安全研究人员可能发现的痕迹。
- en: Try searching our sample app for `dalvik.system.Dex`. It should return just
    a single use outside of the standard SDKs, once again in the probably malicious
    *d.** package.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在我们的示例应用程序中搜索`dalvik.system.Dex`。它应该仅在标准 SDK 之外返回一个使用，再次出现在可能恶意的*d.**包中。
- en: '***Non-Java Code***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非 Java 代码***'
- en: Modern Android applications can be written in many programming languages and
    frameworks other than Java. Examples include Flutter, Kotlin, Xamarin.Android,
    and ReactNative. Malware developers intentionally use these newer technologies
    to make malware analysis harder.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Android 应用程序可以用除了 Java 以外的许多编程语言和框架编写。比如 Flutter、Kotlin、Xamarin.Android 和
    ReactNative。恶意软件开发者故意使用这些新技术来使恶意软件分析更加困难。
- en: Some malware developers have started building their malware entirely in these
    languages. This simple choice already makes analysis more difficult, as most Android
    reverse engineers likely have good tooling for Java apps but not for those written
    in other languages. Other malware developers have continued to use Java as their
    main programming language while strategically developing malicious portions of
    the app in alternative languages. To detect this malicious activity, automated
    analysis tools need the ability to understand control and data flow between parts
    of code written in different languages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件开发者已经开始完全使用这些语言来构建恶意软件。这个简单的选择已经使分析变得更加困难，因为大多数 Android 逆向工程师可能拥有很好的 Java
    应用分析工具，但对于用其他语言编写的应用并没有相应的工具。其他恶意软件开发者则继续使用 Java 作为主要编程语言，同时战略性地使用其他语言开发恶意部分。为了检测这些恶意活动，自动化分析工具需要能够理解不同语言编写的代码部分之间的控制流和数据流。
- en: The two most common programming languages we see strategically used by malware
    are JavaScript and native ARM code. JavaScript is most likely used less as a pure
    anti-analysis technique and more as a way to interact with websites. Native ARM
    code, which is developed in C, C++, or other languages that compile to ARM code,
    is regularly used to hide malicious functionality. For example, it’s common for
    malware to ship native code binary files that contain just a single decryption
    routine called from Java code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到恶意软件策略性使用的两种最常见编程语言是 JavaScript 和原生 ARM 代码。JavaScript 更可能作为与网站交互的方式使用，而非纯粹的反分析技术。原生
    ARM 代码是使用 C、C++ 或其他编译成 ARM 代码的语言开发的，通常用于隐藏恶意功能。例如，恶意软件常常会发布只包含单一解密例程的原生代码二进制文件，这个解密例程是通过
    Java 代码调用的。
- en: We recommend looking for alternative languages during Android malware analysis,
    with a particular focus on JavaScript and native ARM code. Malware apps can hide
    the use of these alternative languages, but they often leave telltale signs. For
    example, you’ll often find native code in the APK file’s *lib* folder. Java code
    keywords for interacting with native code such as `native` or the API `System.loadLibrary`
    also provide strong indicators that the app uses native ARM code. Look for JavaScript
    in WebView objects, in particular those declaring a JavaScript interface through
    the API `addJavascriptInterface`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在 Android 恶意软件分析中寻找替代语言，特别关注 JavaScript 和原生 ARM 代码。恶意软件应用可能会隐藏这些替代语言的使用，但它们通常会留下明显的痕迹。例如，你经常可以在
    APK 文件的 *lib* 文件夹中找到原生代码。用于与原生代码交互的 Java 关键字，如 `native` 或 API `System.loadLibrary`，也提供了强烈的指示，表明应用使用了原生
    ARM 代码。查找 WebView 对象中的 JavaScript，特别是那些通过 API `addJavascriptInterface` 声明 JavaScript
    接口的对象。
- en: Our sample does not have any obvious indicators suggesting the use of native
    ARM code or JavaScript. There are no native code asset files, uses of any of the
    APIs mentioned above, or keywords that would hint at their presence. Later, you’ll
    learn that the app does make use of JavaScript, but that use is hidden and not
    easily discovered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样本中没有明显的指示表明使用了原生 ARM 代码或 JavaScript。没有原生代码资产文件，也没有使用上述提到的任何 API，或者任何能暗示它们存在的关键字。稍后，你将了解到应用确实使用了
    JavaScript，但这种使用是隐藏的，难以发现。
- en: '***Encryption and Encoding***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密与编码***'
- en: Malware developers love to encrypt and encode strings. In fact, the use of cryptography
    APIs can provide a hint about the location of malicious functionality. Malware
    developers often use the default Java implementations of encryption algorithms
    like AES or RSA from the *javax.crypto* package. Use of *java.util.Base64* or
    *android.util.Base64* is also common. Looking for references to these packages
    can help you quickly locate interesting methods, such as those that decrypt communication
    received from command-and-control servers. However, other than in benign Google
    SDKs, our sample does not make obvious use of any APIs in *javax.crypto*. It more
    often uses *java.util.Base64*, including in the obfuscated package *b.**, which
    we previously declared harmless.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件开发者喜欢加密和编码字符串。实际上，使用加密 API 可以提供恶意功能位置的线索。恶意软件开发者通常会使用 *javax.crypto* 包中的默认
    Java 加密算法实现，比如 AES 或 RSA。使用 *java.util.Base64* 或 *android.util.Base64* 也很常见。查找对这些包的引用可以帮助你快速定位有趣的方法，例如那些解密从命令控制服务器接收到的通信。然而，除了在无害的
    Google SDK 中，我们的样本并没有明显使用 *javax.crypto* 中的任何 API。它更多地使用 *java.util.Base64*，包括在之前声明为无害的混淆包
    *b.** 中。
- en: When reverse engineers get stuck, they might start looking at strings and method
    names used in apps, hoping to spot interesting leads. This technique takes only
    a couple of minutes and can lead to new discoveries. For example, malware developers
    may have forgotten to remove sensitive log strings, or the search might reveal
    an API call to read the user’s SMS messages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当逆向工程师遇到瓶颈时，他们可能会开始查看应用中的字符串和方法名称，希望能发现有趣的线索。这项技术只需几分钟时间，可能会带来新的发现。例如，恶意软件开发者可能忘记删除敏感的日志字符串，或者搜索可能会揭示出一个读取用户短信的
    API 调用。
- en: However, without careful planning, searching for strings and method names can
    be a waste of time, as it depends more on luck than on expertise. To structure
    your search, you could, for example, develop a regular expression to return all
    the interesting strings and method names that you can think of. This might include
    the names of SMS or contact list APIs, as well as strings that match URLs or interesting
    content providers. The regular expression doesn’t have to be perfect to be useful;
    you can refine it over time as you discover additional interesting APIs and string
    patterns. In our sample, for instance, searching for suspicious strings and API
    names returns a URL in the malicious *d.** package we identified earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有精心的规划，搜索字符串和方法名称可能会浪费时间，因为这更多依赖于运气而非专业知识。为了构建搜索结构，你可以开发一个正则表达式，返回所有你能想到的有趣的字符串和方法名称。例如，这可能包括短信或联系人列表
    API 的名称，以及匹配 URL 或有趣内容提供者的字符串。正则表达式不必完美才有用；随着你发现更多有趣的 API 和字符串模式，你可以逐步完善它。在我们的示例中，例如，搜索可疑的字符串和
    API 名称返回了我们之前识别的恶意 *d.** 包中的一个 URL。
- en: '**The Malware’s First Stage**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件的第一阶段**'
- en: We’ve come across the suspicious package *d.** several times in this chapter
    so far. It’s finally time to analyze it. The package is conveniently simple, with
    just two classes, `d.a` and `d.b`. Interestingly, the app doesn’t seem to use
    `d.a` at all, while `d.b` is executed straight from the application entry point
    in the `android.app.Application` subclass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本章中多次遇到可疑的 *d.** 包。现在是时候分析它了。这个包结构非常简单，只有两个类，`d.a` 和 `d.b`。有趣的是，应用程序似乎根本没有使用
    `d.a`，而 `d.b` 直接从 `android.app.Application` 子类的应用程序入口点执行。
- en: It is unclear why `d.a` is present in the app. The developer might have used
    the class for testing and forgotten to remove it before releasing the malware.
    Its code doesn’t seem to be referenced or called from anywhere, its functionality
    is limited and not obfuscated, and it contains the URL of a command-and-control
    server in plaintext. Connecting to the URL from this file downloads another code
    file with more malicious content.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不清楚为什么 `d.a` 会出现在应用程序中。开发者可能在测试时使用了该类，并且忘记在发布恶意软件前将其移除。它的代码似乎没有被引用或调用，它的功能有限且未被混淆，并且包含了一个以明文形式呈现的命令与控制服务器的
    URL。从这个文件连接到该 URL 会下载另一个包含更多恶意内容的代码文件。
- en: The `d.b` class is the first part of the app’s malicious functionality. We already
    know that its constructor and the method `o` run as soon as the application starts.
    Looking around the class also shows intensive code obfuscation and encryption,
    for example in [Listing 3-5](ch03.xhtml#ch3lis5), which shows the class’s sole
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`d.b` 类是应用程序恶意功能的第一部分。我们已经知道它的构造函数和方法 `o` 一启动应用程序就会运行。检查该类还会发现强烈的代码混淆和加密，例如在[示例
    3-5](ch03.xhtml#ch3lis5)中所示，那里展示了该类唯一的构造函数。'
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-5: The constructor for the malware class d.b*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-5：恶意软件类 d.b 的构造函数*'
- en: The constructor code contains several obfuscation techniques found elsewhere
    in the class. For example, many attributes are assigned seemingly arbitrary string
    and integer values. These appear obfuscated or encrypted. The code also has complex-looking
    arithmetic expressions and opaque predicates. *Opaque predicates* are expressions
    that evaluate to true or false and look complicated to calculate, yet always resolve
    to the same value. Malware uses them to confuse human and automated analysis,
    for instance by making it harder to follow how `if` statements branch or how often
    loop statements repeat.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数代码包含了在类的其他地方发现的几种混淆技术。例如，许多属性被赋予看似随意的字符串和整数值。这些值看起来像是被混淆或加密了。代码中还有复杂的算术表达式和不透明的谓词。*不透明的谓词*是那些计算结果为真或假的表达式，虽然看起来计算复杂，但总是解析为相同的值。恶意软件利用它们来混淆人工和自动化分析，例如，通过使得
    `if` 语句的分支或循环语句的重复变得更难以跟踪。
- en: The `d.b` class uses two kinds of opaque predicate conditions, one of which
    is shown in the `if` statement of [Listing 3-5](ch03.xhtml#ch3lis5), which compares
    the Android SDK version to 93\. This check is nonsensical; as of this writing,
    we’re more than 60 versions (and many decades) away from reaching API level 93\.
    For the time being, this expression will always return false, and the instructions
    inside the `if` block will never execute.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`d.b` 类使用了两种类型的不透明谓词条件，其中一种在[示例 3-5](ch03.xhtml#ch3lis5)中的 `if` 语句中展示，比较了 Android
    SDK 版本与 93\. 这个检查是没有意义的；截至目前，我们离 API 级别 93 还有 60 多个版本（以及很多年）。目前，这个表达式将永远返回 false，`if`
    块中的指令将永远不会执行。'
- en: The second opaque predicate condition in this class uses Java’s `java.util.Calendar`
    API, as shown in [Listing 3-6](ch03.xhtml#ch3lis6).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中的第二个不透明谓词条件使用了 Java 的 `java.util.Calendar` API，如[列表 3-6](ch03.xhtml#ch3lis6)所示。
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-6: The malware class d.b uses the Calendar API to build opaque predicates.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-6：恶意类 d.b 使用 Calendar API 构造不透明谓词。*'
- en: This code asks the default system calendar for the number of the current week
    in the current month. Return values of this API must be between 0 and 6, so the
    expression can never be true, and the instructions in this `if` block never execute,
    either.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码请求系统默认日历获取当前月份中当前周的编号。此 API 的返回值必须介于 0 和 6 之间，因此该表达式永远不会为真，这样 `if` 块中的指令也永远不会执行。
- en: '***Understanding the Malicious Class***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解恶意类***'
- en: We’ve now identified the techniques used in `d.b` to make analysis harder, but
    we still have to defeat them to understand what the malware is doing. Luckily,
    the malware authors made some crucial mistakes that we can exploit. Without these
    mistakes, we may have had to trawl through nearly 1,000 lines of painful-to-read
    code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经识别出 `d.b` 中用于增加分析难度的技术，但我们仍然需要破解它们，以理解恶意软件的行为。幸运的是，恶意软件的作者犯了一些关键性的错误，我们可以加以利用。如果没有这些错误，我们可能不得不翻阅近
    1,000 行难以阅读的代码。
- en: The developers’ first mistake was to reuse the same few techniques. For the
    opaque predicates, it’s easy to eyeball whether the check is for a legitimate
    API version or a realistic calendar date. The arithmetic expressions and assignments
    of seemingly random values to attributes all look similar, too. As a human reviewer,
    you can make use of your brain’s pattern-recognition powers and rapidly scan the
    code to find instructions that are visually different. In the next section, when
    we rebuild the class’s string decryption algorithm, you will see that these different
    instructions are really the only ones that matter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的第一个错误是重复使用相同的几种技术。对于不透明谓词来说，很容易判断检查的是合法的 API 版本还是现实的日历日期。看似随机的值赋给属性的算术表达式和赋值也都非常相似。作为人工审查者，你可以利用大脑的模式识别能力，快速扫描代码，找到那些在视觉上不同的指令。在下一节中，当我们重建该类的字符串解密算法时，你会发现这些不同的指令实际上是唯一重要的。
- en: The developers’ second mistake was to leave strings in the class intact. Although
    they obfuscated these strings to the point of illegibility, they still left them
    at the exact places where they are passed to standard APIs, as shown in [Listing
    3-7](ch03.xhtml#ch3lis7).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的第二个错误是将字符串保留在类中。尽管他们将这些字符串混淆到几乎无法辨认的程度，但它们仍然保留在传递给标准 API 的确切位置，如[列表 3-7](ch03.xhtml#ch3lis7)所示。
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-7: The malware class d.b encrypts strings but leaves them in place.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-7：恶意类 d.b 加密字符串，但将其保留在原地。*'
- en: As the reflection API requires an unobfuscated, plaintext string to work, it’s
    clear that the `p` method returns that string. Moreover, it’s highly likely that
    the argument to `p` is the obfuscated and encrypted string, and that `p` decrypts
    it to the method name string expected by the `getMethod` API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反射 API 需要一个未混淆的明文字符串才能工作，因此很明显，`p` 方法返回的就是那个字符串。此外，`p` 方法的参数很可能是经过混淆和加密的字符串，而
    `p` 方法将其解密为 `getMethod` API 所期望的类方法名称字符串。
- en: '***Reverse Engineering the String Decryption Method***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逆向工程字符串解密方法***'
- en: The `p` method looks daunting at first, with nearly 50 lines of obfuscated code.
    However, the developers made additional mistakes here, so reverse engineering
    `p` is easy. For brevity, we omit the full method code and instead build up the
    relevant parts of it in this section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` 方法乍一看很令人畏惧，因为它有近 50 行混淆代码。然而，开发者在这里犯了一些额外的错误，因此逆向工程 `p` 方法变得容易了。为了简洁起见，我们省略了完整的代码，而是在本节中构建了相关部分。'
- en: Recall that the most important aspect of this method is its return value, which
    must be the decrypted string fed into the reflection API. Stripping all instructions
    but the return value instruction leaves us with the code shown in [Listing 3-8](ch03.xhtml#ch3lis8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个方法最重要的方面是它的返回值，它必须是输入到反射 API 中的解密字符串。去掉除了返回值指令之外的所有指令后，代码如[列表 3-8](ch03.xhtml#ch3lis8)所示。
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-8: The p method stripped down to its return value*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-8：简化为只包含返回值的 p 方法*'
- en: Because we’re really only after the content of `sb`, we now need to bring in
    all the lines that contribute to the value of `sb`. In jadx, we can select the
    variable `sb` to highlight all other uses of it. Adding these lines produces the
    code in [Listing 3-9](ch03.xhtml#ch3lis9).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们真正关注的是`sb`的内容，现在我们需要引入所有对`sb`值有贡献的代码行。在jadx中，我们可以选择变量`sb`来突出显示所有其他使用它的地方。添加这些行生成了[清单
    3-9](ch03.xhtml#ch3lis9)中的代码。
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-9: The p method with the references to sb included*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-9：包含对 sb 的引用的 p 方法*'
- en: As this code expansion pulled in another variable, `length`, we also need to
    add all the lines of code that manipulate this variable. We do this in [Listing
    3-10](ch03.xhtml#ch3lis10).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码扩展引入了另一个变量`length`，我们还需要添加所有操作此变量的代码行。我们在[清单 3-10](ch03.xhtml#ch3lis10)中执行此操作。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-10: The complete decryption method*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-10：完整的解密方法*'
- en: This last step did not pull in any more variables, so we’re done. Of the 50
    original lines in `p`, only these lines contribute to string decryption. The malware
    authors added the rest of the code to mislead us. Compiling and running this code
    in Java confirms that it decrypts the string `qmqMRa3e34OrqtqLdSAnAjne4p4ssoXYOMh`
    to `openStream`, the name of the method that is looked up through reflection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步并没有引入更多的变量，所以我们完成了。在`p`的50行原始代码中，只有这些行对字符串解密有贡献。恶意软件作者添加了其余的代码来误导我们。在Java中编译并运行此代码确认它将字符串`qmqMRa3e34OrqtqLdSAnAjne4p4ssoXYOMh`解密为`openStream`，这是通过反射查找的方法名称。
- en: The crucial mistake that allowed us to speedily recover the decryption code
    is that the developers mixed original instructions with obfuscating instructions
    but kept the data flow of the original code completely separate from the data
    flow of the obfuscated code. Thus, the code initially appears difficult to read
    and hard to follow, but when we look only at variables and how they influence
    each other, we can easily extract the original code without having to consider
    the obfuscation at all.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们迅速恢复解密代码的关键错误是，开发人员将原始指令与混淆指令混合在一起，但保持了原始代码的数据流与混淆代码的数据流完全分开。因此，代码最初看起来难以阅读且难以跟踪，但当我们只关注变量及其相互影响时，就能轻松提取原始代码，而无需考虑混淆。
- en: The small size of the decryption method allowed us to trace the data flow manually.
    To avoid similar manual work in the future, we could write code that performs
    these steps automatically using techniques from compiler theory, like use-definition
    chains.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 解密方法的体积较小，使我们能够手动追踪数据流。为了避免将来进行类似的手动工作，我们可以编写使用编译器理论中的技术（如使用定义链）自动执行这些步骤的代码。
- en: '***Decrypting All Strings in the Class***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解密类中的所有字符串***'
- en: Now that we’ve understood the decryption method and rebuilt it in Java, we can
    easily decode all the strings in the `d.b` class. Unless malware developers go
    the extra mile to hide this connection, there tends to be a strong correlation
    between the length of an obfuscated or encrypted string and its importance. The
    string starting with `PnPt` seems to be the longest, and sure enough, once decoded,
    it translates to a URL.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了解密方法并在Java中重建了它，我们可以轻松解码`d.b`类中的所有字符串。除非恶意软件开发人员进一步努力隐藏这种连接，否则混淆或加密字符串的长度与其重要性之间通常存在强烈的相关性。以`PnPt`开头的字符串似乎是最长的，果然，一旦解码，它转换为一个URL。
- en: The decoded URL is the same one we found earlier in the `d.a` class. By connecting
    to it, we were able to download a file called *ban*, which contains the code of
    the next stage. The rest of the code in `d.b` downloads this code file and loads
    it through the reflection API. We leave following this process as an exercise
    for the reader.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后的URL与我们之前在`d.a`类中找到的相同。通过连接到该URL，我们能够下载一个名为*ban*的文件，其中包含下一阶段的代码。`d.b`中的其余代码下载此代码文件并通过反射API加载它。我们将此过程的后续操作留给读者作为练习。
- en: '**The Malware’s Second Stage**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件的第二阶段**'
- en: The *ban* file is much smaller and less obfuscated than the `d.b` class. You’ll
    commonly find this to be the case in later malware stages, which generally contain
    less functionality. Malware developers might also think that their first stage
    has enough protection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*ban*文件比`d.b`类要小得多，且混淆程度较低。在恶意软件的后期阶段，通常会发现这种情况，因为它们通常包含更少的功能。恶意软件开发人员可能还认为其第一阶段已经足够保护。'
- en: The *ban* file contains two packages, *yin.** and *com.**. The *yin.** package
    contains only three small classes. One of these, `yin.Chao`, is loaded by the
    first stage in `d.b`, as shown in [Listing 3-11](ch03.xhtml#ch3lis11).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*ban*文件包含两个包，*yin.**和*com.**。*yin.**包只包含三个小类。其中一个，`yin.Chao`，是由第一阶段中的`d.b`加载的，如[清单3-11](ch03.xhtml#ch3lis11)所示。'
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-11: The malware obfuscates its invoking of yin.Chao through encrypted
    strings.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-11：恶意软件通过加密字符串混淆了对yin.Chao的调用。*'
- en: The three obfuscated strings decrypt to `dalvik.system.DexClassLoader`, `loadClass`,
    and `yin.Chao`, in that order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个混淆的字符串按顺序解密为`dalvik.system.DexClassLoader`、`loadClass`和`yin.Chao`。
- en: '***Entry Points***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***入口点***'
- en: While the code is small enough to simply read, let’s use our structured approach
    to find interesting entry points to our analysis. This approach makes sure that
    we don’t miss interesting functionality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码足够小，可以直接阅读，但让我们使用结构化的方法来寻找分析中的有趣入口点。这种方法确保我们不会错过有趣的功能。
- en: As *ban* is a dynamically loaded plug-in file, our analysis of it will differ
    from our first-stage analysis in some major ways. Most importantly, plug-in files
    do not have a manifest file, making it much harder to find permissions or entry
    points. In fact, plug-ins have no predefined entry point. The code that loads
    the plug-in can declare the class and method in which the plug-in should begin
    to run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*ban*是一个动态加载的插件文件，我们对它的分析将与第一阶段的分析在一些重要方面有所不同。最重要的一点是，插件文件没有清单文件，这使得查找权限或入口点变得更加困难。实际上，插件没有预定义的入口点。加载插件的代码可以声明插件应该开始运行的类和方法。
- en: Permissions
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权限
- en: Plug-in files like *ban* can use only the permissions declared in the manifest
    file of the app that loads them. Knowing this, we can simply revisit the permissions
    we discovered earlier. A text search for *permission* in jadx returns two distinct
    parts of *ban*. In the `com.gppp.hk.b.b` class, a string array mentions the `READ_PHONE_STATE`
    and `READ_CONTACTS` permissions. In the `com.gppp.hk.a.a` class, code requests
    these permissions. Later in this chapter, you’ll see that the malware uses the
    `READ_PHONE_STATE` permission to access the device’s phone number. The use of
    `READ_CONTACTS` remains unclear.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 像*ban*这样的插件文件只能使用加载它们的应用程序清单文件中声明的权限。了解这一点后，我们可以简单地回顾之前发现的权限。在jadx中搜索*permission*会返回*ban*的两个不同部分。在`com.gppp.hk.b.b`类中，一个字符串数组提到了`READ_PHONE_STATE`和`READ_CONTACTS`权限。在`com.gppp.hk.a.a`类中，代码请求了这些权限。在本章稍后的部分，你将看到恶意软件使用`READ_PHONE_STATE`权限来访问设备的电话号码。`READ_CONTACTS`的使用仍不明确。
- en: Of course, *ban* might make use of other permissions declared in the main app’s
    manifest file. As an exercise, try using one of the previously discussed permission
    maps to find permission-protected API calls.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*ban*可能还会使用主应用程序清单文件中声明的其他权限。作为练习，可以尝试使用之前讨论过的权限映射来查找受权限保护的API调用。
- en: The Main Entry Point
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要入口点
- en: We mentioned that the code loading the plug-in gets to decide where in the plug-in
    execution begins. To find this entry point, we need to revisit the `d.b` class
    of the first stage, where the encrypted string `fofRiawhwZyCx.xF-nViVkrysJ4iJ`
    decrypts to `yin.Chao`. Its first method is also called `yin`, once decrypted.
    If we don’t find any better leads, starting with `yin.Chao` is a good idea, as
    it will allow us to understand the malware’s second stage from its first executed
    line of code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，加载插件的代码可以决定插件执行从哪里开始。为了找到这个入口点，我们需要重新查看第一阶段的`d.b`类，在这个类中，经过解密的字符串`fofRiawhwZyCx.xF-nViVkrysJ4iJ`解密为`yin.Chao`。解密后，它的第一个方法也叫做`yin`。如果我们找不到更好的线索，从`yin.Chao`开始是一个不错的选择，因为这将帮助我们从恶意软件执行的第一行代码开始理解其第二阶段。
- en: Activities, Services, and Broadcast Receivers
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 活动、服务和广播接收器
- en: In addition to the main entry point into *ban*, we can also look for activities,
    services, and broadcast receivers. Using jadx’s search function shows one activity
    and one service, but no broadcast receivers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*ban*的主要入口点外，我们还可以寻找活动、服务和广播接收器。使用jadx的搜索功能显示了一个活动和一个服务，但没有广播接收器。
- en: While the activity `com.gufra.base_normal.MainActivity` seems unused, the service
    in `com.gppp.hk.b.a` is important. This is the base class of the notification
    listener `com.bp.statis.bloodsugar.PE`, which intercepts app notifications on
    behalf of the malware. Later in this section, we’ll explain this service in more
    detail.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`com.gufra.base_normal.MainActivity`活动似乎未使用，但`com.gppp.hk.b.a`中的服务非常重要。这是通知监听器`com.bp.statis.bloodsugar.PE`的基类，它代表恶意软件拦截应用通知。在本节稍后，我们将更详细地解释这个服务。
- en: Note that there are other service subclasses of `com.gppp.hk.b.a`, but the app
    cannot run them because they are not declared in the manifest file. We’ll ignore
    these services going forward, as they appear to be dead code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`com.gppp.hk.b.a`还有其他服务子类，但应用无法运行它们，因为它们没有在清单文件中声明。我们将忽略这些服务，因为它们看起来是死代码。
- en: Anti-Analysis Tricks and Hidden Code
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反分析技巧与隐藏代码
- en: While this second stage includes no native code or uses of the encryption package
    *javax.crypto*, we can find some interesting uses of the reflection API. Searching
    for *reflect* in jadx shows five instances of it, of which `com.gppp.hk.a.b.a`
    is the most relevant, as it contains another URL string. Further described later
    in this chapter, this class is responsible for downloading and running the third
    stage of the malware.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第二阶段没有包含本地代码或使用加密包*javax.crypto*，但我们可以找到一些有趣的反射API的使用。在jadx中搜索*reflect*会显示五个实例，其中`com.gppp.hk.a.b.a`最为相关，因为它包含了另一个URL字符串。稍后在本章中进一步描述，这个类负责下载并运行恶意软件的第三阶段。
- en: Strings and API Names
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串和API名称
- en: Besides functionality related to permissions, reflection, and the previously
    mentioned URL from which to download the third stage, there is little more to
    discover from a search for strings and method names.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与权限、反射相关的功能，以及前面提到的用于下载第三阶段的URL外，通过搜索字符串和方法名称几乎没有其他可发现的内容。
- en: For example, a search for *sms* returns a single line, where the malware checks
    whether it is the default SMS handler configured on the system, but that’s it.
    The second stage is just too small for any other discoveries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，搜索*sms*返回了一行，其中恶意软件检查它是否是系统中配置的默认短信处理程序，但仅此而已。第二阶段实在是太小，无法发现其他内容。
- en: '***The yin.Chao.yin Method***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***yin.Chao.yin方法***'
- en: Let’s take a look at the code for `yin.Chao.yin`, the method from which the
    main app executes the plug-in. As shown in [Listing 3-12](ch03.xhtml#ch3lis12),
    it starts a new thread from which to call a few other methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`yin.Chao.yin`方法，这是主应用执行插件的入口。如[列表 3-12](ch03.xhtml#ch3lis12)所示，它启动了一个新线程，从中调用了其他几个方法。
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-12: The yin.Chao.yin method is the entry point into the malware’s
    second stage.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-12：yin.Chao.yin方法是恶意软件第二阶段的入口。*'
- en: A cursory glance at these other methods shows that the last two, `Chao.Nti`
    and `b.a`, may be interesting. Code in `Chao.Nti`, shown in [Listing 3-13](ch03.xhtml#ch3lis13),
    checks whether the user has already granted the app permission to process notifications
    sent by all other apps. If not, the app shows the dialog for granting that permission.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随便看一下这些其他方法，我们可以发现最后两个方法`Chao.Nti`和`b.a`可能比较有趣。`Chao.Nti`中的代码，如[列表 3-13](ch03.xhtml#ch3lis13)所示，检查用户是否已经授予应用处理所有其他应用发送的通知的权限。如果没有，应用会显示一个对话框，要求授予该权限。
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-13: Chao.Nti tries to get access to all app notifications.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-13：Chao.Nti尝试获取对所有应用通知的访问权限。*'
- en: Recall that we previously saw a service for processing app notifications declared
    in the manifest file, but that we couldn’t find the code for it. This method seems
    to be it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前看到的一个用于处理应用通知的服务，它在清单文件中声明，但我们找不到相关的代码。这个方法似乎就是它。
- en: The `b.a` method, whose fully qualified name is `com.gppp.hk.a.b.a`, is even
    more interesting. As you can see in [Listing 3-14](ch03.xhtml#ch3lis14), it opens
    a connection to *https://xn3o.oss-accelerate.aliyuncs.com/xn3o*, downloads yet
    another code stage from there, and executes the downloaded code with the `DexClassLoader`
    API.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`b.a`方法，其完全限定名为`com.gppp.hk.a.b.a`，更为有趣。如[列表 3-14](ch03.xhtml#ch3lis14)所示，它打开了一个与*https://xn3o.oss-accelerate.aliyuncs.com/xn3o*的连接，从那里下载了另一个代码阶段，并通过`DexClassLoader`
    API执行下载的代码。'
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-14: The method com.gppp.hk.a.b.a downloads the third malware stage.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-14：com.gppp.hk.a.b.a方法下载恶意软件的第三阶段。*'
- en: The two other methods called by `yin.Chao.yin` seem less interesting. The `Hook.hook2`
    method contains code for merging the app’s default class loader with a new class
    loader. Its code seems to have been copied from Chinese-origin Android plug-in
    tutorials, reminding us to always search for any kind of boilerplate code we encounter
    during analysis. The call to `registerActivityLifecycleCallbacks` registers a
    callback that prompts the user to grant certain permissions at various stages
    of the app’s lifecycle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`yin.Chao.yin`方法中的其他两个方法似乎不太有趣。`Hook.hook2`方法包含将应用的默认类加载器与新的类加载器合并的代码。其代码似乎是从中文来源的Android插件教程中复制过来的，这提醒我们在分析过程中始终要查找任何类型的模板代码。对`registerActivityLifecycleCallbacks`的调用注册了一个回调，在应用生命周期的各个阶段提示用户授予某些权限。'
- en: '***The com.* Package***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***com.*包***'
- en: Before moving on to the third stage, let’s have a quick look at *ban*’s second
    package, *com.**. It contains a whole lot of subpackages with different names
    yet similar code. For example, in the *com.bp.statis.bloodsugar* package, we find
    one class, `PE`. This is the notification listener service declared in the manifest
    file. Its code is tiny, as it merely forwards the incoming notification to its
    parent class, `com.gppp.hk.b.a`. Most other subpackages of the *com.** package
    have a similar structure. We can assume that the names of the subpackages belong
    to other malware samples of the same family.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入第三阶段之前，让我们快速看看*ban*的第二个包，*com.**。它包含了很多子包，虽然名字不同，但代码相似。例如，在*com.bp.statis.bloodsugar*包中，我们发现了一个类，`PE`。这是在清单文件中声明的通知监听服务。它的代码很简短，因为它只是将传入的通知转发给父类`com.gppp.hk.b.a`。*com.**包中的大多数其他子包结构类似。我们可以推测，子包的名称属于同一恶意软件家族的其他样本。
- en: The code in the parent class `com.gppp.hk.b.a` is likewise small. Shown in [Listing
    3-15](ch03.xhtml#ch3lis15), it takes incoming notifications, forwards them to
    other parts of the app with a broadcast message, and then hides the original notification
    from the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 父类`com.gppp.hk.b.a`中的代码同样很简短。请参见[列表3-15](ch03.xhtml#ch3lis15)，它接收传入的通知，通过广播消息将它们转发到应用的其他部分，然后将原始通知隐藏起来。
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-15: The com.gppp.hk.b.a class intercepts notifications from all
    other apps on the device.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-15：com.gppp.hk.b.a类拦截来自设备上所有其他应用的通知。*'
- en: This code uses context-registered messages and broadcast receivers that aren’t
    declared in the manifest file. Somewhere else, probably in the same app, we should
    find a broadcast receiver that listens for broadcasts of type `action_text`. Locating
    this broadcast receiver can often be tricky, but in this particular malware sample,
    it’s not. If you search for *action_text* in the code of the malware’s third stage,
    you’ll find it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了在清单文件中未声明的上下文注册消息和广播接收器。在其他地方，可能是在同一应用程序中，我们应该能够找到一个监听`action_text`类型广播的广播接收器。定位这个广播接收器可能会比较棘手，但在这个特定的恶意软件样本中并不难。如果你在恶意软件的第三阶段代码中搜索*action_text*，你会找到它。
- en: To summarize, the whole purpose of the second stage is to make sure that the
    app has access to notifications from all apps on the system. It intercepts them
    and sends their contents to the third stage, which the second stage also downloads
    and executes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，第二阶段的全部目的是确保应用程序能够访问系统中所有应用的通知。它拦截通知并将其内容发送到第三阶段，第二阶段还会下载并执行第三阶段。
- en: '**The Malware’s Third Stage**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件的第三阶段**'
- en: The third, and main, stage of this malware sample contains the majority of its
    malicious functionality. It has more classes, and a lot more code, than the previous
    two stages. Loading the third stage in jadx shows code in packages *com* and *vgy7.vgy7.vgy7.vgy7.**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本的第三个也是主要阶段包含了大部分的恶意功能。它比前两个阶段有更多的类和代码。在jadx中加载第三阶段会看到*com*和*vgy7.vgy7.vgy7.vgy7.**包中的代码。
- en: These two packages are very different. The *com* package contains just one class,
    `com.xn3o`. The *vgy7.vgy7.vgy7.vgy7.** package contains 10 classes distributed
    across multiple subpackages. The malware authors spent some effort obfuscating
    variable names and strings, but it’s still possible to eyeball what’s going on.
    For example, the class `vgy7.vgy7.vgy7.vgy7.vgy7` contains a bunch of poorly obfuscated
    strings that hint at network, telephony, and JavaScript functionality.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个包非常不同。*com*包只包含一个类，`com.xn3o`。*vgy7.vgy7.vgy7.vgy7.**包包含了分布在多个子包中的10个类。恶意软件的作者花了一些功夫来混淆变量名和字符串，但仍然可以大致看出发生了什么。例如，类`vgy7.vgy7.vgy7.vgy7.vgy7`包含了一些未完全混淆的字符串，这些字符串暗示了网络、电话和JavaScript的功能。
- en: This third stage is unfortunately way too large to fully explain in this chapter.
    It contains significant chunks of custom code for manipulating certain premium
    service sign-up pages and thwarting their anti-bot protections. All the code in
    this stage contributes to this malicious functionality, so it’s hard to completely
    ignore certain packages. Instead, we describe only the beginning of the third
    stage’s analysis.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，第三阶段的代码太大，无法在本章中完全解释。它包含了大量的自定义代码，用于操控某些高级服务的注册页面并破坏它们的反机器人保护措施。本阶段的所有代码都贡献了恶意功能，因此很难完全忽视某些包。相反，我们仅描述第三阶段分析的开始部分。
- en: '***jadx Decompilation Issues***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***jadx反编译问题***'
- en: Decompiling the code in *com.xn3o.xn3o* is beyond jadx’s capabilities, which
    happens occasionally when you try to load larger and more complex pieces of code.
    As a first workaround, try the jadx option called *Show Inconsistent Code*, which
    shows the parts of the code that could not be properly disassembled. The inconsistent
    code is mostly correct, but not perfectly so. When it comes to methods that are
    important to understand correctly, say a decryption method, it’s best to get a
    second opinion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译*com.xn3o.xn3o*中的代码超出了jadx的能力范围，这种情况偶尔会发生，特别是在你尝试加载更大更复杂的代码块时。作为一个初步的解决方法，可以尝试使用jadx的一个选项，叫做*显示不一致的代码*，它会显示那些无法被正确反编译的代码部分。不一致的代码大多是正确的，但并不完美。当遇到一些需要准确理解的方法时，比如解密方法，最好请别人提供第二意见。
- en: You can get this second opinion by using other Android decompilers. For example,
    the Bytecode Viewer tool includes six different Android decompilers. Usually at
    least one of them can produce some reasonable decompiled code for any Android
    app.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用其他Android反编译工具来获得第二意见。例如，Bytecode Viewer工具包含六个不同的Android反编译器。通常，至少其中一个能够为任何Android应用生成合理的反编译代码。
- en: '***Entry Points***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***入口点***'
- en: 'With just 11 classes, it’s possible to manually scan the entire code for interesting
    functionality. But to sharpen our reverse engineering processes, let’s return
    to the techniques we’ve introduced previously to find entry points: looking at
    permissions; the main entry point; activities, services, and broadcast receivers;
    anti-analysis tricks and hidden code; and string and API names.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 只有11个类，便可以手动扫描整个代码，找出感兴趣的功能。但是，为了提高我们的逆向工程效率，让我们回到之前介绍的技术，寻找入口点：查看权限；主要入口点；活动、服务和广播接收器；反分析技巧和隐藏代码；以及字符串和API名称。
- en: Permissions
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权限
- en: Like the second stage, the third stage is a dynamically loaded plug-in, which
    means that the permissions available to it must be declared in the main app’s
    manifest file. Searching for permissions in jadx shows references to the `SEND_SMS`
    and `RECEIVE_SMS` permissions. Because these two permissions were not declared
    in the first stage’s manifest file, *xn3o* won’t be able to use them. It is likely
    that *xn3o* is loaded by many different malware apps, some of which have access
    to one or both of the SMS permissions. Alternatively, the app may nudge the user
    to install newer versions of itself that declare these permissions, but in this
    particular malware we have not seen such functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 和第二阶段一样，第三阶段是一个动态加载的插件，这意味着它所需的权限必须在主应用的清单文件中声明。在jadx中搜索权限会显示`SEND_SMS`和`RECEIVE_SMS`权限的引用。由于这两个权限在第一阶段的清单文件中没有声明，*xn3o*将无法使用它们。很可能，*xn3o*被许多不同的恶意软件应用加载，其中一些应用可以访问一个或两个SMS权限。或者，该应用可能会提示用户安装更新版本的自己，这些新版本声明了这些权限，但在这个特定的恶意软件中我们并没有看到这样的功能。
- en: Even though this app can’t use the SMS permissions, we can still find it worthwhile
    to understand how they are used when loaded into other apps. The first line of
    [Listing 3-16](ch03.xhtml#ch3lis16) calls the method `bhu8`, which indirectly
    calls the `PackageManager.checkPermission` method to check for the availability
    of the `RECEIVE_SMS` permission. The second line checks for the `SEND_SMS` permission.
    The results are stored in two variables and later sent to the malware’s command-and-control
    server.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个应用无法使用SMS权限，但我们仍然认为了解它们在加载到其他应用中时如何使用是值得的。[列表 3-16](ch03.xhtml#ch3lis16)中的第一行调用了`bhu8`方法，该方法间接调用了`PackageManager.checkPermission`方法来检查`RECEIVE_SMS`权限的可用性。第二行检查`SEND_SMS`权限。结果被存储在两个变量中，之后发送到恶意软件的指挥与控制服务器。
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-16: The malware’s third stage checks for RECEIVE_SMS and SEND_SMS
    permissions.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-16：恶意软件的第三阶段检查RECEIVE_SMS和SEND_SMS权限。*'
- en: Now that we know that *xn3o* uses SMS permissions when they’re available, we
    can search jadx for *sms* to surface several entry points into the malicious functionality.
    The class `vgy7.vgy7.vgy7.vgy7.bhu8` contains references to the API `sendTextMessage`,
    while `vgy7.vgy7.vgy7.vgy7.cft6.bhu8` contains code for receiving and handling
    incoming text messages. Besides SMS permissions, *xn3o* does not seem to check
    for any other permissions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道*xn3o*在有SMS权限时会使用它，我们可以在jadx中搜索*sms*，以展示几个进入恶意功能的入口点。类`vgy7.vgy7.vgy7.vgy7.bhu8`包含对API
    `sendTextMessage`的引用，而`vgy7.vgy7.vgy7.vgy7.cft6.bhu8`则包含接收和处理来电短信的代码。除了SMS权限外，*xn3o*似乎没有检查其他权限。
- en: The Main Entry Point
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要入口点
- en: The main entry point into *xn3o* is defined by the second stage, *ban*. [Listing
    3-17](ch03.xhtml#ch3lis17) shows that the third stage’s execution starts in the
    `com.xn3o` class’s `xn3o` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*xn3o*的主要入口点由第二阶段*ban*定义。[列表 3-17](ch03.xhtml#ch3lis17)显示，第三阶段的执行从`com.xn3o`类的`xn3o`方法开始。'
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-17: Code in* ban *executes the* com.xn3o.xn3o *method in the third
    stage.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-17：*ban* 中的代码执行了第三阶段的*com.xn3o.xn3o*方法。*'
- en: If we don’t find any better leads, we could start trying to understand the functionality
    of the third stage from there. For now, let’s consider other potential entry points.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到更好的线索，可以从那里开始尝试理解第三阶段的功能。现在，让我们考虑其他可能的入口点。
- en: Activities, Services, and Broadcast Receivers
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 活动、服务和广播接收器
- en: We can also look for activities, services, and broadcast receivers. Using jadx’s
    search function shows just two broadcast receivers and not much else. The first
    broadcast receiver handles messages sent by the second stage with `android.text`.
    Recall that this broadcast contains intercepted app notifications. A look into
    the method `bhu8.vgy7`, called from the last line of [Listing 3-18](ch03.xhtml#ch3lis18),
    shows that the app stores the intercepted notifications in a list for later processing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查找活动、服务和广播接收器。使用jadx的搜索功能只显示了两个广播接收器，其他没什么特别的内容。第一个广播接收器处理由第二阶段使用`android.text`发送的消息。回想一下，这个广播包含了拦截的应用通知。查看从[列表
    3-18](ch03.xhtml#ch3lis18)的最后一行调用的`bhu8.vgy7`方法，发现该应用将拦截的通知存储在列表中以便后续处理。
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-18: The first broadcast receiver processes previously intercepted
    app notifications.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-18：第一个广播接收器处理先前拦截的应用通知。*'
- en: The second broadcast receiver ([Listing 3-19](ch03.xhtml#ch3lis19)) handles
    incoming text messages. It calls the same `bhu8.vgy7` method to store and process
    the intercepted messages that it previously used to handle intercepted notifications.
    The one difference is that it also pings its command-and-control server if the
    text message starts with *rch*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个广播接收器（[列表 3-19](ch03.xhtml#ch3lis19)）处理传入的短信。它调用相同的`bhu8.vgy7`方法来存储和处理之前用来处理拦截通知的拦截消息。唯一的不同是，如果短信以*rch*开头，它还会向命令与控制服务器发送请求。
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-19: The second broadcast receiver intercepts incoming SMS messages
    for processing.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-19：第二个广播接收器拦截传入的短信进行处理。*'
- en: Why the malware looks for *rch* is unclear. One possibility is that the malware
    authors send these messages to communicate with the malware as an alternative
    to using the HTTP-based command-and-control server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件为何寻找*rch*尚不清楚。一个可能性是，恶意软件作者通过发送这些消息与恶意软件进行通信，作为替代HTTP命令与控制服务器的方式。
- en: Anti-Analysis Tricks and Hidden Code
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反分析技巧与隐藏代码
- en: Looking for typical anti-analysis tricks also works in the third stage. While
    there is no native code or uses of the encryption package *javax.crypto*, we can
    find some interesting uses of *android.util.Base64*. In [Listing 3-20](ch03.xhtml#ch3lis20),
    you can see a method that encodes a byte array using Base64 and then passes the
    encoded byte array to another function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找典型的反分析技巧在第三阶段也有效。虽然没有原生代码或使用加密包*javax.crypto*，但我们可以找到一些有趣的*android.util.Base64*用法。在[列表
    3-20](ch03.xhtml#ch3lis20)中，你可以看到一个方法，它使用Base64编码一个字节数组，然后将编码后的字节数组传递给另一个函数。
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-20: The malware uses Base64 encoding and custom encryption to communicate
    with the server.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-20：恶意软件使用Base64编码和自定义加密与服务器通信。*'
- en: As you’ll soon see, this other function, `vgy7`, is responsible for encrypting
    and decrypting the malware’s communications with its command-and-control server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快将看到的，这个其他函数`vgy7`负责加密和解密恶意软件与其命令与控制服务器的通信。
- en: Strings and API Names
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串和API名称
- en: Besides functionality related to permissions, SMS, and encoding, we can surface
    some other interesting parts of the code by searching for strings and method names.
    A search for *HTTP* shows embedded URLs, as well as code from the *java.net* package
    used to connect to these URLs. Later in this chapter, you’ll learn that many of
    these URLs are for communicating with the malware’s command-and-control server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与权限、短信和编码相关的功能外，我们还可以通过搜索字符串和方法名来揭示一些其他有趣的代码部分。搜索*HTTP*可以显示嵌入的URL，以及来自*java.net*包的代码，这些代码用于连接到这些URL。在本章稍后的部分，你将了解到，这些URL是用于与恶意软件的命令与控制服务器通信。
- en: '***Name Mangling***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称混淆***'
- en: Now that we’ve found many ways to proceed with the analysis, we have to make
    the obfuscated code more readable. One of the most important tools in a reverse
    engineer’s toolbox is the ability to rename variables, methods, classes, and other
    names in a program. Malware developers like to throw name mangling techniques
    at malware analysts, so you’ll often have to reverse those techniques to resurface
    the original code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了许多继续分析的方法，接下来我们需要使混淆代码更具可读性。逆向工程师工具箱中最重要的工具之一就是重命名变量、方法、类和其他名称的能力。恶意软件开发者喜欢用名称混淆技术来对抗恶意软件分析师，因此你经常需要逆转这些技术，以恢复原始代码。
- en: Renaming mangled names doesn’t just make code easier to understand. The practice
    also helps you keep track of code you’ve already analyzed. When you see an unmangled
    name, you don’t have to worry about whether you’ve seen it before; you’ll be able
    to recognize the human-readable name more easily, even if it’s something like
    *unknown_string* or *not_sure*. Rename mangled names liberally, even if you don’t
    quite understand yet what a name is for.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名混淆名称不仅让代码更容易理解。这种做法还帮助你跟踪已经分析过的代码。当你看到一个解混淆后的名称时，你就不必担心自己是否已经见过它；即使它是像*unknown_string*或*not_sure*这样的名称，你也能更容易地识别出这个人类可读的名称。大胆地重命名混淆名称，即使你还不完全理解某个名称的用途。
- en: While unmangling names, we also recommend that you introduce some structure
    to them. Although the style is shunned in software development nowadays, we’ve
    found *Hungarian notation*, a naming convention in which a variable’s type information
    is included in its name, to be extremely useful for this purpose. For example,
    you might name an integer `iLen`, a string `strName`, and so on. You can even
    use this naming scheme for unmangling method names, for example by using `getStrName`
    for a simple getter function that returns a string we call `name`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在解开名字混淆的同时，我们还建议为它们引入一些结构。尽管这种风格在现代软件开发中已不常见，我们发现*匈牙利命名法*（一种在变量名中包含类型信息的命名规范）对于这一目的非常有用。例如，你可以将一个整数命名为`iLen`，将一个字符串命名为`strName`，等等。你甚至可以用这种命名方式来解开方法名的混淆，比如使用`getStrName`来表示一个简单的获取函数，它返回一个我们称之为`name`的字符串。
- en: Finally, name unmangling can reduce visual load. Try renaming long names to
    short names, and names with numbers or Unicode characters to simple names consisting
    of ASCII characters only. For each name mangling technique you encounter, consider
    why it was introduced and then use your tool’s renaming function to counter the
    effect. Developers of name mangling techniques think it’s smart to use only random
    Unicode characters, shorten all names to single characters, or even change the
    text direction so names are read from top to bottom instead of left to right.
    However, for reverse engineers, all of these techniques make it extremely easy
    to spot the difference between mangled names and names that have already been
    unmangled. It’s much more confusing for reverse engineers if all names are random
    English-language nouns, or, as we’ve seen in real malware, if the names come from
    the code’s original source but have been randomly swapped so that the malware
    uses, for example, `int socket` and `Socket i` instead of `int i` and `Socket
    socket`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，名称解混淆可以减少视觉负担。尝试将长名称重命名为短名称，将包含数字或Unicode字符的名称重命名为仅由ASCII字符组成的简单名称。对于你遇到的每个名称混淆技术，考虑它为何出现，然后使用你工具的重命名功能来抵消这种效果。名称混淆技术的开发者认为只使用随机的Unicode字符、将所有名称缩短为单个字符，甚至改变文本方向使得名称从上到下而非从左到右阅读是聪明的做法。然而，对于逆向工程师而言，所有这些技术都让他们更容易发现混淆名和已经解混淆的名称之间的区别。如果所有名称都是随机的英语名词，或者正如我们在实际恶意软件中看到的那样，名称来自代码的原始源代码，但被随机交换，以至于恶意软件使用了例如`int
    socket`和`Socket i`，而不是`int i`和`Socket socket`，这对逆向工程师来说就会变得更加混乱。
- en: Armed with these name unmangling concepts, let’s take a stab at unmangling a
    sample of the third-stage code. [Listing 3-21](ch03.xhtml#ch3lis21) shows the
    original code, with the mangled names intact.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些名称解混淆的概念后，让我们尝试解混淆一段第三阶段的代码。[列表 3-21](ch03.xhtml#ch3lis21)展示了原始代码，其中的混淆名称保持不变。
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-21: The original mangled code, as produced by jadx*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-21：由jadx生成的原始混淆代码*'
- en: Let’s clean this up by removing lengthy package names to reduce visual overload,
    supplying meaningful names, using Hungarian notation to provide easily accessible
    type information, and marking code that doesn’t do anything as *noOp* (no operation).
    The unmangled version, shown in [Listing 3-22](ch03.xhtml#ch3lis22), is much easier
    to understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过删除冗长的包名称以减少视觉过载，提供有意义的名称，使用匈牙利命名法来提供易于访问的类型信息，并将不做任何操作的代码标记为*noOp*（无操作），来清理这些内容。未经过混淆的版本，如[Listing
    3-22](ch03.xhtml#ch3lis22)所示，易于理解得多。
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-22: Code cleaned up with jadx’s renaming function*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-22：使用jadx重命名功能清理后的代码*'
- en: We still don’t know what the preferences in `bshwai` and `tffhhk` are, or what
    the URL `urlUtansy` is used for, but at least we can read the transformed code
    relatively fluently. Note also that we’ve given two different variables the same
    name, `context`. That would be a big no-no in programming, as compilers don’t
    allow two variables in the same scope to have the same name. In reverse engineering,
    however, this is perfectly fine, and perhaps even encouraged. For example, renaming
    every uninteresting name to an underscore (`_`) can significantly reduce cognitive
    load.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然不知道`bshwai`和`tffhhk`中的偏好设置是什么，或者`urlUtansy`网址的用途是什么，但至少我们可以相对流畅地阅读转换后的代码。另请注意，我们给两个不同的变量起了相同的名称`context`。在编程中，这通常是大忌，因为编译器不允许在同一作用域中有两个同名的变量。然而，在逆向工程中，这是完全可以接受的，甚至可能是鼓励的。例如，将每个无趣的名称重命名为下划线（`_`）可以显著减少认知负担。
- en: '**Command-and-Control Server Communication**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指挥与控制服务器通信**'
- en: In this section, we will showcase pieces of *xn3o* to explain how the fraudulent
    app works. Execution of this third stage is dynamic, with a command-and-control
    server telling the malware what to do and in what order. To follow along, you
    must understand how the malware communicates with the server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一些*xn3o*的片段，解释欺诈应用是如何工作的。执行第三阶段是动态的，指挥与控制服务器告诉恶意软件应该做什么，以及按什么顺序做。为了跟上这个过程，你必须理解恶意软件是如何与服务器通信的。
- en: You’ll notice that we’re no longer in the realm of pure static analysis. At
    this point, sticking with a static approach alone is too limiting. To understand
    how malware communicates with its command-and-control servers, it’s usually easier
    to just run the malware and intercept the traffic. However, to keep this chapter
    focused on static analysis, we’ll punt our explanation of dynamic analysis tools
    to the next chapter and concentrate instead on the information we can glean from
    the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们不再处于纯静态分析的范畴了。在这一点上，单纯依赖静态方法已经太过局限。要理解恶意软件如何与其指挥与控制服务器通信，通常更容易直接运行恶意软件并拦截流量。然而，为了让本章专注于静态分析，我们将在下一章中介绍动态分析工具，而集中讨论我们可以从代码中获取的信息。
- en: 'As you’ll see, this app performs direct carrier billing fraud, or toll fraud,
    by signing users up for premium services without their knowledge or against their
    will. Some toll fraud functions as a pure social engineering scam, showing the
    users phishing-like sign-up pages and hoping that they will complete the registration
    process themselves. The toll fraud shown here, however, uses a second common technique:
    simulating user actions with Android and JavaScript APIs and signing up for premium
    services without the user noticing. Despite all of this automation, the malware
    performs just a few key steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这款应用通过直接的运营商账单欺诈或话费欺诈，在用户不知情或不愿意的情况下为其注册付费服务。有些话费欺诈作为纯粹的社交工程骗局，通过显示类似钓鱼的注册页面，诱使用户自己完成注册过程。然而，本文展示的话费欺诈使用了第二种常见技术：通过Android和JavaScript
    API模拟用户操作，未经用户察觉地为其注册付费服务。尽管所有这些过程都是自动化的，恶意软件仅执行几个关键步骤：
- en: Load a referral website that forwards to the premium service.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载一个转发到付费服务的推荐网站。
- en: Use code to automatically engage with the premium service page and subscribe
    the user without their consent.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码自动与付费服务页面交互，并在用户未同意的情况下为其订阅付费服务。
- en: Intercept and extract the one-time password sent over SMS.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截并提取通过短信发送的一次性密码。
- en: Paste the one-time password into the premium service page to complete registration.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一次性密码粘贴到付费服务页面以完成注册。
- en: Most toll fraud apps use roughly the same framework. Armed with this knowledge,
    we can now revisit the malware’s third stage and look into how it achieves all
    of these steps.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数话费欺诈应用使用大致相同的框架。掌握了这些知识后，我们现在可以重新审视恶意软件的第三阶段，看看它是如何完成这些步骤的。
- en: '***Examining the Encryption Algorithm***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查加密算法***'
- en: All communication with the command-and-control server is encrypted using a simple
    algorithm found in the `vgy7.vgy7.vgy7.vgy7.bhu8` class. Recall that we discovered
    this `vgy7` method in [Listing 3-20](ch03.xhtml#ch3lis20). Shown in [Listing 3-23](ch03.xhtml#ch3lis23),
    it takes two arguments. The second argument controls whether the string passed
    as the first argument is encrypted (`z = true`) or decrypted (`z = false`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令与控制服务器的所有通信都使用在 `vgy7.vgy7.vgy7.vgy7.bhu8` 类中找到的简单算法进行加密。回想一下，我们在[示例 3-20](ch03.xhtml#ch3lis20)中发现了这个
    `vgy7` 方法。[示例 3-23](ch03.xhtml#ch3lis23)展示了它的实现，它接受两个参数。第二个参数控制第一个参数传递的字符串是加密（`z
    = true`）还是解密（`z = false`）。
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-23: The vgy7 method can encrypt and decrypt communications with
    the command-and-control server.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-23：vgy7 方法可以加密和解密与命令与控制服务器的通信。*'
- en: The encryption algorithm is clearly homegrown and very weak. To encrypt a string,
    it first picks a random lowercase letter and a random uppercase letter. It subtracts
    the ASCII code of the second letter from that of the first and adds five. The
    encrypted output string starts with the two random letters, followed by the letters
    of the input string to encrypt. At string locations where the result of the subtraction
    plus five equals zero, the algorithm inserts a random character that doesn’t have
    any meaning. For example, the third character of the encrypted string (in other
    words, the zeroth character of the transformed input string) is always a random
    character, as zero modulo any value is always zero.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该加密算法显然是自创的，且非常弱。要加密一个字符串，它首先随机选择一个小写字母和一个大写字母。然后，将第二个字母的 ASCII 码减去第一个字母的 ASCII
    码，再加上五。加密后的输出字符串以这两个随机字母开头，接着是需要加密的输入字符串的字母。在减法结果加五后等于零的字符串位置，算法会插入一个没有任何意义的随机字符。例如，加密字符串的第三个字符（换句话说，是转换后输入字符串的第零个字符）始终是一个随机字符，因为零对任何值取模总是零。
- en: '***Probing the Server from the Command Line***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从命令行探测服务器***'
- en: 'Now that we know how encryption and decryption works, we can write a small
    script to interact with the malware’s command-and-control server and probe its
    commands and responses. As the encryption and decryption routine is self-contained
    in just one method, we’ve pasted the code from jadx into two files, *Encrypt.java*
    and *Decrypt.java*, that can be run from the command line. Here, we use the Linux
    command line to interact with the malware’s server:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了加密和解密的工作原理，我们可以编写一个小脚本与恶意软件的命令与控制服务器进行交互，探测其命令和响应。由于加密和解密过程只包含一个方法，我们已将
    jadx 中的代码粘贴到两个文件中，分别是 *Encrypt.java* 和 *Decrypt.java*，可以从命令行运行。在这里，我们使用 Linux
    命令行与恶意软件的服务器进行交互：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command encodes a JSON argument with values collected by the app (and
    explained later in this section), echoes the command to our *Encrypt* script while
    stripping the newline with the `-n` flag, pipes the encrypted payload to cURL
    in silent (`-s`) and POST (`-d`) modes, and decrypts the command received from
    the server. The output will look something like this: `"bshwai": 5320786, "xjnguw":
    ""`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '这个命令将通过应用程序收集的 JSON 参数进行编码（稍后会在本节中解释），将命令传递给我们的*加密*脚本，同时使用 `-n` 标志去除换行符，将加密后的负载以静默（`-s`）和
    POST（`-d`）模式通过 cURL 传输，并解密从服务器接收到的命令。输出大致如下：`"bshwai": 5320786, "xjnguw": ""`。'
- en: '**NOTE**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As command-and-control servers are usually short-lived, we don’t expect this
    command-and-control server to be around for experimentation when you’re reading
    this book. Unfortunately, this will limit your ability to follow along with dynamic
    analysis.*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于命令与控制服务器通常生命周期较短，我们不指望你在阅读本书时能进行实验，命令与控制服务器仍然存在。不幸的是，这将限制你进行动态分析的能力。*'
- en: '***Registering with the Server***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向服务器注册***'
- en: Now that we can send encrypted payloads to the server and decrypt its responses,
    we can begin to understand how the malware communicates with it. Here, we’ll show
    the information being sent between the malware and its command-and-control server
    by simulating the malware running on a real device connected to the mobile network
    of Belgian carrier Orange. As the malware uses the value of the `worikt` field
    in command-and-control communication to identify the phone’s mobile carrier, changing
    this value to identifiers of other mobile carriers allows us to easily experiment
    with different mobile carriers in different countries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向服务器发送加密的有效负载，并解密其响应，我们可以开始了解恶意软件是如何与服务器通信的。在这里，我们将通过模拟恶意软件在与比利时Orange运营商的移动网络连接的真实设备上运行时，展示恶意软件与其指挥与控制服务器之间传输的信息。由于恶意软件使用`worikt`字段的值来识别手机的移动运营商，通过将此值更改为其他移动运营商的标识符，我们可以轻松地在不同国家的不同移动运营商之间进行实验。
- en: The first connection the malware makes to its command-and-control server is
    to register with the server. It sends registration information to *https://www.utansy.com/xn3o/in*
    using encrypted JSON. The server responds with an encrypted JSON object that the
    malware decrypts and processes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首次与指挥与控制服务器建立连接时，会向服务器注册。它使用加密的JSON发送注册信息到*https://www.utansy.com/xn3o/in*，服务器响应一个加密的JSON对象，恶意软件解密并处理它。
- en: In all instances of encrypted JSON communication, the malware developers replaced
    the meaningful names of the JSON fields with gibberish names to throw off analysis.
    You can see what this looks like in [Listing 3-24](ch03.xhtml#ch3lis24), which
    shows the decrypted JSON object sent to the command-and-control server in the
    registration phase.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有加密的JSON通信实例中，恶意软件开发者将JSON字段的有意义名称替换为乱码名称，以迷惑分析人员。你可以在[列表3-24](ch03.xhtml#ch3lis24)中看到这种情况，该列表显示了在注册阶段发送到指挥与控制服务器的解密JSON对象。
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 3-24: The decrypted payload of the registration message*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-24：注册消息的解密有效负载*'
- en: To understand these gibberish names, it helps to approach the problem from two
    sides. When you see gibberish JSON fields referred to in the code, document the
    values they are assigned. Then do the same thing when you see gibberish JSON fields
    in decrypted communication. We can guess the meaning of some fields, like `josiwo`,
    from their assigned values. The meaning of others, like `kdthit`, must be found
    through code inspection.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些乱码名称，最好从两个方面来解决问题。当你在代码中看到乱码的JSON字段时，记录它们被赋予的值。然后，在你看到解密通信中的乱码JSON字段时，也做同样的事情。我们可以根据字段的赋值推测一些字段的含义，例如`josiwo`。而像`kdthit`这样的字段，其含义必须通过代码检查来找出。
- en: Luckily, the malware doesn’t try to hide the gibberish strings in the code or
    reuse the same gibberish names in different contexts. For example, searching jadx
    for `josiwo` returns only one location, shown in [Listing 3-25](ch03.xhtml#ch3lis25).
    This code contains the exact same field names as the decrypted JSON object in
    [Listing 3-24](ch03.xhtml#ch3lis24). We can safely assume that the code is responsible
    for assigning the values of these gibberish fields.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，恶意软件并没有试图隐藏代码中的乱码字符串，也没有在不同的上下文中重复使用相同的乱码名称。例如，在jadx中搜索`josiwo`只会返回一个位置，如[列表3-25](ch03.xhtml#ch3lis25)所示。此代码包含与[列表3-24](ch03.xhtml#ch3lis24)中解密的JSON对象完全相同的字段名称。我们可以安全地假设，这段代码负责为这些乱码字段分配值。
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 3-25: Building up the JSON payload of the registration message*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-25：构建注册消息的JSON有效负载*'
- en: With this extra context, we can see that `josiwo` is clearly the malware app’s
    own package name and `qredyb` is the device’s SDK build level. The string `kdthit`
    is always the number 6, but its meaning is unclear. Maybe it’s a version code
    to help the client and server negotiate a communication protocol.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些额外的上下文信息，我们可以看出，`josiwo`显然是恶意软件应用程序自己的包名，而`qredyb`是设备的SDK构建级别。字符串`kdthit`始终是数字6，但它的含义尚不明确。也许它是一个版本代码，用于帮助客户端和服务器协商通信协议。
- en: 'The meaning of `worikt` and `zubfih` are not immediately obvious, but following
    the code to the assignment of the two variables makes it possible to understand
    them: `worikt` is the device’s SIM operator code, as returned by `TelephonyManager.getSimOperator`
    (the 20610 code is for the provider Orange Belgium). The value of `zubfih` is
    more complex. Depending on the device’s API level, the value is either set to
    the Unix timestamp of the app’s install time or the device’s Android ID.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`worikt`和`zubfih`的含义不太明显，但通过追踪代码到这两个变量的赋值过程，可以理解它们的含义：`worikt`是设备的SIM卡运营商代码，由`TelephonyManager.getSimOperator`返回（20610代码代表比利时的运营商Orange）。`zubfih`的值则更复杂。根据设备的API级别，该值要么设置为应用安装时间的Unix时间戳，要么设置为设备的Android
    ID。'
- en: '***Processing the Registration Response***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理注册响应***'
- en: After a successful registration request, the command-and-control server responds
    with a string that decrypts to the JSON object shown in [Listing 3-26](ch03.xhtml#ch3lis26).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注册请求后，命令与控制服务器会响应一个字符串，解密后得到[清单3-26](ch03.xhtml#ch3lis26)中显示的JSON对象。
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-26: Response from the command-and-control server for a new client
    registration*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-26：新客户端注册的命令与控制服务器响应*'
- en: The exact meaning of the return value of `bshwai` is unclear, but it could be
    an ID assigned to the client. Using cURL to probe the command-and-control server
    returns the same value for `bshwai` until a new timestamp value is sent in the
    `zubfih` request field. It’s likely that the server uses the installation timestamp
    to distinguish between infected clients and assigns new client IDs on that basis.
    As the client IDs seem to increment linearly, it’s also possible to use this value
    to estimate the number of infected devices and how fast new devices are infected.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`bshwai`返回值的确切含义尚不清楚，但它可能是分配给客户端的ID。使用cURL探测命令与控制服务器会返回相同的`bshwai`值，直到在`zubfih`请求字段中发送一个新的时间戳值。很可能，服务器使用安装时间戳来区分被感染的客户端，并基于此分配新的客户端ID。由于客户端ID似乎是线性递增的，因此也有可能使用此值来估算感染设备的数量，以及新设备的感染速度。'
- en: The second return value, `xjnguw`, is also very interesting. In our tests, it
    was nearly always empty. It seems to depend on the app’s package name, because
    the server returned a non-empty value when we switched the package name parameter
    in `josiwo` to, for example, *com.takela.message*, the package name of another
    malware sample in the same family. Returned non-empty values look like *1_1487372418053478*,
    where the 1 (or sometimes 2) before the underscore is a version identifier for
    a fourth stage to download and the part after the underscore is a Facebook app
    ID used to initialize the Facebook SDK bundled in this fourth stage. The fourth
    stage is downloaded from *https://xn3o.oss-accelerate.aliyuncs.com/fbhx1* or *https://xn3o.oss-accelerate.aliyuncs.com/fbhx2*,
    depending on the version code. At the end of this chapter, we’ll take a look at
    these plug-ins.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个返回值`xjnguw`也非常有趣。在我们的测试中，它几乎总是为空。它似乎依赖于应用的包名，因为当我们将`josiwo`中的包名参数更改为例如*com.takela.message*（另一个同一恶意软件家族中的恶意软件样本的包名）时，服务器返回了一个非空值。返回的非空值像是*1_1487372418053478*，其中下划线前面的1（或有时是2）是第四阶段下载的版本标识符，下划线后的部分是用于初始化Facebook
    SDK的Facebook应用ID，Facebook SDK被打包在第四阶段中。第四阶段从*https://xn3o.oss-accelerate.aliyuncs.com/fbhx1*或*https://xn3o.oss-accelerate.aliyuncs.com/fbhx2*下载，具体取决于版本号。在本章的最后，我们将看看这些插件。
- en: '***Downloading Commands***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***下载命令***'
- en: After registering with the command-and-control server, the malware connects
    to *https://www.utansy.com/xn3o/ti* to retrieve commands to execute. These commands
    are used to connect to an affiliate website that forwards to a payment sign-up
    page. Once the page is loaded, the downloaded commands start to interact with
    it and sign the user up without their consent. Users will be billed on their next
    phone bill, and the affiliate that led to the sign-up is paid a reward.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在与命令与控制服务器注册后，恶意软件会连接到*https://www.utansy.com/xn3o/ti*以检索要执行的命令。这些命令用于连接到一个关联网站，该网站将转发到一个支付注册页面。一旦页面加载完毕，下载的命令会开始与之交互，并在用户不知情的情况下进行注册。用户将在下一个电话账单中被收费，而引导用户注册的关联方将获得奖励。
- en: The request payload sent to the command URL contains information collected by
    the malware about the state of the device. [Listing 3-27](ch03.xhtml#ch3lis27)
    shows an example request.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到命令URL的请求有效载荷包含恶意软件收集的有关设备状态的信息。[清单3-27](ch03.xhtml#ch3lis27)显示了一个请求示例。
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 3-27: Payload sent to the command-and-control server to request commands*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-27：发送到命令与控制服务器的有效载荷，请求命令*'
- en: The `eymbmw` field indicates whether the device is on a mobile network or not
    (devices need a mobile connection to sign up for many carrier billing sites).
    The `rktfht` field indicates whether the app has permission to receive incoming
    SMS messages or access app notifications, which the app needs in order to retrieve
    the one-time password for the billing sign-up process. The `segdip` field indicates
    whether the app has permission to send SMS messages, which is necessary to confirm
    the billing sign-up on some pages. The `elbcnf` field contains the device’s phone
    number, and `dgebpf` contains a list of all accounts registered with the device.
    Depending on the device, registered accounts can be someone’s email address, WhatsApp
    number, X account handle, or LinkedIn profile ID. It is unclear why the malware
    collects this information. Also included are the values `zubfih` and `bshwai`
    seen in the registration request.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`eymbmw` 字段指示设备是否处于移动网络状态（设备需要移动连接才能注册到许多运营商账单站点）。`rktfht` 字段指示应用程序是否有权限接收短信或访问应用通知，应用程序需要此权限才能获取账单注册过程中的一次性密码。`segdip`
    字段指示应用程序是否有权限发送短信，这对于在某些页面上确认账单注册是必需的。`elbcnf` 字段包含设备的电话号码，而 `dgebpf` 列出了与设备注册的所有账户。根据设备的不同，注册的账户可以是某人的电子邮件地址、WhatsApp
    号码、X 账户句柄或 LinkedIn 个人资料 ID。目前尚不清楚为什么恶意软件会收集这些信息。还包括了注册请求中看到的 `zubfih` 和 `bshwai`
    值。'
- en: '***Processing the Command-and-Control Server’s Response***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理命令与控制服务器的响应***'
- en: Interpreting the response received from the command URL is difficult, but [Listing
    3-28](ch03.xhtml#ch3lis28) shows the two most obvious fields.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 解释从命令 URL 接收到的响应是困难的，但[列表 3-28](ch03.xhtml#ch3lis28)展示了两个最明显的字段。
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 3-28: The response contains JavaScript code to navigate through sign-up
    pages.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-28：响应包含用于导航注册页面的 JavaScript 代码。*'
- en: The `gooycf` field contains the affiliate URL to be loaded in the next step
    of the fraud. The `jxdkqb` field contains a list of JavaScript instructions. These
    use a JavaScript bridge object injected into the premium sign-up website and allow
    the malicious JavaScript code to interact with the malicious Java code in *xn3o*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`gooycf` 字段包含要在欺诈的下一步加载的附属 URL。`jxdkqb` 字段包含一系列 JavaScript 指令。这些指令使用注入到高级注册网站中的
    JavaScript 桥接对象，允许恶意 JavaScript 代码与 *xn3o* 中的恶意 Java 代码进行交互。'
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the original JSON response from the server, this JavaScript code is found
    on a single line. We have formatted it here to make it more readable. We’ve also
    abbreviated it, as it is very long.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*在服务器返回的原始 JSON 响应中，这段 JavaScript 代码是单行显示的。我们在这里对其进行了格式化，使其更易于阅读。我们还对其进行了简化，因为它非常长。*'
- en: '***Secretly Signing Up for the Premium Service***'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***秘密注册高级服务***'
- en: After the affiliate URL and the JavaScript commands have been downloaded, the
    malware opens the affiliate URL in a customized WebView. The WebView’s customizations
    all involve intercepting loaded websites and manipulating them, partly to circumvent
    anti-bot protections on the sign-up page and partly to interact with the sign-up
    page to simulate a legitimate user.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在附属 URL 和 JavaScript 命令被下载后，恶意软件将在定制的 WebView 中打开附属 URL。WebView 的所有定制都涉及拦截加载的网站并对其进行操控，部分目的是绕过注册页面上的反机器人保护，部分目的是与注册页面进行交互，模拟合法用户。
- en: In a mobile web browser, opening the affiliate URL shown in the command response
    payload redirects to the site shown in [Figure 3-3](ch03.xhtml#ch3fig3).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动网页浏览器中，打开命令响应有效负载中显示的附属 URL 会重定向到[图 3-3](ch03.xhtml#ch3fig3)所示的站点。
- en: '![Image](../images/ch03fig03.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch03fig03.jpg)'
- en: '*Figure 3-3: Belgian premium service sign-up page*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：比利时高级服务注册页面*'
- en: This is the first stage of the premium service subscription process, where the
    user enters their phone number. In small text at the bottom, the cost of this
    service is disclosed to be six euros per week, and there are instructions for
    unsubscribing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高级服务订阅过程的第一阶段，用户在此输入其电话号码。在底部的小字中，透露了该服务的费用为每周六欧元，并提供了退订说明。
- en: '***Setting Up the JavaScript Bridge***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置 JavaScript 桥接***'
- en: After the sign-up page has loaded, the malware starts to interact with it through
    a *JavaScript interface*, a standard Android API in which an app can create a
    bridge between it and a website in a WebView object. A simple jadx search for
    the Android API `addJavascriptInterface` shows where this happens in *xn3o* ([Listing
    3-29](ch03.xhtml#ch3lis29)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册页面加载完成后，恶意软件开始通过*JavaScript接口*与其交互，Java接口标准Android API允许应用程序在WebView对象中创建与网站之间的桥接。简单的jadx搜索Android
    API `addJavascriptInterface`可以显示恶意软件在*xn3o*中发生的位置（[清单 3-29](ch03.xhtml#ch3lis29)）。
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-29: Setting up the JavaScript interface to manipulate the sign-up
    page*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-29：设置JavaScript接口以操作注册页面*'
- en: The first argument passed to `addJavascriptInterface` is a Java object that
    is made accessible from websites loaded into the WebView. The second argument
    is the name that the object should be given in JavaScript. JavaScript code can
    use this name to refer to the object and call methods defined in the object. In
    case of the malware, the name is simply `JBridge`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`addJavascriptInterface`传递的第一个参数是一个Java对象，它可以从加载到WebView中的网站访问。第二个参数是该对象在JavaScript中应赋予的名称。JavaScript代码可以使用这个名称来引用该对象并调用定义在该对象中的方法。在恶意软件中，这个名称就是`JBridge`。'
- en: The Java class `zse4`, which defines the JavaScript bridge object, has only
    one method marked with the `@JavascriptInterface` decorator, the `call` method.
    Only methods marked with this decorator are accessible from JavaScript, so this
    is the only method the JavaScript part of the malware can invoke. Inside the `call`
    method is a long chain of `if...else` statements, which in malware often indicates
    a piece of code that interprets commands. Finding malware’s command interpreter
    is a jackpot for reverse engineers, as it lets them see which commands are backed
    by what code. This helps reverse engineers quickly understand large parts of malicious
    functionality.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Java类`zse4`定义了JavaScript桥接对象，它只有一个用`@JavascriptInterface`装饰器标记的方法，即`call`方法。只有标记了这个装饰器的方法才能从JavaScript访问，因此这是恶意软件的JavaScript部分可以调用的唯一方法。在`call`方法内部，有一长串`if...else`语句，这在恶意软件中通常表示一个解释命令的代码段。找到恶意软件的命令解释器是逆向工程师的宝藏，因为它能让他们看到哪些命令由哪些代码支持。这帮助逆向工程师迅速理解恶意功能的大部分内容。
- en: Based on the arguments to `call`, we can already see that the first argument
    is the command name and the second argument is the command options. The long `if...else`
    chain checks the command name and invokes different code based on the command
    to execute. A slice of that functionality is shown in [Listing 3-30](ch03.xhtml#ch3lis30).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`call`方法的参数，我们已经可以看到第一个参数是命令名称，第二个参数是命令选项。长串的`if...else`链检查命令名称，并根据命令调用不同的代码来执行。该功能的部分代码在[清单
    3-30](ch03.xhtml#ch3lis30)中显示。
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 3-30: Processing JavaScript commands in the zse4 class*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-30：在zse4类中处理JavaScript命令*'
- en: In this code, the `str` argument is compared to string values `finish`, `schedule`,
    `textTo`, and `popMsg`, respectively. Following the methods called from inside
    the `if` clauses reveals the code that backs these commands.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`str`参数依次与字符串值`finish`、`schedule`、`textTo`和`popMsg`进行比较。跟踪`if`语句内部调用的方法可以揭示支撑这些命令的代码。
- en: '***Interacting with the Java Bridge Object***'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与Java桥接对象的交互***'
- en: Now that you understand the Java implementation of the JavaScript bridge object,
    take a closer look at the downloaded JavaScript commands, shown in [Listing 3-31](ch03.xhtml#ch3lis31).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了JavaScript桥接对象的Java实现，接下来仔细查看下载的JavaScript命令，见[清单 3-31](ch03.xhtml#ch3lis31)。
- en: '[PRE32]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 3-31: JavaScript code is used to subscribe to the premium service.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-31：JavaScript代码用于订阅高级服务。*'
- en: First, the code tries to find the phone number input field on the subscription
    site using the `querySelector` method. Once it has discovered this, the code inputs
    the device’s phone number into the field, uses JavaScript to click the subscription
    button, and calls the method `nextThings`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码使用`querySelector`方法尝试在订阅网站上找到电话号码输入框。找到后，代码将设备的电话号码输入到该字段中，使用JavaScript点击订阅按钮，并调用`nextThings`方法。
- en: '[Listing 3-32](ch03.xhtml#ch3lis32) shows an excerpt of the code from `nextThings`,
    where many lines invoke the `call` method of the bridge object. As the bridge
    object is defined by the Java class `zse4`, we can easily follow what these lines
    do. Analysis of `zse4` confirms that the command names are true to their meaning:
    the JavaScript code tries to intercept an incoming SMS (`popMsg`) and send a confirmation
    SMS to the number 9956 to complete the registration process (`textTo`).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-32](ch03.xhtml#ch3lis32)展示了`nextThings`中的代码摘录，许多行调用了桥接对象的`call`方法。由于桥接对象由Java类`zse4`定义，我们可以轻松地跟踪这些行的作用。对`zse4`的分析确认了命令名称与其含义一致：JavaScript代码试图拦截一条传入的短信(`popMsg`)，并向号码9956发送确认短信以完成注册流程(`textTo`)。'
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 3-32: The payload connects Java and JavaScript code through JavaScript
    interface JBridge.*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-32：有效载荷通过JavaScript接口JBridge连接Java和JavaScript代码。*'
- en: 'One mystery remains: how are the JavaScript commands actually executed in the
    context of the subscription website? There’s a standard Android API for that:
    `WebView.evaluateJavascript`, which allows an app to inject any JavaScript code
    into a website.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个谜团：JavaScript命令是如何在订阅网站的上下文中执行的呢？对此有一个标准的Android API：`WebView.evaluateJavascript`，它允许应用将任何JavaScript代码注入到网站中。
- en: '***Completing the Sign-up Process***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***完成注册流程***'
- en: At a different code location, the list `vgy7Var.yhn6` is read and the intercepted
    SMS messages and notifications are processed. A quick reference check in jadx
    shows that the only place in the code where the list is read is in the `bhu8`
    method.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个代码位置，`vgy7Var.yhn6`列表被读取，并且拦截到的短信和通知被处理。通过在jadx中快速查阅，我们发现代码中唯一读取该列表的地方是在`bhu8`方法中。
- en: This method, shown in [Listing 3-33](ch03.xhtml#ch3lis33), takes a string argument
    of the form `number::string`, which it splits at the double colon (`::`). The
    first part of this argument is used as a regular expression to parse the SMS.
    The second part contains the regular expression capture group number where the
    one-time password is expected. The method also takes an integer argument used
    to sleep the current thread if the expected SMS can’t be found. It likely does
    this to wait for the SMS to arrive and then check for it again.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 3-33](ch03.xhtml#ch3lis33)所示，该方法接收一个形式为`number::string`的字符串参数，并在双冒号(`::`)处分割。该参数的第一部分作为正则表达式来解析短信。第二部分包含一个正则表达式捕获组的数字，表示预期的一次性密码的位置。该方法还接受一个整数参数，用于在找不到预期短信时使当前线程进入休眠状态。它可能这样做是为了等待短信到达，然后再次检查它。
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-33: Parsing for the one-time password*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-33：解析一次性密码*'
- en: 'The `bhu8` method is called from two places in *xn3o*: once with a hardcoded
    string argument built to parse SMS messages from certain Thai subscription sites
    and once from the command handler for the `popMsg` command. For the Belgian subscription
    site, the malware uses the second option. We now know that the JavaScript code
    shown in [Listing 3-34](ch03.xhtml#ch3lis34) and previously downloaded from the
    command-and-control server is a simple extractor for a number with three to six
    digits.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`bhu8`方法从*xn3o*中的两个地方被调用：一次是通过硬编码的字符串参数，该参数用于解析来自某些泰国订阅网站的短信消息；另一次是从`popMsg`命令的命令处理器调用。对于比利时订阅网站，恶意软件使用的是第二种方式。我们现在知道，[列表
    3-34](ch03.xhtml#ch3lis34)中显示的JavaScript代码，之前从指挥与控制服务器下载的，实际上是一个简单的提取器，用于提取三到六位数的数字。'
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-34: Parsing the one-time password for the Belgian sign-up page*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-34：解析比利时注册页面的一次性密码*'
- en: What happens after the call to the `popMsg` method is noteworthy. [Listing 3-32](ch03.xhtml#ch3lis32)
    showed that, no matter the number extracted from the SMS, the app continues the
    sign-up process by sending the message *ok* to the phone number 9956\. While we
    don’t have access to a real Belgian phone to observe the complete sign-up process,
    we can assume that this premium service doesn’t use one-time passwords at all.
    Maybe users can confirm their subscription by simply texting *ok* to the service’s
    premium number.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`popMsg`方法后的行为值得注意。[列表 3-32](ch03.xhtml#ch3lis32)显示，无论从短信中提取出什么数字，应用都会继续通过发送*ok*消息到电话号码9956来完成注册流程。虽然我们无法访问真正的比利时电话来观察完整的注册过程，但可以推测，这个增值服务根本没有使用一次性密码。也许用户可以仅仅通过向服务的增值号码发送*ok*来确认他们的订阅。
- en: '**The Mysterious Fourth Stage**'
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**神秘的第四阶段**'
- en: 'Before we wrap up this chapter, let’s have a quick look at the mysterious fourth
    stage that the malware seems to rarely use. Downloading the previously mentioned
    *fbhx1* and *fbhx2* files and loading them in jadx shows that they each have just
    a single package name: *com.facebook.** or *com.facebook2.**.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，快速看一下恶意软件似乎很少使用的神秘第四阶段。下载前面提到的 *fbhx1* 和 *fbhx2* 文件，并在 `jadx` 中加载它们，可以看到它们各自只有一个包名：*com.facebook.**
    或 *com.facebook2.**。
- en: 'In a first step, we can try to determine the differences between *fbhx1* and
    *fbhx2*. The command line version of jadx is helpful here, as we can just decompile
    both files and then use standard programming tools to diff the two generated source
    code folders. As the package names *com.facebook.** and *com.facebook2.** are
    slightly different, we have to rename *facebook2* to *facebook* before standard
    code diffing tools work well on the output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们可以尝试确定 *fbhx1* 和 *fbhx2* 之间的差异。`jadx` 的命令行版本在这里很有帮助，因为我们只需反编译这两个文件，然后使用标准编程工具对比生成的源代码文件夹。由于包名
    *com.facebook.** 和 *com.facebook2.** 有些微差异，我们必须先将 *facebook2* 重命名为 *facebook*，才能使标准代码比较工具在输出上正常工作：
- en: '[PRE36]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The output, omitted here, contains only some differences seemingly caused by
    jadx decompilation quirks. It appears that the code of *fbhx1* and *fbhx2* is
    functionally identical. Knowing this, let’s take a look at how the malware interacts
    with these two files. Depending on which file is loaded, it appears that *xn3o*
    interacts with *fbhx* in only one section of code. [Listing 3-35](ch03.xhtml#ch3lis35)
    shows that the malware loads class `j` and calls methods `a` and `c`, respectively.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容在此省略，只有一些看起来是由 `jadx` 反编译特性引起的差异。看起来 *fbhx1* 和 *fbhx2* 的代码在功能上是相同的。知道这一点后，我们来看看恶意软件是如何与这两个文件交互的。根据加载的文件不同，似乎
    *xn3o* 仅在代码的某个部分与 *fbhx* 交互。[列表 3-35](ch03.xhtml#ch3lis35) 显示，恶意软件加载了 `j` 类，并分别调用了
    `a` 和 `c` 方法。
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 3-35: The malware loading the Facebook SDK*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-35：恶意软件加载 Facebook SDK*'
- en: A quick web search for the many strings in `j` reveals that this class is originally
    `FacebookSdk`. The `a` method is really `setApplicationId` and the `c` method
    is really `sdkInitialize`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `j` 类中的许多字符串进行快速网络搜索，发现该类原本是 `FacebookSdk`。`a` 方法实际上是 `setApplicationId`，而
    `c` 方法实际上是 `sdkInitialize`。
- en: Is the Facebook SDK legitimate, or has it been maliciously manipulated? The
    answer to that question is unclear, as, to our knowledge, there are no good public
    tools available to find maliciously modified SDKs in Android apps. Even if such
    tools were available, you would have to first find the original, legitimate SDK
    to compare with the malware’s version. Luckily the `FacebookSdk` class contains
    a version string that makes that part easier.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook SDK 是否是合法的，还是被恶意篡改过？这个问题的答案尚不明确，因为据我们所知，目前没有有效的公开工具可以用于查找 Android 应用中被恶意修改的
    SDK。即使有这样的工具，你也必须首先找到原始的、合法的 SDK，才能与恶意软件版本进行比较。幸运的是，`FacebookSdk` 类包含了一个版本字符串，这使得这部分工作变得更容易。
- en: In the absence of useful tools, we’ll have to leave the answer to this question
    open. The Facebook SDK, as decompiled by jadx, contains more than 20,000 lines
    of code in more than 150 classes. That’s too much to manually compare to the real
    Facebook SDK. As names in the *fbhx* files are mangled, a simple diff tool will
    barely help, either.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在缺乏有效工具的情况下，我们只能将这个问题的答案留白。通过 `jadx` 反编译的 Facebook SDK 包含了超过 20,000 行代码，分布在
    150 多个类中。这么多的代码很难手动与真实的 Facebook SDK 进行比较。而且，由于 *fbhx* 文件中的名称已被混淆，使用简单的 diff 工具几乎无法提供帮助。
- en: '**Up Next**'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接下来**'
- en: This completes our introduction to static Android malware analysis. You learned
    about the tools you can use to statically reverse engineer malware code, as well
    as many best practices for doing so.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对静态 Android 恶意软件分析的介绍。你了解了可以用来静态逆向工程恶意软件代码的工具，以及许多最佳实践。
- en: For brevity, we omitted significant chunks of code from our explanation of the
    malware’s core functionality. For example, we didn’t include the code used to
    parse the HTML of the premium sign-up pages. Likewise, the malware contains code
    to thwart several commercially available products that premium services can license
    to protect their sign-up pages from bot activity; we left this undescribed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们在解释恶意软件核心功能时省略了大量代码。例如，我们没有包括解析高级注册页面 HTML 的代码。同样，恶意软件中还包含了代码，用来破坏一些商业可用的产品，这些产品是高级服务可以授权用于防止机器人活动的注册页面保护；我们对此未作描述。
- en: Also not described is the malware’s complex messaging system. Different parts
    of the malware, in both the Java and JavaScript components, exchange messages
    using the default Android messaging system. These messages help the malware organize
    and execute its next steps depending on its current state and how far the sign-up
    process has progressed. Following this messaging system isn’t trivial due to its
    asynchronous nature and its use of broadcasts and message queues.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个未描述的部分是恶意软件复杂的消息传递系统。恶意软件的不同部分，在 Java 和 JavaScript 组件中，使用默认的 Android 消息传递系统交换消息。这些消息帮助恶意软件根据其当前状态以及注册过程的进展情况来组织和执行下一步操作。由于其异步性质以及使用广播和消息队列，跟踪这个消息传递系统并非易事。
- en: While powerful, static analysis is only part of malware analysis and needs to
    be supplemented with dynamic analysis. In the next chapter, we’ll do just that,
    as we analyze a different malware sample using dynamic analysis techniques.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管静态分析很强大，但它只是恶意软件分析的一部分，需要结合动态分析来使用。在下一章中，我们将正是这样做，我们将使用动态分析技术分析另一个恶意软件样本。
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[*OceanofPDF.com*](https://oceanofpdf.com)'
