- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: STATIC ANALYSIS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter and the next present a hands-on approach to Android malware analysis
    by walking through an examination of two Android malware samples from 2022, a
    toll fraud app and a phishing app. In this chapter, we focus on static malware
    analysis and code reading. In [Chapter 4](ch04.xhtml), we discuss dynamic analysis,
    or running a malware sample in a controlled environment to observe its behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章通过对两个2022年Android恶意软件样本（一个收费欺诈应用和一个钓鱼应用）的分析，提供了一种实践性的Android恶意软件分析方法。在本章中，我们重点关注静态恶意软件分析和代码阅读。在[第4章](ch04.xhtml)中，我们讨论动态分析，即在受控环境中运行恶意软件样本以观察其行为。
- en: Rather than treating these chapters as references, you should consider them
    to be examples of real malware analyses through which we introduce Android reverse
    engineering tools and highlight certain best practices. Collectively, the authors
    of this book have examined more than 100,000 Android malware samples over the
    last 10 years. Here, we share some of what we have learned to give your own analyses
    a jump start.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将这些章节视为参考资料，不如将它们看作是实际恶意软件分析的示例，通过这些示例我们介绍了 Android 逆向工程工具并强调了一些最佳实践。本书的作者在过去10年中分析了超过100,000个
    Android 恶意软件样本。在这里，我们分享一些我们所学到的东西，帮助你为自己的分析提供启示。
- en: '**What Is Static Code Analysis?**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是静态代码分析？**'
- en: The term *static code analysis*, or simply *static analysis*, refers to the
    process of analyzing a program to discover its properties without actually executing
    it. This strategy contrasts with *dynamic analysis*, introduced in the next chapter,
    where the program under observation is run to observe its runtime behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态代码分析*（简称 *静态分析*）指的是在不实际执行程序的情况下分析程序以发现其属性的过程。这一策略与接下来章节中介绍的*动态分析*形成对比，在动态分析中，观察的程序会被运行，以观察其运行时行为。'
- en: Static analysis encompasses many techniques. You can think of it as a set of
    approaches to reasoning about programs, including reading program code as well
    as automated strategies like control flow analysis and data flow analysis aimed
    at understanding the order in which a program executes instructions and how data
    flows through its variables and memory. There are also more advanced static analysis
    techniques, such as model checking (used to confirm or disprove properties of
    a piece of code) and abstract interpretation (a way to explore program states
    through simulated execution), but we won’t cover these advanced techniques in
    this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析包括多种技术。你可以将其视为一组推理程序的方式，包括阅读程序代码以及像控制流分析和数据流分析这样的自动化策略，目的是理解程序执行指令的顺序以及数据如何在变量和内存中流动。还有更高级的静态分析技术，如模型检查（用于确认或否定一段代码的属性）和抽象解释（通过模拟执行来探索程序状态），但本书不会涉及这些高级技术。
- en: The following subsections provide some general guidelines for making static
    analysis more efficient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节提供了一些提高静态分析效率的通用指南。
- en: '***Guided vs. Unguided Analysis***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***引导分析与非引导分析***'
- en: In professional malware analysis, it is rare to examine a random app sample
    that you don’t know anything about. Instead, reverse engineers usually look at
    a particular app to confirm or disprove previously collected assumptions about
    its properties. This information can come from malware scanners that flag an app
    on your system, random X chatter, the output of a quick run in an analysis engine,
    or analysis of related samples. In these *guided* scenarios, reverse engineers
    generally know where to start looking. The malware walkthroughs in this and the
    next chapter are *unguided*, meaning we embark without any prior information about
    the samples. All discoveries must be made by inspecting the apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业的恶意软件分析中，很少会分析一个你完全不了解的随机应用样本。相反，逆向工程师通常会查看特定的应用，以确认或否定之前收集的关于其属性的假设。这些信息可能来自恶意软件扫描器标记你系统上的应用、随机的X聊天、分析引擎快速运行的输出，或是相关样本的分析。在这些*引导*场景中，逆向工程师通常知道从哪里开始查看。这里和下一章中的恶意软件分析是*非引导*的，意味着我们在没有任何关于样本的先验信息的情况下开始分析。所有的发现都必须通过检查应用来完成。
- en: Even though unguided reverse engineering is less common in a professional context,
    it can still happen. In these scenarios, reverse engineers should find ways to
    avoid doing full code reviews, as these are costly and take too long for all but
    the most important malware samples. At the same time, the reverse engineer must
    remain confident that no significant part of the malware remains undiscovered,
    even when the code analysis is partial.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to avoid full code reviews is to develop an understanding of
    the SDKs used in apps. We estimate that about 80 percent of the code in an average
    app comes from third-party SDKs. Android reverse engineers must have tools for
    identifying SDKs; otherwise, they will find themselves painstakingly rediscovering
    information they could have learned by reading publicly available SDK documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '***Knowing When You’re Done***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a professional setting, the goal of the analysis determines when you are
    done. If the goal is to classify an app as malware and protect users as fast as
    possible, malware analysis can be extremely superficial. For a phishing app, for
    example, you can look through a sample for less than a minute, find evidence that
    it targets banking apps, record this, and move on. If the goal is to document
    the malicious functionality in a report, or if the analysis is in response to
    an incident at a customer site, you may have to go deeper and spend days or weeks
    on the sample. This chapter and the next will aim to describe the most important
    functionality of the presented malware samples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Experience has shown that malware analysts should either move quickly, to rapidly
    confirm that an app is malware so steps can be taken to disable it, or move slowly
    in order to investigate it in depth and, along the way, learn how to improve their
    tools and processes. Avoid lengthy malware analysis in cases when you aren’t likely
    to learn any lessons for making future analysis easier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading the Malware Sample into jadx**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android malware sample we analyze in this chapter is *com.bp.statis.bloodsugar*
    (v20, adcf). This app, which masquerades as a blood sugar statistics tracker,
    was uploaded to Google Play in February 2022 and is fairly representative of modern
    Android malware. It contains many anti-analysis techniques, downloads remote components
    from a command-and-control server, and abuses mobile carrier billing options to
    run up fraudulent charges. You can download the file from [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: To read the app’s code, we use the open source Android reverse engineering tool
    *jadx*. This tool can take Android code files in formats like APK, DEX, JAR, and
    others and turn them into decompiled Java code that we can understand. Additionally,
    jadx has handy features such as the ability to rename variables and locate the
    places where variables and methods appear in the code. It even has advanced tools
    like a debugger, automated code deobfuscation, and integration with Quark Engine,
    an open source malware analysis engine. You can download jadx from [*https://github.com/skylot/jadx*](https://github.com/skylot/jadx).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阅读应用的代码，我们使用开源的 Android 反向工程工具 *jadx*。该工具可以将 APK、DEX、JAR 等格式的 Android 代码文件转换为可供理解的反编译
    Java 代码。此外，jadx 还有许多方便的功能，如重命名变量以及定位变量和方法在代码中出现的位置。它甚至具有高级工具，如调试器、自动化代码去混淆工具和与开源恶意软件分析引擎
    Quark Engine 的集成。你可以从 [*https://github.com/skylot/jadx*](https://github.com/skylot/jadx)
    下载 jadx。
- en: In the GUI version of jadx, use **File** ▸ **Open Files** to open the malware
    sample to analyze. You should then see the app’s Java package structure in the
    navigation tree on the left-hand side of the interface ([Figure 3-1](ch03.xhtml#ch3fig1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jadx 的图形界面版本中，使用 **文件** ▸ **打开文件** 来打开恶意软件样本进行分析。然后，你应该能在界面左侧的导航树中看到应用的 Java
    包结构（[图 3-1](ch03.xhtml#ch3fig1)）。
- en: The large window on the right-hand side shows the decompiled code for the selected
    Java class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的大窗口显示了选定 Java 类的反编译代码。
- en: '![Image](../images/ch03fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch03fig01.jpg)'
- en: '*Figure 3-1: The jadx main window looks like a code IDE.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：jadx 主窗口看起来像一个代码 IDE。*'
- en: '**Malicious Code in the Permissions**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**权限中的恶意代码**'
- en: The first step of a static analysis should be to locate the malicious parts
    of the app as quickly as possible. Analysts each have their preferences about
    how to do this, as it is not an exact science. We will introduce you to four options
    that we use regularly. The first, described in this section, is to look at the
    permissions the app declares its intention to use and figure out how it might
    use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的第一步应该是尽快定位到应用中的恶意部分。分析师各有偏好，因为这并不是一门精确的科学。我们将在本节中介绍四种我们常用的选项。第一种方法是查看应用声明将要使用的权限，并弄清楚它可能如何使用这些权限。
- en: 'Permissions are often the first thing on people’s minds when they consider
    the security of Android apps. Apps must declare permissions in order to use sensitive
    Android APIs, and users must grant the necessary permissions to the apps before
    they can access those APIs. As this permission model relies on user interaction
    and consent, it is highly visible to everybody using Android phones. However,
    users and reverse engineers alike often draw the wrong conclusions about apps
    based on their permissions. The permission system is ultimately a gentleman’s
    agreement between the app and the user: the app declares that it will use a permission
    for an advertised purpose, but the operating system can’t check what the app actually
    does with it.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们考虑 Android 应用的安全性时，权限往往是首先想到的。应用必须声明权限才能使用敏感的 Android API，用户必须在应用访问这些 API
    之前授予必要的权限。由于这一权限模型依赖于用户互动和同意，它对所有使用 Android 手机的人来说都非常显眼。然而，无论是用户还是逆向工程师，往往会根据应用声明的权限得出错误的结论。权限系统最终是应用与用户之间的一种绅士协议：应用声明它会为了某个宣传的目的使用某个权限，但操作系统无法检查应用实际上如何使用该权限。
- en: Moreover, getting an accurate view of how an app uses permissions can be complicated.
    Apps can hide this information through techniques like reflection, as we show
    later in this chapter. Apps can also collude with each other to indirectly access
    more permissions than the user granted them. If an app doesn’t have permission
    to send SMS messages, it may ask another installed app to send messages on its
    behalf. In the worst case, malware could even use exploits to elevate its privileges
    outside the boundaries of the permission system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，准确地了解应用如何使用权限可能很复杂。应用可以通过反射等技术隐藏这些信息，正如我们在本章稍后所展示的那样。应用还可以通过相互协作，间接访问用户未授予的更多权限。如果一个应用没有发送短信的权限，它可能会请求另一个已安装的应用代表它发送短信。在最坏的情况下，恶意软件甚至可以利用漏洞提升其权限，超出权限系统的边界。
- en: Nevertheless, permissions still provide a reasonable way to gain insight into
    unknown malware. Malware that colludes with other apps or uses exploits to elevate
    its permission privileges is rare. Without any indicators that you’re dealing
    with such malware, it’s reasonable to treat the permissions declared by an app
    as the limits of its capabilities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，权限仍然是获得未知恶意软件洞察的一种合理方式。与其他应用串通或利用漏洞提升权限的恶意软件比较少见。在没有任何迹象表明你遇到这种恶意软件的情况下，合理的做法是将应用声明的权限视为其能力的限制。
- en: '***Viewing the Permissions***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看权限***'
- en: Apps must declare all permissions they want to use in their *Android Manifest.xml*
    file, found in the root folder of an Android app’s APK. [Figure 3-2](ch03.xhtml#ch3fig2)
    shows the beginning of the manifest file for our sample, which you can view in
    jadx by navigating to **Resources** ▸ **AndroidManifest.xml**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用必须在其 *Android Manifest.xml* 文件中声明它们要使用的所有权限，该文件位于 Android 应用 APK 的根文件夹中。[图
    3-2](ch03.xhtml#ch3fig2) 显示了我们示例的清单文件的开头，你可以在 jadx 中通过 **Resources** ▸ **AndroidManifest.xml**
    来查看它。
- en: '![Image](../images/ch03fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch03fig02.jpg)'
- en: '*Figure 3-2: Viewing app permissions in jadx*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：在 jadx 中查看应用权限*'
- en: 'Here, you can see some of the app’s requested permissions. Others, declared
    later in the file, are not visible in the screenshot. The sample uses `<uses-permission>`
    tags to declare its intent to use the following permissions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一些应用请求的权限。文件中稍后声明的其他权限在截图中不可见。示例使用 `<uses-permission>` 标签声明其使用以下权限的意图：
- en: '`INTERNET`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNET`'
- en: '`WAKE_LOCK`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAKE_LOCK`'
- en: '`RECEIVE_BOOT_COMPLETED`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECEIVE_BOOT_COMPLETED`'
- en: '`READ_CONTACTS`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_CONTACTS`'
- en: '`READ_PHONE_STATE`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_PHONE_STATE`'
- en: '`CHANGE_NETWORK_STATE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGE_NETWORK_STATE`'
- en: '`ACCESS_NETWORK_STATE`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_NETWORK_STATE`'
- en: '`BIND_GET_INSTALL_REFERRER_SERVICE`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_GET_INSTALL_REFERRER_SERVICE`'
- en: 'Using `<service>` tags, it also declares its intent to use these permissions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<service>` 标签，它还声明了使用这些权限的意图：
- en: '`BIND_NOTIFICATION_LISTENER_SERVICE`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_NOTIFICATION_LISTENER_SERVICE`'
- en: '`BIND_JOB_SERVICE`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_JOB_SERVICE`'
- en: For malware analysis, not all permissions are equally important. For example,
    the `WAKE_LOCK` permission doesn’t seem particularly interesting, as it refers
    to APIs for keeping devices awake or waking them up from sleep. The `INTERNET`
    permission is also not useful; nearly every app uses it, so it doesn’t help us
    differentiate between malicious and benign apps. On the other hand, any of the
    data access permissions, whose names start with `READ_`, are potentially interesting.
    For example, why would a blood sugar metrics app need access to your contact list?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于恶意软件分析，并非所有权限都同样重要。例如，`WAKE_LOCK` 权限似乎并不特别有趣，因为它涉及的是保持设备唤醒或从睡眠状态唤醒设备的 API。`INTERNET`
    权限也没有什么用处；几乎每个应用都在使用它，因此它不能帮助我们区分恶意应用和良性应用。另一方面，任何以 `READ_` 开头的数据访问权限都可能是值得关注的。例如，为什么一款血糖监测应用需要访问你的联系人列表？
- en: '***Finding the APIs Gated by Permissions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找权限控制的 API***'
- en: To find malicious code based on an app’s declared permissions, you also need
    to know which Android APIs the permissions protect, or *gate*. Figuring this out
    is a surprisingly complex process, because no official reference for this information
    exists. Over the years, several academic research teams have tried to create Android
    API permission maps. This has also proved complicated—each new Android version
    introduces changes to the permission system, so keeping API maps up-to-date is
    a chore—but these maps can help you locate the permission-gated APIs. In 2016,
    researchers from Saarland University and Pennsylvania State University created
    such a map, which you can find at [*https://github.com/reddr/axplorer*](https://github.com/reddr/axplorer).
    Another option is the map created by researchers at Purdue University in 2018,
    which you can find at [*https://arcade-android.github.io/arcade*](https://arcade-android.github.io/arcade).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据应用声明的权限查找恶意代码，你还需要了解这些权限保护或*控制*哪些 Android API。弄清楚这一点是一个出乎意料的复杂过程，因为目前没有官方的参考资料。多年来，多个学术研究团队尝试创建
    Android API 权限图谱，但这也证明很复杂——每个新的 Android 版本都会对权限系统进行更改，因此保持 API 图谱的更新是一项繁琐的工作——不过，这些图谱可以帮助你定位由权限控制的
    API。2016年，萨尔大学和宾夕法尼亚州立大学的研究人员创建了这样的一个图谱，你可以在 [*https://github.com/reddr/axplorer*](https://github.com/reddr/axplorer)
    找到它。另一个选项是2018年由普渡大学研究人员创建的图谱，你可以在 [*https://arcade-android.github.io/arcade*](https://arcade-android.github.io/arcade)
    找到它。
- en: Unfortunately, jadx cannot automatically show the APIs gated by permissions.
    To quickly locate them in the app, you could use the command line version of jadx
    and then write a script that parses one of the permission maps to compare it with
    the app’s decompiled code. Over time, serious Android reverse engineers should
    build a more robust solution for this task.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to locating permission-protected APIs in well-developed apps
    is to look for code that asks the user for consent to use these permissions. For
    example, you could search for strings containing *permission*, or for APIs used
    to request permission access. Well-written apps should ask users for consent right
    before they want to use an API, so the relevant code should be nearby.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing the READ_CONTACTS Permission***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `READ_CONTACTS` permission showcases another problem with permission maps:
    in Android, permissions don’t protect just APIs. They also protect the content
    providers that are the sources of sensitive data. While the permission maps mentioned
    in the previous section show some very obscure APIs behind the `READ_CONTACTS`
    permission, this permission usually just provides access to the user’s contact
    list through the content providers `content://contacts` or `content://com.android.contacts`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Thus, upon spotting this permission, you might first think that it might be
    used to steal someone’s contact list information. However, why wouldn’t a spyware
    app also request `READ_SMS`, `READ_CALENDAR`, and `READ_CALL_LOGS` permissions
    to steal SMS, calendar, and call information? Spyware that targets only contact
    list information certainly exists, but it’s much rarer than spyware that grabs
    more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In jadx, you can use the hotkey CTRL-SHIFT-F to search through all of an app’s
    code and resource files. But searching for *contact* and disabling case sensitivity
    in our sample returns only a few results, including the permission declaration
    in the manifest file. A couple of code lines, in classes in packages whose names
    start with *androidx.activity* or *com.google.android.gms*, appear to be APIs
    provided by Google. Using `READ_CONTACTS` to find malicious functionality didn’t
    work out for this sample.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Again, though, there are caveats to concluding that this permission *isn’t*
    used maliciously. The malicious code using `READ_CONTACTS` could be in an encrypted
    code section or otherwise hidden from our manual analysis. Or the code files described
    as Google APIs could have been injected with malicious code. Or maybe those code
    files have nothing to do with Google SDKs and are malicious code files that have
    adopted the standard Google class naming pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Any of these could be true, but we recommend going broad first and deep later.
    As long as you have other ways to progress through an app, chase those leads down
    before delving into possible but unlikely scenarios like manipulated Google SDKs
    (which definitely exist in real malware but are rarely encountered in any individual
    malware sample). Later in this chapter, we will discover that this malware uses
    `READ_CONTACTS` after all. Its use is hidden from casual analysis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing the BIND_NOTIFICATION_LISTENER_SERVICE Permission***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another interesting permission in the sample is `BIND_NOTIFICATION_LISTENER_SERVICE`,
    which allows apps to access the notifications shown to the user by all other apps.
    Despite its seemingly harmless functionality, malware often abuses this permission,
    as app notifications can contain sensitive information that malware likes to steal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This permission is always tied to a service that receives updates about new
    notifications. [Listing 3-1](ch03.xhtml#ch3lis1) shows how our sample app declares
    the use of the permission and its associated service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: The declaration of the notification listener service, which receives
    information about incoming notifications*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The name of the service class is declared as `com.bp.statis.bloodsugar.PE`,
    but if you look for this class in the jadx file browser, you won’t be able to
    find it. That’s noteworthy. Why would the app declare a service for which no code
    is available? It could be a bug in the app, but later in this chapter we will
    discover that the class is in fact hidden from analysis. For now there is little
    we can do, as we are unable to locate the service code. For brevity, we leave
    a similar analysis of the other declared permissions as an exercise for the reader.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious Code in App Entry Points**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android applications have a surprisingly large number of *entry points*, or
    parts of the code where the Android operating system starts executing the app.
    Common entry points are exported activities (including the app’s main activity);
    broadcast receivers, which handle messages sent by the operating system or other
    apps; services defined by the app to execute long-running operations; and subclasses
    of the `android.app.Application` class. Looking at code at these entry points
    can be a fruitful way to find malicious code, as harmful functionality likes to
    run sooner rather than later. Why wait for the user to interact with an app for
    10 minutes when you can steal their information right away, when they launch the
    app?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Still, not all entry points are equally likely to harbor malicious code, and
    we should first consider those that are more commonly used in malware. For example,
    while every malicious and benign app has a main activity, looking there for malicious
    functionality is likely not a good start. On the other hand, looking at the broadcast
    receiver for the `BOOT_COMPLETED` events may be more promising. Malware likes
    to gain persistence on devices, and having the system execute the malware every
    time the device reboots is a common way to achieve that goal.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有入口点都有同等的可能性藏有恶意代码，我们应该首先考虑那些在恶意软件中更常见的入口点。例如，尽管每个恶意应用和良性应用都有一个主活动，但在主活动中寻找恶意功能可能不是一个好的开始。另一方面，查看用于`BOOT_COMPLETED`事件的广播接收器可能更有前景。恶意软件喜欢在设备上获得持久性，并且让系统在每次设备重启时执行恶意软件是实现这一目标的常见方式。
- en: '***Exported Activities***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导出活动***'
- en: In Android apps, *activities* are the key mechanism for presenting user interfaces.
    They’re best thought of as screens or dialogs. When a user launches an app, the
    first thing they usually see is the main activity. User interactions with the
    current activity may trigger new activities, like the next step in a workflow,
    a settings activity, or a file sharing activity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 应用中，*活动*是呈现用户界面的关键机制。它们最好被认为是屏幕或对话框。当用户启动应用时，他们通常首先看到的是主活动。用户与当前活动的互动可能会触发新的活动，比如工作流中的下一步、设置活动或文件共享活动。
- en: Not all activities are entry points into applications. To identify those, we
    need to distinguish between so-called *exported* and *non-exported* activities.
    Activities marked in the manifest file as `android:exported=”true”` can be started
    from outside the current app and so are considered entry points. Activities marked
    as `android:exported=”false”` can only be started from within the current app
    and are not entry points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有活动都是应用程序的入口点。为了识别这些活动，我们需要区分所谓的*导出活动*和*非导出活动*。在清单文件中标记为`android:exported="true"`的活动可以从应用外部启动，因此被视为入口点。标记为`android:exported="false"`的活动只能从应用内部启动，不能作为入口点。
- en: However, finding exported activities can be tricky. Before Android 12, developers
    could omit the `android:exported` tag from activity declarations. In those cases,
    whether the activity’s default value was `true` or `false` depended on other configuration
    properties. This proved confusing to app developers and led to mistakes and security
    vulnerabilities due to accidentally exported activities, which is why Android
    versions 12 and beyond require explicit declarations for all activities of an
    app. For analysis of apps developed for earlier versions (prior to Android API
    31), our recommendation is to learn the rules once and encode them in a small
    helper tool that can highlight exported activities. Otherwise, reverse engineers
    may make the same mistakes that app developers made.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，找到导出活动可能会很棘手。在 Android 12 之前，开发者可以省略活动声明中的`android:exported`标签。在这些情况下，活动的默认值是`true`还是`false`取决于其他配置属性。这让应用开发者感到困惑，并导致了错误和安全漏洞，因为活动可能会意外地被导出，这也是为什么
    Android 12 及更高版本要求所有应用活动都必须明确声明的原因。对于为早期版本（Android API 31 之前）开发的应用，我们的建议是学习这些规则，并将其编码到一个小的辅助工具中，以便高亮显示导出活动。否则，逆向工程师可能会犯与应用开发者相同的错误。
- en: 'Our sample declares only one interesting activity: its main activity, shown
    in [Listing 3-2](ch03.xhtml#ch3lis2). The other activities are activities from
    Google SDKs, and for now, we consider them legitimate and not maliciously manipulated.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例只声明了一个有趣的活动：它的主活动，如[列表 3-2](ch03.xhtml#ch3lis2)所示。其他活动是来自 Google SDK 的活动，目前我们认为它们是合法的，并没有被恶意篡改。
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: The declaration of our sample’s main activity*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：我们示例的主活动声明*'
- en: The XML declaration code of main activities is full of boilerplate code. For
    us, the only important part is the name of the activity, `com.bp.statis.bloodsugar.MainActivity`.
    Double-clicking this name in jadx takes you straight to its definition. Unfortunately,
    it consists of more than 600 lines of user interface code without any interesting
    features. As the app doesn’t have any other exported activities, there’s nothing
    more to look for in this section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 主活动的 XML 声明代码充满了模板代码。对我们来说，唯一重要的部分是活动的名称，`com.bp.statis.bloodsugar.MainActivity`。在
    jadx 中双击这个名称会直接带你到它的定义。不幸的是，它由超过 600 行的用户界面代码组成，没有任何有趣的功能。由于该应用没有其他导出活动，因此这一部分没有什么值得进一步查看的内容。
- en: '***Broadcast Receivers***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***广播接收器***'
- en: Another key concept in Android is *broadcast receivers*, part of Android’s messaging
    system. All Android apps can send messages (broadcasts) to each other or themselves,
    and broadcast receivers receive and handle incoming messages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'For reverse engineering, broadcast receivers fall into two distinct categories:
    they can either be declared in the manifest file (so-called *manifest-registered
    receivers*) or registered programmatically when an app is running (*context-registered
    receivers*). The ones declared in the manifest are easy to spot, as they cannot
    be hidden from malware analysts. The ones registered at runtime are not so easy
    to locate, as they can be hidden by encrypted or obfuscated code that makes the
    API calls necessary to set up the receivers.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Android API 26, the system uses only manifest-declared receivers
    to wake up apps. Context-registered receivers can operate only when an app is
    already running. Thus, to find entry points into applications, we should consider
    only manifest-declared receivers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: While our sample’s manifest file declares eight broadcast receivers using the
    `<receiver>` tag, they all point to classes that seem to come from standard Google
    SDKs. Even though broadcast receivers don’t appear to provide any useful entry
    points here, many malware samples do use them. For example, registering to receive
    `BOOT_COMPLETED` messages is a popular way for malware to start running again
    after a system reboot. Later in this chapter, you’ll also see that our sample
    sets up context-registered receivers for which no trace can be found in the manifest
    file. In particular, the malware registers a `RECEIVE_SMS` receiver to intercept
    incoming SMS messages and steal one-time passwords.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '***Services***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Services* are the default way for apps to execute long-running operations
    in the background. Developers must declare all services in an app’s manifest file,
    making them easily discoverable. While services are not entry points into apps
    (all services must be launched by the running app itself), they are great entry
    points into reverse engineering as the service class declarations cannot be hidden
    or obfuscated and their code forms distinct units of functionality that can be
    analyzed in isolation. Many malware samples use these to perform malicious operations,
    so looking for service entry points is a quick way to find such code.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Our sample declares nine services, of which eight once again seem to belong
    to Google SDKs. The one remaining service is `com.bp.statis.bloodsugar.PE`, which
    we previously discussed when analyzing the permissions. This service receives
    and intercepts incoming notifications from all apps on the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Subclasses***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other legitimate entry points into Android apps, though a little obscure, are
    subclasses of the `android.app.Application` class. By default, all Android apps
    have an implementation of this Java class. Apps that need to deviate from default
    app behavior can subclass this default class. If an app uses such a subclass,
    you can find its name in the `<application>` tag in the manifest file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sample does declare a subclass of the default `android.app.Application`
    implementation. Within the `<application>` tag, you should see the following declaration,
    where the fully qualified name specified as the value of the `android:name` attribute
    overrides the default class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on its path name, this `androidx.multidex.MultiDexApplication` class seems
    to come from a default Google SDK. Digging into the official documents, one can
    learn that it was introduced to get around size limits for large apps. In our
    experience, apps today increasingly make use of this attribute, so seeing it is
    fairly common.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: However, our sample has maliciously modified this class. Double-clicking the
    class name in jadx opens the code in [Listing 3-3](ch03.xhtml#ch3lis3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-3: Malicious code is started from an android.app.Application subclass.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code is boilerplate, except for the line `new b(this).o()`. The
    instantiation of an object of class `d.b` and the calling of its method `o` is
    highly unusual. Double-clicking either `d` or `o` in jadx takes you to heavily
    obfuscated code. We will revisit that code later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding Malicious Code**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we hadn’t already found a hook into the malicious code, another option could
    be to look for anti-analysis techniques and attempts to hide code from malware
    analysts. This technique is useful partly because malicious code often tries to
    hide and partly because such analysis broadens our understanding of an app and
    ensures that we don’t miss any of its key functionality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, we recommend looking for the following common strategies:
    dynamic and static anti-analysis techniques, reflection and other dynamic code
    loading techniques, non-Java code usage, and encryption and obfuscation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '***Anti-Analysis Techniques***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Anti-analysis techniques try to throw off static or dynamic analysis and can
    take many forms. Most malware includes at least a few of these measures to make
    it harder for malware analysts to understand the specimen, as well as to determine
    whether it is probably under observation or running on a real user’s device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Discovering and understanding anti-analysis techniques is a science in itself.
    One way to get started is to read the “Defense Evasion” section of the MITRE ATT&CK
    framework for Android, a freely available standard to document malware techniques.
    Over time, we recommend that reverse engineers build tools to pinpoint anti-analysis
    techniques in apps. Doing this work manually is difficult and time-consuming,
    as hundreds of individual anti-analysis techniques exist and are publicly documented.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis can be particularly helpful in detecting dynamic anti-analysis
    techniques. Anti-analysis techniques designed to thwart dynamic analysis commonly
    focus on understanding the environment in which the malware runs. Some try to
    detect analysis tools, such as emulators, debuggers, or sandboxes, and avoid running
    if those tools are detected. Others use environmental properties of the device
    to try to figure out whether they are running in a security analysis system. For
    example, they might wait a certain amount of time before executing malicious functionality.
    They might also focus on geographic properties of the device, for example to find
    out whether it’s located in a certain country or connected to a certain mobile
    carrier. Some malware checks for the device’s language or the user’s time zone.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Smarter malware apps use more sophisticated methods that consider information
    from outside the device. For example, we have seen apps that check whether they
    are still published on Google Play or whether a connection to their servers comes
    from the IP range of a given country. A particularly common technique these days
    is to check whether an app was installed through an ad click that the malware
    author paid for. The app will execute malicious functionality only if the user
    installed the app from this ad; automated security tools that didn’t install the
    app by clicking on the ad won’t be able to trigger its malicious payload. This
    technique can get tricky if parts of the ad campaign’s properties are used as
    decryption keys for later stages of code. If you don’t have information from the
    ad click, you may not be able to decrypt parts of the malicious code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Static anti-analysis techniques focus on denying static analysis tools the ability
    to inspect and understand code. In Android malware, this commonly means hiding
    code, encrypting code, or loading code in later stages to make sure that it is
    not even available for static analysis at all. In addition, Android malware commonly
    uses commercial or freely available *app packers*, which take an app and encrypt
    or compress its original code. Many off-the-shelf app packers exist for Android,
    usually marketed as tools to protect intellectual property. Their use to protect
    Android apps is particularly widespread in China, and many available app packers
    originate from there.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: These tools often apply sophisticated static anti-analysis techniques. To make
    the original code harder to understand, they might implement control flow obfuscation
    (garbling the original flow of code through an app) or data flow obfuscation (making
    it harder to follow how variables interact with each other). The most sophisticated
    app packers even take original app code and recompile it into their own custom
    code. Understanding such transformed code requires knowledge of the bytecode defined
    by the packer and the abstract machine that interprets it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '***Reflection***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reflection is another common anti-analysis technique. Many modern Android malware
    samples split malicious functionality across multiple dynamically loaded stages
    that operate like plug-ins. Usually, the first stage, directly embedded in the
    app, is small and benign. It often does nothing but observe its runtime environment.
    If it doesn’t detect any analysis tools, it loads the second stage, which contains
    more malicious functionality.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The Java reflection APIs, defined in the Java package *java.lang.reflect*, are
    used to dynamically look up, instantiate, and invoke classes and methods. They
    allow apps to dynamically load code that may not be present at compile time, such
    as plug-ins. Benign apps often use these APIs, too. For instance, they might load
    benign plug-ins, select between different APIs depending on the current operating
    system version, or access private APIs that are supposed to be hidden from apps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, looking for reflection APIs is effective in malware analysis because
    the use of reflection cannot be hidden. Moreover, distinguishing between benign
    and malicious uses of reflection is often easy. In nearly all cases, benign reflection
    supplies constant arguments to the reflection APIs. For example, apps might look
    up private Android APIs by name. Malicious reflection typically uses non-constant
    arguments that are stitched together at runtime, or encrypted or obfuscated strings
    that it decodes right before passing them to the reflection APIs. That makes it
    very easy for human reviewers to quickly sort through uses of reflection and find
    the ones that are most likely malicious.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In decompiled jadx code, all classes that use reflection begin with an import
    statement for the reflection API, so using the search dialog to look for `import
    java.lang.reflect` should return all of these classes. In the case of our sample
    app, the search dialog returns 293 results, showing just how common reflection
    is. Assuming once again that standard SDK classes haven’t been maliciously modified,
    we can discard all results in Java packages *androidx.**, *kotlin.**, and *com.google.**.
    That leaves a few hits in packages starting with *b.**, *d.**, and *e.**. We already
    identified the package *d.** as a likely candidate for malicious code, so let’s
    look at the other two packages first.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The randomly selected class `b.j.k` shows an example of reflection code that
    is probably benign. As shown in [Listing 3-4](ch03.xhtml#ch3lis4), the reflection
    code tries to load some class whose name contains the string `_LifecycleAdapter`.
    This code does not seem obfuscated or dynamic enough for malicious reflection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-4: A benign use of reflection in the app*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'More importantly, the class has two significant strings: `_LifecycleAdapter`
    and `The observer class has some methods that use newer...`, the latter of which
    we have omitted from the listing for brevity. A quick web search shows that these
    strings are taken from a standard Android class called `androidx.lifecycle.ClassesInfoCache`,
    meaning this code is likely benign.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Most code obfuscators leave the package hierarchy intact when transforming original
    code into obfuscated code. Thus, sibling packages in obfuscated code are likely
    sibling packages in the original code. If the class `b.j.k` is `androidx.lifecycle.ClassesInfoCache`,
    it is highly likely that all classes in the package *b.j* belong to `androidx.lifecycle`
    and that all classes in *b.** belong to `androidx.*`. We’ll make this assumption
    for now, declaring all uses of reflection in *b.** safe and moving on. Similar
    analysis of the reflection code found in the *e.** package shows that this is
    likely a standard library, too.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the Java reflection APIs in the *java.lang.reflect* package,
    Android provides some other code loading APIs often used by benign and malicious
    apps alike. The two most common of these are `dalvik.system.DexClassLoader` and
    `dalvik.system.DexFile` (deprecated in Android API 26). These APIs can load entire
    Android code files and are frequently used to load plug-ins. Java and Android
    have other related APIs, commonly referred to as *ClassLoader APIs*. We recommend
    developing an understanding of these, or even better, an automated tool to surface
    them in apps. In particular, APIs for loading code from byte arrays in memory
    rather than files on disk are becoming more popular in Android malware. Using
    this technique, they can avoid leaving behind artifacts that security researchers
    could discover.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Try searching our sample app for `dalvik.system.Dex`. It should return just
    a single use outside of the standard SDKs, once again in the probably malicious
    *d.** package.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '***Non-Java Code***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern Android applications can be written in many programming languages and
    frameworks other than Java. Examples include Flutter, Kotlin, Xamarin.Android,
    and ReactNative. Malware developers intentionally use these newer technologies
    to make malware analysis harder.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Some malware developers have started building their malware entirely in these
    languages. This simple choice already makes analysis more difficult, as most Android
    reverse engineers likely have good tooling for Java apps but not for those written
    in other languages. Other malware developers have continued to use Java as their
    main programming language while strategically developing malicious portions of
    the app in alternative languages. To detect this malicious activity, automated
    analysis tools need the ability to understand control and data flow between parts
    of code written in different languages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The two most common programming languages we see strategically used by malware
    are JavaScript and native ARM code. JavaScript is most likely used less as a pure
    anti-analysis technique and more as a way to interact with websites. Native ARM
    code, which is developed in C, C++, or other languages that compile to ARM code,
    is regularly used to hide malicious functionality. For example, it’s common for
    malware to ship native code binary files that contain just a single decryption
    routine called from Java code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We recommend looking for alternative languages during Android malware analysis,
    with a particular focus on JavaScript and native ARM code. Malware apps can hide
    the use of these alternative languages, but they often leave telltale signs. For
    example, you’ll often find native code in the APK file’s *lib* folder. Java code
    keywords for interacting with native code such as `native` or the API `System.loadLibrary`
    also provide strong indicators that the app uses native ARM code. Look for JavaScript
    in WebView objects, in particular those declaring a JavaScript interface through
    the API `addJavascriptInterface`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Our sample does not have any obvious indicators suggesting the use of native
    ARM code or JavaScript. There are no native code asset files, uses of any of the
    APIs mentioned above, or keywords that would hint at their presence. Later, you’ll
    learn that the app does make use of JavaScript, but that use is hidden and not
    easily discovered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '***Encryption and Encoding***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware developers love to encrypt and encode strings. In fact, the use of cryptography
    APIs can provide a hint about the location of malicious functionality. Malware
    developers often use the default Java implementations of encryption algorithms
    like AES or RSA from the *javax.crypto* package. Use of *java.util.Base64* or
    *android.util.Base64* is also common. Looking for references to these packages
    can help you quickly locate interesting methods, such as those that decrypt communication
    received from command-and-control servers. However, other than in benign Google
    SDKs, our sample does not make obvious use of any APIs in *javax.crypto*. It more
    often uses *java.util.Base64*, including in the obfuscated package *b.**, which
    we previously declared harmless.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When reverse engineers get stuck, they might start looking at strings and method
    names used in apps, hoping to spot interesting leads. This technique takes only
    a couple of minutes and can lead to new discoveries. For example, malware developers
    may have forgotten to remove sensitive log strings, or the search might reveal
    an API call to read the user’s SMS messages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: However, without careful planning, searching for strings and method names can
    be a waste of time, as it depends more on luck than on expertise. To structure
    your search, you could, for example, develop a regular expression to return all
    the interesting strings and method names that you can think of. This might include
    the names of SMS or contact list APIs, as well as strings that match URLs or interesting
    content providers. The regular expression doesn’t have to be perfect to be useful;
    you can refine it over time as you discover additional interesting APIs and string
    patterns. In our sample, for instance, searching for suspicious strings and API
    names returns a URL in the malicious *d.** package we identified earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**The Malware’s First Stage**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve come across the suspicious package *d.** several times in this chapter
    so far. It’s finally time to analyze it. The package is conveniently simple, with
    just two classes, `d.a` and `d.b`. Interestingly, the app doesn’t seem to use
    `d.a` at all, while `d.b` is executed straight from the application entry point
    in the `android.app.Application` subclass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: It is unclear why `d.a` is present in the app. The developer might have used
    the class for testing and forgotten to remove it before releasing the malware.
    Its code doesn’t seem to be referenced or called from anywhere, its functionality
    is limited and not obfuscated, and it contains the URL of a command-and-control
    server in plaintext. Connecting to the URL from this file downloads another code
    file with more malicious content.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `d.b` class is the first part of the app’s malicious functionality. We already
    know that its constructor and the method `o` run as soon as the application starts.
    Looking around the class also shows intensive code obfuscation and encryption,
    for example in [Listing 3-5](ch03.xhtml#ch3lis5), which shows the class’s sole
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-5: The constructor for the malware class d.b*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The constructor code contains several obfuscation techniques found elsewhere
    in the class. For example, many attributes are assigned seemingly arbitrary string
    and integer values. These appear obfuscated or encrypted. The code also has complex-looking
    arithmetic expressions and opaque predicates. *Opaque predicates* are expressions
    that evaluate to true or false and look complicated to calculate, yet always resolve
    to the same value. Malware uses them to confuse human and automated analysis,
    for instance by making it harder to follow how `if` statements branch or how often
    loop statements repeat.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `d.b` class uses two kinds of opaque predicate conditions, one of which
    is shown in the `if` statement of [Listing 3-5](ch03.xhtml#ch3lis5), which compares
    the Android SDK version to 93\. This check is nonsensical; as of this writing,
    we’re more than 60 versions (and many decades) away from reaching API level 93\.
    For the time being, this expression will always return false, and the instructions
    inside the `if` block will never execute.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The second opaque predicate condition in this class uses Java’s `java.util.Calendar`
    API, as shown in [Listing 3-6](ch03.xhtml#ch3lis6).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-6: The malware class d.b uses the Calendar API to build opaque predicates.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This code asks the default system calendar for the number of the current week
    in the current month. Return values of this API must be between 0 and 6, so the
    expression can never be true, and the instructions in this `if` block never execute,
    either.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding the Malicious Class***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve now identified the techniques used in `d.b` to make analysis harder, but
    we still have to defeat them to understand what the malware is doing. Luckily,
    the malware authors made some crucial mistakes that we can exploit. Without these
    mistakes, we may have had to trawl through nearly 1,000 lines of painful-to-read
    code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The developers’ first mistake was to reuse the same few techniques. For the
    opaque predicates, it’s easy to eyeball whether the check is for a legitimate
    API version or a realistic calendar date. The arithmetic expressions and assignments
    of seemingly random values to attributes all look similar, too. As a human reviewer,
    you can make use of your brain’s pattern-recognition powers and rapidly scan the
    code to find instructions that are visually different. In the next section, when
    we rebuild the class’s string decryption algorithm, you will see that these different
    instructions are really the only ones that matter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The developers’ second mistake was to leave strings in the class intact. Although
    they obfuscated these strings to the point of illegibility, they still left them
    at the exact places where they are passed to standard APIs, as shown in [Listing
    3-7](ch03.xhtml#ch3lis7).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-7: The malware class d.b encrypts strings but leaves them in place.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: As the reflection API requires an unobfuscated, plaintext string to work, it’s
    clear that the `p` method returns that string. Moreover, it’s highly likely that
    the argument to `p` is the obfuscated and encrypted string, and that `p` decrypts
    it to the method name string expected by the `getMethod` API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '***Reverse Engineering the String Decryption Method***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `p` method looks daunting at first, with nearly 50 lines of obfuscated code.
    However, the developers made additional mistakes here, so reverse engineering
    `p` is easy. For brevity, we omit the full method code and instead build up the
    relevant parts of it in this section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the most important aspect of this method is its return value, which
    must be the decrypted string fed into the reflection API. Stripping all instructions
    but the return value instruction leaves us with the code shown in [Listing 3-8](ch03.xhtml#ch3lis8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-8: The p method stripped down to its return value*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re really only after the content of `sb`, we now need to bring in
    all the lines that contribute to the value of `sb`. In jadx, we can select the
    variable `sb` to highlight all other uses of it. Adding these lines produces the
    code in [Listing 3-9](ch03.xhtml#ch3lis9).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-9: The p method with the references to sb included*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: As this code expansion pulled in another variable, `length`, we also need to
    add all the lines of code that manipulate this variable. We do this in [Listing
    3-10](ch03.xhtml#ch3lis10).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-10: The complete decryption method*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This last step did not pull in any more variables, so we’re done. Of the 50
    original lines in `p`, only these lines contribute to string decryption. The malware
    authors added the rest of the code to mislead us. Compiling and running this code
    in Java confirms that it decrypts the string `qmqMRa3e34OrqtqLdSAnAjne4p4ssoXYOMh`
    to `openStream`, the name of the method that is looked up through reflection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The crucial mistake that allowed us to speedily recover the decryption code
    is that the developers mixed original instructions with obfuscating instructions
    but kept the data flow of the original code completely separate from the data
    flow of the obfuscated code. Thus, the code initially appears difficult to read
    and hard to follow, but when we look only at variables and how they influence
    each other, we can easily extract the original code without having to consider
    the obfuscation at all.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The small size of the decryption method allowed us to trace the data flow manually.
    To avoid similar manual work in the future, we could write code that performs
    these steps automatically using techniques from compiler theory, like use-definition
    chains.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '***Decrypting All Strings in the Class***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve understood the decryption method and rebuilt it in Java, we can
    easily decode all the strings in the `d.b` class. Unless malware developers go
    the extra mile to hide this connection, there tends to be a strong correlation
    between the length of an obfuscated or encrypted string and its importance. The
    string starting with `PnPt` seems to be the longest, and sure enough, once decoded,
    it translates to a URL.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The decoded URL is the same one we found earlier in the `d.a` class. By connecting
    to it, we were able to download a file called *ban*, which contains the code of
    the next stage. The rest of the code in `d.b` downloads this code file and loads
    it through the reflection API. We leave following this process as an exercise
    for the reader.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**The Malware’s Second Stage**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *ban* file is much smaller and less obfuscated than the `d.b` class. You’ll
    commonly find this to be the case in later malware stages, which generally contain
    less functionality. Malware developers might also think that their first stage
    has enough protection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The *ban* file contains two packages, *yin.** and *com.**. The *yin.** package
    contains only three small classes. One of these, `yin.Chao`, is loaded by the
    first stage in `d.b`, as shown in [Listing 3-11](ch03.xhtml#ch3lis11).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-11: The malware obfuscates its invoking of yin.Chao through encrypted
    strings.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The three obfuscated strings decrypt to `dalvik.system.DexClassLoader`, `loadClass`,
    and `yin.Chao`, in that order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '***Entry Points***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the code is small enough to simply read, let’s use our structured approach
    to find interesting entry points to our analysis. This approach makes sure that
    we don’t miss interesting functionality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: As *ban* is a dynamically loaded plug-in file, our analysis of it will differ
    from our first-stage analysis in some major ways. Most importantly, plug-in files
    do not have a manifest file, making it much harder to find permissions or entry
    points. In fact, plug-ins have no predefined entry point. The code that loads
    the plug-in can declare the class and method in which the plug-in should begin
    to run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Plug-in files like *ban* can use only the permissions declared in the manifest
    file of the app that loads them. Knowing this, we can simply revisit the permissions
    we discovered earlier. A text search for *permission* in jadx returns two distinct
    parts of *ban*. In the `com.gppp.hk.b.b` class, a string array mentions the `READ_PHONE_STATE`
    and `READ_CONTACTS` permissions. In the `com.gppp.hk.a.a` class, code requests
    these permissions. Later in this chapter, you’ll see that the malware uses the
    `READ_PHONE_STATE` permission to access the device’s phone number. The use of
    `READ_CONTACTS` remains unclear.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Of course, *ban* might make use of other permissions declared in the main app’s
    manifest file. As an exercise, try using one of the previously discussed permission
    maps to find permission-protected API calls.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The Main Entry Point
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We mentioned that the code loading the plug-in gets to decide where in the plug-in
    execution begins. To find this entry point, we need to revisit the `d.b` class
    of the first stage, where the encrypted string `fofRiawhwZyCx.xF-nViVkrysJ4iJ`
    decrypts to `yin.Chao`. Its first method is also called `yin`, once decrypted.
    If we don’t find any better leads, starting with `yin.Chao` is a good idea, as
    it will allow us to understand the malware’s second stage from its first executed
    line of code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Activities, Services, and Broadcast Receivers
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to the main entry point into *ban*, we can also look for activities,
    services, and broadcast receivers. Using jadx’s search function shows one activity
    and one service, but no broadcast receivers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: While the activity `com.gufra.base_normal.MainActivity` seems unused, the service
    in `com.gppp.hk.b.a` is important. This is the base class of the notification
    listener `com.bp.statis.bloodsugar.PE`, which intercepts app notifications on
    behalf of the malware. Later in this section, we’ll explain this service in more
    detail.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are other service subclasses of `com.gppp.hk.b.a`, but the app
    cannot run them because they are not declared in the manifest file. We’ll ignore
    these services going forward, as they appear to be dead code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Analysis Tricks and Hidden Code
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While this second stage includes no native code or uses of the encryption package
    *javax.crypto*, we can find some interesting uses of the reflection API. Searching
    for *reflect* in jadx shows five instances of it, of which `com.gppp.hk.a.b.a`
    is the most relevant, as it contains another URL string. Further described later
    in this chapter, this class is responsible for downloading and running the third
    stage of the malware.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Strings and API Names
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Besides functionality related to permissions, reflection, and the previously
    mentioned URL from which to download the third stage, there is little more to
    discover from a search for strings and method names.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: For example, a search for *sms* returns a single line, where the malware checks
    whether it is the default SMS handler configured on the system, but that’s it.
    The second stage is just too small for any other discoveries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***The yin.Chao.yin Method***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a look at the code for `yin.Chao.yin`, the method from which the
    main app executes the plug-in. As shown in [Listing 3-12](ch03.xhtml#ch3lis12),
    it starts a new thread from which to call a few other methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-12: The yin.Chao.yin method is the entry point into the malware’s
    second stage.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: A cursory glance at these other methods shows that the last two, `Chao.Nti`
    and `b.a`, may be interesting. Code in `Chao.Nti`, shown in [Listing 3-13](ch03.xhtml#ch3lis13),
    checks whether the user has already granted the app permission to process notifications
    sent by all other apps. If not, the app shows the dialog for granting that permission.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-13: Chao.Nti tries to get access to all app notifications.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we previously saw a service for processing app notifications declared
    in the manifest file, but that we couldn’t find the code for it. This method seems
    to be it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The `b.a` method, whose fully qualified name is `com.gppp.hk.a.b.a`, is even
    more interesting. As you can see in [Listing 3-14](ch03.xhtml#ch3lis14), it opens
    a connection to *https://xn3o.oss-accelerate.aliyuncs.com/xn3o*, downloads yet
    another code stage from there, and executes the downloaded code with the `DexClassLoader`
    API.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-14: The method com.gppp.hk.a.b.a downloads the third malware stage.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The two other methods called by `yin.Chao.yin` seem less interesting. The `Hook.hook2`
    method contains code for merging the app’s default class loader with a new class
    loader. Its code seems to have been copied from Chinese-origin Android plug-in
    tutorials, reminding us to always search for any kind of boilerplate code we encounter
    during analysis. The call to `registerActivityLifecycleCallbacks` registers a
    callback that prompts the user to grant certain permissions at various stages
    of the app’s lifecycle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '***The com.* Package***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before moving on to the third stage, let’s have a quick look at *ban*’s second
    package, *com.**. It contains a whole lot of subpackages with different names
    yet similar code. For example, in the *com.bp.statis.bloodsugar* package, we find
    one class, `PE`. This is the notification listener service declared in the manifest
    file. Its code is tiny, as it merely forwards the incoming notification to its
    parent class, `com.gppp.hk.b.a`. Most other subpackages of the *com.** package
    have a similar structure. We can assume that the names of the subpackages belong
    to other malware samples of the same family.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The code in the parent class `com.gppp.hk.b.a` is likewise small. Shown in [Listing
    3-15](ch03.xhtml#ch3lis15), it takes incoming notifications, forwards them to
    other parts of the app with a broadcast message, and then hides the original notification
    from the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-15: The com.gppp.hk.b.a class intercepts notifications from all
    other apps on the device.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This code uses context-registered messages and broadcast receivers that aren’t
    declared in the manifest file. Somewhere else, probably in the same app, we should
    find a broadcast receiver that listens for broadcasts of type `action_text`. Locating
    this broadcast receiver can often be tricky, but in this particular malware sample,
    it’s not. If you search for *action_text* in the code of the malware’s third stage,
    you’ll find it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the whole purpose of the second stage is to make sure that the
    app has access to notifications from all apps on the system. It intercepts them
    and sends their contents to the third stage, which the second stage also downloads
    and executes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**The Malware’s Third Stage**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third, and main, stage of this malware sample contains the majority of its
    malicious functionality. It has more classes, and a lot more code, than the previous
    two stages. Loading the third stage in jadx shows code in packages *com* and *vgy7.vgy7.vgy7.vgy7.**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: These two packages are very different. The *com* package contains just one class,
    `com.xn3o`. The *vgy7.vgy7.vgy7.vgy7.** package contains 10 classes distributed
    across multiple subpackages. The malware authors spent some effort obfuscating
    variable names and strings, but it’s still possible to eyeball what’s going on.
    For example, the class `vgy7.vgy7.vgy7.vgy7.vgy7` contains a bunch of poorly obfuscated
    strings that hint at network, telephony, and JavaScript functionality.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This third stage is unfortunately way too large to fully explain in this chapter.
    It contains significant chunks of custom code for manipulating certain premium
    service sign-up pages and thwarting their anti-bot protections. All the code in
    this stage contributes to this malicious functionality, so it’s hard to completely
    ignore certain packages. Instead, we describe only the beginning of the third
    stage’s analysis.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***jadx Decompilation Issues***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decompiling the code in *com.xn3o.xn3o* is beyond jadx’s capabilities, which
    happens occasionally when you try to load larger and more complex pieces of code.
    As a first workaround, try the jadx option called *Show Inconsistent Code*, which
    shows the parts of the code that could not be properly disassembled. The inconsistent
    code is mostly correct, but not perfectly so. When it comes to methods that are
    important to understand correctly, say a decryption method, it’s best to get a
    second opinion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You can get this second opinion by using other Android decompilers. For example,
    the Bytecode Viewer tool includes six different Android decompilers. Usually at
    least one of them can produce some reasonable decompiled code for any Android
    app.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '***Entry Points***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With just 11 classes, it’s possible to manually scan the entire code for interesting
    functionality. But to sharpen our reverse engineering processes, let’s return
    to the techniques we’ve introduced previously to find entry points: looking at
    permissions; the main entry point; activities, services, and broadcast receivers;
    anti-analysis tricks and hidden code; and string and API names.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like the second stage, the third stage is a dynamically loaded plug-in, which
    means that the permissions available to it must be declared in the main app’s
    manifest file. Searching for permissions in jadx shows references to the `SEND_SMS`
    and `RECEIVE_SMS` permissions. Because these two permissions were not declared
    in the first stage’s manifest file, *xn3o* won’t be able to use them. It is likely
    that *xn3o* is loaded by many different malware apps, some of which have access
    to one or both of the SMS permissions. Alternatively, the app may nudge the user
    to install newer versions of itself that declare these permissions, but in this
    particular malware we have not seen such functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Even though this app can’t use the SMS permissions, we can still find it worthwhile
    to understand how they are used when loaded into other apps. The first line of
    [Listing 3-16](ch03.xhtml#ch3lis16) calls the method `bhu8`, which indirectly
    calls the `PackageManager.checkPermission` method to check for the availability
    of the `RECEIVE_SMS` permission. The second line checks for the `SEND_SMS` permission.
    The results are stored in two variables and later sent to the malware’s command-and-control
    server.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-16: The malware’s third stage checks for RECEIVE_SMS and SEND_SMS
    permissions.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that *xn3o* uses SMS permissions when they’re available, we
    can search jadx for *sms* to surface several entry points into the malicious functionality.
    The class `vgy7.vgy7.vgy7.vgy7.bhu8` contains references to the API `sendTextMessage`,
    while `vgy7.vgy7.vgy7.vgy7.cft6.bhu8` contains code for receiving and handling
    incoming text messages. Besides SMS permissions, *xn3o* does not seem to check
    for any other permissions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The Main Entry Point
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main entry point into *xn3o* is defined by the second stage, *ban*. [Listing
    3-17](ch03.xhtml#ch3lis17) shows that the third stage’s execution starts in the
    `com.xn3o` class’s `xn3o` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-17: Code in* ban *executes the* com.xn3o.xn3o *method in the third
    stage.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t find any better leads, we could start trying to understand the functionality
    of the third stage from there. For now, let’s consider other potential entry points.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Activities, Services, and Broadcast Receivers
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can also look for activities, services, and broadcast receivers. Using jadx’s
    search function shows just two broadcast receivers and not much else. The first
    broadcast receiver handles messages sent by the second stage with `android.text`.
    Recall that this broadcast contains intercepted app notifications. A look into
    the method `bhu8.vgy7`, called from the last line of [Listing 3-18](ch03.xhtml#ch3lis18),
    shows that the app stores the intercepted notifications in a list for later processing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-18: The first broadcast receiver processes previously intercepted
    app notifications.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The second broadcast receiver ([Listing 3-19](ch03.xhtml#ch3lis19)) handles
    incoming text messages. It calls the same `bhu8.vgy7` method to store and process
    the intercepted messages that it previously used to handle intercepted notifications.
    The one difference is that it also pings its command-and-control server if the
    text message starts with *rch*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-19: The second broadcast receiver intercepts incoming SMS messages
    for processing.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Why the malware looks for *rch* is unclear. One possibility is that the malware
    authors send these messages to communicate with the malware as an alternative
    to using the HTTP-based command-and-control server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Analysis Tricks and Hidden Code
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Looking for typical anti-analysis tricks also works in the third stage. While
    there is no native code or uses of the encryption package *javax.crypto*, we can
    find some interesting uses of *android.util.Base64*. In [Listing 3-20](ch03.xhtml#ch3lis20),
    you can see a method that encodes a byte array using Base64 and then passes the
    encoded byte array to another function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-20: The malware uses Base64 encoding and custom encryption to communicate
    with the server.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll soon see, this other function, `vgy7`, is responsible for encrypting
    and decrypting the malware’s communications with its command-and-control server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Strings and API Names
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Besides functionality related to permissions, SMS, and encoding, we can surface
    some other interesting parts of the code by searching for strings and method names.
    A search for *HTTP* shows embedded URLs, as well as code from the *java.net* package
    used to connect to these URLs. Later in this chapter, you’ll learn that many of
    these URLs are for communicating with the malware’s command-and-control server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '***Name Mangling***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve found many ways to proceed with the analysis, we have to make
    the obfuscated code more readable. One of the most important tools in a reverse
    engineer’s toolbox is the ability to rename variables, methods, classes, and other
    names in a program. Malware developers like to throw name mangling techniques
    at malware analysts, so you’ll often have to reverse those techniques to resurface
    the original code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Renaming mangled names doesn’t just make code easier to understand. The practice
    also helps you keep track of code you’ve already analyzed. When you see an unmangled
    name, you don’t have to worry about whether you’ve seen it before; you’ll be able
    to recognize the human-readable name more easily, even if it’s something like
    *unknown_string* or *not_sure*. Rename mangled names liberally, even if you don’t
    quite understand yet what a name is for.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: While unmangling names, we also recommend that you introduce some structure
    to them. Although the style is shunned in software development nowadays, we’ve
    found *Hungarian notation*, a naming convention in which a variable’s type information
    is included in its name, to be extremely useful for this purpose. For example,
    you might name an integer `iLen`, a string `strName`, and so on. You can even
    use this naming scheme for unmangling method names, for example by using `getStrName`
    for a simple getter function that returns a string we call `name`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Finally, name unmangling can reduce visual load. Try renaming long names to
    short names, and names with numbers or Unicode characters to simple names consisting
    of ASCII characters only. For each name mangling technique you encounter, consider
    why it was introduced and then use your tool’s renaming function to counter the
    effect. Developers of name mangling techniques think it’s smart to use only random
    Unicode characters, shorten all names to single characters, or even change the
    text direction so names are read from top to bottom instead of left to right.
    However, for reverse engineers, all of these techniques make it extremely easy
    to spot the difference between mangled names and names that have already been
    unmangled. It’s much more confusing for reverse engineers if all names are random
    English-language nouns, or, as we’ve seen in real malware, if the names come from
    the code’s original source but have been randomly swapped so that the malware
    uses, for example, `int socket` and `Socket i` instead of `int i` and `Socket
    socket`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these name unmangling concepts, let’s take a stab at unmangling a
    sample of the third-stage code. [Listing 3-21](ch03.xhtml#ch3lis21) shows the
    original code, with the mangled names intact.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-21: The original mangled code, as produced by jadx*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Let’s clean this up by removing lengthy package names to reduce visual overload,
    supplying meaningful names, using Hungarian notation to provide easily accessible
    type information, and marking code that doesn’t do anything as *noOp* (no operation).
    The unmangled version, shown in [Listing 3-22](ch03.xhtml#ch3lis22), is much easier
    to understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-22: Code cleaned up with jadx’s renaming function*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: We still don’t know what the preferences in `bshwai` and `tffhhk` are, or what
    the URL `urlUtansy` is used for, but at least we can read the transformed code
    relatively fluently. Note also that we’ve given two different variables the same
    name, `context`. That would be a big no-no in programming, as compilers don’t
    allow two variables in the same scope to have the same name. In reverse engineering,
    however, this is perfectly fine, and perhaps even encouraged. For example, renaming
    every uninteresting name to an underscore (`_`) can significantly reduce cognitive
    load.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-and-Control Server Communication**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will showcase pieces of *xn3o* to explain how the fraudulent
    app works. Execution of this third stage is dynamic, with a command-and-control
    server telling the malware what to do and in what order. To follow along, you
    must understand how the malware communicates with the server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that we’re no longer in the realm of pure static analysis. At
    this point, sticking with a static approach alone is too limiting. To understand
    how malware communicates with its command-and-control servers, it’s usually easier
    to just run the malware and intercept the traffic. However, to keep this chapter
    focused on static analysis, we’ll punt our explanation of dynamic analysis tools
    to the next chapter and concentrate instead on the information we can glean from
    the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll see, this app performs direct carrier billing fraud, or toll fraud,
    by signing users up for premium services without their knowledge or against their
    will. Some toll fraud functions as a pure social engineering scam, showing the
    users phishing-like sign-up pages and hoping that they will complete the registration
    process themselves. The toll fraud shown here, however, uses a second common technique:
    simulating user actions with Android and JavaScript APIs and signing up for premium
    services without the user noticing. Despite all of this automation, the malware
    performs just a few key steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Load a referral website that forwards to the premium service.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use code to automatically engage with the premium service page and subscribe
    the user without their consent.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercept and extract the one-time password sent over SMS.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paste the one-time password into the premium service page to complete registration.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most toll fraud apps use roughly the same framework. Armed with this knowledge,
    we can now revisit the malware’s third stage and look into how it achieves all
    of these steps.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '***Examining the Encryption Algorithm***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All communication with the command-and-control server is encrypted using a simple
    algorithm found in the `vgy7.vgy7.vgy7.vgy7.bhu8` class. Recall that we discovered
    this `vgy7` method in [Listing 3-20](ch03.xhtml#ch3lis20). Shown in [Listing 3-23](ch03.xhtml#ch3lis23),
    it takes two arguments. The second argument controls whether the string passed
    as the first argument is encrypted (`z = true`) or decrypted (`z = false`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-23: The vgy7 method can encrypt and decrypt communications with
    the command-and-control server.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The encryption algorithm is clearly homegrown and very weak. To encrypt a string,
    it first picks a random lowercase letter and a random uppercase letter. It subtracts
    the ASCII code of the second letter from that of the first and adds five. The
    encrypted output string starts with the two random letters, followed by the letters
    of the input string to encrypt. At string locations where the result of the subtraction
    plus five equals zero, the algorithm inserts a random character that doesn’t have
    any meaning. For example, the third character of the encrypted string (in other
    words, the zeroth character of the transformed input string) is always a random
    character, as zero modulo any value is always zero.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '***Probing the Server from the Command Line***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we know how encryption and decryption works, we can write a small
    script to interact with the malware’s command-and-control server and probe its
    commands and responses. As the encryption and decryption routine is self-contained
    in just one method, we’ve pasted the code from jadx into two files, *Encrypt.java*
    and *Decrypt.java*, that can be run from the command line. Here, we use the Linux
    command line to interact with the malware’s server:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command encodes a JSON argument with values collected by the app (and
    explained later in this section), echoes the command to our *Encrypt* script while
    stripping the newline with the `-n` flag, pipes the encrypted payload to cURL
    in silent (`-s`) and POST (`-d`) modes, and decrypts the command received from
    the server. The output will look something like this: `"bshwai": 5320786, "xjnguw":
    ""`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '*As command-and-control servers are usually short-lived, we don’t expect this
    command-and-control server to be around for experimentation when you’re reading
    this book. Unfortunately, this will limit your ability to follow along with dynamic
    analysis.*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '***Registering with the Server***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we can send encrypted payloads to the server and decrypt its responses,
    we can begin to understand how the malware communicates with it. Here, we’ll show
    the information being sent between the malware and its command-and-control server
    by simulating the malware running on a real device connected to the mobile network
    of Belgian carrier Orange. As the malware uses the value of the `worikt` field
    in command-and-control communication to identify the phone’s mobile carrier, changing
    this value to identifiers of other mobile carriers allows us to easily experiment
    with different mobile carriers in different countries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The first connection the malware makes to its command-and-control server is
    to register with the server. It sends registration information to *https://www.utansy.com/xn3o/in*
    using encrypted JSON. The server responds with an encrypted JSON object that the
    malware decrypts and processes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In all instances of encrypted JSON communication, the malware developers replaced
    the meaningful names of the JSON fields with gibberish names to throw off analysis.
    You can see what this looks like in [Listing 3-24](ch03.xhtml#ch3lis24), which
    shows the decrypted JSON object sent to the command-and-control server in the
    registration phase.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 3-24: The decrypted payload of the registration message*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To understand these gibberish names, it helps to approach the problem from two
    sides. When you see gibberish JSON fields referred to in the code, document the
    values they are assigned. Then do the same thing when you see gibberish JSON fields
    in decrypted communication. We can guess the meaning of some fields, like `josiwo`,
    from their assigned values. The meaning of others, like `kdthit`, must be found
    through code inspection.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the malware doesn’t try to hide the gibberish strings in the code or
    reuse the same gibberish names in different contexts. For example, searching jadx
    for `josiwo` returns only one location, shown in [Listing 3-25](ch03.xhtml#ch3lis25).
    This code contains the exact same field names as the decrypted JSON object in
    [Listing 3-24](ch03.xhtml#ch3lis24). We can safely assume that the code is responsible
    for assigning the values of these gibberish fields.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 3-25: Building up the JSON payload of the registration message*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: With this extra context, we can see that `josiwo` is clearly the malware app’s
    own package name and `qredyb` is the device’s SDK build level. The string `kdthit`
    is always the number 6, but its meaning is unclear. Maybe it’s a version code
    to help the client and server negotiate a communication protocol.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The meaning of `worikt` and `zubfih` are not immediately obvious, but following
    the code to the assignment of the two variables makes it possible to understand
    them: `worikt` is the device’s SIM operator code, as returned by `TelephonyManager.getSimOperator`
    (the 20610 code is for the provider Orange Belgium). The value of `zubfih` is
    more complex. Depending on the device’s API level, the value is either set to
    the Unix timestamp of the app’s install time or the device’s Android ID.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '***Processing the Registration Response***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After a successful registration request, the command-and-control server responds
    with a string that decrypts to the JSON object shown in [Listing 3-26](ch03.xhtml#ch3lis26).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-26: Response from the command-and-control server for a new client
    registration*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The exact meaning of the return value of `bshwai` is unclear, but it could be
    an ID assigned to the client. Using cURL to probe the command-and-control server
    returns the same value for `bshwai` until a new timestamp value is sent in the
    `zubfih` request field. It’s likely that the server uses the installation timestamp
    to distinguish between infected clients and assigns new client IDs on that basis.
    As the client IDs seem to increment linearly, it’s also possible to use this value
    to estimate the number of infected devices and how fast new devices are infected.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The second return value, `xjnguw`, is also very interesting. In our tests, it
    was nearly always empty. It seems to depend on the app’s package name, because
    the server returned a non-empty value when we switched the package name parameter
    in `josiwo` to, for example, *com.takela.message*, the package name of another
    malware sample in the same family. Returned non-empty values look like *1_1487372418053478*,
    where the 1 (or sometimes 2) before the underscore is a version identifier for
    a fourth stage to download and the part after the underscore is a Facebook app
    ID used to initialize the Facebook SDK bundled in this fourth stage. The fourth
    stage is downloaded from *https://xn3o.oss-accelerate.aliyuncs.com/fbhx1* or *https://xn3o.oss-accelerate.aliyuncs.com/fbhx2*,
    depending on the version code. At the end of this chapter, we’ll take a look at
    these plug-ins.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloading Commands***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After registering with the command-and-control server, the malware connects
    to *https://www.utansy.com/xn3o/ti* to retrieve commands to execute. These commands
    are used to connect to an affiliate website that forwards to a payment sign-up
    page. Once the page is loaded, the downloaded commands start to interact with
    it and sign the user up without their consent. Users will be billed on their next
    phone bill, and the affiliate that led to the sign-up is paid a reward.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The request payload sent to the command URL contains information collected by
    the malware about the state of the device. [Listing 3-27](ch03.xhtml#ch3lis27)
    shows an example request.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 3-27: Payload sent to the command-and-control server to request commands*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The `eymbmw` field indicates whether the device is on a mobile network or not
    (devices need a mobile connection to sign up for many carrier billing sites).
    The `rktfht` field indicates whether the app has permission to receive incoming
    SMS messages or access app notifications, which the app needs in order to retrieve
    the one-time password for the billing sign-up process. The `segdip` field indicates
    whether the app has permission to send SMS messages, which is necessary to confirm
    the billing sign-up on some pages. The `elbcnf` field contains the device’s phone
    number, and `dgebpf` contains a list of all accounts registered with the device.
    Depending on the device, registered accounts can be someone’s email address, WhatsApp
    number, X account handle, or LinkedIn profile ID. It is unclear why the malware
    collects this information. Also included are the values `zubfih` and `bshwai`
    seen in the registration request.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '***Processing the Command-and-Control Server’s Response***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Interpreting the response received from the command URL is difficult, but [Listing
    3-28](ch03.xhtml#ch3lis28) shows the two most obvious fields.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 3-28: The response contains JavaScript code to navigate through sign-up
    pages.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The `gooycf` field contains the affiliate URL to be loaded in the next step
    of the fraud. The `jxdkqb` field contains a list of JavaScript instructions. These
    use a JavaScript bridge object injected into the premium sign-up website and allow
    the malicious JavaScript code to interact with the malicious Java code in *xn3o*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '*In the original JSON response from the server, this JavaScript code is found
    on a single line. We have formatted it here to make it more readable. We’ve also
    abbreviated it, as it is very long.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '***Secretly Signing Up for the Premium Service***'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the affiliate URL and the JavaScript commands have been downloaded, the
    malware opens the affiliate URL in a customized WebView. The WebView’s customizations
    all involve intercepting loaded websites and manipulating them, partly to circumvent
    anti-bot protections on the sign-up page and partly to interact with the sign-up
    page to simulate a legitimate user.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: In a mobile web browser, opening the affiliate URL shown in the command response
    payload redirects to the site shown in [Figure 3-3](ch03.xhtml#ch3fig3).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch03fig03.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Belgian premium service sign-up page*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This is the first stage of the premium service subscription process, where the
    user enters their phone number. In small text at the bottom, the cost of this
    service is disclosed to be six euros per week, and there are instructions for
    unsubscribing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up the JavaScript Bridge***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the sign-up page has loaded, the malware starts to interact with it through
    a *JavaScript interface*, a standard Android API in which an app can create a
    bridge between it and a website in a WebView object. A simple jadx search for
    the Android API `addJavascriptInterface` shows where this happens in *xn3o* ([Listing
    3-29](ch03.xhtml#ch3lis29)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-29: Setting up the JavaScript interface to manipulate the sign-up
    page*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The first argument passed to `addJavascriptInterface` is a Java object that
    is made accessible from websites loaded into the WebView. The second argument
    is the name that the object should be given in JavaScript. JavaScript code can
    use this name to refer to the object and call methods defined in the object. In
    case of the malware, the name is simply `JBridge`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The Java class `zse4`, which defines the JavaScript bridge object, has only
    one method marked with the `@JavascriptInterface` decorator, the `call` method.
    Only methods marked with this decorator are accessible from JavaScript, so this
    is the only method the JavaScript part of the malware can invoke. Inside the `call`
    method is a long chain of `if...else` statements, which in malware often indicates
    a piece of code that interprets commands. Finding malware’s command interpreter
    is a jackpot for reverse engineers, as it lets them see which commands are backed
    by what code. This helps reverse engineers quickly understand large parts of malicious
    functionality.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Based on the arguments to `call`, we can already see that the first argument
    is the command name and the second argument is the command options. The long `if...else`
    chain checks the command name and invokes different code based on the command
    to execute. A slice of that functionality is shown in [Listing 3-30](ch03.xhtml#ch3lis30).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 3-30: Processing JavaScript commands in the zse4 class*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the `str` argument is compared to string values `finish`, `schedule`,
    `textTo`, and `popMsg`, respectively. Following the methods called from inside
    the `if` clauses reveals the code that backs these commands.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '***Interacting with the Java Bridge Object***'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you understand the Java implementation of the JavaScript bridge object,
    take a closer look at the downloaded JavaScript commands, shown in [Listing 3-31](ch03.xhtml#ch3lis31).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 3-31: JavaScript code is used to subscribe to the premium service.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: First, the code tries to find the phone number input field on the subscription
    site using the `querySelector` method. Once it has discovered this, the code inputs
    the device’s phone number into the field, uses JavaScript to click the subscription
    button, and calls the method `nextThings`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-32](ch03.xhtml#ch3lis32) shows an excerpt of the code from `nextThings`,
    where many lines invoke the `call` method of the bridge object. As the bridge
    object is defined by the Java class `zse4`, we can easily follow what these lines
    do. Analysis of `zse4` confirms that the command names are true to their meaning:
    the JavaScript code tries to intercept an incoming SMS (`popMsg`) and send a confirmation
    SMS to the number 9956 to complete the registration process (`textTo`).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 3-32: The payload connects Java and JavaScript code through JavaScript
    interface JBridge.*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'One mystery remains: how are the JavaScript commands actually executed in the
    context of the subscription website? There’s a standard Android API for that:
    `WebView.evaluateJavascript`, which allows an app to inject any JavaScript code
    into a website.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '***Completing the Sign-up Process***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At a different code location, the list `vgy7Var.yhn6` is read and the intercepted
    SMS messages and notifications are processed. A quick reference check in jadx
    shows that the only place in the code where the list is read is in the `bhu8`
    method.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: This method, shown in [Listing 3-33](ch03.xhtml#ch3lis33), takes a string argument
    of the form `number::string`, which it splits at the double colon (`::`). The
    first part of this argument is used as a regular expression to parse the SMS.
    The second part contains the regular expression capture group number where the
    one-time password is expected. The method also takes an integer argument used
    to sleep the current thread if the expected SMS can’t be found. It likely does
    this to wait for the SMS to arrive and then check for it again.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-33: Parsing for the one-time password*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bhu8` method is called from two places in *xn3o*: once with a hardcoded
    string argument built to parse SMS messages from certain Thai subscription sites
    and once from the command handler for the `popMsg` command. For the Belgian subscription
    site, the malware uses the second option. We now know that the JavaScript code
    shown in [Listing 3-34](ch03.xhtml#ch3lis34) and previously downloaded from the
    command-and-control server is a simple extractor for a number with three to six
    digits.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-34: Parsing the one-time password for the Belgian sign-up page*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: What happens after the call to the `popMsg` method is noteworthy. [Listing 3-32](ch03.xhtml#ch3lis32)
    showed that, no matter the number extracted from the SMS, the app continues the
    sign-up process by sending the message *ok* to the phone number 9956\. While we
    don’t have access to a real Belgian phone to observe the complete sign-up process,
    we can assume that this premium service doesn’t use one-time passwords at all.
    Maybe users can confirm their subscription by simply texting *ok* to the service’s
    premium number.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**The Mysterious Fourth Stage**'
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we wrap up this chapter, let’s have a quick look at the mysterious fourth
    stage that the malware seems to rarely use. Downloading the previously mentioned
    *fbhx1* and *fbhx2* files and loading them in jadx shows that they each have just
    a single package name: *com.facebook.** or *com.facebook2.**.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'In a first step, we can try to determine the differences between *fbhx1* and
    *fbhx2*. The command line version of jadx is helpful here, as we can just decompile
    both files and then use standard programming tools to diff the two generated source
    code folders. As the package names *com.facebook.** and *com.facebook2.** are
    slightly different, we have to rename *facebook2* to *facebook* before standard
    code diffing tools work well on the output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The output, omitted here, contains only some differences seemingly caused by
    jadx decompilation quirks. It appears that the code of *fbhx1* and *fbhx2* is
    functionally identical. Knowing this, let’s take a look at how the malware interacts
    with these two files. Depending on which file is loaded, it appears that *xn3o*
    interacts with *fbhx* in only one section of code. [Listing 3-35](ch03.xhtml#ch3lis35)
    shows that the malware loads class `j` and calls methods `a` and `c`, respectively.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 3-35: The malware loading the Facebook SDK*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: A quick web search for the many strings in `j` reveals that this class is originally
    `FacebookSdk`. The `a` method is really `setApplicationId` and the `c` method
    is really `sdkInitialize`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Is the Facebook SDK legitimate, or has it been maliciously manipulated? The
    answer to that question is unclear, as, to our knowledge, there are no good public
    tools available to find maliciously modified SDKs in Android apps. Even if such
    tools were available, you would have to first find the original, legitimate SDK
    to compare with the malware’s version. Luckily the `FacebookSdk` class contains
    a version string that makes that part easier.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of useful tools, we’ll have to leave the answer to this question
    open. The Facebook SDK, as decompiled by jadx, contains more than 20,000 lines
    of code in more than 150 classes. That’s too much to manually compare to the real
    Facebook SDK. As names in the *fbhx* files are mangled, a simple diff tool will
    barely help, either.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This completes our introduction to static Android malware analysis. You learned
    about the tools you can use to statically reverse engineer malware code, as well
    as many best practices for doing so.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, we omitted significant chunks of code from our explanation of the
    malware’s core functionality. For example, we didn’t include the code used to
    parse the HTML of the premium sign-up pages. Likewise, the malware contains code
    to thwart several commercially available products that premium services can license
    to protect their sign-up pages from bot activity; we left this undescribed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Also not described is the malware’s complex messaging system. Different parts
    of the malware, in both the Java and JavaScript components, exchange messages
    using the default Android messaging system. These messages help the malware organize
    and execute its next steps depending on its current state and how far the sign-up
    process has progressed. Following this messaging system isn’t trivial due to its
    asynchronous nature and its use of broadcasts and message queues.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: While powerful, static analysis is only part of malware analysis and needs to
    be supplemented with dynamic analysis. In the next chapter, we’ll do just that,
    as we analyze a different malware sample using dynamic analysis techniques.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
