- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INVESTIGATING EVIDENCE FROM LINUX LOGS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The computer term *log* originates from an ancient sailor’s technique for measuring
    the speed of a moving ship. A wooden log attached to a long rope was thrown overboard
    behind the ship. The rope had regularly spaced knots that sailors would count
    as the moving ship distanced itself from the floating log. They could calculate
    the speed of the ship from the number of knots counted over a period of time.
    Regular measurements of the ship’s speed were recorded in the ship’s “log book”
    or log.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the word *log* came to represent a variety of recorded periodic measurements
    or events. Log books are still used by organizations to document visitors entering
    buildings, the delivery of goods, and other activities that need a written historical
    record. The concept of a computer login and logout was created to control and
    record user activity. Early time-sharing computer systems were expensive and needed
    to keep track of computing resources consumed by different users. As the cost
    of storage capacity and processing power dropped, the use of logging expanded
    to nearly all parts of a modern computer system. This wealth of logged activity
    is a valuable source of digital evidence and helps forensic investigators reconstruct
    past events and activity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional Syslog**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traditional logging system on Unix and Unix-like operating systems such
    as Linux is *syslog*. Syslog was originally written for the sendmail software
    package in the early 1980s and has since become the de facto logging standard
    for IT infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Syslog is typically implemented as a daemon (also known as a collector) that
    listens for log messages from multiple sources, such as packets arriving over
    network sockets (UDP port 514), local named pipes, or syslog library calls (see
    [Figure 5-1](ch05.xhtml#ch05fig01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Traditional syslog architecture (rsyslog)*'
  prefs: []
  type: TYPE_NORMAL
- en: The syslog architecture and network protocol is defined in RFC 5424\. Linux
    distributions have historically included one of several implementations of syslog
    for local system logging, the most common being *rsyslog*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Syslog Facility, Severity, and Priority***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The syslog standard defines the format of messages and several characteristics
    of log entries. These characteristics are *facility*, *severity*, and *priority*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message facility allows the categorization of logs depending on a subsystem.
    RFC 5424 documents 24 syslog message facilities. The rsyslog .conf(5) man page
    and the Linux *syslog.h* header file define them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some of these facility codes, like `news` (Usenet) or `uucp` (Unix-to-Unix copy)
    are obsolete and might be explicitly redefined by a system administrator at a
    local site. The last eight “local” facilities are reserved specifically for local
    sites to use as needed.
  prefs: []
  type: TYPE_NORMAL
- en: One internal facility called `mark` is often implemented separately from the
    syslog standard. If used, the syslog daemon generates `mark` log entries, together
    with a timestamp, at regularly defined intervals. These markers indicate that
    the logging subsystem was still functional during periods of time when no logs
    were received. In a forensic examination, the marks are interesting as potential
    indicators of the absence of certain activity, which can be useful information
    in an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are eight severity levels, with zero being the most severe. The highest
    numbers generate the most volume of information and are often enabled on demand
    for troubleshooting or debugging. The severity level can be represented as either
    a numeric value or a text label. The levels are listed here together with the
    short or alternate names and description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These severity levels are interesting from a forensic readiness perspective.
    If a particular syslog-generating component is at heightened risk or suspicion,
    or if there is an ongoing incident, the logging severity can be changed temporarily
    to increase the verbosity of the logs. Some tools and documentation may use the
    word priority when referring to severity.
  prefs: []
  type: TYPE_NORMAL
- en: The priority, or *PRI* value, of a syslog message is calculated from the facility
    and severity (by multiplying the facility by eight and then adding the severity).
    The syslog daemon can use the priority number to decide how to handle the message.
    These decisions include the location and file to save, filtering, which host(s)
    to forward messages to, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '***Syslog Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The configuration of the local syslog daemon is important to know in a forensic
    investigation. The configuration file entries (both defaults and administrator
    customization) direct the investigator to where logs are located, which severity
    levels have been logged, and what other logging hosts are involved. Common syslog
    daemon configuration file locations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/syslog.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/rsyslog.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/rsyslog.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/syslog-ng.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/syslog-ng/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are plaintext files that any text editor can read. The examples here include
    BSD syslog, rsyslog, and syslog-ng implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration files define the location and contents of the logs managed
    by the daemon. A typical syslog configuration line has two fields: the selector
    and the action. The *selector* field is composed of the facility and severity
    (separated by a dot). The *action* field defines the destination or other action
    taken when logs match the selector. The following is an example rsyslog configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line is commented out and intended for debugging when needed. The
    second line sends all kernel logs to */var/log/kern.log*, regardless of severity.
    In the third line, mail logs with a severity of *error* or more are sent to the
    */var/log/mail.err* logfile. These files are stored locally and can be easily
    located and examined. The last line sends all log messages (any facility) with
    a severity of *info* or more to another host on the network. The `@` indicates
    a network destination and `loghost` is a central logging infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The network destinations are especially interesting for an investigation because
    they indicate a separate non-local source of log data that can be collected and
    examined. If identical logs are stored both locally and on a remote log host,
    the correlation can be interesting if the data doesn’t match. A mismatch may indicate
    malicious modification of one of the logs.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux systems, the */var/log/* directory is the most common place to save
    logs. However, these flat text files have scalability, performance, and reliability
    challenges when high volumes of log data are ingested. Enterprise IT environments
    still use the syslog protocol over the network, but messages are often saved to
    high-performance databases or systems designed specifically for managing logs
    (Splunk is a popular example). These databases can be a valuable source of information
    for investigators and enable a quick iterative investigative process. Very large
    text-based logfiles can take a long time to query (`grep`) for keywords compared
    to database log systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Syslog Messages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A syslog message transmitted across a network is not necessarily identical to
    the corresponding message that is saved to a file. For example, some fields may
    not be saved (depending on the syslog configuration).
  prefs: []
  type: TYPE_NORMAL
- en: A program with built-in syslog support, also known as an *originator*, uses
    programming libraries or external programs to generate syslog messages on a local
    system. Programs implementing syslog are free to choose any facility and severity
    they wish for each message.^([1](footnotes.xhtml#ch05foot_01))
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let’s take a look at the `logger`^([2](footnotes.xhtml#ch05foot_02))
    tool for generating syslog messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The syslog message from this example can be observed traversing a network.
    When captured and decoded by `tcpdump`, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Some information (like severity or facility) in the original syslog messages
    might not be stored in the destination logfiles depending on how the syslog daemon
    is configured. For example, a typical rsyslog configuration will log the syslog
    message from the preceding example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the severity and facility are not logged locally; however, the syslog
    daemon is aware of them when the message arrives and may use this information
    to choose the log destination. On the `loghost`, the UDP port numbers (the source
    port in particular) are also not logged unless the site is logging firewall traffic
    or using netflow logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most syslog systems log a few standard items by default. Here is an example
    of a typical log entry generated by rsyslog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This log line contains a timestamp, the local hostname, and the program that
    generated the message together with its process ID (in square brackets), followed
    by the message produced by the program. In this example, the `dhclient` program
    (PID 18842) is logging a DHCP acknowledgement containing the machine’s local IP
    address (10.0.11.227) and the IP address of the DHCP server (10.0.11.1).
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux systems use log rotation to manage retention as logs grow over time.
    Older logs might be renamed, compressed, or even deleted. A common software package
    for this is logrotate, which manages log retention and rotation based on a set
    of configuration files. The default configuration file is */etc/logrotate.conf*,
    but packages may supply their own logrotate configuration and save it in */etc/logrotate.d/**
    during package installation. During a forensic examination, it is useful to check
    whether and how logfiles are rotated and retained over time. The logrotate package
    can manage any logfile, not only those generated by syslog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forensic examiners should be aware that syslog messages have some security
    issues that may affect the evidential value of the resulting logs. Thus, all logs
    should be analyzed with some degree of caution:'
  prefs: []
  type: TYPE_NORMAL
- en: Programs can generate messages with any facility and severity they want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syslog messages sent over a network are stateless, unencrypted, and based on
    UDP, which means they can be spoofed or modified in transit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syslog does not detect or manage dropped packets. If too many messages are sent
    or the network is unstable, some messages may go missing, and logs can be incomplete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text-based logfiles can be maliciously manipulated or deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, trusting logs and syslog messages involves assessing and accepting
    the risks of integrity and completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Some Linux distributions are starting to switch over to the systemd journal
    for logging and aren’t installing a syslog daemon. It is likely that locally installed
    syslog daemons on desktop Linux systems will decline in popularity, but in server
    environments, syslog will remain a de facto standard for network-based logging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Systemd Journal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shortcomings of the aging syslog system have resulted in a number of security
    and availability enhancements. Many of these enhancements have been added to existing
    syslog daemons as non-standard features and never gained widespread use among
    Linux distributions. The systemd journal was developed from scratch as an alternative
    logging system with additional features missing from syslog.
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd Journal Features and Components***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The design goals and decisions of the systemd journal were to add new features
    to those already found in traditional logging systems and integrate various components
    that had previously functioned as separate daemons or programs. Systemd journal
    features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Tight integration with systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr` and `stdout` from daemons is captured and logged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log entries are compressed and stored in a database format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in integrity using forward secure sealing (FSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional trusted metadata fields for each entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logfile compression and rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log message rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the introduction of FSS and trusted fields, the developers created a greater
    focus on log integrity and trustworthiness. From a digital forensics perspective,
    this is interesting and useful because it strengthens the reliability of the evidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The journal offers network transfer of messages to another log host (central
    logging infrastructure) in a similar way to traditional logging, but with a few
    enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP-based for stateful established sessions (solves dropped packet issue with
    UDP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted transmission (HTTPS) for confidentiality and privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticated connections to prevent spoofing and unauthorized messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queuing when `loghost` is unavailable (no lost messages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed data with FSS for message integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active or passive message delivery modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These networking features allow a more secure logging infrastructure to be built,
    with a focus on integrity and completeness. A significant problem with syslog
    was the UDP-based stateless packet transmission. With the systemd journal, reliability
    and completeness of log transmission is addressed.
  prefs: []
  type: TYPE_NORMAL
- en: If the journal networking features are used, check the */etc/systemd/ journal-upload.conf*
    file for the `"URL="` parameter containing the hostname of a central log host.
    This is a forensic artifact that may point to the existence of logs in a different
    location and may be important on systems for which logging is not persistent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](ch05.xhtml#ch05fig02) shows the architectural component diagram
    of systemd journal networking.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Systemd journal networking*'
  prefs: []
  type: TYPE_NORMAL
- en: See the systemd-journal-remote(8), systemd-journal-gatewayd(8), and systemd-journal-upload(8)
    man pages for more information about the journal networking features. Although
    those features are innovative and greatly improve traditional logging, they are
    systemd specific and not compatible or well known outside the Linux community.
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd Journal Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding the configuration of the systemd journal helps us assess the potential
    for finding forensic evidence on a system. The journal functions as a normal Linux
    daemon (see [Figure 5-3](ch05.xhtml#ch05fig03)) called systemd-journald and is
    well
  prefs: []
  type: TYPE_NORMAL
- en: documented in the systemd-journald(8) man page. You can find the *enable* status
    of the journal daemon at boot time by examining the systemd unit files (*systemd-journald.service*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Systemd journal daemon*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd journal has several configuration parameters that define aspects
    of its operation (described in the journald.conf(5) man page). Common configuration
    file locations for the journal are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/systemd/journald.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/systemd/journald.conf.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/usr/lib/systemd/journald.conf.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration file specifies whether logs are volatile or persistent with
    the `"Storage="` parameter. Persistent logs, if configured, are stored in a binary
    format in */var/log/journal/*. If logs are configured to be volatile, they will
    be stored in */run/log/journal/* and exist only when the system is running; they
    are not available for postmortem forensic analysis. If `"ForwardToSyslog=` `yes"`
    is set, journal logs are sent to the traditional syslog system on the local machine
    and stored in local logfiles (*/var/log/*) or possibly forwarded to a central
    log host.
  prefs: []
  type: TYPE_NORMAL
- en: On systems with a persistent journal, the */var/log/journal/* directory contains
    a subdirectory named after the machine-id (as found in */etc/machine-id*) that
    contains the local journal logfiles. The magic number identifying a journal file
    is the initial byte sequence 0x4C504B5348485248 or LPKSHHRH.
  prefs: []
  type: TYPE_NORMAL
- en: The journal files contain both system and user logs. System logs are generated
    by system services and the kernel. User logs are generated by user login sessions
    (shell or desktop) and various programs that a user executes. Users may read their
    own logs, but they are not permitted to modify or write to them directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a system with a machine-id of `506578466b474f6e88ec`
    `fbd783475780` and the corresponding directory with journal logfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Normal journal logs have a file extension of **.journal*. If the system crashed
    or had an unclean shutdown, or if the logs were corrupted, the filename will end
    in a tilde (**.journal~*). Filenames of logs that are in current use, or “online,”
    are *system.journal* and *user-UID.journal* (where UID is the numeric ID of a
    user). Logs that have been rotated to an “offline” or “archived” state have the
    original filename followed by *@* and a unique string. The unique string between
    the *@* and *.journal* is broken into three parts that describe the content of
    the logfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the composition of a long journal filename, as shown in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The deconstructed parts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/journal/ The location (path) of persistent journal files
  prefs: []
  type: TYPE_NORMAL
- en: 506578466b474f6e88ecfbd783475780/ The machine-id directory
  prefs: []
  type: TYPE_NORMAL
- en: system@ Indicates a system logfile that has been archived
  prefs: []
  type: TYPE_NORMAL
- en: e29c14a0a5fc46929ec601deeabd2204 A sequence ID
  prefs: []
  type: TYPE_NORMAL
- en: -000000000000189c The first sequence number in the file
  prefs: []
  type: TYPE_NORMAL
- en: -00059e37774baedd Hexadecimal timestamp of the first log entry
  prefs: []
  type: TYPE_NORMAL
- en: .journal Indicates a systemd journal logfile
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal timestamp refers to when the first entry was added to the journal.
    For the familiar epoch in seconds, convert this timestamp to decimal and then
    strip off the last six digits.
  prefs: []
  type: TYPE_NORMAL
- en: If the system is receiving journal logs over the network from other hosts (by
    `systemd-journal-upload` or `systemd-journal-gatewayd`), a *remote/* directory
    may exist that contains logs for each remote host. These logs will have filenames
    like *remote-*HOSTNAME*.journal*.
  prefs: []
  type: TYPE_NORMAL
- en: The journal logs the systemd boot process and follows the starting and stopping
    of unit files until the system is shut down. Linux systems maintain a unique 128-bit
    boot-id that can be found (on a running system) in */proc/sys/kernel/random/boot_id*.
    The boot-id is randomly generated by the kernel at every boot, and it acts as
    a unique identifier for a particular duration of uptime (from boot to shutdown/reboot).
    The boot-id is recorded in the journal logs and used to distinguish time periods
    between boots (for example, `journalctl --list-boots`) and to show logs since
    the last boot (for example, `journalctl -b`). These journalctl options can also
    be applied to a file or directory for offline analysis. The boot-id may be of
    interest during a forensic examination if any malicious activity was known to
    have occurred during a specific boot period.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis of Journal File Contents***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If commercial forensic tool support for journal files is unavailable, you can
    copy and analyze the journal files on a separate Linux analysis machine using
    the `journalctl` command. This command allows you to list the journal contents,
    search the journal, list individual boot periods, view additional log metadata
    (journald specific), view `stderr` and `stdout` from programs, export to other
    formats, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying the desired journal files or the entire journal directory to
    your analysis machine, you can use `journalctl` file and directory flags to specify
    the location of the journal files to be analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a file will operate only on that single file. Specifying a directory
    will operate on all the valid journal files in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each journal file contains a header with metadata about itself, which you can
    view by using the `--header` flag of `journalctl`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output provides a technical description of the journal file, the time- stamps
    of the period covered (head and tail), the number of logs (`Entry` `objects`),
    and other statistics. You can find more information about the journal file format
    here:^([3](footnotes.xhtml#ch05foot_03)) *[https://systemd.io/JOURNAL_FILE_FORMAT/](https://systemd.io/JOURNAL_FILE_FORMAT/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a basic listing of a specific journal file’s contents
    using the `journalctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, system.journal is the name of the file being analyzed. The
    first line is informational, indicating the time period contained in the output.
    Some of the output is from the kernel, similar to the output from the dmesg command.
    Other lines are similar to syslog, starting with a timestamp, hostname, daemon
    name, and the process ID in square brackets, and ending with the log message.
    The journalctl command may also add other informational lines like -- Reboot --
    to indicate the end of a boot period (and the start of a new boot-id).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each log entry has journal-specific metadata stored together with the log message.
    A full extraction of a journal entry can be done with a verbose output (`-o verbose`)
    parameter. The following is a verbose journal entry from the OpenSSH daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This output provides structured information with unique identifiers, systemd
    information, syslog `FACILITY` and `PRIORITY` (severity), the process that produced
    the log message, and more. The systemd.journal-fields(7) man page describes the
    fields of a journal log entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Journal files are saved in a binary format that’s open and documented. The
    `journalctl` tool can be used to perform various examination tasks on journal
    files, but some forensic investigators may prefer to export the journal contents
    into another format for analysis. Two useful output formats are *export* and *json*.
    The export format is similar to the verbose format, with each entry separated
    by a blank line (this is technically a binary format, but it contains mostly readable
    text). The *json* output generates the journal entries in JSON for easy scripting
    or ingesting into other analysis tools. Here are two command line examples of
    creating *.json* and *.export* files with the full contents of a journal file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The new files created are *system.journal.json* and *system.journal.export*,
    which other (non-Linux) tools can easily read. Another output format is *.json-pretty*,
    which produces JSON in a more human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching journal files is done by including match arguments in the form *FIELD*`=`*VALUE*,
    but the exact value you’re searching for needs to be specified. This type of search
    can be useful for extracting logs from a particular service. For example, to extract
    all logs from the `sshd.service` unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions (regex) can be used with the --grep= parameter, but they
    can search only the message fields, not the journal metadata. The search syntax
    is not very flexible for forensic investigators, and it may be easier to export
    the journal to another format and use familiar tools like grep or other text search
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the systemd journal can log `stdout` and `sdterr`
    of daemons and other unit files. With traditional syslog, that information was
    typically lost because the daemon would detach from the controlling terminal when
    it started. Systemd preserves this output and saves it to the journal. You can
    list this output by specifying the `stdout` transport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Transports specify how the journal received the log entry. There are other transports
    like syslog, kernel, audit, and so on. These transports are documented in the
    systemd.journal-fields(7) man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a journal file contains FSS information, the integrity can be checked using
    the `--verify` flag. In the following example, a journal file is checked, and
    `PASS` indicates that the file integrity is verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If a journal file has been tampered with, it will fail the verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the FSS integrity failed at byte offset 0x38fcc0 of the journal
    file, with a log entry that was maliciously modified. If a logfile has been tampered
    with in multiple places, the verification will fail at the first instance of tampering.
  prefs: []
  type: TYPE_NORMAL
- en: 'When investigating incidents that happened during a known window of time, extracting
    logs from an explicit time frame is useful. The `journalctl` command can extract
    logs with a specified time range using two flags: `-S` (since) and `-U` (until).
    Any logs existing since the time of `-S` until (but not including) the time of
    `-U` are extracted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two examples are from a Linux forensic analysis machine where
    journal files have been copied to an evidence directory for examination using
    the `journalctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the directory containing the journal files is specified
    and logs from November 1 and November 2 are extracted. The second example specifies
    a more exact time range and extracts logs from 8 AM to 9 AM on November 5\. See
    the journalctl(1) man page for other variations of the time and date string.
  prefs: []
  type: TYPE_NORMAL
- en: The new features of systemd’s journal mechanism are very much aligned with forensic-readiness
    expectations. The systemd journal offers log completeness and integrity, which
    are fundamental concepts in digital forensics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Application and Daemon Logs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programs are not required to use syslog or the systemd journal. A daemon or
    application may have a separate logging mechanism that completely ignores system-provided
    logging. Daemons or applications may also use syslog or the journal, but with
    non-standard facilities or severities and their own message formats.
  prefs: []
  type: TYPE_NORMAL
- en: '***Custom Logging to Syslog or Systemd Journal***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Syslog provides a C library function for programs to generate syslog messages.
    Systemd provides an API for programs to submit log entries to the journal. Developers
    are free to use those instead of developing their own logging subsystems. However,
    the facilities, severities, and format of the message, are all decided by the
    developer. This freedom can lead to a variety of logging configurations among
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, each program uses a different syslog facility and
    severity for logging similar actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These logs describe failed logins from a mail server (`postfix`) ➊, secure shell
    (`sshd`) ➋, an imap server (`dovecot` using `pam`) ➌, and a SOCKS proxy (`danted`)
    ➍ .They all use different facilities (`mail`, `auth`, `authpriv`, `daemon`), and
    they all use different severities (`warning`, `info`, `notice`). In some cases,
    additional logs may contain more information about the same event at different
    facilities or severities. Forensic examiners should not assume all similar log
    events will use the same facility or severity, but rather should expect some variation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Daemons may choose to log to a custom or user-defined facility. This is usually
    defined in the daemon’s configuration or from compiled-in defaults. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here a `pppd` daemon is using `local2` as the facility, the `tcsd` daemon that
    manages the TPM uses `local5`, and an Apache web server (`apache2`) is configured
    to use `local7`. Daemons can log to whatever facility they want, and system administrators
    may choose to configure logging to a desired facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an investigation is ongoing or an attack is underway, additional logging
    may be needed (possibly only temporarily). If there are heightened risks involving
    potential suspects or victims, logging can be selectively increased to support
    the collection of digital forensic evidence. For example, consider these potential
    entities for which selective increased logging could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: A particular user or group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A geographical region or specific location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A particular server or group of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IP address or range of IPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific software components running on a system (daemons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most daemons provide configuration options to increase the verbosity of logging.
    Some daemons offer very granular possibilities of selective logging. For example,
    Postfix configuration directives allow increased logging for a specific list of
    IP addresses or domain names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a single IP address is selected for increased logging, using
    Postfix’s internal debug levels (3 instead of the default 2). The configuration
    documentation for each daemon will describe possibilities for verbose, debug,
    or other selective logging adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous section, the `stdout` and `stderr` of a daemon
    started with systemd will be captured and logged to the journal, which is also
    useful from a forensic readiness perspective. If a daemon allows for verbose or
    debugging output to the console, it can be temporarily enabled for the duration
    of an incident or investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Independent Server Application Logs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often applications will manage their own logfiles without the use of local logging
    systems like syslog or the systemd journal. In those situations, logs are typically
    stored in a separate logfile or log directory, usually in the */var/ log/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Larger applications may be complex enough to warrant multiple separate logfiles
    for different subsystems and components. This may include separate logfiles for
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Application technical errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication (logins, logouts, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application user transactions (web access, sessions, purchases, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security violations and alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotated or archived logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Apache web server is a good example. It typically has a separate directory
    like */var/log/apache2/* or */var/log/httpd/*. The contents of the directory may
    include logs for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General web access (*access.log*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web access for individual virtual hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web access for individual web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daemon errors (*error.log*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL error logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications will typically specify the log location, content, and verbosity
    in their configuration files. A forensic examiner should check for those log locations
    if it is not otherwise obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Some application installations may be fully contained in a specific directory
    on the filesystem, and the application may use this directory to store logs together
    with other application files. This setup is typical of web applications that may
    be self-contained within a directory. For example, the
  prefs: []
  type: TYPE_NORMAL
- en: 'Nextcloud hosting platform and Roundcube webmail application have such application
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nextcloud/data/nextcloud.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextcloud/data/updater.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextcloud/data/audit.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*roundcube/logs/sendmail.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*roundcube/logs/errors.log*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that these logs are generated in addition to the web server access
    and error logs (apache, nginx, and so on). With web applications, a forensic examiner
    may find logs in multiple places related to a particular application, event, or
    incident.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications may store logs in databases instead of text files. These are
    either full database services like MySQL or Postgres, or local database files
    like SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting log related to programs installed on a system is the *alternatives*
    log. The alternatives system was originally developed for Debian to allow installation
    of several concurrent versions of similar programs. Multiple distributions have
    adopted the alternatives mechanism. The `update-alternatives` script manages the
    symbolic links to generic or alternative application names located in the */etc/alternatives/*
    directory. For example, several symlinks are created to provide a `vi` program
    alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The timestamp of the */etc/alternatives/* symlink indicates when the last change
    was made. This information is also recorded in the *alternatives.log* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a system-wide method of assigning default applications (analogous to
    XDG defaults for desktop users) and helps build a picture of which programs were
    used on a system. See the update-alternatives(1) man page^([4](footnotes.xhtml#ch05foot_04))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: During a forensic examination, pay close attention to error logs. Error messages
    reveal unusual and suspicious activity, and help to reconstruct past events. When
    investigating intrusions, error messages appearing before an incident can indicate
    pre-attack reconnaissance or prior failed attempts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Independent User Application Logs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a user logs in to a Linux system, standard logs are created by the various
    components of the system (login, pam, display manager, and so on). After a user
    has logged in to their desktop or shell, further logging may also be saved in
    locations specific to that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd journal saves persistent logs specific to a user’s login session
    in */var/log/journal/*MACHINE-ID*/*user-UID*.journal*, where *UID* is a user’s
    numeric ID. This log (and the rotated instances) contains traces of a person’s
    login session activity, which may include information like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Systemd targets reached and user services started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dbus-daemon activated services and other activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents like gnupg, polkit, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages from subsystems like pulseaudio and Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs from desktop environments like GNOME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation like `sudo` or `pkexec`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of user journal files is the same as system journal files, and you
    can use the `journalctl` tool to analyze them (described earlier in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Other logs may be saved by programs as they are run by a user. The location
    of such program logs must be in a directory writable by the user, which generally
    means they are somewhere in the user’s home directory. The most common places
    for persistent logs are the XDG base directory standards such as *~/.local/share/*APP*/**
    or *~/.config/*APP*/** (where *APP* is the application generating user logs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a Jitsi video chat application log stored in *~/.config/*,
    which contains error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The benign warning messages shown here were generated whenever the Jitsi application
    started. For a forensic investigator, the content of these messages may not be
    interesting, but the timestamps indicate every time the video chat program was
    started. Trivial errors like this are potentially interesting for reconstructing
    past events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programs ignore the XDG standard and create hidden files and directories
    at the root of the user’s home directory. For example, the Zoom video chat application
    creates a *~/.zoom/log/* directory with a logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This Zoom log contains a wealth of information, including traces of past conference
    IDs that were used.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary or non-persistent logs may also be found in *~/.local/cache/* APP*/**,
    as this cache directory is intended for data that can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `libvirt` system for managing the user’s KVM/QEMU virtual
    machines has a log directory with a file for each machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Performing a search for **.log* files or directories called “log” across a user’s
    home directory will produce an initial list of files to analyze. Linux applications
    can produce a significant amount of logs and persistent data that’s saved whenever
    the user runs various programs.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis of individual application logs is outside the scope of this book,
    but it is worth mentioning that many popular apps store significant amounts of
    information about past use in a user’s home directory. This information often
    contains a history of files opened, remote host connections, communication with
    other people, timestamps of usage, devices accessed, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plymouth Splash Startup Logs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During startup, most desktop distros use the Plymouth system to produce a graphical
    splash screen while the system is booting. The ESC key can be pressed while waiting
    to switch to console output. Non-graphical servers can also use Plymouth to provide
    visible output while a system is booting. The output provides color status indicators
    with green `[ OK ]` or red `[FAILED]` messages for each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Plymouth console output is typically saved to the */var/log/boot.log*
    file; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This file contains escape codes needed to produce the color indicators. It is
    safe to view, even if your analysis tool warns that it is a binary file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Failed components during boot will also appear in the boot log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rotated versions of the boot log may also exist in the */var/log/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: This boot log can be interesting to analyze in a forensic investigation. It
    shows the sequence of events during previous boots and may provide useful error
    messages. For example, the preceding error message indicates that the Linux firewall
    rules (`nftables`) failed to start. If this were an investigation of a system
    intrusion, that could be a critical piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel and Audit Logs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logging described so far has been generated by userspace programs, daemons,
    and applications. The Linux kernel also generates log information from kernel
    space, which can be useful in a forensic investigation. This section explains
    the purpose of kernel-generated messages, where they are located, and how to analyze
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux audit system is composed of many userspace tools and daemons to configure
    auditing, but the auditing and logging activity is performed from within the running
    kernel. This is the reason for including it here together with the kernel logging
    mechanism. Firewall logs are also produced by the kernel and would fit nicely
    in this section, but that topic is covered in [Chapter 8](ch08.xhtml) on the forensic
    analysis of Linux networking.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Kernel Ring Buffer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Linux kernel has a cyclic buffer that contains messages generated by the
    kernel and kernel modules. This buffer is a fixed size, and once it’s full, it
    stays full and starts overwriting the oldest entries with any new entries, which
    means kernel logs are continuously lost as new messages are written. Userspace
    daemons are needed to capture and process events as they are produced. The kernel
    provides */dev/kmsg* and */proc/kmsg* for daemons like systemd-journald and rsyslogd
    to read new kernel messages as they are generated. These messages are then saved
    or forwarded depending on the log daemon’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The `dmesg` command is used on a running system to display the current contents
    of the ring buffer, but that isn’t useful in a postmortem forensic examination.
    The ring buffer exists only in memory, but we can find traces of it in the logs
    written to the filesystem. During boot, the kernel begins saving messages to the
    ring buffer before any logging daemons are started. Once these daemons (systemd-journald,
    rsyslogd, and so on) start, they can read all the current kernel logs and begin
    to monitor for new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common for syslog daemons to log kernel events to the */var/log/ kern.log*
    file. Rotated versions of this log may include *kern.log.1*, *kern.log.2.gz*,
    and so on. The format is similar to other syslog files. For example, the saved
    kernel logs from a compressed rotated log from rsyslogd on a Raspberry Pi look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The rsyslogd daemon has a module called `imklog` that manages the logging of
    kernel events and is typically configured in the */etc/rsyslog.conf* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Systemd stores kernel logs in the journal with everything else. To view the
    kernel logs from a journal file, add the -k flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The */etc/systemd/journald.conf* has a parameter (`ReadKMsg=`) that enables
    processing of kernel messages from */dev/kmsg* (which is the default).
  prefs: []
  type: TYPE_NORMAL
- en: 'For a forensic examiner, kernel messages are important to help reconstruct
    the hardware components of a system at boot time and during system operation (until
    shutdown). During this period (identified by the boot-id), a record of attached,
    detached, and modified hardware devices (including manufacturer details) can be
    seen. In addition, information about various kernel subsystems such as networking,
    filesystems, virtual devices, and more can be found. Some examples of information
    that you can find in the kernel logs include:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU features and microcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel version and kernel command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical RAM and memory maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BIOS and mainboard details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACPI information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure boot and TPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCI bus and devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB hubs and devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethernet interfaces and network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage devices (SATA, NVMe, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall logging (blocked or accepted packets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors and security alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at some examples of kernel messages that are interesting in a forensic
    investigation or that may raise questions regarding the existence of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, information about a particular mainboard is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can determine the mainboard is an ASUS Republic of Gamers model, and
    the current firmware (BIOS) version is shown. The mainboard model may provide
    some indication of system use (gamer rig, server, office PC, and so on). The firmware
    version may be of interest when examining security relevant vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newly attached hardware will generate kernel logs like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, an external speaker was plugged in to the system. This log information
    associates a specific piece of hardware with a machine at a specific point in
    time, and indicates that a person was in physical proximity to plug in the USB
    cable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example kernel message about a network interface’s mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A network interface in *promiscuous mode* indicates that a packet sniffer is
    being used to capture traffic on a network subnet. An interface may enter promiscuous
    mode when a network administrator is troubleshooting problems or if a machine
    has been compromised and is sniffing for passwords or other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A kernel message about a network interface’s online/offline status may look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the kernel logs indicate that a network interface came online for nearly
    50 minutes before going offline. If this were an intrusion or data theft investigation,
    observing an interface suddenly appearing could indicate an unused network port
    was involved. And if an unused physical Ethernet port was involved, it could mean
    that there was physical access to the server (which then means that you should
    check CCTV footage or server room access logs).
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the kernel logs, try to separate the boot logs from the operational
    logs. During boot, there will be hundreds of log lines in a short period that
    are all associated with the boot process. The kernel logs generated after booting
    is finished will indicate changes during the operational state of the machine
    until shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: You can temporarily increase the verbosity of kernel logs during an ongoing
    investigation or attack to generate additional information. The kernel accepts
    parameters to specify increased (or reduced) logging in several areas. See *[https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.txt](https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.txt)*
    for more information about the kernel parameters (search for “log”). These parameters
    can be added to GRUB during system startup (see [Chapter 6](ch06.xhtml) for more
    information).
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual kernel modules may also have verbose flags to increase logging.
    Use modinfo with the kernel module name to find possible debug options. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Ethernet module e1000e has a `debug` option that can be set.
    The options for individual modules can be specified by placing a **.conf* file
    in the */etc/modprobe.d/* directory. See the modprobe.d(5) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Linux Auditing System***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Linux Auditing System is described in the README file of the source code:
    “The Linux Audit subsystem provides a secure logging framework that is used to
    capture and record security relevant events.” Linux auditing is a kernel feature
    that generates an audit trail based on a set of rules. It has similarities to
    other logging mechanisms, but it is more flexible, granular, and able to log file
    access and system calls. The `auditctl` program loads rules into the kernel, and
    the `auditd` daemon writes the audit records to disk. See the auditctl(8) and
    auditd(8) man pages for more information. [Figure 5-4](ch05.xhtml#ch05fig04) shows
    the interaction between the various components.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Linux Auditing System*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of audit rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control rules** Overall control of the audit system'
  prefs: []
  type: TYPE_NORMAL
- en: '**File or “watch” rules** Audit access to files and directories'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syscall** Audit system calls'
  prefs: []
  type: TYPE_NORMAL
- en: Audit rules are loaded into the kernel at boot time or by a system administrator
    using the `auditctl` tool on a running system.^([5](footnotes.xhtml#ch05foot_05))
    The audit rules are located in the */etc/audit/audit.rules* file. See the audit.rules(7)
    man page for more information about audit rules.
  prefs: []
  type: TYPE_NORMAL
- en: A collection of separate rule files located in */etc/audit/rules.d/*.rules*
    can be merged with the */etc/audit/audit.rules* file using the *augenrules* file.
    The audit rules file is simply a list of arguments that would be provided to `auditctl`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several examples of audit rule lines as seen in a rule file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first rule deletes all current rules, effectively creating a new rule set.
    The second rule watches all the files in the */etc/ssl/private/* directory (recursively).
    If any user or process reads, writes, or changes the attributes on any files (like
    SSL private keys), an audit record will be generated. The third rule monitors
    a specific user (UID 1001 specified with `auid=`) for all files opened. Presumably
    this user is at heightened risk of attack or under suspicion.
  prefs: []
  type: TYPE_NORMAL
- en: The default location of the audit log is */var/log/audit/audit.log* where `auditd`
    writes new audit records. This is a plaintext file with *FIELD = VALUE* pairs
    separated by spaces. The current list of field names can be found at *[https://github.com/linux-audit/audit-documentation/blob/master/specs/fields/field-dictionary.csv](https://github.com/linux-audit/audit-documentation/blob/master/specs/fields/field-dictionary.csv)*.
    This file can be examined in its raw format, but the `ausearch` and `aureport`
    tools provide normalization, post-processing, and more readable output.
  prefs: []
  type: TYPE_NORMAL
- en: The *audit.log* file can be copied to a Linux analysis machine on which `ausearch`
    and `aureport` can be used with the `--input` flag to specify the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An audit record format can be raw or enriched. Enriched records additionally
    resolve numbers to names and append them to the log line. An example enriched
    audit record from a */var/log/audit/audit.log* file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The same audit record produced with the ausearch tool looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This command produces a formatted output of the entire *audit.log* file. Here
    the date is converted from epoch format, and some control character formatting
    corrections are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify `csv` or `text` for the output format. The `csv` format is
    useful for importing into other tools. The `text` format produces a single readable
    line for each audit record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See the ausearch(8) man page for other specific queries of the audit log.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a report of statistics from an audit logfile, the `aureport` command
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This summary may be useful for inclusion in a forensic report or to help guide
    where to look next in a forensic examination.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate individual reports for each of these statistics. For example,
    the following generates a report on logins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See the aureport(9) man page for the flags needed to generate other detailed
    reports about the other statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aureport` and `ausearch` commands can also specify a time period. For
    example, this report is generated for the time period between 9 AM and 10 AM (but
    not including 10 AM) on November 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Both `aureport` and `ausearch` use the same flags for the time range.
  prefs: []
  type: TYPE_NORMAL
- en: The `aureport` and `ausearch` commands have flags to interpret numeric entities
    and convert them to names. Do not do this. It will replace the numeric user IDs
    and group IDs with the matching names found on your own analysis machine, not
    from the suspect disk under analysis. The `ausearch` command also has a flag to
    resolve hostnames, which is not recommended when performing a forensic examination.
    This will potentially trigger a DNS network request, which could produce inaccurate
    results or otherwise compromise an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we have identified the locations of typical logs found on a
    Linux system. You have learned how to view these logs and the information they
    may contain. You have also seen examples of tools used to analyze logs in a forensic
    context. This chapter has provided the background on Linux logs that are referenced
    throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
