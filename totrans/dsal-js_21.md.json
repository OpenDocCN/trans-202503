["```\nconst isEmpty = (list) => list === null;\n\nconst add = (list, position, value) => {\n❶ if (isEmpty(list) || position === 0) {\n   return {value, next: list};\n❷} else {\n   return {value: list.value, next: add(list.next, position - 1, value)};\n  }\n};\n```", "```\nconst remove = (list, position) => {\n❶ if (isEmpty(list)) {\n   return list;\n❷} else if (position === 0) {\n   return list.next;\n❸} else {\n   return {value: list.value, next: remove(list.next, position - 1)};\n  }\n};\n```", "```\n❶ const newQueue = () => ({backPart: null, frontPart: null});\n\n❷ const isEmpty = (queue) =>\n  queue.backPart === null && queue.frontPart === null;\n```", "```\nconst enter = (queue, value) => ({\n❶ backPart: {value, next: queue.backPart},\n❷ frontPart: queue.frontPart\n});\n```", "```\nconst exit = (queue) => {\n❶ if (isEmpty(queue)) {\n    return queue;\n❷} else {\n    let newfrontPart = queue.frontPart;\n    let oldbackPart = queue.backPart;\n  ❸ if (newfrontPart === null) {\n    ❹ while (oldbackPart !== null) {\n        newfrontPart = {value: oldbackPart.value, next: newfrontPart};\n        oldbackPart = oldbackPart.next;\n      }\n    }\n  ❺ return {backPart: oldbackPart, frontPart: newfrontPart.next};\n  }\n};\n```", "```\nconst add = (tree, keyToAdd) => {\n❶ if (isEmpty(tree)) {\n   return newNode(keyToAdd);\n❷} else if (keyToAdd <= tree.key) {\n   return newNode(tree.key, add(tree.left, keyToAdd), tree.right);\n❸} else {\n   return newNode(tree.key, tree.left, add(tree.right, keyToAdd));\n  }\n};\n```", "```\nconst newNode = (key, left = null, right = null) => ({key, left, right});\n```", "```\nconst remove = (tree, keyToRemove) => {\n❶ if (isEmpty(tree)) {\n   return tree;\n❷} else if (keyToRemove < tree.key) {\n   return newNode(tree.key, remove(tree.left, keyToRemove), tree.right);\n❸} else if (keyToRemove > tree.key) {\n   return newNode(tree.key, tree.left, remove(tree.right, keyToRemove));\n❹} else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n   return null;\n❺} else if (isEmpty(tree.left)) {\n   return tree.right;\n❻} else if (isEmpty(tree.right)) {\n   return tree.left;\n❼} else {\n  ❽ const rightMin = minKey(tree.right);\n  ❾ return newNode(rightMin, tree.left, remove(tree.right, rightMin));\n  }\n};\n```", "```\nconst minKey = (tree) => (isEmpty(tree.left) ? tree.key : minKey(tree.left));\n```"]