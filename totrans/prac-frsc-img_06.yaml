- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ATTACHING SUBJECT MEDIA TO AN ACQUISITION HOST**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the physical attachment of subject storage media to an
    examination host, identification of the subject device on the system, and querying
    the device firmware for information. You’ll also learn about methods for removing
    HPA and DCO, unlocking ATA passwords, and decrypting self-encrypting drives. The
    chapter ends with several special storage topics. Let’s start by examining the
    subject PC hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examine Subject PC Hardware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a PC or notebook is seized in the field or delivered to a forensic lab
    for examination, more than just the internal disks can be examined. Included in
    the examination should be a complete review of the PC hardware configuration,
    BIOS settings, hardware clock, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The scope of this book covers “dead” disk acquisition, that is, drives and
    PCs that are already powered off. Depending on the organization, a triage process
    will exist for arriving at a crime or incident scene with live, running machines.
    This triage process may include taking photographs of screens, using mouse jigglers
    to prevent password-protected screensavers from activating, or running memory-dumping
    tools. First responder triage of live PCs is outside the scope of this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Physical PC Examination and Disk Removal***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you unplug any drive cables or unscrew any drives from the drive bays,
    take photographs of the subject PC to document the hardware configuration, the
    number of disks it contains, and how the disks are cabled to the mainboard.
  prefs: []
  type: TYPE_NORMAL
- en: Remove disks with care, especially if they’re in old PCs that may not have been
    opened for many years. The top of each drive can be photographed to capture the
    serial number and other information on the label. For each disk, note the cable
    location on the mainboard. If a mainboard has multiple SATA ports, note which
    port each disk was using.
  prefs: []
  type: TYPE_NORMAL
- en: Open optical drive trays to confirm they don’t contain any discs. Most optical
    drives have a pinhole that can manually release the drive door without powering
    on the drive.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the PCI slots for PCI SATA Express drives or PCI NVME drives. If a mainboard
    has an M.2 or mSATA slot, check for SSD circuit boards.
  prefs: []
  type: TYPE_NORMAL
- en: '***Subject PC Hardware Review***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After removing all the drives from the subject PC enclosure, power on the subject
    mainboard and note the BIOS configuration, clock, boot order, potential BIOS logs,
    version, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: If you require further information about the subject PC, examine it using a
    forensic boot CD that contains various hardware analysis tools, such as lshw,
    dmidecode, biosdecode, lspic, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You might be able to retrieve some vendor-specific information by using vendor-specific
    tools—for example, vpddecode for IBM and Lenovo hardware or ownership for Compaq
    hardware ownership tags.
  prefs: []
  type: TYPE_NORMAL
- en: Examine and document any additional hardware components as well, such as memory
    modules or PCI cards.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attach Subject Disk to an Acquisition Host**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After physically attaching the subject drive to the examiner workstation (using
    a write-blocking mechanism), you need to identify the correct block device associated
    with the subject drive. To reliably identify the subject drive on the acquisition
    host, list the storage media devices, confirm any unique identifiers associated
    with the physical drive, and determine the corresponding device file in */dev*.
    This section examines these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***View Acquisition Host Hardware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding the examination host’s hardware configuration is useful for performance
    tuning, capacity planning, maintaining a stable platform, troubleshooting, isolating
    faults, and reducing the risk of human error. In this section, you’ll see examples
    of tools you can use for listing and viewing PC hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the lshw tool, you can generate a quick overview of the examiner workstation
    hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The bus information describes the device specific addresses, such as [pci@domain:bus:slot.function](mailto:pci@domain:bus:slot.function),
    [scsi@host.channel.target.lun](mailto:scsi@host.channel.target.lun), and [usb@bus:device](mailto:usb@bus:device).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use lshw to specifically look for an attached device type. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that `scsi22` links to `scsi@22:.0.0.0`, which links to */dev/sdp*. Identifying
    the Linux device file for an attached physical drive is discussed further in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: If the subject drive has been externally attached, it’s likely connected via
    USB, Thunderbolt, FireWire, or eSATA (and in rare cases, possibly Fibre Channel).
  prefs: []
  type: TYPE_NORMAL
- en: If the drive has been internally attached, it’s likely connected via SATA cable,
    a PCI Express slot, an M.2 interface, or SAS cable (or possibly legacy interfaces,
    such as parallel SCSI or IDE).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the devices attached to the PCI bus (including parallel PCI and
    PCI Express) using the lspci tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The PCI bus categorizes devices by class (see *[http://pci-ids.ucw.cz/](http://pci-ids.ucw.cz/)*
    for more information about PCI IDs and device classes). Devices matching the *Mass
    storage controller* class (class ID 01) are of interest because they manage attached
    storage media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newer versions of lspci (as of pciutils version 3.30) can list the PCI bus
    by device class, which can be useful to isolate specific hardware of interest.
    The following command lists all SATA mass storage controller (class ID 01, subclass
    ID 06) devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command enumerates all the SCSI, IDE, RAID, ATA, SATA, SAS, and NVME mass
    storage controller devices on a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another PCI class that can manage connected storage media is the *serial bus
    controller* class (class ID 0C). The following command lists all devices with
    the USB serial bus controller class (class ID 0C, subclass ID 03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command enumerates all FireWire, USB, and Fibre Channel serial bus controllers
    on the examiner host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the subject drive is attached via USB, it won’t appear on the PCI bus. You
    can list USB devices separately using lsusb. Without options, the command generates
    a list of all attached USB devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here a USB thumb drive is attached to USB bus 1 and assigned a USB device ID
    of 5\. Running `lsusb -v` will provide more detailed output about the USB device.^([1](footnote.xhtml#fn22))
  prefs: []
  type: TYPE_NORMAL
- en: The preceding tools and examples provide an overview of the storage media controllers
    and the hardware attached to an examiner workstation. The lshw(1), lspci(8), and
    lsusb(8) manual pages explain additional parameters and features, which you can
    use to view more detail about the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify the Subject Drive***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having an understanding of the examiner workstation hardware, especially the
    available bus systems and controllers, will help you locate where a subject disk
    is attached. The next step is to positively confirm the identity of the subject
    drive using some distinct information, such as a serial number, unique model number,
    or other unique property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use multiple approaches to identify the subject device. If the subject
    disk is attached via the USB bus and listed with the lsusb tool, you can retrieve
    more information by specifying the subject disk’s `vendor`:productID, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From this output, you can use the unique information (serial number and so on)
    about the device to confirm the identity of the attached device as the subject
    drive. If the serial number or other unique properties match the physically attached
    drive, you’ve identified the correct device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearly all drives are accessible via SCSI commands (directly attached NVME
    drives are a notable exception). To query for an attached storage device, you
    can use the lsscsi tool. It supports a number of transport layer protocols, including
    SATA, USB, SAS, FireWire, ATA, SCSI, Fibre Channel, and more. lsscsi is also useful
    for linking kernel device paths with device files in */dev*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel outputs an informational message when devices are attached or detached
    from a host system. This is the kernel *ring buffer* and is viewed with the dmesg
    tool. Running `dmesg` with the `-T` flag prints human-readable timestamps, which
    are useful when you’re determining which device was added at a known time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can use this output to identify an attached physical device, linking the
    USB device to a SCSI host ID and a block device name. In this example, `usb 2-1:`
    refers to bus 2 and physical port 1 (the plug). The USB drive is assigned `device
    number 9` and uses the *xhci_hcd driver* (which has USB3 support). The vendor
    and product ID strings, `idVendor=0781`, `idProduct=5583`, are displayed, followed
    by informational strings for the manufacturer, product, and serial number (these
    can be different from `idVendor` and `idProduct`). The Bulk-Only Transport `usb-storage`
    driver detects the device (not needed for UASP devices), and `scsi host24:` indicates
    a SCSI host number has been assigned to the device and corresponds to the SCSI
    address `24:0:0:0:`. Two devices are created, `sg5` (generic SCSI) and `sdf` (block
    device), which correspond to */dev/sg5* and */dev/sdf*. Some information about
    the (now established) SCSI device is queried, and partition tables are detected
    (`sdf1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler command to list all attached storage devices, including descriptive
    information and device paths, is the `lsblk` command. Newer versions of lsblk
    provide output options for vendor, model, revision, serial number, and *WWN* (*World
    Wide Name*; *[https://en.wikipedia.org/wiki/World_Wide_Name](https://en.wikipedia.org/wiki/World_Wide_Name)*)
    number. In addition, lsblk provides useful technical details, such as the device
    name, size, physical and logical sector size, transport (USB, SATA, SAS, and so
    on), SCSI address, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Most of the tools demonstrated here are simply reading different files and directories
    from the Linux */proc* directory. You’ll find more information about attached
    drives and other kernel structures in the */proc* tree. Consult the proc(5) manual
    page for more information about the proc filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Query the Subject Disk for Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After attaching the subject drive to the examiner workstation and positively
    identifying the correct Linux device to work with, you can gather additional meta
    information about the device. You can query the device directly for information
    about the drive, the firmware, SMART data, and other configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: A number of tools are available to query information stored in the hard drive.
    Typically, you access this firmware information using lower-level ATA or SCSI
    interface commands, which interact directly with the drive electronics.
  prefs: []
  type: TYPE_NORMAL
- en: '***Document Device Identification Details***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, you should have a number of details and technical identifiers
    about the drive attached to the examiner host, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Vendor, make, and model
  prefs: []
  type: TYPE_NORMAL
- en: • Serial number or WWN
  prefs: []
  type: TYPE_NORMAL
- en: • Linux device name
  prefs: []
  type: TYPE_NORMAL
- en: • PCI `domain`:bus:slot.function
  prefs: []
  type: TYPE_NORMAL
- en: • PCI `vendorID`:deviceID
  prefs: []
  type: TYPE_NORMAL
- en: • USB `bus`:device
  prefs: []
  type: TYPE_NORMAL
- en: • USB `vendorID`:productID
  prefs: []
  type: TYPE_NORMAL
- en: • SCSI `host`:channel:target:lun
  prefs: []
  type: TYPE_NORMAL
- en: You can save this information for reporting purposes by redirecting the various
    tool command outputs to text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Document evidence for the use of a write blocker. If you’re using a hardware
    write blocker, such as Tableau, query it and save the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here */dev/sdc* should be replaced with the relevant device of the subject drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using a software write blocker, such as wrtblk, query `blockdev`
    for a report on the current status of the device (including the read-only flag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here */dev/sda* should be replaced with the relevant device of the subject drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the subject drive is attached via USB, you can specify it either by the
    `bus`:device (using `-s`) or by `vendor`:product (using `-d`). The following two
    commands will produce and save the same verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here `2:2` and `13fe:5200` should be replaced with the relevant values for the
    subject drive on your acquisition host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lsblk` command can specify a Linux device, and the `-O` flag will output
    all available columns in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here */dev/sda* should be replaced with the relevant device of the subject drive
    on your acquisition host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lsscsi` command can also save a certain perspective of the attached drive,
    specifying the SCSI address to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here `16:0:0:0` should be replaced with the relevant SCSI address of the subject
    drive on your acquisition host.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant dmesg output could also be copied into a text file if desired.
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in this section illustrated how to save command output for
    a specific subject drive. For brevity, subsequent chapters sometimes will not
    include examples of saving data to files, focusing instead on the construction
    of commands.
  prefs: []
  type: TYPE_NORMAL
- en: '***Query Disk Capabilities and Features with hdparm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many of the tools discussed previously (lsusb, lspci, lsblk, and so on) have
    queried the Linux system and kernel structures for information. However, it’s
    possible to query a drive directly for additional information. The hdparm tool
    is useful for sending commands to most drives attached to a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hdparm tool operates by sending requests to the OS disk drivers (using
    ioctls) to retrieve information about the disk. From a forensics perspective,
    a number of items may be of interest or useful to document:'
  prefs: []
  type: TYPE_NORMAL
- en: • Details about the drive geometry (physical and logical)
  prefs: []
  type: TYPE_NORMAL
- en: • The disk’s supported standards, features, and capabilities
  prefs: []
  type: TYPE_NORMAL
- en: • States and flags related to the drive configuration
  prefs: []
  type: TYPE_NORMAL
- en: • DCO and HPA information
  prefs: []
  type: TYPE_NORMAL
- en: • Security information
  prefs: []
  type: TYPE_NORMAL
- en: • Vendor information, such as make, model, and serial number
  prefs: []
  type: TYPE_NORMAL
- en: • The WWN device identifier (if it exists)
  prefs: []
  type: TYPE_NORMAL
- en: • Time needed for secure erase (for most disks, this is roughly the acquisition
    time)
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information about hdparm’s features, see the hdparm(8) manual
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how to use hdparm to get an overview of the disk
    using the `-I` flag together with the raw disk device. The listing is annotated
    with comments relevant to forensic investigators.
  prefs: []
  type: TYPE_NORMAL
- en: The output begins with documenting information about the drive, including manufacturer,
    model, serial number, and the standards with which it is compliant. Also in the
    output are various drive parameters, such as physical and logical sector size,
    number of sectors, form factor, and other physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The next section of the output describes the features available on a drive,
    and the star (`[*]`) indicates if a feature is currently enabled. (To understand
    vendor-specific features, you might need additional proprietary documentation.)
    This is useful when you’re preparing for a forensic acquisition, because it indicates
    the status of security feature sets and other things like the DCO (`Device Configuration
    Overlay feature set`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next section of the hdparm output provides more detail about the currently
    active security features, which are important when you’re determining if a drive
    is locked or encrypted. The time needed for a secure erase is also a rough estimate
    of how long an acquisition might take (if the subject drive is the performance
    bottleneck).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The final section of the hdparm output displays the WWN again, but this time
    it’s broken down into the NAA (which describes the rest of the WWN), the IEEE
    OUI assigned vendor ID, and the rest of the WWN (which isunique to the drive).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The hdparm output contains a number of items of interest to forensic investigators,
    either for documentation or as information for further analysis. To include the
    entire output of `hdparm -I` in a forensic report, you can redirect it to a text
    file.
  prefs: []
  type: TYPE_NORMAL
- en: A similar tool for querying SCSI drives is sdparm, which you can use to access
    SCSI mode pages. Running `sdparm` with the flags `-a -l` retrieves a verbose list
    of disk parameters. A more concise query using `sdparm -i` can extract the Vital
    Product Data (VPD), which provides unique identifying information about the make,
    model, and serial number of SCSI and SAS drives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extract SMART Data with smartctl***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'SMART was developed in the early 1990s to help monitor hard disks and predict
    failures. It was added to the SCSI-3 standard in 1995(SCSI-3 standard: X3T10/94-190
    Rev 4) and the ATA-3 standard in 1997 (ATA-3 standard: X3.298-1997). Because certain
    details about the disk hardware may be of value in forensic investigations, in
    this section, you’ll learn several techniques to extract SMART information about
    the disk hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: The `smartctl` command is part of the smartmontools package and provides access
    to the SMART interface built into nearly all modern hard drives. The `smartctl`
    command queries attached ATA, SATA, SAS, and SCSI hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'SMART provides a number of variables and statistics about a disk, some of which
    could be of interest to a forensic investigator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: • Statistics about errors on the disk and the overall health of the disk
  prefs: []
  type: TYPE_NORMAL
- en: • Number of times the disk was powered on
  prefs: []
  type: TYPE_NORMAL
- en: • Number of hours the disk was in operation
  prefs: []
  type: TYPE_NORMAL
- en: • Number of bytes read and written (often expressed in gigabytes)
  prefs: []
  type: TYPE_NORMAL
- en: • Various SMART logs (temperature history, and so on)^([2](footnote.xhtml#fn23))
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows SMART data requested from a drive. The listing is
    annotated with comments relevant to forensic investigators.
  prefs: []
  type: TYPE_NORMAL
- en: The `-x` flag instructs smartctl to print all available information. The first
    block of output is the information section, which provides unique identifying
    information about the drive. You can also retrieve most of this information using
    other tools, such as hdparm, as shown in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following SMART data section shows the health of the drive and the results
    of self-tests. An unhealthy drive is an early warning of possible acquisition
    issues. Additional SMART capabilities are then listed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The next section provides more statistics about the drive. Of possible forensic
    interest here are statistics on the history of the drive usage; for example, the
    cumulative number of hours the drive has been powered on (`Power_On_Hours`) and
    how many times the drive has been powered up (`Power_Cycle_Count`). Both attributes
    may correlate with the PC from where they were taken. The total logical block
    addresses (LBAs) read and written indicates the drive volume usage in the past.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next section is the log directory, which describes the SMART logs available
    on the drive. The logs are included in the `smartctl -x` output with repeating
    entries removed (“skipped”). Some of these logs may be of interest in a forensic
    investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The next section of log information displays the results of self-tests. Failed
    self-tests are an early warning that the acquisition could have issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next output block describes a drive’s temperature statistics. This information
    could be useful to monitor during the acquisition process. For investigation purposes,
    the minimum and maximum temperatures reached during the drive’s lifetime might
    be of interest if correlated with environ-mental factors linked to a suspect’s
    PC. Vendor-specific SMART data is not part of the generic SMART standard, and
    you may need additional proprietary documentation to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Some SMART-capable drives maintain a log of temperature history. You can calculate
    the history from the interval multiplied by the history size. In this example,
    478 minutes are roughly 8 hours of temperature data. Some disks have a temperature-logging
    interval set much higher (one hour or more). The temperature-logging interval
    is potentially useful for investigations: if a disk were seized immediately after
    a crime, known temperature variations might be correlated with the disk temperature
    record.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The final section of output in this example shows statistics of physical errors.
    It can be useful to compare these statistics with values during or at the end
    of an acquisition to ensure no physical errors arose during the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Other SMART logs might exist depending on the drive vendor. Consult the smartctl(8)
    manual page for more information about additional flags and queries that you can
    send to attached subject drives.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable Access to Hidden Sectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forensic literature often includes handling the HPA and DCO as part of the imaging
    process. Indeed, some imaging software has the capability to detect and remove
    these hidden areas at acquisition time. This book positions the detection and
    removal of the HPA/DCO as part of the preparation process, not the actual imaging.
    There is no special technique to image these hidden areas once they’ve been made
    accessible. They’re simply disk sectors protected by drive configuration parameters.
    It is a simple preparatory step to make them available for a subsequent imaging
    process. Removing the HPA or DCO modifies the drive’s configuration, but it does
    not modify its contents.^([3](footnote.xhtml#fn24))
  prefs: []
  type: TYPE_NORMAL
- en: This section also covers drive maintenance sectors and service areas on a disk,
    but this topic is mentioned only briefly, because these areas are not easily accessible
    using common open source tools.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remove a DCO***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The DCO was developed to allow PC system manufacturers to make different drive
    models appear to have the same features. Using a DCO, certain features can be
    disabled, and the capacity of a drive (number of usable sectors) can be reduced
    to fit a vendor’s requirements. Identifying and removing the DCO is standard forensic
    practice when you’re analyzing a suspect drive.
  prefs: []
  type: TYPE_NORMAL
- en: The DCO is a general configuration overlay, and multiple features can be overridden.
    It does not only refer to the number of sectors on a drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two hdparm commands can determine if a DCO exists and provide the number of
    real sectors available. The first command determines if the drive has the DCO
    feature set enabled. In this example, the current size of the disk is reported
    to be 474GB or 926773168 sectors (512-byte sector size) and the asterisk (`[*]`)
    next to `Device Configuration Overlay feature set` indicates it is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command specifically queries for the features modified by a DCO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, “Real max sectors” is 976773168, which is 25GB less than the
    reported size, indicating the existence of a DCO. The reported size of 474GB is
    also a mismatch to the 500GB label on the physical drive. You can confirm the
    expected number of sectors by checking the drive model number with the vendor’s
    product documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having confirmed the existence of a DCO using hdparm, you can use the same
    command to remove it. First, run `hdparm` to ensure the drive configuration is
    not locked or frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some BIOSes or OSes will issue an ATA command to freeze the DCO configuration
    during boot to prevent malicious changes. In this case, hot plugging the drive
    power cable after booting should cause the drive to spin up in an unfrozen state.^([4](footnote.xhtml#fn25))
    Many USB bridges automatically spin up an attached disk in an unfrozen state.
    If the drive is locked, refer to “[Identify and Unlock ATA Password-Protected
    Disks](ch05.xhtml#ch05lev2sec11)” on [page 126](ch05.xhtml#page_126).
  prefs: []
  type: TYPE_NORMAL
- en: Once the drive is ready, you can send the appropriate ATA command to reset the
    DCO, making the additional hidden sectors available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply running the `hdparm` command with the `--dco-restore` option will do
    nothing but generate a warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the instructions, and including the `--yes-i-know-what-i-am-doing`
    flag, you can remove the DCO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now when you run the `hdparm -I` command again, the full sectors will be revealed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now you can acquire the drive or analyze it with forensic tools. It’s important
    to note the DCO hidden area’s exact sector offset, which will be useful when you
    want to extract only the DCO sectors for separate analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the DCO using `hdparm` can be tricky. Read the hdparm(8) manual page
    if a particular drive is causing problems with the removal commands.
  prefs: []
  type: TYPE_NORMAL
- en: The tableau-parm tool has an `-r` flag that should remove the DCO (and possibly
    the HPA) from the drive.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remove an HPA***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The HPA was developed to allow PC system manufacturers to store data in a way
    that is normally inaccessible to a customer. Examples of HPA uses include diagnostic
    tools, recovery partitions, and so on. These special areas are often activated
    with BIOS hotkeys during startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can detect the existence of an HPA using a single `hdparm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here `HPA is enabled` indicates that an HPA exists. The `max sectors` provides
    the visible sector count followed by the real sector count. In this example, subtracting
    the two sector counts reveals a 50GB difference, which is the host protected area.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can temporarily remove the HPA using the same command (as with the DCO
    removal, a warning message appears, and you need to use the `--yes-i-know-what-i-am-doing`
    flag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this command is only temporary; the original HPA will be in place
    next time you cycle the drive’s power. To make the change permanent, add `p` to
    the sector count number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The HPA is now removed, and you can acquire the drive or analyze it with forensic
    tools. It’s important to note the HPA hidden area’s exact sector offset, which
    will be useful when you want to extract only the HPA sectors for separate analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the HPA with hdparm can be tricky. Read the hdparm(8) manual page if
    a particular drive is causing problems with the removal commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, the Sleuth Kit forensic suite had two utilities to detect and temporarily
    remove the HPA: disk_stat and disk_sreset. These were removed in 2009 because
    other tools, such as hdparm, included the same features.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Drive Service Area Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hard disk drives need to store information such as SMART logs, ATA passwords,
    bad sector lists, firmware, and other persistent information. This information
    is typically stored on the disk platters in reserved, user-inaccessible sectors
    called the *system area* (also known as the *service area*, *negative sectors*,
    or *maintenance sectors*). Access to this area is done through proprietary vendor
    commands, which are usually not public.
  prefs: []
  type: TYPE_NORMAL
- en: There is no common systematic approach to access a disk’s system areas. Each
    disk manufacturer implements system areas differently, there are no industry standards,
    and there are few publicly available tools. Some specialized commercial tools
    exist, such as Ace Laboratory’s PC-3000 (*[http://www.acelaboratory.com/catalog/](http://www.acelaboratory.com/catalog/)*)
    or Atola Insight Forensic (*[http://www.atola.com/products/insight/supported-drives.html](http://www.atola.com/products/insight/supported-drives.html)*),
    which can access service areas of many disks.^([5](footnote.xhtml#fn26), [6](footnote.xhtml#fn27))
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it’s possible to bypass the standard SATA, USB, or SAS interfaces
    and access storage media using debug or diagnostic ports built into the drive
    electronics. These interfaces may use serial RS-232/TTL, JTAG for chip access,^([7](footnote.xhtml#fn28))
    or undocumented vendor proprietary commands over the regular drive interface.
    Media access in this manner is not standard across manufacturers or even across
    drives from the same manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: For illustration purposes, the following example shows reading information over
    a serial interface on a Seagate Barracuda ST500DM002 drive. The drive has a serial
    port next to the SATA data plug and can be accessed with a USB 3V TTL cable. Standard
    serial terminal emulation software such as the Linux `cu` (connect UNIX) command
    is used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch5fig1) shows a photo of the USB cable connected to
    the pin block at the back of the drive.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Serial port access to disk firmware*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Warning:** This method should not be used without specialized training or
    tools. There is a risk of physically damaging the disk beyond repair.*'
  prefs: []
  type: TYPE_NORMAL
- en: After connecting a terminal and powering on the drive, a boot message is displayed.
    Entering CTRL-Z puts the drive in diagnostic mode with a command prompt from the
    drive firmware (similar to UNIX terminals or analog modems).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From thisdiagnostic interface, detailed underlying information about the disk
    can be retrieved. In the following example, a Level 2 `x` command reveals the
    internal physical drive geometry and partitioning for User and System areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Diagnostic interfaces, such as this one, can provide access to disk sectors
    in the system areas and other information that is not otherwise accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Online forums exist that discuss low-level disk access and recovery, for example,
    HDDGURU (*[http://forum.hddguru.com/index.php](http://forum.hddguru.com/index.php)*)
    and The HDD Oracle (*[http://www.hddoracle.com/index.php](http://www.hddoracle.com/index.php)*).
  prefs: []
  type: TYPE_NORMAL
- en: Methods of accessing the underlying areas of SSD or flash storage media include
    the physical removal (desoldering) of memory chips, sometimes called *chip-off*.
    The memory contents from these chips can then be extracted and reconstructed into
    readable blocks of data.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices (Internet-of-Things, mobile devices, and so on) may have a JTAG
    interface providing access to memory contents. JTAG is a well-documented standard
    and can be applied in a forensic context to extract data (see *[http://www.evidencemagazine.com/index.php?option=com_content&task=view&id=922](http://www.evidencemagazine.com/index.php?option=com_content&task=view&id=922)*).
  prefs: []
  type: TYPE_NORMAL
- en: Covering these techniques in more depth is beyond the scope of this book. I’ve
    mentioned JTAG interfaces and Serial access to disks for illustration purposes
    to make you aware that such techniques exist in the forensics industry.
  prefs: []
  type: TYPE_NORMAL
- en: '**ATA Password Security and Self-Encrypting Drives**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers the standard security features implemented by the disk vendors.
    These features include drive locking, password protection, self-encrypting drives,
    and other security mechanisms. Although some of the features discussed here are
    not widely used, they are still important to understand in a professional forensic
    lab setting.
  prefs: []
  type: TYPE_NORMAL
- en: Password recovery techniques are not described in detail here. The examples
    demonstrate how to attach password-protected media to an acquisition host in preparation
    for imaging. It is assumed that passwords are already known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods of acquiring passwords are beyond the scope of this book, but recovery
    techniques may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Brute force, exhaustively attempting multiple passwords until the correct
    one is found.
  prefs: []
  type: TYPE_NORMAL
- en: • Finding passwords hidden or stored in an accessible location.
  prefs: []
  type: TYPE_NORMAL
- en: • Knowledge of password reuse across different accounts or devices. Recovery
    from one location provides access to all.
  prefs: []
  type: TYPE_NORMAL
- en: • Depending on the jurisdiction, a person may be legally compelled to provide
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: • The password may be volunteered by a friendly or cooperative owner (the victim
    perhaps) or a cooperating accomplice.
  prefs: []
  type: TYPE_NORMAL
- en: • Enterprise IT environments may have key escrow or backups in place.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify and Unlock ATA Password-Protected Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ATA/ATAPI commands (*[http://www.t13.org/](http://www.t13.org/)*) specify
    a security feature set that restricts access to a disk using passwords. When this
    feature is enabled, the firmware prevents the execution of certain ATA commands,
    including access to content, until the required password is provided. This is
    only an access control feature and doesn’t use encryption to protect data on the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hdparm tool can determine if a disk has the security feature set enabled.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Commands/features:` information indicates the `Security Mode feature set`
    exists and is enabled, and the `Security:` information also confirms the feature
    is supported and enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If `Security:` has `enabled` listed, a user password has been set, and the drive
    will be locked on boot. If the drive is locked, as in the preceding example, access
    to the drive is prevented until a correct password is provided. The OS may generate
    a device error or failed command error as it tries to access the disk. The T13
    standard outlines which commands are allowed when a disk is locked. Access to
    a number of commands, including to query SMART information, is still possible
    when a disk is locked.
  prefs: []
  type: TYPE_NORMAL
- en: Two passwords can be set, user and master. If the user password is set, security
    is enabled (as shown in the preceding example). Setting the master password alone
    does not enable security.
  prefs: []
  type: TYPE_NORMAL
- en: If a master password has never been set (it may still have a factory default
    password set), the `Master password revision code` will be set to 65534\. The
    first time the master password is set, this value is set to 1 and incremented
    each time the master password is set again.
  prefs: []
  type: TYPE_NORMAL
- en: Two security levels control how correct passwords behave. The `Security level`
    refers to the `MASTER PASSWORD CAPABILITY` bit in the T13 standard and can be
    “high” or “maximum.” If the security level is set to high, either user or master
    passwords can unlock the drive. If the security level is set to maximum, the master
    password will allow security erase commands but only the user password can unlock
    the drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some PCs might issue a security freeze command after booting to prevent further
    security commands from being sent, even with correct passwords (to prevent malicious
    password-setting attacks). The Security output from hdparm will indicate if a
    drive is frozen. Many USB bridges automatically spin up an attached disk in an
    unfrozen state, but if you still have difficulty, here are several possibilities
    to try:'
  prefs: []
  type: TYPE_NORMAL
- en: • Checking the BIOS for settings to enable/disable the freeze command
  prefs: []
  type: TYPE_NORMAL
- en: • Using a forensic boot CD that prevents freeze commands from being issued
  prefs: []
  type: TYPE_NORMAL
- en: • Attaching the disk to a separate controller card (not built into the mainboard)
  prefs: []
  type: TYPE_NORMAL
- en: • Hot plugging the disk into the system (if supported)
  prefs: []
  type: TYPE_NORMAL
- en: • Using a mainboard that does not issue freeze commands
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the user password and the drive security is not frozen, you can
    unlock the drive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the user password is provided using hdparm, and the master password
    needs to be explicitly specified with an additional command line parameter. If
    you know the master password and the security level is set to high, you can use
    the master password to unlock the drive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If no passwords are known, access to the disk is not possible with regular tools.
    The password information is stored on the service/system areas of a disk and is
    generally not accessible without special hardware or tools. However, several further
    options are available and are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: The master password might be set to a factory default and can be used to gain
    access to the drive (if the security level is set to high and not maximum). You
    can easily find lists of factory default master passwords on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Using brute force to identify either the master or user password is inefficient,
    because the drive must be reset after five failed attempts. However, if you have
    a small set of likely passwords, multiple attempts become feasible and may lead
    to lucky success.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized data recovery companies provide services and hardware tools that
    can recover or reset ATA Security Feature Set passwords from the service areas
    of a disk. Success is not guaranteed for all disks, but data recovery firms often
    list the disks they do support. In some cases, you might have to ship the disk
    to the firm’s laboratory, which may have chain-of-custody implications. See “[Drive
    Service Area Access](ch05.xhtml#ch05lev2sec10)” on [page 122](ch05.xhtml#page_122)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The hard disk vendor may be able to provide assistance to disable or reset the
    ATA password. This will depend on the cooperation of the drive vendor, the ability
    to prove ownership of the disk and its contents, the authority of the requesting
    party, and the motivation for recovering the data.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware and firmware hacks and published methods by researchers may exist that
    provide access for certain hard drive models. The security research community
    is regularly finding innovative ways to access and modify data in hard-to-reach
    places.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify and Unlock Opal Self-Encrypting Drives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Self-encrypting drives (SEDs)* are a form of full-disk encryption (FDE). Unlike
    software-based FDE (TrueCrypt, FileVault, LUKS, and so on) where the OS manages
    the encryption, SEDs have encryption capabilities built directly into the drive
    electronics and firmware. SEDs are OS agnostic and are based on vendor-independent
    standards. The international body responsible for defining the standard is the
    Trusted Computing Group (TCG; *[http://www.trustedcomputinggroup.org/](http://www.trustedcomputinggroup.org/)*).
    The standard is the TCG Storage Security Subsystem Class: Opal, Specification
    Version 2.00.'
  prefs: []
  type: TYPE_NORMAL
- en: This section identifies drives with Opal encryption and describes how appropriate
    keys can be used to unlock the drive. The recovery of encryption keys is outside
    the scope of this book. The examples shown here assume the key is known.
  prefs: []
  type: TYPE_NORMAL
- en: A physical examination of the drive can already indicate if it is an Opal SED.
    The existence of a *Physical Secure ID (PSID)* string printed on the label of
    the drive is shown in [Figure 5-2](ch05.xhtml#ch5fig2). This string is used for
    the Opal RevertSP feature, which generates a new key securely, destroying all
    data and resetting the drive to its original factory state. The PSID cannot be
    queried from the drive and must be physically read or scanned if a QR code exists.
    The existence of a PSID string does not mean the drive is locked and passwords
    are set; it just indicates the drive supports Opal full-disk encryption.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Opal SED PSID*'
  prefs: []
  type: TYPE_NORMAL
- en: Full-disk encryption has a chicken-and-egg problem. If an entire drive is encrypted,
    including the boot sector, how can the system execute the master boot record (MBR)
    and ask for a password or other security credentials? The solution was to implement
    a *shadow MBR* and store it in the system area of a disk (the same place where
    SMART data, bad block lists, and so on are stored). When an Opal disk is in a
    locked state, only the shadow MBR is visible to the host. It is a group of unencrypted
    sectors (can be large— 150MB in size, for example) that is executed as a normal
    MBR (the host is completely unaware that it is using a shadow MBR). This alternate
    boot area can execute code to request a password, access a Trusted Platform Module
    (TPM) chip or smartcard, or get other credentials. Once the disk has been unlocked,
    the proper MBR becomes visible, and a normal boot process can begin.
  prefs: []
  type: TYPE_NORMAL
- en: An open source command line tool was created to manage Opal SED encryption under
    Linux. Originally called msed, it was available at *[https://github.com/r0m30/msed/](https://github.com/r0m30/msed/)*,
    but the tool was recently renamed sedutil-cli and moved to *[https://github.com/Drive-Trust-Alliance/sedutil/](https://github.com/Drive-Trust-Alliance/sedutil/)*.
    This tool is still under development and may not work on all drives. Follow the
    instructions carefully and ensure that `libata.allow_tpm` is enabled in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command scans the local system for all Opal-compliant SED drives.
    Out of four attached drives, one disk is detected as Opal version 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can query the drive to find information about the Opal status, including
    if a disk is encrypted, locked, or has a shadow MBR (all three are shown in this
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Two commands can be issued: one to disable locking and the second to inform
    the disk that the shadow MBR is not needed (MBR is “Done”). In this example, *xxmonkey*
    is the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, a kernel message (dmesg) might show a change in available devices.
    The status in this example now shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The drive is no longer locked, and the shadow MBR is no longer visible. The
    proper MBR and the rest of the decrypted disk are available, and they can be accessed
    with regular forensic tools. Now the partition table of a Linux installation becomes
    visible, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A locked drive that has no shadow MBR enabled will produce multiple error messages
    in the kernel dmesg output.
  prefs: []
  type: TYPE_NORMAL
- en: The simple example described in this section was provided for illustration purposes
    only. Some Opal disks may behave differently with this tool. In real scenarios,
    the key might not be a simple password but instead be tied to the TPM or some
    other enterprise security mechanism. If the wrong commands are given in this situation,
    the data on the disk can be irrevocably destroyed (in an instant if the key is
    destroyed).
  prefs: []
  type: TYPE_NORMAL
- en: From a forensics perspective, it may be useful to image the shadow MBR for analysis
    as well. It could contain interesting artifacts from the time the disk encryption
    was set up. It is also conceivable that data could be hidden in the shadow MBR
    region of Opal-capable drives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Encrypted Flash Thumb Drives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: USB thumb drives sold as “secure” devices often come with a proprietary software
    encryption solution provided by the vendor. Some drives offer OS-independent encryption
    with authentication using keypads, fingerprint readers, or smartcards (see [Figure
    5-3](ch05.xhtml#ch5fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Encrypted USB sticks*'
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary solutions might not have a compatible tool to manage access, making
    it difficult to acquire decrypted data with Linux. Devices with an onboard authentication
    mechanism should appear as a normal USB storage device after authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Secure thumb drives that are locked may behave differently when attached to
    a host. Some don’t provide any indication that they’ve been plugged into the host.
    Some appear as a removable media device without media (like a memory card reader).
    Some will appear as a CD-ROM and have software available to run or install, which
    manages the drive.
  prefs: []
  type: TYPE_NORMAL
- en: Larger hardware-encrypted external drives also exist and may require a pin to
    unlock. An example of such a drive is described in [Chapter 7](ch07.xhtml#ch07)
    (see [Figure 7-1](ch07.xhtml#ch7fig1) on [page 216](ch07.xhtml#page_216)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Attach Removable Media**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers the attachment of devices that use removable storage media.
    The most common examples of removable media are optical discs, memory cards, and
    magnetic tapes. In a way, attaching removable storage media to an acquisition
    host occurs twice. First the device electronics are attached, and then in an additional
    step, the removable media is inserted. Let’s begin with a discussion on optical
    media drives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Optical Media Drives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Optical drives are typically attached internally via SATA or externally via
    USB. The drives appear in the Linux device tree but without media. Running forensic
    commands on an empty drive produces obvious results, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Two useful commands provide information about the attached drive and inserted
    discs. The `cd-drive` command provides details about an attached optical drive
    (internal or external), including various features, supported media, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When you insert a disc into the drive, you can retrieve information about the
    media using the `cd-info` command. The result includes the mode, format, and information
    about the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can eject the optical media using the `eject` shell command.
  prefs: []
  type: TYPE_NORMAL
- en: Using write blockers on optical drives is unnecessary. No timestamps are updated
    simply by accessing files on a disc. Modifying an optical disc requires explicit
    burn instructions, reducing the risk of accidental modification.
  prefs: []
  type: TYPE_NORMAL
- en: '***Magnetic Tape Drives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can determine a list of attached tape drives using the lshw tool and the
    tape class. The output provides information about the drive vendor, serial number,
    and device information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, two tape drives are found (LTO and DAT):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Magnetic tape drives are typically SCSI devices, which you can query using
    standard SCSI commands. The standard tool for controlling tapes is mt, which provides
    information about the drive status, controls the position of the tape, and ejects
    the media. The mt tool can provide basic information about the tape, but the tapeinfo
    tool is more comprehensive. In this example, the mt and tapeinfo tools query the
    status of an LTO tape drive with a loaded tape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The tape head is positioned at the second file on the tape (file 1 is after
    file 0). The block offset and file offset are useful when you’re forensically
    acquiring individual files from a tape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using mt, you can rewind tapes and take them offline (eject them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When a tape device is attached to a Linux system, a number of corresponding
    devices are created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `st*` devices auto-rewind the tape after each command (which is not always
    desired), and the `nst*` devices are the nonrewinding devices. The `a`, `l`, and
    `m` characters represent the same device but with different characteristics (block
    size, compression). When you’re performing a forensic acquisition, you should
    use the `nst[*]` devices (without an additional `a`, `l`, or `m` character).
  prefs: []
  type: TYPE_NORMAL
- en: '***Memory Cards***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Memory cards typically attach to a host using a USB adapter with multiple slots
    for different types of memory cards. When attached, the adapter creates a removable
    SCSI device for each slot (even when the slots are empty). This behavior can be
    observed in the following dmesg output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you insert media into the slots, the media is made available as a USB mass
    storage device with a linear sequence of “sectors,” which you can forensically
    acquire. Continuing on from the previous example, a memory card has now been inserted
    into a slot of the card reader and appears as block device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Hardware-querying tools, such as hdparm and smartctl, may produce unreliable
    results, because memory cards don’t have the ATA features of more complex drives
    with dedicated drive circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attach Other Storage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes storage media is attached to a forensic acquisition host and behaves
    in a unique way. In particular, it is useful to know about special behavior with
    portable devices, Apple computer systems, and NVME drives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Apple Target Disk Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TDM allows Apple computers with OpenBoot firmware or newer firmware to boot
    into a state where the Mac system appears as an external disk enclosure and the
    internal disks are available as SCSI target devices. Earlier TDM implementations
    used the FireWire bus but have since moved to Thunderbolt. You activate this mode
    by holding down the T key while powering on the Apple computer.
  prefs: []
  type: TYPE_NORMAL
- en: A Linux machine without a Thunderbolt adapter can use FireWire to achieve the
    same result with an adapter. [Figure 5-4](ch05.xhtml#ch5fig4) shows a photo of
    a Thunderbolt-to-FireWire adapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Thunderbolt to Firewire adapter*'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to boot the Apple device (while holding the T key) with the Thunderbolt-to-FireWire
    adapter already plugged in; otherwise, the Apple firmware will not use the FireWire
    adapter for the target device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows dmesg output of an Apple notebook in TDM that is
    connected to a Linux machine using a Thunderbolt to FireWire adapter (Thunderbolt
    on the Apple; FireWire on the Linux machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: PC-based Linux systems with Thunderbolt ports are not common, and Linux kernel
    support is still under development. As an alternative, you can boot recent Apple
    computers with a forensic boot CD/USB device and acquire them to a locally attached
    evidence drive.
  prefs: []
  type: TYPE_NORMAL
- en: '***NVME SSDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NVME drives compete with SATA Express in the way they attach directly to a PCI
    Express bus. As of this writing, hardware write blockers for NVME drives are very
    new. There are hot-pluggable USB bridges for NVME and SATA Express drives from
    Tableau (Guidance Software). For illustration purposes, the examples shown here
    use an NVME device directly attached to a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the nvme tool from the nvme-cli software package to list the attached
    NVME devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also check each NVME drive for multiple namespaces by using the
    nvme tool. In this example, only a single namespace exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Multiple namespaces may need to be acquired individually. This is a fundamental
    difference from other drives where a single drive is viewed as a linear set of
    sectors, which you can acquire in a single pass. NVME drives with multiple namespaces
    will likely need special consideration.^([8](footnote.xhtml#fn29))
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the NVME standard was created from scratch without
    backward compatibility with SCSI or ATA standards (AHCI, and so on). It has its
    own command set and operates independently from other disk systems. For this reason,
    some tools may not work as expected with NVME hardware. Any forensic tool operating
    directly on low-level device drivers, such as SATA or SAS, will not work with
    NVME. However, if forensic tools operate on the virtual block layer, they should
    continue to work normally. In addition, PCI forensic write blockers may act as
    a bridge and make the device appear as a SCSI device. For example, here the Sleuth
    Kit mmls tool is used on an NVME drive attached to the examination host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the device is `nvme1n1` and not simply `nvme1`. The namespace of
    the drive must be specified when you’re using commands on NVME drives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other drives, NVME drives have a SMART log, but you can’t access it
    with current versions of smartctl (as of this writing). However, you can use the
    nvme tool to extract the SMART log as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The nvme tool has a number of features for querying attached NVME drives. See
    the nvme(1) manual page or visit *[https://github.com/linux-nvme/](https://github.com/linux-nvme/)*
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, NVME drives are an emerging technology. Because they have
    numerous benefits in terms of performance and efficiency, they may become more
    popular in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Devices with Block or Character Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can image any device that is detected as a block device by the Linux kernel.
    Some devices will appear as a block device the moment they are attached to the
    host system. For example, many generic MP3/music players, cameras, and other mobile
    devices behave in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices need to be switched into a different “disk” mode before they can
    become accessible as a block device. Often, you can select this mode from the
    device’s user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Some USB devices are multifunctional and may provide other USB modes in addition
    to storage. You might need to switch the mode on these devices to usb-storage
    before acquiring them. A Linux tool called usb_modeswitch is able to query some
    multifunction USB devices and switch modes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned to attach a subject drive to an acquisition machine
    and positively identify the device for imaging. You learned different aspects
    of PC hardware (USB, PCI, block devices, and so on), how to query your acquisition
    system, and how to query your drive for firmware and SMART information. I demonstrated
    the removal of the HPA and DCO as well as various types of security built into
    the hardware of some drives. You are now equipped with the knowledge necessary
    to perform a forensic acquisition, which will be the focus of [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
