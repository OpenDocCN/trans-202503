<html><head></head><body>
<h2 class="h" id="ch02"><span epub:type="pagebreak" id="page_25" class="calibre1"/><strong class="calibre2"><span class="big">2</span><br class="calibre3"/>LANGUAGE BASICS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Learning another language is not only learning different words for the same things, but learning another way to think about things.</em></p>
<p class="center1"><em class="calibre11">—</em>Flora Lewis</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Sometimes people new to programming ask why there are so many computer languages. They all have different syntaxes. Some use braces and semicolons, like C and JavaScript; some use whitespace, like Python; some are notorious for a proliferation of parentheses, like the Lisp family; and some use keywords, like Julia.</p>
<p class="indent">However, differences in syntax are not the real reason. With experience, variations in language punctuation become trivialities. It’s also true that some languages are faster than others, or have different demands on memory, although these are often properties of implementations rather than the languages themselves, but performance is not the real reason either.</p>
<p class="indent">The fundamental reason for the persistence of different languages and language families is that they are based on different ideas. Each language represents a unique conceptual framework in which to express computations. When we write a program, we are not simply telling a machine what to do. If that were the case, we would all write in the machine code into which our programs are ultimately translated. Instead, we are telling <em class="calibre11">people</em>, <span epub:type="pagebreak" id="page_26"/>including ourselves, about a computation. Computer languages are human languages.</p>
<p class="indent">As you begin your journey through Julia, it’s important to keep this in mind. You are not learning merely a collection of incantations for getting the computer to do what you want. You are learning a way of thinking: a set of concepts that you can use to organize computational ideas. If you master these ideas, your programs will do what you expect, will perform well, and will be clear to others and even to your future self.</p>
<p class="indent">That being said, most of these overarching ideas will come out in the application chapters in <a href="part2.xhtml" class="calibre10">Part II</a>. In this chapter, we cover the nitty-gritty: the bricks and stones out of which you will build your cathedrals.</p>
<p class="indent">These elements are the blocks with which you structure your Julia programs—functions, loops, and decisions—and the data types they interact with, such as strings, various kinds of numbers, and collections. After you finish this chapter, you will know enough about Julia to write your first programs.</p>
<h3 class="h2" id="ch02lev1"><strong class="calibre2">The Syntax: Data Types, Expressions, and Blocks</strong></h3>
<p class="noindent">In this section we’ll learn about the fundamentals of Julia syntax for creating the basic structures used in almost every Julia program. We’ll also be introduced to our first Julia data types.</p>
<p class="indent">Throughout this chapter I’ll refer to the REPL, but these references apply equally well to any interactive environment for Julia, such as Pluto or VS Code.</p>
<h4 class="h3" id="ch02lev1sec1"><strong class="calibre2"><em class="calibre4">Types of Numbers</em></strong></h4>
<p class="noindent">All values in Julia have a <em class="calibre11">type</em>, just as in almost all programming languages. One of the basic types is that of a number, but, just as in mathematics, there are different types of numbers. In math we have positive and negative numbers, integers and real numbers, and more exotic varieties such as complex numbers and quaternions. Positive integers, or counting numbers, have been with us since before recorded history, but somebody had to invent all the other kinds of numbers. In “User-Defined Types” on <a href="ch08.xhtml#ch08lev3" class="calibre10">page 234</a>, you’ll learn how you can invent your own kinds of Julia numbers if you want to, but for now, let’s look at some of the built-in types.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Perhaps more than any other chapter in this book, it is important to read this one with the Julia REPL open and try things out as you read about them. Experiment with variations of the examples in the chapter until you feel comfortable with the syntax. You will use everything in this chapter repeatedly in all your programs, so making these details second nature now will be helpful.</em></p>
</div>
<p class="indent">If you type a number without a decimal point into the REPL and press <small class="calibre5">RETURN</small> or <small class="calibre5">ENTER</small>, Julia will give you the same number back. A number by itself is an <em class="calibre11">expression</em>, which means something that returns a result. Since the result of evaluating a plain number is the number itself, that’s what you <span epub:type="pagebreak" id="page_27"/>get. These whole numbers, by default, are given the type of <code>Int64</code>, which just means an integer that takes up 64 bits of storage. (I’m assuming a 64-bit system, which is a pretty safe assumption these days. If you are using a 32-bit system, replace <code>Int64</code> with <code>Int32</code> throughout this chapter.)</p>
<p class="indent">A number with a decimal point has the type <code>Float64</code>. The numbers 1 and 1.0 may have the same values, but they are different to the computer. The first is an <code>Int64</code>, and the second is a <code>Float64</code>. This difference has various repercussions that will appear in our later work.</p>
<p class="indent">Since Julia is intended, among other things, for scientific calculation, naturally it can deal with complex numbers as well. The syntax for entering complex numbers uses <code>im</code> for the imaginary unit (the square root of –1). So to enter the number 3 + 4<em class="calibre11">i</em>, you write <code>3 + 4im</code>. The type of that number is called <code>Complex{Int64}</code>, because the numerical parts happen to be integers. The type of <code>3.4 + 1.1im</code> is called <code>Complex{Float64}</code>. This notation means that it’s a <code>Complex</code> type that has <code>Float64</code> parts.</p>
<p class="indent">You can write very big or small numbers using the usual computer version of scientific notation: <code>6.02e23</code> means 6<em class="calibre11">.</em>02 × 10<sup class="calibre23">23</sup>. Numbers written in this way are <code>Float64</code>s, even if you write the mantissa as an integer. The exponent must be an integer, and if you prefer, you can use an uppercase <span class="codeitalic1">E</span>.</p>
<p class="indent">Julia will rewrite your entry in “proper” scientific notation. For example, if you enter <code>1234e19</code> in the REPL, it will repeat the value as <code>1.234e22</code>. And apparently, it prefers the lowercase <code>e</code>.</p>
<p class="indent">There are a few other numerical types, such as the unsigned integer <code>UInt64</code>, but this is enough for now. We’ll go deeper into the type system in <a href="ch08.xhtml" class="calibre10">Chapter 8</a>.</p>
<h4 class="h3" id="ch02lev1sec2"><strong class="calibre2"><em class="calibre4">Operations and Expressions</em></strong></h4>
<p class="noindent">Addition, subtraction, and multiplication work as you would expect on all these types of numbers. The order of operations is the same as in mathematics and is similarly overridden using parentheses.</p>
<p class="indent">Julia performs obvious <em class="calibre11">type promotion</em> when needed. The expression <code>1 + 1</code> involves only integers, and the result will be the integer <code>2</code>; there is no reason to return any other type. But the expression <code>1.0 + 1</code> involves a floating-point number, so it will return the <code>Float64</code> result <code>2.0</code>.</p>
<p class="indent">Try some arithmetic in the REPL involving operands of various types, including complex numbers, to make sure you understand how promotion works. Integers are promoted to floats, and both of those are promoted to complex numbers, as needed.</p>
<h5 class="h4" id="ch02sec1sec1"><strong class="calibre2">Division and Rational Numbers</strong></h5>
<p class="noindent">Julia has <em class="calibre11">three</em> kinds of division. Every language has to decide what to do about expressions such as <code>1/2</code>. The problem is that both operands are integers, but the result is not. Some languages, such as Fortran and Python 2, evaluate that expression to be zero, because that is the result of taking the integer part before the decimal point in the answer. Other languages will promote the result into a float and return <code>0.5</code>; that’s what Julia does.</p>
<p class="indent"><span epub:type="pagebreak" id="page_28"/>If you want a form of division that behaves like Fortran, you can use the division symbol (<code>÷</code>): <code>1</code> ÷ <code>2</code> gives <code>0</code> and <code>4</code> ÷<code>3</code> gives <code>1</code>. To enter this operator in the REPL, enter <span class="codestrong1">\div</span> followed by <small class="calibre5">TAB</small> (see “Unicode Characters” on <a href="ch01.xhtml#ch01sec1sec7" class="calibre10">page 13</a>).</p>
<p class="indent">The third form of division uses the <code>//</code> operator to define <code>Rational</code> numbers, which are ratios of two integers. Using this data type, you can perform exact arithmetic on rationals without converting the results into floats. For example, the expression <code>1//2 + 1//3</code> evaluates to <code>5//6</code>. Julia reduces rational numbers to their simplest form, so if you enter <code>4//6</code> in the REPL, it will return the result <code>2//3</code>.</p>
<p class="indent">What do you think you get if you enter <code>1//2 + 1//2</code> in the REPL? If you tried it, you may have been surprised to find the result printed as <code>1//1</code> rather than simply <code>1</code>. The result of expressions involving only <code>Rational</code> numbers is a <code>Rational</code> number. If instead you evaluate <code>1//2 + 0.5</code>, you get the <code>Float64</code> number <code>1.0</code>.</p>
<h5 class="h4" id="ch02sec1sec2"><strong class="calibre2">Exponentiation and Infinities</strong></h5>
<p class="noindent">To raise a number to a power, use the <code>^</code> operator. Here are the results of exponentiation of various types of numbers:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">2^3</span>
8

julia&gt; <span class="codestrong">2^0.5</span>
1.4142135623730951

julia&gt; <span class="codestrong">2^-1</span>
0.5

julia&gt; <span class="codestrong">(1 + im)^2</span>
0 + 2im

julia&gt; <span class="codestrong">(1 + im)^(1 + im)</span>
0.2739572538301211 + 0.5837007587586147im

julia&gt; <span class="codestrong">0^-1</span>
Inf

julia&gt; <span class="codestrong">(0//1)^-1</span>
1//0</pre>
<p class="indent">All of those results should be as expected, but the last two infinite results merit some discussion. Division by zero, as in the next-to-last expression shown or the equivalent <code>1/0</code>, evaluates to <code>Inf</code>, which has the <code>Float64</code> data type. The <code>Rational</code> number <code>1//0</code> is also infinite, but it has the <code>Rational</code> data type. It behaves as an infinity should: since adding a finite number to infinity doesn’t change it, we have <code>1//0 + 1</code> yielding <code>1//0</code>. The type promotion <span epub:type="pagebreak" id="page_29"/>rules still apply, so if, instead, we evaluate <code>1//0 + 1.0</code> we get <code>Inf</code>: still infinity, but the <code>Float64</code> infinity.</p>
<p class="indent">Dividing by infinity gets us zero, as it should. However, we get a <code>Rational</code> zero or a <code>Float64</code> zero, depending on the operands:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1/(1//0)</span>
0//1

julia&gt; <span class="codestrong">1.0/(1//0)</span>
0.0</pre>
<p class="indent">There are other sizes of floating-point numbers, just as there are integers. If we contrived to divide <code>a/b</code> where <code>a</code> had the value 1.0 of type <code>Float32</code> and <code>b</code> had the value 0.0 of the same data type, Julia would return yet another kind of infinity: <code>Inf32</code>. You’ll learn how to make variables contain types of your choosing in “User-Defined Types” on <a href="ch08.xhtml#ch08lev3" class="calibre10">page 234</a>.</p>
<h5 class="h4" id="ch02sec1sec3"><strong class="calibre2">Modular Arithmetic</strong></h5>
<p class="noindent">Another useful operator, <code>%</code>, returns the remainder when dividing its first operand by its second. For example, <code>5 % 2</code> returns <code>1</code>. As with the other arithmetic operators, integers yield an integer and floats yield a floating-point result.</p>
<h5 class="h4" id="ch02sec1sec4"><strong class="calibre2">Chains of Expressions</strong></h5>
<p class="noindent">We’ve briefly seen the use of the semicolon to separate expressions and, in the REPL, to suppress the printing of a result (see <a href="ch01.xhtml#page_11" class="calibre10">page 11</a>). If we have a list of expressions on a line, separated by semicolons, the result of the chain of expressions is the result of the last expression:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">1; 2; 5+3</span>
8</pre>
<p class="indent">We assign values to variables in Julia using the <code>=</code> operator. Since the value of a chain of expressions is the last one, the assignment</p>
<pre class="calibre13">r = (1; 2; 5+3)</pre>
<p class="noindent">results in <code>r</code> having the value 8. If we had omitted the parentheses, <code>r</code> would have been assigned the value 1, because then the assignment <code>r = 1</code> would have been a separate expression.</p>
<h5 class="h4" id="ch02sec1sec5"><strong class="calibre2">Coefficient Syntax</strong></h5>
<p class="noindent">In cases where it is not ambiguous, we can juxtapose a literal number with a variable (or function, as we’ll see later) to signify multiplication. If the juxtaposition creates an ambiguity, Julia will complain, and we must revert to using the <code>*</code> operator.</p>
<p class="indent">Multiplication written this way has one important difference from the use of <code>*</code>. It has a higher operation precedence than the other arithmetic <span epub:type="pagebreak" id="page_30"/>operations, so it is an exception to the usual order of operations. A few examples should make this clear:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">w = 2</span>
2

julia&gt; <span class="codestrong">2w</span>
4

julia&gt; <span class="codestrong">2^2w</span>
16

julia&gt; <span class="codestrong">2^2*w</span>
8

julia&gt; <span class="codestrong">1/2w</span>
0.25

julia&gt; <span class="codestrong">1/2*w</span>
1.0</pre>
<p class="indent">In an expression such as <code>1/2*w</code>, the <code>1/2</code> is calculated first and the result is multiplied by <code>2</code>. But since juxtaposition binds more tightly than explicit arithmetic operators, in the expression <code>1/2w</code>, the <code>2w</code> is calculated first.</p>
<p class="indent">This unusual syntax feature, along with the ability to use Greek letters and other Unicode symbols, helps to make math in code look more like math.</p>
<h5 class="h4" id="ch02sec1sec6"><strong class="calibre2">Expression Blocks</strong></h5>
<p class="noindent">Another way to group expressions together is with a <code>begin...end</code> block. This unit of code starts with the keyword <code>begin</code> and, as do all blocks in Julia, ends with the keyword <code>end</code>. You can enter blocks directly in the REPL. Julia sees that you are defining a block and will not print the prompt until the structure is complete:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">begin</span>
           <span class="codestrong">1</span>
           <span class="codestrong">2</span>
           <span class="codestrong">5 + 3</span>
       <span class="codestrong">end</span>
8


julia&gt;</pre>
<p class="noindent">As with chains of expressions separated by semicolons, the result of this group of expressions is the final one. You can even assign the result of the block to a variable:<span epub:type="pagebreak" id="page_31"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">eight = begin</span>
           <span class="codestrong">1</span>
           <span class="codestrong">2</span>
           <span class="codestrong">5 + 3</span>
       <span class="codestrong">end</span>
8


julia&gt; <span class="codestrong">eight</span>
8</pre>
<p class="indent">The value of an expression is printed by default in the REPL and in other interactive environments such as Pluto. However, if you are running a program stored in a file, you need to use <code>print(expression)</code> to see the value on the terminal.</p>
<h4 class="h3" id="ch02lev1sec3"><strong class="calibre2"><em class="calibre4">Logic</em></strong></h4>
<p class="noindent">Logical values are represented by <code>true</code> and <code>false</code>, which are of type <code>Bool</code>. The important logical operators are logical AND, which is represented by <code>&amp;&amp;</code>, and logical OR, which uses <code>||</code>. These operators are <em class="calibre11">short-circuiting</em>, which means that, going from left to right in an expression, once the final value of an expression can be determined to be <code>true</code> or <code>false</code>, Julia will stop and not evaluate the remainder. For example, in the expression <code>false &amp;&amp; more stuff</code>, as soon as Julia hits the <code>&amp;&amp;</code> operator, it will stop and return <code>false</code>, and never try to evaluate the <code>more stuff</code>. It can do this because the result of this expression must be <code>false</code>, regardless of whether the <code>more stuff</code> is <code>true</code> or <code>false</code>. The programmer must be aware of this and not depend on all parts of a logical expression being evaluated. In an expression such as <code>false &amp;&amp; (cc = 17)</code>, the part after the <code>&amp;&amp;</code> is never even looked at, and, therefore, the assignment never happens.</p>
<p class="indent">If you need to ensure that all parts of a logical expression are evaluated, use the operators <code>&amp;</code> and <code>|</code> instead. These are the bitwise AND and OR operators. They transform numbers, as we’ll see in later chapters, but act as logical operators when applied to <code>Bool</code>s.</p>
<p class="indent"><code>Bool</code> values usually arise from the evaluation of comparisons, which use the operators <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, and <code>===</code>. The negations of the equality tests are <span class="literal"/>!= and !==. The <code>&lt;=</code> operator can also be spelled using the nicer-looking Unicode symbol <code>≤</code>, and <code>&gt;=</code> is synonymous with <code>≥</code>. The expression <code>1 &lt; 5</code> evaluates to <code>true</code>, <code>5 ≥ 5</code> is also <code>true</code>, and so on.</p>
<p class="indent">You may have noticed that there are two equality comparisons. The first, <code>==</code>, compares two values, regardless of type. So <code>5 == 5.0</code> will give us <code>true</code>, even though one number is an integer and the other is a float. The other equality comparison tests whether two values are identical in all respects. It only returns <code>true</code> if no program could be written where it could possibly make a difference which value was used. Therefore, the expression <code>5 === 5.0</code> returns <span epub:type="pagebreak" id="page_32"/><code>false</code> because it is certainly possible for a program to distinguish between integers and floats.</p>
<p class="indent">Comparisons such as <code>&gt;</code> don’t usually need associated negations, because the negation of <code>&gt;</code> is <code>&lt;=</code>. In fact, mathematicians sometimes pronounce that comparison as “not larger than.” If you need to express this as an explicit negation, you’ll have to negate a whole expression using the syntax <code>!(a &gt; b)</code>, at least at the time of writing. Including negated comparisons in the language, which would be written as <code>!&lt;</code>, for example, is under consideration.</p>
<h4 class="h3" id="ch02lev1sec4"><strong class="calibre2"><em class="calibre4">Looping: while Blocks</em></strong></h4>
<p class="noindent">So far we’ve learned about one kind of block: the expression block using <code>begin</code>. A common way to write a <em class="calibre11">loop</em>, or piece of code that is to be repeated until some condition no longer holds, is with another kind of block: the <code>while</code> block. As with all blocks, it is terminated with the <code>end</code> keyword. The condition that terminates the block uses the comparisons that we learned about in the previous section. <a href="ch02.xhtml#ch2lis1" class="calibre10">Listing 2-1</a> is a simple example of a <code>while</code> block in action in the REPL.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">j = 0;</span>

julia&gt; <span class="codestrong">while j &lt; 5</span>
           <span class="codestrong">println(j^2)</span>
           <span class="codestrong">j = j + 1</span>
       <span class="codestrong">end</span>
0
1
4
9
16</pre>
<p class="list" id="ch2lis1"><em class="calibre11">Listing 2-1: Looping in the REPL</em></p>
<p class="indent">The <code>println()</code> function prints its value on a separate line. But why did we have to use this at all, when expressions in the REPL are supposed to be printed automatically?</p>
<p class="indent">The <code>begin</code> blocks return a result, which is the last expression evaluated in the block. But <code>while</code> blocks do not return a result, so there is nothing to print. Whatever we want to see, we have to print explicitly. This is probably a good thing, as loops can evaluate many expressions and are likely to produce a mass of output that we don’t want.</p>
<p class="indent">Notice also the initialization of the <code>j</code> variable before the start of the loop. In the REPL, this creates a <em class="calibre11">global</em> variable that is accessible and modifiable anywhere. After the <code>while</code> loop is finished, the value of <code>j</code> equals 5. This is another behavior that differs between the REPL (and other interactive contexts such as Pluto) and programs in files. (I’ll explain this in more detail in “Scope” on <a href="ch02.xhtml#ch02lev7" class="calibre10">page 52</a>.)<span epub:type="pagebreak" id="page_33"/></p>
<h4 class="h3" id="ch02lev1sec5"><strong class="calibre2"><em class="calibre4"><em class="calibre4">if Blocks</em></em></strong></h4>
<p class="noindent">Julia has conventional conditional evaluation control flow using the logical comparison operators (see “Logic” on <a href="ch02.xhtml#ch02lev1sec3" class="calibre10">page 31</a>) and the keywords <code>if</code>, <code>elseif</code>, and <code>else</code>. You may nest your <code>if</code> blocks at will; each one is terminated with the <code>end</code> keyword.</p>
<p class="indent">Here is a little program that we can run in the REPL to tell us if a number is even or odd:</p>
<pre class="calibre13">if n % 2 === 0
    "That number is even."
elseif n % 2 === 1
    "That number is odd."
else
    "I only deal with integers."
end</pre>
<p class="indent">If, before entering this block, you define <code>n</code> to be a number, it will give you the answer. If <code>n</code> is undefined or something besides a number, you’ll get an error message.</p>
<p class="indent">The <code>===</code> comparison between two integers makes the code refuse to handle any kinds of numbers other than integers. Try the code with, say, <code>n = 6</code> and then with <code>n = 6.0</code> to see what happens.</p>
<p class="indent">Unlike <code>while</code> blocks, <code>if</code> blocks return a result, so an explicit <code>print()</code> statement isn’t needed.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">I’ve used indentation to clarify the structure of the code blocks in the examples through-out this book. Indentation has no syntactic meaning in Julia, but using it is a good habit that makes programs easier to read. You can indent code lines any way you please, or not at all, and it will not affect their execution. Spaces are needed to separate tokens, and newlines are equivalent to semicolons in their role as statement and expression separators. Otherwise, Julia doesn’t care about whitespace in general.</em></p>
</div>
<h3 class="h2" id="ch02lev2"><strong class="calibre2">Arrays</strong></h3>
<p class="noindent">The various numbers that we’ve seen so far are all types that hold single values. Arrays are a class of Julia data types that hold <em class="calibre11">collections</em> of values. Scientific calculation typically involves operations over vectors, matrices, or higher-dimensional arrays, and Julia offers a convenient, concise syntax for manipulating these data structures, as well as excellent array performance.</p>
<p class="indent">Try typing <span class="codestrong1">[1, 2, 3]</span> in the REPL. This is the syntax for creating a one-dimensional array, also called a <em class="calibre11">vector</em>, of three elements. Its data type is called <code>Vector</code>. As before, the REPL will print the expression back, but this time in a different form:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[1, 2, 3]</span>
3-element Vector{Int64}:
 1
 2
 3</pre>
<p class="indent"><span epub:type="pagebreak" id="page_34"/>It also prints, before the value, a bit of information about the kind of value that it’s about to display. Julia routinely does this in the REPL when printing anything more complicated than a simple data type. The information is provided to help you interpret the display. This is useful because, when constructing arrays, Julia may change the types of some of the elements that you included under some circumstances, and it’s good to know about that. Also, the feedback about the shape of the array tells you whether your array operations did what you expected.</p>
<p class="indent">Here is a case where Julia changes some numerical types:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = [4, 5.0, 6]</span>
3-element Vector{Float64}:
 4.0
 5.0
 6.0</pre>
<p class="indent">We give <code>a</code> a value entered as a literal array with three elements: an integer, a float, and another integer. The message from the REPL confirms that this is a <code>3-element Vector</code>, but the notation <code>Vector{Float64}</code> means that the elements of the <code>Vector</code> are all of type <code>Float64</code>. Julia has <em class="calibre11">promoted</em> the integers to floats. We can confirm this by looking at the numbers it prints, which are now all adorned with decimal points. When you initialize an array with a literal expression like the one just shown, Julia will always try to make the types of its elements uniform by promoting values as needed. This helps performance for later calculations using the array. The vertical arrangement of numbers is the way Julia prints vectors when possible. As we’ll see shortly, it has conventions for printing arrays of various shapes.</p>
<p class="indent">Sometimes it’s impossible to promote elements so that they all have the same type. The elements of an array can be anything, including other arrays, as shown in <a href="ch02.xhtml#ch2lis2" class="calibre10">Listing 2-2</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = [4, [5.0, 6], 7]</span>
3-element Vector{Any}:
 4
  [5.0, 6.0]
 7</pre>
<p class="list" id="ch2lis2"><em class="calibre11">Listing 2-2: A heterogeneous array</em></p>
<p class="indent">Julia is still following the printing convention of arranging the elements in a column. The first and third elements are integers, and the second element is a vector. But notice how Julia promoted the integer <code>6</code> in that vector to a float so that all of <em class="calibre11">its</em> elements would have the same type. The message from the REPL tells us that the type of the complete vector is <code>Vector{Any}</code>, which means it’s a <code>Vector</code> that can hold a mixture of any types. This particular array has two elements of type <code>Int64</code> and one element of type <code>Vector{Float64}</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_35"/>We can get the value of, or assign a value to, an element of an array by <em class="calibre11">indexing</em> using square brackets. Array indices in Julia, as in Fortran and many other languages designed with scientific and mathematical work in mind, start at 1.</p>
<p class="indent">In the following example, I’ve entered a few array indexing expressions into the REPL after performing the assignment in <a href="ch02.xhtml#ch2lis2" class="calibre10">Listing 2-2</a>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a[1]</span>
4

julia&gt; <span class="codestrong">a[end]</span>
7

julia&gt; <span class="codestrong">a[2]</span>
2-element Vector{Float64}:
 5.0
 6.0

julia&gt; <span class="codestrong">a[2][2]</span>
6.0</pre>
<p class="indent">Notice the use of the keyword <code>end</code> to point to the last element of an array; this is convenient when you don’t know its length. The second element of the array is another array; we can index into that array in one expression using a double index, as in the last expression. If you do need to find the length of an array, use the <code>length()</code> function.</p>
<h3 class="h2" id="ch02lev3"><strong class="calibre2">Ranges</strong></h3>
<p class="noindent">Julia can construct ranges of numbers with a special notation. The syntax <code>1:5</code> represents a range of integers from <code>1</code> to <code>5</code> inclusive, counting by 1. You can count by numbers other than 1 by using a version of the syntax with three numbers. For example, <code>1:3:12</code> represents a range with the numbers <code>1, 4, 7, 10</code>. The range can count down as well, using a negative step, as in <code>5:-1:2</code>. Finally, any of the numbers in the range specifier can be a float rather than an integer, in which case all the numbers in the range will be floats.</p>
<p class="indent">Ranges are not arrays. They live in a kind of dimension of potentiality, ready to be brought to life by being used. In the meantime, they take up almost no space. One way to bring them to life is with the <code>collect()</code> function that turns them into a bona fide <code>Vector</code>:<span epub:type="pagebreak" id="page_36"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">collect(1:5)</span>
5-element Vector{Int64}:
 1
 2
 3
 4
 5
julia&gt; <span class="codestrong">[collect(1:2:10), collect(2.5:-0.5:0)]</span>
2-element Vector{Vector{Float64}}:
 [1.0, 3.0, 5.0, 7.0, 9.0]
 [2.5, 2.0, 1.5, 1.0, 0.5, 0.0]</pre>
<p class="indent">The first example turns a range into a vector, while the second uses two <code>collect()</code> operations inside a literal vector, resulting in a vector of two vectors.</p>
<p class="indent">The most common use of ranges is in <code>for</code> loops, which is covered in “More Looping: for Blocks” on <a href="ch02.xhtml#ch02lev5" class="calibre10">page 46</a>.</p>
<p class="indent">Ranges are also useful in indexing expressions to extract more than one element from an array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v = collect(0:5:20)</span>
5-element Vector{Int64}:
  0
  5
 10
 15
 20

julia&gt; <span class="codestrong">v[2:4]</span>
3-element Vector{Int64}:
  5
 10
 15

julia&gt; <span class="codestrong">v[end:-2:1]</span>
3-element Vector{Int64}:
 20
 10
  0</pre>
<p class="indent">These examples show how we can extract subsets of arrays and conveniently reverse the order of elements by using a decreasing range. We can extract noncontiguous elements by supplying the range with a step. For instance, <code>v[1:2:5]</code> yields <code>[0, 10, 20]</code>.</p>
<h4 class="h3" id="ch02lev1sec6"><strong class="calibre2"><em class="calibre4">Arrays: Beyond the First Dimension</em></strong></h4>
<p class="noindent">The <code>Vector</code>s we’ve seen up to now are <code>Array</code>s of one dimension. Even though the elements of a <code>Vector</code> may contain other collections, the <code>Vector</code> itself is still one-dimensional. Julia has arrays with any number of dimensions. Those with one dimension have their own type because they are a common special case, and optimizations can be applied to routines that calculate on them.<span epub:type="pagebreak" id="page_37"/></p>
<h5 class="h4" id="ch02sec1sec7"><strong class="calibre2">Matrices</strong></h5>
<p class="noindent">Arrays with two dimensions also have a particular type, called a <code>Matrix</code>. Matrices arise in many contexts in mathematics and physics, and in all kinds of calculations. They represent linear transformations that rotate vectors, encode the coefficients of systems of linear equations, are used as simple data tables, and much more.</p>
<p class="indent">Think of a matrix as a rectangular table of values. You can enter such tables directly to define them:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = [5 6</span>
            <span class="codestrong">7 8]</span>
2×2 Matrix{Int64}:
 5  6
 7  8</pre>
<p class="indent">When entering the definition of the matrix <code>m</code> into the REPL, I press <small class="calibre5">ENTER</small> after the number <code>6</code> to insert a line break. Julia’s REPL knows that the input is not complete because of the unclosed square bracket, so it doesn’t try to evaluate anything, but instead waits for more input. After I close the bracket and press ENTER, the REPL sees a complete expression, makes the assignment to the variable <code>m</code>, and returns the expression, preceded by a description of its shape (<code>2</code>×<code>2</code>), type (<code>Matrix</code>), and the type of the collection’s elements (<code>Int64</code>).</p>
<p class="indent">You can take advantage of this behavior to break an expression between lines, as in the following example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">(1 + 1</span>
          <span class="codestrong">+ 1</span>
       <span class="codestrong">)</span>
3</pre>
<p class="noindent">Without the opening parenthesis, the addition on the first line would have been performed immediately because it’s a complete expression.</p>
<h5 class="h4" id="ch02sec1sec8"><strong class="calibre2">Matrices vs. Vectors of Vectors</strong></h5>
<p class="noindent">Make sure that you understand the difference between the <code>2</code>×<code>2 Matrix m</code> and this vector:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v = [[5, 6], [7, 8]]</span>
2-element Vector{Vector{Int64}}:
 [5, 6]
 [7, 8]</pre>
<p class="indent">The latter is a one-dimensional array, whereas the former has two dimensions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_38"/>Some indexing should make this clear:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v[1]</span>
2-element Vector{Int64}:
 5
 6</pre>
<p class="noindent">Here, the first element of the <code>Vector v</code> is itself a vector.</p>
<p class="indent">A double index selects the second element of this first element:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v[1][2]</span>
6</pre>
<p class="noindent">In this case, we get the number <code>6</code>.</p>
<p class="indent">A colon standing alone means to select everything—in this case, the entire second element, which is a <code>Vector</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">v[2][:]</span>
2-element Vector{Int64}:
 7
 8</pre>
<p class="noindent">In this example the stand-alone colon is unnecessary, as just <code>v[2]</code> would yield the same result.</p>
<p class="indent">Since <code>m</code> is a <code>Matrix</code>, or a two-dimensional array, we select its elements using two indices:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m[1, 1]</span>
5</pre>
<p class="noindent">In this expression, the index <code>[1, 1]</code> means row 1, column 1, where the number <code>5</code> resides.</p>
<p class="indent">In a <code>Matrix</code>, the colon index is useful:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m[2, :]</span>
2-element Vector{Int64}:
 7
 8</pre>
<p class="noindent">Here it’s selecting the entire second row.</p>
<h5 class="h4" id="ch02sec1sec9"><strong class="calibre2">Scalar Indexing</strong></h5>
<p class="noindent">The usual way to index an <em class="calibre11">n</em>-dimensional array is with <em class="calibre11">n</em> indices: one for a vector, two for a matrix, and so on, as in the examples just shown. If you use the wrong number of indices, you’ll get an error:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m[1, 2, 3]</span>
ERROR: BoundsError: attempt to access 2×2 Matrix{Int64} at index [1, 2, 3]</pre>
<p class="indent"><span epub:type="pagebreak" id="page_39"/>Julia is complaining that we tried to index a two-dimensional array as if it had three dimensions.</p>
<p class="indent">What do you think we would get if we used just one index on <code>m</code>, as if it were a vector? Oddly enough, we don’t get an error, but it may not be obvious at first why we are getting these particular results:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m[1]</span>
5

julia&gt; <span class="codestrong">m[2]</span>
7

julia&gt; <span class="codestrong">m[3]</span>
6

julia&gt; <span class="codestrong">m[4]</span>
8</pre>
<p class="indent">Apparently we can access the four elements of this matrix as if they were arranged as a one-dimensional array, and they seem to be arranged by column. This is indeed the case, and it reflects how the numbers in the matrix are arranged in memory. The numbers 5, 7, 6, and 8 are the contents of the matrix reading down by column, starting with the first column and then the second. This is called <em class="calibre11">column-major order</em>, and is the way the elements are stored in memory.</p>
<p class="indent">Concepts like “two-dimensional arrays” are abstractions that make it easier to think about calculations and write programs. In the machine, the elements of the array are stored in one long row. The numbers in a Julia <code>Vector</code>, <code>Matrix</code>, or other <code>Array</code> type are guaranteed to be stored contiguously. Using a single integer as an index is called <em class="calibre11">scalar indexing</em>.</p>
<p class="indent">The scalar index can go from 1 to the total size of the matrix. If we try <code>m[5]</code>, we get an error message because the matrix contains only four elements.</p>
<p class="indent">The Julia programmer doesn’t have to be overly concerned with the machine representation of data structures or think much about how they are arranged in memory, but this detail is important. A calculation that loops over the elements of a matrix should proceed in column-major order rather than row-major order because the former method accesses contiguous values in memory and will be more efficient.</p>
<h5 class="h4" id="ch02sec1sec10"><strong class="calibre2">Indexing Arrays with Arrays</strong></h5>
<p class="noindent">In addition to numbers and ranges, elements of an index expression can themselves be vectors. <a href="ch02.xhtml#ch2lis3" class="calibre10">Listing 2-3</a> sets up a slightly larger matrix so we have more room to play.</p>
<pre class="calibre13">   julia&gt; m = <span class="codestrong">[11 12 13 14</span>
               <span class="codestrong">15 16 17 18</span>
               <span class="codestrong">19 20 21 22];</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">m[2, [2, 3]]</span>
   2-element Vector{Int64}:
    16
    17

   julia&gt; <span class="codestrong">m[[1, 2], [3, 4]]</span>
   2×2 Matrix{Int64}:
    13  14
    17  18</pre>
<p class="list" id="ch2lis3"><span epub:type="pagebreak" id="page_40"/><em class="calibre11">Listing 2-3: Indexing with vectors</em></p>
<p class="indent">After defining a 3×4 <code>Matrix</code>, I extract the elements from the second and third columns of the second row by using a vector for the column part of the indexing expression <span class="ent">➊</span>. Since the result is one-dimensional, Julia puts the elements into a <code>Vector</code>.</p>
<p class="indent">Then I pull out the elements in the first two rows and the third and fourth columns. Since the result is two-dimensional, it becomes a (smaller) <code>Matrix</code>.</p>
<p class="indent">We’ve seen that when we access elements of a multidimensional array using a single index, Julia interprets that as an index into the one-dimensional array made by taking the elements in column-major order.</p>
<p class="indent">When indexing an array, you can refer to all of its dimensions:</p>
<pre class="calibre13"><span class="codeitalic">Array</span>[<span class="codeitalic">rows, columns, third_dimension, fourth_dimension</span>]</pre>
<p class="indent">With this style, each of the expressions separated by commas must be a <code>Vector</code> or a number. (A number is treated as a <code>Vector</code> with one element, as evaluating <code>5[1]</code> shows.) The <code>Vector</code>s can be in the form of range expressions or simple colons, which are interpreted as the <code>Vector</code>s they represent.</p>
<p class="indent">Alternatively, you can index it as if it were a <code>Vector</code>:</p>
<pre class="calibre13"><span class="codeitalic">Array</span>[<span class="codeitalic">Array</span>]</pre>
<p class="indent">When using this second style, the <code>Array</code> in the index expression can have any shape. The result will have the shape of that <code>Array</code>. It can be larger than the original <code>Array</code> because you can repeat elements. The only limitation is that, if the original <code>Array</code> has <em class="calibre11">n</em> elements, you can use indices only in the range [1, <em class="calibre11">n</em>]. The same limitation applies to the first style, but to each individual indexing vector, where <em class="calibre11">n</em> means the length of the array along that dimension. In other words, you can’t index elements that don’t exist.</p>
<p class="indent">Let’s take another look at the second indexing style with a couple of examples, using the <code>Array m</code> defined earlier:<span epub:type="pagebreak" id="page_41"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">m[[2 3</span>
          <span class="codestrong">4 5]]</span>
2×2 Matrix{Int64}:
 15  19
 12  16

julia&gt; <span class="codestrong">m[[end 1 9</span>
          <span class="codestrong">9   1 end]]</span>
2×3 Matrix{Int64}:
 22  11  21
 21  11  22</pre>
<p class="indent">In both of these cases, the result has the same shape as the array used as an index. The <code>end</code> keyword picks out the last element in the source array. In the first style of indexing, it picks out the last element along the relevant dimension.</p>
<h5 class="h4" id="ch02sec1sec11"><strong class="calibre2">Concatenation Operators</strong></h5>
<p class="noindent">It’s not always convenient to use line breaks to signify the end of a row when defining matrices, so in Julia, you can use a semicolon instead:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m1 = [6 7</span>
             <span class="codestrong">8 9];</span>

julia&gt; <span class="codestrong">m2 = [6 7; 8 9];</span>

julia&gt; <span class="codestrong">m1 == m2</span>
true</pre>
<p class="indent">The line break and the semicolon are both ways to spell the <em class="calibre11">vertical concatenation operator</em>. This has another name, <code>vcat</code>, so another way to construct the <code>m1</code> or <code>m2</code> matrix is with <code>vcat([6 7], [8 9])</code>. In this expression, <code>[6 7]</code> and <code>[8 9]</code> are two <em class="calibre11">arguments</em> to the <code>vcat()</code> function.</p>
<p class="indent">The space used to separate the numbers <code>6</code> and <code>7</code> in the definitions of <code>m1</code> and <code>m2</code> just shown is an operator, too, called the <em class="calibre11">horizontal concatenation operator</em>. It has its own explicit function as well, called <code>hcat()</code>. It’s important to understand the difference between <code>[6, 7]</code>, which is a <code>Vector</code> containing two elements, and <code>[6 7]</code>, which is a <code>1</code>×<code>2 Matrix</code> formed by horizontal concatenation invoked by a space. (Tabs can be used as well as spaces for this purpose.)</p>
<p class="indent">The following are a few final examples to clarify the results of the two different directions of concatenation. Here’s one way to construct a matrix:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[[6 7]; [8 9]]</span>
2×2 Matrix{Int64}:
 6  7
 8  9</pre>
<p class="indent">This construction combines vertical and horizontal concatenation in one expression. The spaces between the numbers concatenate them horizontally into arrays with a single row each. The semicolon vertically concatenates each of those matrices into a larger matrix with the first row on top of the second.</p>
<p class="indent"><span epub:type="pagebreak" id="page_42"/>Replacing the semicolon with a space produces a different shape, horizontally joining the two one-row matrices into a longer one-row matrix:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[[6 7] [8 9]]</span>
1×4 Matrix{Int64}:
 6  7  8  9</pre>
<p class="indent">In the third example, we’ll ask for two <em class="calibre11">vectors</em> to be horizontally concatenated:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[[6, 7] [8, 9]]</span>
2×2 Matrix{Int64}:
 6  8
 7  9</pre>
<p class="indent">The result in this example surprises some people new to the language. You may not immediately understand why we don’t get the same result as in the previous example. Horizontal concatenation really means, for a <code>Matrix</code>, joining along the second dimension. Since a <code>Vector</code> doesn’t have a second dimension, Julia first has to change each <code>Vector</code> into a <code>2</code>×<code>1 Matrix</code>, and then join them along the column dimension.</p>
<p class="indent">But there is no such issue when we ask Julia to <em class="calibre11">vertically</em> concatenate the vectors because that means to join them along their first dimensions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[[6, 7]; [8, 9]]</span>
4-element Vector{Int64}:
 6
 7
 8
 9</pre>
<p class="noindent">The result of this is a longer <code>Vector</code>.</p>
<h4 class="h3" id="ch02lev1sec7"><strong class="calibre2"><em class="calibre4">Tuples</em></strong></h4>
<p class="noindent">A <code>Tuple</code> is similar to a <code>Vector</code>, with the important difference being that you cannot change it once it is created. Initialize a <code>Tuple</code> the same way you create a <code>Vector</code>, but use parentheses instead of square brackets or omit them entirely if that does not create an ambiguity, as shown in <a href="ch02.xhtml#ch2lis4" class="calibre10">Listing 2-4</a>.</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">tup1 = (5, 6)</span>
   (5, 6)

   julia&gt; <span class="codestrong">tup2 = 5, 6</span>
   (5, 6)

   julia&gt; <span class="codestrong">tup1 === tup2</span>
   true

<span class="ent">➊</span> julia&gt; <span class="codestrong">tup1[1]</span>
   5

<span class="ent">➋</span> julia&gt; <span class="codestrong">tup1[1] = 9</span>
   ERROR: MethodError: no method matching [...]</pre>
<p class="list" id="ch2lis4"><span epub:type="pagebreak" id="page_43"/><em class="calibre11">Listing 2-4: Some properties of tuples</em></p>
<p class="indent">This example shows that the parentheses are optional, and that two tuples containing the same values (in the same order) are indistinguishable because they pass the <code>===</code> comparison.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">When a tuple contains only one element, it must be written with parentheses and a comma after the element—for example,</em> <span class="codeitalic1">(3,)</span><em class="calibre11">.</em></p>
</div>
<p class="indent">We can index tuples <span class="ent">➊</span> as if they were vectors, but we can neither <em class="calibre11">assign</em> values to element locations <span class="ent">➋</span> nor change the tuple in any way.</p>
<p class="indent">What is the use of a vector-like collection that can’t be changed? Tuples can be used to store lists of values that we want to ensure can’t be altered accidentally. Their main use is supplying arguments to functions and collecting results, as we’ll see shortly.</p>
<h4 class="h3" id="ch02lev1sec8"><strong class="calibre2"><em class="calibre4">Membership</em></strong></h4>
<p class="noindent">Julia provides another logical operator that tests for membership in a collection. It’s the <code>in</code> operator, which can also take the form <code>∊</code>, entered in the REPL with <code>\in</code> followed by pressing <small class="calibre5">TAB</small>. In this case, the Unicode version is preferred because it comes with a negated form, meaning “not in,” that looks like <code>∉</code> and is entered in the REPL with <code>\notin</code> followed by <small class="calibre5">TAB</small>.</p>
<p class="indent">Here are some examples:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">2</span> ∈ <span class="codestrong">[1, 2, 3]</span>
   true

   julia&gt; <span class="codestrong">2</span> ∉ <span class="codestrong">[1, 2, 3]</span>
   false

<span class="ent">➊</span> julia&gt; <span class="codestrong">2</span> ∈ <span class="codestrong">[1, 2.0, 3]</span>
   true

<span class="ent">➋</span> julia&gt; <span class="codestrong">[2, 3]</span> ∈ <span class="codestrong">[2, 3, 4]</span>
   false

<span class="ent">➌</span> julia&gt; <span class="codestrong">[2, 3]</span> ∈ <span class="codestrong">[[2, 3], 4]</span>
   true</pre>
<p class="indent">Membership uses comparisons of values <span class="ent">➊</span>, not object identity, which may not be what you were expecting.</p>
<p class="indent">In <span class="ent">➋</span>, we get <code>false</code> because the <code>Vector [2, 3]</code> is not one of the members of the <code>Vector [2, 3, 4]</code>. In the following example <span class="ent">➌</span> , we get a <code>true</code> result because the <code>Vector [2, 3]</code> <em class="calibre11">is</em> a member of <code>[[2, 3], 4]</code>.<span epub:type="pagebreak" id="page_44"/></p>
<h3 class="h2" id="ch02lev4"><strong class="calibre2">Strings and Characters</strong></h3>
<p class="noindent">Julia is a bit unusual in that single and double quotation marks have different meanings: single quotes indicate characters and double quotes are for strings. <code>Char</code> and <code>String</code> are two distinct data types.</p>
<h4 class="h3" id="ch02lev1sec9"><strong class="calibre2"><em class="calibre4">Characters</em></strong></h4>
<p class="noindent">A <code>Char</code> is entered with a pair of single quotes. Julia was created in the age of Unicode, so it was spared the painful transitions of older languages such as Python. Julia is fully Unicode aware. A <code>Char</code> can be any Unicode character, such as <code>'5'</code>, <code>'a'</code>, <code>'ñ'</code>, or <code>'∑'</code>. Under the hood, it’s a 32-bit value representing the character with its UTF-8 encoding. The value has some of the properties of a number, but it is not, in fact, a number.</p>
<p class="indent">Characters have an ordering, so you can ask <code>'a' &lt; 'z'</code> and Julia will tell you <code>true</code>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">In many languages, single and double quotes can be used interchangeably, and both signify strings or characters, with characters being strings with only one letter or other symbol. Like Elixir and SQL, Julia distinguishes between string and character data types:</em> <span class="codeitalic1">"ab"</span> <em class="calibre11">is a string, but</em> <code>'</code><em class="calibre11">ab</em><code>'</code> <em class="calibre11">is a syntax error.</em></p>
</div>
<p class="indent">You can add an integer to a character, as in <code>'a' + 1</code>, and Julia will give you the next character, <code>'b'</code>. Subtraction gives similar results. You can even subtract two characters to find the distance between them: <code>'c' - 'a'</code> yields <code>2</code>, which means that <code>'a' + 2</code> yields <code>'c'</code>. However, addition of characters is not allowed.</p>
<h4 class="h3" id="ch02lev1sec10"><strong class="calibre2"><em class="calibre4">Strings</em></strong></h4>
<p class="noindent">A <code>String</code> is entered with double quotes, like <code>"François"</code>. It is a type of collection, similar in some ways to a <code>Vector</code>, but with some complications. As it is a series of characters, you can make one by joining together single characters. The operator for this, unusually, is <code>*</code>. The designers of Julia decided not to employ the more usual <code>+</code> for several reasons, one of them being that addition is commutative, but the joining of characters certainly is not: <code>'a' * 'b'</code> yields the string <code>"ab"</code>, but <code>'b' * 'a'</code> yields a different string, <code>"ba"</code>. You can also build up a string by joining other strings: <code>"Fran" * "çois"</code> becomes <code>"François"</code>.</p>
<p class="indent">Since strings are collections, you can use the membership operator with them, but only for testing the occurrence of characters: <code>'a' in "abc"</code> yields <code>true</code>.</p>
<p class="indent">If you want to test for the occurrence of a string, even one consisting of a single character, in another string, use the <code>occursin()</code> function: <code>occursin("a", "abc")</code> will give you a <code>true</code> result.</p>
<p class="indent">One of the complications that arises when treating strings like vectors is when trying to index them:<span epub:type="pagebreak" id="page_45"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">n = "François"</span>
"François"

julia&gt; <span class="codestrong">length(n)</span>
8

julia&gt; <span class="codestrong">n[end]</span>
's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)

julia&gt; <span class="codestrong">n[1]</span>
'F': ASCII/Unicode U+0046 (category Lu: Letter, uppercase)

julia&gt; <span class="codestrong">n[5]</span>
'ç': Unicode U+00E7 (category Ll: Letter, lowercase)

julia&gt; <span class="codestrong">n[6]</span>
ERROR: StringIndexError: invalid index [6], valid nearby indices [5]=&gt;'ç', [7]=&gt;'o'</pre>
<p class="indent">Everything was going fine until the last expression. Extracting single elements from the <code>String</code> gives us the <code>Char</code> that we expect. Why doesn’t <code>n[6]</code> just return the sixth character? Even stranger, if we try <code>n[8]</code>, we don’t get the last letter, but <code>'i'</code> instead. If we try <code>n[end]</code>, we <em class="calibre11">do</em> get the final letter.</p>
<p class="indent">The cause of these mysteries is that different Unicode characters take up different amounts of space. The index into a <code>String</code> counts the number of <em class="calibre11">bytes</em>, or 8-bit units, from the beginning of the <code>String</code>. Ordinary ASCII letters like “F” and “r” take up one byte each, but “ç” happens to take up two bytes. So it starts at position 5 when counting bytes, but the next character is at position 7, as the error message advises us. And we got the error because we are not allowed to index “inside” a character.</p>
<p class="indent">There are complicated ways to avoid this problem by finding out the legal indices for any <code>String</code>. Fortunately, you won’t have to learn these techniques, because one rarely needs to index strings directly. If you need to iterate over the elements of a <code>String</code> or any other collection, there is a far easier way to do so, which we’ll cover in the next section.</p>
<p class="indent">For very long strings, especially those that contain line breaks and may contain quote characters, there is a more convenient syntax. Delimit these strings using three double quotes:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">ls = """</span>
       <span class="codestrong">Line one.</span>
       <span class="codestrong">Line two "with a quoted section"!</span>
       <span class="codestrong">We're done.</span>
       <span class="codestrong">"""</span>
"Line one.\nLine two \"with a quoted section\"!\nWe're done.\n"


julia&gt; <span class="codestrong">print(ls)</span>
Line one.
Line two "with a quoted section"!
We're done.</pre>
<p class="indent"><span epub:type="pagebreak" id="page_46"/>In this example, using <code>print()</code> displays strings somewhat differently from how they are returned as results.</p>
<h3 class="h2" id="ch02lev5"><strong class="calibre2">More Looping: for Blocks</strong></h3>
<p class="noindent">So far, we’ve learned one way to iterate over a section of code, or loop, by using a <code>while</code> block in conjunction with a condition for stopping the iteration. This is appropriate for situations when we want to do something repeatedly until something changes—for example, when reading data from a network socket until the socket is closed or calculating a progressively more accurate solution to an equation until the error is smaller than some tolerance. In other situations, we simply want to iterate a fixed number of times or iterate over the members of a collection. This is where <code>for</code> loops come in.</p>
<p class="indent">To loop a fixed number of times, use a range expression. This loop repeats the calculation in <a href="ch02.xhtml#ch2lis1" class="calibre10">Listing 2-1</a>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for j in 0:4</span>
           <span class="codestrong">println(j^2)</span>
       <span class="codestrong">end</span>
0
1
4
9
16</pre>
<p class="indent">This version is simpler because we didn’t have to add 1 to <code>j</code> on each iteration. The variable takes on the sequence of values in the range expression, progressing to the next one each time through the loop. As with <code>while</code> loops, <code>for</code> loops do not return results, so we need an explicit <code>println()</code> statement.</p>
<p class="indent">We can use any kind of range expression:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for q in 8:-2:1</span>
           <span class="codestrong">println(1/q)</span>
       <span class="codestrong">end</span>
0.125
0.16666666666666666
0.25
0.5</pre>
<p class="indent">Here we’re counting down by twos from 8 to 1.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">You may substitute</em> <span class="codeitalic1">=</span> <em class="calibre11">for the keyword</em> <span class="codeitalic1">in</span> <em class="calibre11">in any</em> <span class="codeitalic1">for</span> <em class="calibre11">block if you prefer. There is also a third, fancier option: you can use the membership symbol</em> <code>∈</code><em class="calibre11">, which we first met in “</em><em class="calibre11">Membership</em><em class="calibre11">” on <a href="ch02.xhtml#ch02lev1sec8" class="calibre10">page 43</a></em><em class="calibre11">.</em></p>
</div>
<p class="indent">You may nest as many <code>for</code> blocks inside each other as required. In cases where you have a contiguous loop body, meaning you don’t have to do anything between the updates of any of the loop variables (such as the counters <span epub:type="pagebreak" id="page_47"/><code>i</code> and <code>j</code> in the following listing), Julia provides a concise syntax that avoids deeply nested structures on the page:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for i</span> ∈ <span class="codestrong">0:3, j</span> ∈ <span class="codestrong">4:6</span>
           <span class="codestrong">println([i, j, i + j])</span>
       <span class="codestrong">end</span>
[0, 4, 4]
[0, 5, 5]
[0, 6, 6]
[1, 4, 5]
[1, 5, 6]
[1, 6, 7]
[2, 4, 6]
[2, 5, 7]
[2, 6, 8]
[3, 4, 7]
[3, 5, 8]
[3, 6, 9]</pre>
<p class="indent">All the looping instructions are on one line, and we need only one <code>end</code> statement.</p>
<p class="indent">The same <code>for</code> block syntax lets us loop over vectors, matrices, or other containers:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for x in [-19 23 0]</span>
           <span class="codestrong">println(abs(x))</span>
       <span class="codestrong">end</span>
19
23
0</pre>
<p class="indent">In this example, <code>x</code> takes on the values in the <code>1</code>×<code>3 Matrix</code>, applying the absolute value function to each one.</p>
<p class="indent">The loop can be over <code>Vector</code> and <code>Tuple</code> data types as well, but a <code>Tuple</code> needs to be enclosed in parentheses if used in the <code>for</code> statement.</p>
<p class="indent">You can loop over arrays of any dimension:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for x in [[-19 23 0]; [-1 22 -17]]</span>
           <span class="codestrong">println(abs(x))</span>
       <span class="codestrong">end</span>
19
1
23
22
0
17</pre>
<p class="indent">The elements are printed in column-major order, reflecting their layout in memory.</p>
<p class="indent"><span epub:type="pagebreak" id="page_48"/>Since strings are containers, too, you can loop over them: François</p>
<pre class="calibre13">julia&gt; <span class="codestrong">for c</span> ∈ <span class="codestrong">"François"</span>
           <span class="codestrong">print(c * " • ")</span>
       <span class="codestrong">end</span>
F • r • a • n • ç • o • i • s •</pre>
<p class="indent">Here we don’t have to worry about the varying lengths of Unicode characters as the <code>for</code> loop knows how to step from one character to the next.</p>
<h3 class="h2" id="ch02lev6"><strong class="calibre2">Functions</strong></h3>
<p class="noindent">Projects in Julia are organized around sets of <em class="calibre11">functions</em>. These resemble functions in mathematics, in that they are maps of values to other values. In Julia the input and output values can be of any type.</p>
<p class="indent">Here is how to define a function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function double(x)</span>
           <span class="codestrong">2x</span>
       <span class="codestrong">end</span>
double (generic function with 1 method)</pre>
<p class="indent">The <code>double()</code> function takes a number and returns twice the number. For now, don’t worry about the message that the REPL returns. You’ll find out what it means in “Functions and Methods: Multiple Dispatch” on <a href="ch08.xhtml#ch08lev2" class="calibre10">page 229</a>.</p>
<p class="indent">Simple functions like this one have an alternative syntax. You can shorten this function definition block as follows:</p>
<pre class="calibre13">double(x) = 2x</pre>
<p class="indent">Notice that we don’t need a <code>print()</code> statement because a function returns the last expression that it evaluates. Try it by entering expressions like <code>double(-3.1)</code> in the REPL. Anything where <code>2x</code> makes sense will work, but if you supply an argument where it doesn’t, such as a string, Julia will respond with an error message.</p>
<p class="indent">In the definition of the function, the <code>(x)</code> part is actually a <code>Tuple</code> with one element, <code>x</code>, which is <code>double()</code>’s single <em class="calibre11">argument</em>.</p>
<p class="indent">Functions can have any number of arguments. Here is one that gives the length of a vector from the origin if you supply the x-, y-, and z-coordinates of its end:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function length3d(x, y, z)</span>
           <span class="codestrong">sqrt(x^2 + y^2 + z^2)</span>
       <span class="codestrong">end</span>
length3d (generic function with 1 method)

julia&gt; <span class="codestrong">length3d(1, 1, 1)</span>
1.7320508075688772</pre>
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Use the <code>return</code> statement if you want the function to stop and return a value. We can use this to modify our <code>length3d()</code> function to accept only positive coordinates:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function length3d(x, y, z)</span>
           <span class="codestrong">if x &lt; 0 || y &lt; 0 || z &lt; 0</span>
               <span class="codestrong">return "I only work with positive coordinates."</span>
           <span class="codestrong">end</span>
           <span class="codestrong">sqrt(x^2 + y^2 + z^2)</span>
       <span class="codestrong">end</span>
length3d (generic function with 1 method)</pre>
<p class="indent">If we call <code>length3d()</code> with all positive arguments, all is well:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">length3d(1, 1, 1)</span>
1.7320508075688772</pre>
<p class="indent">But a negative argument hits the <code>return</code> statement:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">length3d(1, 1, -1)</span>
"I only work with positive coordinates."</pre>
<p class="indent">When you invoke the name of a function with parentheses and arguments, you are causing the function to execute using those arguments. This is called <em class="calibre11">calling</em> the function. If you supply the wrong number of arguments, such as trying to call <code>length3d(1, 1)</code>, you’ll get an error. When we want to <em class="calibre11">refer</em> to the function without calling it, we simply use its name without parentheses or arguments: for instance, <code>length3d</code>. We can assign functions to variables, pass them as arguments to other functions, and generally treat them as any other value.</p>
<p class="indent">The function in <a href="ch02.xhtml#ch2lis5" class="calibre10">Listing 2-5</a> takes a value and another function as arguments and announces the result of applying the supplied function to the argument. It works with any function of one argument, as long as you supply an argument <code>x</code> that <code>f</code> can handle.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function tellme(f, x)</span>
           <span class="codestrong">print("The result is ")</span>
           <span class="codestrong">f(x)</span>
       <span class="codestrong">end</span>
tellme (generic function with 1 method)</pre>
<p class="list" id="ch2lis5"><em class="calibre11">Listing 2-5: A function with a function as an argument</em></p>
<p class="indent">Now if we call <code>tellme(double, 3)</code> we will see the string <code>The result is 6</code> printed on the terminal. If we call <code>tellme(abs, -17)</code>, the function prints <code>The result is 17</code>.</p>
<p class="indent">These two examples use the <code>double()</code> function that we defined and the built-in absolute value function.</p>
<p class="indent">I mentioned previously that you don’t need to use <code>print()</code> statements to see the result a function returns, so you may wonder why there is one <span epub:type="pagebreak" id="page_50"/>here. A function returns the last expression it evaluates or returns immediately if it reaches a <code>return</code> statement. If we had omitted the <code>print()</code> statement and had only the string in its place, the value of the string would be evaluated as itself, but not returned, because it would not be the last expression. Function execution would proceed to the next line and return the value <code><em class="calibre11">f</em>(<em class="calibre11">x</em>)</code>.</p>
<p class="indent">The <code>print()</code> statement is not an expression, but a <em class="calibre11">statement</em>, meaning that it does not return a result; instead, it has the <em class="calibre11">side effect</em> of causing something to be written on the terminal. So the function produces that side effect and continues to the next (last) line, which is an expression, whose value it returns.</p>
<p class="indent">A side effect is anything that changes the state of the world, such as creating a file, printing to a terminal, or downloading something from the internet. A <em class="calibre11">pure function</em> is a function that has no side effects, but just returns a result. Writing pure functions when possible makes your code easier to debug and reason about, and it helps make your functions <em class="calibre11">composable</em>, which is the topic of the next section.</p>
<h4 class="h3" id="ch02lev1sec11"><strong class="calibre2"><em class="calibre4">Composing Functions</em></strong></h4>
<p class="noindent">Just as in math, <em class="calibre11">composing</em> functions means to supply the output of one function as the input of the next. Julia supplies three syntaxes for function composition. The first two are the same as common mathematical notations, but the third is a somewhat different idea. Here are all three methods, used for applying our <code>double()</code> function twice:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">double(double(3))</span>
12

julia&gt; <span class="codestrong">(double ○ double)(3)</span>
12

julia&gt; <span class="codestrong">3 |&gt; double |&gt; double</span>
12</pre>
<p class="indent">The first way uses the syntax for applying a function to an argument, where the argument is the function applied to the number <code>3</code>. The number gets doubled and the result is itself doubled.</p>
<p class="indent">The second way uses a symbol that mathematicians sometimes use for composition and has a neater appearance, especially as we can compose as many functions as we want inside the first set of parentheses, something that, using the first method, leads to a proliferation of brackets. The series of functions are combined into a single composite function, applied to the argument list in the second set of parentheses. You can enter the little circle in the REPL using <code>\circ</code> followed by <small class="calibre5">TAB</small>.</p>
<p class="indent">The final option goes from left to right, whereas the previous two acted from right to left. It uses the <em class="calibre11">pipe operator</em> <code>|&gt;</code> to create a <em class="calibre11">pipeline</em>. A value at <span epub:type="pagebreak" id="page_51"/>the beginning, in this case 3, is fed to the first function in the pipeline, and the result of applying that function to the value is passed along to the second function, and so on. This method is a favorite of people who don’t like parentheses; it’s especially suited to expressing the processing of data through a series of transformations.</p>
<p class="indent">The three syntaxes for function composition are exactly equivalent. Which one to use is a matter of preference and convenience in a particular situation.</p>
<h4 class="h3" id="ch02lev1sec12"><strong class="calibre2"><em class="calibre4">Creating Anonymous Functions</em></strong></h4>
<p class="noindent">Sometimes you need to define a function “on the fly,” without giving it a name. This happens when you want to supply a function as an argument to another function, but the one you supply needs to live only as long as the computation performed by the outer function. That is, it’s disposable.</p>
<p class="indent">The syntax for anonymous functions makes their operation as maps explicit, using the operator <code>-&gt;</code> to indicate the mapping. To define an anonymous doubling function, write <code>x -&gt; 2x</code>.</p>
<p class="indent">If the function has multiple variables, enclose them in parentheses: <code>(x, y) -&gt; x/(1 + y)</code>.</p>
<p class="indent">We’ll make extensive use of anonymous functions in <a href="ch04.xhtml" class="calibre10">Chapter 4</a>, where they’ll make it easy for us to plot mathematical functions.</p>
<h4 class="h3" id="ch02lev1sec13"><strong class="calibre2"><em class="calibre4">Broadcasting</em></strong></h4>
<p class="noindent">One of the most useful and innovative operators in Julia is the humble dot. With this single character you can turn any function into one that operates element by element on an array, a process called <em class="calibre11">broadcasting</em>.</p>
<p class="indent">You can transform your own functions into array functions simply by appending a dot to their names:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">f(x) = 2x</span>
f (generic function with 1 method)

julia&gt; <span class="codestrong">f.([1, 2, 3])</span>
3-element Vector{Int64}:
 2
 4
 6</pre>
<p class="indent">Here we define a doubling function and broadcast it to the elements of a vector. Naturally, broadcasting works with arrays of any shape.</p>
<p class="indent">There is much more to say about the central idea of functions in Julia. As with most topics in this chapter, this is just an introduction. You will meet other facets of functions in later chapters as we need them.<span epub:type="pagebreak" id="page_52"/></p>
<h3 class="h2" id="ch02lev7"><strong class="calibre2">Scope</strong></h3>
<p class="noindent">The <em class="calibre11">scope</em> of a variable refers to the region of code where it is visible and modifiable. When you define a variable outside any block, with a statement like <code>a = 1</code>, the variable <code>a</code> is <em class="calibre11">global</em> because you’ve defined it in the <em class="calibre11">global scope</em>.</p>
<p class="indent">The interactive style of computation in the REPL or Pluto leads to the routine use of global variables, as we improvise within an interactive workspace where it’s convenient to have everything immediately available. When writing permanent programs in files, however, it’s a good practice to limit your use of global variables. They are best confined to constants that need to be available to more than one function in your project.</p>
<p class="indent">If you need to use such global constants, declare them with the <code>const</code> keyword; for example, <code>const e = exp(1)</code>. This both ensures that you won’t accidently change their value later and helps the compiler to generate faster code.</p>
<p class="indent">This practice has several benefits. For one, it allows you to move a function from one file to another or reuse your functions without worrying about whether they depend on global quantities defined elsewhere. It keeps functions self-contained.</p>
<p class="indent">Loops and functions have somewhat different scoping rules in non-interactive contexts. After we master them, we’ll learn about a slight modification to the rules that makes working in the REPL more convenient.</p>
<p class="indent">Not all blocks create local scopes. Expression blocks, beginning with the <code>begin</code> keyword (see “Expression Blocks” on <a href="ch02.xhtml#ch02sec1sec6" class="calibre10">page 30</a>), do not establish their own scopes. Their scope is the same as the scope of whatever they’re contained within. If the <code>begin</code> block is at the top level, it’s in the global scope.</p>
<p class="indent">The same holds for <code>if</code> blocks: they’re simply part of their immediate environment as far as scope is concerned.</p>
<p class="indent">The other blocks introduced in this chapter establish <em class="calibre11">local scopes</em>, but there are two different varieties. One type of scope applies to function definition blocks while a different type applies to <code>for</code> and <code>while</code> blocks.</p>
<h4 class="h3" id="ch02lev1sec14"><strong class="calibre2"><em class="calibre4">Scoping Rules for Functions</em></strong></h4>
<p class="noindent">Inside a function definition, all variables are local unless you decorate them with the <code>global</code> keyword. You can use this notation one time, anywhere within the function definition, because variables can be of only one variety in any one block.</p>
<p class="indent">If you assign to a variable that doesn’t already exist as a local variable, a new one is created. If it <em class="calibre11">does</em> already exist, because the function definition is inside another block where it’s defined, that preexisting variable is used.</p>
<p class="indent">None of this has to do with variables supplied as function arguments. Those are simply local; but see “Mutability” on <a href="ch02.xhtml#ch02lev8" class="calibre10">page 55</a>.</p>
<p class="indent">A few examples should help to make this clear:</p>
<pre class="calibre13">s = 0
function glos()
    s = s + 1
end

glos()</pre>
<p class="indent"><span epub:type="pagebreak" id="page_53"/>If you save this listing in a file and run it by entering <code>julia</code> <code><em class="calibre11">filename</em></code>, you’ll get an error message complaining that <code>s</code> is undefined. Although <code>s</code> is already defined to be 0 in the global scope, its assignment within the function definition creates a new local variable. However, this variable is undefined on the right-hand side of the statement.</p>
<p class="indent">This program file, however, runs without error:</p>
<pre class="calibre13">s = 0
function glos()
    print(s)
end

glos()</pre>
<p class="noindent">It prints out <code>0</code>. Since there is no <em class="calibre11">assignment</em> to <code>s</code> within the function body, no new local variable is created and the function uses the existing global variable.</p>
<p class="indent">What if we really had intended, in the first example, to use that global <code>s</code>?</p>
<pre class="calibre13">s = 0
function glos()
    global s = s + 1
    print(s)
end

glos()</pre>
<p class="noindent">This program prints out <code>1</code>. The declaration of <code>s</code> as <code>global</code> within the function means that the variable inside the function is the same as the one outside.</p>
<p class="indent">We’ve looked at the relationship between variables defined inside a function and global variables. We also need to consider what happens if a variable inside the function block shares a name with a <em class="calibre11">local</em> variable outside the function. This can happen if everything is enclosed within another block—say, another function definition:</p>
<pre class="calibre13">function outer()
 <span class="ent">➊</span> s = 0
    function glos()
     <span class="ent">➋</span> s = s + 1
    end
    glos()
    print(s)
end

outer()</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_54"/>When this program is run, it prints <code>1</code>. The variable <code>s</code> is a local variable because it’s defined inside a function block <span class="ent">➊</span>. Therefore, according to the scoping rules, when it’s assigned to inside the inner function <code>glos()</code> <span class="ent">➋</span>, a new local variable is <em class="calibre11">not</em> created; rather, the existing one is used.</p>
<h4 class="h3" id="ch02lev1sec15"><strong class="calibre2"><em class="calibre4">Scoping Rules for Loops</em></strong></h4>
<p class="noindent">Both kinds of loops, <code>for</code> blocks and <code>while</code> blocks, create local scopes, but they have one small change in behavior from function blocks.</p>
<p class="indent">If you assign to a variable inside a loop, and a variable with the same name already exists in the global scope, two things happen: the variable is treated as local within the loop, with the value of its global version unaffected by whatever happens inside the loop, and Julia prints a warning about this on the terminal when you run the program from a file (but not from the REPL, as discussed in the next section).</p>
<p class="indent">The reason for the warning is that <em class="calibre11">shadowing</em> a global variable inside a loop creates an ambiguity: Julia is not sure whether you mean to create a new local variable or use the global one. Rather than refusing to run your program, Julia picks one option, but warns you that you may have intended something different. Remove the ambiguity by using the <code>local</code> or <code>global</code> keyword to decorate the variable inside the loop.</p>
<p class="indent">An even better solution for program files is to put the loop and the variables it references inside a function. Then the variables will not be in the global scope and Julia will not issue a warning. In general, while we do many calculations in the REPL outside functions, it’s a good practice to place as much as possible inside functions when writing program files.</p>
<p class="indent">The behavior, therefore, is exactly the same as in the case of function blocks, aside from the warning. Julia issues this warning in the case of loops, but not function definitions, because while functions generally use only the variables passed in as arguments and their private, local variables, it is common for loops to be initialized by variables set up outside the loops. When everything is local, as when the loop and its initialization are all inside a function, there is little chance that the programmer repeated the variable name inadvertently. However, when the variable external to the loop is global, there is the distinct possibility that this happened by accident. The loop could have been copied from another file that used the same variable names by chance, or the global variables could have been defined somewhere in the file thousands of lines away from the loop. To help keep you safe, Julia follows the scoping rules, but warns you about existing global variables shadowed in the loop.</p>
<h4 class="h3" id="ch02lev1sec16"><strong class="calibre2"><em class="calibre4">Modification of Scoping Rules in Interactive Contexts</em></strong></h4>
<p class="noindent">Inside the REPL, Pluto, or other interactive contexts, different scoping rules for <code>while</code> and <code>for</code> loops apply. Function blocks use the same rules in both interactive and noninteractive contexts.</p>
<p class="indent">In the REPL, if a variable is assigned within a loop, and the variable does not exist in the global REPL scope, a new local variable is established. If, <span epub:type="pagebreak" id="page_55"/>however, a global variable with the same name already exists, that global variable is used and no warning is issued.</p>
<p class="indent">This modification to the scoping rules makes work in the REPL, with all of its global variables, more convenient. It also simplifies the process of debugging parts of functions inside the REPL. Imagine that a loop, along with its initialization, is copied from within a big function defined in a file and pasted into the REPL. In the file, the initialization variables are local, but when pasted into the REPL, they appear in the global scope. The REPL rule exceptions allow loops and their initializations to behave the same way they do in their natural habitat, nestled within function blocks.</p>
<h3 class="h2" id="ch02lev8"><strong class="calibre2">Mutability</strong></h3>
<p class="noindent">In several places in this chapter, the <code>===</code> operator appears as a test of strict equality: two values are only equal in the <code>===</code> sense, or identical, if they have the same types as well as the same values.</p>
<p class="indent">Now that we know more, we can revisit the <code>===</code> comparison in other contexts. The following example might surprise you:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[1] === [1]</span>
false</pre>
<p class="indent">Both sides of the comparison look the same: both are <code>Vector</code>s and both contain the same single value with the same <code>Int64</code> type. And, as you can check, <code>1 === 1</code> is <code>true</code>.</p>
<p class="indent">The reason for the result in the listing just shown is that every time you create an array, you are creating a new object with its own location in memory. The two arrays on the two sides of the comparison are not identical because they reside at different memory addresses. It is possible to write a program that distinguishes between them, which is the formal criterion that forces the <code>===</code> comparison to yield <code>false</code>.</p>
<p class="indent">A number, in contrast, is just a number, with no particular location in memory. The integer <code>1</code> is always identical to itself.</p>
<p class="indent">This becomes clearer if we assign these objects to variables. If we make the assignments <code>v1 = [1]</code> and <code>v2 = [1]</code>, the comparison <code>v1 === v2</code> will yield <code>false</code>, while <code>v1 == v2</code> gives us <code>true</code>. The two variables have the same <em class="calibre11">values</em>, but are different objects. They are not identical. Think of the variables as references, or pointers, to the memory addresses where the arrays begin.</p>
<p class="indent">Arrays are <em class="calibre11">mutable</em>. Here is one consequence of the mutability of arrays:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">a = [1]</span>
   1-element Vector{Int64}:
    1

   julia&gt; <span class="codestrong">b = a</span>
   1-element Vector{Int64}:
    1

<span class="ent">➊</span> julia&gt; <span class="codestrong">b[1] = 7</span>
    7

<span class="ent">➋</span> julia&gt; <span class="codestrong">a</span>
   1-element Vector{Int64}:
    7

   julia&gt; <span class="codestrong">b === a</span>
   true</pre>
<p class="indent"><span epub:type="pagebreak" id="page_56"/>First we define <code>a</code> to be a <code>Vector</code> with one element. Then we set <code>b</code> to be equal to <code>a</code>. We then change <span class="ent">➊</span> the first (and only) element of <code>b</code> to be <code>7</code>. After that, when we take a look at <code>a</code> <span class="ent">➋</span>, we find that <em class="calibre11">it’s</em> changed, too. Its first element is now also <code>7</code>. The clue to why this happens is in the last line: <code>b</code> and <code>a</code> are not simply equal, they are <em class="calibre11">identical</em>. When we make the assignment <code>b = a</code> we make <code>b</code> point to the same memory address as <code>a</code>. The two variables are now pointers to, or names for, the same object. So if we change, or <em class="calibre11">mutate</em>, one, we see the same change in the other.</p>
<p class="indent">Some objects in Julia are <em class="calibre11">immutable</em>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">a = 1</span>
1

julia&gt; <span class="codestrong">b = a</span>
1

julia&gt; <span class="codestrong">b = 7</span>
7

julia&gt; <span class="codestrong">a</span>
1</pre>
<p class="indent">After making the assignments to <code>a</code> and <code>b</code>, they become alternative names for the numbers <code>1</code> and <code>7</code>. A table keeps track of the names we’ve given to values, and it lives somewhere in memory, but the variables are names for values, not for memory addresses.</p>
<p class="indent">In the second line, we tell Julia to also use <span class="codeitalic1">b</span> as a name for the number <code>1</code>. After that, we change our mind and want <code>b</code> to mean <code>7</code>, but that does not change the assignment of <code>a</code> as a name for <code>1</code>. You can’t mutate the number <code>1</code>. It will always be <code>1</code>, and has always been <code>1</code>. But you can mutate an array by changing what it contains.</p>
<h4 class="h3" id="ch02lev1sec17"><strong class="calibre2"><em class="calibre4">Functions That Mutate Their Arguments</em></strong></h4>
<p class="noindent">We can mutate an array by assigning directly to one of its elements with an indexing expression. We can also mutate an array by adding an element to its end, making it larger. We can always do this with concatenation. For <span epub:type="pagebreak" id="page_57"/>example, if <code>v</code> is a <code>Vector</code> of numbers, <code>v = [v; 7]</code> sticks the number 7 onto the end, increasing its length by one.</p>
<p class="indent">However, in calculations where we are going to be doing that many times, this is inefficient. If we get to a point where there is not enough room in memory to keep the elements of <code>v</code> contiguous, Julia will have to relocate it, perhaps repeatedly. A more efficient option is to use a built-in function made for this purpose. If we call <code>push! (v, 7)</code>, that mutates <code>v</code> just as in the concatenation version, but more efficiently. When <code>push!()</code> runs out of space, it moves the array and reserves memory for its later expansion. Every time it finds it needs to do this, it reserves a geometrically increasing amount of space. The function is designed to handle the common scenario of a loop in which an array is appended to in a time- and space-efficient manner.</p>
<p class="indent">The use of the exclamation point in the name <code>push!()</code> warns and reminds the user that this is a function that mutates its argument(s). It’s not part of the actual syntax, but a strongly held convention. Usually functions in Julia use their arguments as inputs to a calculation that returns a result: what we called “pure functions” earlier. Functions with <code>!</code> in the name change their arguments, and may or may not also return a result. The <code>push!()</code> function does return a result as well: the mutated array.</p>
<p class="indent">As the use of the exclamation point is a convention rather than a rule enforced by the language, it’s possible for any function to mutate its mutable arguments, but the convention is valuable, and Julia programmers are careful in following it.</p>
<p class="indent">The opposite of <code>push!()</code> is <code>pop!()</code>, which mutates its argument by removing its last element and returning that element as a result.</p>
<h4 class="h3" id="ch02lev1sec18"><strong class="calibre2"><em class="calibre4">Strings Are Immutable</em></strong></h4>
<p class="noindent">Although the <code>String</code> type is a collection, like <code>Vector</code>, <code>Matrix</code>, and the other array types, it is immutable.</p>
<p class="indent">We can index a string, but we can’t assign to its elements, because strings cannot be changed:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">s = "abc"</span>
"abc"

julia&gt; <span class="codestrong">s[1:2]</span>
"ab"

julia&gt; <span class="codestrong">s[3] = 'Z'</span>
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)</pre>
<p class="indent">This shows that we can index the string just as we index a vector, but we’re not allowed to change any of its elements.</p>
<p class="indent">If we want to make a new string, we have to define it literally or build it from parts of existing strings or from characters, using concatenation and <span epub:type="pagebreak" id="page_58"/>indexing. Here is a little function that takes a string and returns a decorative version of it:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function string_decorator(s)</span>
           <span class="codestrong">decorated = ""</span>
           <span class="codestrong">for char in s</span>
               <span class="codestrong">decorated = decorated * char * " • "</span>
           <span class="codestrong">end</span>
           <span class="codestrong">decorated[1:end-5]</span>
       <span class="codestrong">end</span>
string_decorator (generic function with 1 method)

julia&gt; <span class="codestrong">string_decorator("Julia")</span>
"J • u • l • i • a"</pre>
<p class="indent">The <code>end-5</code> in the last line of the function is there to omit the final bullet and the space before it—a bullet takes up four bytes.</p>
<p class="indent">In general, the technique used here of building up a string by repeatedly redefining it is a good idea only for small strings and limited numbers of redefinitions. Because strings are immutable, each time through the loop creates a new object, which is wasteful of memory.</p>
<p class="indent">Here’s how to write a function that performs the same task without creating a bunch of strings:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function better_string_decorator(s)</span>
           <span class="codestrong">a = String[]</span>
           <span class="codestrong">for char in s</span>
               <span class="codestrong">push!(a, char * " • ")</span>
           <span class="codestrong">end</span>
           <span class="codestrong">join(a)[1:end-5]</span>
       <span class="codestrong">end</span>
better_string_decorator (generic function with 1 method)

julia&gt; <span class="codestrong">better_string_decorator("PARTY!")</span>
"P • A • R • T • Y • !"</pre>
<p class="indent">The built-in <code>join()</code> function takes an array of strings and joins them together into one longer string. It will convert other types to strings if there is a sensible way to do so, which means <code>join([5, "6", 'X'])</code> returns <code>"56X"</code>.</p>
<p class="indent">A sort of opposite to <code>join()</code> is <code>split()</code>. This function takes a string and turns it into an array of shorter strings:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">split("a     b c")</span>
3-element Vector{SubString{String}}:
 "a"
 "b"
 "c"


julia&gt; <span class="codestrong">split("a||b||c", "||")</span>
3-element Vector{SubString{String}}:
 "a"
 "b"
 "c"</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_59"/>It splits on whitespace of any length, unless you supply a second argument in the form of a character or string. In that case, it will use the second argument as a delimiter; the delimiters themselves are discarded.</p>
<h3 class="h2" id="ch02lev9"><strong class="calibre2">Comments in Code</strong></h3>
<p class="noindent">An introduction to a language would not be complete without including the syntax for comments.</p>
<p class="indent">A single-line comment in Julia begins with a hash mark (<code>#</code>) and can appear on its own line or following a line of code. In other words, Julia ignores everything after a naked <code>#</code> character.</p>
<p class="indent">To include a multiline comment, begin it with <code>#=</code> and end it with <code>=#</code>.</p>
<h3 class="h2" id="ch02lev10"><strong class="calibre2">Congratulations</strong></h3>
<p class="noindent">If you’ve mastered everything in this chapter, you are now able to write useful Julia programs to solve many types of problems.</p>
<p class="indent">Most of the programs you write will not be completely self-contained, however. Modern programmers build solutions by combining their own code with functions from existing libraries written by others and by themselves. The next chapter will introduce a system built into Julia that helps you manage these libraries and your own programs.<span epub:type="pagebreak" id="page_60"/></p>
</body></html>