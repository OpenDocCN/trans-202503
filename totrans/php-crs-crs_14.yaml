- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 CREATING AND PROCESSING WEB FORMS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 创建与处理网页表单
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: After simple, clickable links, web forms are perhaps the most common way people
    interact with websites. In this chapter, we’ll look at how web clients can submit
    form data to server scripts, and we’ll create a range of web forms that send data.
    We’ll also practice writing server-side PHP scripts to extract and process the
    incoming form data. You’ll learn to handle data from a range of web-form elements,
    sent with both GET and POST HTTP requests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单、可点击的链接之后，网页表单可能是人们与网站互动的最常见方式。在本章中，我们将探讨网页客户端如何向服务器脚本提交表单数据，并创建一系列发送数据的网页表单。我们还将练习编写服务器端的
    PHP 脚本，以提取和处理传入的表单数据。你将学习如何处理来自各种网页表单元素的数据，并使用 GET 和 POST HTTP 请求发送这些数据。
- en: A *web form* is simply a portion of a web page that allows the user to enter
    data and then communicates that user input to server applications. Examples of
    web form interactions include creating a Facebook post, booking flights or entertainment
    tickets, and entering login information. As you’ll see, each form on a web page
    is defined between starting and ending HTML <form> tags. The form data might be
    text input by the user, or it might come from mechanisms like radio buttons, selections
    lists, or checkboxes. We’ll discuss how to work with all these types of input
    in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*网页表单*只是网页的一部分，允许用户输入数据，然后将用户输入传递给服务器应用程序。网页表单的交互实例包括创建 Facebook 帖子、预订航班或娱乐票、以及输入登录信息。如你所见，网页上的每个表单都在开始和结束的
    HTML <form> 标签之间定义。表单数据可能是用户输入的文本，或者可能来自单选按钮、选择列表或复选框等机制。本章将讨论如何处理这些不同类型的输入。'
- en: Basic Client/Server Communication for Web Forms
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网页表单的基本客户端/服务器通信
- en: Behind the typical web form lies a sequence of four messages between a web client
    (such as the user’s browser) and a web server, whereby the form is requested,
    received, submitted, and processed. [Figure 11-1](#fig11-1) summarizes these messages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的网页表单背后，是网页客户端（如用户的浏览器）与网页服务器之间四个消息的序列，其中表单被请求、接收、提交和处理。[图 11-1](#fig11-1)总结了这些消息。
- en: '![](../images/figure11-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-1.jpg)'
- en: 'Figure 11-1: The typical exchange of messages for displaying and processing
    a web form'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：显示和处理网页表单的典型消息交换
- en: First, the web browser client requests the HTML of the form from the server
    ❶. The user triggers this request through an action such as clicking a link or
    a button. Next, the server retrieves and, in some cases, customizes the HTML for
    the form and sends it back to the client ❷. Once the user has entered data and
    submitted the form, the form data is sent back to the server ❸. Finally, the server
    processes the received data, constructs an appropriate message for the user, and
    sends that message back ❹. This final message may be a simple confirmation of
    received data or an error message if an issue occurs, or it could be the original
    form with messages highlighting missing required data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，网页浏览器客户端从服务器请求表单的 HTML ❶。用户通过点击链接或按钮等操作触发此请求。接下来，服务器检索并在某些情况下定制表单的 HTML，然后将其发送回客户端
    ❷。用户输入数据并提交表单后，表单数据会发送回服务器 ❸。最后，服务器处理接收到的数据，构造适当的消息并发送回客户端 ❹。这个最终消息可以是简单的数据接收确认，或者如果发生问题则是错误消息，或者它可能是原始表单，表明缺少必填数据。
- en: '#### GET vs. POST Requests'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '#### GET 与 POST 请求'
- en: As mentioned in [Chapter 10](chapter10.xhtml), the two most common types of
    HTTP request sent from a client to a server are GET and POST. When you create
    an HTML form, you can send the data to the server with either type of request,
    since both GET and POST can send variables from the browser client to the web
    server as part of the request. In almost all cases, the data variables sent from
    web forms to the server are simple name/value pairs, such as username=matt or
    q=chocolate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 10 章](chapter10.xhtml)所述，从客户端发送到服务器的两种最常见的 HTTP 请求是 GET 和 POST。当你创建 HTML
    表单时，可以使用这两种请求中的任何一种将数据发送到服务器，因为 GET 和 POST 都可以将变量从浏览器客户端发送到网页服务器作为请求的一部分。在几乎所有情况下，从网页表单发送到服务器的数据变量都是简单的名称/值对，例如
    username=matt 或 q=chocolate。
- en: The request type you use comes down to the purposes of the form and how you
    want the form data to be sent. As you’ll see, the GET method makes the submission
    variables visible in the URL, while the POST method can hide the variables in
    the body of the HTTP request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的请求类型取决于表单的目的以及你希望表单数据如何发送。正如你将看到的，GET 方法会使提交的变量在 URL 中可见，而 POST 方法则可以将变量隐藏在
    HTTP 请求的主体中。
- en: Sending Data Visibly with GET
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 GET 发送数据
- en: An HTTP GET request is primarily for retrieving data or a web page from a server.
    While you can send data along with the request to help with this retrieval, a
    GET request should never result in changes to content stored on the server (such
    as modifications to values in a database).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP GET 请求主要用于从服务器获取数据或网页。虽然你可以在请求中发送数据以帮助检索，但 GET 请求不应导致服务器上存储的内容发生变化（例如，修改数据库中的值）。
- en: With a GET request, any variables the server needs to complete the request,
    including values submitted through web forms, are added to the end of the URL
    of the request, after a question mark character (?). This part of the URL after
    the question mark is known as a *query string*, and it will be visible in your
    browser’s address bar. The variables are encoded as name/value pairs in the form
    name=value, such as username=matt. For example, when you perform a search using
    Google or Bing, the terms you enter into the search engine’s web form are assigned
    to the variable q, added to a URL query string, and sent using a GET request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GET 请求中，服务器完成请求所需的任何变量，包括通过 Web 表单提交的值，都被添加到请求的 URL 末尾，紧跟着一个问号字符（?）。问号后面的这部分
    URL 被称为*查询字符串*，并且它将在浏览器的地址栏中可见。变量以名称/值对的形式进行编码，格式为 name=value，例如 username=matt。例如，当你使用
    Google 或 Bing 搜索时，输入的搜索词会被分配给变量 q，添加到 URL 查询字符串中，并通过 GET 请求发送。
- en: Say you use Google to search the phrase *cheese cake*. When you view the search
    results, you should see something like *https://www.google.com/search?q=cheese+cake*
    in the address bar. The single letter *q* represents your search query and is
    paired with the value you entered into Google’s web form. This indicates your
    query was passed to Google’s servers through a GET request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用 Google 搜索短语 *cheese cake*。当你查看搜索结果时，地址栏中应该会看到类似 *https://www.google.com/search?q=cheese+cake*
    的内容。单个字母 *q* 表示你的搜索查询，并与输入到 Google Web 表单中的值配对。这表明你的查询是通过 GET 请求传递给 Google 服务器的。
- en: Special rules define the characters allowed in a URL, and the variables sent
    via the HTTP GET method must follow these rules too. As a result, special characters
    and spaces can’t be represented verbatim in a query string but must instead be
    encoded as other symbols. For example, each space is replaced with either %20
    or a plus sign (+), which is why the Google search query string reads *q=cheese+cake*
    rather than *q=cheese cake*. When two or more variables are being encoded (for
    example, from separate fields in a form), the name/value pairs are separated by
    ampersand (&) characters, as in *?firstname=matt&lastname=smith*. The web browser
    will look after this sort of encoding automatically, but knowing about it is handy
    since it explains why you’ll often see cryptic, percent-encoded characters when
    sending form data with the GET method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊规则定义了 URL 中允许的字符，使用 HTTP GET 方法发送的变量也必须遵循这些规则。因此，特殊字符和空格不能在查询字符串中按原样表示，而必须编码为其他符号。例如，每个空格被替换为
    %20 或加号 (+)，这就是为什么 Google 搜索查询字符串显示为 *q=cheese+cake* 而不是 *q=cheese cake* 的原因。当编码两个或更多变量时（例如来自表单中不同字段的变量），名称/值对通过和符号（&）分隔，如
    *?firstname=matt&lastname=smith*。Web 浏览器会自动处理这种编码，但了解这一点很有用，因为它解释了为什么在使用 GET 方法发送表单数据时，你经常会看到一些加密的、百分号编码的字符。
- en: 'One common use of the GET method is to create a URL that’s easily bookmarked,
    perhaps to share with someone else via email or text message. The Google *cheese
    cake* query is one example: *https://www.google.com/search?q=cheese+cake*. Another
    example could be a Google Maps search, such as this one for Dublin, Ireland: *https://www.google.com/maps?q=dublin+ireland*.
    The variables in the URL can come from values entered into a web form, as is the
    case with a Google search, or they can be hardcoded by explicitly adding the question
    mark and the desired name/value pairs to the end of a URL.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GET方法的一个常见用途是创建一个易于书签保存的URL，可能是通过电子邮件或短信与他人分享。例如，Google的*芝士蛋糕*查询就是一个例子：*https://www.google.com/search?q=cheese+cake*。另一个例子可能是Google
    Maps搜索，例如这个指向爱尔兰都柏林的链接：*https://www.google.com/maps?q=dublin+ireland*。URL中的变量可以来自用户输入的值（如Google搜索的情况），也可以通过明确添加问号和所需的名称/值对到URL的末尾来硬编码。
- en: '[Figure 11-2](#fig11-2) shows an example of the latter, where clicking the
    COMP H2029 -FT link initiates a GET request that includes the name/value pair
    id=1499 in the query string. This id value doesn’t come from user input but rather
    was hardcoded into the logic of the website.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](#fig11-2)展示了后者的例子，点击COMP H2029 -FT链接会发起一个GET请求，其中包括查询字符串中的名称/值对id=1499。这个id值不是来自用户输入，而是硬编码在网站的逻辑中。'
- en: '![](../images/figure11-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-2.jpg)'
- en: 'Figure 11-2: A link with a hardcoded value to be sent via the GET request method'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：一个带有硬编码值的链接，通过GET请求方法发送
- en: A web server doesn’t care how a GET request is created. Whether the query-string
    variables come from form submissions or were hardcoded, the name/value pairs can
    be extracted by a server-side script for processing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器不关心GET请求是如何创建的。无论查询字符串变量来自表单提交还是硬编码，服务器端脚本都可以提取这些名称/值对进行处理。
- en: Sending Data Invisibly with POST
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用POST隐形发送数据
- en: HTTP POST requests send data primarily for the purposes of creating or modifying
    a resource on a server. With the POST method, you can send variables in the body
    of the HTTP message, meaning they won’t be seen in the resulting URL. For any
    confidential data like usernames and passwords, you should use POST requests so
    that people looking at the screen can’t see the data values being sent to the
    server. In fact, most web forms send their data by using the POST method. [Figure
    11-3](#fig11-3) illustrates a POST method login form.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP POST请求主要用于创建或修改服务器上的资源。使用POST方法，你可以将变量发送到HTTP消息的主体中，这意味着它们不会出现在结果URL中。对于任何机密数据，比如用户名和密码，你应该使用POST请求，以便屏幕上的人无法看到发送到服务器的数据值。事实上，大多数网页表单都使用POST方法发送数据。[图11-3](#fig11-3)展示了一个POST方法的登录表单。
- en: '![](../images/figure11-3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-3.jpg)'
- en: 'Figure 11-3: POST method variables in the request body'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：POST方法在请求主体中的变量
- en: In this example, I’ve tried to log in to a site with a username of matt and
    a password of smith. The browser’s HTTP message inspection tool reveals that the
    username and password values were sent in the body of the HTTP POST request. These
    values therefore don’t appear as part of the URL in the address bar.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我尝试用用户名matt和密码smith登录一个网站。浏览器的HTTP消息检查工具显示，用户名和密码值是作为HTTP POST请求的主体发送的。因此，这些值并未出现在地址栏的URL中。
- en: NOTE
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*A* POST *request can send data directly in the query string, like a* GET *request,
    as well as in the request body. We’ll explore* POST *requests that do both in
    “Sending Noneditable Data Along with Form Variables” on [page 206](#pg_206).*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个*POST*请求可以像*GET*请求一样，直接在查询字符串中发送数据，也可以在请求主体中发送数据。我们将在《发送不可编辑数据和表单变量一起发送》一节中探讨*POST*请求的两种方式，详见[第206页](#pg_206)。*'
- en: A Simple Example
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: To more clearly understand how the GET and POST methods send data differently,
    let’s build a simple site with a web form consisting of a single text box where
    the user can enter their name (see [Figure 11-4](#fig11-4)). We’ll try passing
    data from the form by using both HTTP methods. As you’ll see, we can choose which
    method to use whenever we create an HTML <form> element.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解GET和POST方法如何以不同方式发送数据，我们来构建一个简单的网站，其中包含一个只有单一文本框的表单，用户可以在其中输入他们的名字（见[图11-4](#fig11-4)）。我们将尝试使用这两种HTTP方法从表单传递数据。正如你所见，在创建HTML
    <form>元素时，我们可以选择使用哪种方法。
- en: '![](../images/figure11-4.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-4.jpg)'
- en: 'Figure 11-4: A simple web form displayed in the browser'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-4：浏览器中显示的简单网页表单
- en: Our project will consist of a *public* folder containing two PHP script files,
    *index.php* and *process.php*. Here, *index.php* is the default home-page script
    that will display the form, and *process.php* will receive the name submitted
    by the user from the index page and generate a *Hello <name>* message in response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将包含一个*public*文件夹，其中包含两个PHP脚本文件，*index.php*和*process.php*。其中，*index.php*是默认的主页脚本，用于显示表单，而*process.php*将接收用户在主页提交的姓名，并生成一个*Hello
    <name>*消息作为响应。
- en: Creating a Form with the GET Method
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用GET方法创建表单
- en: We’ll start with the GET version of our simple web form. Create a new project
    with a *public* folder, and inside that folder create a new PHP script file named
    *index.php*. Enter the code shown in [Listing 11-1](#lis11-1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单网页表单的GET版本开始。创建一个新的项目，并在该项目的*public*文件夹中创建一个名为*index.php*的新的PHP脚本文件。输入[示例
    11-1](#lis11-1)中显示的代码。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: The HTML code for a simple web form using the GET method'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1：使用GET方法的简单网页表单的HTML代码
- en: The file consists entirely of HTML template text, including a <form> element
    that defines the web form. We use the element’s method attribute to declare that
    the form data should be submitted with the GET HTTP method, and the action attribute
    to specify that the HTTP request and its data should be sent to the *process.php*
    server script. Note that the GET or POST values of the method HTML form attribute
    are case insensitive, so we could also write method="get".
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件完全由HTML模板文本组成，包括一个定义网页表单的<form>元素。我们使用该元素的method属性声明表单数据应使用GET HTTP方法提交，并使用action属性指定HTTP请求及其数据应发送到*process.php*服务器脚本。请注意，HTML表单的method属性中的GET或POST值是不区分大小写的，因此我们也可以写method="get"。
- en: Within the form, we create an <input> element and give it a name of firstName.
    We also create a second <input> element with a type of submit to add a Submit
    button to the form. Since we don’t specify the type of the firstName input, HTML
    5 automatically defines the default form input type to be a text box. Text boxes
    are displayed to the user as rectangular input boxes. If you wanted to explicitly
    declare the type of input, you could do so via <input type="text" name="firstName">.
    You could go further and set the character width of the text box and other specs
    by using the various optional attributes for each type of HTML form input.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单内，我们创建一个<input>元素并为其指定名称为firstName。我们还创建第二个<input>元素，类型为submit，以向表单中添加一个提交按钮。由于我们没有指定firstName输入的类型，HTML
    5会自动将默认的表单输入类型定义为文本框。文本框会以矩形输入框的形式显示给用户。如果你想明确声明输入类型，可以通过<input type="text" name="firstName">来实现。你还可以进一步设置文本框的字符宽度和其他规格，使用各种HTML表单输入的可选属性。
- en: 'Since our form inputs only a single value, we don’t need to bother displaying
    a text label to the user. However, when several input controls are present, you
    should precede each with a prompt so that the user knows which text box (or radio
    button or other input type) relates to which value. For example, if we wanted
    the user to input an age, we might write the template text Age: and then the form
    input, like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的表单只输入一个值，我们不需要向用户显示文本标签。然而，当表单包含多个输入控件时，应在每个输入框前加上提示，以便用户知道哪个文本框（或单选按钮或其他输入类型）对应哪个值。例如，如果我们想让用户输入年龄，可能会写上模板文本Age:，然后是表单输入，像这样：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modern HTML good practice would also require us to add an id attribute to the
    age input with <input name="age" id="age"> and a <label> element around the template
    text with <label for="age">Age:</label>. This allows the user to click either
    the label or the text box to make age the active form input.  ##### Processing
    the GET Request'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现代HTML的最佳实践还要求我们为年龄输入添加id属性，使用<input name="age" id="age">，并使用<label>元素包围模板文本，使用<label
    for="age">Age:</label>。这允许用户点击标签或文本框，使年龄成为活动的表单输入。##### 处理GET请求
- en: We’ve created an HTML web form, but our work is only half done; we also need
    to write the *process.php* script to handle the data submitted through the form.
    All we need to know when writing processing scripts for simple forms is the name
    of the variable the script is to receive and whether that variable was submitted
    through the query string (as with the GET method) or in the request body (as with
    the POST method).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个HTML网页表单，但我们的工作才完成一半；我们还需要编写*process.php*脚本来处理通过表单提交的数据。在编写简单表单的处理脚本时，我们只需要知道脚本将接收的变量名称，以及该变量是通过查询字符串（如GET方法）提交的，还是通过请求体（如POST方法）提交的。
- en: In this case, the script should attempt to find a value for the firstName variable
    in the query string received from the GET request and then output HTML to present
    to the user a greeting featuring that name. Add *process.php* to the *public*
    folder of your project and enter the code in [Listing 11-2](#lis11-2).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，脚本应该尝试从通过 GET 请求接收到的查询字符串中查找 firstName 变量的值，然后输出 HTML 以显示包含该名称的问候语。将
    *process.php* 文件添加到项目的 *public* 文件夹中，并在其中输入 [示例 11-2](#lis11-2) 中的代码。
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-2: A process.php server script to respond to the web form'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2：一个 process.php 服务器脚本，用于响应 Web 表单
- en: 'Notice that we use two kinds of comments in this script, since it mixes two
    languages: a PHP comment starting with // and an HTML <!-- comment. Inside the
    initial PHP code block, we call the filter_input() function to read data from
    the incoming HTTP request, storing the result in the $firstName variable ❶. The
    INPUT_GET argument specifies that we want to read data embedded directly in the
    URL query string, and the ''firstName'' argument identifies the specific HTML
    form variable we’re looking for. Form input variable names are case sensitive,
    so it’s important to carefully match the variable names defined in HTML forms
    when calling the filter_input() function. If we passed ''firstname'' rather than
    ''firstName'' as a function argument, for example, the script wouldn’t work. When
    passing the value of a form variable along to a PHP variable, as we’re doing here,
    it’s generally good practice to give the PHP variable the same name as the corresponding
    form variable.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这个脚本中使用了两种类型的注释，因为它混合了两种语言：一个以 // 开头的 PHP 注释和一个 HTML 注释 <!--。在最初的 PHP
    代码块中，我们调用了 filter_input() 函数来读取来自 HTTP 请求的数据，并将结果存储在 $firstName 变量中 ❶。INPUT_GET
    参数指定我们要读取嵌入在 URL 查询字符串中的数据，而 'firstName' 参数标识我们要查找的特定 HTML 表单变量。表单输入变量名是区分大小写的，因此在调用
    filter_input() 函数时，务必要小心匹配 HTML 表单中定义的变量名。例如，如果我们传递的是 'firstname' 而不是 'firstName'，脚本就无法正常工作。当将表单变量的值传递给
    PHP 变量时，像我们这里所做的那样，通常的良好实践是给 PHP 变量与对应表单变量相同的名称。
- en: Next, we declare the HTML that should be sent in response to the form submission.
    This includes the template text Hello followed by the value of the $firstName
    variable inside PHP short echo tags ❷.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明应该作为响应发送的 HTML，这包括模板文本 Hello，后面跟着 PHP 短标签内的 $firstName 变量值 ❷。
- en: NOTE
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* INPUT_GET *argument to* filter_input() *is somewhat misleadingly named.
    Its purpose is to retrieve data from the URL query string, regardless of whether
    that data was sent via the* GET *method (where all variables are part of the query
    string) or via the* POST *method (where data can be either in the query string
    or in the request body). Therefore, when you see* GET *while working on form-processing
    code in PHP, interpret this as* query-string variables *and don’t necessarily
    assume they came from a* GET *request.*  ##### Testing the Form'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*INPUT_GET* 参数传递给 *filter_input()* 函数时，其名称可能会让人误解。它的目的是从 URL 查询字符串中检索数据，无论这些数据是通过
    *GET* 方法（所有变量都是查询字符串的一部分）还是通过 *POST* 方法（数据可以在查询字符串中，也可以在请求体中）发送的。因此，当你在 PHP 表单处理代码中看到
    *GET* 时，应将其理解为 *查询字符串变量*，而不必假设它们来自 *GET* 请求。##### 测试表单'
- en: 'Now that we’ve created the web form in *index.php* and written the *process.php*
    script to respond to it, let’s test our work. Launch the PHP web server at the
    command line by using the php -S localhost:8000 -t public command, as discussed
    in [Chapter 10](chapter10.xhtml); then open a browser tab to *localhost:8000*.
    The form we’ve created should be displayed by default since the file is named
    *index.php*. You’ll see something like the form in [Figure 11-4](#fig11-4): a
    text box with a Submit button.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 *index.php* 中创建了 Web 表单，并编写了 *process.php* 脚本来响应它，接下来让我们测试一下我们的工作。通过命令行启动
    PHP Web 服务器，使用 php -S localhost:8000 -t public 命令，如 [第 10 章](chapter10.xhtml)
    中所讨论的那样；然后打开浏览器标签页并访问 *localhost:8000*。默认情况下，我们创建的表单应该会显示出来，因为文件名是 *index.php*。你将看到类似于
    [图 11-4](#fig11-4) 中的表单：一个带有提交按钮的文本框。
- en: Enter your name into the form, then click **Submit**. When you do, the text
    entered should be sent as part of an HTTP GET request from the browser to the
    PHP server. The GET request triggers the server to execute the *process.php* script,
    as declared in the action attribute of the HTML <form> element in *index.php*.
    This script extracts the submitted value and injects it into its HTML template
    text, which is then added to the text buffer that becomes the body of the HTTP
    response message the server sends back to the requesting client (the web browser).
    You should see something like [Figure 11-5](#fig11-5) as a result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中输入你的姓名，然后点击 **提交**。此时，输入的文本应作为 HTTP GET 请求的一部分从浏览器发送到 PHP 服务器。GET 请求触发服务器执行
    *process.php* 脚本，如 HTML <form> 元素中的 action 属性在 *index.php* 中所声明。该脚本提取提交的值并将其注入到
    HTML 模板文本中，然后将其添加到文本缓冲区，这些文本最终成为服务器发送回请求客户端（即网页浏览器）的 HTTP 响应消息的正文。你应该看到类似 [图 11-5](#fig11-5)
    的结果。
- en: '![](../images/figure11-5.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-5.jpg)'
- en: 'Figure 11-5: The result of the process.php script, confirming the data received
    through the form'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：process.php 脚本的结果，确认通过表单接收到的数据
- en: You see your name not only in the greeting displayed on the page (such as *Hello
    matt* in the figure) but also at the end of the URL in the browser’s address bar,
    because the form is submitted via a GET request. For example, the URL I get when
    I submit matt through the form is *localhost:8000/process.php?firstName=matt*.
    This indicates the GET request is trying to access the *process.php* script and
    pass it a firstName variable with a value of matt. Notice the question mark separating
    the query string from the rest of the URL.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅在页面显示的问候语中看到自己的名字（例如图中的 *Hello matt*），还可以在浏览器地址栏的 URL 末尾看到它，因为表单是通过 GET 请求提交的。例如，当我通过表单提交
    matt 时，得到的 URL 是 *localhost:8000/process.php?firstName=matt*。这表明 GET 请求正尝试访问 *process.php*
    脚本，并传递一个值为 matt 的 firstName 变量。注意，问号将查询字符串与 URL 其余部分分开。
- en: Switching to the POST Method
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切换到 POST 方法
- en: Let’s modify our project to send the form data with the POST method rather than
    GET and see what difference it makes. Only a few minor changes are needed. First,
    update the *index.php* script as shown in [Listing 11-3](#lis11-3).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的项目，改用 POST 方法发送表单数据，而非 GET，看看会有什么不同。只需做几个小修改。首先，更新 *index.php* 脚本，如
    [列表 11-3](#lis11-3) 所示。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-3: Switching from GET to POST in index.php'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-3：在 index.php 中从 GET 切换到 POST
- en: 'We now declare the method of the <form> element to be POST. That’s it: no further
    changes are required to the index script to ensure that the web browser uses the
    POST method instead of GET to submit the form data. Next, update *process.php*
    as shown in [Listing 11-4](#lis11-4).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 <form> 元素的 method 声明为 POST。就这样：无需对 index 脚本做进一步修改，确保网页浏览器使用 POST 方法而非
    GET 提交表单数据。接下来，更新 *process.php*，如 [列表 11-4](#lis11-4) 所示。
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-4: Switching from GET to POST in process.php'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：在 process.php 中从 GET 切换到 POST
- en: 'This is another simple change: all we have to do is pass INPUT_POST rather
    than INPUT_GET as an argument to filter_input() to tell the function to look for
    a variable submitted in the body of the request with POST.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个简单的更改：我们只需将 INPUT_GET 改为 INPUT_POST 作为 filter_input() 的参数，告诉该函数在请求体中查找通过
    POST 提交的变量。
- en: Try running the web server and submitting your name through the form again.
    You should still see the same *Hello <name>* greeting as before. If you look a
    little closer, however, you’ll see some key differences, as shown in [Figure 11-6](#fig11-6).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新运行 web 服务器，并再次通过表单提交你的姓名。你应该仍然会看到与之前相同的 *Hello <name>* 问候语。然而，如果你仔细查看，你会看到一些关键的不同之处，如
    [图 11-6](#fig11-6) 所示。
- en: '![](../images/figure11-6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-6.jpg)'
- en: 'Figure 11-6: Viewing the HTTP POST request and the firstName variable with
    the browser developer tools'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：使用浏览器开发者工具查看 HTTP POST 请求和 firstName 变量
- en: First, the URL in the browser’s address bar should read just *localhost:8000/
    process.php*. Because the firstName form variable is now being sent in the request
    body with POST, it no longer appears in the URL query string for all to see. You
    can verify that the variable is still being transmitted by viewing the request
    with the browser’s developer tools. In this example, I submitted the name Fred
    through the form, and you can see in [Figure 11-6](#fig11-6) that, indeed, the
    form data variable firstName=Fred is shown in the body of the POST request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，浏览器地址栏中的 URL 应该只显示 *localhost:8000/ process.php*。因为 firstName 表单变量现在通过 POST
    请求体发送，它不再出现在所有人都能看到的 URL 查询字符串中。你可以通过查看浏览器的开发者工具来验证变量是否仍然被传输。在这个例子中，我通过表单提交了名字
    Fred，你可以在 [图 11-6](#fig11-6) 中看到，确实，表单数据变量 firstName=Fred 显示在 POST 请求的请求体中。
- en: The filter_input() Function
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter_input() 函数
- en: Our simple web form project illustrated how to receive incoming form data by
    using PHP’s filter_input() function. This function makes it easy to extract values
    submitted with the GET and POST methods. Writing form-processing scripts wasn’t
    always so simple, however; in older versions of PHP, the usual way to extract
    data received from the user was to access one or both of the built-in $_GET and
    $_POST *superglobal arrays*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单网页表单项目演示了如何使用 PHP 的 filter_input() 函数接收传入的表单数据。这个函数使得提取通过 GET 和 POST 方法提交的值变得容易。然而，编写表单处理脚本并不总是如此简单；在较早的
    PHP 版本中，从用户接收的数据通常是通过访问内建的 $_GET 和 $_POST *超全局数组* 来提取的。
- en: The $_GET array contains key/value pairs representing all the variables received
    as part of the URL query string, while the $_POST array contains key/value pairs
    representing all the variables received via the POST HTTP method. For instance,
    submitting the first name Matt through the GET request version of our simple web
    form would produce a $_GET array containing ['firstName' => 'Matt'] and an empty
    $_POST array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: $_GET 数组包含表示作为 URL 查询字符串一部分接收到的所有变量的键/值对，而 $_POST 数组包含表示通过 POST HTTP 方法接收到的所有变量的键/值对。例如，通过
    GET 请求提交名字 Matt 的简单网页表单将产生一个包含 ['firstName' => 'Matt'] 的 $_GET 数组，以及一个空的 $_POST
    数组。
- en: NOTE
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* $_GET *and* $_POST *arrays are examples of PHP’s* superglobals*. These
    are arrays that always exist and that can be accessed from anywhere in your PHP
    code (that is, from any scope), including inside functions and class methods.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*$_GET* 和 *$_POST* 数组是 PHP 的*超全局变量*的例子。这些数组总是存在的，可以从 PHP 代码的任何地方（即任何作用域中），包括函数和类方法内部访问。'
- en: Even in modern PHP programming, extracting form data from these two superglobal
    arrays is still theoretically possible. But PHP version 5.2 introduced the filter_input()
    function as a much better way of accessing submitted data. To illustrate the improvement,
    let’s look at what it takes to work with these superglobal arrays.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在现代 PHP 编程中，从这两个超全局数组中提取表单数据仍然在理论上是可能的。但 PHP 5.2 版本引入了 filter_input() 函数，作为访问提交数据的更好方法。为了说明这一改进，让我们来看一下处理这些超全局数组的过程。
- en: In [Chapter 7](chapter7.xhtml), you learned that trying to access a nonexistent
    key in an array will trigger a warning, which you can avoid by using the isset()
    function to verify that an array key exists before accessing its value. This kind
    of test makes scripts more robust and error-proof, and it’s especially important
    when working directly with the $_GET and $_POST arrays. Unfortunately, such a
    test also adds extra code to a script. For example, [Listing 11-5](#lis11-5) illustrates
    how to safely retrieve a $firstName variable from the $_GET array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](chapter7.xhtml) 中，你已经学到，尝试访问数组中不存在的键将触发警告，你可以通过使用 isset() 函数来验证数组键是否存在，以避免这种警告。进行这种测试可以使脚本更健壮，减少错误，尤其是在直接处理
    $_GET 和 $_POST 数组时更为重要。不幸的是，这种测试也会向脚本中添加额外的代码。例如，[示例 11-5](#lis11-5) 演示了如何安全地从
    $_GET 数组中提取 $firstName 变量。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-5: Testing an array key with isset() before attempting to extract
    a value from $_GET'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-5：在尝试从 $_GET 中提取值之前，使用 isset() 测试数组键
- en: We use isset() in an if...else statement to check whether the 'firstName' key
    exists in the $_GET array (indicating that a firstName form variable was submitted
    through the incoming query string). If the key exists, we pass on its value to
    the $firstName variable. Otherwise, we set $firstName to NULL. This if...else
    statement saves us from getting a warning if we naively access a nonexistent value
    in the array.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在if...else语句中使用isset()来检查$_GET数组中是否存在'firstName'键（表示通过传入的查询字符串提交了firstName表单变量）。如果该键存在，我们将其值传递给$firstName变量。否则，我们将$firstName设置为NULL。这个if...else语句可以避免我们在没有警告的情况下直接访问数组中不存在的值。
- en: 'Listing 11-5 will work fine, but it represents such a common series of actions
    in PHP form-processing code that filter_input() was introduced to encapsulate
    it. Our entire if...else statement can therefore be replaced with a single statement:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5 将正常工作，但它表示了PHP表单处理代码中一个常见的动作序列，因此引入了filter_input()函数来封装这一过程。因此，我们的整个if...else语句可以用一句话来替换：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The filter_input() function automatically checks whether the desired variable
    exists before trying to access it and typically returns NULL if it doesn’t. This
    spares us from writing clunky conditional tests like the one in [Listing 11-5](#lis11-5).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: filter_input()函数会在尝试访问变量之前自动检查所需的变量是否存在，如果不存在，通常会返回NULL。这使我们免去了像[列表 11-5](#lis11-5)中那样编写繁琐的条件测试。
- en: 'An additional advantage of the filter_input() function is that it can use filters
    to ignore and remove unwanted and potentially dangerous content from the received
    form data. This helps prevent security vulnerabilities such as cross-site scripting
    attacks. For example, to filter out (discard) any nonalphabetic characters from
    the user input, we could add a third argument of FILTER_SANITIZE_SPECIAL_CHARS
    to the filter_input() call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: filter_input()函数的另一个优点是，它可以使用过滤器忽略并移除接收到的表单数据中的不需要的和潜在危险的内容。这有助于防止安全漏洞，如跨站脚本攻击。例如，为了过滤掉（丢弃）用户输入中的任何非字母字符，我们可以在filter_input()调用中添加一个第三个参数FILTER_SANITIZE_SPECIAL_CHARS：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Other Ways to Send Data
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送数据的其他方式
- en: Taking user input through a web form isn’t the only way to send data via an
    HTTP request. In this section, we’ll consider other techniques for transmitting
    data to a server. We’ll look at how to embed noneditable data into a query string
    for submission along with user-entered form data, how to send data about the form’s
    Submit button itself, and how to add query-string variables to a regular hyperlink,
    separate from any web form. Along the way, you’ll also see how to process a mixture
    of query string and POST variables, and how to harness PHP arrays and loops to
    generate query-string variables programmatically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网页表单获取用户输入并不是通过HTTP请求发送数据的唯一方式。在本节中，我们将考虑其他将数据传输到服务器的技术。我们将研究如何将不可编辑的数据嵌入查询字符串中，以便与用户输入的表单数据一起提交，如何发送关于表单提交按钮本身的数据，以及如何将查询字符串变量添加到常规超链接中，独立于任何网页表单。过程中，你还将看到如何处理查询字符串和POST变量的混合，以及如何利用PHP数组和循环以编程方式生成查询字符串变量。
- en: Sending Noneditable Data Along with Form Variables
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与表单变量一起发送不可编辑数据
- en: Often you’ll want a web form to send extra data that the user can’t edit. Perhaps
    the most common example occurs when the user, maybe an employee, is editing details
    for an item in a database. The item, which might be a record about a product or
    a customer, already has an assigned ID that should be included with the form data,
    but the ID itself should never be changed via the form. For these cases, you can
    send the noneditable values as query-string variables at the end of the URL in
    the form’s action attribute (for example, action="/process.php?id=1022").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望网页表单发送一些用户无法编辑的额外数据。最常见的例子可能是用户（也许是员工）正在编辑数据库中某个项的详细信息。这个项可能是有关产品或客户的记录，它已经有一个分配的ID，这个ID应该包含在表单数据中，但ID本身不应通过表单进行更改。对于这种情况，你可以将不可编辑的值作为查询字符串变量通过表单的action属性（例如，action="/process.php?id=1022"）在URL的末尾发送。
- en: To illustrate, let’s create a new web form for submitting information about
    movies. Start a new project containing a *public* folder and create an *index.php*
    script within it. Then enter the HTML code in [Listing 11-6](#lis11-6) to create
    the web form.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，假设我们创建一个新的网页表单，用于提交关于电影的信息。启动一个新的项目，其中包含一个*public*文件夹，并在其中创建一个*index.php*脚本。然后输入[列表
    11-6](#lis11-6)中的HTML代码以创建网页表单。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-6: The HTML code for a movie form in index.php'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：index.php中电影表单的HTML代码
- en: 'We declare a form using the POST method ❶. (In a more realistic scenario, this
    form would likely result in changes to a record in a database, so POST rather
    than GET is the appropriate method here.) For the form’s action attribute, we
    specify that the script to process the form is *process.php*, and we also send
    a URL query-string variable named id with a hardcoded value of 1022. When the
    form is submitted, this extra name/value pair will be visible in the resulting
    URL itself (much like data sent with the GET method). Meanwhile, the form will
    also send two variables with user-entered values in the body of the POST request:
    title ❷ and price ❸.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 POST 方法声明了一个表单 ❶。（在更现实的场景中，这个表单很可能会导致数据库中记录的更改，因此此处使用 POST 而非 GET 方法是合适的。）对于表单的
    action 属性，我们指定了处理表单的脚本为 *process.php*，并且还发送了一个名为 id 的 URL 查询字符串变量，值为硬编码的 1022。当表单提交时，这个额外的名称/值对将在生成的
    URL 中可见（就像使用 GET 方法发送的数据一样）。同时，表单还会将用户输入的两个变量 title ❷ 和 price ❸ 作为 POST 请求体中的数据发送。
- en: Processing Mixed Query-String and POST Variables
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理混合查询字符串和 POST 变量
- en: Now let’s write the *process.php* script to receive and extract data from this
    movie form. Unlike our earlier form-processing script, this one needs to extract
    multiple variables from the incoming POST request, including the id variable sent
    through the query string and the title and price variables embedded in the request
    body. Add *process.php* to your project’s *public* folder and enter the code in
    [Listing 11-7](#lis11-7).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写 *process.php* 脚本来接收并提取来自此电影表单的数据。与我们早期的表单处理脚本不同，这个脚本需要从传入的 POST 请求中提取多个变量，包括通过查询字符串发送的
    id 变量和嵌入在请求体中的 title 和 price 变量。将 *process.php* 添加到项目的 *public* 文件夹中，并在其中输入 [列表
    11-7](#lis11-7) 中的代码。
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-7: The PHP server script to process the movie form'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：处理电影表单的 PHP 服务器脚本
- en: We use the filter_input() function with the INPUT_GET argument to read the id
    query-string variable into the corresponding PHP variable, $id. (Remember, INPUT_GET
    simply means we’re reading data from the query string, even if that data was sent
    with the POST method rather than GET. The actual method of the HTTP request makes
    little difference from the server-side script’s perspective.) Then we use filter_input()
    twice more with INPUT_POST to read the two values from the request body into the
    $title and $price variables. After some basic HTML page tags, we output each variable’s
    name and value by using PHP short echo tags, separating them with HTML <br> line
    breaks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 filter_input() 函数，并带上 INPUT_GET 参数，将 id 查询字符串变量读取到对应的 PHP 变量 $id 中。（记住，INPUT_GET
    只是意味着我们正在从查询字符串读取数据，即使这些数据是通过 POST 方法而非 GET 方法发送的。从服务器端脚本的角度来看，HTTP 请求的实际方法差别不大。）然后我们再使用
    filter_input() 函数两次，带上 INPUT_POST，将请求体中的两个值读取到 $title 和 $price 变量中。经过一些基础的 HTML
    页面标签后，我们通过 PHP 短 echo 标签输出每个变量的名称和值，用 HTML <br> 换行符分隔。
- en: '[Figure 11-7](#fig11-7) shows how the *process.php* script handles the incoming
    form data.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#fig11-7) 显示了 *process.php* 脚本如何处理传入的表单数据。'
- en: '![](../images/figure11-7.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-7.jpg)'
- en: 'Figure 11-7: An HTTP request sending query-string and POST variables'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：发送查询字符串和 POST 变量的 HTTP 请求
- en: In this example, I filled in The Lost World in the title field of the form and
    9.99 in the price field. The output in the browser shows these values echoed back,
    along with the id value of 1022 that we hardcoded into the query string. You should
    also see the id variable in the URL in the browser’s address bar, and if you view
    the request with the browser developer tools, you should see id listed as a query-string
    parameter, while title and price are listed as form data variables in the request
    body.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我在表单的标题字段中填写了《失落的世界》，在价格字段中填写了 9.99。浏览器中的输出显示了这些值的回显，以及我们在查询字符串中硬编码的
    id 值 1022。你还应该在浏览器的地址栏中看到 URL 中的 id 变量，如果使用浏览器开发者工具查看请求，你会看到 id 被列为查询字符串参数，而 title
    和 price 被列为请求体中的表单数据变量。
- en: Offering Multiple Submit Buttons
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供多个提交按钮
- en: Another way to send data through a form is to give a name attribute to the form’s
    Submit button. This is especially useful when you want a form to feature multiple
    Submit buttons so the user can choose how to process the data in a form.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过表单发送数据的另一种方式是给表单的提交按钮添加一个 name 属性。当你希望表单包含多个提交按钮时，这种方式尤其有用，因为用户可以选择如何处理表单中的数据。
- en: For example, a customer renting an online movie might want to pay for it and
    immediately start watching it, or they might want to pay for it but start watching
    later. Each option could be triggered by a different Submit button, as illustrated
    in [Figure 11-8](#fig11-8). The server-side script can then detect the name of
    the button the user clicked and respond accordingly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，租用在线视频的客户可能希望支付费用后立即开始观看，或者他们可能希望先支付费用，但稍后再观看。每个选项都可以通过不同的提交按钮触发，如 [图 11-8](#fig11-8)
    所示。服务器端脚本可以检测用户点击的按钮名称，并作出相应的响应。
- en: '![](../images/figure11-8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-8.jpg)'
- en: 'Figure 11-8: Two Submit buttons for the same form'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8：同一表单的两个提交按钮
- en: Let’s design such a form with multiple Submit buttons. Create a new project
    containing a *public* folder with a PHP script file named *index.php*, and enter
    the code in [Listing 11-8](#lis11-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个带有多个提交按钮的表单。创建一个新项目，其中包含一个名为 *index.php* 的 PHP 脚本文件，并在其中输入 [列表 11-8](#lis11-8)
    中的代码。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-8: The HTML code for a form with two Submit buttons'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-8：带有两个提交按钮的表单 HTML 代码
- en: First, we read in the Bootstrap CSS stylesheet ❶. This allows us to style the
    submit-type inputs to look like nice green buttons by using class="btn btn-success"
    without having to write any CSS code ourselves. Then we set up a form using the
    POST method since this form submits data that would likely lead to changes on
    the server (processing the payment and recording the movie as being rented by
    the user) ❷. Notice that we’ve hardcoded a movieID variable into the query string
    through the form’s action attribute, much as in the previous movie form example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入了 Bootstrap CSS 样式表 ❶。这使得我们可以通过使用 class="btn btn-success" 来将提交类型的输入框样式化为漂亮的绿色按钮，而无需自己编写任何
    CSS 代码。然后我们使用 POST 方法设置表单，因为该表单提交的数据可能会导致服务器上的更改（处理支付并记录电影被用户租用） ❷。注意，我们通过表单的
    action 属性将 movieID 变量硬编码到查询字符串中，就像前面的电影表单示例一样。
- en: We give the form input fields for the user’s credit card information, and then
    we define two Submit buttons, one with a name attribute of watchNow ❸ and the
    other with a name attribute of watchLater ❹. These buttons also have value attributes
    to define the text that will appear in each button. Thanks to these buttons’ name
    attributes, when one of them is clicked, its name and value will be sent as a
    key/value pair in the body of the POST request along with the other form data.
    For example, if the user clicks the watchNow button, a watchNow=Pay and start
    watching now will be sent with the request. The value portion is of little significance,
    but the server-side script can check for a key of watchNow among the form data
    to determine which Submit button was clicked. [Listing 11-9](#lis11-9) shows a
    *process.php* file that does just that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为表单提供了用户信用卡信息的输入字段，然后定义了两个提交按钮，一个具有 watchNow ❸ 的 name 属性，另一个具有 watchLater
    ❹ 的 name 属性。这些按钮还具有 value 属性，用于定义每个按钮上显示的文本。由于这些按钮的 name 属性，当其中一个按钮被点击时，它的 name
    和 value 会作为键/值对与其他表单数据一起发送到 POST 请求的主体中。例如，如果用户点击 watchNow 按钮，将会发送 watchNow=Pay
    and start watching now 的请求。值部分意义不大，但服务器端脚本可以检查表单数据中是否包含 watchNow 键，以确定点击了哪个提交按钮。[列表
    11-9](#lis11-9) 显示了一个 *process.php* 文件，它正是实现了这一功能。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-9: Detecting which Submit button was clicked in process.php'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-9：在 process.php 中检测点击了哪个提交按钮
- en: Since the form has only two Submit buttons, we use an if...else statement to
    test whether one of them (watchNow) was clicked; if not, we can safely assume
    that the other was clicked instead. (If we had three or more buttons, we could
    use elseif statements or a switch statement to detect the correct button.) In
    theory, we could call the filter_input() function as usual, extracting the value
    of the watchNow variable and checking that its value isn’t NULL to determine whether
    that’s the button that was used. Since we aren’t interested in the value of watchNow,
    but rather in whether such a variable even exists in the incoming request, we
    instead use PHP’s filter_has_var() function to set the if...else statement’s condition.
    This function takes two input parameters, the source of the variable (usually
    INPUT_GET or INPUT_POST) and the name of the variable, and returns true or false
    based on whether that named value is found.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单只有两个提交按钮，我们使用 if...else 语句测试是否点击了其中一个按钮（watchNow）；如果没有点击，我们可以安全地假设点击了另一个按钮。（如果有三个或更多按钮，我们可以使用
    elseif 语句或 switch 语句来检测正确的按钮。）理论上，我们可以像往常一样调用 filter_input() 函数，提取 watchNow 变量的值，并检查其值是否为
    NULL，以确定是否是该按钮被点击。由于我们并不关心 watchNow 的值，而是关心该变量是否存在于传入的请求中，因此我们改用 PHP 的 filter_has_var()
    函数来设置 if...else 语句的条件。该函数接受两个输入参数，变量的来源（通常是 INPUT_GET 或 INPUT_POST）和变量的名称，并根据是否找到该命名值返回
    true 或 false。
- en: '[Figure 11-9](#fig11-9) shows a sample submission through our movie rental
    web form.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](#fig11-9) 显示了通过我们的电影租赁网页表单提交的示例。'
- en: '![](../images/figure11-9.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-9.jpg)'
- en: 'Figure 11-9: Finding a Submit button name among the POST variables in the request
    body'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：在请求体中的 POST 变量中找到提交按钮的名称
- en: In this example, I’ve used the watchNow button to submit the form data. The
    message on the resulting page confirms that the *process.php* script detected
    this button. Further, a look at the request with the browser developer tools shows
    watchNow listed with the other POST variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用了 watchNow 按钮来提交表单数据。结果页面上的消息确认了 *process.php* 脚本检测到了该按钮。此外，通过浏览器的开发者工具查看请求，显示
    watchNow 与其他 POST 变量一起列出。
- en: Encoding Data in Hyperlinks
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在超链接中编码数据
- en: In addition to sending data through a web form, we can send data to a server
    by adding name/value pairs to the query string at the end of the URL in an HTML
    hyperlink. This data will be sent with the GET method, since whenever you click
    a link in a web page, your browser is making an HTTP GET request using the URL
    of the clicked link. An HTML hyperlink is represented with the anchor (<a>) element;
    the link’s URL is set via the element’s href attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过网页表单发送数据外，我们还可以通过在 HTML 超链接的 URL 末尾添加名称/值对将数据发送到服务器。这些数据将通过 GET 方法发送，因为每当你点击网页上的一个链接时，浏览器会使用该链接的
    URL 发起 HTTP GET 请求。HTML 超链接通过锚点（<a>）元素表示；链接的 URL 通过元素的 href 属性设置。
- en: We’ll explore this additional way to send data via the GET method through a
    typical example of a link that shows details about an item in an online shopping
    cart. [Figure 11-10](#fig11-10) shows the button-styled links we want to create.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个典型的示例来探讨这种通过 GET 方法发送数据的附加方式，该示例展示了一个显示在线购物车中项目详细信息的链接。[图 11-10](#fig11-10)
    显示了我们希望创建的按钮样式链接。
- en: '![](../images/figure11-10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-10.jpg)'
- en: 'Figure 11-10: The Details hyperlinks styled as buttons in a shopping cart'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10：购物车中的按钮样式的详细信息超链接
- en: Each item in the cart has a hyperlink (styled as a button) alongside it to show
    details about that item. The links might be to URLs such as */show.php?id=102*.
    This URL would request the PHP script *show.php* via the GET method, while passing
    the product’s ID (in this case, 102) through the query string id variable. The
    GET method is more appropriate than POST in this case since the intended result
    is simply to display data (so no content is being changed on the server).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车中的每个项目旁边都有一个超链接（样式为按钮），用来显示该项目的详细信息。链接可能指向像 */show.php?id=102* 这样的 URL。这个
    URL 会通过 GET 方法请求 PHP 脚本 *show.php*，同时将产品的 ID（在此例中为 102）通过查询字符串 id 变量传递。由于此处的目标只是显示数据（因此不会改变服务器上的任何内容），使用
    GET 方法比 POST 方法更合适。
- en: Hardcoding the Links
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 硬编码链接
- en: Let’s create the page shown in [Figure 11-10](#fig11-10). For simplicity, we’ll
    begin by hardcoding the product IDs into the hyperlinks. Create a new project
    containing a *public* folder and add an *index.php* script to that folder. Then
    enter the code in [Listing 11-10](#lis11-10).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建如[图 11-10](#fig11-10)所示的页面。为简便起见，我们将从硬编码产品 ID 到超链接开始。创建一个包含 *public* 文件夹的新项目，并将
    *index.php* 脚本添加到该文件夹中。然后输入[列表 11-10](#lis11-10)中的代码。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-10: An index.php file with data embedded in the Details hyperlinks'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-10：一个包含数据并嵌入 Details 超链接的 index.php 文件
- en: 'As in the previous example, we read in the Bootstrap CSS stylesheet as a shortcut
    for styling the page. In the page’s HTML, we create two links with the text Details,
    styled as blue buttons using the Bootstrap CSS class btn btn-primary: one for
    a hammer ❶ and one for a bucket of nails ❷. Each link is to the PHP script *show.php*,
    with the ID of the product encoded into the URL in the fashion ?id=102. Clicking
    one of these links will send the appropriate id variable via a GET request, as
    shown in [Figure 11-11](#fig11-11).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们通过读取 Bootstrap CSS 样式表来快速为页面添加样式。在页面的 HTML 中，我们创建了两个文本为“Details”的链接，并使用
    Bootstrap CSS 类 btn btn-primary 将其样式化为蓝色按钮：一个指向锤子 ❶，另一个指向一桶钉子 ❷。每个链接都指向 PHP 脚本
    *show.php*，产品的 ID 会以 ?id=102 这种方式编码到 URL 中。点击其中一个链接将通过 GET 请求发送相应的 id 变量，如[图 11-11](#fig11-11)所示。
- en: '![](../images/figure11-11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-11.jpg)'
- en: 'Figure 11-11: The result of clicking one of the Details links'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11：点击 Details 链接后的结果
- en: We won’t worry about writing the *show.php* script, but notice that clicking
    the Details link for the bucket of nails initiates a GET request with an id value
    of 511 embedded in the query string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心编写 *show.php* 脚本，但请注意，点击钉子桶的“Details”链接会发起一个 GET 请求，其中 id 值 511 被嵌入到查询字符串中。
- en: NOTE
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In a more realistic scenario, we wouldn’t hardcode* id *values into links
    like this. Instead, we’d loop through an array representing the products in the
    user’s shopping cart and programmatically insert each product’s ID into its corresponding
    Details link. We’ll look at how to do this next.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*在更实际的场景中，我们不会像这样将 id 值硬编码到链接中。相反，我们会通过循环遍历表示用户购物车中产品的数组，并编程地将每个产品的 ID 插入到相应的
    Details 链接中。接下来我们将讨论如何做到这一点。*'
- en: Generating the Links Programmatically
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 程序化生成链接
- en: Most of the content presented in web pages is dynamically generated at runtime
    based on values in the website’s database. Therefore, instead of hardcoding product
    ID values into links like */show.php?id=102*, links are usually created programmatically
    with PHP statements looping through a collection of data representing the items
    in the user’s shopping cart. Each time through the loop, the product’s ID is looked
    up and dynamically inserted into a hyperlink. The product’s description and price
    are similarly dynamically inserted into generic HTML template text.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网页展示的内容都是基于网站数据库中值动态生成的。因此，链接通常不会像 */show.php?id=102* 这样硬编码产品 ID，而是通过 PHP
    语句编程生成链接，遍历表示用户购物车中商品的一个数据集合。每次循环时，都会查找并动态插入该商品的 ID 到超链接中。产品的描述和价格也会类似地动态插入到通用的
    HTML 模板文本中。
- en: Let’s update our shopping cart page to try this approach. We’ll use an array
    to represent the shopping cart as a whole; each item in the array will itself
    be an array representing a particular cart item, with three values for the ID,
    description, and price of the product. Modify the *index.php* file as shown in
    [Listing 11-11](#lis11-11).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新购物车页面，尝试这种方法。我们将使用一个数组来表示整个购物车；数组中的每个项将是一个代表特定购物车商品的数组，包含该产品的 ID、描述和价格三个值。按[列表
    11-11](#lis11-11)所示修改 *index.php* 文件。
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-11: Using a PHP loop to create the Details links for the shopping
    cart items'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-11：使用 PHP 循环为购物车中的商品创建 Details 链接
- en: Before any HTML, we use a PHP code block to declare an $items array containing
    information about our two products. (Of course, we’re still hardcoding the information,
    albeit within an array; in a more realistic scenario, we’d retrieve the product
    information from a database, as we’ll discuss in [Part VI](part6.xhtml)). Then
    we begin the HTML template text. Under the Your shopping cart heading, we use
    another PHP code block to begin a foreach loop in which the $item variable will
    represent the current element of the $items array ❶. We use alternative loop syntax
    with a colon (:) to set up the start of the loop and endforeach ❸ to close it.
    See [Chapter 6](chapter6.xhtml) to review this alternative loop syntax which makes
    it easier to combine PHP with HTML.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何HTML之前，我们使用一个PHP代码块来声明一个$items数组，包含我们两个产品的信息。（当然，我们仍然在硬编码这些信息，尽管是放在数组中；在更实际的场景中，我们会从数据库中获取产品信息，正如我们在[第六部分](part6.xhtml)中将要讨论的那样。）然后我们开始HTML模板文本。在“您的购物车”标题下，我们使用另一个PHP代码块开始一个foreach循环，其中$items数组的当前元素由$item变量表示
    ❶。我们使用带冒号（:）的替代循环语法来设置循环的开始，并使用endforeach ❸来结束循环。请参见[第六章](chapter6.xhtml)以回顾这种替代的循环语法，它使得将PHP与HTML结合更加容易。
- en: Inside the loop, we use a mix of HTML and PHP short echo tags within a <div>
    to insert the current product’s 'description', 'price', and 'id' values into the
    template text. In this way, we dynamically create a <div> element for each product,
    including a Bootstrap-styled Details link. Notice in particular that we embed
    the product’s ID into the href property of the <a> element ❷, which will result
    in hyperlinks like */show.php?id=102*, just as before. Overall, the page should
    look exactly the same as [Figure 11-10](#fig11-10).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们结合使用HTML和PHP短标签来在`<div>`中插入当前产品的'描述'、'价格'和'id'值到模板文本中。通过这种方式，我们为每个产品动态创建一个`<div>`元素，包括一个Bootstrap样式的详细信息链接。特别需要注意的是，我们将产品的ID嵌入到`<a>`元素的href属性中
    ❷，这将生成类似于*/show.php?id=102*的超链接，与之前相同。总体而言，页面应该看起来与[图11-10](#fig11-10)完全相同。
- en: Other Form Input Types
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他表单输入类型
- en: Single text and numeric form inputs (text, password, textarea, and so on) are
    all sent in the HTTP request as a name/value pair, but other types of form data
    aren’t quite so simple. It’s important to understand how the browser chooses the
    variable names and values for these other form elements so that you can write
    server scripts to correctly retrieve and validate the incoming data. In this section,
    we’ll discuss how to work with other common form elements like radio buttons,
    checkboxes, and single- and multiple-selection lists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 单一文本和数字表单输入（如文本框、密码框、文本区域等）都会作为名称/值对发送到HTTP请求中，但其他类型的表单数据就没有那么简单了。理解浏览器如何为这些其他表单元素选择变量名称和值非常重要，这样你才能编写服务器脚本，正确获取和验证传入的数据。在本节中，我们将讨论如何处理其他常见的表单元素，如单选按钮、复选框以及单选和多选列表。
- en: Radio Buttons
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单选按钮
- en: '*Radio buttons* are a set of two or more form input choices offered to the
    user, of which only one value can be chosen. Radio button inputs are declared
    in groups that share the same name attribute, with each having a unique value
    attribute to distinguish which input was selected. In this way, a set of radio
    buttons forms a group of mutually exclusive choices for the value assigned to
    the shared name attribute. Except in rare situations where it’s acceptable for
    no option to be selected, one of the radio buttons should be automatically checked
    so the user is offered a default choice. This way, a value will definitely be
    sent in the HTTP request.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*单选按钮*是一组两个或更多供用户选择的表单输入选项，其中只能选择一个值。单选按钮输入以共享相同名称属性的分组方式声明，每个选项都有一个唯一的值属性，用于区分选中了哪个输入。通过这种方式，一组单选按钮形成了一个互斥的选项组，供分配给共享名称属性的值选择。除非在少数情况下不接受选择任何选项，否则应该自动选中其中一个单选按钮，以便用户能够选择默认选项。这样，值将在HTTP请求中被发送。'
- en: Let’s write the HTML for a form that uses radio buttons to present a choice
    between two Irish counties, as shown in [Figure 11-12](#fig11-12). This figure
    also illustrates the output when the form is processed by *process.php*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个HTML表单，使用单选按钮呈现两个爱尔兰县之间的选择，如[图11-12](#fig11-12)所示。该图还展示了当表单通过*process.php*处理时的输出。
- en: '![](../images/figure11-12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-12.jpg)'
- en: 'Figure 11-12: Radio buttons submitting values via a query-string parameter'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-12：通过查询字符串参数提交值的单选按钮
- en: Create a new project containing a *public* folder with an *index.php* script,
    then enter the code shown in [Listing 11-12](#lis11-12).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，其中包含一个*public*文件夹和一个*index.php*脚本，然后输入[清单11-12](#lis11-12)中显示的代码。
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-12: An HTML form illustrating radio buttons'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-12：演示单选按钮的HTML表单
- en: We create a form using the GET method with an action attribute to request the
    *process.php* script. Within the form, we declare two radio buttons (<input> elements
    of type "radio"), both with "county" as a name attribute. One has a value of "dublin"
    ❶, and the other a value of "cork" ❷. We use the checked attribute to set the
    Dublin option as the default. All the user sees for a radio button is a small
    circular input, so it’s important to add a text or image prompt immediately next
    to each radio button, and to use <label> elements so that the user can click either
    the text or the button.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GET方法创建一个表单，并通过action属性请求*process.php*脚本。在表单内，我们声明了两个单选按钮（类型为"radio"的<input>元素），它们的name属性均为"county"。其中一个的值为"dublin"
    ❶，另一个的值为"cork" ❷。我们使用checked属性将都柏林选项设置为默认选项。用户在页面上看到的单选按钮是一个小圆形输入框，因此在每个单选按钮旁边添加文本或图片提示非常重要，同时还要使用<label>元素，以便用户可以点击文本或按钮进行选择。
- en: NOTE
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The labels show each county starting with a capital letter (such as* Dublin*),
    while the corresponding values start with a lowercase letter (*dublin*). Personally,
    I always use lower camel case for the values of radio buttons, checkboxes, and
    other inputs. Having a consistent naming convention like this makes it easier
    to write the form-processing logic without having to look back at the form code
    itself and reduces the number of mistakes you’re likely to make.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签显示每个县的名称，首字母大写（例如*都柏林*），而对应的值以小写字母开头（*dublin*）。就个人而言，我总是为单选按钮、复选框和其他输入使用小驼峰命名法。采用一致的命名规范可以使编写表单处理逻辑变得更加容易，无需反复查看表单代码本身，也能减少出错的概率。*'
- en: Because this form uses the GET method, we’ll see either ?county=dublin or ?county=cork
    in the URL when the form is submitted. In other words, the name attribute of the
    radio button group serves as the key for a query-string variable, and the value
    attribute of the selected button serves as the variable’s value. We would therefore
    use filter_input(INPUT_GET, 'county') to extract the value submitted by the user
    through the button group.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个表单使用的是GET方法，我们在提交表单时会在URL中看到?county=dublin或?county=cork。换句话说，单选按钮组的name属性充当查询字符串变量的键，选中按钮的value属性充当该变量的值。因此，我们可以使用filter_input(INPUT_GET,
    'county')来提取用户通过按钮组提交的值。
- en: Checkboxes
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复选框
- en: '*Checkboxes* offer Boolean (true/false) choices to the user. They appear in
    the browser as small squares that can be checked or unchecked. You might use checkboxes
    in a form, for example, to allow the user to select toppings when ordering a pizza.
    Unlike radio buttons, checkboxes aren’t mutually exclusive; the user can check
    as many of the boxes as they want. As with radio buttons, adding text or an image
    prompt immediately next to each checkbox lets the user know what they’re selecting.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*复选框*为用户提供布尔值（真/假）选择。它们在浏览器中显示为可以勾选或取消勾选的小方框。例如，您可能会在一个表单中使用复选框，允许用户在点餐时选择披萨的配料。与单选按钮不同，复选框不是互斥的；用户可以选择任意多个复选框。与单选按钮一样，在每个复选框旁边添加文本或图片提示可以让用户知道他们在选择什么。'
- en: The checkboxes in a form can be treated individually or processed collectively
    as an array. We’ll look at both approaches.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的复选框可以单独处理，也可以作为数组进行统一处理。我们将查看这两种方法。
- en: '##### Treated Individually'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 单独处理'
- en: When checkboxes are treated individually, each one should have a unique name
    attribute. You can define a value attribute for each checkbox as well, but it
    isn’t really necessary for processing the form. A checkbox will send its name/value
    pair with the HTTP request only if it has been selected, so on the receiving end,
    it’s sufficient to simply test for the box’s name with the filter_has_var() function,
    regardless of the box’s value. If a checkbox is selected and no value was defined,
    the default value of on will be submitted with the form data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当复选框被单独处理时，每个复选框应有一个唯一的name属性。您还可以为每个复选框定义一个value属性，但对于表单处理来说这并不是必须的。复选框只有在被选中时才会将其name/value对随HTTP请求发送，因此在接收端，只需通过filter_has_var()函数测试复选框的name即可，无需关心复选框的value。如果复选框被选中且没有定义value，则会将默认值"on"与表单数据一起提交。
- en: To see how this works, let’s use checkboxes to create a form for pizza toppings.
    [Figure 11-13](#fig11-13) shows how the form should look.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个功能，让我们使用复选框来创建一个披萨配料的表单。[图11-13](#fig11-13)展示了表单的外观。
- en: '![](../images/figure11-13.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-13.jpg)'
- en: 'Figure 11-13: A form with checkboxes'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-13：带有复选框的表单
- en: Start a new project with a *public/index.php* file containing the code in [Listing
    11-13](#lis11-13) to design the pizza toppings form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个包含 [清单 11-13](#lis11-13) 中代码的 *public/index.php* 文件开始一个新项目，用于设计披萨配料表单。
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 11-13: An HTML form with checkboxes'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-13：带有复选框的 HTML 表单
- en: Inside a form declared with the GET method, we create checkboxes for the olives,
    pepper, and garlic salt options, as well as a Submit button. Each checkbox has
    a unique name attribute and is immediately followed by a text label to indicate
    which option the checkbox represents. Because the checkboxes don’t have explicitly
    declared value attributes, when the user submits the form, each checkbox that
    has been selected will add a variable to the query string in the form *<name>=on*.
    For example, if only “Olives” is selected, the form will trigger a GET request
    with the URL *http://localhost:8000/process.php?olives=on*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 GET 方法声明的表单内，我们为橄榄、辣椒和大蒜盐选项创建复选框，并添加一个提交按钮。每个复选框都有一个独特的 name 属性，紧随其后的是一个文本标签，指示复选框代表的选项。由于复选框没有显式声明值属性，当用户提交表单时，每个选中的复选框会将一个变量添加到查询字符串中，形式为
    *<name>=on*。例如，如果只有“橄榄”被选中，表单将触发一个 GET 请求，URL 为 *http://localhost:8000/process.php?olives=on*。
- en: Listing 11-14 illustrates the sort of logic we might use in the *process.php*
    script to detect one of the checkboxes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-14 展示了我们在 *process.php* 脚本中可能使用的逻辑，用于检测其中一个复选框。
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-14: Detecting an individual checkbox'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-14：检测单个复选框
- en: We call filter_has_var() with INPUT_GET and 'olives' to detect whether an olives
    variable was sent with the GET request, indicating this box was checked. We store
    the resulting true/false value in $olivesSelected, which for simplicity we pass
    to var_dump(). In a more realistic scenario, we might use the Boolean to set up
    conditional logic. We could use a similar filter_has_var() test for the other
    checkboxes, as long as each is uniquely named.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 filter_has_var() 与 INPUT_GET 和 'olives' 一起调用，检测是否有 olives 变量随 GET 请求发送，表示该复选框已被选中。我们将结果的
    true/false 值存储在 $olivesSelected 中，出于简便起见，我们将其传递给 var_dump()。在更现实的场景中，我们可能会使用该布尔值来设置条件逻辑。我们可以对其他复选框进行类似的
    filter_has_var() 测试，只要每个复选框都有唯一的名称。
- en: Treated as an Array
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 作为数组处理
- en: Sometimes it’s more practical to treat two or more checkboxes as related by
    giving them all the same name attribute ending in square brackets. For example,
    the checkboxes in the pizza toppings form could all be given a name of toppings[].
    This way, all the toppings that are selected will be grouped into an array and
    sent in the HTTP request under the same toppings variable name. When taking this
    approach, it’s vital to ensure that each checkbox has a unique value attribute
    so the individual boxes can still be distinguished from one another.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将两个或多个复选框视为相关联的更实际做法是为它们都赋予相同的 name 属性，并以方括号结尾。例如，披萨配料表单中的复选框可以都命名为 toppings[]。这样，所有选中的配料会被分组到一个数组中，并在
    HTTP 请求中以相同的 toppings 变量名发送。当采用这种方法时，必须确保每个复选框都有一个独特的值属性，以便能够区分各个复选框。
- en: Listing 11-15 shows how to rewrite the pizza toppings form to send all selected
    checkboxes as values in a single array.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-15 显示了如何重写披萨配料表单，将所有选中的复选框作为值发送到一个单一的数组中。
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-15: Grouping a form’s checkboxes into an array'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-15：将表单中的复选框分组为一个数组
- en: As before, we declare checkboxes for the three topping options. However, this
    time we assign toppings[] as the name for each checkbox so they will be grouped
    into a toppings array. We also add a value attribute to each checkbox, indicating
    the type of topping to be added to the array if selected. [Figure 11-14](#fig11-14)
    shows how multiple values for toppings[] appear in the query string when the form
    is submitted with all three boxes checked.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们为三个配料选项声明复选框。然而，这次我们为每个复选框分配 toppings[] 作为 name，这样它们就会被分组到一个 toppings
    数组中。我们还为每个复选框添加了一个值属性，表示如果该选项被选中，所添加到数组中的配料类型。[图 11-14](#fig11-14) 显示了当提交表单并勾选所有三个复选框时，toppings[]
    的多个值如何出现在查询字符串中。
- en: '![](../images/figure11-14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-14.jpg)'
- en: 'Figure 11-14: Checkbox values being submitted as values for a single array
    variable'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-14：复选框的值作为单一数组变量的值提交
- en: To successfully process this form, we’ll have to ensure that the *process.php*
    script is set up to expect an array of checkbox values. The array may be empty
    if no checkboxes were selected, or it could contain one or more values. [Listing
    11-16](#lis11-16) uses an if...else statement to handle both cases, so it should
    work regardless of how many pizza toppings are selected.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理这个表单，我们必须确保 *process.php* 脚本已经设置好以接受复选框值的数组。如果没有选择复选框，数组可能为空，或者数组可能包含一个或多个值。[列表
    11-16](#lis11-16) 使用 if...else 语句来处理这两种情况，因此无论选择了多少个比萨配料，它都能正常工作。
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-16: Processing an array of checkbox values'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-16：处理复选框值的数组
- en: 'Now that the values of the checkboxes matter, we need to use filter _input()
    instead of filter_has_var() ❶. As usual, we use the function’s first two arguments
    to retrieve a toppings variable from the query string, but this time we also use
    a named argument of options: FILTER_REQUIRE_ARRAY to specify that we’re looking
    for an array of values under the toppings variable name. We store the resulting
    array in the $toppings PHP variable.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '现在复选框的值变得重要了，我们需要使用 filter_input() 而不是 filter_has_var() ❶。像往常一样，我们使用函数的前两个参数从查询字符串中获取
    toppings 变量，但这次我们还使用了一个命名参数 `options: FILTER_REQUIRE_ARRAY`，指定我们需要获取 toppings
    变量名下的一个数组。我们将结果数组存储在 `$toppings` PHP 变量中。'
- en: We need to use a named argument here because $options is the filter _input()
    function’s fourth parameter. We’re skipping over the third parameter, $filter,
    leaving it with its default value of FILTER_DEFAULT. See [Chapter 5](chapter5.xhtml)
    for a review of named and optional parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里使用命名参数，因为 `$options` 是 filter_input() 函数的第四个参数。我们跳过了第三个参数 `$filter`，让它保持默认值
    FILTER_DEFAULT。关于命名参数和可选参数的复习，请参见 [第 5 章](chapter5.xhtml)。
- en: We next use an if...else statement to check whether the $toppings array is empty.
    If so, we print a message accordingly ❷. Otherwise, we use the built-in implode()
    array function to collapse the array of toppings into a single string, with the
    topping names separated by plus signs ❸. Look back at the bottom of [Figure 11-14](#fig11-14)
    to see the resulting string of toppings when all three boxes are checked.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 if...else 语句来检查 `$toppings` 数组是否为空。如果为空，我们会相应地打印一条消息 ❷。否则，我们使用内置的 implode()
    数组函数将 toppings 数组压缩成一个单一的字符串，字符串中的配料名称通过加号连接 ❸。回顾 [图 11-14](#fig11-14) 底部，可以看到当三个选框都被选中时，生成的配料字符串。
- en: Single-Selection Lists
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单选列表
- en: A *single-selection list* displays as a drop-down menu enabling the user to
    choose one option. This list is created with an HTML <select> element containing
    <option> elements representing the possible choices. The <select> element has
    a name that will be assigned the value of the chosen <option> element when the
    form is submitted, resulting in a straightforward name/value pair on the receiving
    end. [Figure 11-15](#fig11-15) shows a form offering a simple single-selection
    list of flowers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*单选列表* 显示为一个下拉菜单，允许用户选择一个选项。这个列表是通过 HTML `<select>` 元素创建的，元素中包含 `<option>`
    元素，表示可能的选择。`<select>` 元素有一个名称，在表单提交时，该名称将与所选 `<option>` 元素的值一起传送，从而在接收端形成一个简单的名称/值对。例如，[图
    11-15](#fig11-15) 显示了一个提供简单单选花卉列表的表单。'
- en: '![](../images/figure11-15.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-15.jpg)'
- en: 'Figure 11-15: A single-selection list'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-15：单选列表
- en: Let’s create this flower form. Start a new project with a *public/index.php*
    file and enter the contents of [Listing 11-17](#lis11-17).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来创建这个花卉表单。首先创建一个新项目，包含 *public/index.php* 文件，并输入 [列表 11-17](#lis11-17) 的内容。
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-17: An HTML form with a single-selection list'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-17：带有单选列表的 HTML 表单
- en: We declare a form with the GET method containing a Submit button alongside a
    selection list with the name flower ❶. The <select> element holds three <option>
    elements with value attributes of poppy, daisy, and tulip. When the form is submitted,
    the selected flower will be sent in the HTTP request as a query parameter named
    flower. In [Figure 11-15](#fig11-15), for example, *flower=poppy* appears in the
    query string when the poppy is selected.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个使用 GET 方法的表单，表单中有一个提交按钮和一个名为 flower 的选择列表 ❶。`<select>` 元素包含三个 `<option>`
    元素，它们的值分别为 poppy、daisy 和 tulip。当表单提交时，所选的花卉将作为名为 flower 的查询参数发送到 HTTP 请求中。例如，在
    [图 11-15](#fig11-15) 中，当选择了 poppy 时，查询字符串中会出现 *flower=poppy*。
- en: We can process the choice submitted through a single-selection list by using
    filter_input() and the name of the select element. In the case of our flower form,
    for example, we can use filter_input(INPUT_GET, 'flower') to extract the user’s
    chosen flower.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用filter_input()和选择元素的名称来处理通过单选列表提交的选择。例如，在我们的花卉表单中，我们可以使用filter_input(INPUT_GET,
    'flower')来提取用户选择的花卉。
- en: Multiple-Selection Lists
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多选列表
- en: A multiple-selection list allows the user to choose more than one option from
    a menu. This list is created by adding the multiple attribute to the HTML <select>
    element. [Figure 11-16](#fig11-16) shows a multiple-selection version of our flower
    form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 多选列表允许用户从菜单中选择多个选项。通过在HTML的<select>元素中添加multiple属性来创建此列表。[图11-16](#fig11-16)展示了我们花卉表单的多选版本。
- en: '![](../images/figure11-16.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure11-16.jpg)'
- en: 'Figure 11-16: A multiple-selection list'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-16：多选列表
- en: 'Whereas a single-selection list results in a simple name/value pair, a multiple-selection
    list should be handled similarly to the array approach we used for checkboxes:
    the list should have a name attribute ending with square brackets, as in flowers[].
    This way, we’ll get an array containing the zero, one, or more values selected
    from the list’s options. [Listing 11-18](#lis11-18) shows how to modify the *index.php*
    file for our flower form to turn it into a multiple-selection list.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 单选列表结果是简单的名称/值对，而多选列表应该像我们在复选框中使用的数组方法一样处理：列表应该具有以方括号结尾的名称属性，如flowers[]。通过这种方式，我们将得到一个包含从列表选项中选择的零个、一个或多个值的数组。[清单11-18](#lis11-18)展示了如何修改*index.php*文件，使其将花卉表单转变为多选列表。
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 11-18: An HTML form illustrating a multiple-selection list as an array
    of values'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-18：一个HTML表单，展示了作为值数组的多选列表
- en: We modify the selection list to have an array name of flowers[] ❶ and specify
    that it should be displayed in a box that fits three rows. We include the multiple
    attribute to indicate that the user may select more than one item from the list
    (this attribute doesn’t need to be assigned a value) ❷. When the form is submitted,
    any selected flowers will be sent in the HTTP request as an array named flowers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改选择列表，使其拥有一个名为flowers[]的数组❶，并指定它应显示为适合三行的框。我们添加multiple属性以表示用户可以从列表中选择多个项目（此属性不需要指定值）❷。当表单提交时，任何选择的花卉将作为名为flowers的数组随HTTP请求一起发送。
- en: We can process this form by using similar logic to that of our script processing
    an array of checkboxes from [Listing 11-16](#lis11-16). We use an if...else statement
    to check whether the incoming array is empty, as shown in [Listing 11-19](#lis11-19).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用与[清单11-16](#lis11-16)中处理复选框数组的脚本类似的逻辑来处理这个表单。我们使用if...else语句来检查传入的数组是否为空，如[清单11-19](#lis11-19)所示。
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-19: Processing the array of values from a multiple-selection list'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-19：处理来自多选列表的值数组
- en: 'We extract the $flowers array from the incoming GET request, once again using
    the extra options: FILTER_REQUIRE_ARRAY argument to filter_input() to specify
    that we’re looking for an array. Then, if the array isn’t empty, we use implode()
    to merge the received flowers into a string separated by plus signs.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从传入的GET请求中提取$flowers数组，再次使用额外的选项：FILTER_REQUIRE_ARRAY参数来传递给filter_input()，以指定我们正在查找一个数组。然后，如果数组不为空，我们使用implode()将接收到的花卉合并成一个由加号分隔的字符串。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how to create web forms that submit data to server
    scripts, and we discussed the difference between submitting those forms with the
    HTTP GET and POST methods. We also covered how to write server-side scripts to
    identify and extract the submitted form data. We focused on how to use PHP’s filter_input()
    function to extract the values of variables from an incoming HTTP request, as
    well as how to use filter _has_var() when all we need to know is whether a variable
    exists at all. We applied this approach to a variety of form input types, including
    text inputs, radio buttons, checkboxes, and selection lists.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们探讨了如何创建提交数据到服务器脚本的Web表单，并讨论了使用HTTP GET和POST方法提交这些表单的区别。我们还介绍了如何编写服务器端脚本来识别并提取提交的表单数据。我们重点讲解了如何使用PHP的filter_input()函数从传入的HTTP请求中提取变量的值，以及如何使用filter_has_var()在我们只需要知道变量是否存在的情况下使用它。我们将这种方法应用于多种表单输入类型，包括文本输入、单选按钮、复选框和选择列表。
- en: Exercises
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create a form for a costume-rental company that enables the user to submit
    the name of the superhero costume they want. Make the form submit data via the
    HTTP GET method to a PHP script called *costumeSearch.php*, and use hero for the
    name of the text value entered by the user. Visit the form through your web server
    and submit the value superman. You should see *costumeSearch.php?hero=superman*
    in the resulting URL.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   为一个服装租赁公司创建一个表单，使用户能够提交他们想要的超级英雄服装的名称。使表单通过HTTP GET方法提交数据到名为*costumeSearch.php*的PHP脚本，并使用hero作为用户输入的文本值的名称。通过你的web服务器访问该表单并提交值superman。你应该会在结果URL中看到*costumeSearch.php?hero=superman*。
- en: 2.   Create a basic login form using the HTTP POST method, with <input> elements
    for a username (using the default text type) and a password (use the password
    type). Use your browser’s developer tools to inspect the form data when it’s submitted.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   使用HTTP POST方法创建一个基本的登录表单，表单中包含一个用户名（使用默认的文本类型）和一个密码（使用密码类型）的`<input>`元素。使用浏览器的开发者工具检查提交的表单数据。
- en: 3.   Create a form to input the user’s age and a script to process the received
    age. The processing script should return an HTML page containing a message stating
    how old the user will be on their next birthday.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   创建一个输入用户年龄的表单和一个处理接收到的年龄的脚本。处理脚本应返回一个包含用户下一个生日时年龄的消息的HTML页面。
- en: 4.   Create a form with radio buttons asking the user whether they would be
    willing to pay more for an environmentally friendly car. If they say yes, return
    an HTML page containing a message recommending they buy an electric car. If they
    say no, recommend a gas car.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   创建一个包含单选按钮的表单，询问用户是否愿意为环保汽车支付更多费用。如果他们回答“是”，返回一个包含推荐购买电动汽车的消息的HTML页面。如果他们回答“否”，则推荐购买燃油车。
- en: 5.   Create a form offering the user several options for a new car, each represented
    with a uniquely named checkbox. For example, offer options such as metallic paint,
    fog lights, and a reversing camera. Write a script that processes the form data
    and returns an HTML page containing a message confirming each selected option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   创建一个表单，向用户提供几种新车选项，每个选项用一个独特名称的复选框表示。例如，提供金属漆、雾灯和倒车影像等选项。编写一个脚本，处理表单数据并返回一个包含确认每个选定选项的消息的HTML页面。
- en: 6.   Duplicate your answer for Exercise 5 about car options, but change the
    checkboxes to send the data as part of an array variable named extras[]. Update
    your form-processing code to handle the array. Think about whether you find the
    array approach easier or harder than processing the checkboxes individually.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   复制关于汽车选项的第5题答案，但将复选框更改为将数据作为名为extras[]的数组变量发送。更新表单处理代码以处理该数组。思考一下，你觉得使用数组方式处理比单独处理复选框更容易还是更困难？
