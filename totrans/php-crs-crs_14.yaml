- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 11 CREATING AND PROCESSING WEB FORMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After simple, clickable links, web forms are perhaps the most common way people
    interact with websites. In this chapter, we’ll look at how web clients can submit
    form data to server scripts, and we’ll create a range of web forms that send data.
    We’ll also practice writing server-side PHP scripts to extract and process the
    incoming form data. You’ll learn to handle data from a range of web-form elements,
    sent with both GET and POST HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: A *web form* is simply a portion of a web page that allows the user to enter
    data and then communicates that user input to server applications. Examples of
    web form interactions include creating a Facebook post, booking flights or entertainment
    tickets, and entering login information. As you’ll see, each form on a web page
    is defined between starting and ending HTML <form> tags. The form data might be
    text input by the user, or it might come from mechanisms like radio buttons, selections
    lists, or checkboxes. We’ll discuss how to work with all these types of input
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Client/Server Communication for Web Forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behind the typical web form lies a sequence of four messages between a web client
    (such as the user’s browser) and a web server, whereby the form is requested,
    received, submitted, and processed. [Figure 11-1](#fig11-1) summarizes these messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The typical exchange of messages for displaying and processing
    a web form'
  prefs: []
  type: TYPE_NORMAL
- en: First, the web browser client requests the HTML of the form from the server
    ❶. The user triggers this request through an action such as clicking a link or
    a button. Next, the server retrieves and, in some cases, customizes the HTML for
    the form and sends it back to the client ❷. Once the user has entered data and
    submitted the form, the form data is sent back to the server ❸. Finally, the server
    processes the received data, constructs an appropriate message for the user, and
    sends that message back ❹. This final message may be a simple confirmation of
    received data or an error message if an issue occurs, or it could be the original
    form with messages highlighting missing required data.
  prefs: []
  type: TYPE_NORMAL
- en: '#### GET vs. POST Requests'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 10](chapter10.xhtml), the two most common types of
    HTTP request sent from a client to a server are GET and POST. When you create
    an HTML form, you can send the data to the server with either type of request,
    since both GET and POST can send variables from the browser client to the web
    server as part of the request. In almost all cases, the data variables sent from
    web forms to the server are simple name/value pairs, such as username=matt or
    q=chocolate.
  prefs: []
  type: TYPE_NORMAL
- en: The request type you use comes down to the purposes of the form and how you
    want the form data to be sent. As you’ll see, the GET method makes the submission
    variables visible in the URL, while the POST method can hide the variables in
    the body of the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Data Visibly with GET
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An HTTP GET request is primarily for retrieving data or a web page from a server.
    While you can send data along with the request to help with this retrieval, a
    GET request should never result in changes to content stored on the server (such
    as modifications to values in a database).
  prefs: []
  type: TYPE_NORMAL
- en: With a GET request, any variables the server needs to complete the request,
    including values submitted through web forms, are added to the end of the URL
    of the request, after a question mark character (?). This part of the URL after
    the question mark is known as a *query string*, and it will be visible in your
    browser’s address bar. The variables are encoded as name/value pairs in the form
    name=value, such as username=matt. For example, when you perform a search using
    Google or Bing, the terms you enter into the search engine’s web form are assigned
    to the variable q, added to a URL query string, and sent using a GET request.
  prefs: []
  type: TYPE_NORMAL
- en: Say you use Google to search the phrase *cheese cake*. When you view the search
    results, you should see something like *https://www.google.com/search?q=cheese+cake*
    in the address bar. The single letter *q* represents your search query and is
    paired with the value you entered into Google’s web form. This indicates your
    query was passed to Google’s servers through a GET request.
  prefs: []
  type: TYPE_NORMAL
- en: Special rules define the characters allowed in a URL, and the variables sent
    via the HTTP GET method must follow these rules too. As a result, special characters
    and spaces can’t be represented verbatim in a query string but must instead be
    encoded as other symbols. For example, each space is replaced with either %20
    or a plus sign (+), which is why the Google search query string reads *q=cheese+cake*
    rather than *q=cheese cake*. When two or more variables are being encoded (for
    example, from separate fields in a form), the name/value pairs are separated by
    ampersand (&) characters, as in *?firstname=matt&lastname=smith*. The web browser
    will look after this sort of encoding automatically, but knowing about it is handy
    since it explains why you’ll often see cryptic, percent-encoded characters when
    sending form data with the GET method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common use of the GET method is to create a URL that’s easily bookmarked,
    perhaps to share with someone else via email or text message. The Google *cheese
    cake* query is one example: *https://www.google.com/search?q=cheese+cake*. Another
    example could be a Google Maps search, such as this one for Dublin, Ireland: *https://www.google.com/maps?q=dublin+ireland*.
    The variables in the URL can come from values entered into a web form, as is the
    case with a Google search, or they can be hardcoded by explicitly adding the question
    mark and the desired name/value pairs to the end of a URL.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-2](#fig11-2) shows an example of the latter, where clicking the
    COMP H2029 -FT link initiates a GET request that includes the name/value pair
    id=1499 in the query string. This id value doesn’t come from user input but rather
    was hardcoded into the logic of the website.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: A link with a hardcoded value to be sent via the GET request method'
  prefs: []
  type: TYPE_NORMAL
- en: A web server doesn’t care how a GET request is created. Whether the query-string
    variables come from form submissions or were hardcoded, the name/value pairs can
    be extracted by a server-side script for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Data Invisibly with POST
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: HTTP POST requests send data primarily for the purposes of creating or modifying
    a resource on a server. With the POST method, you can send variables in the body
    of the HTTP message, meaning they won’t be seen in the resulting URL. For any
    confidential data like usernames and passwords, you should use POST requests so
    that people looking at the screen can’t see the data values being sent to the
    server. In fact, most web forms send their data by using the POST method. [Figure
    11-3](#fig11-3) illustrates a POST method login form.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: POST method variables in the request body'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’ve tried to log in to a site with a username of matt and
    a password of smith. The browser’s HTTP message inspection tool reveals that the
    username and password values were sent in the body of the HTTP POST request. These
    values therefore don’t appear as part of the URL in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A* POST *request can send data directly in the query string, like a* GET *request,
    as well as in the request body. We’ll explore* POST *requests that do both in
    “Sending Noneditable Data Along with Form Variables” on [page 206](#pg_206).*'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To more clearly understand how the GET and POST methods send data differently,
    let’s build a simple site with a web form consisting of a single text box where
    the user can enter their name (see [Figure 11-4](#fig11-4)). We’ll try passing
    data from the form by using both HTTP methods. As you’ll see, we can choose which
    method to use whenever we create an HTML <form> element.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: A simple web form displayed in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: Our project will consist of a *public* folder containing two PHP script files,
    *index.php* and *process.php*. Here, *index.php* is the default home-page script
    that will display the form, and *process.php* will receive the name submitted
    by the user from the index page and generate a *Hello <name>* message in response.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Form with the GET Method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll start with the GET version of our simple web form. Create a new project
    with a *public* folder, and inside that folder create a new PHP script file named
    *index.php*. Enter the code shown in [Listing 11-1](#lis11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: The HTML code for a simple web form using the GET method'
  prefs: []
  type: TYPE_NORMAL
- en: The file consists entirely of HTML template text, including a <form> element
    that defines the web form. We use the element’s method attribute to declare that
    the form data should be submitted with the GET HTTP method, and the action attribute
    to specify that the HTTP request and its data should be sent to the *process.php*
    server script. Note that the GET or POST values of the method HTML form attribute
    are case insensitive, so we could also write method="get".
  prefs: []
  type: TYPE_NORMAL
- en: Within the form, we create an <input> element and give it a name of firstName.
    We also create a second <input> element with a type of submit to add a Submit
    button to the form. Since we don’t specify the type of the firstName input, HTML
    5 automatically defines the default form input type to be a text box. Text boxes
    are displayed to the user as rectangular input boxes. If you wanted to explicitly
    declare the type of input, you could do so via <input type="text" name="firstName">.
    You could go further and set the character width of the text box and other specs
    by using the various optional attributes for each type of HTML form input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our form inputs only a single value, we don’t need to bother displaying
    a text label to the user. However, when several input controls are present, you
    should precede each with a prompt so that the user knows which text box (or radio
    button or other input type) relates to which value. For example, if we wanted
    the user to input an age, we might write the template text Age: and then the form
    input, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Modern HTML good practice would also require us to add an id attribute to the
    age input with <input name="age" id="age"> and a <label> element around the template
    text with <label for="age">Age:</label>. This allows the user to click either
    the label or the text box to make age the active form input.  ##### Processing
    the GET Request'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created an HTML web form, but our work is only half done; we also need
    to write the *process.php* script to handle the data submitted through the form.
    All we need to know when writing processing scripts for simple forms is the name
    of the variable the script is to receive and whether that variable was submitted
    through the query string (as with the GET method) or in the request body (as with
    the POST method).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the script should attempt to find a value for the firstName variable
    in the query string received from the GET request and then output HTML to present
    to the user a greeting featuring that name. Add *process.php* to the *public*
    folder of your project and enter the code in [Listing 11-2](#lis11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: A process.php server script to respond to the web form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we use two kinds of comments in this script, since it mixes two
    languages: a PHP comment starting with // and an HTML <!-- comment. Inside the
    initial PHP code block, we call the filter_input() function to read data from
    the incoming HTTP request, storing the result in the $firstName variable ❶. The
    INPUT_GET argument specifies that we want to read data embedded directly in the
    URL query string, and the ''firstName'' argument identifies the specific HTML
    form variable we’re looking for. Form input variable names are case sensitive,
    so it’s important to carefully match the variable names defined in HTML forms
    when calling the filter_input() function. If we passed ''firstname'' rather than
    ''firstName'' as a function argument, for example, the script wouldn’t work. When
    passing the value of a form variable along to a PHP variable, as we’re doing here,
    it’s generally good practice to give the PHP variable the same name as the corresponding
    form variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the HTML that should be sent in response to the form submission.
    This includes the template text Hello followed by the value of the $firstName
    variable inside PHP short echo tags ❷.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* INPUT_GET *argument to* filter_input() *is somewhat misleadingly named.
    Its purpose is to retrieve data from the URL query string, regardless of whether
    that data was sent via the* GET *method (where all variables are part of the query
    string) or via the* POST *method (where data can be either in the query string
    or in the request body). Therefore, when you see* GET *while working on form-processing
    code in PHP, interpret this as* query-string variables *and don’t necessarily
    assume they came from a* GET *request.*  ##### Testing the Form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created the web form in *index.php* and written the *process.php*
    script to respond to it, let’s test our work. Launch the PHP web server at the
    command line by using the php -S localhost:8000 -t public command, as discussed
    in [Chapter 10](chapter10.xhtml); then open a browser tab to *localhost:8000*.
    The form we’ve created should be displayed by default since the file is named
    *index.php*. You’ll see something like the form in [Figure 11-4](#fig11-4): a
    text box with a Submit button.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter your name into the form, then click **Submit**. When you do, the text
    entered should be sent as part of an HTTP GET request from the browser to the
    PHP server. The GET request triggers the server to execute the *process.php* script,
    as declared in the action attribute of the HTML <form> element in *index.php*.
    This script extracts the submitted value and injects it into its HTML template
    text, which is then added to the text buffer that becomes the body of the HTTP
    response message the server sends back to the requesting client (the web browser).
    You should see something like [Figure 11-5](#fig11-5) as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: The result of the process.php script, confirming the data received
    through the form'
  prefs: []
  type: TYPE_NORMAL
- en: You see your name not only in the greeting displayed on the page (such as *Hello
    matt* in the figure) but also at the end of the URL in the browser’s address bar,
    because the form is submitted via a GET request. For example, the URL I get when
    I submit matt through the form is *localhost:8000/process.php?firstName=matt*.
    This indicates the GET request is trying to access the *process.php* script and
    pass it a firstName variable with a value of matt. Notice the question mark separating
    the query string from the rest of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to the POST Method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s modify our project to send the form data with the POST method rather than
    GET and see what difference it makes. Only a few minor changes are needed. First,
    update the *index.php* script as shown in [Listing 11-3](#lis11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Switching from GET to POST in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now declare the method of the <form> element to be POST. That’s it: no further
    changes are required to the index script to ensure that the web browser uses the
    POST method instead of GET to submit the form data. Next, update *process.php*
    as shown in [Listing 11-4](#lis11-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: Switching from GET to POST in process.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another simple change: all we have to do is pass INPUT_POST rather
    than INPUT_GET as an argument to filter_input() to tell the function to look for
    a variable submitted in the body of the request with POST.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the web server and submitting your name through the form again.
    You should still see the same *Hello <name>* greeting as before. If you look a
    little closer, however, you’ll see some key differences, as shown in [Figure 11-6](#fig11-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Viewing the HTTP POST request and the firstName variable with
    the browser developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: First, the URL in the browser’s address bar should read just *localhost:8000/
    process.php*. Because the firstName form variable is now being sent in the request
    body with POST, it no longer appears in the URL query string for all to see. You
    can verify that the variable is still being transmitted by viewing the request
    with the browser’s developer tools. In this example, I submitted the name Fred
    through the form, and you can see in [Figure 11-6](#fig11-6) that, indeed, the
    form data variable firstName=Fred is shown in the body of the POST request.
  prefs: []
  type: TYPE_NORMAL
- en: The filter_input() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our simple web form project illustrated how to receive incoming form data by
    using PHP’s filter_input() function. This function makes it easy to extract values
    submitted with the GET and POST methods. Writing form-processing scripts wasn’t
    always so simple, however; in older versions of PHP, the usual way to extract
    data received from the user was to access one or both of the built-in $_GET and
    $_POST *superglobal arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: The $_GET array contains key/value pairs representing all the variables received
    as part of the URL query string, while the $_POST array contains key/value pairs
    representing all the variables received via the POST HTTP method. For instance,
    submitting the first name Matt through the GET request version of our simple web
    form would produce a $_GET array containing ['firstName' => 'Matt'] and an empty
    $_POST array.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* $_GET *and* $_POST *arrays are examples of PHP’s* superglobals*. These
    are arrays that always exist and that can be accessed from anywhere in your PHP
    code (that is, from any scope), including inside functions and class methods.*'
  prefs: []
  type: TYPE_NORMAL
- en: Even in modern PHP programming, extracting form data from these two superglobal
    arrays is still theoretically possible. But PHP version 5.2 introduced the filter_input()
    function as a much better way of accessing submitted data. To illustrate the improvement,
    let’s look at what it takes to work with these superglobal arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](chapter7.xhtml), you learned that trying to access a nonexistent
    key in an array will trigger a warning, which you can avoid by using the isset()
    function to verify that an array key exists before accessing its value. This kind
    of test makes scripts more robust and error-proof, and it’s especially important
    when working directly with the $_GET and $_POST arrays. Unfortunately, such a
    test also adds extra code to a script. For example, [Listing 11-5](#lis11-5) illustrates
    how to safely retrieve a $firstName variable from the $_GET array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: Testing an array key with isset() before attempting to extract
    a value from $_GET'
  prefs: []
  type: TYPE_NORMAL
- en: We use isset() in an if...else statement to check whether the 'firstName' key
    exists in the $_GET array (indicating that a firstName form variable was submitted
    through the incoming query string). If the key exists, we pass on its value to
    the $firstName variable. Otherwise, we set $firstName to NULL. This if...else
    statement saves us from getting a warning if we naively access a nonexistent value
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11-5 will work fine, but it represents such a common series of actions
    in PHP form-processing code that filter_input() was introduced to encapsulate
    it. Our entire if...else statement can therefore be replaced with a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The filter_input() function automatically checks whether the desired variable
    exists before trying to access it and typically returns NULL if it doesn’t. This
    spares us from writing clunky conditional tests like the one in [Listing 11-5](#lis11-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional advantage of the filter_input() function is that it can use filters
    to ignore and remove unwanted and potentially dangerous content from the received
    form data. This helps prevent security vulnerabilities such as cross-site scripting
    attacks. For example, to filter out (discard) any nonalphabetic characters from
    the user input, we could add a third argument of FILTER_SANITIZE_SPECIAL_CHARS
    to the filter_input() call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Other Ways to Send Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Taking user input through a web form isn’t the only way to send data via an
    HTTP request. In this section, we’ll consider other techniques for transmitting
    data to a server. We’ll look at how to embed noneditable data into a query string
    for submission along with user-entered form data, how to send data about the form’s
    Submit button itself, and how to add query-string variables to a regular hyperlink,
    separate from any web form. Along the way, you’ll also see how to process a mixture
    of query string and POST variables, and how to harness PHP arrays and loops to
    generate query-string variables programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Noneditable Data Along with Form Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often you’ll want a web form to send extra data that the user can’t edit. Perhaps
    the most common example occurs when the user, maybe an employee, is editing details
    for an item in a database. The item, which might be a record about a product or
    a customer, already has an assigned ID that should be included with the form data,
    but the ID itself should never be changed via the form. For these cases, you can
    send the noneditable values as query-string variables at the end of the URL in
    the form’s action attribute (for example, action="/process.php?id=1022").
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s create a new web form for submitting information about
    movies. Start a new project containing a *public* folder and create an *index.php*
    script within it. Then enter the HTML code in [Listing 11-6](#lis11-6) to create
    the web form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: The HTML code for a movie form in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a form using the POST method ❶. (In a more realistic scenario, this
    form would likely result in changes to a record in a database, so POST rather
    than GET is the appropriate method here.) For the form’s action attribute, we
    specify that the script to process the form is *process.php*, and we also send
    a URL query-string variable named id with a hardcoded value of 1022. When the
    form is submitted, this extra name/value pair will be visible in the resulting
    URL itself (much like data sent with the GET method). Meanwhile, the form will
    also send two variables with user-entered values in the body of the POST request:
    title ❷ and price ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Processing Mixed Query-String and POST Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s write the *process.php* script to receive and extract data from this
    movie form. Unlike our earlier form-processing script, this one needs to extract
    multiple variables from the incoming POST request, including the id variable sent
    through the query string and the title and price variables embedded in the request
    body. Add *process.php* to your project’s *public* folder and enter the code in
    [Listing 11-7](#lis11-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-7: The PHP server script to process the movie form'
  prefs: []
  type: TYPE_NORMAL
- en: We use the filter_input() function with the INPUT_GET argument to read the id
    query-string variable into the corresponding PHP variable, $id. (Remember, INPUT_GET
    simply means we’re reading data from the query string, even if that data was sent
    with the POST method rather than GET. The actual method of the HTTP request makes
    little difference from the server-side script’s perspective.) Then we use filter_input()
    twice more with INPUT_POST to read the two values from the request body into the
    $title and $price variables. After some basic HTML page tags, we output each variable’s
    name and value by using PHP short echo tags, separating them with HTML <br> line
    breaks.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-7](#fig11-7) shows how the *process.php* script handles the incoming
    form data.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: An HTTP request sending query-string and POST variables'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I filled in The Lost World in the title field of the form and
    9.99 in the price field. The output in the browser shows these values echoed back,
    along with the id value of 1022 that we hardcoded into the query string. You should
    also see the id variable in the URL in the browser’s address bar, and if you view
    the request with the browser developer tools, you should see id listed as a query-string
    parameter, while title and price are listed as form data variables in the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Offering Multiple Submit Buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to send data through a form is to give a name attribute to the form’s
    Submit button. This is especially useful when you want a form to feature multiple
    Submit buttons so the user can choose how to process the data in a form.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a customer renting an online movie might want to pay for it and
    immediately start watching it, or they might want to pay for it but start watching
    later. Each option could be triggered by a different Submit button, as illustrated
    in [Figure 11-8](#fig11-8). The server-side script can then detect the name of
    the button the user clicked and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Two Submit buttons for the same form'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s design such a form with multiple Submit buttons. Create a new project
    containing a *public* folder with a PHP script file named *index.php*, and enter
    the code in [Listing 11-8](#lis11-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-8: The HTML code for a form with two Submit buttons'
  prefs: []
  type: TYPE_NORMAL
- en: First, we read in the Bootstrap CSS stylesheet ❶. This allows us to style the
    submit-type inputs to look like nice green buttons by using class="btn btn-success"
    without having to write any CSS code ourselves. Then we set up a form using the
    POST method since this form submits data that would likely lead to changes on
    the server (processing the payment and recording the movie as being rented by
    the user) ❷. Notice that we’ve hardcoded a movieID variable into the query string
    through the form’s action attribute, much as in the previous movie form example.
  prefs: []
  type: TYPE_NORMAL
- en: We give the form input fields for the user’s credit card information, and then
    we define two Submit buttons, one with a name attribute of watchNow ❸ and the
    other with a name attribute of watchLater ❹. These buttons also have value attributes
    to define the text that will appear in each button. Thanks to these buttons’ name
    attributes, when one of them is clicked, its name and value will be sent as a
    key/value pair in the body of the POST request along with the other form data.
    For example, if the user clicks the watchNow button, a watchNow=Pay and start
    watching now will be sent with the request. The value portion is of little significance,
    but the server-side script can check for a key of watchNow among the form data
    to determine which Submit button was clicked. [Listing 11-9](#lis11-9) shows a
    *process.php* file that does just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-9: Detecting which Submit button was clicked in process.php'
  prefs: []
  type: TYPE_NORMAL
- en: Since the form has only two Submit buttons, we use an if...else statement to
    test whether one of them (watchNow) was clicked; if not, we can safely assume
    that the other was clicked instead. (If we had three or more buttons, we could
    use elseif statements or a switch statement to detect the correct button.) In
    theory, we could call the filter_input() function as usual, extracting the value
    of the watchNow variable and checking that its value isn’t NULL to determine whether
    that’s the button that was used. Since we aren’t interested in the value of watchNow,
    but rather in whether such a variable even exists in the incoming request, we
    instead use PHP’s filter_has_var() function to set the if...else statement’s condition.
    This function takes two input parameters, the source of the variable (usually
    INPUT_GET or INPUT_POST) and the name of the variable, and returns true or false
    based on whether that named value is found.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-9](#fig11-9) shows a sample submission through our movie rental
    web form.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: Finding a Submit button name among the POST variables in the request
    body'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’ve used the watchNow button to submit the form data. The
    message on the resulting page confirms that the *process.php* script detected
    this button. Further, a look at the request with the browser developer tools shows
    watchNow listed with the other POST variables.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding Data in Hyperlinks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to sending data through a web form, we can send data to a server
    by adding name/value pairs to the query string at the end of the URL in an HTML
    hyperlink. This data will be sent with the GET method, since whenever you click
    a link in a web page, your browser is making an HTTP GET request using the URL
    of the clicked link. An HTML hyperlink is represented with the anchor (<a>) element;
    the link’s URL is set via the element’s href attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore this additional way to send data via the GET method through a
    typical example of a link that shows details about an item in an online shopping
    cart. [Figure 11-10](#fig11-10) shows the button-styled links we want to create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: The Details hyperlinks styled as buttons in a shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: Each item in the cart has a hyperlink (styled as a button) alongside it to show
    details about that item. The links might be to URLs such as */show.php?id=102*.
    This URL would request the PHP script *show.php* via the GET method, while passing
    the product’s ID (in this case, 102) through the query string id variable. The
    GET method is more appropriate than POST in this case since the intended result
    is simply to display data (so no content is being changed on the server).
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoding the Links
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s create the page shown in [Figure 11-10](#fig11-10). For simplicity, we’ll
    begin by hardcoding the product IDs into the hyperlinks. Create a new project
    containing a *public* folder and add an *index.php* script to that folder. Then
    enter the code in [Listing 11-10](#lis11-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-10: An index.php file with data embedded in the Details hyperlinks'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we read in the Bootstrap CSS stylesheet as a shortcut
    for styling the page. In the page’s HTML, we create two links with the text Details,
    styled as blue buttons using the Bootstrap CSS class btn btn-primary: one for
    a hammer ❶ and one for a bucket of nails ❷. Each link is to the PHP script *show.php*,
    with the ID of the product encoded into the URL in the fashion ?id=102. Clicking
    one of these links will send the appropriate id variable via a GET request, as
    shown in [Figure 11-11](#fig11-11).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: The result of clicking one of the Details links'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t worry about writing the *show.php* script, but notice that clicking
    the Details link for the bucket of nails initiates a GET request with an id value
    of 511 embedded in the query string.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In a more realistic scenario, we wouldn’t hardcode* id *values into links
    like this. Instead, we’d loop through an array representing the products in the
    user’s shopping cart and programmatically insert each product’s ID into its corresponding
    Details link. We’ll look at how to do this next.*'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Links Programmatically
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most of the content presented in web pages is dynamically generated at runtime
    based on values in the website’s database. Therefore, instead of hardcoding product
    ID values into links like */show.php?id=102*, links are usually created programmatically
    with PHP statements looping through a collection of data representing the items
    in the user’s shopping cart. Each time through the loop, the product’s ID is looked
    up and dynamically inserted into a hyperlink. The product’s description and price
    are similarly dynamically inserted into generic HTML template text.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update our shopping cart page to try this approach. We’ll use an array
    to represent the shopping cart as a whole; each item in the array will itself
    be an array representing a particular cart item, with three values for the ID,
    description, and price of the product. Modify the *index.php* file as shown in
    [Listing 11-11](#lis11-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-11: Using a PHP loop to create the Details links for the shopping
    cart items'
  prefs: []
  type: TYPE_NORMAL
- en: Before any HTML, we use a PHP code block to declare an $items array containing
    information about our two products. (Of course, we’re still hardcoding the information,
    albeit within an array; in a more realistic scenario, we’d retrieve the product
    information from a database, as we’ll discuss in [Part VI](part6.xhtml)). Then
    we begin the HTML template text. Under the Your shopping cart heading, we use
    another PHP code block to begin a foreach loop in which the $item variable will
    represent the current element of the $items array ❶. We use alternative loop syntax
    with a colon (:) to set up the start of the loop and endforeach ❸ to close it.
    See [Chapter 6](chapter6.xhtml) to review this alternative loop syntax which makes
    it easier to combine PHP with HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we use a mix of HTML and PHP short echo tags within a <div>
    to insert the current product’s 'description', 'price', and 'id' values into the
    template text. In this way, we dynamically create a <div> element for each product,
    including a Bootstrap-styled Details link. Notice in particular that we embed
    the product’s ID into the href property of the <a> element ❷, which will result
    in hyperlinks like */show.php?id=102*, just as before. Overall, the page should
    look exactly the same as [Figure 11-10](#fig11-10).
  prefs: []
  type: TYPE_NORMAL
- en: Other Form Input Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single text and numeric form inputs (text, password, textarea, and so on) are
    all sent in the HTTP request as a name/value pair, but other types of form data
    aren’t quite so simple. It’s important to understand how the browser chooses the
    variable names and values for these other form elements so that you can write
    server scripts to correctly retrieve and validate the incoming data. In this section,
    we’ll discuss how to work with other common form elements like radio buttons,
    checkboxes, and single- and multiple-selection lists.
  prefs: []
  type: TYPE_NORMAL
- en: Radio Buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Radio buttons* are a set of two or more form input choices offered to the
    user, of which only one value can be chosen. Radio button inputs are declared
    in groups that share the same name attribute, with each having a unique value
    attribute to distinguish which input was selected. In this way, a set of radio
    buttons forms a group of mutually exclusive choices for the value assigned to
    the shared name attribute. Except in rare situations where it’s acceptable for
    no option to be selected, one of the radio buttons should be automatically checked
    so the user is offered a default choice. This way, a value will definitely be
    sent in the HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the HTML for a form that uses radio buttons to present a choice
    between two Irish counties, as shown in [Figure 11-12](#fig11-12). This figure
    also illustrates the output when the form is processed by *process.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: Radio buttons submitting values via a query-string parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project containing a *public* folder with an *index.php* script,
    then enter the code shown in [Listing 11-12](#lis11-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-12: An HTML form illustrating radio buttons'
  prefs: []
  type: TYPE_NORMAL
- en: We create a form using the GET method with an action attribute to request the
    *process.php* script. Within the form, we declare two radio buttons (<input> elements
    of type "radio"), both with "county" as a name attribute. One has a value of "dublin"
    ❶, and the other a value of "cork" ❷. We use the checked attribute to set the
    Dublin option as the default. All the user sees for a radio button is a small
    circular input, so it’s important to add a text or image prompt immediately next
    to each radio button, and to use <label> elements so that the user can click either
    the text or the button.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The labels show each county starting with a capital letter (such as* Dublin*),
    while the corresponding values start with a lowercase letter (*dublin*). Personally,
    I always use lower camel case for the values of radio buttons, checkboxes, and
    other inputs. Having a consistent naming convention like this makes it easier
    to write the form-processing logic without having to look back at the form code
    itself and reduces the number of mistakes you’re likely to make.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because this form uses the GET method, we’ll see either ?county=dublin or ?county=cork
    in the URL when the form is submitted. In other words, the name attribute of the
    radio button group serves as the key for a query-string variable, and the value
    attribute of the selected button serves as the variable’s value. We would therefore
    use filter_input(INPUT_GET, 'county') to extract the value submitted by the user
    through the button group.
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Checkboxes* offer Boolean (true/false) choices to the user. They appear in
    the browser as small squares that can be checked or unchecked. You might use checkboxes
    in a form, for example, to allow the user to select toppings when ordering a pizza.
    Unlike radio buttons, checkboxes aren’t mutually exclusive; the user can check
    as many of the boxes as they want. As with radio buttons, adding text or an image
    prompt immediately next to each checkbox lets the user know what they’re selecting.'
  prefs: []
  type: TYPE_NORMAL
- en: The checkboxes in a form can be treated individually or processed collectively
    as an array. We’ll look at both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Treated Individually'
  prefs: []
  type: TYPE_NORMAL
- en: When checkboxes are treated individually, each one should have a unique name
    attribute. You can define a value attribute for each checkbox as well, but it
    isn’t really necessary for processing the form. A checkbox will send its name/value
    pair with the HTTP request only if it has been selected, so on the receiving end,
    it’s sufficient to simply test for the box’s name with the filter_has_var() function,
    regardless of the box’s value. If a checkbox is selected and no value was defined,
    the default value of on will be submitted with the form data.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, let’s use checkboxes to create a form for pizza toppings.
    [Figure 11-13](#fig11-13) shows how the form should look.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: A form with checkboxes'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project with a *public/index.php* file containing the code in [Listing
    11-13](#lis11-13) to design the pizza toppings form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-13: An HTML form with checkboxes'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a form declared with the GET method, we create checkboxes for the olives,
    pepper, and garlic salt options, as well as a Submit button. Each checkbox has
    a unique name attribute and is immediately followed by a text label to indicate
    which option the checkbox represents. Because the checkboxes don’t have explicitly
    declared value attributes, when the user submits the form, each checkbox that
    has been selected will add a variable to the query string in the form *<name>=on*.
    For example, if only “Olives” is selected, the form will trigger a GET request
    with the URL *http://localhost:8000/process.php?olives=on*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11-14 illustrates the sort of logic we might use in the *process.php*
    script to detect one of the checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-14: Detecting an individual checkbox'
  prefs: []
  type: TYPE_NORMAL
- en: We call filter_has_var() with INPUT_GET and 'olives' to detect whether an olives
    variable was sent with the GET request, indicating this box was checked. We store
    the resulting true/false value in $olivesSelected, which for simplicity we pass
    to var_dump(). In a more realistic scenario, we might use the Boolean to set up
    conditional logic. We could use a similar filter_has_var() test for the other
    checkboxes, as long as each is uniquely named.
  prefs: []
  type: TYPE_NORMAL
- en: Treated as an Array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes it’s more practical to treat two or more checkboxes as related by
    giving them all the same name attribute ending in square brackets. For example,
    the checkboxes in the pizza toppings form could all be given a name of toppings[].
    This way, all the toppings that are selected will be grouped into an array and
    sent in the HTTP request under the same toppings variable name. When taking this
    approach, it’s vital to ensure that each checkbox has a unique value attribute
    so the individual boxes can still be distinguished from one another.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 11-15 shows how to rewrite the pizza toppings form to send all selected
    checkboxes as values in a single array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-15: Grouping a form’s checkboxes into an array'
  prefs: []
  type: TYPE_NORMAL
- en: As before, we declare checkboxes for the three topping options. However, this
    time we assign toppings[] as the name for each checkbox so they will be grouped
    into a toppings array. We also add a value attribute to each checkbox, indicating
    the type of topping to be added to the array if selected. [Figure 11-14](#fig11-14)
    shows how multiple values for toppings[] appear in the query string when the form
    is submitted with all three boxes checked.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: Checkbox values being submitted as values for a single array
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: To successfully process this form, we’ll have to ensure that the *process.php*
    script is set up to expect an array of checkbox values. The array may be empty
    if no checkboxes were selected, or it could contain one or more values. [Listing
    11-16](#lis11-16) uses an if...else statement to handle both cases, so it should
    work regardless of how many pizza toppings are selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-16: Processing an array of checkbox values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the values of the checkboxes matter, we need to use filter _input()
    instead of filter_has_var() ❶. As usual, we use the function’s first two arguments
    to retrieve a toppings variable from the query string, but this time we also use
    a named argument of options: FILTER_REQUIRE_ARRAY to specify that we’re looking
    for an array of values under the toppings variable name. We store the resulting
    array in the $toppings PHP variable.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a named argument here because $options is the filter _input()
    function’s fourth parameter. We’re skipping over the third parameter, $filter,
    leaving it with its default value of FILTER_DEFAULT. See [Chapter 5](chapter5.xhtml)
    for a review of named and optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We next use an if...else statement to check whether the $toppings array is empty.
    If so, we print a message accordingly ❷. Otherwise, we use the built-in implode()
    array function to collapse the array of toppings into a single string, with the
    topping names separated by plus signs ❸. Look back at the bottom of [Figure 11-14](#fig11-14)
    to see the resulting string of toppings when all three boxes are checked.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Selection Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *single-selection list* displays as a drop-down menu enabling the user to
    choose one option. This list is created with an HTML <select> element containing
    <option> elements representing the possible choices. The <select> element has
    a name that will be assigned the value of the chosen <option> element when the
    form is submitted, resulting in a straightforward name/value pair on the receiving
    end. [Figure 11-15](#fig11-15) shows a form offering a simple single-selection
    list of flowers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: A single-selection list'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create this flower form. Start a new project with a *public/index.php*
    file and enter the contents of [Listing 11-17](#lis11-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-17: An HTML form with a single-selection list'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a form with the GET method containing a Submit button alongside a
    selection list with the name flower ❶. The <select> element holds three <option>
    elements with value attributes of poppy, daisy, and tulip. When the form is submitted,
    the selected flower will be sent in the HTTP request as a query parameter named
    flower. In [Figure 11-15](#fig11-15), for example, *flower=poppy* appears in the
    query string when the poppy is selected.
  prefs: []
  type: TYPE_NORMAL
- en: We can process the choice submitted through a single-selection list by using
    filter_input() and the name of the select element. In the case of our flower form,
    for example, we can use filter_input(INPUT_GET, 'flower') to extract the user’s
    chosen flower.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-Selection Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A multiple-selection list allows the user to choose more than one option from
    a menu. This list is created by adding the multiple attribute to the HTML <select>
    element. [Figure 11-16](#fig11-16) shows a multiple-selection version of our flower
    form.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure11-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: A multiple-selection list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas a single-selection list results in a simple name/value pair, a multiple-selection
    list should be handled similarly to the array approach we used for checkboxes:
    the list should have a name attribute ending with square brackets, as in flowers[].
    This way, we’ll get an array containing the zero, one, or more values selected
    from the list’s options. [Listing 11-18](#lis11-18) shows how to modify the *index.php*
    file for our flower form to turn it into a multiple-selection list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-18: An HTML form illustrating a multiple-selection list as an array
    of values'
  prefs: []
  type: TYPE_NORMAL
- en: We modify the selection list to have an array name of flowers[] ❶ and specify
    that it should be displayed in a box that fits three rows. We include the multiple
    attribute to indicate that the user may select more than one item from the list
    (this attribute doesn’t need to be assigned a value) ❷. When the form is submitted,
    any selected flowers will be sent in the HTTP request as an array named flowers.
  prefs: []
  type: TYPE_NORMAL
- en: We can process this form by using similar logic to that of our script processing
    an array of checkboxes from [Listing 11-16](#lis11-16). We use an if...else statement
    to check whether the incoming array is empty, as shown in [Listing 11-19](#lis11-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-19: Processing the array of values from a multiple-selection list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We extract the $flowers array from the incoming GET request, once again using
    the extra options: FILTER_REQUIRE_ARRAY argument to filter_input() to specify
    that we’re looking for an array. Then, if the array isn’t empty, we use implode()
    to merge the received flowers into a string separated by plus signs.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored how to create web forms that submit data to server
    scripts, and we discussed the difference between submitting those forms with the
    HTTP GET and POST methods. We also covered how to write server-side scripts to
    identify and extract the submitted form data. We focused on how to use PHP’s filter_input()
    function to extract the values of variables from an incoming HTTP request, as
    well as how to use filter _has_var() when all we need to know is whether a variable
    exists at all. We applied this approach to a variety of form input types, including
    text inputs, radio buttons, checkboxes, and selection lists.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create a form for a costume-rental company that enables the user to submit
    the name of the superhero costume they want. Make the form submit data via the
    HTTP GET method to a PHP script called *costumeSearch.php*, and use hero for the
    name of the text value entered by the user. Visit the form through your web server
    and submit the value superman. You should see *costumeSearch.php?hero=superman*
    in the resulting URL.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Create a basic login form using the HTTP POST method, with <input> elements
    for a username (using the default text type) and a password (use the password
    type). Use your browser’s developer tools to inspect the form data when it’s submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Create a form to input the user’s age and a script to process the received
    age. The processing script should return an HTML page containing a message stating
    how old the user will be on their next birthday.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Create a form with radio buttons asking the user whether they would be
    willing to pay more for an environmentally friendly car. If they say yes, return
    an HTML page containing a message recommending they buy an electric car. If they
    say no, recommend a gas car.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Create a form offering the user several options for a new car, each represented
    with a uniquely named checkbox. For example, offer options such as metallic paint,
    fog lights, and a reversing camera. Write a script that processes the form data
    and returns an HTML page containing a message confirming each selected option.
  prefs: []
  type: TYPE_NORMAL
- en: 6.   Duplicate your answer for Exercise 5 about car options, but change the
    checkboxes to send the data as part of an array variable named extras[]. Update
    your form-processing code to handle the array. Think about whether you find the
    array approach easier or harder than processing the checkboxes individually.
  prefs: []
  type: TYPE_NORMAL
