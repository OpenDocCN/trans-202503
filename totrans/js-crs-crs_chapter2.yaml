- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    BASICS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">基础知识</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: In this chapter, I’ll introduce some of the basic ingredients that make up any
    JavaScript program. You’ll learn about the fundamental units of JavaScript code
    that allow you to represent values and give instructions to the computer. You’ll
    also learn how to assign a name to a value so you can refer to it later in your
    code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍构成任何 JavaScript 程序的一些基本元素。你将了解 JavaScript 代码的基本单元，这些单元让你能够表示值并向计算机发出指令。你还将学习如何为一个值赋予名称，以便在代码中以后引用它。
- en: This chapter also shows how JavaScript categorizes values into different data
    types based on the kind of information a value can represent. We’ll focus on primitive
    data types that represent individual values, such as a single number or a single
    piece of text. You’ll practice working with different primitive data types in
    the JavaScript console and explore some of the operations you can apply to them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还展示了 JavaScript 如何根据值可以表示的信息种类将值分类为不同的数据类型。我们将重点介绍表示单一值的原始数据类型，例如一个数字或一段文本。你将练习在
    JavaScript 控制台中使用不同的原始数据类型，并探索可以应用于它们的一些操作。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Expressions and Statements</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">表达式与语句</samp>
- en: The most basic building block in JavaScript is the *expression*, a fragment
    of code that represents a single value. The act of determining the value of an
    expression is known as *evaluation*. For example, 100 + 200 is an expression that
    evaluates to the number 300.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中最基本的构建块是 *表达式*，它是表示单一值的代码片段。确定表达式值的过程被称为 *求值*。例如，100 + 200 是一个表达式，它求值为数字
    300。
- en: Another important JavaScript building block is the *statement*, which is a complete
    thought, like a sentence in English, instructing the computer to do something.
    Every JavaScript program consists of a series of statements. In [Chapter 1](chapter1.xhtml),
    for example, we used the statement alert("Hello, world!"); to instruct the computer
    to display a dialog with the text *Hello, world!* in it. Whereas a sentence ends
    with a period, JavaScript statements end with a semicolon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的 JavaScript 构建块是 *语句*，它是一个完整的思想，像英语中的句子，指示计算机做某事。每个 JavaScript 程序都由一系列语句组成。例如，在[第一章](chapter1.xhtml)中，我们使用了语句
    alert("Hello, world!"); 来指示计算机显示一个包含 *Hello, world!* 文本的对话框。与句子以句号结尾不同，JavaScript
    语句以分号结尾。
- en: 'You can turn an expression into a statement simply by adding a semicolon to
    the end of it. For example, 100 + 200; is a statement instructing the computer
    to add two numbers together. Open up the JavaScript console and enter this statement.
    When you do this, it will evaluate the expression in the statement and print the
    result:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地在表达式末尾加上分号，将表达式转化为语句。例如，100 + 200; 就是一个语句，指示计算机将两个数字相加。打开 JavaScript
    控制台并输入此语句。当你这样做时，它将对语句中的表达式进行求值并打印结果：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main expression in this statement, 100 + 200, is known as a *compound expression*,
    since it actually contains two smaller expressions, 100 and 200. These are examples
    of the simplest form of JavaScript expression, the *literal*, which is a direct
    representation of a fixed value in code. Specifically, 100 and 200 are *number
    literals*, since they directly correspond to the numeric values they represent,
    100 and 200\. By contrast, the compound expression 100 + 200 isn’t a literal,
    since it doesn’t directly correspond to its value of 300\. The + in this compound
    expression doesn’t represent a value at all. Rather, it’s an *operator*, a symbol
    used to combine or manipulate expressions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句中的主要表达式 100 + 200 被称为 *复合表达式*，因为它实际上包含了两个较小的表达式，100 和 200。这些是 JavaScript
    表达式最简单形式的示例，*字面量*，即在代码中直接表示一个固定值。具体来说，100 和 200 是 *数字字面量*，因为它们直接对应它们表示的数值 100
    和 200。相反，复合表达式 100 + 200 不是字面量，因为它并不直接对应它的值 300。这个复合表达式中的 + 并不表示一个值。它实际上是一个 *运算符*，用于组合或操作表达式的符号。
- en: It’s important to distinguish between values, which are the underlying pieces
    of data in a program, and expressions, which are the notations in code that tell
    JavaScript what the values should be. Both 300 and 100 + 200 have a value of 300,
    but they’re two different expressions—one literal, one compound—that provide different
    ways of representing that value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 区分值和表达式很重要，值是程序中的底层数据，而表达式是代码中的符号，告诉 JavaScript 值应该是什么。300 和 100 + 200 都有一个值
    300，但它们是两种不同的表达式——一个是字面值，另一个是复合表达式——它们以不同的方式表示这个值。
- en: JavaScript expressions and statements complement each other. Expressions have
    values, but an expression by itself doesn’t actually *do* anything. Conversely,
    statements do work by telling the computer to perform tasks, but statements themselves
    don’t have values; they’re just instructions. The power of programming comes from
    writing statements that use and manipulate the values of expressions to achieve
    the desired outcomes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 表达式和语句相辅相成。表达式有值，但表达式本身并不会*做*任何事情。相反，语句通过告诉计算机执行任务来完成工作，但语句本身没有值；它们只是指令。编程的力量来自于编写语句，利用并操作表达式的值以达到预期的结果。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Numbers and Operators</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_11">数字和运算符</samp>
- en: 'JavaScript uses the *number* data type to store numeric values. You already
    started working with numbers in the previous section, where you also met the +
    operator, which adds two numbers together. JavaScript has operators for other
    common mathematical calculations, too, including subtraction (-), multiplication
    (*), and division (/). Try them out in the JavaScript console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用*数字*数据类型来存储数值。你已经在上一节中开始使用数字，并且遇到了 + 运算符，它将两个数字相加。JavaScript 也有其他常见数学运算的运算符，包括减法（-）、乘法（*）和除法（/）。在
    JavaScript 控制台中试试这些运算符：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In cases like this, where the expression involves an operator (such as + or
    *), we often say the operator *returns* a value (rather than saying an expression
    is being *evaluated*). For instance, the * operator takes in the numbers 999 and
    111 and returns their product, 110889.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样的情况中，表达式涉及一个运算符（例如 + 或 *），我们通常说运算符*返回*一个值（而不是说表达式被*求值*）。例如，* 运算符接收数字 999
    和 111，并返回它们的乘积 110889。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Order of Operations</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运算顺序</samp>
- en: 'You can combine multiple numbers and operators in a single expression, in which
    case you need to think about the order in which the operations will be performed.
    Consider this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个表达式中组合多个数字和运算符，在这种情况下，你需要考虑操作执行的顺序。考虑这个例子：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you have multiple operators like this, JavaScript uses the standard mathematical
    PEMDAS (parentheses, exponents, multiplication, division, addition, subtraction)
    rule to determine the order of calculations. The division operation in this expression
    takes place first, followed by the addition and subtraction, yielding a value
    of 1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个运算符时，JavaScript 使用标准的数学 PEMDAS（括号、指数、乘法、除法、加法、减法）规则来确定计算顺序。这个表达式中的除法操作首先执行，其次是加法和减法，最终得到的值是
    1。
- en: 'To force the addition and subtraction to happen first, use parentheses:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制加法和减法先进行，可以使用括号：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, the expression produces a different value, since the parentheses
    changed the order of operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，表达式产生了不同的值，因为括号改变了运算顺序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Point</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点数</samp>
- en: 'So far we’ve limited ourselves to whole numbers, but JavaScript’s number data
    type also accommodates fractional numbers, called *floating-point numbers* in
    programming terms. Here’s an expression that produces a floating-point number:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅限于整数，但 JavaScript 的数字数据类型也可以容纳小数，即编程术语中的*浮点数*。这里有一个生成浮点数的表达式：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Floating-point numbers have limited precision, so the decimal component can’t
    go on forever. Instead, they’re truncated, as in the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的精度有限，因此小数部分不能无限延续。相反，它们会被截断，如以下示例所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You may notice some weird quirks of floating-point math, where the answer isn’t
    quite what you’d expect. For example, 0.1 + 0.2 doesn’t work out to exactly 0.3.
    Instead, we get several extra decimal places:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到浮点数学的一些怪异现象，其中结果不是你预期的那样。例如，0.1 + 0.2 并不会准确等于 0.3。相反，我们得到了一些额外的小数位：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is due to the underlying mathematics of how computers represent numbers
    (search the web for “floating-point arithmetic” to learn more). In general, these
    quirks shouldn’t affect you, but they could in certain circumstances. For example,
    if you’re writing an application that works with monetary values, it could be
    a problem if $0.10 and $0.20 didn’t sum to exactly $0.30\. In this case, the usual
    solution is to convert your monetary values to cents (or the equivalent smallest
    denomination) before doing any math on them. For example, the number 0.10, representing
    an amount of dollars, would become 10, representing an amount of cents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于计算机表示数字的基础数学原理（可以在网上搜索“浮动点运算”了解更多）。一般来说，这些问题不应该影响你，但在某些情况下可能会。举个例子，如果你正在编写一个处理货币数值的应用程序，假如$0.10和$0.20相加后不等于$0.30，可能就会成为问题。在这种情况下，通常的解决方案是将货币数值转换为美分（或等值的最小单位），然后再进行数学计算。例如，表示美元金额的数字0.10将变成表示美分金额的10。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bindings</samp>
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">绑定</samp>
- en: In JavaScript, you can associate a name with a value so you can easily reference
    that value later in your code. This association is called a *binding*. Bindings
    are powerful tools because they provide a place to store the values your expressions
    generate. Without them, your programs would have no way of remembering the work
    they’ve already done.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以将一个名称与一个值关联，这样以后在代码中可以轻松引用该值。这个关联称为*绑定*。绑定是非常强大的工具，因为它们提供了一个存储表达式生成值的地方。没有它们，你的程序将无法记住它们已经做过的工作。
- en: One type of binding is a *variable*, which allows you to update the value associated
    with a particular name as needed. They’re called variables because their values
    can change, or vary. Another type of binding is a *constant*, where you can’t
    update the value associated with the name once it’s been assigned. The value remains
    fixed, or constant.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种绑定类型是*变量*，它允许你根据需要更新与特定名称关联的值。它们之所以叫变量，是因为它们的值可以变化或改变。另一种绑定类型是*常量*，在赋值后你不能更新与名称关联的值。这个值保持不变，或者说是常量。
- en: Think of a variable or constant as a box with a label (the name) that holds
    a single item (the value). You put a value in the box, then look it up by name
    when you need it again. A variable allows you to put a new value in the box, while
    a constant will always contain the same value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 把变量或常量想象成一个有标签（名称）的盒子，里面放着一个单独的物品（值）。你把一个值放进盒子，然后在需要时通过名称去查找它。变量允许你把新值放进盒子，而常量将始终保持相同的值。
- en: 'The name of a binding is also called its *identifier*, and creating an identifier
    is known as *declaration*: the binding’s name is being declared. In JavaScript,
    a declaration is a special kind of statement that generates a new identifier.
    Let’s look at how to declare and work with variables and constants.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的名称也叫做*标识符*，创建标识符的过程称为*声明*：绑定的名称正在被声明。在JavaScript中，声明是一种特殊类型的语句，它生成一个新的标识符。让我们来看一下如何声明并使用变量和常量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">变量</samp>
- en: 'JavaScript has two keywords for declaring variables: var and let. A *keyword*
    is a word built into the JavaScript language that’s reserved for a particular
    purpose. Originally, the var keyword was the only option available, but let was
    later added to fix some of the shortcomings of var. Today, let is the preferred
    keyword for declaring variables, so that’s what we’ll use in this book, but don’t
    be surprised if you encounter var while looking at older code.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两个关键字用于声明变量：var和let。*关键字*是内建于JavaScript语言中的一个词，它被保留用于特定的目的。最初，var关键字是唯一的选择，但后来let被加入以修复var的一些不足。如今，let是声明变量时推荐使用的关键字，所以在本书中我们将使用let，但在查看旧代码时，如果遇到var也不要惊讶。
- en: 'Here’s an example of using let to declare a variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用let声明变量的例子：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This let declaration creates a new variable called age. A let declaration doesn’t
    have a value, so the JavaScript console prints out the special value undefined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个let声明创建了一个名为age的新变量。let声明本身没有值，因此JavaScript控制台会打印出特殊值undefined。
- en: 'Now that we’ve created a variable, let’s write an expression to give it a value:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个变量，接下来让我们编写一个表达式来赋予它一个值：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Giving a variable a value is called *assignment*, and you use the assignment
    operator (=) to do it. On the right side of the operator, you enter an expression
    (in this case, the number literal 35), and on the left, you enter the name of
    the variable that should be assigned the value of that expression (in this case,
    age).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给变量赋值叫做 *赋值*，你可以使用赋值运算符（`=`）来完成。在运算符的右侧，你输入一个表达式（在这个例子中是数字字面量 35），在左侧，你输入应该被赋予该表达式值的变量名（在这个例子中是
    `age`）。
- en: An assignment using the = operator is a compound expression, just like expressions
    using + and other mathematical operators. The value of an assignment expression
    is the new value of the variable. In this case, we’ve set age to 35, so the console
    prints 35.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `=` 运算符进行赋值是一种复合表达式，就像使用 `+` 和其他数学运算符的表达式一样。赋值表达式的值是变量的新值。在这种情况下，我们将 `age`
    设置为 35，所以控制台打印出 35。
- en: 'Assigning a value to a variable for the first time is called *initialization*.
    Programmers usually combine the declaration and initialization of a variable into
    a single line of code. For example, here we create a new variable called cats
    and assign it the value 2, all in the same statement:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次给变量赋值叫做 *初始化*。程序员通常将变量的声明和初始化合并成一行代码。例如，在这里我们创建了一个名为 `cats` 的新变量，并给它赋值为 2，所有操作都在同一句话中完成：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though we’re assigning the variable a value here, the prevailing rule is
    that the let declaration itself has no value, so the JavaScript console prints
    undefined.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里给变量赋值，但主要规则是 `let` 声明本身没有值，因此 JavaScript 控制台会打印出 undefined。
- en: 'To confirm the assignment worked, enter just the variable name into the console,
    followed by a semicolon:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认赋值是否成功，只需在控制台中输入变量名，后跟分号：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, cats is an expression that evaluates to the current value of the cats
    variable, so the console prints that value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cats` 是一个表达式，它的值是当前 `cats` 变量的值，因此控制台打印出这个值。
- en: 'Because cats is a variable, we’re free to change its value using new assignment
    expressions. Here, for example, we update its value to 3:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `cats` 是一个变量，我们可以使用新的赋值表达式自由地更改它的值。例如，这里我们将它的值更新为 3：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The nice thing about variables is that you can change their values whenever
    you need—for example, when you get another cat.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的一个好处是，你可以随时更改它们的值——例如，当你得到另一只猫时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constants</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">常量</samp>
- en: 'To declare a constant in JavaScript, we use the const keyword:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中声明常量时，我们使用 `const` 关键字：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a new constant called PI and assigns it the value 3.141592653589793,
    which is the approximate value of the number π.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为 `PI` 的新常量，并赋值为 3.141592653589793，这就是数字 π 的近似值。
- en: 'Now we can use that constant to determine the circumference of a circle based
    on its diameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个常量来根据圆的直径计算圆的周长：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we create a variable called diameter and assign it the value 3. Then we
    create another variable, circumference, and assign it a value of diameter * PI.
    Notice that we’re using a compound expression consisting of a variable (diameter),
    a constant (PI), and a math operation (*) to set the value of a variable. A lot
    of programming boils down to creating constants and variables, and then manipulating
    them to create other constants and variables.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `diameter` 的变量并赋值为 3。然后我们创建了另一个变量 `circumference`，并给它赋值为 `diameter
    * PI`。请注意，我们使用了一个复合表达式，由一个变量（`diameter`）、一个常量（`PI`）和一个数学运算符（`*`）组成，来设置变量的值。编程的核心就是创建常量和变量，然后通过操作它们来创建其他常量和变量。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Going forward, to keep the book’s code listings from getting too cluttered,
    I’ll stop showing the undefined that the console prints after a variable or constant
    is declared.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了避免书中的代码示例过于杂乱，从现在开始，我将不再显示变量或常量声明后控制台打印的 undefined。*'
- en: 'Unlike with variables, you can’t change the value of a constant once it’s been
    created. For example, if you try to update the value of PI, JavaScript gives an
    error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量不同，一旦常量被创建，你就无法更改它的值。例如，如果你尝试更新 PI 的值，JavaScript 会报错：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Errors are how JavaScript tells you there’s something wrong with your code.
    The important part of this error message is Assignment to constant variable. This
    indicates that we mistakenly tried to assign a new value to a constant.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是 JavaScript 告诉你代码有问题的方式。这个错误信息中最重要的部分是“Assignment to constant variable”（赋值给常量变量）。这表明我们错误地试图给一个常量赋一个新值。
- en: 'Also unlike with variables, where you can separate the declaration from the
    initialization, you have to give a constant its value in its declaration. As a
    result, this won’t work:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量不同，你不能将常量的声明与初始化分开，你必须在声明时就为常量赋值。因此，下面的代码是无法工作的：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This error message tells us that the constant declaration is missing its initializer,
    meaning the constant should have been given a value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息告诉我们，常量声明缺少初始化器，意味着常量应该在声明时赋予一个值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Naming Conventions</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">命名约定</samp>
- en: You should give variables and constants descriptive names, so when you or somebody
    else is reading your code, it’s clear what your variables and constants represent.
    For example, if you’re writing code to control a car, you might want a variable
    that stores the speed of the car in miles per hour. The name speedInMilesPerHour
    is a bit too long, but given that MPH is a commonly understood abbreviation for
    miles per hour, a good variable name would be speedInMPH. A shorter name like
    speed might be okay, but only if it’s obvious to everyone reading your code that
    speed is always in miles per hour. (Imagine if someone from Germany were reading
    your code and thought you were talking about kilometers per hour.) A bad name
    for this variable would be s, which tells the reader nothing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该给变量和常量起有描述性的名字，这样当你或其他人阅读你的代码时，能清楚地知道这些变量和常量代表什么。例如，如果你在写控制汽车的代码，你可能需要一个变量来存储汽车的速度，单位是英里每小时。speedInMilesPerHour
    这个名字有点长，但考虑到 MPH 是一个广泛理解的“英里每小时”缩写，好的变量名应该是 speedInMPH。像 speed 这样的简短名字也可以，但前提是每个阅读代码的人都能明确知道这个
    speed 是以英里每小时为单位。（想象一下，如果有一个来自德国的人在阅读你的代码，认为你说的是公里每小时。）这个变量的一个糟糕名字是 s，它完全没有给读者任何提示。
- en: JavaScript is case sensitive, which means it distinguishes between the variables
    age, Age, and AGE. Also, identifiers can’t contain spaces. To work around that,
    a common convention for variable names is to use *camelCase*, where the first
    word in the name starts with a lowercase letter and each subsequent word starts
    with a capital letter, as in speedInMilesPerHour. (It’s called camelCase because
    the capital letter in the middle looks like the hump of a camel.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是区分大小写的，这意味着它会区分变量 age、Age 和 AGE。此外，标识符不能包含空格。为了避免这个问题，常见的变量命名约定是使用*camelCase*，其中名称中的第一个单词以小写字母开头，后续单词以大写字母开头，例如
    speedInMilesPerHour。（之所以叫 camelCase，是因为中间的大写字母看起来像骆驼的驼峰。）
- en: An alternative naming convention for variables is *snake_case*, where everything
    is lowercase and each word is separated by an underscore. (I guess this looks
    a bit like a snake if you squint.) In snake_case, we would write speed_in_miles_per_hour
    or speed_in_MPH.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变量命名约定是*snake_case*，其中所有字母都是小写，每个单词之间用下划线分隔。（我猜这看起来有点像蛇，如果你眯着眼睛看。）在 snake_case
    中，我们可以写作 speed_in_miles_per_hour 或 speed_in_MPH。
- en: Using snake_case can make variable names slightly clearer than camelCase, but
    it also makes them longer and harder to type quickly. JavaScript programmers tend
    to prefer camelCase, so that’s what I’ll use in this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蛇形命名法（snake_case）可以让变量名比驼峰命名法（camelCase）稍微更清晰一些，但它也让变量名变得更长，而且输入时不容易快速打字。JavaScript
    程序员通常偏好使用驼峰命名法，所以本书中我将使用这种命名法。
- en: 'Constants follow a separate naming convention from variables. There are two
    types of constants: *true constants*, which have values that will never change
    whenever you run the program (such as pi or the number of hours in a day), and
    values you’ve made constants because you don’t want to accidentally change them
    in your code (such as the current user’s name). For true constants, it’s customary
    to use all-caps snake_case, like HOURS_IN_A_DAY. For constants you’ve created
    to avoid accidentally changing a value, use the same convention as for variables.
    In that case, the only difference is that the binding has been created using const
    rather than let.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 常量遵循与变量不同的命名约定。常量有两种类型：*真正的常量*，它的值在程序运行时永远不会改变（例如 pi 或一天中的小时数），以及那些你将其设为常量，因为你不希望在代码中不小心修改它们的值（例如当前用户的名字）。对于真正的常量，习惯上使用全大写的
    snake_case，例如 HOURS_IN_A_DAY。对于那些为了避免意外修改值而创建的常量，使用与变量相同的命名约定。在这种情况下，唯一的区别是，绑定是使用
    const 而不是 let 创建的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Incrementing and Decrementing</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">递增与递减</samp>
- en: When you’re writing software, you’ll often have to *increment* (increase) or
    *decrement* (decrease) the value of a variable by 1 or some other number. For
    example, you might use a variable to count the occurrences of a word in a document.
    Every time you see that word, you would increase the value of the variable by
    1\. Likewise, you might use a variable to keep track of how much money a player
    has in a game, increasing or decreasing it whenever the player earns or spends
    some.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，你经常需要对变量的值进行*递增*（增加）或*递减*（减少）1或其他数字。例如，你可能会使用一个变量来统计文档中某个单词的出现次数。每次看到该单词时，你就将变量的值加1。同样，你也可以使用一个变量来跟踪游戏中玩家的金额，每当玩家赚取或花费一些钱时，就增加或减少这个金额。
- en: 'One way to increment a variable is to initialize it, then change its value
    to itself plus 1:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 递增变量的一种方法是初始化它，然后将它的值改为其原值加1：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we declare a new variable called money and initialize it with the value
    100. We then assign a new value to money by adding 1 to its existing value. It
    may seem paradoxical to see an expression like money = money + 1;, but this is
    actually quite a normal programming pattern. When JavaScript encounters an assignment
    expression like this, it first calculates the value of the expression on the right
    of the assignment operator, which in this case is money + 1. Because money is
    currently 100, money + 1 has a value of 101. JavaScript then updates the value
    of the variable on the left side of the assignment operator, which in this case
    is the same variable, money.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个名为money的新变量，并将其初始化为100。然后，我们通过给money现有的值加1来给money赋新值。看到像money = money
    + 1;这样的表达式可能会显得有些矛盾，但实际上这是一种很常见的编程模式。当JavaScript遇到像这样的赋值表达式时，它会首先计算赋值运算符右侧表达式的值，在这个例子中就是money
    + 1。因为money当前是100，所以money + 1的值是101。然后，JavaScript会更新赋值运算符左侧变量的值，这里是同一个变量money。
- en: The key here is that JavaScript waits to change the value of the variable on
    the left of the operator until after it’s calculated the value of the expression
    on the right of the operator. This is how the same variable can appear on both
    sides of the operator. In the end, money = money + 1 means “add 1 to money.”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，JavaScript会等到计算完运算符右侧表达式的值之后，才会更改运算符左侧变量的值。这就是为什么同一个变量可以出现在运算符的两边。最终，money
    = money + 1的意思是“将1加到money上”。
- en: 'Because adding 1 to a variable is a very common task, JavaScript makes it easier
    with the increment operator (++). When you attach this operator to a variable,
    it increases the value of that variable by 1, without you having to write out
    a full assignment expression. Similarly, JavaScript’s decrement operator (--)
    decreases the value of a variable by 1\. Here, we use ++ and -- to change the
    value of a temperature variable:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于给变量加1是一个非常常见的任务，JavaScript通过递增运算符（++）使这个操作变得更容易。当你将此运算符附加到变量时，它会将该变量的值增加1，而无需你写出完整的赋值表达式。同样，JavaScript的递减运算符（--）会将变量的值减少1。在这里，我们使用++和--来改变一个温度变量的值：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we’ve placed the increment and decrement operators *before*
    the variable we want to change. With the operators in this position, the output
    of the increment or decrement operation is the variable’s updated value. For example,
    when temperature has a value of 70, ++temperature outputs a value of 71. This
    is called *prefix* incrementing and decrementing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将递增和递减运算符放在我们想要更改的变量*之前*。在这种位置下，递增或递减操作的输出是变量的更新值。例如，当temperature的值为70时，++temperature输出的值是71。这种方式称为*前缀*递增和递减。
- en: 'JavaScript also allows for *postfix* incrementing and decrementing, where the
    operator goes *after* the variable. In this case, the variable still increases
    or decreases by 1, but the value shown in the output is the variable’s value *before*
    it was changed. Here’s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还允许进行*后缀*递增和递减，其中运算符位于变量*之后*。在这种情况下，变量仍然会增加或减少1，但输出显示的是变量*变化之前*的值。下面是一个例子：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We initialize the books variable with the value 2. Then books++ increments that
    value, but it returns the value of books from *before* it was incremented ❶. When
    we then ask for the value of books on its own, we can see that it has the new
    value ❷, confirming that the increment operation took place.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将books变量初始化为2。然后，books++会递增这个值，但它返回的是递增之前的books值❶。当我们随后单独请求books的值时，我们可以看到它的值已经变为新的值❷，这证明了递增操作已经发生。
- en: 'Whether you use prefix or postfix incrementing and decrementing, the effect
    on the variable is the same: its value increases or decreases by 1\. The only
    difference is how the incrementing or decrementing expression itself evaluates.
    Luckily, most of the time when you use one of these operators, you won’t actually
    need the value of the incrementing or decrementing expression itself—you’ll just
    be modifying the value saved in the variable. Therefore, you can usually use the
    prefix and postfix versions interchangeably.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用前缀递增还是后缀递增，递减的效果是一样的：它的值增加或减少1。唯一的区别在于递增或递减表达式本身是如何求值的。幸运的是，大多数时候当你使用这些运算符时，实际上并不需要递增或递减表达式的值——你只需要修改保存在变量中的值。因此，你通常可以交换使用前缀和后缀版本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition and Subtraction
    Assignment</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加法与减法赋值</samp>
- en: 'The increment operator increases a variable’s value by 1, but sometimes you’ll
    want to increase it by a different amount. For that, JavaScript has the addition
    assignment operator (+=). It increases the value of the variable on the left side
    of the operator by whatever value you place to the right of the operator, as shown
    here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 递增运算符将变量的值增加1，但有时你希望将其增加不同的值。为此，JavaScript 提供了加法赋值运算符（`+=`）。它将运算符左侧的变量值增加右侧所指定的值，如下所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we use += to increase the value of price by 5. Essentially, price += 5
    is shorthand for price = price + 5. The += operator combines addition and assignment
    into one symbol.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`+=`将价格增加5。实际上，`price += 5`是`price = price + 5`的简写。`+=`运算符将加法和赋值合并成一个符号。
- en: 'Similarly, the subtraction assignment operator (-=) is a convenient way to
    subtract any value from a variable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，减法赋值运算符（`-=`）是一种方便的方式，可以从变量中减去任何值：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, cookies -= 5 is shorthand for cookies = cookies - 5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`cookies -= 5`是`cookies = cookies - 5`的简写。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication and
    Division Assi</samp><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">g</samp><samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">nment</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">乘法与除法赋值</samp><samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运算</samp><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">符</samp>
- en: 'The multiplication and division assignment operators, *= and /=, update a variable’s
    value by multiplying or dividing it by the specified number. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法赋值运算符，`*=`和`/=`，通过将变量的值乘以或除以指定的数字来更新变量的值。例如：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Similarly to the other shorthand assignment operators, these assignment operators
    translate to tribbles = tribbles * 2 and tribbles = tribbles / 3, respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他简写赋值运算符类似，这些赋值运算符分别转换为`tribbles = tribbles * 2`和`tribbles = tribbles / 3`。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Strings</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符串</samp>
- en: 'JavaScript uses the *string* data type to represent text. It’s called a string
    because the text is treated as a sequence, or string, of characters. For example,
    the string Hello! consists of six characters: H, e, l, l, o, and !.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用*字符串*数据类型来表示文本。之所以叫字符串，是因为文本被当作一串字符来处理。例如，字符串`Hello!`由六个字符组成：H、e、l、l、o
    和 !。
- en: 'A *string literal* is a direct representation of a string value. To create
    a string literal, simply surround some text with double quotation marks. Every
    character between the quotes is part of the string. For example, here we assign
    the string literal "Hello!" as the value of the variable greeting. Then we check
    the value of the variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串字面量*是字符串值的直接表示。要创建一个字符串字面量，只需将一些文本用双引号括起来。引号之间的每个字符都是字符串的一部分。例如，这里我们将字符串字面量"Hello!"赋值给变量`greeting`。然后我们检查变量的值：'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can also write string literals inside single quotation marks rather than
    double quotation marks. In fact, as shown in this example, when Chrome’s JavaScript
    console outputs a string, it encloses the string in single quotes (even if you
    wrote it with double quotes). For consistency, I’ll stick with double quotes when
    I’m writing strings throughout this book, although I’ll also use single quotes
    to accurately reflect the output of the console.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用单引号而不是双引号来书写字符串字面量。事实上，正如这个例子所示，当 Chrome 的 JavaScript 控制台输出一个字符串时，它会将该字符串用单引号括起来（即使你是用双引号书写的）。为了保持一致性，我将在本书中书写字符串时坚持使用双引号，尽管我也会使用单引号来准确反映控制台的输出。
- en: 'Typically, strings mostly consist of letters, but as our "Hello!" example indicated,
    they can also include punctuation. Strings can contain spaces, too, as well as
    numerals, as in this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字符串主要由字母组成，但正如我们在“Hello!”的示例中看到的，字符串也可以包含标点符号。字符串还可以包含空格以及数字，举例如下：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s even possible to have a string that just contains numerals, such as "123",
    but it’s important to distinguish this string from an actual number. The string
    literal "123" is a sequence of three characters, 1, 2, and 3, while the number
    literal 123 has a numerical value of 123.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以有一个只包含数字的字符串，如 "123"，但区分这个字符串和实际的数字是很重要的。字符串字面量 "123" 是三个字符的序列，1、2 和 3，而数字字面量
    123 的数值为 123。
- en: JavaScript provides a lot of ways to manipulate strings. We’ll look at some
    of these string operations next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了很多操作字符串的方法。接下来我们将查看一些这些字符串操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Joining Strings</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">连接字符串</samp>
- en: 'When applied to strings rather than numbers, the + operator joins the strings
    together. This way, you can build up a longer message by combining various strings.
    Here’s an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于字符串而不是数字时，+ 操作符会将字符串连接在一起。这样，你可以通过组合不同的字符串来构建一个更长的消息。以下是一个示例：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we assign two strings to the variables first and second. Then we use +
    to join the strings, storing the result in the variable joined. Notice that JavaScript
    doesn’t add a space between the strings being joined—it just tacks the second
    string directly onto the end of the first. If you want a space in between, you
    have to add it explicitly by treating the space as its own string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个字符串赋值给变量 first 和 second。然后，我们使用 + 将这些字符串连接起来，将结果存储在变量 joined 中。请注意，JavaScript
    在连接字符串时不会自动添加空格——它只是直接将第二个字符串附加到第一个字符串的末尾。如果你希望它们之间有空格，必须通过将空格当作一个独立的字符串显式地添加进去：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we join three string literals:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们连接了三个字符串字面量：
- en: 1.  "First string"
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  "第一个字符串"
- en: 2.  " " (a string consisting of a single space)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  " "（由一个空格组成的字符串）
- en: 3.  "Second string"
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  "第二个字符串"
- en: As a result, we get a space between string and Second.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们在字符串和 Second 之间得到了一个空格。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Length
    of a String</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算字符串的长度</samp>
- en: 'You’ll often need to check the length of a string. For example, if you’re making
    a reviews website, you might want to limit review length to something like 1,000
    characters. To find out how many characters are in a string, add .length after
    the string to access its length property. (A *property* is a piece of information
    about something in your code; we’ll discuss properties in more detail in [Chapter
    3](chapter3.xhtml).) Here we use .length to confirm that the string "abc" has
    three characters:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常需要检查字符串的长度。例如，如果你在制作一个评论网站，你可能希望将评论的长度限制为 1,000 个字符。要查找字符串中有多少个字符，在字符串后面加上
    .length 来访问其长度属性。（*属性*是关于代码中某个对象的信息；我们将在[第 3 章](chapter3.xhtml)中详细讨论属性。）在这里，我们使用
    .length 来确认字符串 "abc" 有三个字符：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, we used .length on a string literal, but you can also use it
    on variables or constants that contain strings, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在字符串字面量上使用了 .length， 但你也可以在包含字符串的变量或常量上使用它，如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code counts all the characters, including the spaces, in the string bound
    to the variable name longString.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码统计了字符串中所有字符的数量，包括空格，字符串绑定到变量名 longString。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Character
    from a String</samp>
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从字符串中获取字符</samp>
- en: To get a single character from a string, use that character’s *index*. This
    is a number representing the character’s position within the string. JavaScript
    always counts from zero, so index 0 refers to the first character in the string,
    index 1 to the second character, and so on. This is known as *zero-based indexing*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中获取单个字符，请使用该字符的 *索引*。这是一个表示字符在字符串中位置的数字。JavaScript 总是从零开始计数，因此索引 0 表示字符串中的第一个字符，索引
    1 表示第二个字符，以此类推。这就是 *零基索引*。
- en: 'Place the desired index in square brackets to access the character at that
    index, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将所需的索引放入方括号中以访问该索引位置的字符，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, alphabet[0] retrieves the first character of the string stored in the
    variable alphabet, and alphabet[1] retrieves the second character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，alphabet[0] 获取存储在变量 alphabet 中的字符串的第一个字符，alphabet[1] 获取第二个字符。
- en: 'If you use an index beyond the length of the string, the expression evaluates
    to undefined:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用超出字符串长度的索引，表达式将返回undefined：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The string in alphabet has only seven characters, at indices 0 through 6, so
    alphabet[10] is out of range.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串alphabet只有七个字符，索引范围为0到6，所以`alphabet[10]`超出了范围。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Multiple
    Characters from a String</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从字符串中获取多个字符</samp>
- en: To get a sequence of multiple characters (also called a *slice*) from a string,
    rather than just a single character, use the slice method. A *method* is a specific
    kind of function that’s attached to a particular value or data type. (As we discussed
    in [Chapter 1](chapter1.xhtml), a function is a named piece of code that carries
    out a task.) Methods are generally used to make a calculation about the thing
    they’re attached to, or to update something about it. In this case, slice is one
    of many methods associated with the string data type that you can use to manipulate
    a given string.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中获取多个字符（也称为*切片*），而不仅仅是单个字符，可以使用切片方法。*方法*是一种特定类型的函数，附加在特定的值或数据类型上。（正如我们在[第1章](chapter1.xhtml)中讨论的，函数是执行任务的命名代码块。）方法通常用于对其所附加的对象进行计算，或更新其某些内容。在这个例子中，slice是与字符串数据类型相关联的多种方法之一，你可以用它来操作给定的字符串。
- en: The syntax for using, or *calling*, a method is to follow the value or variable
    you want to apply the method to with a period, then the name of the method, and
    then a set of parentheses. Inside the parentheses, you write any values that the
    method needs to do its job, separated by commas. As with other functions, these
    values are known as *arguments*. Methods can also produce a value, known as the
    method’s *return value*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用或*调用*方法的语法是，在你想应用方法的值或变量后面加一个句点，然后是方法名，再加上一对括号。在括号内，你写入方法需要的任何值，这些值用逗号分隔。和其他函数一样，这些值被称为*参数*。方法也可以返回一个值，称为方法的*返回值*。
- en: 'The slice method takes two arguments, the start index (inclusive) and end index
    (exclusive) of the slice you want to extract, and returns the substring containing
    the specified range of characters. Here’s an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 切片方法接受两个参数，即你想提取的切片的起始索引（包含）和结束索引（不包含），并返回包含指定范围字符的子字符串。以下是一个示例：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we store a string in the variable sentence and then call the slice method
    on that string by writing sentence.slice(3, 7). The first argument in the parentheses
    means we want the slice to start at index 3 of the string (the fourth character,
    the n in name). The second argument means we want the slice to go up to, but not
    include, index 7 of the string (the space after name). The net result is that
    the slice method returns the characters at indices 3, 4, 5, and 6, giving us the
    string "name".
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个字符串存储在变量sentence中，然后通过写`sentence.slice(3, 7)`来调用该字符串的切片方法。括号中的第一个参数意味着我们希望切片从字符串的索引3开始（即第四个字符，“name”中的n）。第二个参数意味着我们希望切片到达字符串的索引7，但不包括该位置（即“name”后的空格）。最终结果是，切片方法返回索引3、4、5和6的字符，得到字符串"name"。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*We’ll talk more about functions generally in [Chapter 5](chapter5.xhtml),
    and about methods specifically in [Chapter 6](chapter6.xhtml).*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将在[第5章](chapter5.xhtml)中更详细地讨论函数，一般而言，并在[第6章](chapter6.xhtml)中专门讨论方法。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trimming Whitespace
    from a String</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修剪字符串中的空白字符</samp>
- en: '*Whitespace* refers to characters that wouldn’t require any ink to print, such
    as spaces or tabs. The trim method removes any whitespace from the beginning or
    end of a string and returns a new string with that whitespace removed. This can
    be helpful, for example, if you’re taking input from a user and they accidentally
    add a few spaces at the beginning and/or end, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*空白字符*指的是打印时不需要任何墨水的字符，如空格或制表符。trim方法删除字符串开头和结尾的所有空白字符，并返回一个去除空白的新字符串。这在某些情况下很有用，例如当你从用户那里获取输入时，他们不小心在开始或结束处加了几个空格，如下所示：'
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The string stored in the variable inputText starts with a space before the word
    Here and ends with three extra spaces after the word input. When we call the trim
    method by writing inputText.trim(), we get a new string with those spaces removed.
    Notice, however, that the spaces *between* the words aren’t affected; only the
    whitespace at the beginning and end of the string is trimmed. The trim method
    doesn’t require any arguments, so we simply write an empty set of parentheses
    after the method name.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在变量 inputText 中的字符串在单词 Here 之前有一个空格，在单词 input 后面有三个额外的空格。当我们通过写 inputText.trim()
    来调用 trim 方法时，我们得到一个新字符串，其中这些空格被移除了。但是请注意，单词*之间*的空格没有受到影响；只有字符串开头和结尾的空格被去除。trim
    方法不需要任何参数，所以我们只需在方法名后写一个空括号。
- en: 'Because the trim method returns a new string, the original string stored in
    inputText is left unchanged. We can see this when we ask for the value of inputText
    at the end of the code listing: the output still has the spaces at the start and
    end of the string ❶.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 trim 方法返回一个新的字符串，所以原始字符串 inputText 保持不变。我们可以通过查看代码清单末尾的 inputText 的值来看到这一点：输出结果仍然包含字符串开头和结尾的空格
    ❶。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Useful String
    Methods</samp>
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">其他有用的字符串方法</samp>
- en: 'JavaScript has many more string methods available besides slice and trim. I
    won’t go into the details of all of them, but here are some useful ones:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 slice 和 trim，JavaScript 还有更多可用的字符串方法。我不会详细讲解所有方法，但这里列出了一些有用的方法：
- en: str.toLowerCase()    Returns a new string with all the uppercase characters
    in str converted to lowercase.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: str.toLowerCase()    返回一个新的字符串，将 str 中的所有大写字母转换为小写字母。
- en: str.includes(otherStr)    Returns true if str includes the string given as the
    otherStr argument.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: str.includes(otherStr)    如果 str 包含作为 otherStr 参数传入的字符串，则返回 true。
- en: str.padStart(num, char)    Returns a new string that has at least num characters,
    and adds the char character as many times as needed to the start of the string
    if it isn’t already num in length.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: str.padStart(num, char)    返回一个新的字符串，该字符串至少有 num 个字符，如果原字符串长度小于 num，则在字符串的开头添加必要次数的
    char 字符。
- en: str.repeat(count)    Returns a new string with str repeated count times.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: str.repeat(count)    返回一个新的字符串，str 重复 count 次。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Escape Sequences</samp>
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">转义序列</samp>
- en: 'Sometimes you’ll want to put special characters into your strings, like newline
    characters to create a line break in the middle of the string, or tab characters
    to create wider horizontal spacing. JavaScript lets you include these using *escape
    sequences*. An escape sequence is a series of characters, always starting with
    a backslash (\), that gets converted to another character. For example, to insert
    a newline character into a string, use the \n escape sequence:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想在字符串中插入特殊字符，比如插入换行符以在字符串中间创建换行，或者插入制表符以创建更宽的水平间距。JavaScript 允许你通过*转义序列*来插入这些字符。转义序列是一串字符，始终以反斜杠（\）开头，表示将被转换为另一个字符。例如，要在字符串中插入换行符，可以使用
    \n 转义序列：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For better or worse, when Chrome’s JavaScript console evaluates a string with
    a special character and outputs the result, the special character remains in its
    escaped form. To see how the string appears with the escape sequence interpreted
    correctly, pass the string as an argument to the console.log method. This method
    prints data to the console, including any necessary formatting. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论好坏，当 Chrome 的 JavaScript 控制台评估一个包含特殊字符的字符串并输出结果时，特殊字符会保持其转义形式。要查看该字符串如何正确解释转义序列，请将字符串作为参数传递给
    console.log 方法。该方法将数据输出到控制台，包括任何必要的格式化。例如：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output of this method shows how the \n escape sequence is interpreted as
    a line break between the two words in the string.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的输出显示了 \n 转义序列如何被解释为字符串中两个单词之间的换行符。
- en: '[Table 2-1](chapter2.xhtml#tab2-1) lists some of the escape sequences you’ll
    use most often.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](chapter2.xhtml#tab2-1) 列出了你最常使用的一些转义序列。'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Escape Sequences</samp> |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">常见转义序列</samp>
    |'
- en: '| --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp>
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">转义序列</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| \'' | <samp class="SANS_Futura_Std_Book_11">Single quote</samp> |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| \'' | <samp class="SANS_Futura_Std_Book_11">单引号</samp> |'
- en: '| \" | <samp class="SANS_Futura_Std_Book_11">Double quote</samp> |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| \" | <samp class="SANS_Futura_Std_Book_11">Double quote</samp> |'
- en: '| \\ | <samp class="SANS_Futura_Std_Book_11">Backslash</samp> |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| \\ | <samp class="SANS_Futura_Std_Book_11">Backslash</samp> |'
- en: '| \n | <samp class="SANS_Futura_Std_Book_11">Newline</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| \n | <samp class="SANS_Futura_Std_Book_11">Newline</samp> |'
- en: '| \t | <samp class="SANS_Futura_Std_Book_11">Tab</samp> |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| \t | <samp class="SANS_Futura_Std_Book_11">Tab</samp> |'
- en: 'As the table indicates, if you want to include an actual backslash character
    in your string, you’ll need to use \\. Similarly, if you want to include a double
    quote character in your double-quoted string, you’ll need to use \". For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如表所示，如果你想在字符串中包含实际的反斜杠字符，你需要使用 \\. 同样，如果你想在双引号字符串中包含双引号字符，你需要使用 \"。例如：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you write a string inside double quotes, there’s no need to use the \''
    escape sequence when you want a single quote, for example, as an apostrophe in
    a contraction. You can just write the single quote directly, as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在双引号中编写字符串时，如果想使用单引号（例如，作为缩写中的撇号），就不需要使用 \' 转义序列。你可以直接写出单引号，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similarly, when you write a string inside single quotes, there’s no need to
    escape double quotes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你在单引号内编写字符串时，如果想使用双引号，也不需要进行转义。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Template Literals</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">模板字面量</samp>
- en: A *template literal* is a special kind of string that can evaluate any expressions
    embedded within it. This gives you the flexibility to dynamically populate a string
    with the values of variables, the results of calculations, or other code, instead
    of having to type out every character of the string exactly or combine several
    variables into a string with the + operator.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板字面量* 是一种特殊类型的字符串，可以评估其中嵌入的任何表达式。这让你可以灵活地动态填充字符串，插入变量的值、计算结果或其他代码，而不必一字一句地输入字符串中的每个字符，或者使用
    + 运算符将多个变量组合成一个字符串。'
- en: 'Template literals are enclosed in backticks (`) instead of quotation marks.
    You incorporate code using *placeholder syntax*, which looks like this: ${}. The
    text inside the braces of the placeholder is treated as an expression and is evaluated
    before the final string is evaluated, as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量用反引号（`）包围，而不是用引号。你可以使用 *占位符语法* 来插入代码，语法如下：${}。占位符中的内容会被视为一个表达式，并在最终字符串被求值之前进行求值，如下所示：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, the value of the name variable gets inserted into the string instead
    of the ${name} placeholder, resulting in the string "Hello Nick!" If we change
    the value of name, the same template literal will produce a different string:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，name 变量的值会被插入到字符串中，而不是 ${name} 占位符，最终得到字符串 "Hello Nick!"。如果我们更改 name 的值，相同的模板字面量会生成不同的字符串：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can place any expression in the placeholder braces, not just a simple variable.
    The expression will be evaluated, and the result will be inserted into the string.
    For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在占位符的大括号中放置任何表达式，而不仅仅是简单的变量。表达式会被求值，结果会插入到字符串中。例如：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, JavaScript calculates the value of 60 * 60 * 24, converts it to
    a string, and incorporates it into the evaluated string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript 会计算 60 * 60 * 24 的值，将其转换为字符串，并将其包含在计算后的字符串中。
- en: 'Template literals have many applications, such as taking text input from a
    user and inserting it into a new string. They’re especially useful when you need
    to make a string based on several variables. For example, say you’re building
    a Mad Libs–type web application that takes in words of different parts of speech
    and combines them into sentences. The user has input the following three words,
    which you’ve stored in separate variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量有很多应用，比如从用户那里获取文本输入并将其插入到新字符串中。当你需要基于多个变量构造字符串时，它们特别有用。例如，假设你正在构建一个类似 Mad
    Libs 的 Web 应用程序，用户输入不同词性的单词并将其组合成句子。用户已经输入了以下三个单词，这些单词存储在不同的变量中：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Without template literals, you’d have to combine the variables into a string
    by repeatedly using the + operator:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有模板字面量，你就得通过反复使用 + 运算符将变量合并成一个字符串：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code is pretty tedious to write, especially as you want to include a space
    between each word and a period at the end of the sentence. It’s much simpler to
    use a template literal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码写起来相当繁琐，特别是当你想在每个单词之间加一个空格，并在句末加一个句号时。使用模板字面量要简单得多：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In addition to making code easier to write, template literals also make it easier
    to read. It’s much more apparent that this code is inserting a custom noun, adverb,
    and adjective into a sentence.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让代码更容易编写外，模板字面量还使其更容易阅读。这样可以更清楚地看到代码是在将一个自定义名词、副词和形容词插入到句子中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Undefined and Null</samp>
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">未定义和空值</samp>
- en: 'In JavaScript, the values undefined and null have a special meaning: they represent
    *nothing*. When JavaScript doesn’t have a value for something, it returns undefined
    by default. For example, as you saw earlier in this chapter, if you create a variable
    without giving it a value, JavaScript automatically assigns that variable a value
    of undefined:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`undefined`和`null`有特殊的含义：它们代表*无*。当JavaScript无法为某个值提供数据时，默认返回`undefined`。例如，正如你在本章前面看到的，如果你声明一个变量但没有给它赋值，JavaScript会自动将其赋值为`undefined`：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You also get undefined when you execute a function that has no useful value
    to return in the console, such as the alert function we used in [Chapter 1](chapter1.xhtml)
    to pop up a dialog in the browser:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行一个没有有用返回值的函数时，比如我们在[第1章](chapter1.xhtml)中使用的`alert`函数，它会在控制台中返回`undefined`，用于弹出一个对话框：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Whereas JavaScript automatically uses undefined when something has no value,
    programmers generally use null to explicitly mark something as empty. For example,
    if you’re writing some code that takes an address as user input, and the user
    doesn’t supply their address, you can set the address variable to null instead:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 而JavaScript会在某个值没有定义时自动使用`undefined`，程序员通常使用`null`来明确标记某个值为空。例如，如果你写的代码需要获取用户输入的地址，而用户没有提供地址，你可以将地址变量设置为`null`：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Functionally speaking, setting address to null isn’t really any different from
    leaving the variable undefined, but it makes your intentions clearer. Someone
    else reading your code will see that you’re deliberately marking address as an
    empty value, as opposed to it just not having been defined yet.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，将地址设置为`null`与将变量留空（即未定义）并没有本质区别，但它让你的意图更加明确。其他阅读你代码的人会看到你故意将地址标记为空值，而不是因为它还没有定义。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Booleans</samp>
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">布尔值</samp>
- en: 'The last primitive data type we’ll consider is the *Boolean* type, which represents
    true/false values. There are only two Boolean literals: true and false. Here we
    create a Boolean variable using a literal and confirm its value:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的最后一种原始数据类型是*布尔值*类型，它表示真/假值。布尔值只有两个字面量：`true`和`false`。在这里，我们创建了一个布尔变量并通过字面量确认其值：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, we’re declaring a new variable called playing and initializing
    it with the Boolean literal true. You can imagine that this is some code in a
    game, and that the playing variable tells us if the game is currently active (true)
    or paused (false).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了一个名为`playing`的新变量，并将其初始化为布尔字面量`true`。你可以想象这是一个游戏中的代码，`playing`变量告诉我们游戏当前是处于活动状态（true）还是暂停状态（false）。
- en: Booleans are an essential part of programming because they give us a way to
    talk about logic. If you want your program to behave differently for a particular
    condition, you need to be able to say whether or not that condition holds—that
    is, whether it’s true or false. For example, if you’re working on a video streaming
    website, you might need to know if the current user is under 18\. If they are,
    you might hide certain content. You’d use a Boolean in this case to decide whether
    or not to hide the content.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是编程中至关重要的一部分，因为它们为我们提供了一种讨论逻辑的方式。如果你希望程序根据某个特定条件作出不同的行为，你需要能够判断这个条件是否成立——即，是否为真或假。例如，如果你在开发一个视频流网站，可能需要判断当前用户是否未满18岁。如果是的话，可能会隐藏某些内容。在这种情况下，你会使用布尔值来决定是否隐藏这些内容。
- en: 'Booleans have various operators associated with them. They fall into two groups:
    *logical operators*, which take Boolean values and return Boolean values, and
    *comparison operators*, which can take values of other types, such as numbers
    and strings, and return Boolean values.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值有多种相关运算符，它们分为两类：*逻辑运算符*，它们接受布尔值并返回布尔值；以及*比较运算符*，它们可以接受其他类型的值，如数字和字符串，并返回布尔值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Operators</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">逻辑运算符</samp>
- en: 'There are three Boolean logical operators: *and*, *or*, and *not*. The and
    operator (&&) takes two values, known as *operands*, and returns true only if
    both operands are true. This is useful for any case where you need two conditions
    to be true for something to happen. Let’s continue the game example, and pretend
    we’re writing the logic for a platform game. In this game, you can shoot fireballs,
    but only if you have a powerup *and* you’re jumping. Here’s how to express that
    in code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个布尔逻辑运算符：*与*、*或*和*非*。与运算符 (&&) 接受两个值，称为*操作数*，只有在两个操作数都为真时才返回 true。这对于任何需要两个条件都为真才能发生某事的情况都很有用。让我们继续用游戏示例，假设我们正在为一个平台游戏编写逻辑。在这个游戏中，你可以发射火球，但只有在你有一个道具*并且*你正在跳跃时。下面是如何在代码中表达这一点：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, powerup is true and jumping is true, so powerup && jumping is
    also true. If you set either (or both) of those variables to false, however, powerup
    && jumping will also be false:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，powerup 为 true，jumping 为 true，因此 powerup && jumping 也为 true。然而，如果你将这两个变量中的任何一个（或两个）设置为
    false，powerup && jumping 也会变为 false：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The or operator (||) returns true if *either* of its operands is true. This
    is useful if only one of several conditions needs to be true for something to
    happen. In our game, for example, let’s say you die if a fireball hits you *or*
    if you touch a monster:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或运算符 (||) 如果*任意*一个操作数为真时会返回 true。这在只有多个条件中的一个需要为真时非常有用。例如，在我们的游戏中，假设你死了如果火球击中了你*或者*你碰到了怪物：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because one of the two operands is true, the expression hitByFireball || touchedMonster
    is true. The || operator will also return true if both operands are true.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个操作数中的一个为真，表达式 hitByFireball || touchedMonster 为真。如果两个操作数都为真，|| 运算符也会返回 true。
- en: 'The not operator (!) takes only one operand and returns the inverse of its
    value, so !true is false and !false is true. This is particularly useful if you
    want something to happen when a condition is *not* true. In our game, for example,
    we might have a variable called alive that tells us if the player is currently
    alive. The game should end when the player is dead—that is, when !alive is true
    (meaning alive itself is false):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 非运算符 (!) 只接受一个操作数，并返回其值的反值，所以 !true 为 false，!false 为 true。如果你希望在条件*不*为真时发生某些事情，这非常有用。例如，在我们的游戏中，我们可能有一个名为
    alive 的变量，它告诉我们玩家是否还活着。游戏应在玩家死亡时结束——即当 !alive 为真时（意味着 alive 本身为假）：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Different logical operators are often combined to form more sophisticated logical
    expressions. For example, let’s say you can jump in our game only when you’re
    not carrying a box and you’re not swimming. In that case, we’d use two Boolean
    variables to represent carrying a box and swimming, use ! to invert each of those
    variables, and use && to check the two inverted variables together, like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的逻辑运算符通常会组合在一起，形成更复杂的逻辑表达式。例如，假设在我们的游戏中，只有在你没有搬箱子并且没有游泳时，你才能跳跃。在这种情况下，我们将使用两个布尔变量来表示搬箱子和游泳，使用
    ! 来反转这两个变量，然后使用 && 来检查这两个反转后的变量，如下所示：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You aren’t swimming, but you *are* carrying a box, so the && operator returns
    false, meaning you can’t jump.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有游泳，但你*正在*搬箱子，所以 && 运算符返回 false，意味着你不能跳跃。
- en: 'It can sometimes be hard to read more complex logical expressions, so let’s
    go through the steps JavaScript takes when evaluating the !carryingBox && !swimming
    expression. First, to simplify things, replace the variable names with the Boolean
    values they’re currently set to:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有时更复杂的逻辑表达式很难阅读，所以让我们来看一下 JavaScript 在计算 !carryingBox && !swimming 表达式时的步骤。首先，为了简化，替换变量名为它们当前设置的布尔值：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, replace the expressions !true and !false with their equivalent values,
    removing the ! operators:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，替换表达式 !true 和 !false 为它们的等效值，移除 ! 运算符：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now we just have to remember that && returns true only if both its operands
    are true. In this case, one of the operands is false, so we know that this expression
    evaluates to false.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要记住 && 仅在两个操作数都为真时返回 true。在这种情况下，其中一个操作数为假，所以我们知道这个表达式的值为 false。
- en: There’s a useful trick for working with Boolean expressions like this. The expression
    !a && !b can be rewritten as !(a || b). Think of this as rewording the original
    description from “not carrying a box *and* not swimming” to “not (carrying a box
    *or* swimming).” This trick is called De Morgan’s law (no relation!). It can also
    be used to convert !a || !b to !(a && b).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 处理像这样的布尔表达式有一个有用的技巧。表达式 !a && !b 可以重写为 !(a || b)。可以将其理解为将原始描述“既不搬箱子*也*不游泳”重新表述为“不是（搬箱子*或*游泳）”。这个技巧被称为德摩根定律（与人名无关！）。它也可以用来将
    !a || !b 转换为 !(a && b)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparison Operators</samp>
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">比较运算符</samp>
- en: 'JavaScript’s comparison operators compare values and return a Boolean value
    based on the result of the comparison. For example, the === or “triple equals”
    operator checks if two values are equal. It returns true if they are, or false
    if they aren’t. Here are some examples of the === operator in action:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的比较运算符用于比较值，并根据比较结果返回布尔值。例如，=== 或 “三等号” 运算符用于检查两个值是否相等。如果相等，返回 true，否则返回
    false。以下是一些 === 运算符的示例：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that === isn’t just for comparing number literals; it can also work
    with numerical expressions like 2 + 2, string literals ("hello"), string expressions
    ("hel" + "lo"), and Booleans. It can compare values stored in variables as well:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，=== 不仅用于比较数字字面量；它还可以与数值表达式（如 2 + 2）、字符串字面量（"hello"）、字符串表达式（"hel" + "lo"）以及布尔值一起使用。它还可以比较存储在变量中的值：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here answer is set to 4, the value of 2 + 2, so the comparison with 5 is false.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，answer 被设置为 4，即 2 + 2 的值，因此与 5 的比较结果为 false。
- en: 'The opposite of the === operator is !== (the first = is replaced by a !). This
    operator checks if two values are *not* equal. For example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: === 运算符的反义运算符是 !==（第一个 = 被 ! 替代）。该运算符检查两个值是否 *不* 相等。例如：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using the !== operator is the same as using the === operator, then applying
    the ! operator to the result:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 !== 运算符与使用 === 运算符相同，只是对结果应用了 ! 运算符：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'JavaScript’s other comparison operators check if one value is greater than
    or less than another. These include the standard mathematical operations of greater
    than (>), less than (<), greater than or equal to (>=), and less than or equal
    to (<=). Consider these examples:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的其他比较运算符用于检查一个值是否大于或小于另一个值。这些包括大于 (>)、小于 (<)、大于或等于 (>=) 和小于或等于 (<=)
    等标准数学运算符。考虑以下示例：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice in particular that comparing identical values with > or < returns false,
    but comparing them with >= or <= returns true.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，使用 > 或 < 比较相同的值时会返回 false，而使用 >= 或 <= 时则返回 true。
- en: 'These comparison operators can also be used with strings. One string is considered
    “greater than” another string if it would appear later in a dictionary. For example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较运算符也可以与字符串一起使用。如果一个字符串在字典中排列在另一个字符串之后，那么它被认为是“更大”的。举个例子：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first comparison evaluates to true because the first letter of cat comes
    before the first letter of dog in the alphabet. In the second comparison, the
    first two characters of the strings are the same, but looking at the third character,
    c is later in the alphabet than b, so the first string is considered greater.
    It doesn’t matter that the second string is longer; JavaScript compares the strings
    character by character and stops the comparison as soon as it’s found a difference.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个比较的结果为 true，因为 cat 的首字母在字母表中排在 dog 的首字母之前。在第二个比较中，两个字符串的前两个字符相同，但第三个字符上，c
    在字母表中排在 b 后面，因此第一个字符串被认为更大。第二个字符串更长并不重要；JavaScript 会逐个字符地比较字符串，并在发现差异时立即停止比较。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Coercion</samp>
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型强制转换</samp>
- en: '*Coercion* is the act of automatically converting a value of one data type
    into a value of a different data type. JavaScript uses coercion in certain circumstances
    where values of different data types appear in the same expression. For example,
    if you use the + operator with a string on one side and a number on the other,
    JavaScript coerces the number to a string, then joins the two strings together:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制转换*是自动将一种数据类型的值转换为另一种数据类型值的行为。在某些情况下，JavaScript 会使用强制转换，当不同数据类型的值出现在同一个表达式中时。例如，如果你在一个表达式中使用
    + 运算符，且一边是字符串，另一边是数字，JavaScript 会将数字强制转换为字符串，然后将两个字符串连接在一起：'
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that 10 appears inside the quotes in the output, meaning it’s become
    a string rather than a number. This kind of coercion makes it quite easy to incorporate
    numbers into strings for display to a user.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出中的 10 被放在引号内，意味着它已经变成了字符串，而不是数字。这种类型的强制转换使得在字符串中轻松地嵌入数字，以便显示给用户。
- en: 'In some contexts, Boolean values are coerced into numbers, with false becoming
    0 and true becoming 1. For example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，布尔值会被强制转换为数字，false 变为 0，true 变为 1。例如：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here we’ve used the Boolean literal true with a number in a mathematical expression,
    so JavaScript coerces it to a 1, then adds 100 and 1 to produce 101.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在数学表达式中使用了布尔字面量 true 与数字进行运算，因此 JavaScript 将其强制转换为 1，然后加上 100 和 1 得到 101。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality with Coercion</samp>
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">带强制转换的相等性</samp>
- en: 'Earlier we used the triple equals operator (===) to check for equality. There’s
    another operator, double equals (==), that applies coercion to its operands before
    checking for equality. For example, if you compare a number to a Boolean using
    ==, the Boolean will first be coerced into a number:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们使用了三等号运算符(===)来检查相等性。还有另一个运算符，双等号(==)，它会在检查相等性之前对操作数进行强制类型转换。例如，如果你用==将一个数字与布尔值进行比较，布尔值会先被转换成数字：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This comparison is true because the Boolean false is first coerced to a 0.
    If you make the same comparison using the triple equals operator, however, it
    will be false, since === doesn’t permit type coercion:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较为真，因为布尔值false首先被强制转换为0。然而，如果你使用三等号运算符进行相同的比较，它将为假，因为===不允许类型强制转换：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It can be hard to guess what will be coerced to what when you use the == operator.
    Here are some other examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用==运算符时，猜测什么会被强制转换成什么可能会很困难。以下是一些其他的例子：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When you compare a number with a string consisting of all numerals, such as
    "1", the string is coerced to the equivalent number, so "1" == 1 becomes 1 ==
    1, which evaluates to true. The == operator also returns true when undefined and
    null are compared to each other, but it returns false if undefined or null is
    compared to anything else. Meanwhile, an *empty string*—that is, a string that
    contains no characters, represented by a set of quotation marks with nothing in
    between ("")—is considered equivalent to the number 0 and the Boolean false.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个数字与一个由所有数字组成的字符串进行比较时，比如"1"，该字符串会被强制转换为等效的数字，因此"1" == 1变为1 == 1，这个表达式的结果是true。==运算符在比较undefined和null时也会返回true，但如果undefined或null与其他任何值进行比较，它则返回false。同时，*空字符串*——即一个不包含任何字符的字符串，用一对引号表示（""）——被视为等同于数字0和布尔值false。
- en: 'The opposite of == is the != operator. It determines if two operands are *not
    equal*, after any appropriate type coercion. Some inequalities that are true using
    the strict !== operator become false with the coercive != operator. For example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '!=运算符是==的反义运算符。它会在适当的类型强制转换后判断两个操作数是否*不相等*。一些在使用严格的!==运算符时为真的不等式，在使用强制转换的!=运算符时则变为假。例如：'
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Without coercion, 0 is not equal to false, so 0 !== false is true. With coercion,
    however, false becomes 0, so 0 != false is false.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有强制转换，0不等于false，因此0 !== false为真。然而，在强制转换的情况下，false变为0，因此0 != false为假。
- en: It’s important to be aware of the == and != operators, but because of the complicated
    rules governing type coercion, I’d recommend sticking to the strict === and !==
    operators as much as possible. You’ll be less likely to encounter unexpected behavior
    in your code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 了解==和!=运算符非常重要，但由于类型强制转换的规则复杂，我建议尽可能坚持使用严格的===和!==运算符。这样，你的代码更不容易出现意外行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Truthiness</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">真值性</samp>
- en: '*Truthiness* is a special type of coercion that defines how non-Boolean values
    are treated as Booleans. This allows logical operators like && and ! to be used
    on any type of value. The way the operators work depends on whether JavaScript
    considers the value to be *truthy* (equivalent to true) or *falsy* (equivalent
    to false). The falsy values include undefined, null, the number 0, and an empty
    string (""). All nonzero numbers and nonempty strings are truthy.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*真值性*是一种特殊的类型强制转换，定义了非布尔值如何被视为布尔值。这使得像&&和!这样的逻辑运算符可以作用于任何类型的值。运算符的工作方式取决于JavaScript是否将该值视为*真值*（等同于true）或*假值*（等同于false）。假值包括undefined、null、数字0和空字符串("")。所有非零数字和非空字符串都被视为真值。'
- en: 'The easiest way to check if a value is truthy or falsy is to apply two not
    operations to it using !!, meaning “not not,” a double negative. This works because
    the ! operator always returns a Boolean, regardless of the data type of the value
    it’s applied to. For example, say you want to verify that the number 0 is falsy.
    A single ! operation coerces the number to a Boolean, then inverts that Boolean,
    so !0 evaluates to true:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个值是真值还是假值的最简单方法是使用!!对其进行两次取反操作，意味着“非非”，即双重否定。之所以有效，是因为!运算符始终返回布尔值，无论它作用于哪种数据类型。例如，假设你想验证数字0是否为假值。单一的!操作将数字强制转换为布尔值，然后取反该布尔值，因此!0的结果为true：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Adding a second ! reverses the Boolean again, giving the Boolean equivalent
    of the original value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第二个!再次反转布尔值，给出原值的布尔等效：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This confirms that 0 is equivalent to false, or falsy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了0等价于false，或者说是假的。
- en: 'You can use the same !! trick to check the other truthiness rules I mentioned
    earlier:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的!!技巧来检查我之前提到的其他真值规则：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The output confirms that nonzero numbers and nonempty strings are truthy, while
    an empty string, undefined, and null are falsy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了非零数字和非空字符串为真值，而空字符串、未定义和null为假值。
- en: 'When the && and || operators are applied to non-Booleans, they don’t return
    a true or false value. Instead, they return one of the original operands. In the
    case of the && operator, if the first operand is truthy, the second operand is
    returned. If the first operand is falsy, the first operand is returned. Here are
    some examples:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当&&和||运算符应用于非布尔值时，它们不会返回true或false值。相反，它们返回原始操作数之一。对于&&运算符，如果第一个操作数为真值，则返回第二个操作数。如果第一个操作数为假值，则返回第一个操作数。以下是一些示例：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the first case, 15 is truthy, so 17 is returned. In the other two cases,
    the first operand is falsy, so 0 and undefined are returned, respectively.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例中，15是一个真值，因此返回17。在另外两个案例中，第一个操作数是假的，因此分别返回0和undefined。
- en: 'The || operator works the opposite way. If the first operand is falsy, it returns
    the second operand, and if the first operand is truthy, it returns the first operand,
    as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '||运算符的工作方式相反。如果第一个操作数是假的，则返回第二个操作数，如果第一个操作数为真值，则返回第一个操作数，如下所示：'
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the first case, the first operand is an empty string, which is falsy, so
    the second operand is returned. In the second case, the first operand is a nonempty
    string, which is truthy, so the first operand is returned.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例中，第一个操作数是一个空字符串，这是假的，因此返回第二个操作数。在第二个案例中，第一个操作数是一个非空字符串，这是一个真值，因此返回第一个操作数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uses for Truthiness</samp>
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">真值的应用</samp>
- en: 'You can leverage the behavior of & & and || with truthy and falsy values in
    a number of ways. For example, the || operator can be used to give a variable
    a default value if one isn’t provided. This could be helpful in a scenario where
    a user neglects to enter their name on a form:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用&&和||在许多情况下与真值和假值的行为。例如，||运算符可以用于在未提供值时为变量设置默认值。这在用户在表单中忘记输入名字时很有用：
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'At the start of this example, name is created without being given a value,
    so it’s undefined. Then we assign it a value using the Boolean expression name
    || "No name provided". Since the first operand is falsy, the second operand is
    returned. As a result, name is given the default value "No name provided". If,
    on the other hand, a name *had* been provided, name would be considered truthy,
    and so it would retain its value:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的开始，name在没有赋值的情况下被创建，因此它是未定义的。然后，我们使用布尔表达式name || "未提供名字"为其赋值。由于第一个操作数是假的，因此返回第二个操作数。结果，name被赋予默认值"未提供名字"。另一方面，如果提供了名字，name将被视为真值，因此它将保留原值：
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Similarly, you can use && or || to *short-circuit*, or skip, an expression.
    With &&, if the first operand is falsy, that’s the operand that will be evaluated
    and returned, so JavaScript doesn’t even bother evaluating the second operand.
    When the operands are just simple values, we don’t really care if they’re evaluated
    or not; all we care about is which value is returned. For example, in the expression
    1 || 2 + 2, it doesn’t especially matter whether JavaScript calculates the result
    of 2 + 2, because we know the first operand, 1, is going to be returned. It *does*
    matter if an expression is evaluated when that expression has some kind of *side
    effect*, however, meaning that evaluating it does something other than just returning
    a value. For example, the alert function returns the value undefined, but more
    importantly has the side effect of displaying a dialog. But what if we want to
    only display a dialog in some circumstances?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用&&或||来*短路*，即跳过一个表达式。使用&&时，如果第一个操作数为假值，则会评估并返回该操作数，因此JavaScript不会再评估第二个操作数。当操作数只是简单的值时，我们不太关心它们是否被评估；我们关心的只是哪个值被返回。例如，在表达式1
    || 2 + 2中，JavaScript是否计算2 + 2的结果并不重要，因为我们知道第一个操作数1会被返回。然而，当一个表达式具有某种*副作用*时，它是否被评估就非常重要了，这意味着评估它除了返回一个值之外，还会做其他事情。例如，alert函数返回undefined值，但更重要的是它有显示对话框的副作用。但是，如果我们只希望在某些情况下显示对话框怎么办？
- en: 'For instance, say we want to use alert to display a player’s score in a game,
    but only when the score isn’t zero. We can make the score variable and the alert
    function the operands in an && expression:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们想使用 alert 显示游戏中玩家的分数，但只有当分数不为零时才显示。我们可以将 score 变量和 alert 函数作为 && 表达式的操作数：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here score is 0, so the first operand in the && expression is falsy. The &&
    operator therefore returns this value and ignores the second operand, meaning
    alert is never called. We’ve short-circuited the function call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 score 是 0，因此 && 表达式中的第一个操作数是假的。所以，&& 运算符返回这个值并忽略第二个操作数，意味着 alert 函数没有被调用。我们已经短路了函数调用。
- en: 'Now consider what happens if score increases:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一下如果 score 增加会发生什么：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here we use ++ to increment score, changing its value to 1. This makes score
    truthy, so the second operand in the && expression is evaluated, executing the
    alert function. The function returns undefined, but also has the (desired) side
    effect of displaying a dialog with the player’s score (see [Figure 2-1](chapter2.xhtml#fig2-1)).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 ++ 来增加 score，将其值更改为 1。这使得 score 为真，因此 && 表达式中的第二个操作数被评估，执行了 alert 函数。该函数返回
    undefined，但也具有显示玩家分数对话框的（期望的）副作用（参见[图 2-1](chapter2.xhtml#fig2-1)）。
- en: '![](../images/Figure_2-1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_2-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The alert function’s
    side effect is displaying a message in a dialog.</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：alert 函数的副作用是在对话框中显示消息。</samp>
- en: Essentially, we’re using the && operator to decide whether or not to run some
    code (the alert function) based on a condition (whether or not score is 0). In
    [Chapter 4](chapter4.xhtml), we’ll look at control structures like if statements,
    which give a more explicit way of controlling whether and how our code is run.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们使用 && 运算符来决定是否根据条件（分数是否为 0）运行某些代码（alert 函数）。在[第 4 章](chapter4.xhtml)中，我们将研究控制结构，如
    if 语句，这些控制结构提供了更明确的方式来控制代码是否以及如何执行。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter introduced you to some of the fundamental building blocks of JavaScript
    programming. You learned that a statement is a complete thought in JavaScript,
    ending with a semicolon, that instructs the computer to do something, and that
    a statement can consist of one or more expressions (units of code that represent
    a value). You saw how to use bindings to give a value a name for later use, either
    as a variable, in which case the value can be updated later, or as a constant,
    in which case the value remains fixed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 JavaScript 编程中的一些基础构建块。你了解了语句是 JavaScript 中的完整思想，通常以分号结尾，指示计算机执行某些操作，并且一个语句可以包含一个或多个表达式（代表值的代码单元）。你学习了如何使用绑定将值命名以便以后使用，可以是变量，这样值可以稍后更新，或者是常量，这样值保持不变。
- en: 'You also learned about three primitive data types in JavaScript: numbers, strings,
    and Booleans. You applied math operations to numbers, including using shorthand
    like ++ and -- to increment or decrement them, and you practiced manipulating
    strings using various methods, including slicing and trimming whitespace. With
    Booleans, you learned how to use logical operators like and (&&), or (||), and
    not (!), and you saw how to generate Boolean values using comparison operators
    like === and !==. Finally, you learned how JavaScript sometimes coerces values
    from one data type to another, including how non-Booleans are treated as truthy
    or falsy, and you explored situations where this can come in handy, such as to
    short-circuit an expression.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了 JavaScript 中的三种基本数据类型：数字、字符串和布尔值。你对数字进行了数学运算，包括使用递增（++）和递减（--）等简写操作符对数字进行增减，并且练习了使用各种方法操作字符串，包括切片和修剪空格。在布尔值方面，你学习了如何使用逻辑运算符，如与（&&）、或（||）和非（!），还了解了如何通过比较运算符（如
    === 和 !==）生成布尔值。最后，你学习了 JavaScript 如何将一种数据类型的值强制转换为另一种数据类型，包括非布尔值如何被处理为真值或假值，并探讨了在一些场景下这如何派上用场，比如短路表达式。
