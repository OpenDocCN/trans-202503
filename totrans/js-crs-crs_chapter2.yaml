- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    BASICS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I’ll introduce some of the basic ingredients that make up any
    JavaScript program. You’ll learn about the fundamental units of JavaScript code
    that allow you to represent values and give instructions to the computer. You’ll
    also learn how to assign a name to a value so you can refer to it later in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also shows how JavaScript categorizes values into different data
    types based on the kind of information a value can represent. We’ll focus on primitive
    data types that represent individual values, such as a single number or a single
    piece of text. You’ll practice working with different primitive data types in
    the JavaScript console and explore some of the operations you can apply to them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Expressions and Statements</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most basic building block in JavaScript is the *expression*, a fragment
    of code that represents a single value. The act of determining the value of an
    expression is known as *evaluation*. For example, 100 + 200 is an expression that
    evaluates to the number 300.
  prefs: []
  type: TYPE_NORMAL
- en: Another important JavaScript building block is the *statement*, which is a complete
    thought, like a sentence in English, instructing the computer to do something.
    Every JavaScript program consists of a series of statements. In [Chapter 1](chapter1.xhtml),
    for example, we used the statement alert("Hello, world!"); to instruct the computer
    to display a dialog with the text *Hello, world!* in it. Whereas a sentence ends
    with a period, JavaScript statements end with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can turn an expression into a statement simply by adding a semicolon to
    the end of it. For example, 100 + 200; is a statement instructing the computer
    to add two numbers together. Open up the JavaScript console and enter this statement.
    When you do this, it will evaluate the expression in the statement and print the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main expression in this statement, 100 + 200, is known as a *compound expression*,
    since it actually contains two smaller expressions, 100 and 200. These are examples
    of the simplest form of JavaScript expression, the *literal*, which is a direct
    representation of a fixed value in code. Specifically, 100 and 200 are *number
    literals*, since they directly correspond to the numeric values they represent,
    100 and 200\. By contrast, the compound expression 100 + 200 isn’t a literal,
    since it doesn’t directly correspond to its value of 300\. The + in this compound
    expression doesn’t represent a value at all. Rather, it’s an *operator*, a symbol
    used to combine or manipulate expressions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to distinguish between values, which are the underlying pieces
    of data in a program, and expressions, which are the notations in code that tell
    JavaScript what the values should be. Both 300 and 100 + 200 have a value of 300,
    but they’re two different expressions—one literal, one compound—that provide different
    ways of representing that value.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript expressions and statements complement each other. Expressions have
    values, but an expression by itself doesn’t actually *do* anything. Conversely,
    statements do work by telling the computer to perform tasks, but statements themselves
    don’t have values; they’re just instructions. The power of programming comes from
    writing statements that use and manipulate the values of expressions to achieve
    the desired outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Numbers and Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript uses the *number* data type to store numeric values. You already
    started working with numbers in the previous section, where you also met the +
    operator, which adds two numbers together. JavaScript has operators for other
    common mathematical calculations, too, including subtraction (-), multiplication
    (*), and division (/). Try them out in the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In cases like this, where the expression involves an operator (such as + or
    *), we often say the operator *returns* a value (rather than saying an expression
    is being *evaluated*). For instance, the * operator takes in the numbers 999 and
    111 and returns their product, 110889.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Order of Operations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can combine multiple numbers and operators in a single expression, in which
    case you need to think about the order in which the operations will be performed.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you have multiple operators like this, JavaScript uses the standard mathematical
    PEMDAS (parentheses, exponents, multiplication, division, addition, subtraction)
    rule to determine the order of calculations. The division operation in this expression
    takes place first, followed by the addition and subtraction, yielding a value
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the addition and subtraction to happen first, use parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This time, the expression produces a different value, since the parentheses
    changed the order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Point</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far we’ve limited ourselves to whole numbers, but JavaScript’s number data
    type also accommodates fractional numbers, called *floating-point numbers* in
    programming terms. Here’s an expression that produces a floating-point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating-point numbers have limited precision, so the decimal component can’t
    go on forever. Instead, they’re truncated, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice some weird quirks of floating-point math, where the answer isn’t
    quite what you’d expect. For example, 0.1 + 0.2 doesn’t work out to exactly 0.3.
    Instead, we get several extra decimal places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is due to the underlying mathematics of how computers represent numbers
    (search the web for “floating-point arithmetic” to learn more). In general, these
    quirks shouldn’t affect you, but they could in certain circumstances. For example,
    if you’re writing an application that works with monetary values, it could be
    a problem if $0.10 and $0.20 didn’t sum to exactly $0.30\. In this case, the usual
    solution is to convert your monetary values to cents (or the equivalent smallest
    denomination) before doing any math on them. For example, the number 0.10, representing
    an amount of dollars, would become 10, representing an amount of cents.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bindings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, you can associate a name with a value so you can easily reference
    that value later in your code. This association is called a *binding*. Bindings
    are powerful tools because they provide a place to store the values your expressions
    generate. Without them, your programs would have no way of remembering the work
    they’ve already done.
  prefs: []
  type: TYPE_NORMAL
- en: One type of binding is a *variable*, which allows you to update the value associated
    with a particular name as needed. They’re called variables because their values
    can change, or vary. Another type of binding is a *constant*, where you can’t
    update the value associated with the name once it’s been assigned. The value remains
    fixed, or constant.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a variable or constant as a box with a label (the name) that holds
    a single item (the value). You put a value in the box, then look it up by name
    when you need it again. A variable allows you to put a new value in the box, while
    a constant will always contain the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of a binding is also called its *identifier*, and creating an identifier
    is known as *declaration*: the binding’s name is being declared. In JavaScript,
    a declaration is a special kind of statement that generates a new identifier.
    Let’s look at how to declare and work with variables and constants.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has two keywords for declaring variables: var and let. A *keyword*
    is a word built into the JavaScript language that’s reserved for a particular
    purpose. Originally, the var keyword was the only option available, but let was
    later added to fix some of the shortcomings of var. Today, let is the preferred
    keyword for declaring variables, so that’s what we’ll use in this book, but don’t
    be surprised if you encounter var while looking at older code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using let to declare a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This let declaration creates a new variable called age. A let declaration doesn’t
    have a value, so the JavaScript console prints out the special value undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created a variable, let’s write an expression to give it a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Giving a variable a value is called *assignment*, and you use the assignment
    operator (=) to do it. On the right side of the operator, you enter an expression
    (in this case, the number literal 35), and on the left, you enter the name of
    the variable that should be assigned the value of that expression (in this case,
    age).
  prefs: []
  type: TYPE_NORMAL
- en: An assignment using the = operator is a compound expression, just like expressions
    using + and other mathematical operators. The value of an assignment expression
    is the new value of the variable. In this case, we’ve set age to 35, so the console
    prints 35.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning a value to a variable for the first time is called *initialization*.
    Programmers usually combine the declaration and initialization of a variable into
    a single line of code. For example, here we create a new variable called cats
    and assign it the value 2, all in the same statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even though we’re assigning the variable a value here, the prevailing rule is
    that the let declaration itself has no value, so the JavaScript console prints
    undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm the assignment worked, enter just the variable name into the console,
    followed by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, cats is an expression that evaluates to the current value of the cats
    variable, so the console prints that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because cats is a variable, we’re free to change its value using new assignment
    expressions. Here, for example, we update its value to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about variables is that you can change their values whenever
    you need—for example, when you get another cat.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constants</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To declare a constant in JavaScript, we use the const keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new constant called PI and assigns it the value 3.141592653589793,
    which is the approximate value of the number π.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use that constant to determine the circumference of a circle based
    on its diameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a variable called diameter and assign it the value 3. Then we
    create another variable, circumference, and assign it a value of diameter * PI.
    Notice that we’re using a compound expression consisting of a variable (diameter),
    a constant (PI), and a math operation (*) to set the value of a variable. A lot
    of programming boils down to creating constants and variables, and then manipulating
    them to create other constants and variables.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Going forward, to keep the book’s code listings from getting too cluttered,
    I’ll stop showing the undefined that the console prints after a variable or constant
    is declared.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike with variables, you can’t change the value of a constant once it’s been
    created. For example, if you try to update the value of PI, JavaScript gives an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Errors are how JavaScript tells you there’s something wrong with your code.
    The important part of this error message is Assignment to constant variable. This
    indicates that we mistakenly tried to assign a new value to a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also unlike with variables, where you can separate the declaration from the
    initialization, you have to give a constant its value in its declaration. As a
    result, this won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This error message tells us that the constant declaration is missing its initializer,
    meaning the constant should have been given a value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Naming Conventions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should give variables and constants descriptive names, so when you or somebody
    else is reading your code, it’s clear what your variables and constants represent.
    For example, if you’re writing code to control a car, you might want a variable
    that stores the speed of the car in miles per hour. The name speedInMilesPerHour
    is a bit too long, but given that MPH is a commonly understood abbreviation for
    miles per hour, a good variable name would be speedInMPH. A shorter name like
    speed might be okay, but only if it’s obvious to everyone reading your code that
    speed is always in miles per hour. (Imagine if someone from Germany were reading
    your code and thought you were talking about kilometers per hour.) A bad name
    for this variable would be s, which tells the reader nothing.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is case sensitive, which means it distinguishes between the variables
    age, Age, and AGE. Also, identifiers can’t contain spaces. To work around that,
    a common convention for variable names is to use *camelCase*, where the first
    word in the name starts with a lowercase letter and each subsequent word starts
    with a capital letter, as in speedInMilesPerHour. (It’s called camelCase because
    the capital letter in the middle looks like the hump of a camel.)
  prefs: []
  type: TYPE_NORMAL
- en: An alternative naming convention for variables is *snake_case*, where everything
    is lowercase and each word is separated by an underscore. (I guess this looks
    a bit like a snake if you squint.) In snake_case, we would write speed_in_miles_per_hour
    or speed_in_MPH.
  prefs: []
  type: TYPE_NORMAL
- en: Using snake_case can make variable names slightly clearer than camelCase, but
    it also makes them longer and harder to type quickly. JavaScript programmers tend
    to prefer camelCase, so that’s what I’ll use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants follow a separate naming convention from variables. There are two
    types of constants: *true constants*, which have values that will never change
    whenever you run the program (such as pi or the number of hours in a day), and
    values you’ve made constants because you don’t want to accidentally change them
    in your code (such as the current user’s name). For true constants, it’s customary
    to use all-caps snake_case, like HOURS_IN_A_DAY. For constants you’ve created
    to avoid accidentally changing a value, use the same convention as for variables.
    In that case, the only difference is that the binding has been created using const
    rather than let.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Incrementing and Decrementing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re writing software, you’ll often have to *increment* (increase) or
    *decrement* (decrease) the value of a variable by 1 or some other number. For
    example, you might use a variable to count the occurrences of a word in a document.
    Every time you see that word, you would increase the value of the variable by
    1\. Likewise, you might use a variable to keep track of how much money a player
    has in a game, increasing or decreasing it whenever the player earns or spends
    some.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to increment a variable is to initialize it, then change its value
    to itself plus 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare a new variable called money and initialize it with the value
    100. We then assign a new value to money by adding 1 to its existing value. It
    may seem paradoxical to see an expression like money = money + 1;, but this is
    actually quite a normal programming pattern. When JavaScript encounters an assignment
    expression like this, it first calculates the value of the expression on the right
    of the assignment operator, which in this case is money + 1. Because money is
    currently 100, money + 1 has a value of 101. JavaScript then updates the value
    of the variable on the left side of the assignment operator, which in this case
    is the same variable, money.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that JavaScript waits to change the value of the variable on
    the left of the operator until after it’s calculated the value of the expression
    on the right of the operator. This is how the same variable can appear on both
    sides of the operator. In the end, money = money + 1 means “add 1 to money.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Because adding 1 to a variable is a very common task, JavaScript makes it easier
    with the increment operator (++). When you attach this operator to a variable,
    it increases the value of that variable by 1, without you having to write out
    a full assignment expression. Similarly, JavaScript’s decrement operator (--)
    decreases the value of a variable by 1\. Here, we use ++ and -- to change the
    value of a temperature variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve placed the increment and decrement operators *before*
    the variable we want to change. With the operators in this position, the output
    of the increment or decrement operation is the variable’s updated value. For example,
    when temperature has a value of 70, ++temperature outputs a value of 71. This
    is called *prefix* incrementing and decrementing.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript also allows for *postfix* incrementing and decrementing, where the
    operator goes *after* the variable. In this case, the variable still increases
    or decreases by 1, but the value shown in the output is the variable’s value *before*
    it was changed. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the books variable with the value 2. Then books++ increments that
    value, but it returns the value of books from *before* it was incremented ❶. When
    we then ask for the value of books on its own, we can see that it has the new
    value ❷, confirming that the increment operation took place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you use prefix or postfix incrementing and decrementing, the effect
    on the variable is the same: its value increases or decreases by 1\. The only
    difference is how the incrementing or decrementing expression itself evaluates.
    Luckily, most of the time when you use one of these operators, you won’t actually
    need the value of the incrementing or decrementing expression itself—you’ll just
    be modifying the value saved in the variable. Therefore, you can usually use the
    prefix and postfix versions interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Addition and Subtraction
    Assignment</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The increment operator increases a variable’s value by 1, but sometimes you’ll
    want to increase it by a different amount. For that, JavaScript has the addition
    assignment operator (+=). It increases the value of the variable on the left side
    of the operator by whatever value you place to the right of the operator, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we use += to increase the value of price by 5. Essentially, price += 5
    is shorthand for price = price + 5. The += operator combines addition and assignment
    into one symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the subtraction assignment operator (-=) is a convenient way to
    subtract any value from a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, cookies -= 5 is shorthand for cookies = cookies - 5.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplication and
    Division Assi</samp><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">g</samp><samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">nment</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The multiplication and division assignment operators, *= and /=, update a variable’s
    value by multiplying or dividing it by the specified number. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to the other shorthand assignment operators, these assignment operators
    translate to tribbles = tribbles * 2 and tribbles = tribbles / 3, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Strings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript uses the *string* data type to represent text. It’s called a string
    because the text is treated as a sequence, or string, of characters. For example,
    the string Hello! consists of six characters: H, e, l, l, o, and !.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *string literal* is a direct representation of a string value. To create
    a string literal, simply surround some text with double quotation marks. Every
    character between the quotes is part of the string. For example, here we assign
    the string literal "Hello!" as the value of the variable greeting. Then we check
    the value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can also write string literals inside single quotation marks rather than
    double quotation marks. In fact, as shown in this example, when Chrome’s JavaScript
    console outputs a string, it encloses the string in single quotes (even if you
    wrote it with double quotes). For consistency, I’ll stick with double quotes when
    I’m writing strings throughout this book, although I’ll also use single quotes
    to accurately reflect the output of the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, strings mostly consist of letters, but as our "Hello!" example indicated,
    they can also include punctuation. Strings can contain spaces, too, as well as
    numerals, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It’s even possible to have a string that just contains numerals, such as "123",
    but it’s important to distinguish this string from an actual number. The string
    literal "123" is a sequence of three characters, 1, 2, and 3, while the number
    literal 123 has a numerical value of 123.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides a lot of ways to manipulate strings. We’ll look at some
    of these string operations next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Joining Strings</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When applied to strings rather than numbers, the + operator joins the strings
    together. This way, you can build up a longer message by combining various strings.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we assign two strings to the variables first and second. Then we use +
    to join the strings, storing the result in the variable joined. Notice that JavaScript
    doesn’t add a space between the strings being joined—it just tacks the second
    string directly onto the end of the first. If you want a space in between, you
    have to add it explicitly by treating the space as its own string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we join three string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  "First string"
  prefs: []
  type: TYPE_NORMAL
- en: 2.  " " (a string consisting of a single space)
  prefs: []
  type: TYPE_NORMAL
- en: 3.  "Second string"
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we get a space between string and Second.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Length
    of a String</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll often need to check the length of a string. For example, if you’re making
    a reviews website, you might want to limit review length to something like 1,000
    characters. To find out how many characters are in a string, add .length after
    the string to access its length property. (A *property* is a piece of information
    about something in your code; we’ll discuss properties in more detail in [Chapter
    3](chapter3.xhtml).) Here we use .length to confirm that the string "abc" has
    three characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we used .length on a string literal, but you can also use it
    on variables or constants that contain strings, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code counts all the characters, including the spaces, in the string bound
    to the variable name longString.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Character
    from a String</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get a single character from a string, use that character’s *index*. This
    is a number representing the character’s position within the string. JavaScript
    always counts from zero, so index 0 refers to the first character in the string,
    index 1 to the second character, and so on. This is known as *zero-based indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the desired index in square brackets to access the character at that
    index, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, alphabet[0] retrieves the first character of the string stored in the
    variable alphabet, and alphabet[1] retrieves the second character.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use an index beyond the length of the string, the expression evaluates
    to undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The string in alphabet has only seven characters, at indices 0 through 6, so
    alphabet[10] is out of range.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting Multiple
    Characters from a String</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get a sequence of multiple characters (also called a *slice*) from a string,
    rather than just a single character, use the slice method. A *method* is a specific
    kind of function that’s attached to a particular value or data type. (As we discussed
    in [Chapter 1](chapter1.xhtml), a function is a named piece of code that carries
    out a task.) Methods are generally used to make a calculation about the thing
    they’re attached to, or to update something about it. In this case, slice is one
    of many methods associated with the string data type that you can use to manipulate
    a given string.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for using, or *calling*, a method is to follow the value or variable
    you want to apply the method to with a period, then the name of the method, and
    then a set of parentheses. Inside the parentheses, you write any values that the
    method needs to do its job, separated by commas. As with other functions, these
    values are known as *arguments*. Methods can also produce a value, known as the
    method’s *return value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The slice method takes two arguments, the start index (inclusive) and end index
    (exclusive) of the slice you want to extract, and returns the substring containing
    the specified range of characters. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we store a string in the variable sentence and then call the slice method
    on that string by writing sentence.slice(3, 7). The first argument in the parentheses
    means we want the slice to start at index 3 of the string (the fourth character,
    the n in name). The second argument means we want the slice to go up to, but not
    include, index 7 of the string (the space after name). The net result is that
    the slice method returns the characters at indices 3, 4, 5, and 6, giving us the
    string "name".
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We’ll talk more about functions generally in [Chapter 5](chapter5.xhtml),
    and about methods specifically in [Chapter 6](chapter6.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trimming Whitespace
    from a String</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Whitespace* refers to characters that wouldn’t require any ink to print, such
    as spaces or tabs. The trim method removes any whitespace from the beginning or
    end of a string and returns a new string with that whitespace removed. This can
    be helpful, for example, if you’re taking input from a user and they accidentally
    add a few spaces at the beginning and/or end, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The string stored in the variable inputText starts with a space before the word
    Here and ends with three extra spaces after the word input. When we call the trim
    method by writing inputText.trim(), we get a new string with those spaces removed.
    Notice, however, that the spaces *between* the words aren’t affected; only the
    whitespace at the beginning and end of the string is trimmed. The trim method
    doesn’t require any arguments, so we simply write an empty set of parentheses
    after the method name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the trim method returns a new string, the original string stored in
    inputText is left unchanged. We can see this when we ask for the value of inputText
    at the end of the code listing: the output still has the spaces at the start and
    end of the string ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Useful String
    Methods</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has many more string methods available besides slice and trim. I
    won’t go into the details of all of them, but here are some useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: str.toLowerCase()    Returns a new string with all the uppercase characters
    in str converted to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: str.includes(otherStr)    Returns true if str includes the string given as the
    otherStr argument.
  prefs: []
  type: TYPE_NORMAL
- en: str.padStart(num, char)    Returns a new string that has at least num characters,
    and adds the char character as many times as needed to the start of the string
    if it isn’t already num in length.
  prefs: []
  type: TYPE_NORMAL
- en: str.repeat(count)    Returns a new string with str repeated count times.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Escape Sequences</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to put special characters into your strings, like newline
    characters to create a line break in the middle of the string, or tab characters
    to create wider horizontal spacing. JavaScript lets you include these using *escape
    sequences*. An escape sequence is a series of characters, always starting with
    a backslash (\), that gets converted to another character. For example, to insert
    a newline character into a string, use the \n escape sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For better or worse, when Chrome’s JavaScript console evaluates a string with
    a special character and outputs the result, the special character remains in its
    escaped form. To see how the string appears with the escape sequence interpreted
    correctly, pass the string as an argument to the console.log method. This method
    prints data to the console, including any necessary formatting. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The output of this method shows how the \n escape sequence is interpreted as
    a line break between the two words in the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-1](chapter2.xhtml#tab2-1) lists some of the escape sequences you’ll
    use most often.'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Escape Sequences</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| \'' | <samp class="SANS_Futura_Std_Book_11">Single quote</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| \" | <samp class="SANS_Futura_Std_Book_11">Double quote</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| \\ | <samp class="SANS_Futura_Std_Book_11">Backslash</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| \n | <samp class="SANS_Futura_Std_Book_11">Newline</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| \t | <samp class="SANS_Futura_Std_Book_11">Tab</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'As the table indicates, if you want to include an actual backslash character
    in your string, you’ll need to use \\. Similarly, if you want to include a double
    quote character in your double-quoted string, you’ll need to use \". For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write a string inside double quotes, there’s no need to use the \''
    escape sequence when you want a single quote, for example, as an apostrophe in
    a contraction. You can just write the single quote directly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when you write a string inside single quotes, there’s no need to
    escape double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Template Literals</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *template literal* is a special kind of string that can evaluate any expressions
    embedded within it. This gives you the flexibility to dynamically populate a string
    with the values of variables, the results of calculations, or other code, instead
    of having to type out every character of the string exactly or combine several
    variables into a string with the + operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template literals are enclosed in backticks (`) instead of quotation marks.
    You incorporate code using *placeholder syntax*, which looks like this: ${}. The
    text inside the braces of the placeholder is treated as an expression and is evaluated
    before the final string is evaluated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the value of the name variable gets inserted into the string instead
    of the ${name} placeholder, resulting in the string "Hello Nick!" If we change
    the value of name, the same template literal will produce a different string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can place any expression in the placeholder braces, not just a simple variable.
    The expression will be evaluated, and the result will be inserted into the string.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, JavaScript calculates the value of 60 * 60 * 24, converts it to
    a string, and incorporates it into the evaluated string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template literals have many applications, such as taking text input from a
    user and inserting it into a new string. They’re especially useful when you need
    to make a string based on several variables. For example, say you’re building
    a Mad Libs–type web application that takes in words of different parts of speech
    and combines them into sentences. The user has input the following three words,
    which you’ve stored in separate variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Without template literals, you’d have to combine the variables into a string
    by repeatedly using the + operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is pretty tedious to write, especially as you want to include a space
    between each word and a period at the end of the sentence. It’s much simpler to
    use a template literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In addition to making code easier to write, template literals also make it easier
    to read. It’s much more apparent that this code is inserting a custom noun, adverb,
    and adjective into a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Undefined and Null</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, the values undefined and null have a special meaning: they represent
    *nothing*. When JavaScript doesn’t have a value for something, it returns undefined
    by default. For example, as you saw earlier in this chapter, if you create a variable
    without giving it a value, JavaScript automatically assigns that variable a value
    of undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You also get undefined when you execute a function that has no useful value
    to return in the console, such as the alert function we used in [Chapter 1](chapter1.xhtml)
    to pop up a dialog in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas JavaScript automatically uses undefined when something has no value,
    programmers generally use null to explicitly mark something as empty. For example,
    if you’re writing some code that takes an address as user input, and the user
    doesn’t supply their address, you can set the address variable to null instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Functionally speaking, setting address to null isn’t really any different from
    leaving the variable undefined, but it makes your intentions clearer. Someone
    else reading your code will see that you’re deliberately marking address as an
    empty value, as opposed to it just not having been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Booleans</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last primitive data type we’ll consider is the *Boolean* type, which represents
    true/false values. There are only two Boolean literals: true and false. Here we
    create a Boolean variable using a literal and confirm its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re declaring a new variable called playing and initializing
    it with the Boolean literal true. You can imagine that this is some code in a
    game, and that the playing variable tells us if the game is currently active (true)
    or paused (false).
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are an essential part of programming because they give us a way to
    talk about logic. If you want your program to behave differently for a particular
    condition, you need to be able to say whether or not that condition holds—that
    is, whether it’s true or false. For example, if you’re working on a video streaming
    website, you might need to know if the current user is under 18\. If they are,
    you might hide certain content. You’d use a Boolean in this case to decide whether
    or not to hide the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans have various operators associated with them. They fall into two groups:
    *logical operators*, which take Boolean values and return Boolean values, and
    *comparison operators*, which can take values of other types, such as numbers
    and strings, and return Boolean values.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Operators</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three Boolean logical operators: *and*, *or*, and *not*. The and
    operator (&&) takes two values, known as *operands*, and returns true only if
    both operands are true. This is useful for any case where you need two conditions
    to be true for something to happen. Let’s continue the game example, and pretend
    we’re writing the logic for a platform game. In this game, you can shoot fireballs,
    but only if you have a powerup *and* you’re jumping. Here’s how to express that
    in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, powerup is true and jumping is true, so powerup && jumping is
    also true. If you set either (or both) of those variables to false, however, powerup
    && jumping will also be false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The or operator (||) returns true if *either* of its operands is true. This
    is useful if only one of several conditions needs to be true for something to
    happen. In our game, for example, let’s say you die if a fireball hits you *or*
    if you touch a monster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Because one of the two operands is true, the expression hitByFireball || touchedMonster
    is true. The || operator will also return true if both operands are true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The not operator (!) takes only one operand and returns the inverse of its
    value, so !true is false and !false is true. This is particularly useful if you
    want something to happen when a condition is *not* true. In our game, for example,
    we might have a variable called alive that tells us if the player is currently
    alive. The game should end when the player is dead—that is, when !alive is true
    (meaning alive itself is false):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Different logical operators are often combined to form more sophisticated logical
    expressions. For example, let’s say you can jump in our game only when you’re
    not carrying a box and you’re not swimming. In that case, we’d use two Boolean
    variables to represent carrying a box and swimming, use ! to invert each of those
    variables, and use && to check the two inverted variables together, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You aren’t swimming, but you *are* carrying a box, so the && operator returns
    false, meaning you can’t jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can sometimes be hard to read more complex logical expressions, so let’s
    go through the steps JavaScript takes when evaluating the !carryingBox && !swimming
    expression. First, to simplify things, replace the variable names with the Boolean
    values they’re currently set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, replace the expressions !true and !false with their equivalent values,
    removing the ! operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now we just have to remember that && returns true only if both its operands
    are true. In this case, one of the operands is false, so we know that this expression
    evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a useful trick for working with Boolean expressions like this. The expression
    !a && !b can be rewritten as !(a || b). Think of this as rewording the original
    description from “not carrying a box *and* not swimming” to “not (carrying a box
    *or* swimming).” This trick is called De Morgan’s law (no relation!). It can also
    be used to convert !a || !b to !(a && b).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparison Operators</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript’s comparison operators compare values and return a Boolean value
    based on the result of the comparison. For example, the === or “triple equals”
    operator checks if two values are equal. It returns true if they are, or false
    if they aren’t. Here are some examples of the === operator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that === isn’t just for comparing number literals; it can also work
    with numerical expressions like 2 + 2, string literals ("hello"), string expressions
    ("hel" + "lo"), and Booleans. It can compare values stored in variables as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here answer is set to 4, the value of 2 + 2, so the comparison with 5 is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of the === operator is !== (the first = is replaced by a !). This
    operator checks if two values are *not* equal. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the !== operator is the same as using the === operator, then applying
    the ! operator to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript’s other comparison operators check if one value is greater than
    or less than another. These include the standard mathematical operations of greater
    than (>), less than (<), greater than or equal to (>=), and less than or equal
    to (<=). Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Notice in particular that comparing identical values with > or < returns false,
    but comparing them with >= or <= returns true.
  prefs: []
  type: TYPE_NORMAL
- en: 'These comparison operators can also be used with strings. One string is considered
    “greater than” another string if it would appear later in a dictionary. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The first comparison evaluates to true because the first letter of cat comes
    before the first letter of dog in the alphabet. In the second comparison, the
    first two characters of the strings are the same, but looking at the third character,
    c is later in the alphabet than b, so the first string is considered greater.
    It doesn’t matter that the second string is longer; JavaScript compares the strings
    character by character and stops the comparison as soon as it’s found a difference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Coercion</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Coercion* is the act of automatically converting a value of one data type
    into a value of a different data type. JavaScript uses coercion in certain circumstances
    where values of different data types appear in the same expression. For example,
    if you use the + operator with a string on one side and a number on the other,
    JavaScript coerces the number to a string, then joins the two strings together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice that 10 appears inside the quotes in the output, meaning it’s become
    a string rather than a number. This kind of coercion makes it quite easy to incorporate
    numbers into strings for display to a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some contexts, Boolean values are coerced into numbers, with false becoming
    0 and true becoming 1. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve used the Boolean literal true with a number in a mathematical expression,
    so JavaScript coerces it to a 1, then adds 100 and 1 to produce 101.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality with Coercion</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier we used the triple equals operator (===) to check for equality. There’s
    another operator, double equals (==), that applies coercion to its operands before
    checking for equality. For example, if you compare a number to a Boolean using
    ==, the Boolean will first be coerced into a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This comparison is true because the Boolean false is first coerced to a 0.
    If you make the same comparison using the triple equals operator, however, it
    will be false, since === doesn’t permit type coercion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be hard to guess what will be coerced to what when you use the == operator.
    Here are some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: When you compare a number with a string consisting of all numerals, such as
    "1", the string is coerced to the equivalent number, so "1" == 1 becomes 1 ==
    1, which evaluates to true. The == operator also returns true when undefined and
    null are compared to each other, but it returns false if undefined or null is
    compared to anything else. Meanwhile, an *empty string*—that is, a string that
    contains no characters, represented by a set of quotation marks with nothing in
    between ("")—is considered equivalent to the number 0 and the Boolean false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of == is the != operator. It determines if two operands are *not
    equal*, after any appropriate type coercion. Some inequalities that are true using
    the strict !== operator become false with the coercive != operator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Without coercion, 0 is not equal to false, so 0 !== false is true. With coercion,
    however, false becomes 0, so 0 != false is false.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be aware of the == and != operators, but because of the complicated
    rules governing type coercion, I’d recommend sticking to the strict === and !==
    operators as much as possible. You’ll be less likely to encounter unexpected behavior
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Truthiness</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Truthiness* is a special type of coercion that defines how non-Boolean values
    are treated as Booleans. This allows logical operators like && and ! to be used
    on any type of value. The way the operators work depends on whether JavaScript
    considers the value to be *truthy* (equivalent to true) or *falsy* (equivalent
    to false). The falsy values include undefined, null, the number 0, and an empty
    string (""). All nonzero numbers and nonempty strings are truthy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to check if a value is truthy or falsy is to apply two not
    operations to it using !!, meaning “not not,” a double negative. This works because
    the ! operator always returns a Boolean, regardless of the data type of the value
    it’s applied to. For example, say you want to verify that the number 0 is falsy.
    A single ! operation coerces the number to a Boolean, then inverts that Boolean,
    so !0 evaluates to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a second ! reverses the Boolean again, giving the Boolean equivalent
    of the original value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that 0 is equivalent to false, or falsy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the same !! trick to check the other truthiness rules I mentioned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The output confirms that nonzero numbers and nonempty strings are truthy, while
    an empty string, undefined, and null are falsy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the && and || operators are applied to non-Booleans, they don’t return
    a true or false value. Instead, they return one of the original operands. In the
    case of the && operator, if the first operand is truthy, the second operand is
    returned. If the first operand is falsy, the first operand is returned. Here are
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, 15 is truthy, so 17 is returned. In the other two cases,
    the first operand is falsy, so 0 and undefined are returned, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The || operator works the opposite way. If the first operand is falsy, it returns
    the second operand, and if the first operand is truthy, it returns the first operand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the first operand is an empty string, which is falsy, so
    the second operand is returned. In the second case, the first operand is a nonempty
    string, which is truthy, so the first operand is returned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uses for Truthiness</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can leverage the behavior of & & and || with truthy and falsy values in
    a number of ways. For example, the || operator can be used to give a variable
    a default value if one isn’t provided. This could be helpful in a scenario where
    a user neglects to enter their name on a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'At the start of this example, name is created without being given a value,
    so it’s undefined. Then we assign it a value using the Boolean expression name
    || "No name provided". Since the first operand is falsy, the second operand is
    returned. As a result, name is given the default value "No name provided". If,
    on the other hand, a name *had* been provided, name would be considered truthy,
    and so it would retain its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can use && or || to *short-circuit*, or skip, an expression.
    With &&, if the first operand is falsy, that’s the operand that will be evaluated
    and returned, so JavaScript doesn’t even bother evaluating the second operand.
    When the operands are just simple values, we don’t really care if they’re evaluated
    or not; all we care about is which value is returned. For example, in the expression
    1 || 2 + 2, it doesn’t especially matter whether JavaScript calculates the result
    of 2 + 2, because we know the first operand, 1, is going to be returned. It *does*
    matter if an expression is evaluated when that expression has some kind of *side
    effect*, however, meaning that evaluating it does something other than just returning
    a value. For example, the alert function returns the value undefined, but more
    importantly has the side effect of displaying a dialog. But what if we want to
    only display a dialog in some circumstances?
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we want to use alert to display a player’s score in a game,
    but only when the score isn’t zero. We can make the score variable and the alert
    function the operands in an && expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here score is 0, so the first operand in the && expression is falsy. The &&
    operator therefore returns this value and ignores the second operand, meaning
    alert is never called. We’ve short-circuited the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider what happens if score increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here we use ++ to increment score, changing its value to 1. This makes score
    truthy, so the second operand in the && expression is evaluated, executing the
    alert function. The function returns undefined, but also has the (desired) side
    effect of displaying a dialog with the player’s score (see [Figure 2-1](chapter2.xhtml#fig2-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The alert function’s
    side effect is displaying a message in a dialog.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we’re using the && operator to decide whether or not to run some
    code (the alert function) based on a condition (whether or not score is 0). In
    [Chapter 4](chapter4.xhtml), we’ll look at control structures like if statements,
    which give a more explicit way of controlling whether and how our code is run.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced you to some of the fundamental building blocks of JavaScript
    programming. You learned that a statement is a complete thought in JavaScript,
    ending with a semicolon, that instructs the computer to do something, and that
    a statement can consist of one or more expressions (units of code that represent
    a value). You saw how to use bindings to give a value a name for later use, either
    as a variable, in which case the value can be updated later, or as a constant,
    in which case the value remains fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also learned about three primitive data types in JavaScript: numbers, strings,
    and Booleans. You applied math operations to numbers, including using shorthand
    like ++ and -- to increment or decrement them, and you practiced manipulating
    strings using various methods, including slicing and trimming whitespace. With
    Booleans, you learned how to use logical operators like and (&&), or (||), and
    not (!), and you saw how to generate Boolean values using comparison operators
    like === and !==. Finally, you learned how JavaScript sometimes coerces values
    from one data type to another, including how non-Booleans are treated as truthy
    or falsy, and you explored situations where this can come in handy, such as to
    short-circuit an expression.'
  prefs: []
  type: TYPE_NORMAL
