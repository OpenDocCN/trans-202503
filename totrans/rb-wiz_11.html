<html><head></head><body>
  <div class="chapter" title="Chapter&#xA0;12.&#xA0;Reading, Writing, and Ruby Magic">&#13;
    <div class="titlepage">&#13;
      <h1 class="title" id="heading_id_2"><a id="readingcomma_writingcomma_and_ruby_magic"/>Chapter 12. Reading, Writing, and Ruby Magic</h1>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="File Input and Output">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_3"><a id="file_input_and_output"/>File Input and Output</h1>&#13;
      </div>&#13;
&#13;
      <p><a class="indexterm" id="iddle1419"/><a class="indexterm" id="iddle1445"/><a class="indexterm" id="iddle1643"/><a class="indexterm" id="iddle1822"/>Ruben looked around him and sighed. “Why did we run all the way here if the freight elevator goes so <span class="emphasis"><em>slow</em></span>?” he asked.</p>&#13;
&#13;
      <p>“You know,” said the King, rubbing his beardy chin, “I really don’t know. But I imagine it’ll be here any minute!”</p>&#13;
&#13;
      <p>No sooner had the King spoken than the freight elevator arrived with a great <span class="emphasis"><em>clang</em></span>. The doors slid open, revealing a huge metal elevator car.</p>&#13;
&#13;
      <p>“All aboard!” said Rusty, and they all climbed in. Rusty punched a round red button labeled <span class="smaller">LOADING DOCKS</span>, and with another <span class="emphasis"><em>clang</em></span>, the car began to slowly descend into the heart of the Refactory.</p>&#13;
&#13;
      <p>“We’ll be there in a jiffy,” Rusty said.</p>&#13;
&#13;
      <p>“A <span class="emphasis"><em>slow</em></span> jiffy,” Scarlet said. Ruben stifled a laugh.</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00057a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00057"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160067.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>“Not to worry,” Rusty said. “Every worker in the Refactory is down there, so there’s no chance those villains’ll escape!”</p>&#13;
&#13;
      <p>The King paced around the elevator car. “I can’t wait to question those scoundrels,” he said. “All this trouble they’ve caused! I’ll be keen to know what drove them to it.”</p>&#13;
&#13;
      <p>“I’ll bet they’re evil ninja wizards!” said Ruben.</p>&#13;
&#13;
      <p>“More like evil robot pirates,” said Scarlet.</p>&#13;
&#13;
      <p>“Whoever they are, they’ll have a lot to answer for,” said the Queen. “But we’ll know soon enough. We’re close—I can feel it!”</p>&#13;
&#13;
      <p>“That we are,” said Rusty. “Next stop: loading docks!”</p>&#13;
&#13;
      <p>A moment later, the freight elevator doors groaned open, and the King, the Queen, Scarlet, Ruben, and Rusty stepped onto the immense, bustling floor of the Refactory loading docks.</p>&#13;
&#13;
      <p>“Foreman here!” Rusty yelled to the crowd of men and women in hard hats as he led the group up a metal walkway and onto a large platform in the center of the enormous room. “What’ve we got?”</p>&#13;
&#13;
      <p>“Sir!” said Marshall, climbing up the walkway, “I rushed down here ahead of you to try to assess the situation. It looks like we’ve got four intruders holed up in one of the loading docks.”</p>&#13;
&#13;
      <p>“Which one?” Rusty asked.</p>&#13;
&#13;
      <p>Marshall shook his head. “We don’t know! They hid before we could see where they went. All we know is that we had the docks surrounded when they disappeared, so they must still be in here somewhere.”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1329"/>Rusty nodded and stroked his beard for a moment. “Well,” he said at last, “best get to finding them.” He walked to the edge of the platform and stepped on a large round indentation with his boot. In a hiss of steam, a column rose out of the platform. On the side facing the Foreman shone the unmistakable glow of a Computing Contraption screen.</p>&#13;
&#13;
      <p>“Each dock is controlled by a Ruby program,” Rusty said as the King, the Queen, Ruben, and Scarlet gathered around him. “Ruby treats each of them as a <span class="emphasis"><em>file</em></span>. If we can open each file, we’ll find our missing criminals!”</p>&#13;
&#13;
      <p>“A file? You mean, like a regular computer file?” Scarlet asked.</p>&#13;
&#13;
      <p>“The very same!” said Rusty. “Ruby can open just about any file you can think of: Ruby programs, text files, pictures, you name it!”</p>&#13;
&#13;
      <p>The Queen smiled. “I know all about files!” she said. “I’d be happy to lend a hand opening all these docks to find our culprits.” She cracked her knuckles. “How many files are there?” she asked.</p>&#13;
&#13;
      <p>Rusty gestured to the far wall, which was covered in hundreds of heavy metal doors.</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00058a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00058"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160069.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p><a class="indexterm" id="iddle1012"/><a class="indexterm" id="iddle1319"/><a class="indexterm" id="iddle1330"/><a class="indexterm" id="iddle1531"/><a class="indexterm" id="iddle1591"/><a class="indexterm" id="iddle1633"/>“Oh my,” said the Queen. “Well, then! We’d better get started.” She turned to Scarlet and Ruben. “To do this, we’ll need to use Ruby’s <span class="emphasis"><em>file I/O</em></span> methods,” she explained. “The I/O part stands for ‘input/output.’ <span class="emphasis"><em>Input</em></span> is what you put into a file, and <span class="emphasis"><em>output</em></span> is what comes out.”</p>&#13;
&#13;
      <p>“Like when you write a text file or save a picture?” Scarlet asked.</p>&#13;
&#13;
      <p>“Very much like that,” the Queen said. “Ruby can write input to a file, which is just like typing it with the keyboard and clicking Save. It can also read output from a file, which is just like double-clicking on the file and opening it!”</p>&#13;
&#13;
      <p>The Queen turned to Rusty. “Is there a test file I could use to show how it works?” she asked.</p>&#13;
&#13;
      <p>Rusty nodded. “Try <span class="emphasis"><em>lunch.txt</em></span>,” he said. “I think it just has the text <span class="smaller">ONE KAT-MAN-BLEU BURGER</span>, <span class="smaller">PLEASE</span> in it.”</p>&#13;
&#13;
      <p>“What’s a Kat-Man-Bleu burger?” asked Ruben.</p>&#13;
&#13;
      <p>“It’s the Wednesday lunch special in the Refactory cafeteria!” Rusty said. “The food’s not as good here as the food at the Hashery, but it does all right. That file just has the most recent lunch order in it.”</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="Opening a File with Ruby">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_4"><a id="opening_a_file_with_ruby"/>Opening a File with Ruby</h1>&#13;
      </div>&#13;
&#13;
      <p>“Very good!” said the Queen. “Now, if you have a file called <span class="emphasis"><em>lunch.txt</em></span> that contains only the text <span class="smaller">ONE KAT</span>-<span class="smaller">MAN</span>-<span class="smaller">BLEU BURGER</span>, <span class="smaller">PLEASE</span>, you can get to it like this!” She began typing:</p><a id="pro_id00410"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'r')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "ONE KAT-MAN-BLEU BURGER, PLEASE\n"&#13;
</pre>&#13;
&#13;
      <p>“That’s exactly the same as if you had double-clicked on <span class="emphasis"><em>lunch.txt</em></span>, only we can read the file’s text right inside Ruby! The <code class="literal">\n</code> at the end of <code class="literal">PLEASE</code> is Ruby’s way of representing ‘newline.’ If you open the file, it’ll just be the text <span class="smaller">ONE KAT</span>-<span class="smaller">MAN</span>-<span class="smaller">BLEU BURGER</span>, <span class="smaller">PLEASE</span> with a blank line under it.”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1132"/>The Queen thought for a moment. “Let me explain a bit more. <code class="literal">File.open</code> tells Ruby to create a file object based on a file called <span class="emphasis"><em>lunch.txt</em></span>.”</p>&#13;
&#13;
      <p>“What about the <code class="literal">'r'</code>?” Ruben asked.</p>&#13;
&#13;
      <p>“That’s called a <span class="emphasis"><em>mode</em></span>,” said the Queen, “and it tells Ruby what <span class="emphasis"><em>mode</em></span> it should open the file in. <code class="literal">'r'</code> means we’re just reading the file for now, not changing it.”</p>&#13;
&#13;
      <p>“Okay,” said Scarlet, “so we’ve got a file object stored in <code class="literal">file</code>. What does calling the <code class="literal">read</code> method do?”</p>&#13;
&#13;
      <p>“Exactly what you’d think!” said the Queen. “It reads the contents of the file and shows them to us.” She paused.</p>&#13;
&#13;
      <p>“Though usually, we open files with a block, like this.” She typed some more:</p><a id="pro_id00411"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">File.open('lunch.txt', 'r') { |file| file.read }</span>&#13;
=&gt; "ONE KAT-MAN-BLEU BURGER, PLEASE"&#13;
</pre>&#13;
&#13;
      <p>“Once again, we’ve got <code class="literal">File.open</code>, and we pass in the name of the file we want to open as a string, followed by a second string that tells us what mode to open the file in. In this case, we’ve used <code class="literal">'r'</code> for ‘read.’”</p>&#13;
&#13;
      <p>“With you so far,” said the King.</p>&#13;
&#13;
      <p>“Instead of saving the file object to a <code class="literal">file</code> variable and calling <code class="literal">read</code> on it, like we did before,” the Queen continued, “we pass <code class="literal">File.open</code> a block. We pass <code class="literal">file</code> to the block instead and call <code class="literal">file.read</code> inside the block!”</p>&#13;
&#13;
      <p>“Is there a difference between opening a file with a block and opening a file without one?” Scarlet asked.</p>&#13;
&#13;
      <p>“A very important difference!” said the Queen. “When you open a file with a block, the file is closed as soon as the block is finished. But if you open a file <span class="emphasis"><em>without</em></span> a block, it won’t automatically close. See?” She typed:</p><a id="pro_id00412"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'r')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&gt;&gt; <span class="red">file.closed?</span>&#13;
=&gt; false&#13;
</pre>&#13;
&#13;
      <p>“How do you close a file if you <span class="emphasis"><em>didn’t</em></span> open it with a block?” Ruben asked.</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1178"/><a class="indexterm" id="iddle1326"/><a class="indexterm" id="iddle1328"/>“By using the <code class="literal">close</code> method, like this!” the Queen said, typing:</p><a id="pro_id00413"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'r')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "ONE KAT-MAN-BLEU BURGER, PLEASE"&#13;
&#13;
&gt;&gt; <span class="red">file.close</span>&#13;
=&gt; nil&#13;
</pre>&#13;
&#13;
      <p>“That seems easy enough,” said the King, “but why do we need to close files in the first place?”</p>&#13;
&#13;
      <p>“Ruby keeps track of all the files we open, and the computer we’re running Ruby on will only let us open a certain number of files at a time,” the Queen explained. “If we try to open too many without closing them, we could make the computer crash!”</p>&#13;
&#13;
      <p>“Sweet kite-flying porcupines!” said the King. “We certainly wouldn’t want <span class="emphasis"><em>that</em></span>.”</p>&#13;
&#13;
      <p>“Also, if you don’t close a file,” the Queen continued, “Ruby won’t know you’re done with it, and unexpected things can happen later if you try to use a file you haven’t properly closed. You might even delete everything in it by accident!”</p>&#13;
&#13;
      <p>“Okay, we’ll make sure to close any files we open,” Ruben said. “It sounds like opening a file with a block is the easiest way to do that.”</p>&#13;
&#13;
      <p>“What else can we pass into the <code class="literal">open</code> method besides <code class="literal">'r'</code>?” asked the King, scratching under his tiny crown. “Can we do things besides just read files?”</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="Writing and Adding to Files">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_5"><a id="writing_and_adding_to_files"/>Writing and Adding to Files</h1>&#13;
      </div>&#13;
&#13;
      <p>“Of course, dear,” the Queen said. “You see, Ruby does exactly what you tell it, which means you must be very exact when you tell it to do anything. When you <code class="literal">open</code> a file, the first argument you give the <code class="literal">open</code> method is the filename, and the second one tells Ruby what it should expect to do with the file. You can do a lot with <code class="literal">open</code>—for instance, <code class="literal">open 'r'</code> tells Ruby to open a file but <span class="emphasis"><em>only</em></span> to read from it, starting from the beginning of the file.”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1068"/><a class="indexterm" id="iddle1446"/><a class="indexterm" id="iddle1647"/><a class="indexterm" id="iddle1947"/>“What are some of the other modes?” Scarlet asked.</p>&#13;
&#13;
      <p>“Well, you can use <code class="literal">open 'w'</code> to write to a file,” the Queen said. “Using the <code class="literal">'w'</code> mode will tell Ruby to create a new file with the name you give it, or it will completely overwrite any file that already has that name.”</p>&#13;
&#13;
      <p>“Overwrite!” said Scarlet. “You mean it will replace everything in the existing file with whatever text you give it?”</p>&#13;
&#13;
      <p>“That’s right,” said the Queen.</p>&#13;
&#13;
      <p>“What if you want to <span class="emphasis"><em>add</em></span> to an existing file?” asked Ruben.</p>&#13;
&#13;
      <p>“For that, you can use the <code class="literal">'a'</code> mode,” the Queen said. “That still tells Ruby to create a brand-new file with the name you give it if that file doesn’t already exist, but if that file <span class="emphasis"><em>does</em></span> exist, Ruby will start writing at the end of the file, so you won’t lose anything that’s already there.”</p>&#13;
&#13;
      <p>“Reading, writing, and adding,” said Scarlet. “I think that’s everything we want to do. But what happens if you use a mode that tells Ruby you’re going to do one thing, but then you try to do something else?” she asked.</p>&#13;
&#13;
      <p>“I’ll show you!” said the Queen. She typed into the Computing Contraption:</p><a id="pro_id00414"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'w')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
IOError: not opened for reading&#13;
</pre>&#13;
&#13;
      <p>“An error!” said Ruben. “We’ll have to be careful to use the right modes when we open files, then.”</p>&#13;
&#13;
      <p>“Precisely,” said the Queen. “Remember: Ruby does exactly what you tell it. If you use the <code class="literal">'w'</code> mode to tell Ruby you’re opening a file only for writing, then try to read from the file instead, Ruby will get confused and produce an error.”</p>&#13;
&#13;
      <p>“What if you want to read <span class="emphasis"><em>and</em></span> write to a file?” asked the King, who was busy inspecting a puff of pink lint he’d found stuck to his beard.</p>&#13;
&#13;
      <p>“Then we need to pass a slightly different mode to <code class="literal">File.open</code>,” the Queen said. She turned to Rusty. “What’s today’s cafeteria special?” she asked.</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1013"/><a class="indexterm" id="iddle1070"/><a class="indexterm" id="iddle1123"/><a class="indexterm" id="iddle1322"/><a class="indexterm" id="iddle1592"/><a class="indexterm" id="iddle1689"/><a class="indexterm" id="iddle1731"/>“Grilled cheese!” said Rusty. The Queen nodded and typed into the Computing Contraption:</p><a id="pro_id00415"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'w+')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.puts('THE MELTIEST OF GRILLED CHEESES')</span>&#13;
=&gt; nil&#13;
</pre>&#13;
&#13;
      <p>“Wow, what was that?” said Ruben. “I didn’t know you could use <code class="literal">puts</code> to write to a file!”</p>&#13;
&#13;
      <p>“Yes, you can,” said the Queen. “The only difference between <code class="literal">puts</code> and <code class="literal">write</code> is that <code class="literal">puts</code> adds an extra blank line after whatever you type, which Ruby represents with an <code class="literal">\n</code> (remember, that stands for ‘newline’). If you open the file, it’ll just be the text <span class="smaller">THE MELTIEST OF GRILLED CHEESES</span> with a blank line under it!”</p>&#13;
&#13;
      <p>“Now, we’ll try to read the lunch text back,” said the Queen, “but take a look at what happens the first time we try!”</p><a id="pro_id00416"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; ""&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "THE MELTIEST OF GRILLED CHEESES\n"&#13;
</pre>&#13;
&#13;
      <p>“Whoa!” said Scarlet. “We got nothing but an empty string the first time we called <code class="literal">file.read</code>, but after you called <code class="literal">file.rewind</code>, we could read the text in <span class="emphasis"><em>lunch.txt</em></span>. What does <code class="literal">rewind</code> do?”</p>&#13;
&#13;
      <p>“Just like you can press <span class="smaller">REWIND</span> on a remote control and send a movie back to the beginning, Ruby uses the <code class="literal">rewind</code> method to send you back to the beginning of a file. If you don’t <code class="literal">rewind</code> and then you try to <code class="literal">read</code> right after you’ve written to the file, you’ll just get an empty string!” replied the Queen.</p>&#13;
&#13;
      <p>“Like trying to press <span class="smaller">PLAY</span> when you’re already at the end of a movie!” said Ruben.</p>&#13;
&#13;
      <p>“Precisely,” said the Queen.</p>&#13;
&#13;
      <p>“That all makes sense,” said Scarlet, “but we used the <code class="literal">'w+'</code> mode, which means we overwrote the original <span class="emphasis"><em>lunch.txt</em></span> file!”</p>&#13;
&#13;
      <p>“That we did,” said the Queen. “Let’s put it back! I’ll show you a couple of new tricks while we do.” She began typing:</p><a id="pro_id00417"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('lunch.txt', 'a+')</span>&#13;
=&gt; #&lt;File:lunch.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.write('ONE KAT-MAN-BLEU BURGER, PLEASE')</span>&#13;
=&gt; 31&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.readlines</span>&#13;
=&gt; ["THE MELTIEST OF GRILLED CHEESES\n", "ONE KAT-MAN-BLEU BURGER,&#13;
PLEASE"]&#13;
</pre>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00059a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00059"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160071.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>“First, we reopen <span class="emphasis"><em>lunch.txt</em></span> for writing with <code class="literal">File.open</code>, using the <code class="literal">'a+'</code> mode,” the Queen explained. “This tells Ruby we want to add our new text to the end of the file instead of replacing all the text that’s already there. Next, we call <code class="literal">file.write</code> and pass in the new text we want to add to the end of <span class="emphasis"><em>lunch.txt</em></span>.”</p>&#13;
&#13;
      <p>“Why does Ruby return <code class="literal">31</code> when we call <code class="literal">file.write</code>?” Ruben asked.</p>&#13;
&#13;
      <p>“An excellent question!” said the Queen. “Ruby is telling us that it successfully added 31 characters to the end of <span class="emphasis"><em>lunch.txt</em></span>.”</p>&#13;
&#13;
      <p>“I see,” said Ruben. “So the <code class="literal">'a+'</code> mode must mean that we add to the file—so we don’t get rid of what’s already there—and the <code class="literal">+</code> part means we can add to <span class="emphasis"><em>and</em></span> read the file!”</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1323"/><a class="indexterm" id="iddle1711"/><a class="indexterm" id="iddle1732"/>“Correct!” said the Queen. “You’ll also see that since adding the text puts us all the way at the end of the file, we call <code class="literal">file.rewind</code> to ‘rewind’ our position to the very beginning. That’s why <code class="literal">file.rewind</code> returns <code class="literal">0</code>: we’re at the very start of the file!”</p>&#13;
&#13;
      <p>“But what does that <code class="literal">readlines</code> method do?” Ruben asked. “Does it just give us back an array of lines of text from the file?”</p>&#13;
&#13;
      <p>“Right again,” said the Queen. “Because I used <code class="literal">puts</code> to add the first line, <span class="smaller">ONE KAT</span>-<span class="smaller">MAN</span>-<span class="smaller">BLEU BURGER</span>, <span class="smaller">PLEASE</span> was added on its own line. The <code class="literal">readlines</code> method just goes through and creates an array from the file, where each item in the array is a single line of text. So we have an array with two elements here.”</p>&#13;
&#13;
      <p>“Astounding!” said the King, peering over his wife’s shoulder.</p>&#13;
&#13;
      <p>“Isn’t it?” she asked. “There’s also a <code class="literal">readline</code> method, which just gives us back one line at a time. See?” She typed some more:</p><a id="pro_id00418"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.readline</span>&#13;
=&gt; "THE MELTIEST OF GRILLED CHEESES\n"&#13;
&#13;
&gt;&gt; <span class="red">file.readline</span>&#13;
=&gt; "ONE KAT-MAN-BLEU BURGER, PLEASE"&#13;
</pre>&#13;
&#13;
      <p>“We can even use <code class="literal">readlines</code> with <code class="literal">each</code> to print out all the lines at once!” the Queen said, typing even more quickly:</p><a id="pro_id00419"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.readlines.each { |line| puts line }</span>&#13;
&#13;
THE MELTIEST OF GRILLED CHEESES&#13;
ONE KAT-MAN-BLEU BURGER, PLEASE&#13;
=&gt; ["THE MELTIEST OF GRILLED CHEESES\n", "ONE KAT-MAN-BLEU BURGER,&#13;
PLEASE"]&#13;
</pre>&#13;
&#13;
      <p>“That’s amazing!” said Ruben.</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="Avoiding Errors While Working with Files">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_6"><a id="avoiding_errors_while_working_with_files"/>Avoiding Errors While Working with Files</h1>&#13;
      </div>&#13;
&#13;
      <p><a class="indexterm" id="iddle1280"/><a class="indexterm" id="iddle1283"/><a class="indexterm" id="iddle1284"/><a class="indexterm" id="iddle1305"/><a class="indexterm" id="iddle1318"/><a class="indexterm" id="iddle1327"/>“I think I’m starting to understand file input and output now. But what happens if I try to use a file that doesn’t exist?” Ruben asked as he reached over to the Computing Contraption’s keyboard and typed:</p><a id="pro_id00420"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">File.open('imaginary.txt', 'r')</span>&#13;
Errno::ENOENT: No such file or directory - imaginary.txt&#13;
</pre>&#13;
&#13;
      <p>“An error!” Scarlet said. “That makes sense. Is there any way to find out if a file exists <span class="emphasis"><em>before</em></span> we try to use it?”</p>&#13;
&#13;
      <p>“Good question!” said the Queen. “If we’re not sure whether a file exists, we can use Ruby’s built-in <code class="literal">File.exist?</code> method to check.” She typed:</p><a id="pro_id00421"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">File.exist? 'lunch.txt'</span>&#13;
=&gt; true&#13;
&#13;
&gt;&gt; <span class="red">File.exist? 'imaginary.txt'</span>&#13;
=&gt; false&#13;
</pre>&#13;
&#13;
      <p>“Wonderful, wonderful!” said the King, clapping his hands together. “With all these magnificent Ruby tools, I have no doubt we can capture these crooks quite quickly.”</p>&#13;
&#13;
      <p>“You’re right!” said the Queen. She turned to Rusty. “Is there anything in the Ruby program that represents all the loading docks?” she asked.</p>&#13;
&#13;
      <p>Rusty nodded. “There’s an array, <code class="literal">loading_docks</code>, which is an array of files. Each file represents a loading dock door, so if you open and read all the files, all the doors should open!”</p>&#13;
&#13;
      <p>The Queen thought for a moment, her fingers hovering above the keyboard. Then she typed into the Computing Contraption:</p><a id="pro_id00422"/>&#13;
      <pre class="programlisting">&#13;
<span class="ash">loading_docks.each do |dock|</span>&#13;
  <span class="ash">current_dock = File.open(dock, 'r')</span>&#13;
  <span class="ash">puts current_dock.read</span>&#13;
  <span class="ash">current_dock.close</span>&#13;
<span class="ash">end</span>&#13;
</pre>&#13;
&#13;
      <p>One by one, the doors to each loading dock rolled open, hung ajar for a moment, then slid shut. Descriptions of each dock’s contents began to fill the Computing Contraption’s screen.</p>&#13;
&#13;
      <p>“Ruby code . . . Ruby code . . . shipment of Key-a-ma-Jiggers . . . <span class="emphasis"><em>there!</em></span>” shouted Rusty, pointing to a door in the center of the far wall.</p>&#13;
&#13;
      <p>Four shadowy figures leapt from the loading dock near the lower-left corner of the wall just as the doors began to slide shut again.</p>&#13;
&#13;
      <div class="informalfigure">&#13;
        <a id="med_id00060a"/>&#13;
&#13;
        <div class="mediaobject"><a id="med_id00060"/><img alt="image with no caption" src="../Images/httpatomoreillycomsourcenostarchimages2160073.png.jpg"/></div>&#13;
      </div>&#13;
&#13;
      <p>“Freeze!” shouted the King. “We’ve got you surrounded!”</p>&#13;
&#13;
      <p>The four figures moved with surprising speed, knocking over several Refactory workers as they tried to make their way to the nearest exit.</p>&#13;
&#13;
      <p>“Stop them!” Rusty yelled as the five of them ran down the metal walkway to the loading dock floor.</p>&#13;
&#13;
      <p>Several Refactory workers struggled with the intruders, but they were too fast and too slippery. In just a few seconds, they’d made it all the way to the exit!</p>&#13;
&#13;
      <p>“Make way, make way!” cried the Queen, and the five of them reached the Refactory exit just as the shadowy villains escaped <a class="indexterm" id="iddle1492"/>through the door. Without breaking stride, the King, the Queen, Ruby, Scarlet, and Rusty barreled through the doorway and into the narrow corridor leading back the way they’d come in.</p>&#13;
&#13;
      <p>“Are they headed for the freight elevator?” Ruben panted as they ran.</p>&#13;
&#13;
      <p>“Much worse!” Rusty said. “They’re headed straight for the WEBrick road!”</p>&#13;
&#13;
      <p>The King and Queen gasped together. “The WEBrick road!” said the Queen. “That leads straight out of the kingdom! If they get out through the kingdom gates, we’ll <span class="emphasis"><em>never</em></span> catch them!”</p>&#13;
&#13;
      <p>“Then we’ll just have to be sure that doesn’t happen,” Rusty said. He turned and called over his shoulder: “Everyone, after them!” And with that, every single person in the Refactory ran toward the small bright exit sign, with the King, the Queen, Scarlet, Ruben, and Rusty leading the pack.</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="All Loading Docks, Report for Duty!">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_7"><a id="all_loading_dockscomma_report_for_dutyex"/>All Loading Docks, Report for Duty!</h1>&#13;
      </div>&#13;
&#13;
      <p>We’ve nearly caught our crooks red-handed! Oh man, the suspense is killing me. Who <span class="emphasis"><em>are</em></span> they? Will the King, the Queen, Ruben, Scarlet, and Rusty catch them in time? What’s on the Refactory cafeteria lunch menu for tomorrow? Questions worth pondering until the end of time, for sure—or at least, until the end of this chapter. In the meantime, let’s get in just a bit more practice reading from and writing to a file.</p>&#13;
&#13;
      <p>Let’s start out by making a new file called <span class="bolditalic red">loading_docks.rb</span> and typing the following code. This is a simple little program that will create a text file for each of our loading docks, write some text into it, and then read it back to us.</p>&#13;
&#13;
      <p><span class="bolditalic red">loading_docks.rb</span></p><a id="pro_id00423"/>&#13;
      <pre class="programlisting">&#13;
  def create_loading_docks(➌docks=3)&#13;
➊   loading_docks = []&#13;
&#13;
➋   (1..docks).each do |number|&#13;
➍     file_name = "dock_#{number}.txt"&#13;
      loading_docks &lt;&lt; file_name&#13;
&#13;
➎     file = File.open(file_name, 'w+')&#13;
      file.write("Loading dock no. #{number}, reporting for duty!")&#13;
      file.close&#13;
    end&#13;
&#13;
    loading_docks&#13;
  end&#13;
&#13;
➏ def open_loading_docks(docks)&#13;
➐   docks.each do |dock|&#13;
      file = File.open(dock, 'r')&#13;
      puts file.read&#13;
      file.close&#13;
    end&#13;
  end&#13;
&#13;
➑ all_docks = create_loading_docks(5)&#13;
➒ open_loading_docks(all_docks)&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1096"/><a class="indexterm" id="iddle1571"/>While there are a few bits of code that are making appearances from earlier chapters, there’s nothing brand-new here for you to worry about. Let’s walk through the code line by line.</p>&#13;
&#13;
      <p>First, we set up an empty array called <code class="literal">loading_docks</code> ➊, which we’ll use to store the names of all the loading dock files we’ll create (so we can read them later). Next, we use the <code class="literal">(1..docks)</code> range to create as many loading docks as the <code class="literal">create_loading_docks</code> method requires ➋ (it defaults to <code class="literal">3</code> if no number is passed in ➌).</p>&#13;
&#13;
      <p>For each number in the range, we call a block that creates a file with that number (such as <span class="emphasis"><em>dock_1.txt</em></span>) and adds that filename to the <code class="literal">loading_docks</code> array ➍. We then open the file, write a string of text into it, and close it ➎.</p>&#13;
&#13;
      <p>Finally, in the <code class="literal">open_loading_docks</code> method ➏, we simply take our array of loading dock names (it looks something like <code class="literal">["dock_1.txt", "dock_2.txt"...]</code>, and so on), and for each filename, we open the file for reading, read its contents, and close it ➐. So when we run this script with <code class="literal">all_docks = create_loading_docks(5)</code> ➑ and <code class="literal">open_loading_docks(all_docks)</code> ➒ at the bottom, we end up creating <span class="emphasis"><em>dock_1.txt</em></span> through <span class="emphasis"><em>dock_5.txt</em></span>, each of which has its individual number and the <code class="literal">"reporting for duty!"</code> string in it.</p>&#13;
&#13;
      <p>Pretty great, right?</p>&#13;
&#13;
      <p><a class="indexterm" id="iddle1738"/><a class="indexterm" id="iddle1948"/>As always, you can run the finished script by typing <span class="strong"><strong><span class="red"><code class="literal">ruby loading_docks.rb</code></span></strong></span> at the command line. When you run it, you’ll see this:</p><a id="pro_id00424"/>&#13;
      <pre class="programlisting">&#13;
Loading dock no. 1, reporting for duty!&#13;
Loading dock no. 2, reporting for duty!&#13;
Loading dock no. 3, reporting for duty!&#13;
Loading dock no. 4, reporting for duty!&#13;
Loading dock no. 5, reporting for duty!&#13;
</pre>&#13;
&#13;
      <p>If you look in the directory where you ran <span class="emphasis"><em>loading_docks.rb</em></span>, you’ll also see a <span class="emphasis"><em>.txt</em></span> file for each dock, containing the very text our script printed out!</p>&#13;
&#13;
      <p>But I’m sure your head is already spinning with ways to improve this humble little script. For instance, we could change the number of files we create from 5 to 1, 3, 10, or any other number we choose! Just be careful—creating too many files will not only fill up your folder, but it could even crash your computer. (That’s why we defaulted to 3 and only did 5 in the example.)</p>&#13;
&#13;
      <p>You probably noticed that we wrote to the files with the <code class="literal">'w+'</code> mode, meaning that if we run the script again, it will overwrite the files with the new content. What if we want to add to the file instead, though? (Hint: The <code class="literal">'a+'</code> mode might be involved.)</p>&#13;
&#13;
      <p>For that matter, what if we want to write something fancier than just a plain old text file? What if we want to write a file that writes <span class="emphasis"><em>another Ruby file</em></span>? This is not only possible, but it’s a big part of what professional programmers do every day. Try to write a file with a small bit of Ruby in it—something as simple as <code class="literal">puts 'Written by Ruby!'</code>. (Make sure you write the file with <span class="emphasis"><em>.rb</em></span> at the end instead of <span class="emphasis"><em>.txt</em></span> so Ruby can run it.)</p>&#13;
&#13;
      <p>Finally, how might you work in some of the file methods we saw, like <code class="literal">exist?</code>, <code class="literal">rewind</code>, or <code class="literal">puts</code>? Are there other file methods in the Ruby documentation at <span class="emphasis"><em><a class="ulink" href="http://ruby-doc.org/core-1.9.3/File.html">http://ruby-doc.org/core-1.9.3/File.html</a></em></span> that might be cool to use? Remember to ask your local adult before going online!</p>&#13;
    </div>&#13;
&#13;
    <div class="sect1" title="You Know This!">&#13;
      <div class="titlepage">&#13;
        <h1 class="title" id="heading_id_8"><a id="you_know_thisexclamation_mark-id00012"/>You Know This!</h1>&#13;
      </div>&#13;
&#13;
      <p><a class="indexterm" id="iddle1133"/><a class="indexterm" id="iddle1179"/><a class="indexterm" id="iddle1317"/><a class="indexterm" id="iddle1320"/><a class="indexterm" id="iddle1321"/><a class="indexterm" id="iddle1332"/><a class="indexterm" id="iddle1632"/><a class="indexterm" id="iddle1701"/><a class="indexterm" id="iddle1709"/>You can read! You can write! Well, okay, you already knew how to do those things, but now you know how to do them <span class="emphasis"><em>with Ruby</em></span>. I don’t doubt that you’re a full-fledged Ruby sorcerer by now, but just to make sure there’s nothing unclear about this new Ruby wizardry we’ve covered, let’s take a second to review it.</p>&#13;
&#13;
      <p>You saw that Ruby can create, read, write, and understand <span class="emphasis"><em>files</em></span>, which are exactly like the computer files you already know about: text documents, pictures, Ruby scripts, and more. Ruby can open a file that already exists with the <code class="literal">open</code> method:</p><a id="pro_id00425"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('alien_greeting.txt', 'r')</span>&#13;
=&gt; #&lt;File:alien_greeting.txt&gt;&#13;
</pre>&#13;
&#13;
      <p>It can read a file with the <code class="literal">read</code> method:</p><a id="pro_id00426"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "GREETINGS HUMAN!"&#13;
</pre>&#13;
&#13;
      <p>And when we’re finished using a file, we should close it using the <code class="literal">close</code> method:</p><a id="pro_id00427"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.close</span>&#13;
=&gt; nil&#13;
</pre>&#13;
&#13;
      <p>It turns out we can accidentally crash our computer by keeping too many files open at once, so it’s always a good idea to close any file we’ve opened. Luckily, if we open a file with a block, Ruby automatically closes the file for us:</p><a id="pro_id00428"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">File.open('alien_greeting.txt', 'r') { |file| file.read }</span>&#13;
=&gt; "GREETINGS HUMAN!"&#13;
</pre>&#13;
&#13;
      <p>Ruby is pretty picky about being told what to do, so we have to use different <span class="emphasis"><em>modes</em></span> to tell Ruby which input and output <span class="emphasis"><em>mode</em></span> it should use. When we use <code class="literal">'r'</code>, we tell Ruby that we expect it only <a class="indexterm" id="iddle1069"/><a class="indexterm" id="iddle1949"/>to read files, and when we use <code class="literal">'w'</code>, we tell it we expect it only to write files. To tell Ruby it should both read <span class="emphasis"><em>and</em></span> write a file, we can give it the <code class="literal">'w+'</code> mode:</p><a id="pro_id00429"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">new_file = File.new('brand_new.txt', 'w+')</span>&#13;
=&gt; #&lt;File:brand_new.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">new_file.write("I'm a brand-new file!")</span>&#13;
=&gt; 21&#13;
&#13;
&gt;&gt; <span class="red">new_file.close</span>&#13;
=&gt; nil&#13;
&#13;
&gt;&gt; <span class="red">File.open('brand_new.txt', 'r') { |file| file.read }</span>&#13;
=&gt; "I'm a brand-new file!"&#13;
</pre>&#13;
&#13;
      <p>You found out that <code class="literal">'w+'</code> will overwrite a file—that is, it will replace <span class="emphasis"><em>everything</em></span> in the existing file with whatever string we tell Ruby to put in there. If we just want to <span class="emphasis"><em>add</em></span> to a file instead of replacing it completely, we can use the <code class="literal">'a'</code> mode (<code class="literal">'a+'</code> if we want to add to the file <span class="emphasis"><em>and</em></span> read from it):</p><a id="pro_id00430"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('breakfast.txt', 'a+')</span>&#13;
=&gt; #&lt;File:breakfast.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.write('Chunky ')</span>&#13;
=&gt; 7&#13;
&#13;
&gt;&gt; <span class="red">file.write('bacon!')</span>&#13;
=&gt; 6&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "Chunky bacon!"&#13;
</pre>&#13;
&#13;
      <p><a class="indexterm" id="iddle1324"/><a class="indexterm" id="iddle1690"/><a class="indexterm" id="iddle1710"/><a class="indexterm" id="iddle1712"/><a class="indexterm" id="iddle1733"/>Speaking of our friend <code class="literal">rewind</code>, you saw we could use it to back up to the start of the file and read the whole file:</p><a id="pro_id00431"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.open('dinner.txt', 'a+')</span>&#13;
=&gt; #&lt;File:dinner.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.write('A festive ham!')</span>&#13;
=&gt; 14&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; ""&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "A festive ham!"&#13;
</pre>&#13;
&#13;
      <p>In that first <code class="literal">file.read</code>, the string is empty because we’re at the end of the file. After we <code class="literal">rewind</code>, though, we go back to the start, and when we <code class="literal">file.read</code> again, our text is there.</p>&#13;
&#13;
      <p>You discovered that if we want to add a blank line after a line of text, we can use a file’s <code class="literal">puts</code> method instead of <code class="literal">write</code>. When we read the file back, Ruby shows us the blank line as a backslash and the letter <span class="emphasis"><em>n</em></span> (<code class="literal">\n</code>):</p><a id="pro_id00432"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.puts('A sprig of fresh parsley!')</span>&#13;
=&gt; nil&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.read</span>&#13;
=&gt; "A festive ham!A sprig of fresh parsley!\n"&#13;
</pre>&#13;
&#13;
      <p>In fact, you saw that we could use the <code class="literal">readline</code> and <code class="literal">readlines</code> methods to read out lines of a file one by one. <code class="literal">readline</code> reads one <a class="indexterm" id="iddle1306"/>line from the file at a time, and calling it a bunch of times reads each line, one after another:</p><a id="pro_id00433"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file = File.new('dessert.txt', 'a+')</span>&#13;
=&gt; #&lt;File:dessert.txt&gt;&#13;
&#13;
&gt;&gt; <span class="red">file.puts('A gooseberry pie')</span>&#13;
=&gt; nil&#13;
&#13;
&gt;&gt; <span class="red">file.puts('A small sack of muffins')</span>&#13;
=&gt; nil&#13;
&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.readline</span>&#13;
=&gt; "A gooseberry pie\n"&#13;
&#13;
&gt;&gt; <span class="red">file.readline</span>&#13;
=&gt; "A small sack of muffins\n"&#13;
</pre>&#13;
&#13;
      <p>If we want to read the lines of our file all at once, we can use <code class="literal">file.readlines</code> with a call to the <code class="literal">each</code> method and a block:</p><a id="pro_id00434"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">file.rewind</span>&#13;
=&gt; 0&#13;
&#13;
&gt;&gt; <span class="red">file.readlines.each { |line| puts line }</span>&#13;
A gooseberry pie&#13;
A small sack of muffins&#13;
=&gt; ["A gooseberry pie\n", "A small sack of muffins\n"]&#13;
</pre>&#13;
&#13;
      <p>Finally, you saw that we could check whether a file exists by using the <code class="literal">exist?</code> method:</p><a id="pro_id00435"/>&#13;
      <pre class="programlisting">&#13;
&gt;&gt; <span class="red">File.exist? 'breakfast.txt'</span>&#13;
=&gt; true&#13;
&#13;
&gt;&gt; <span class="red">File.exist? 'fancy_snack.txt'</span>&#13;
=&gt; false&#13;
</pre>&#13;
&#13;
      <p>Files and file input/output probably don’t seem like a big deal to you now (especially since you know a lot about how they work), but they’re a major part of how computers get work done. Don’t hesitate to mess around with creating and changing your files on your computer, and—with permission—hunt around the Internet for more information on files, how they work, and any interesting bits of Ruby code you can run to improve your understanding. But enough out of me: our heroes are hot on the tails of the tricksters who have been mucking things up in the kingdom all day, and we’re about to find out who they are, what they want, and whether the King, the Queen, Ruben, Scarlet, and the crew of the Refactory can stop them once and for all!</p>&#13;
    </div>&#13;
  </div>&#13;
</body></html>