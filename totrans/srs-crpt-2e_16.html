<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ELLIPTIC CURVES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">The introduction of <i>elliptic curve cryptography (ECC)</i> in 1985 revolutionized public-key cryptography. It’s more powerful and efficient than alternatives like RSA and classical Diffie–Hellman: ECC with a 256-bit key is stronger than RSA with a 4,096-bit key. But it’s also more complex.</p>&#13;
<p class="TX">Like RSA, ECC consists mainly of multiplications of large numbers, but it does so to combine points on a mathematical curve, called an <i>elliptic curve</i> (this has nothing to do with an ellipse, by the way). To complicate matters, there are many types of elliptic curves—simple and sophisticated, efficient and inefficient, and secure and insecure, depending on the use case.</p>&#13;
<p class="TX">ECC wasn’t adopted by standardization bodies until the early 2000s, and it wasn’t seen in major cryptographic software until much later: OpenSSL added ECC in 2005, and the OpenSSH secure connectivity tool waited until 2011. You’ll find ECC in most HTTPS connections, in mobile phones, and in blockchain platforms such as Bitcoin and Ethereum. Indeed, elliptic curves allow you to perform common public-key cryptography operations <span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>such as encryption, signature, and key agreement faster than their classical counterparts. Most cryptographic applications that rely on the discrete logarithm problem (DLP) also work when based on its elliptic curve counterpart, ECDLP, with one notable exception: the Secure Remote Password (SRP) protocol.</p>&#13;
<p class="TX">This chapter focuses on applications of ECC and discusses when and why to use ECC over RSA or classical Diffie–Hellman, as well as how to choose the right elliptic curve for your application.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">What Is an Elliptic Curve?</samp></h3>&#13;
<p class="TNI">An elliptic curve is a <i>curve</i> on a plane—a set of points with x- and y-coordinates. A curve’s equation defines all the points that belong to that curve. For example, the curve <i>y</i> = 3 is a horizontal line with the vertical coordinate 3, curves of the form <i>y</i> = <i>ax</i> + <i>b</i> with fixed numbers <i>a</i> and <i>b</i> are straight lines, <i>x</i><sup>2</sup> + <i>y</i><sup>2</sup> = 1 is a circle of radius 1 centered on the origin, and so on. Whatever the type of curve, the points on a curve are (<i>x</i>, <i>y</i>) pairs that satisfy the curve’s equation.</p>&#13;
<p class="TX">In cryptography, an elliptic curve typically has an equation in the form <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + <i>ax</i> + <i>b</i> (the <i>Weierstrass form</i>), where the constants <i>a</i> and <i>b</i> define the shape of the curve. For example, <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> shows the elliptic curve that satisfies the equation <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i>.</p>&#13;
<figure class="IMG"><img id="fig12-1" class="img1" src="../images/fig12-1.jpg" alt="" width="1360" height="1057"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An elliptic curve with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">– 4</samp><samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, shown over the real numbers</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>This figure displays all the points that make up the curve for <i>x</i> between –3 and 4, be they points on the left side of the curve, which looks like a circle, or on the right side, which looks like a parabola. All points have (<i>x</i>, <i>y</i>) coordinates that satisfy the curve’s equation <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i>. For example, when <i>x</i> = 0, then <i>y</i><i><sup>2</sup></i> = <i>x</i><sup>3</sup> – 4<i>x</i> = 0<sup>3</sup> – 4 × 0 = 0; hence, <i>y</i> = 0 is a solution, and the point (0, 0) belongs to the curve. Likewise, if <i>x</i> = 2, the solution to the equation is <i>y</i> = 0, meaning that the point (2, 0) belongs to the curve.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In this chapter, I focus on the simplest, most common type of elliptic curves—those with an equation like</i> <span class="note_Italic">y</span><i><sup>2</sup></i> <i>=</i> <span class="note_Italic">x</span><i><sup>3</sup></i> <i>+</i> <span class="note_Italic">ax</span> <i>+</i> <span class="note_Italic">b</span><i>—but other elliptic curves have equations in different forms. For example,</i> <span class="note_Italic">Edwards curves</span> <i>have equations of the form</i> <span class="note_Italic">x</span><i><sup>2</sup></i> <i>+</i> <span class="note_Italic">y</span><i><sup>2</sup></i> <i>= 1 +</i> <span class="note_Italic">dx</span><i><sup>2</sup></i><span class="note_Italic">y</span><i><sup>2</sup></i><i>. Cryptographers sometimes use Edwards curves (for example, in the Ed25519 scheme).</i></p>&#13;
<p class="TX">When using elliptic curves for cryptography, it’s crucial to distinguish points that belong to the curve from other points, as points off the curve often present a security risk. However, the curve’s equation doesn’t always admit solutions, at least not in the natural number plane. For example, to find points with the horizontal coordinate <i>x</i> = 1, you solve <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i> and obtain <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i> = 1<sup>3</sup> – 4 × 1, resulting in –3. But <i>y</i><sup>2</sup> = –3 doesn’t have a solution because there’s no number for which <i>y</i><sup>2</sup> = –3. There exists a solution in the complex numbers (√3<i>i</i>), but in practice, elliptic curve cryptography uses only natural numbers (ECC works with integer number modulo a prime number, either directly or via polynomials). Because there’s no solution to the curve’s equation for <i>x</i> = 1, the curve has no point at that position on the x-axis, as you can see in <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>.</p>&#13;
<p class="TX">If you try to solve for <i>x</i> = –1, you get the equation <i>y</i><sup>2</sup> = –1 + 4 = 3, which has two solutions (<i>y</i> = √3 ≈ 1.73 and <i>y</i> = –√3 ≈ –1.73), the square root of 3 and its negative value. The square of both values is 3, and <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> has two points with <i>x</i> = –1. More generally, the curve is symmetric with respect to the x-axis for all points that satisfy its equation (as are all elliptic curves of the form <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + <i>ax</i> + <i>b</i>, except for <i>y</i> = 0).</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-146"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curves over Integers</samp></h4>&#13;
<p class="TNI">Here’s a bit of a twist: the curves in elliptic curve cryptography don’t actually look like <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>. They’re neither curves nor ellipses. They look instead like <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>, which is a cloud of points rather than a curve. What’s going on here?</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>&#13;
<figure class="IMG"><img id="fig12-2" class="img1" src="../images/fig12-2.jpg" alt="" width="1362" height="1048"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The elliptic curve with the equation</samp> <samp class="SANS_Futura_Std_Book_11">y</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">=</samp> <samp class="SANS_Futura_Std_Book_11">x</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">– 4</samp><samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">over</samp> <samp class="SANS_Futura_Std_Book_11">Z</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">191</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, the set of integers modulo 191</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-1">Figures 12-1</a> and <a href="chapter12.xhtml#fig12-2">12-2</a> are based on the same curve equation, <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i>, but they show the curve’s points with respect to different sets of numbers: <a href="chapter12.xhtml#fig12-1">Figure 12-1</a> shows the curve’s points over the set of <i>real numbers</i>, which includes negative numbers, decimals, and so on. For example, as a continuous curve, it shows the points at <i>x</i> = 2.0, <i>x</i> = 2.1, <i>x</i> = 2.00002, and so on. <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>, on the other hand, shows only <i>integers</i> that satisfy this equation, which excludes decimal numbers. Specifically, <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> shows the curve <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i> with respect to the integers <i>modulo 191</i>: 0, 1, 2, 3, up to 190. You can denote this set of numbers <b>Z</b><sub>191</sub>. (There’s nothing special with 191 here, except that it’s a prime number. I picked a small number to avoid having too many points on the graph.) The points in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> therefore all have x- and y-coordinates that are integers modulo 191 and that satisfy the equation <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i>. For example, for <i>x</i> = 2, you have <i>y</i><sup>2</sup> = 0, for which <i>y</i> = 0 is a valid solution. This tells you that the point (2, 0) belongs to the curve.</p>&#13;
<p class="TX">If <i>x</i> = 3, you get the equation <i>y</i><sup>2</sup> = 27 – 12 = 15, which admits two solutions in <b>Z</b><sub>191</sub>, 46 and 145. Indeed, 46<sup>2</sup> = 2,116, with 2,116 mod 191 = 15, and 145<sup>2</sup> = 21,025, with 21,025 mod 191 = 15. Thus, the points (3, 46) and (3, 145) both belong to the curve and appear as in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> (the two points circled on the left).</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT0"><i><a href="chapter12.xhtml#fig12-2">Figure 12-2</a> considers points from the set denoted</i> <b><i>Z</i></b><span class="ePub-I-SUB">191</span> <i>= {0, 1, 2, . . . , 190}, which includes zero. This differs from the groups denoted</i> <b><i>Z</i></b><sub>p</sub><sup>*</sup> <i>(with a star superscript) that we discussed in the context of RSA and Diffie–Hellman. The reason for this difference is that you’ll both multiply and add numbers, and you therefore need to ensure that the set of numbers includes addition’s identity element (namely 0, such that</i> <span class="note_Italic">x</span> <i>+ 0 =</i> <span class="note_Italic">x</span> <i>for every</i> <span class="note_Italic">x</span> <i>in</i> <b><i>Z</i></b><span class="ePub-I-SUB">191</span><i>).</i></p>&#13;
<p class="NoteContinued"><i>Also, every number</i> <span class="notecontinued_Italic">x</span> <i>has an inverse with respect to addition, denoted –</i><span class="notecontinued_Italic">x</span><i>, such that</i> <span class="notecontinued_Italic">x</span> <i>+ (–</i><span class="notecontinued_Italic">x</span><i>) = 0. For example, the inverse of 100 in</i> <b><i>Z</i></b><span class="ePub-I-SUB">191</span> <i>is 91 because 100 + 91 mod 191 = 0. Such a set of numbers, where addition and multiplication are possible and where each element</i> <span class="notecontinued_Italic">x</span> <i>admits an inverse with respect to addition (denoted –</i><span class="notecontinued_Italic">x</span><i>) as well as an inverse (except for the element zero) with respect to multiplication (denoted 1 /</i> <span class="notecontinued_Italic">x</span><i>), is called a</i> <span class="notecontinued_Italic">field</span><i>. When a field has a finite number of elements, as in</i> <b><i>Z</i></b><span class="ePub-I-SUB">191</span> <i>and as with all fields used for elliptic curve cryptography, it is a</i> <span class="notecontinued_Italic">finite field</span>.</p>&#13;
</blockquote>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-147"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Addition Law</samp></h4>&#13;
<p class="TNI">Now that you know that the points on an elliptic curve are coordinates (<i>x</i>, <i>y</i>) that satisfy the curve’s equation, <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + <i>ax</i> + <i>b</i>, let’s look at how to add elliptic curve points with the <i>addition law</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Two Points</samp></h5>&#13;
<p class="TNI">Say you want to add two points on the elliptic curve, <i>P</i> and <i>Q</i>, to give a new point, <i>R</i>, that is the sum of these two points. The simplest way to understand point addition is to determine the position of <i>R</i> = <i>P</i> + <i>Q</i> on the curve relative to <i>P</i> and <i>Q</i> based on a geometric rule: draw the line that connects <i>P</i> and <i>Q</i>, find the other point of the curve that intersects with this line, and <i>R</i> is the reflection of this point with respect to the x-axis. For example, in <a href="chapter12.xhtml#fig12-3">Figure 12-3</a>, the line connecting <i>P</i> and <i>Q</i> intersects the curve at a third point between <i>P</i> and <i>Q</i>, and the point <i>P</i> + <i>Q</i> is at the same x-coordinate but the inverse y-coordinate.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>&#13;
<figure class="IMG"><img id="fig12-3" class="img1" src="../images/fig12-3.jpg" alt="" width="1358" height="1052"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A general case of the geometric rule for adding points over an elliptic curve</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This geometric rule is simple, but it won’t directly give you the coordinates of the point <i>R</i>. You compute the coordinates (<i>x</i><span class="ePub-I-SUB">R</span>, <i>y</i><span class="ePub-I-SUB">R</span>) of <i>R</i> using the coordinates (<i>x</i><span class="ePub-I-SUB">P</span>, <i>y</i><span class="ePub-I-SUB">P</span>) of <i>P</i> and the coordinates (<i>x</i><span class="ePub-I-SUB">Q</span>, <i>y</i><span class="ePub-I-SUB">Q</span>) of <i>Q</i> using the formulas <i>x</i><span class="ePub-I-SUB">R</span> <i>= m</i><sup>2</sup> <i>– x</i><span class="ePub-I-SUB">P</span> <i>– x</i><span class="ePub-I-SUB">Q</span> and <i>y</i><span class="ePub-I-SUB">R</span> <i>= m(x</i><span class="ePub-I-SUB">P</span> <i>– x</i><span class="ePub-I-SUB">R</span><i>) – y</i><span class="ePub-I-SUB">P</span> , where the value <i>m = (y</i><span class="ePub-I-SUB">Q</span> <i>– y</i><span class="ePub-I-SUB">P</span><i>) / (x</i><span class="ePub-I-SUB">Q</span> <i>– x</i><span class="ePub-I-SUB">P</span><i>)</i> is the slope of the line connecting <i>P</i> and <i>Q</i>.</p>&#13;
<p class="TX">Unfortunately, these formulas and the line-drawing trick in <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> don’t always work. If, for example, <i>P</i> = <i>Q</i>, you can’t draw a line between two points (there’s only one), and if <i>Q</i> = –<i>P</i>, the line doesn’t cross the curve again, so there’s no point on the curve to mirror. We’ll explore these in the next sections.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Point and Its Negative</samp></h5>&#13;
<p class="TNI">The negative of a point <i>P</i> = (<i>x</i><span class="ePub-I-SUB">P</span>, <i>y</i><span class="ePub-I-SUB">P</span>) is the point –<i>P</i> = (<i>x</i><span class="ePub-I-SUB">P</span>, –<i>y</i><span class="ePub-I-SUB">P</span>), which is the point mirrored around the x-axis. For any <i>P</i>, you can say that <i>P</i> + (–<i>P</i>) = <i>O</i>, where <i>O</i> is the <i>point at infinity</i>. As in <a href="chapter12.xhtml#fig12-4">Figure 12-4</a>, the line between <i>P</i> and –<i>P</i> runs to infinity and never intersects the curve. The point at infinity is to elliptic curves what zero is to integers, except that it’s only a “virtual” point that you can’t locate at a specific place, because it’s infinitely far.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>&#13;
<figure class="IMG"><img id="fig12-4" class="img1" src="../images/fig12-4.jpg" alt="" width="1356" height="1050"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The geometric rule for adding a point and its negative, or</samp> <samp class="SANS_Futura_Std_Book_11">P</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+ (–</samp><samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">O,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">when the line between the points never intersects the curve</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doubling a Point</samp></h5>&#13;
<p class="TNI">When <i>P</i> = <i>Q</i> (that is, <i>P</i> and <i>Q</i> are at the same position), adding <i>P</i> and <i>Q</i> is equivalent to computing <i>P</i> + <i>P</i>, or 2<i>P</i>. This addition operation is called a <i>doubling</i>.</p>&#13;
<p class="TX">To find the coordinates of the result <i>R</i> = 2<i>P</i>, you can’t use the geometric rule from the previous section, because you can’t draw a line between <i>P</i> and itself. Instead, you draw the line <i>tangent</i> to the curve at <i>P</i>, and 2<i>P</i> is the negation of the point where this line intersects the curve, as <a href="chapter12.xhtml#fig12-5">Figure 12-5</a> demonstrates.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>&#13;
<figure class="IMG"><img id="fig12-5" class="img1" src="../images/fig12-5.jpg" alt="" width="1363" height="1055"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The geometric rule for doubling a point—that is,</samp> <samp class="SANS_Futura_Std_Book_11">P</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">P</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The formula to determine the coordinates (<i>x</i><span class="ePub-I-SUB">R</span>, <i>y</i><span class="ePub-I-SUB">R</span>) of <i>R</i> = <i>P</i> + <i>P</i> is slightly different from the formula for a distinct <i>P</i> and <i>Q</i>. The basic formula is <i>x</i><span class="ePub-I-SUB">R</span> = <i>m</i><sup>2</sup> – <i>x</i><span class="ePub-I-SUB">P</span> – <i>x</i><span class="ePub-I-SUB">Q</span> and <i>y</i><span class="ePub-I-SUB">R</span> = <i>m</i>(<i>x</i><span class="ePub-I-SUB">P</span> – <i>x</i><span class="ePub-I-SUB">R</span>) – <i>y</i><span class="ePub-I-SUB">P</span> , but the value of <i>m</i> becomes (3<i>x</i><span class="ePub-I-SUB">P</span><sup>2</sup> + <i>a</i>) / 2<i>y</i><span class="ePub-I-SUB">P</span> , where <i>a</i> is the curve’s parameter, as in <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + <i>ax</i> + <i>b</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Multiplying Points</samp></h5>&#13;
<p class="TNI">To multiply points on elliptic curves by a given integer number <i>k</i>, you determine the point <i>kP</i> by adding <i>P</i> to itself <i>k</i> – 1 times. In other words, 2<i>P</i> = <i>P</i> + <i>P</i>, 3<i>P</i> = <i>P</i> + <i>P</i> + <i>P</i>, and so on. To obtain the x- and y-coordinates of <i>kP</i>, repeatedly add <i>P</i> to itself and apply the preceding addition law.</p>&#13;
<p class="TX">To compute <i>kP</i> efficiently, however, the naive technique of adding <i>P</i> by applying the addition law <i>k</i> – 1 times is far from optimal. For example, if <i>k</i> is large (of the order of, say, 2<sup>256</sup>) as it occurs in elliptic curve–based crypto schemes, then computing <i>k</i> – 1 additions is downright infeasible.</p>&#13;
<p class="TX">You can gain an exponential speedup by adapting the technique in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>’s “<span class="Xref">A Fast Exponentiation Algorithm</span>” to compute <i>x</i><i><sup>e</sup></i> mod <i>n</i>. The difference is that you’re multiplying points by an integer rather than computing exponentiations. But you can adapt the method to become <i>double-and-add</i>, where multiplication becomes addition and squaring becomes doubling.</p>&#13;
<p class="TX">For example, to compute 8<i>P</i> in three additions instead of seven using the naive method, first compute <i>P</i><sub>2</sub> = <i>P</i> + <i>P</i>, then <i>P</i><sub>4</sub> = <i>P</i><sub>2</sub> + <i>P</i><sub>2</sub>, and finally <i>P</i><sub>4</sub> + <i>P</i><sub>4</sub> = 8<i>P</i>. This is the simplest case, when the multiplier is a power of two, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>such as 8 = 2<sup>3</sup>. Otherwise, for example, to compute 10<i>P</i>, proceed as follows: observing that 10 is 1010 in binary, start by the most significant (“leftmost”) bit and compute the result <i>R</i> like so:</p>&#13;
<p class="RunInPara"><b>Bit 1 </b>Start by setting <i>R</i> = <i>P</i>.</p>&#13;
<p class="RunInPara"><b>Bit 0 </b>Double, setting <i>R</i> = 2<i>R</i> = 2<i>P</i>.</p>&#13;
<p class="RunInPara"><b>Bit 1 </b>Double and add, setting <i>R</i> = 2<i>R</i> + <i>P</i> = 2(2<i>P</i>) + <i>P</i> = 5<i>P</i>.</p>&#13;
<p class="RunInPara"><b>Bit 0 </b>Double, setting <i>R</i> = 2<i>R</i> = 2(5<i>P</i>) = 10<i>P</i>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Elliptic Curve Groups</samp></h4>&#13;
<p class="TNI">Not only can you add elliptic curve points together, you can also use them to form a group structure. According to the definition of a group (see “<span class="Xref">Groups</span>” in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>), if the points <i>P</i> and <i>Q</i> belong to a given curve, then <i>P</i> + <i>Q</i> also belongs to the curve.</p>&#13;
<p class="TX">Furthermore, because addition is <i>associative</i>, you have (<i>P</i> + <i>Q</i>) + <i>R</i> = <i>P</i> + (<i>Q</i> + <i>R</i>) for any points <i>P</i>, <i>Q</i>, and <i>R</i>. In a group of elliptic curve points, we call the identity element the point at infinity and denote it as <i>O</i>, such that <i>P</i> + <i>O</i> = <i>P</i> for any <i>P</i>. Every point <i>P</i> = (<i>x</i><span class="ePub-I-SUB">P</span>, <i>y</i><span class="ePub-I-SUB">P</span>) has an inverse, –<i>P</i> = (<i>x</i><span class="ePub-I-SUB">P</span> , –<i>y</i><span class="ePub-I-SUB">P</span>), such that <i>P</i> + (–<i>P</i>) = <i>O</i>.</p>&#13;
<p class="TX">In practice, most elliptic curve–based cryptosystems work with x- and y-coordinates that are numbers modulo a prime number, <i>p</i> (in other words, numbers in the finite field <b>Z</b><span class="ePub-I-SUB">p</span>). Just as the security of RSA depends on the size of the numbers used, the security of an elliptic curve–based cryptosystem depends on the number of points on the curve. But how do you know the number of points on an elliptic curve, or its <i>cardinality</i>? Well, it depends on the curve and the value of <i>p</i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Prime fields aren’t the only fields used in elliptic curve cryptography. There are also</i> <span class="note_Italic">binary fields</span><i>, which are extensions of the two-element field (which includes 0 and 1), whose elements are represented as polynomials with binary coefficients. Arithmetic over binary fields has the advantage of often being easier to implement efficiently in hardware as logic circuits, compared to a general-purpose microprocessor.</i></p>&#13;
<p class="TX">There are of the order of <i>p</i> points on a curve defined over <b>Z</b><span class="ePub-I-SUB">p</span>, but you can compute the exact number of points with Schoof’s algorithm, which counts points on elliptic curves over finite fields. You’ll find this algorithm built into SageMath. For example, <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a> uses Schoof’s algorithm to count the number of points on the curve <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 4<i>x</i> over <b>Z</b><sub>191</sub> from <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>.</p>&#13;
<span id="Lis12-1"/><pre><code>sage: <b>Z = Zmod(191)</b>&#13;
sage: <b>E = EllipticCurve(Z, (-4,0))</b>&#13;
sage: <b>E.cardinality()</b>&#13;
192</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Computing the cardinality, or the number of points on a curve</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>In <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a>, you first define the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> as the set over integers modulo 191; then you define the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> as the elliptic curve over <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> with the coefficients –4 and 0. Finally, you compute the number of points on the curve, or its <i>cardinality</i>, <i>group order</i>, or just <i>order</i>. This count includes the point at infinity <i>O</i>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">The ECDLP Problem</samp></h3>&#13;
<p class="TNI"><span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> introduced the discrete logarithm problem (DLP): that of finding the number <i>y</i> given some base number <i>g</i>, where <i>x</i> = <i>g</i> <i><sup>y</sup></i> mod <i>p</i> for some large prime number <i>p</i>. Cryptography with elliptic curves has a similar problem of finding the number <i>k</i> given a base point <i>P</i> where the point <i>Q</i> = <i>kP</i>. This is the elliptic curve discrete logarithm problem. Instead of numbers, the elliptic curve’s problems operate on points and use multiplication instead of exponentiation.</p>&#13;
<p class="TX">About all elliptic curve cryptography is built on the ECDLP problem, which, like DLP, is believed to be hard and has withstood cryptanalysis since its introduction in 1985. One important difference from the classical DLP is that ECDLP allows you to work with smaller numbers and still enjoy a similar level of security.</p>&#13;
<p class="TX">Generally, when the parameter <i>p</i> is <i>n</i>-bit, ECC gets you a security level of about <i>n</i>/2 bits. For example, an elliptic curve taken over numbers modulo a 256-bit <i>p</i> gives a security level of about 128 bits. For the sake of comparison, to achieve a similar security level with DLP or RSA, you need to use numbers of several thousands of bits. Using smaller numbers for ECC arithmetic is one reason why it’s often faster than RSA or classical Diffie–Hellman.</p>&#13;
<p class="TX">One approach to solving ECDLP is to find a collision between two outputs, <i>c</i><sub>1</sub><i>P</i> + <i>d</i><sub>1</sub><i>Q</i> and <i>c</i><sub>2</sub><i>P</i> + <i>d</i><sub>2</sub><i>Q</i>. The points <i>P</i> and <i>Q</i> in these equations are such that <i>Q</i> = <i>kP</i> for some unknown <i>k</i>, and <i>c</i><sub>1</sub>, <i>d</i><sub>1</sub>, <i>c</i><sub>2</sub>, and <i>d</i><sub>2</sub> are the numbers you need to find <i>k</i>.</p>&#13;
<p class="TX">As with the hash function in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, a collision occurs when two different inputs produce the same output. Therefore, to solve ECDLP, you need to find points where the following is true:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg240-1.jpg" alt="" width="1383" height="40"/></figure>&#13;
<p class="TX">Assuming you’ve found the four coefficients, you’re going to recover <i>k</i>. For this, replace <i>Q</i> with the value <i>kP</i>, and you have the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg240-2.jpg" alt="" width="1383" height="52"/></figure>&#13;
<p class="TX">This tells you that (<i>c</i><sub>1</sub> + <i>d</i><sub>1</sub><i>k</i>) equals (<i>c</i><sub>2</sub> + <i>d</i><sub>2</sub><i>k</i>) when taken modulo the number of points on the curve, which isn’t a secret.</p>&#13;
<p class="TX">From this, you can deduce the following:</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg241-1.jpg" alt="" width="1383" height="185"/></figure>&#13;
<p class="TX">And you’ve found <i>k</i>, the solution to ECDLP. Of course, that’s only the big picture—the details are more complex and interesting, notably regarding the way to recover the coefficients <i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>, <i>d</i><sub>1</sub>, <i>d</i><sub>2</sub>.</p>&#13;
<p class="TX">In practice, elliptic curves extend over numbers of at least 256 bits, which makes attacking elliptic curve cryptography by finding a collision impractical because doing so takes up to 2<sup>128</sup> operations (the cost of finding a collision over 256-bit numbers—see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1" id="sec10"><span id="h1-84"/><samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Key Agreement over Elliptic Curves</samp></h3>&#13;
<p class="TNI">Recall from <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> that in the classical Diffie–Hellman (DH) key agreement protocol, two parties establish a shared secret by exchanging nonsecret values. Given some fixed number <i>g</i>, Alice picks a secret random number <i>a</i>, computes <i>A</i> = <i>g</i><i><sup>a</sup></i>, and sends <i>A</i> to Bob. Then Bob picks a secret random <i>b</i> and sends <i>B</i> = <i>g</i><i><sup>b</sup></i> to Alice. Both combine their secret key with the other’s public key to produce the same <i>A</i><i><sup>b</sup></i> = <i>B</i><i><sup>a</sup></i> = <i>g</i><i><sup>ab</sup></i>.</p>&#13;
<p class="TX">The elliptic curve version of DH, <i>elliptic curve Diffie–Hellman (ECDH)</i>, is identical to that of classical DH but with different notations. In the case of ECC, for some fixed-point <i>G</i>, Alice picks a secret random number <i>a</i>, computes <i>A</i> = <i>aG</i> (the point <i>G</i> multiplied by the integer <i>a</i>), and sends <i>A</i> to Bob. Bob picks a secret random <i>b</i>, computes the point <i>B</i> = <i>bG</i>, and sends it to Alice. Then both compute the same shared secret, <i>aB</i> = <i>bA</i> = <i>abG</i>.</p>&#13;
<p class="TX">ECDH is to the ECDLP problem what DH is to DLP: it’s secure as long as ECDLP is hard. You can therefore adapt DH protocols that rely on DLP to work with elliptic curves and rely on ECDLP as a hardness assumption. For example, authenticated DH and Menezes–Qu–Vanstone (MQV) will also be secure when used with elliptic curves. In fact, MQV was first defined as working over elliptic curves.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H1" id="sec11"><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">Signing with Elliptic Curves</samp></h3>&#13;
<p class="TNI">The main standard algorithm you can use for signing with ECC is <i>elliptic curve digital signature algorithm (ECDSA)</i>. This algorithm has replaced RSA signatures and classical DSA signatures in many applications. ECDSA is a NIST standard, is supported in the TLS and SSH protocols, and is the main signature algorithm in many blockchain platforms, including Bitcoin and Ethereum.</p>&#13;
<p class="TX">As with all signature schemes, ECDSA consists of a <i>signature generation</i> algorithm that the signer uses to create a signature using their private key and a <i>verification</i> algorithm that a verifier uses to check a signature’s correctness given the signer’s public key. The signer holds a number, <i>d</i>, as a private <span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>key, and verifiers hold the public key, <i>P</i> = <i>dG</i>. Both know in advance what elliptic curve to use, its order (<i>n</i>, the number of points in the curve), and the coordinates of a base point, <i>G</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-149"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Generation</samp></h4>&#13;
<p class="TNI">To sign a message, the signer first hashes the message with a cryptographic hash function such as SHA-256 or BLAKE2 to generate a hash value, <i>h</i>, that you interpret as a number between 0 and <i>n</i> – 1. Next, the signer picks a random number, <i>k</i>, between 1 and <i>n</i> – 1 and computes <i>kG</i>, a point with the coordinates (<i>x</i>, <i>y</i>). The signer now sets <i>r</i> = <i>x</i> mod <i>n</i> and computes <i>s</i> = (<i>h</i> + <i>rd</i>) / <i>k</i> mod <i>n</i> and then uses these values as the signature (<i>r</i>, <i>s</i>).</p>&#13;
<p class="TX">The length of the signature depends on the coordinate lengths you’re using. For example, when you’re working with a curve where coordinates are 256-bit numbers, <i>r</i> and <i>s</i> are both 256 bits long, yielding a 512-bit-long signature.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-150"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA Signature Verification</samp></h4>&#13;
<p class="TNI">The ECDSA verification algorithm uses a signer’s public key to verify the validity of a signature.</p>&#13;
<p class="TX">To verify an ECDSA signature (<i>r</i>, <i>s</i>) and a message’s hash, <i>h</i>, the verifier first computes <i>w</i> = 1 / <i>s</i>, the inverse of <i>s</i> in the signature, which is equal to <i>k</i> / (<i>h</i> + <i>rd</i>) mod <i>n</i>, since <i>s</i> is defined as <i>s</i> = (<i>h</i> + <i>rd</i>) / <i>k</i>. Next, the verifier multiplies <i>w</i> with <i>h</i> to find <i>u</i> according to the following formula:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg242-1.jpg" alt="" width="1519" height="48"/></figure>&#13;
<p class="TX">The verifier then multiplies <i>w</i> with <i>r</i> to find <i>v</i>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg242-2.jpg" alt="" width="1519" height="48"/></figure>&#13;
<p class="TX">Given <i>u</i> and <i>v</i>, the verifier computes the point <i>Q</i> according to the following formula:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg242-3.jpg" alt="" width="1519" height="40"/></figure>&#13;
<p class="TX">Here, <i>P</i> is the signer’s public key, which is equal to <i>dG</i>, and the verifier accepts the signature only if the x-coordinate of <i>Q</i> is equal to the value <i>r</i> from the signature.</p>&#13;
<p class="TX">This process works because, as a last step, you compute the point <i>Q</i> by substituting the public key <i>P</i> with its actual value <i>dG</i>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg242-4.jpg" alt="" width="1519" height="48"/></figure>&#13;
<p class="TX">When you replace <i>u</i> and <i>v</i> with their actual values, you obtain the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg242-5.jpg" alt="" width="1519" height="48"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>This tells you that (<i>u</i> + <i>vd</i>) is equal to the value <i>k</i>, chosen during signature generation, and that <i>uG</i> + <i>vdG</i> is equal to the point <i>kG</i>. In other words, the verification algorithm succeeds in computing point <i>kG</i>, the same point computed during signature generation. Validation is complete once a verifier confirms that <i>kG</i>’s x-coordinate is equal to the <i>r</i> received; otherwise, the signature is rejected as invalid.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-151"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA vs. RSA Signatures</samp></h4>&#13;
<p class="TNI">While some view elliptic curve cryptography as an alternative to RSA for public-key cryptography, ECC and RSA don’t have much in common. You use RSA only for encryption and signatures, and ECC is a family of algorithms that you use to perform encryption, generate signatures, perform key agreement, and offer advanced cryptographic functionalities such as identity-based encryption (a kind of encryption that uses encryption keys derived from a personal identifier, such as an email address).</p>&#13;
<p class="TX">When comparing ECDSA to RSA signatures, recall that in RSA signatures, the signer uses their private key <i>d</i> to compute a signature as <i>y</i> = <i>x</i><i><sup>d</sup></i> mod <i>n</i>, where <i>x</i> is the data to be signed and <i>y</i> is the signature. Verification uses the public key <i>e</i> to confirm that <i>y</i><i><sup>e</sup></i> mod <i>n</i> equals <i>x</i>—a process that’s clearly simpler than that of ECDSA.</p>&#13;
<p class="TX">RSA’s verification process is often faster than ECC’s signature verification because it uses a small public key <i>e</i>. Verification of an RSA signature then consists only in an exponentiation <i>y</i><sup>65,537</sup> mod <i>n.</i></p>&#13;
<p class="TX">ECC has two major advantages over RSA: shorter signatures and signing speed. Because ECC works with shorter numbers, it produces shorter signatures than RSA (hundreds of bits long, not thousands of bits), which is an obvious benefit if you have to store or transmit numerous signatures. Signing with ECDSA is also faster than signing with RSA because ECDSA’s arithmetic with much smaller numbers is computationally cheaper. For example, <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a> shows that ECDSA is about 200 times faster at signing and about as fast as RSA at verifying (benchmarks on an Apple M2 processor). Note that in this example, ECDSA signatures are also shorter than RSA signatures because they’re 512 bits (two elements of 256 bits each) rather than 4,096 bits.</p>&#13;
<span id="Lis12-2"/><pre><code>$ <b>openssl speed ecdsap256 rsa4096</b>&#13;
                              sign     verify     sign/s     verify/s&#13;
rsa 4096 bits            0.003297s  0.000048s      303.3      20933.4&#13;
                              sign     verify     sign/s     verify/s&#13;
256 bit ecdsa (nistp256)   0.0000s    0.0000s    63709.1      20979.8</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Comparing the speed of 4,096-bit RSA signatures with 256-bit ECDSA signatures</samp></p>&#13;
<p class="TX">It’s fair to compare the performance of these differently sized signatures because they provide a similar security level. However, in practice, many systems use RSA signatures with 2,048 bits, which is orders of magnitude less secure than 256-bit ECDSA. Thanks to its smaller modulus size, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>2,048-bit RSA is faster than 256-bit ECDSA at verifying, yet still slower at signing, as <a href="chapter12.xhtml#Lis12-3">Listing 12-3</a> shows.</p>&#13;
<span id="Lis12-3"/><pre><code>$ <b>openssl speed rsa2048</b>&#13;
                              sign     verify     sign/s     verify/s&#13;
rsa 2048 bits            0.000520s  0.000013s     1923.7      77221.1</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: The speed of 2,048-bit RSA signatures</samp></p>&#13;
<p class="TX">You should prefer ECDSA to RSA except when signature verification is critical <i>and</i> you don’t care about signing speed, as in a sign-once, verify-many situation (for example, when a Windows executable application is signed once and then verified by all the systems executing it).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-152"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">EdDSA and Ed25519</samp></h4>&#13;
<p class="TNI">ECDSA was introduced in the early 1990s as an elliptic curve version of DSA, the digital signature standard from the NSA standardized by NIST in 1991. But in 1989, cryptographer Claus-Peter Schnorr proposed the so-called Schnorr signature scheme, an algorithm simpler and more efficient than (EC)DSA and also suitable for elliptic curves. However, Schnorr filed a patent restricting the use of his signature scheme, preventing wide adoption and standardization.</p>&#13;
<p class="TX">After Schnorr’s patent expired in 2008, cryptographers Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang built atop Schnorr’s idea to create <i>Edwards-curve DSA (EdDSA)</i>, a signature suitable only for elliptic curves, with the following advantages:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Simpler than ECDSA</li>&#13;
<li class="BL">Faster than ECDSA, both signing and verification</li>&#13;
<li class="BL">Deterministic (whereas the ECDSA and Schnorr signatures used a random number for signing), eliminating the risks related to flawed randomness</li>&#13;
</ul>&#13;
<p class="TX">Let’s see how the general EdDSA works and what makes its specific instance of Ed25519 so appealing. To keep it simple, I’ll provide a simplified overview of these schemes. For the full details and rationale behind these schemes, see the 2011 paper “High-Speed High-Security Signatures” and RFC 8032, “Edwards-Curve Digital Signature Algorithm (EdDSA).”</p>&#13;
<p class="TX">Note that I use notations similar to those in the original article, which may differ from notations previously used in this book.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Signature</samp></h5>&#13;
<p class="TNI">Like any signature scheme, signing with EdDSA requires a private key and a message, but unlike with ECDSA, the private key is a random byte string rather than a random (scalar) number. You derive the actual private scalar by hashing the private key string. This has several security benefits, including making it easier for applications to pick a random key by just dumping raw bytes from a PRNG, rather than ensuring that the key has the right <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>format and isn’t weak. It also helps to efficiently derive a nonce from the key and the message, which replaces the use of a per-signature random value like in ECDSA.</p>&#13;
<p class="TX">Signing then works as follows, from a 256-bit private key <i>k</i> and a message <i>M</i> of arbitrary size, and given a base point <i>B</i>:</p>&#13;
<p class="NLF">  1.  Compute <i>a</i> || <i>h</i> = <b>Hash</b>(<i>k</i>), for a hash function producing 512-bit values, where the first 256 bits form the private scalar <i>a</i> and the last 256 bits form the string <i>h</i>.</p>&#13;
<p class="NL">  2.  Define the public key as <i>A</i> = <i>aB</i> (in practice, this is precomputed).</p>&#13;
<p class="NL">  3.  Compute the message’s “pre-hash” <i>r</i> = <b>Hash</b>(<i>h</i> || <i>M</i>) and compute the elliptic curve point <i>R</i> = <i>rB</i>, which is the first part of the signature, the <i>signature point</i>.</p>&#13;
<p class="NLL">  4.  Compute the number <i>S</i> = <i>r</i> + <b>Hash</b>(<i>R</i>, <i>A</i>, <i>M</i>) × <i>a</i>, the second part of the signature.</p>&#13;
<p class="TNI">The signature returned is the pair (<i>R</i>, <i>S</i>).</p>&#13;
<p class="TX">The computation bottleneck is thus the scalar-point multiplication <i>rB</i>, for a fixed base point <i>B</i>. When messages are long, the cost of hashing the message twice may be significant too. However, unlike in ECDSA, you don’t have to compute a modular inverse.</p>&#13;
<p class="TX">In practice, you can optimize implementations—for example, to avoid recomputing the public key for every signature. You must also set values to the right type (such as numbers subject to modular reduction) and encode them in a reliable and nonambiguous format (like curve points).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">EdDSA Verification</samp></h5>&#13;
<p class="TNI">Given a signature (<i>R</i>, <i>S</i>), a message <i>M</i>, a public key <i>A</i>, and a base point <i>B</i>, verification consists of checking that <i>SB</i> equals <i>R</i> + <b>Hash</b>(<i>R</i>, <i>A</i>, <i>M</i>)<i>A</i>. Note that <i>SB</i> = <i>S</i> × <i>B.</i></p>&#13;
<p class="TX">If you replace <i>S</i> by its expression evaluated in step 4, <i>SB</i> is equal to the following values:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg245-1.jpg" alt="" width="1388" height="48"/></figure>&#13;
<p class="TX">In this expression, you know that <i>rB</i> = <i>R</i> and <i>aB</i> = <i>A</i>. You thus end up with the expected result, <i>R</i> + <b>Hash</b>(<i>R</i>, <i>A</i>, <i>M</i>) × <i>A</i>.</p>&#13;
<p class="TX">Compared to ECDSA, you avoid the computation of a modular inverse. Like ECDSA, you need two scalar-point multiplications (<i>SB</i> and <b>Hash</b>(<i>R</i>, <i>A</i>, <i>M</i>)<i>A</i>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h5 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ed25519</samp></h5>&#13;
<p class="TNI">Ed25519 is a specific instance of EdDSA with the following parameters:</p>&#13;
<ul class="ul">&#13;
<li class="BL">A <i>twisted Edwards curve</i> based on Curve25519, which you’ll see in the next section</li>&#13;
<li class="BL">SHA-512 as a hash function</li>&#13;
<li class="BL">A based point <i>B</i> chosen to optimize efficiency</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/>As of 2023, Ed25519 is likely the second most popular elliptic curve signature algorithm due to its performance benefits and high security guarantees (see <i><a href="https://ed25519.cr.yp.to">https://<wbr/>ed25519<wbr/>.cr<wbr/>.yp<wbr/>.to</a></i>).</p>&#13;
<p class="TX">OpenSSH, Apple products, and many blockchain platforms use Ed25519 to sign transactions. In February 2023, Ed25519 was added as a NIST standard, as part of FIPS 186-5, “Digital Signature Standard.”</p>&#13;
<p class="TX">Ed25519 has suffered from some interoperability issues, as you’ll see later in this chapter.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H1" id="sec19"><span id="h1-86"/><samp class="SANS_Futura_Std_Bold_B_11">Encrypting with Elliptic Curves</samp></h3>&#13;
<p class="TNI">Although you will typically use elliptic curves for signing, you can encrypt with them. But you’ll rarely see people do so in practice because of restrictions on the size of the plaintext that can be encrypted: you can fit about 100 bits of plaintext, as compared to almost 4,000 in RSA with the same security level.</p>&#13;
<p class="TX">You can encrypt with elliptic curves with the <i>elliptic curve integrated encryption scheme (ECIES)</i>, a <i>hybrid</i> scheme combining asymmetric and symmetric cryptography. It uses a Diffie–Hellman operation to derive a shared secret key, which protects data with an authenticated cipher.</p>&#13;
<p class="TX">Given a recipient’s public key <i>P</i>, ECIES encrypts a message <i>M</i>, as follows:</p>&#13;
<p class="NLF">  1.  Pick a random number, <i>d</i>, and compute the point <i>Q</i> = <i>dG</i>, where the base point <i>G</i> is a fixed parameter. Here, (<i>d</i>, <i>Q</i>) acts as an ephemeral key pair, used only for encrypting <i>M</i>.</p>&#13;
<p class="NL">  2.  Compute an ECDH shared secret by computing <i>S</i> = <i>dP</i>.</p>&#13;
<p class="NL">  3.  Use a key derivation function (KDF) to derive a symmetric key, <i>K</i>, from <i>S</i>.</p>&#13;
<p class="NLL">  4.  Encrypt <i>M</i> using <i>K</i> and a symmetric authenticated cipher, obtaining a ciphertext, <i>C</i>, and an authentication tag, <i>T</i>.</p>&#13;
<p class="TX">The ECIES ciphertext then consists of the ephemeral public key <i>Q</i> followed by <i>C</i> and <i>T</i>. Decryption is straightforward: the recipient computes <i>S</i> by multiplying <i>Q</i> with their private exponent, then derives the key <i>K</i>, decrypts <i>C</i>, and verifies <i>T</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H1" id="sec20"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">Choosing a Curve</samp></h3>&#13;
<p class="TNI">Criteria to assess the safety of an elliptic curve include the order of the group you use (that is, its number of points), its addition formulas, and the origin of its parameters.</p>&#13;
<p class="TX">There are several types of elliptic curves, but not all are equal for cryptographic purposes. Choose coefficients <i>a</i> and <i>b</i> in the curve’s equation <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + <i>ax</i> + <i>b</i> carefully, according to established security criteria; <span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>otherwise, you may end up with an insecure curve. In practice, you’ll use an established curve for encryption, but knowing what makes a safe curve will help you choose among the several available ones and better understand any associated risks. Here are some points to keep in mind:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The order of the group shouldn’t be a product of small numbers; otherwise, solving ECDLP becomes much easier.</li>&#13;
<li class="BL">In “<span class="listbullet_Xref">The Addition Law</span>” on <span class="listbullet_Xref"><a href="#sec3">page 235</a></span>, you learned that adding points <i>P</i> + <i>Q</i> required a specific addition formula when <i>Q</i> = <i>P</i>. Unfortunately, treating this case differently from the general one may leak critical information if an attacker can distinguish doublings from additions between distinct points. Some curves are secure <i>because</i> they use a single formula for all point addition. (When a curve doesn’t require a specific formula for doublings, it admits a <i>unified</i> addition law.)</li>&#13;
<li class="BL">If the creators of a curve don’t explain the origin of <i>a</i> and <i>b</i>, they may be suspected of foul play because you can’t know whether they’ve chosen weaker values that enable some yet-unknown attack on the cryptosystem.</li>&#13;
</ul>&#13;
<p class="TX">Let’s review some of the most common curves, especially ones used for signatures or Diffie–Hellman key agreement.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You’ll find more criteria and details about curves on</i> <span class="note_LinkURL_Italic"><a href="https://safecurves.cr.yp.to">https://<wbr/>safecurves<wbr/>.cr<wbr/>.yp<wbr/>.to</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-153"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NIST Curves</samp></h4>&#13;
<p class="TNI">In 2000, NIST standardized several curves in the FIPS 186 document under “Recommended Elliptic Curves for Federal Government Use.” Five NIST curves, called <i>prime curves</i>, work modulo a prime number (see “<span class="Xref">Elliptic Curves over Integers</span>” on <span class="Xref"><a href="#sec2">page 233</a></span>). Ten other NIST curves work with binary polynomials, mathematical objects that make implementation in hardware more efficient. (I won’t cover binary polynomials in further detail because they’re seldom used with elliptic curves.)</p>&#13;
<p class="TX">The most common NIST curves are the prime curves. Of these, one of the most common is P-256, a curve that works over numbers modulo the 256-bit number <i>p</i> = 2<sup>256</sup> – 2<sup>224</sup> + 2<sup>192</sup> + 2<sup>96</sup> – 1. The equation for P-256 is <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> – 3<i>x</i> + <i>b</i>, where <i>b</i> is a 256-bit number. NIST also provides prime curves of 192 bits, 224 bits, 384 bits, and 521 bits (this isn’t a typo; it’s 521, not 512).</p>&#13;
<p class="TX">NIST curves are sometimes criticized because only the NSA, creator of the curves, knows the origin of the <i>b</i> coefficient in their equations. The explanation they’ve provided is that <i>b</i> results from hashing a random-looking constant with SHA-1. For example, P-256’s <i>b</i> parameter comes from the following constant: <samp class="SANS_TheSansMonoCd_W5Regular_11">c49d3608 86e70493 6a6678e1 139d26b7 819f7e90</samp>. No one knows why the NSA picked this particular constant, but most experts don’t believe the curve’s origin hides any weakness.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>&#13;
<h4 class="H2" id="sec22"><span id="h2-154"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Curve25519</samp></h4>&#13;
<p class="TNI">Daniel J. Bernstein brought Curve25519 (usually pronounced <i>curve-twenty-five-five-nineteen</i>) to the world in 2006. Motivated by performance, he designed Curve25519 to be faster and use shorter keys than the standard curves. But Curve25519 also brings security benefits; unlike the NIST curves, it has no suspicious constants and can use the same unified formula for adding distinct points or for doubling a point.</p>&#13;
<p class="TX">The form of Curve25519’s equation, <i>y</i><sup>2</sup> = <i>x</i><sup>3</sup> + 486662<i>x</i><sup>2</sup> + <i>x</i>, is slightly different from the other equations in this chapter, but it still belongs to the elliptic curve family. The unusual form of this equation allows for specific implementation techniques that make Curve25519 fast in software.</p>&#13;
<p class="TX">Curve25519 works with numbers modulo 2<sup>255</sup> – 19, a prime number that’s as close as possible to 2<sup>255</sup>. The <i>b</i> coefficient 486662 is the smallest integer that satisfies the security criteria set by Bernstein. Taken together, these features make Curve25519 more trustworthy than NIST curves and their fishy coefficients.</p>&#13;
<p class="TX">Curve25519 is used everywhere—for example, in WhatsApp, TLS 1.3, OpenSSH, and many other systems. Following this success, Curve25519 was added to the list of NIST-approved curves in February 2023, as part of the document SP 800-186, “Recommendations for Discrete Logarithm-based Cryptography: Elliptic Curve Domain Parameters.”</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For the details and rationale behind Curve25519, view the 2016 presentation “The First 10 Years of Curve25519” by Daniel J. Bernstein at</i> <span class="note_LinkURL_Italic"><a href="https://cr.yp.to/talks.html#2016.03.09">https://<wbr/>cr<wbr/>.yp<wbr/>.to<wbr/>/talks<wbr/>.html#2016<wbr/>.03<wbr/>.09</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-155"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Curves</samp></h4>&#13;
<p class="TNI">As I write this, most cryptographic applications use NIST curves or Curve25519 (including via Ed25519), but there are other legacy standards in use, and newer curves are being promoted and pushed within standardization committees. Old national standards include France’s ANSSI curves and Germany’s Brainpool curves: two families that don’t support complete addition formulas and that use constants of unknown origins.</p>&#13;
<p class="TX">Some newer curves are more efficient than the older ones and are clear of any suspicion; they offer different security levels and various efficiency optimizations. Examples include Curve41417, a variant of Curve25519, which works with larger numbers and offers a higher level of security (approximately 200 bits); Ed448-Goldilocks, a 448-bit curve first proposed in 2014 and specified in RFC 8032; and six curves proposed by Diego Aranha et al. in “A Note on High-Security General-Purpose Elliptic Curves” (see <i><a href="https://eprint.iacr.org/2013/647">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2013<wbr/>/647</a></i>), though these curves are rarely used. The details specific to these curves are beyond the scope of this book.</p>&#13;
<p class="TX">Finally, the Ristretto initiative (<i><a href="https://ristretto.group">https://<wbr/>ristretto<wbr/>.group</a></i>) is a technique for constructing prime-order point groups from elliptic curves with non-prime order (and therefore having subgroups). Ristretto offers a safe and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>unambiguous way to represent points on an elliptic curve, eliminating risks linked to the structure of Curve25519, for example.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H1" id="sec24"><span id="h1-88"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">A downside of elliptic curves is their relative complexity. The greater number of parameters than for RSA or classic Diffie–Hellman leaves a larger attack surface and more possibilities for design errors and implementation bugs. ECC implementations can also be vulnerable to side-channel attacks, especially their big-number arithmetic—for example, when the calculation time depends on secret values.</p>&#13;
<p class="TX">In the following sections, I discuss three examples of vulnerabilities that can occur with elliptic curves, even when the implementation is safe.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-156"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ECDSA with Bad Randomness</samp></h4>&#13;
<p class="TNI">ECDSA signing is randomized, as it involves a secret random number <i>k</i> when setting <i>s</i> = (<i>h</i> + <i>rd</i>) / <i>k</i> mod <i>n</i>. However, if you reuse the same <i>k</i> to sign a second message, an attacker could combine the resulting values, <i>s</i><sub>1</sub> = (<i>h</i><sub>1</sub> + <i>rd</i>) / <i>k</i> and <i>s</i><sub>2</sub> = (<i>h</i><sub>2</sub> + <i>rd</i>) / <i>k</i>, to get <i>s</i><sub>1</sub> – <i>s</i><sub>2</sub> = (<i>h</i><sub>1</sub> – <i>h</i><sub>2</sub>) / <i>k</i> and then <i>k</i> = (<i>h</i><sub>1</sub> – <i>h</i><sub>2</sub>) / (<i>s</i><sub>1</sub> – <i>s</i><sub>2</sub>). When you know <i>k</i>, you can easily recover the private key <i>d</i> by computing the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg249-1.jpg" alt="" width="1390" height="56"/></figure>&#13;
<p class="TX">Unlike RSA signatures, which won’t allow the key to be recovered if using a weak PRNG, the use of nonrandom numbers can lead to ECDSA’s <i>k</i> being recoverable, as happened with the attack on the PlayStation 3 game console in 2010, presented by the fail0verflow team at the 27th Chaos Communication Congress in Berlin, Germany. They discovered that the same <i>k</i> was reused to sign different games and were then able to find the signing key, which made it possible to sign any program to authorize it to run on the console.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-157"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Invalid Curve Attacks</samp></h4>&#13;
<p class="TNI">You can elegantly break ECDH if input points are not properly validated. The primary reason is that the formulas that give the coordinates for the sum of points <i>P</i> + <i>Q</i> never involve the <i>b</i> coefficient of the curve; instead, they rely only on the coordinates of <i>P</i> and <i>Q</i> and the <i>a</i> coefficient (when doubling a point). The unfortunate consequence is that when adding two points, you can’t be sure you’re working on the right curve because you may actually be adding points on a different curve with a different <i>b</i> coefficient. That means you can break ECDH, as the following scenario, the <i>invalid curve attack</i>, describes.</p>&#13;
<p class="TX">Say that Alice and Bob are running ECDH and agreed on a curve and a base point, <i>G</i>. Bob sends his public key <i>bG</i> to Alice. Alice, instead of sending a public key <i>aG</i> on the agreed upon curve, sends a point on a different curve, either intentionally or accidentally. Unfortunately, this new curve is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>weak and allows Alice to choose a point <i>P</i> for which solving ECDLP is easy. She chooses a point of low order, for which there’s a relatively small <i>k</i> such that <i>kP</i> = <i>O</i>.</p>&#13;
<p class="TX">Bob, believing that he has a legitimate public key, computes what he thinks is the shared secret <i>bP</i>, hashes it, and uses the resulting key to encrypt data sent to Alice. When Bob computes <i>bP</i>, he’s unknowingly computing on the weaker curve. As a result, because <i>P</i> was chosen to belong to a small subgroup within the larger group of points, the result <i>bP</i> also belongs to that small subgroup, allowing an attacker to determine the shared secret <i>bP</i> efficiently if they know the order of <i>P</i>.</p>&#13;
<p class="TX">One way to prevent this is to confirm points <i>P</i> and <i>Q</i> belong to the right curve by ensuring their coordinates satisfy the curve’s equation. This ensures you’re able to work on only the secure curve.</p>&#13;
<p class="TX">Such an invalid curve attack was found in 2015 on certain implementations of the TLS protocol, which uses ECDH to negotiate session keys. (For details, see the paper “Practical Invalid Curve Attacks on TLS-ECDH” by Tibor Jager, J<span class="accent">ö</span>rg Schwenk, and Juraj Somorovsky.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h4 class="H2" id="sec27"><span id="h2-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incompatible Ed25519 Validation Rules</samp></h4>&#13;
<p class="TNI">You saw that Ed25519 is a signature scheme optimized to offer both efficiency and high security guarantees. The designers of Ed25519 described how it works in detail in a scientific paper and published a well-coded reference implementation. The algorithm was specified as an IETF standard in RFC 8032. One would expect there to be only one version of Ed25519 and different implementations to work in exactly the same way: for a given input value, they should all behave identically and return the same result.</p>&#13;
<p class="TX">Unfortunately, this is not the case. As cryptographer Henry de Valence documented in the article “It’s 255:19AM. Do You Know What Your Validation Criteria Are?” (see <i><a href="https://hdevalence.ca/blog/2020-10-04-its-25519am">https://<wbr/>hdevalence<wbr/>.ca<wbr/>/blog<wbr/>/2020<wbr/>-10<wbr/>-04<wbr/>-its<wbr/>-25519am</a></i>), different implementations of Ed25519 have different criteria for what constitutes a valid signature. Indeed, RFC 8032 doesn’t fully describe the validation criteria—and many implementations don’t even comply with it.</p>&#13;
<p class="TX">Of the 15 implementations in de Valence’s article, each had its own validation criteria. In particular, the validation of points <i>R</i> (of the signature) and <i>A</i> (the public key) is often different, as is the verification of the equality between <i>S</i> × <i>B</i> and <i>R</i> + <b>Hash</b>(<i>R</i>, <i>A</i>, <i>M</i>) × <i>A</i>. Divergences can occur at several levels, including the encoding of points (how you assemble bytes to describe their coordinates) and the validation that points belong to the right subgroup.</p>&#13;
<p class="TX">As a result, different implementations of the same scheme could behave differently—for example, in a blockchain network where signatures would be accepted by some nodes but rejected by others, a problem for a consensus protocol. All details are explained in de Valence’s blog post.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>&#13;
<h3 class="H1" id="sec28"><span id="h1-89"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">Elliptic curve cryptography is a fascinating, complex topic that involves lots of mathematics. I haven’t discussed important notions such as a point’s order, a curve’s cofactor, projective coordinates, torsion points, and methods for solving the ECDLP problem. If you’re mathematically inclined, you’ll find information on these and other related topics in the <i>Handbook of Elliptic and Hyperelliptic Curve Cryptography</i> by Henri Cohen and Gerhard Frey (Chapman and Hall/CRC, 2005). The 2013 survey “Elliptic Curve Cryptography in Practice” by Joppe Bos, Alex Halderman, Nadia Heninger, Jonathan Moore, Michael Naehrig, and Eric Wustrow also gives an illustrated introduction with practical examples (<i><a href="https://eprint.iacr.org/2013/734">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2013<wbr/>/734</a></i>).</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>