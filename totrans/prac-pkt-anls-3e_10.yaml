- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**BASIC REAL-WORLD SCENARIOS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础现实世界场景**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Beginning with this chapter, we’ll dig into the meat of packet analysis as we
    use Wireshark to analyze real-world network problems. I’ll introduce a series
    of problem scenarios by describing the context of the problem and providing the
    information that was available to the analyst at the time. Having laid the groundwork,
    we’ll turn to analysis as I describe the method used to capture the appropriate
    packets and step you through the process of working toward a diagnosis. Once analysis
    is complete, I’ll point toward potential solutions and give an overview of the
    lessons learned.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章开始，我们将深入数据包分析的核心内容，使用Wireshark分析现实世界中的网络问题。我将通过描述问题的背景并提供分析师当时获得的信息来介绍一系列问题场景。在打下基础后，我们将转向分析部分，我会描述用于捕获适当数据包的方法，并引导你一步步向诊断迈进。一旦分析完成，我将指出潜在的解决方案并概述学到的经验教训。
- en: Throughout, remember that analysis is a very dynamic process. Thus, the methods
    I use to analyze each scenario may not be the same ones that you would use. Everyone
    approaches problem solving and reasoning through their own lens. The most important
    thing is that the result of the analysis solves a problem, but even when it doesn’t,
    it’s critical to learn from failures as well. Experience is the thing we get when
    we don’t get what we want, after all.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，请记住，分析是一个非常动态的过程。因此，我用来分析每个场景的方法可能和你使用的方法不同。每个人通过自己的视角来解决问题和推理。最重要的是，分析的结果能解决问题，即使没有解决问题，从失败中学习也是至关重要的。毕竟，经验是我们在没有得到想要的结果时获得的。
- en: In addition, most problems discussed in this chapter can probably be solved
    with methods that don’t necessarily involve a packet sniffer, but what’s the fun
    in that? When I was first learning how to analyze packets, I found it helpful
    to examine typical problems in atypical ways by using packet analysis techniques,
    which is why I present these scenarios to you.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章讨论的大多数问题可能通过不一定需要使用数据包嗅探器的方法来解决，但那样有什么趣味呢？当我第一次学习如何分析数据包时，我发现通过使用数据包分析技巧以不寻常的方式分析典型问题很有帮助，这也是我向你们展示这些场景的原因。
- en: '**Missing Web Content**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**缺失的网页内容**'
- en: '*http_espn_fail.pcapng*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_espn_fail.pcapng*'
- en: In the first scenario we’ll look at, our user is Packet Pete, a college basketball
    fan who doesn’t keep late hours and usually misses the West Coast games. The first
    thing he does when he sits down at his workstation every morning is visit *[http://www.espn.com/](http://www.espn.com/)*
    for the previous night’s final scores. When Pete browses to ESPN this morning,
    he finds that the page is taking a long time to load, and when it finally does,
    most of the images and content are missing ([Figure 10-1](ch10.xhtml#ch10fig1)).
    Let’s help Pete diagnose this issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们要查看的第一个场景中，我们的用户是数据包皮特，他是一个大学篮球迷，不熬夜，通常错过西海岸的比赛。每当他早上坐到工作站时，他首先做的事就是访问*[http://www.espn.com/](http://www.espn.com/)*查看前一晚的比赛最终得分。当皮特今天早上浏览ESPN时，他发现页面加载非常缓慢，最终加载完成时，大部分图片和内容都缺失了（[图10-1](ch10.xhtml#ch10fig1)）。让我们帮皮特诊断这个问题。
- en: '![image](../images/f200-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f200-01.jpg)'
- en: '*Figure 10-1: ESPN is failing to load properly.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：ESPN加载不正常*'
- en: '***Tapping into the Wire***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接到线路***'
- en: This issue is isolated to Pete’s workstation and is not affecting any others,
    so we’ll start by capturing packets directly from there. To do this, we’ll install
    Wireshark and capture packets while browsing to the ESPN website. Those packets
    are found in the file *http_espn_fail.pcapng*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题仅限于皮特的工作站，并没有影响到其他工作站，所以我们将从皮特的工作站直接捕获数据包来开始。为此，我们将安装Wireshark并在浏览ESPN网站时捕获数据包。这些数据包存储在文件*http_espn_fail.pcapng*中。
- en: '***Analysis***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: We know Pete’s issue is that he’s unable to view a website he is browsing to,
    so we’re primarily going to be looking at the HTTP protocol. If you read the previous
    chapter, you should have a basic understanding of what HTTP traffic between a
    client and server looks like. A good place to start looking is at the HTTP requests
    being made to the remote server. You can do this by applying a filter for `GET`
    requests (using http.request.method == "GET"), but this can also be done by simply
    selecting **Statistics** ▶ **HTTP** ▶ **Requests** from the main drop-down menu
    ([Figure 10-2](ch10.xhtml#ch10fig2)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Pete的问题是他无法查看他正在浏览的网站，因此我们主要会查看HTTP协议。如果你阅读了上一章，你应该对客户端和服务器之间的HTTP流量有一个基本的了解。一个好的起点是查看向远程服务器发出的HTTP请求。你可以通过应用`GET`请求的过滤器（使用http.request.method
    == "GET"）来做到这一点，但也可以通过从主下拉菜单中选择**统计信息** ▶ **HTTP** ▶ **请求**来实现这一点（[图10-2](ch10.xhtml#ch10fig2)）。
- en: '![image](../images/f201-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f201-01.jpg)'
- en: '*Figure 10-2: Viewing HTTP requests to ESPN*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：查看向ESPN发送的HTTP请求*'
- en: From this overview, it appears the capture is limited to seven different HTTP
    requests, and they all look like they are associated with the ESPN website. Each
    request contains the string `espn` within the domain name, with the exception
    of *[cdn.optimizely.com](http://cdn.optimizely.com)*, which is a *content delivery
    network* (CDN) used to deliver advertising to a multitude of sites. It’s common
    to see requests to various CDNs when browsing to websites that host advertisements
    or other external content.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个概述中看，捕获内容似乎仅限于七个不同的HTTP请求，而且它们看起来都与ESPN网站相关。每个请求的域名中都包含`espn`这个字符串，唯一例外的是
    *[cdn.optimizely.com](http://cdn.optimizely.com)*，它是一个*内容分发网络*(CDN)，用于向多个网站投放广告。浏览到托管广告或其他外部内容的网站时，看到对各种CDN的请求是很常见的。
- en: With no clear leads to follow, the next step is to look at the protocol hierarchy
    of the capture file by selecting **Statistics** ▶ **Protocol Hierarchy**. This
    will allow us to spot unexpected protocols or peculiar distributions of traffic
    per protocol ([Figure 10-3](ch10.xhtml#ch10fig3)). Keep in mind that the protocol
    hierarchy screen is based on the currently applied display filter. Be sure to
    clear the previously applied filter to get the expected results based on the entire
    packet capture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有明确的线索可供追踪，下一步是通过选择**统计信息** ▶ **协议层级**来查看捕获文件的协议层级。这将帮助我们发现意外的协议或每种协议的流量分布情况（[图10-3](ch10.xhtml#ch10fig3)）。请记住，协议层级屏幕基于当前应用的显示过滤器。请确保清除先前应用的过滤器，以便基于整个数据包捕获获得预期结果。
- en: '![image](../images/f202-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f202-01.jpg)'
- en: '*Figure 10-3: Reviewing the protocol hierarchy of the browsing session*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：查看浏览会话的协议层级*'
- en: 'The protocol hierarchy isn’t too complex, and we can quickly decipher that
    there are only two application-layer protocols at work: HTTP and DNS. As you learned
    in [Chapter 9](ch09.xhtml#ch09), DNS is used to translate domain names to IP addresses.
    So, when you browse to a site like *[http://www.espn.com/](http://www.espn.com/)*,
    your system may need to send out a DNS query to find the IP address of the remote
    web server if it doesn’t already know it. Once a DNS reply with the appropriate
    IP address comes back, that information can be added to a local cache, and HTTP
    communication (using TCP) can commence.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协议层级并不复杂，我们可以迅速解读出只有两个应用层协议在工作：HTTP 和 DNS。正如你在[第9章](ch09.xhtml#ch09)中所学，DNS用于将域名转换为IP地址。因此，当你浏览像
    *[http://www.espn.com/](http://www.espn.com/)* 这样的网站时，如果系统尚未知道远程服务器的IP地址，可能需要发送DNS查询来查找该IP地址。一旦收到包含适当IP地址的DNS回复，该信息可以被添加到本地缓存中，然后可以开始进行HTTP通信（使用TCP）。
- en: Although nothing looks out of the ordinary here, the 14 DNS packets are notable.
    A DNS request for a single domain name is typically contained in a single packet,
    and the response also constitutes a single packet (unless it’s very large, in
    which case DNS will utilize TCP). Since there are 14 DNS packets here, it’s possible
    that as many as seven DNS queries were generated (7 queries + 7 replies = 14 packets).
    [Figure 10-2](ch10.xhtml#ch10fig2) did show HTTP requests to seven different domains,
    but Pete only typed a single URL into his browser. Why are all of these extra
    requests being made?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里看起来并没有什么异常，但14个DNS数据包是值得注意的。一个域名的DNS请求通常会包含在一个数据包中，响应也会构成一个数据包（除非数据包非常大，在这种情况下DNS会使用TCP）。由于这里有14个DNS数据包，可能生成了多达七个DNS查询（7个查询
    + 7个回复 = 14个数据包）。[图10-2](ch10.xhtml#ch10fig2)确实显示了对七个不同域名的HTTP请求，但Pete在浏览器中只输入了一个URL。为什么会发出这么多额外的请求呢？
- en: In a simple world, visiting a web page would be as easy as querying one server
    and pulling all of its content in a single HTTP conversation. In reality, an individual
    web page may provide content hosted on multiple servers. All of the text-based
    content could be in one place, the graphics could be in another, and embedded
    videos could be in a third. That doesn’t include ads, which could be hosted on
    multiple providers spanning dozens of individual servers. Whenever an HTTP client
    parses HTML code and finds a reference to content on another host, it will attempt
    to query that host for the content, which can generate additional DNS queries
    and HTTP requests. This is exactly what happened here when Pete visited ESPN.
    While he may have intended to view content only from a single source, references
    to additional content were found in the HTML code, and his browser automatically
    requested that content from multiple other domains.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的世界里，访问一个网页可能就像查询一个服务器并通过一次HTTP对话拉取所有内容一样简单。实际上，单个网页可能会提供托管在多个服务器上的内容。所有基于文本的内容可能在一个地方，图形可能在另一个地方，嵌入的视频可能在第三个地方。除此之外，还有广告，这些广告可能由多个提供商托管，跨越数十个独立的服务器。每当HTTP客户端解析HTML代码并找到引用其他主机内容的链接时，它会尝试查询该主机以获取内容，这就可能生成额外的DNS查询和HTTP请求。这正是Pete访问ESPN时发生的情况。尽管他可能只打算查看来自单一来源的内容，但在HTML代码中找到了对其他内容的引用，他的浏览器自动向多个不同的域名请求这些内容。
- en: Now that we understand why all of these extra requests exist, our next step
    is to examine the individual conversations associated with each request (**Statistics
    ▶ Conversations**). Reviewing the Conversations window ([Figure 10-4](ch10.xhtml#ch10fig4))
    provides an important clue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了所有这些额外请求的存在原因，接下来的步骤是检查与每个请求相关的个别对话（**统计 ▶ 对话**）。查看对话窗口（[图10-4](ch10.xhtml#ch10fig4)）提供了一个重要线索。
- en: '![image](../images/f203-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-01.jpg)'
- en: '*Figure 10-4: Reviewing IP conversations*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：审查IP对话*'
- en: We discovered earlier that there were seven DNS requests and seven HTTP requests
    to match. With that in mind, it would be reasonable to expect that there would
    also be seven matching IP conversations, but that isn’t the case. There are eight.
    How can that be explained?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前发现有七个DNS请求和七个HTTP请求相匹配。考虑到这一点，合理的预期是会有七个匹配的IP对话，但事实并非如此。实际上有八个。那该如何解释呢？
- en: 'One thought might be that the capture was “contaminated” by an additional conversation
    unrelated to the problem at hand. Ensuring your analysis doesn’t suffer due to
    irrelevant traffic is certainly something you should be cognizant of, but that
    isn’t the issue with this conversation. If you examine each HTTP request and note
    the IP address the request was sent to, you should be left with one conversation
    that doesn’t have a matching HTTP request. The endpoints for this conversation
    are Pete’s workstation (172.16.16.154) and the remote IP 203.0.113.94\. This conversation
    is represented by the bottom line in [Figure 10-4](ch10.xhtml#ch10fig4). We note
    that 6,774 bytes were sent to this unknown host but zero bytes were sent back:
    that’s worth digging into.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的想法是，捕获的数据中可能有与当前问题无关的额外对话“污染”了分析结果。确保分析不受无关流量的影响是非常重要的，但这并不是本次对话中的问题。如果你检查每个HTTP请求并记录请求发送的IP地址，你应该会发现有一个对话没有匹配的HTTP请求。这个对话的终端是Pete的工作站（172.16.16.154）和远程IP（203.0.113.94）。这个对话在[图10-4](ch10.xhtml#ch10fig4)的底部表示。我们注意到，6,774字节被发送到这个未知主机，但没有字节被返回：这值得进一步探究。
- en: If you filter down into this conversation (right-click the conversation and
    choose **Apply As Filter ▶ Selected ▶ A<->B**), you can apply your knowledge of
    TCP to identify what’s gone wrong ([Figure 10-5](ch10.xhtml#ch10fig5)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个对话进行过滤（右键点击该对话并选择**应用为过滤器 ▶ 选择 ▶ A<->B**），你可以运用你对TCP的知识来识别出了什么问题（[图10-5](ch10.xhtml#ch10fig5)）。
- en: '![image](../images/f203-02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-02.jpg)'
- en: '*Figure 10-5: Reviewing the unexpected connection*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：回顾意外连接*'
- en: With normal TCP communication, you expect to see a standard SYNSYN/ACK-ACK handshake
    sequence. In this case, Pete’s workstation sent a SYN packet to 203.0.113.94,
    but we never see a SYN/ACK response. Not only this, but Pete’s workstation sent
    multiple SYN packets to no avail, eventually leading his machine to send TCP retransmission
    packets. We’ll talk more about the specifics of TCP retransmissions in [Chapter
    11](ch11.xhtml#ch11), but the key takeaway here is that one host is sending packets
    that it never receives a response to. Looking at the Time column, we see that
    the retransmissions continue for 95 seconds without a response. In network communications,
    this is slower than molasses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的TCP通信中，你会看到标准的SYNSYN/ACK-ACK握手序列。在这种情况下，Pete的工作站向203.0.113.94发送了一个SYN数据包，但我们从未看到SYN/ACK响应。不仅如此，Pete的工作站多次发送SYN数据包也未能成功，最终导致他的计算机发送TCP重传数据包。我们将在[第11章](ch11.xhtml#ch11)中详细讨论TCP重传的具体情况，但这里的关键要点是，一个主机发送了数据包，却没有收到任何响应。从时间列中可以看到，重传持续了95秒而没有得到响应。在网络通信中，这比蜂蜜还慢。
- en: We have identified seven DNS requests, seven HTTP requests, and eight IP conversations.
    Since we know that the capture is not contaminated with extra data, it’s reasonable
    to think that the mysterious eighth IP conversation is probably the source of
    Pete’s slowly and incompletely loading web page. For some reason, Pete’s workstation
    is trying to communicate with a device that either doesn’t exist or just isn’t
    listening. To understand why this is happening, we won’t look at what’s in the
    capture file; instead, we’ll consider what isn’t there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经识别出七个DNS请求、七个HTTP请求和八个IP对话。由于我们知道捕获的数据没有被额外数据污染，因此可以合理推测神秘的第八个IP对话可能是Pete的网页加载缓慢且不完全的原因。由于某种原因，Pete的工作站正在尝试与一个不存在或根本没有响应的设备进行通信。为了理解为什么会发生这种情况，我们不去查看捕获文件中的内容，而是考虑文件中缺失的部分。
- en: When Pete browsed to *[http://www.espn.com/](http://www.espn.com/)*, his browser
    identified resources hosted on other domains. To retrieve that data, his workstation
    generated DNS requests to find their IP addresses, then connected to them via
    TCP so that an HTTP request for the content could be sent. For the conversation
    with 203.0.113.94, there is no DNS request to be found. So, how did Pete’s workstation
    know about that address?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pete浏览到 *[http://www.espn.com/](http://www.espn.com/)* 时，他的浏览器识别出了托管在其他域名上的资源。为了检索这些数据，他的工作站生成了DNS请求来查找它们的IP地址，然后通过TCP连接到这些地址，以便发送HTTP请求获取内容。在与203.0.113.94的对话中，并没有找到DNS请求。那么，Pete的工作站是如何知道这个地址的呢？
- en: If you remember our discussion about DNS in [Chapter 9](ch09.xhtml#ch09) or
    are otherwise familiar with it, you know that most systems implement some form
    of DNS caching. This allows them to reference a local DNS-to-IP address mapping
    that has already been retrieved without having to generate a DNS request every
    time you visit a domain that you frequently communicate with. Eventually, these
    DNS-to-IP mappings expire, and a new request must be generated. However, if a
    DNS-to-IP mapping changes and a device doesn’t generate a DNS request to get the
    new address when visiting the next time, the device will attempt to connect to
    an address that is no longer valid.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们在[第9章](ch09.xhtml#ch09)中讨论的DNS内容，或者你对DNS有一定了解，你就知道大多数系统都实现了某种形式的DNS缓存。这使得它们可以引用已经检索到的本地DNS到IP地址的映射，而无需每次访问一个常用域名时都生成DNS请求。最终，这些DNS到IP的映射会过期，必须生成新的请求。然而，如果DNS到IP的映射发生了变化，而设备在下次访问时没有生成DNS请求来获取新的地址，那么该设备将尝试连接一个已经失效的地址。
- en: In Pete’s case, that is exactly what happened. Pete’s workstation already had
    a cached DNS-to-IP mapping for a domain that hosts content for ESPN. Since this
    cached entry exists, a DNS request was not generated, and his system attempted
    to go ahead and connect to the old address. However, that address was no longer
    configured to respond to requests. As a result, the requests timed out, and the
    content never loaded.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在皮特的情况下，正是发生了这种情况。皮特的工作站已经缓存了一个 DNS 到 IP 的映射，该映射指向托管 ESPN 内容的域名。由于这个缓存条目存在，DNS
    请求没有被生成，他的系统尝试直接连接到旧的地址。然而，那个地址已经不再配置为响应请求。因此，请求超时，内容也没有加载出来。
- en: Fortunately for Pete, clearing his DNS cache manually is possible with a few
    keystrokes on the command line or in a terminal window. Alternatively, he could
    also just try again in a few minutes when the DNS cache entry will probably have
    expired so a new request will be generated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于皮特来说，手动清除 DNS 缓存只需要在命令行或终端窗口中敲几下键就能完成。或者，他也可以等几分钟，等 DNS 缓存条目过期时，再尝试一次，这时会生成一个新的请求。
- en: '***Lessons Learned***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: That’s a lot of work just to find out that Kentucky beat Duke by 90 points,
    but we walk away with a deeper understanding of the relationship between network
    hosts. In this scenario, we were able to work toward a solution by assessing multiple
    data points related to the requests and conversations occurring within the capture.
    From there, we were able to spot a few inconsistencies that took us down a path
    toward finding the failed communication between the client and one of ESPN’s content
    delivery servers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项大工程，目的只是为了知道肯塔基大学以 90 分的优势击败了杜克大学，但我们却从中获得了对网络主机关系更深的理解。在这个场景中，我们通过评估与请求和通信相关的多个数据点，逐步找到了问题的解决办法。通过这些数据点，我们发现了一些不一致之处，进而发现了客户端与
    ESPN 内容分发服务器之间的通信故障。
- en: In the real world, diagnosing problems is rarely as simple as scrolling through
    a list of packets and looking for the ones that look funny. Troubleshooting even
    the simplest problems can result in very large captures that rely on the use of
    Wireshark’s analysis and statistics features to spot anomalies. Getting familiar
    with this style of analysis is critical to successful troubleshooting at the packet
    level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，诊断问题很少像滚动查看数据包列表并寻找看起来奇怪的数据包那么简单。即便是最简单的问题，排除故障也可能导致非常大的抓包文件，这时就需要依赖
    Wireshark 的分析和统计功能来识别异常。熟悉这种分析方式对于在数据包级别上成功排查故障至关重要。
- en: If you’d like to see an example of what normal communication looks like between
    a web browser and ESPN, try browsing to the site while capturing traffic yourself
    and see if you can identify all of the servers responsible for delivering content.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看正常的 web 浏览器与 ESPN 之间的通信示例，试着自己访问该网站并捕获流量，看看你能否识别出所有负责传递内容的服务器。
- en: '**Unresponsive Weather Service**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无响应的天气服务**'
- en: '*weather_broken.pcapng weather_working.pcapng*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*weather_broken.pcapng weather_working.pcapng*'
- en: Our second scenario once again involves our pal Packet Pete. Among his many
    hobbies, Pete fancies himself an amateur meteorologist and doesn’t go more than
    a few hours without checking current conditions and the forecast. He doesn’t rely
    solely on the local news forecast though; he actually runs a small weather station
    outside his home that reports data up to *[https://www.wunderground.com/](https://www.wunderground.com/)*
    for aggregation and viewing. Today, Pete went to check his weather station to
    see how much the temperature had dropped overnight, but found that his station
    hadn’t reported in to Wunderground in over nine hours, since around midnight ([Figure
    10-6](ch10.xhtml#ch10fig6)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个场景再次涉及到我们的朋友数据包皮特。在他众多的爱好中，皮特自认为是一个业余气象学家，几乎每隔几个小时就会检查当前的天气状况和预报。不过，他并不完全依赖当地新闻的天气预报；他实际上在家外面安装了一个小型气象站，将数据报告上传到*
    [https://www.wunderground.com/](https://www.wunderground.com/)*，以便聚合和查看。今天，皮特去检查他的气象站，看看气温一夜之间下降了多少，但发现他的气象站已经超过九个小时没有向
    Wunderground 报告数据了，从大约午夜开始（[图 10-6](ch10.xhtml#ch10fig6)）。
- en: '![image](../images/f205-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f205-01.jpg)'
- en: '*Figure 10-6: The weather station hasn’t sent a report in nine hours.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：气象站已经九小时没有报告数据了。*'
- en: '***Tapping into the Wire***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***深入了解数据线***'
- en: In Pete’s network, the weather station mounted on his roof connects to a receiver
    inside his house through an RF connection. That receiver plugs into his network
    switch and reports statistics to Wunderground through the internet. This architecture
    is diagrammed in [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pete的网络中，安装在他屋顶上的气象站通过RF连接与屋内的接收器相连。接收器连接到他的网络交换机，并通过互联网向Wunderground报告统计数据。这种架构在[图10-7](ch10.xhtml#ch10fig7)中进行了示意。
- en: '![image](../images/f206-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f206-01.jpg)'
- en: '*Figure 10-7: Weather station network architecture*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：气象站网络架构*'
- en: The receiver has a simple web-based management page, but Pete logged into it
    only to find a cryptic message about the last synchronization time with no additional
    guidance for troubleshooting—the software doesn’t provide any detailed error logging.
    Since the receiver is the hub of communication for the weather station infrastructure,
    it makes sense to capture packets transmitted to and from that device to try to
    diagnose the issue. This is a home network, so port mirroring is probably not
    an option on the SOHO switch. Our best bet is to use a cheap tap or to perform
    ARP cache poisoning to intercept these packets. The captured packets are contained
    in the file *weather_broken.pcapng*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器有一个简单的基于网页的管理页面，但Pete登录后只看到一条关于最后一次同步时间的晦涩信息，并没有提供任何额外的故障排除指导——软件没有提供详细的错误日志。由于接收器是气象站基础设施的通信枢纽，捕获传入和传出的数据包来诊断问题是有意义的。这是一个家庭网络，所以在SOHO交换机上可能没有端口镜像功能。我们最好的选择是使用便宜的taps，或者执行ARP缓存中毒来拦截这些数据包。捕获的数据包存储在文件*weather_broken.pcapng*中。
- en: '***Analysis***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: Upon opening the capture file, you’ll see that we’re dealing with HTTP communication
    once again. The packet capture is limited to a single conversation between Pete’s
    local weather receiver 172.16.16.154 and an unknown remote device on the internet,
    38.102.136.125 ([Figure 10-8](ch10.xhtml#ch10fig8)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开捕获文件后，你会发现我们再次处理的是HTTP通信。数据包捕获仅限于Pete本地气象接收器172.16.16.154与互联网中一个未知远程设备38.102.136.125之间的单一对话（见[图10-8](ch10.xhtml#ch10fig8)）。
- en: '![image](../images/f206-02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f206-02.jpg)'
- en: '*Figure 10-8: Isolated weather station receiver communication*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：隔离的气象站接收器通信*'
- en: Before we examine the characteristics of the conversation, let’s see if we can
    identify the unknown IP. Without extensive research, we might not be able to find
    out whether this is the exact IP address that Pete’s weather receiver should be
    talking to, but we can at least verify that it is part of the Wunderground infrastructure
    by doing a WHOIS query. You can conduct a WHOIS query through most domain registration
    or regional internet registry websites, such as *[http://whois.arin.net/](http://whois.arin.net/)*.
    In this case, it looks like the IP belongs to Cogent, an *internet service provider
    (ISP)* ([Figure 10-9](ch10.xhtml#ch10fig9)). PSINet Inc. is also mentioned here,
    but a quick search reveals that most PSINet assets were acquired by Cogent in
    the early 2000s.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查对话的特征之前，先看看能否识别出这个未知IP。在没有广泛研究的情况下，我们可能无法确定这个IP是否是Pete的气象接收器应该连接的确切IP地址，但我们至少可以通过进行WHOIS查询验证它是否属于Wunderground的基础设施。你可以通过大多数域名注册或区域互联网注册网站进行WHOIS查询，例如*[http://whois.arin.net/](http://whois.arin.net/)*。在这种情况下，看起来该IP属于Cogent，一家*互联网服务提供商（ISP）*（见[图10-9](ch10.xhtml#ch10fig9)）。PSINet
    Inc.也在这里提到，但通过快速搜索发现，PSINet的大多数资产在2000年代初被Cogent收购。
- en: '![image](../images/f207-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f207-01.jpg)'
- en: '*Figure 10-9: WHOIS data identifies the owner of this IP.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：WHOIS数据识别了该IP的所有者。*'
- en: In some cases, if an IP address is registered directly to an organization, the
    WHOIS query will return that organization’s name. However, many times a company
    will simply utilize IP address space from an ISP without registering it directly
    to itself. In these cases, another useful tactic is to search for the *autonomous
    system number (ASN)* that is associated with an IP address. Organizations are
    required to register for an ASN to support certain types of routing on the public
    internet. There are a number of ways to look up IP-to-ASN associations (some WHOIS
    lookups provide it automatically), but I like using Team Cymru’s automated lookup
    tool (*[https://asn.cymru.com/](https://asn.cymru.com/)*). Using that tool for
    38.102.136.125, we see that it is associated with AS 36347, which is associated
    with “Wunderground – The Weather Channel, LLC, US” ([Figure 10-10](ch10.xhtml#ch10fig10)).
    That tells us that the device the weather station is communicating with is at
    least in the right neighborhood. If we were unable to identify the correct affiliation
    for this address, it might be worth exploring whether Pete’s receiver was talking
    to the wrong device, but the address checks out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果一个 IP 地址直接注册到某个组织，WHOIS 查询会返回该组织的名称。然而，很多时候公司只是利用互联网服务提供商（ISP）的 IP
    地址空间，而没有将其直接注册到自己名下。在这些情况下，另一个有用的策略是搜索与 IP 地址相关联的 *自治系统号码（ASN）*。组织需要注册 ASN 以支持公共互联网中的某些类型路由。有多种方式可以查找
    IP 到 ASN 的关联（一些 WHOIS 查询会自动提供），但我喜欢使用 Team Cymru 的自动查找工具 (*[https://asn.cymru.com/](https://asn.cymru.com/)*)。通过这个工具查询
    38.102.136.125，我们看到它与 AS 36347 相关联，而 AS 36347 又与“Wunderground – The Weather Channel,
    LLC, US”相关联（[图 10-10](ch10.xhtml#ch10fig10)）。这告诉我们，天气站正在与设备进行通信，至少该设备在正确的网络环境中。如果我们无法识别该地址的正确归属，可能需要探索
    Pete 的接收器是否与错误的设备通信，但该地址是正确的。
- en: '![image](../images/f208-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-01.jpg)'
- en: '*Figure 10-10: IP-to-ASN lookup for the external IP address*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：外部 IP 地址的 IP 到 ASN 查找*'
- en: With the unknown host characterized, we can dig into details of the communication.
    The conversation is relatively short. There is a TCP handshake, a single HTTP
    `GET` request and response, and a TCP teardown. The handshake and teardown appear
    to be successful, so whatever issue we are experiencing is probably contained
    with the HTTP request itself. To examine this closely, we’ll follow the TCP stream
    ([Figure 10-11](ch10.xhtml#ch10fig11)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了未知主机之后，我们可以深入研究通信的细节。整个通信过程相对简短。它包括一次 TCP 握手，一个 `GET` 请求和响应，以及一次 TCP 拆除。握手和拆除看起来是成功的，因此我们遇到的问题很可能仅限于
    HTTP 请求本身。为了仔细检查这一点，我们将跟踪 TCP 流（[图 10-11](ch10.xhtml#ch10fig11)）。
- en: '![image](../images/f208-02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-02.jpg)'
- en: '*Figure 10-11: Following the TCP stream of the weather receiver communication*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：跟踪天气接收器通信的 TCP 流*'
- en: The HTTP communication begins with a `GET` request from Pete’s weather receiver
    to Wunderground. No HTTP content was transmitted, but a significant amount of
    data was transmitted in the URL ➊. Transferring data through the URL query string
    is common for web applications, and it looks like the receiver is passing weather
    updates using this mechanism. For instance, you see fields like `tempf=43.0`,
    `dewptf=13.6`, and `windchillf=43.0`. The Wunderground collection server is parsing
    the list of fields and parameters from the URL and storing them in a database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 通信从 Pete 的天气接收器向 Wunderground 发送的 `GET` 请求开始。没有传输 HTTP 内容，但在 URL ➊ 中传输了大量数据。通过
    URL 查询字符串传输数据在 Web 应用中很常见，看来接收器正通过这种机制传递天气更新。例如，你可以看到字段如 `tempf=43.0`、`dewptf=13.6`
    和 `windchillf=43.0`。Wunderground 的收集服务器正在从 URL 中解析字段和参数列表，并将它们存储在数据库中。
- en: At first glance, everything looks fine with the `GET` request to the Wunderground
    server. But a look at the corresponding reply shows an error was reported. The
    server responded with an `HTTP/1.0 200 OK` response code ➋, indicating that the
    `GET` request was received and successful, but the body of the response contains
    a useful message, `INVALIDPASSWORDID|Password or key and/or id are incorrect`
    ➌.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，向 Wunderground 服务器发送的 `GET` 请求似乎一切正常。但查看相应的回复时发现报告了一个错误。服务器响应了一个 `HTTP/1.0
    200 OK` 响应代码 ➋，表示 `GET` 请求已接收并成功，但响应体中包含一条有用的消息：`INVALIDPASSWORDID|密码或密钥和/或 ID
    不正确` ➌。
- en: If you look back up at the request URL, you’ll see the first two parameters
    passed are `ID` and `PASSWORD`. These are used to identify the weather station
    call sign and authenticate it to the Wunderground server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回过头看一下请求 URL，你会发现传递的前两个参数是`ID`和`PASSWORD`。这两个参数用于识别气象站的呼号并将其认证到 Wunderground
    服务器。
- en: In this case, Pete’s weather station ID is correct, but his password is not.
    For some unknown reason, it has been replaced by zeros. Since the last known successful
    communication was at midnight, it’s possible an update was applied or the receiver
    rebooted and lost the password configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Pete 的气象站 ID 是正确的，但密码不正确。由于某种未知原因，它被替换成了零。由于上次已知的成功通信发生在午夜，因此有可能是应用了某次更新，或者接收器重启后丢失了密码配置。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While many developers choose to pass parameters in URLs, it’s generally frowned
    upon to do this with passwords as seen here. That’s because requested URLs are
    transmitted in plaintext when using HTTP without added encryption, such as HTTPS.
    Therefore, a malicious user who happens to be listening on the wire could intercept
    your password.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然许多开发人员选择在 URL 中传递参数，但通常不推荐像这里一样将密码放在 URL 中。因为在使用 HTTP 时，所请求的 URL 会以明文形式传输，除非添加了加密，例如
    HTTPS。因此，任何一个恰巧监听网络的恶意用户都可能拦截你的密码。*'
- en: At this point, Pete was able to access his receiver and type in the new password.
    Shortly thereafter, his weather station began syncing data again. An example of
    successful weather station communication can be found in *weather_working.pcapng*.
    The communication stream is shown in [Figure 10-12](ch10.xhtml#ch10fig12).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Pete 能够访问他的接收器并输入新密码。没过多久，他的气象站开始重新同步数据。成功的气象站通信示例可以在 *weather_working.pcapng*
    中找到。通信流如 [图 10-12](ch10.xhtml#ch10fig12) 所示。
- en: '![image](../images/f209-01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f209-01.jpg)'
- en: '*Figure 10-12: Successful weather station communication*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：成功的气象站通信*'
- en: The password is now correct ➊, and the Wunderground server responds with a `success`
    message in the HTTP response body ➋.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在密码是正确的 ➊，Wunderground 服务器在 HTTP 响应体中返回了 `success` 消息 ➋。
- en: '***Lessons Learned***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: In this scenario, we encountered a third-party service that facilitated network
    communication by using features available within another protocol (HTTP). Fixing
    communication problems with third-party services is something you’ll encounter
    often, and packet analysis techniques are very well suited for troubleshooting
    these services when proper documentation or error logging isn’t available. This
    is becoming more common now that Internet of Things (IoT) devices, such as this
    weather station, are popping up all around us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们遇到了一个第三方服务，通过使用另一种协议（HTTP）中可用的功能来促进网络通信。解决第三方服务的通信问题是你经常会遇到的事情，而当没有合适的文档或错误日志时，数据包分析技术非常适合用于排查这些服务的问题。随着物联网（IoT）设备的普及，如本示例中的气象站，这种情况变得越来越常见。
- en: Fixing such problems requires the ability to inspect unknown traffic sequences
    and derive how things are supposed to be working. Some applications, such as the
    HTTP-based weather data transmission in this scenario, are fairly simple. Others
    are quite complex, requiring multiple transactions, the addition of encryption,
    or even custom protocols that Wireshark may not natively parse.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题需要能够检查未知的流量序列，并推断出事物应该如何工作。一些应用程序，如本场景中的基于 HTTP 的气象数据传输，比较简单。而其他一些应用则相当复杂，可能涉及多个事务、添加加密，甚至是
    Wireshark 无法原生解析的自定义协议。
- en: As you investigate more third-party services, you’ll eventually start learning
    about common patterns developers use to facilitate network communication. This
    knowledge will increase your effectiveness when troubleshooting them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调查更多第三方服务时，你最终会开始了解开发人员用来促进网络通信的常见模式。这些知识将提高你在排查问题时的效率。
- en: '**No Internet Access**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无互联网访问**'
- en: In many scenarios, you may need to diagnose and solve internet connectivity
    problems. We’ll cover some common problems you might encounter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能需要诊断和解决互联网连接问题。我们将讨论一些你可能遇到的常见问题。
- en: '***Gateway Configuration Problems***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网关配置问题***'
- en: '*nowebaccess1.pcapng*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*nowebaccess1.pcapng*'
- en: 'Our next scenario presents a common problem: a user cannot access the internet.
    We have verified that the user can access all the internal resources of the network,
    including shares on other workstations and applications hosted on local servers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个场景呈现了一个常见问题：用户无法访问互联网。我们已确认用户可以访问网络的所有内部资源，包括其他工作站的共享资源和本地服务器上托管的应用程序。
- en: The network architecture is straightforward, as all clients and servers connect
    to a series of simple switches. Internet access is handled through a single router
    serving as the default gateway, and IP-addressing information is provided by DHCP.
    This is a very common scenario in small offices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网络架构非常简单，因为所有的客户端和服务器都连接到一系列简单的交换机。互联网接入通过一个路由器处理，该路由器作为默认网关，IP地址信息由DHCP提供。这是小型办公室中非常常见的场景。
- en: '**Tapping into the Wire**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**接入网络**'
- en: To determine the cause of the issue, we can have the user attempt to browse
    the internet while our sniffer is listening on the wire. We use the information
    from [Chapter 2](ch02.xhtml#ch02) (see [Figure 2-15](ch02.xhtml#ch02fig15)) to
    determine the most appropriate method for placing our sniffer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定问题的原因，我们可以让用户在我们监听网络时尝试浏览互联网。我们使用[第2章](ch02.xhtml#ch02)中的信息（见[图2-15](ch02.xhtml#ch02fig15)）来确定放置嗅探器的最合适方法。
- en: The switches on our network don’t support port mirroring. We already have to
    interrupt the user to conduct our test, so we can assume that it is okay to take
    them offline once again. Even though this isn’t a high-throughput scenario, a
    TAP would be appropriate here if one were available. The resulting file is *nowebaccess1.pcapng*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网络中的交换机不支持端口镜像。我们已经需要中断用户以进行测试，因此我们可以假设再次将用户下线是可以的。即使这不是一个高吞吐量的场景，如果有TAP设备，使用它也是合适的。生成的文件是*nowebaccess1.pcapng*。
- en: '**Analysis**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析**'
- en: The traffic capture begins with an ARP request and reply, as shown in [Figure
    10-13](ch10.xhtml#ch10fig13). In packet 1, the user’s computer, with a MAC address
    of 00:25:b3:bf:91:ee and IP address 172.16.0.8, sends an ARP broadcast packet
    to all computers on the network segment in an attempt to find the MAC address
    associated with the IP address of its default gateway, 172.16.0.10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 流量捕获始于一个ARP请求和回复，如[图10-13](ch10.xhtml#ch10fig13)所示。在数据包1中，用户的计算机，MAC地址为00:25:b3:bf:91:ee，IP地址为172.16.0.8，向网络段上的所有计算机广播ARP数据包，试图找到与其默认网关的IP地址172.16.0.10相关联的MAC地址。
- en: '![image](../images/f211-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-01.jpg)'
- en: '*Figure 10-13: ARP request and reply for the computer’s default gateway*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：计算机默认网关的ARP请求和回复*'
- en: A response is received in packet 2, and the user’s computer learns that 172.16.0.10
    is at 00:24:81:a1:f6:79\. Once this reply is received, the computer has a route
    to a gateway that should be able to direct it to the internet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包2中接收到一个响应，用户的计算机得知172.16.0.10的MAC地址是00:24:81:a1:f6:79。一旦接收到这个回复，计算机便有了通往网关的路由，网关应该能够将其引导到互联网。
- en: Following the ARP reply, the computer must attempt to resolve the DNS name of
    the website to an IP address using DNS in packet 3\. As shown in [Figure 10-14](ch10.xhtml#ch10fig14),
    the computer does this by sending a DNS query packet to its primary DNS server,
    4.2.2.2 ➊.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARP回复之后，计算机必须尝试通过DNS解析网站的DNS名称为IP地址，在数据包3中完成。如[图10-14](ch10.xhtml#ch10fig14)所示，计算机通过向其主要DNS服务器4.2.2.2发送DNS查询数据包来执行此操作➊。
- en: '![image](../images/f211-02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-02.jpg)'
- en: '*Figure 10-14: A DNS query sent to 4.2.2.2*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：发送到4.2.2.2的DNS查询*'
- en: Under normal circumstances, a DNS server would respond to a DNS query very quickly,
    but that’s not the case here. Rather than a response, we see the same DNS query
    sent a second time to a different destination address. As shown in [Figure 10-15](ch10.xhtml#ch10fig15),
    in packet 4, the second DNS query is sent to the secondary DNS server configured
    on the computer, which is 4.2.2.1 ➊.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，DNS服务器会非常快速地响应DNS查询，但这里并非如此。我们没有收到响应，而是看到同样的DNS查询第二次发送到不同的目标地址。如[图10-15](ch10.xhtml#ch10fig15)所示，在数据包4中，第二个DNS查询被发送到计算机上配置的备用DNS服务器4.2.2.1➊。
- en: '![image](../images/f211-03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-03.jpg)'
- en: '*Figure 10-15: A second DNS query sent to 4.2.2.1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-15：发送到4.2.2.1的第二个DNS查询*'
- en: Again, no reply is received from the DNS server, and the query is sent again
    1 second later to 4.2.2.2\. This process repeats itself, alternating between the
    primary ➊ and secondary ➋ configured DNS servers over the next several seconds,
    as shown in [Figure 10-16](ch10.xhtml#ch10fig16). The entire process takes around
    8 seconds ➌, or until the user’s internet browser reports that a website is inaccessible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f212-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: DNS queries are repeated until communication stops.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Based on the packets we’ve seen, we can begin to pinpoint the source of the
    problem. First, we see a successful ARP request to what we believe is the default
    gateway router for the network, so we know that device is online and communicating.
    We also know that the user’s computer is actually transmitting packets on the
    network, so we can assume there isn’t an issue with the protocol stack on the
    computer itself. The problem clearly begins to occur when the DNS request is made.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this network, DNS queries are resolved by an external server
    on the internet (4.2.2.2 or 4.2.2.1). This means that for resolution to take place
    correctly, the router responsible for routing packets to the internet must successfully
    forward the DNS queries to the server, and the server must respond. This all must
    happen before HTTP can be used to request the web page itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Because no other users are having issues connecting to the internet, the network
    router and remote DNS server are probably not the source of the problem. The only
    thing remaining to investigate is the user’s computer itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Upon deeper examination of the affected computer, we find that rather than receiving
    a DHCP-assigned address, the computer has manually assigned addressing information,
    and the default gateway address is set incorrectly. The address set as the default
    gateway is not a router and cannot forward the DNS query packets outside the network.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Lessons Learned**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The problem in this scenario resulted from a misconfigured client. While the
    problem itself turned out to be simple, it significantly impacted the user. Troubleshooting
    a simple misconfiguration like this one could take quite some time for someone
    lacking knowledge of the network or the ability to perform a quick packet analysis,
    as we’ve done here. As you can see, packet analysis is not limited to large and
    complex problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Notice that because we didn’t enter the scenario knowing the IP address of the
    network’s gateway router, Wireshark didn’t identify the problem exactly, but it
    did tell us where to look, saving valuable time. Rather than examining the gateway
    router, contacting our ISP, or trying to find the resources to troubleshoot the
    remote DNS server, we were able to focus our troubleshooting efforts on the computer
    itself, which was, in fact, the source of the problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '*Had we been more familiar with this particular network’s IP-addressing scheme,
    analysis could have been even faster. The problem could have been identified immediately
    once we noticed that the ARP request was sent to an IP address different from
    that of the gateway router. These simple misconfigurations are often the source
    of network problems and can typically be resolved quickly with a bit of packet
    analysis.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '***Unwanted Redirection***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*nowebaccess2.pcapng*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we again have a user who is having trouble accessing the internet
    from their workstation. However, unlike the user in the previous scenario, this
    user can access the internet. Their problem is that they can’t access their home
    page, *[https://www.google.com/](https://www.google.com/)*. When the user attempts
    to reach any domain hosted by Google, they are directed to a browser page that
    says, “Internet Explorer cannot display the web page.” This issue is affecting
    only this particular user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous scenario, this is a small network with a few simple switches
    and a single router serving as the default gateway.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**Tapping into the Wire**'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To begin our analysis, we have the user attempt to browse to *[https://www.google.com/](https://www.google.com/)*
    while we use a tap to listen to the traffic that is generated. The resulting file
    is *nowebaccess2.pcapng*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The capture begins with an ARP request and reply, as shown in [Figure 10-17](ch10.xhtml#ch10fig17).
    In packet 1, the user’s computer, with a MAC address of 00:25:b3:bf:91:ee and
    an IP address of 172.16.0.8, sends an ARP broadcast packet to all computers on
    the network segment in an attempt to find the MAC address associated with the
    host’s IP address 172.16.0.102\. We don’t immediately recognize this address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f213-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: ARP request and reply for another device on the network*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In packet 2, the user’s computer learns that the IP address 172.16.0.102 is
    at 00:21:70:c0:56:f0\. Based on the previous scenario, we might assume that this
    is the gateway router’s address and that address is used so that packets can once
    again be forwarded to the external DNS server. However, as shown in [Figure 10-18](ch10.xhtml#ch10fig18),
    the next packet is not a DNS request but a TCP packet from 172.16.0.8 to 172.16.0.102\.
    It has the SYN flag set ➌, indicating that this is the first packet in the handshake
    for a new TCP-based connection between the two hosts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f214-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: TCP SYN packet sent from one internal host to another*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Notably, the TCP connection attempt is made to port 80 ➋ on 172.16.0.102 ➊,
    which is typically associated with HTTP traffic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10-19](ch10.xhtml#ch10fig19), this connection attempt is
    abruptly halted when host 172.16.0.102 sends a TCP packet in response (packet
    4) with the RST and ACK flags set ➊.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f214-02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-19: TCP RST packet sent in response to the TCP SYN*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 8](ch08.xhtml#ch08) that a packet with the RST flag set
    is used to terminate a TCP connection. Here, the host at 172.16.0.8 attempted
    to establish a TCP connection to the host at 172.16.0.102 on port 80\. Unfortunately,
    because that host has no services configured to listen to requests on port 80,
    the TCP RST packet is sent to terminate the connection. This process repeats three
    times before communication finally ends, as shown in [Figure 10-20](ch10.xhtml#ch10fig20).
    At this point, the user receives a message in their browser saying that the page
    can’t be displayed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f215-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-20: The TCP SYN and RST packets are seen three times in total.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'After examining the configuration of another network device that is working
    correctly, we are concerned by the ARP request and reply in packets 1 and 2, because
    the ARP request isn’t for the gateway router’s actual MAC address but for some
    unknown device. Following the ARP request and reply, we would expect to see a
    DNS query sent to our configured DNS server in order to find the IP address associated
    with *[https://www.google.com/](https://www.google.com/)*, but we don’t. There
    are two conditions that could prevent a DNS query from being made:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: •     The device initiating the connection already has the DNS name-to-IP address
    mapping in its DNS cache (as in the first scenario in this chapter).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: •     The device connecting to the DNS name already has the DNS name-to-IP address
    mapping specified in its *hosts* file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Upon further examination of the client computer, we find that the computer’s
    *hosts* file has an entry for *[https://www.google.com/](https://www.google.com/)*
    associated with the internal IP address 172.16.0.102\. This erroneous entry is
    the source of our user’s problems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: A computer will typically use its *hosts* file as the authoritative source for
    DNS name-to-IP address mappings, and it will check that file before querying an
    outside source. In this scenario, the user’s computer checked its *hosts* file,
    found the entry for *[https://www.google.com/](https://www.google.com/)*, and
    decided that *[https://www.google.com/](https://www.google.com/)* was actually
    on its own local network segment. Next, it sent an ARP request to the host, received
    a response, and attempted to initiate a TCP connection to 172.16.0.102 on port
    80\. However, because the remote system was not configured as a web server, it
    wouldn’t accept the connection attempts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Once the *hosts* file entry was removed, the user’s computer began communicating
    correctly and was able to access *[https://www.google.com/](https://www.google.com/)*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*To examine your* hosts *file on a Windows system, open* C:\Windows\System32\
    drivers\etc\hosts*. On Linux, view* /etc/hosts.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: This very common scenario is one that malware has been using for years to redirect
    users to websites hosting malicious code. Imagine if an attacker were to modify
    your *hosts* file so that every time you went to do your online banking, you were
    redirected to a fake site designed to steal your account credentials!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Lessons Learned**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you continue to analyze traffic, you will learn both how the various protocols
    work and how to break them. In this scenario, the DNS query wasn’t sent because
    the client was misconfigured, not because of any external limitations or misconfigurations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: By examining this problem at the packet level, we were able to quickly spot
    an IP address that was unknown and to determine that the DNS, a key component
    of this communication process, was missing. Using this information, we were able
    to identify the client as the source of the problem.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '***Upstream Problems***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*nowebaccess3.pcapng*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous two scenarios, in this scenario, a user complains of no
    internet access from their workstation. This user has narrowed the issue down
    to a single website, *[https://www.google.com/](https://www.google.com/)*. Upon
    further investigation, we find that this issue is affecting everyone in the organization—no
    one can access Google domains.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The network is configured as in the two prior scenarios, with a few simple switches
    and a single router connecting the network to the internet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Tapping into the Wire**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To troubleshoot this issue, we first browse to *[https://www.google.com/](https://www.google.com/)*
    to generate traffic. Because this issue is network-wide, ideally any device in
    the network should be able to reproduce the issue using most capture methods.
    The file resulting from the capture via a tap is *nowebaccess3.pcapng*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This packet capture begins with DNS traffic instead of the ARP traffic we are
    used to seeing. Because the first packet in the capture is to an external address,
    and packet 2 contains a reply from that address, we can assume that the ARP process
    has already happened and the MAC-to-IP address mapping for our gateway router
    already exists in the host’s ARP cache at 172.16.0.8.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10-21](ch10.xhtml#ch10fig21), the first packet in the capture
    is from the host 172.16.0.8 to address 4.2.2.1 ➊ and is a DNS packet ➋. Examining
    the contents of the packet, we see that it is a query for the A record for *[www.google.com](http://www.google.com)*
    ➌ that will map the DNS name to an IP address.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f217-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-21: DNS query for* [www.google.com](http://www.google.com) *A record*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The response to the query from 4.2.2.1 is the second packet in the capture file,
    as shown in [Figure 10-22](ch10.xhtml#ch10fig22). Here, we see that the name server
    that responded to this request provided multiple answers to the query ➊. At this
    point, all looks good, and communication is occurring as it should.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f217-02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-22: DNS reply with multiple A records*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user’s computer has determined the web server’s IP address, it
    can attempt to communicate with the server. As shown in [Figure 10-23](ch10.xhtml#ch10fig23),
    this process is initiated in packet 3, with a TCP packet sent from 172.16.0.8
    to 74.125.95.105 ➊. This destination address comes from the first A record provided
    in the DNS query response seen in packet 2\. The TCP packet has the SYN flag set
    ➋, and it’s attempting to communicate with the remote server on port 80 ➌.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f218-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-23: The SYN packet is attempting to initiate a connection on port
    80.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a TCP handshake process, we know that we should see a TCP SYN/ACK
    packet sent in response, but instead, after a short time, another SYN packet is
    sent from the source to the destination. This process occurs once more after approximately
    one second, as shown in [Figure 10-24](ch10.xhtml#ch10fig24), at which point communication
    stops and the browser reports that the website could not be found.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f218-02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-24: The TCP SYN packet is attempted three times with no response
    received.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: As we troubleshoot this scenario, consider that we know that the workstation
    within our network can connect to the outside world because the DNS query to our
    external DNS server at 4.2.2.1 is successful. The DNS server responds with what
    appears to be a valid address, and our hosts attempt to connect to one of those
    addresses. Also, the local workstation we are attempting to connect from appears
    to be functioning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that the remote server simply isn’t responding to our connection
    requests; a TCP RST packet is not sent. This might occur for several reasons:
    a misconfigured web server, a corrupted protocol stack on the web server, or a
    packet-filtering device on the remote network (such as a firewall). Assuming there
    is no local packet-filtering device in place, all other potential solutions are
    on the remote network and beyond our control. In this case, the web server was
    not functioning correctly, and no attempt to access it succeeded. Once the problem
    was corrected on Google’s end, communication was able to proceed.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Lessons Learned**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this scenario, the problem wasn’t one that we could correct. Our analysis
    determined that the issue wasn’t with the hosts on our network, our router, or
    the external DNS server providing us with name resolution services. The issue
    lay outside our network infrastructure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes discovering that a problem isn’t really ours not only relieves stress
    but also saves face when management comes knocking. I have fought with many ISPs,
    vendors, and software companies who claim that an issue is not their fault, but
    as you’ve just seen, packets don’t lie.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Inconsistent Printer**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next scenario, an IT help desk administrator is having trouble resolving
    a printing issue. Users in the sales department are reporting that the high-volume
    printer is malfunctioning. When a user sends a large print job to the printer,
    it will print several pages and then stop printing before the job is done. Multiple
    driver configuration changes have been attempted but have been unsuccessful. The
    help desk staff would like you to ensure that this isn’t a network problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '***Tapping into the Wire***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*inconsistent_printer.pcapng*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The common thread in this problem is the printer, so we begin by placing our
    sniffer as close to the printer as we can. While we can’t install Wireshark on
    the printer itself, the switches used in this network are advanced layer 3 switches,
    so we can use port mirroring. We’ll mirror the port used by the printer to an
    empty port and connect a laptop with Wireshark installed to this port. Once this
    setup is complete, we’ll have a user send a large print job to the printer so
    we can monitor the output. The resulting capture file is *inconsistent_printer.pcapng*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A TCP handshake between the network workstation sending the print job (172.16.0.8)
    and the printer (172.16.0.253) initiates the connection at the start of the capture
    file. Following the handshake, a 1,460-byte TCP data packet ➊ is sent to the printer
    in packet 4 ([Figure 10-25](ch10.xhtml#ch10fig25)). The amount of data can be
    seen in the far right side of the Info column in the Packet List pane or at the
    bottom of the TCP header information in the Packet Details pane.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f220-01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-25: Data being transmitted to the printer over TCP*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Following packet 4, another data packet is sent containing 1,460 bytes of data
    ➊, as you can see in [Figure 10-26](ch10.xhtml#ch10fig26). This data is acknowledged
    by the printer in packet 6 ➋.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f220-02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-26: Normal data transmission and TCP acknowledgments*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The flow of data continues until the last few packets in the capture are reached.
    Packet 121 is a TCP retransmission packet, and a sign of trouble, as shown in
    [Figure 10-27](ch10.xhtml#ch10fig27).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A TCP retransmission packet is sent when one device sends a TCP packet to a
    remote device and the remote device doesn’t acknowledge the transmission. Once
    a retransmission threshold is reached, the sending device assumes that the remote
    device did not receive the data, and it retransmits the packet. This process is
    repeated a few times before communication effectively stops.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f221-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-27: These TCP retransmission packets are a sign of a potential problem.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the retransmission is sent from the client workstation to
    the printer because the printer failed to acknowledge the transmitted data. As
    shown in [Figure 10-27](ch10.xhtml#ch10fig27), if you expand the SEQ/ACK analysis
    portion of the TCP header ➊ along with the additional information beneath it,
    you can view the details of why this is a retransmission. According to the details
    processed by Wireshark, packet 121 is a retransmission of packet 120 ➌. Additionally,
    the retransmission timeout (RTO) for the retransmitted packet was around 5.5 seconds
    ➋.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the delay between packets, you can change the time display format
    to suit your situation. In this case, because we want to see how long the retransmissions
    occurred after the previous packet was sent, change this option by selecting **View
    ▶ Time Display Format** and select **Seconds Since Previous Captured Packet**.
    Then, as shown in [Figure 10-28](ch10.xhtml#ch10fig28), you can clearly see that
    the retransmission in packet 121 occurs 5.5 seconds after the original packet
    (packet 120) is sent ➊.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f221-02.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-28: Viewing the time between packets is useful for troubleshooting.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The next packet is another retransmission of packet 120\. The RTO of this packet
    is 11.10 seconds, which includes the 5.5 seconds from the RTO of the previous
    packet. A look at the Time column of the Packet List pane tells us that this retransmission
    was sent 5.6 seconds after the previous retransmission. This appears to be the
    last packet in the capture file, and, not coincidentally, the printer stops printing
    at approximately this time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we have the benefit of dealing with only two devices inside
    our own network, so we just need to determine whether the client workstation or
    the printer is to blame. We can see that data is flowing correctly for quite some
    time, and then at some point, the printer simply stops responding to the workstation.
    The workstation gives its best effort to get the data to its destination, as evidenced
    by the retransmissions, but the effort is met with no response. This issue is
    reproducible and happens regardless of which computer sends a print job, so we
    assume the printer is the source of the problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: After further analysis, we find that the printer’s RAM is malfunctioning. When
    large print jobs are sent to the printer, it prints only a certain number of pages,
    likely until certain regions of memory are accessed. At that point, the memory
    issue causes the printer to be unable to accept any new data, and it ceases communication
    with the host transmitting the print job.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '***Lessons Learned***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although this printer problem wasn’t the result of a network issue, we were
    able to use Wireshark to pinpoint the problem. Unlike previous scenarios, this
    one centered solely on TCP traffic. Since TCP is concerned about reliably transmitting
    data, it often leaves us with useful information when two devices simply stop
    communicating.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In this case, when communication abruptly stopped, we were able to pinpoint
    the location of the problem based on nothing more than TCP’s built-in retransmission
    functionality. As we continue through our scenarios, we will often rely on functionality
    like this to troubleshoot more complex issues.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**No Branch Office Connectivity**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*stranded_clientside.pcapng stranded_branchdns.pcapng*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we have a company with a central headquarters office and a
    newly deployed remote branch office. The company’s IT infrastructure is mostly
    contained within the central office using a Windows server-based domain. This
    infrastructure is supported by a domain controller, a DNS server, and an application
    server used to host web-based software used daily by the organization’s employees.
    The branch office is connected by routers to establish a wide area network (WAN)
    link. Inside the branch office are user workstations and a slave DNS server that
    should receive its resource record information from the upstream DNS server at
    the corporate headquarters. [Figure 10-29](ch10.xhtml#ch10fig29) shows a map of
    each office and how the offices are linked together.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f223-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-29: The relevant components for the stranded branch office issue*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The deployment team is rolling out new infrastructure to the branch office when
    it finds that no one can access the intranet web application server from the branch
    office network. This server is located at the main office and is accessed through
    the WAN link. This connectivity issue affects all users at the branch office.
    All users can access the internet and other resources within the branch.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '***Tapping into the Wire***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the problem lies in communication between the main and branch offices,
    there are a couple of places we could collect data to start tracking down the
    problem. The problem could be with the clients inside the branch office, so we’ll
    start by port mirroring one of those computers to check what it sees on the wire.
    Once we’ve collected that information, we can use it to point toward other collection
    locations that might help solve the problem. The initial capture file obtained
    from one of the clients is *stranded_clientside.pcapng*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As shown in [Figure 10-30](ch10.xhtml#ch10fig30), our first capture file begins
    when the user at the workstation address 172.16.16.101 attempts to access an application
    hosted on the headquarter’s app server, 172.16.16.200\. This capture contains
    only two packets. It appears as though a DNS request is sent to 172.16.16.251
    ➊ for the A record ➌ for `appserver` ➋ in the first packet. This is the DNS name
    for the server at 172.16.16.200 in the central office.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 10-31](ch10.xhtml#ch10fig31), the response to this
    packet is a server failure ➊, which indicates that something is preventing the
    DNS query from resolving successfully. Notice that this packet does not answer
    the query ➋ since it is an error (server failure).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f224-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-30: Communication begins with a DNS query for the `appserver` A
    record.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f224-02.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-31: The query response indicates a problem upstream.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We now know that the communication problem is related to some DNS issue. Because
    the DNS queries at the branch office are resolved by the on-site DNS server at
    172.16.16.251, that’s our next stop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To capture the appropriate traffic from the branch DNS server, we’ll leave our
    sniffer in place and simply change the port-mirroring assignment so that the DNS
    server’s traffic, rather than the workstation’s traffic, is now mirrored to our
    sniffer. The result is the file *stranded_branchdns.pcapng*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10-32](ch10.xhtml#ch10fig32), this capture begins with the
    query and response we saw earlier, along with one additional packet. This additional
    packet looks a bit odd because it is attempting to communicate with the primary
    DNS server at the central office (172.16.16.250) ➊ on the standard DNS server
    port 53 ➌, but it is not the UDP ➋ we’re used to seeing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f225-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-32: This SYN packet uses port 53 but is not UDP.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the purpose of this packet, recall our discussion of DNS in [Chapter
    9](ch09.xhtml#ch09). DNS usually uses UDP, but it uses TCP when the response to
    a query exceeds a certain size. In that case, we’ll see some initial UDP traffic
    that triggers the TCP traffic. TCP is also used for DNS during a zone transfer,
    when resource records are transferred between DNS servers, which is likely the
    case here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The DNS server at the branch office location is a slave to the DNS server at
    the central office, meaning that it relies on it in order to receive resource
    records. The application server that users in the branch office are trying to
    access is located inside the central office, which means that the central office
    DNS server is authoritative for that server. For the branch office server to resolve
    a DNS request for the application server, the DNS resource record for that server
    must be transferred from the central office DNS server to the branch office DNS
    server. This is likely the source of the SYN packet in this capture file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The lack of response to this SYN packet tells us that the DNS problem is the
    result of a failed zone transfer between the branch and central office DNS servers.
    Now we can go one step further by figuring out why the zone transfer is failing.
    The possible culprits for the issue can be narrowed down to the routers between
    the offices or the central office DNS server itself. To determine which is at
    fault, we can sniff the traffic of the central office DNS server to see whether
    the SYN packet is making it to the server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t included a capture file for the central office DNS server traffic
    because there was none. The SYN packet never reached the server. Upon dispatching
    technicians to review the configuration of the routers connecting the two offices,
    it was found that inbound port 53 traffic on the central office router was configured
    to allow only UDP traffic and to block inbound TCP traffic. This simple misconfiguration
    prevented zone transfers from occurring between servers, thus preventing clients
    within the branch office from resolving queries for devices in the central office.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***Lessons Learned***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can learn a lot about investigating network communication issues by watching
    crime dramas. When a crime occurs, the detectives begin by interviewing those
    most affected. Leads that result from that examination are pursued, and the process
    continues until a culprit is found.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we began by examining the target (the workstation) and established
    leads by finding the DNS communication issue. Our leads led us to the branch DNS
    server, then to the central DNS server, and finally to the router, which was the
    source of the problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: When performing analysis, try thinking of packets as clues. The clues don’t
    always tell you who committed the crime, but they often take you to the culprit
    eventually.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Data Corruption**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*tickedoffdeveloper.pcapng*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most frequent arguments in IT are between developers and network
    administrators. Developers always blame poor network engineering and malfunctioning
    equipment for program errors. In turn, network administrators tend to blame bad
    code for network errors and slow communication.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, a programmer has developed an application for tracking the
    sales at multiple stores and reporting back to a central database. To save bandwidth
    during normal business hours, the application does not update in real time. Data
    is accumulated throughout the day and then transmitted at night as a comma-separated
    value (CSV) file to be inserted into the central database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This newly developed application isn’t functioning correctly. The files sent
    from the stores are being received by the server, but the data being inserted
    into the database is not correct. Sections are missing, data is in the wrong place,
    and some portions of the data are missing. Much to the dismay of the network administrator,
    the programmer blames the network for the issue. They are convinced that the files
    are becoming corrupted while in transit from the stores to the central data repository.
    Our goal is to determine whether they are right.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '***Tapping into the Wire***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To collect the data we need, we can capture packets at one of the stores or
    at the central office. Because the issue is affecting all the stores, it should
    occur at the central office if it is network related—that is the only common thread
    among all stores (other than the software itself).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The network switches support port mirroring, so we’ll mirror the port the server
    is plugged into and sniff its traffic. The traffic capture will be isolated to
    a single instance of a store uploading its CSV file to the collection server.
    This result is the capture file *tickedoffdeveloper.pcapng*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We know nothing about the application the programmer has developed, other than
    the basic flow of information on the network. The capture file appears to start
    with some FTP traffic, so we’ll investigate to see whether it is indeed the mechanism
    that is transporting this file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the packet list first ([Figure 10-33](ch10.xhtml#ch10fig33)), we
    can see that 172.16.16.128 ➊ initiates communication to 172.16.16.121 ➋ with a
    TCP handshake. Since 172.16.16.128 initiates the communication, we can assume
    that it is the client and that 172.16.16.121 is the server that compiles and processes
    the data. Following the handshake completion, we begin seeing FTP requests from
    the client and responses from the server ➌.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f227-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-33: The initial communication helps identify the client and server.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We know that some transfer of data should be happening here, so we can use our
    knowledge of FTP to locate the packet where this transfer begins. The FTP connection
    and data transfer are initiated by the client, so from 172.16.16.128 we should
    see the FTP `STOR` command, which is used to upload data to an FTP server. The
    easiest way to find this command is to build a filter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this capture file is littered with FTP request commands, rather than
    sorting through the hundreds of protocols and options in the expression builder,
    we can build the filter we need directly from the Packet List pane. To do so,
    we first need to select a packet with an FTP request command present. We’ll choose
    packet 5, since it’s near the top of our list. Then expand the FTP section in
    the Packet Details pane and expand the USER section. Right-click the **Request
    Command: USER** field and select **Prepare a Filter**. Finally, choose **Selected**.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: This will prepare a filter for all packets that contain the `FTP USER` request
    command and put it in the filter dialog. Next, as shown in [Figure 10-34](ch10.xhtml#ch10fig34),
    edit the filter by replacing the word `USER` with the word STOR ➊.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f227-02.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-34: This filter helps identify where data transfer begins.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We could narrow down the filter further by providing the client’s IP address
    and specifying it as the source of the connection by adding `&& ip.src == 172.16.16.128`
    to the filter, but since this capture file is already isolated to a single client,
    that isn’t necessary here.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now apply this filter by pressing ENTER, and you’ll see that only one instance
    of the `STOR` command exists in the capture file, at packet 64 ➋.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know where data transfer begins, click the packet to select it and
    clear the filter by clicking the **X** button above the Packet List pane. Your
    screen should now show all the packets with packet 64 selected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Examining the capture file beginning with packet 64, we see that this packet
    specifies the transfer of the file *store4829-03222010.csv* ➊, as shown in [Figure
    10-35](ch10.xhtml#ch10fig35).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f228-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-35: The CSV file is being transferred using FTP.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The packets following the `STOR` command use a different port but are identified
    as part of an FTP-DATA transmission. We’ve verified that data is being transferred,
    but we have yet to establish whether the programmer is right or wrong. To do so,
    we need to show whether the contents of the file are intact after traversing the
    network, so we’ll proceed to extract the transferred file from the captured packets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: When a file is transferred across a network in an unencrypted format, it is
    broken down into segments and reassembled at its destination. In this scenario,
    we captured packets as they reached their destination but before they were reassembled.
    The data is all there; we simply need to reassemble it by extracting the file
    as a data stream. To perform the reassembly, select any of the packets in the
    FTP-DATA stream (such as packet 66) and click **Follow TCP Stream**. The results
    are displayed as shown in [Figure 10-36](ch10.xhtml#ch10fig36). This looks like
    a normal CSV-formatted text file containing sales order data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The data appears because it is being transferred in plaintext over FTP, but
    we can’t be sure that the file is intact based on the stream alone. To reassemble
    the data so as to extract it in its original format, click the **Save As** button
    and specify the name of the file as displayed in packet 64\. Then click **Save**.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The result of this save operation should be a CSV file that is an exact byte-level
    copy of the file originally transferred from the store system. The file can be
    verified by comparing the MD5 hash of the original file with that of the extracted
    file. The MD5 hashes should be the same, as shown in [Figure 10-37](ch10.xhtml#ch10fig37).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f229-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-36: The TCP stream shows what appears to be the data being transferred.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f229-02.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-37: The MD5 hashes of the original file and the extracted file are
    equivalent.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Once the files are compared, we can state that the network is not to blame for
    the database corruption occurring within the application. The file transferred
    from the store to the collection server is intact when it reaches the server,
    so any corruption must be occurring when the file is processed by the application
    on the server side.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '***Lessons Learned***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One great thing about packet-level analysis is that you don’t need to deal with
    the clutter of applications. Poorly coded applications greatly outnumber the good
    ones, but at the packet level, none of that matters. In this case, the programmer
    was concerned about all of the mysterious components their application was dependent
    upon, but at the end of the day, their complicated data transfer that took hundreds
    of lines of code is still no more than FTP, TCP, and IP. Using what we know about
    these basic protocols, we were able to ensure the communication process was flowing
    correctly and even extract files to prove the soundness of the network. It’s crucial
    to remember that no matter how complex the issue at hand, it still comes down
    to packets.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Thoughts**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered several scenarios in which packet analysis allowed
    us to gain a better understanding of problematic communication. Using basic analysis
    of common protocols, we were able to track down and solve network problems in
    a timely manner. While you may not encounter exactly the same scenarios on your
    network, the analysis techniques presented here should prove useful as you analyze
    your own unique problems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
