["```\nconst EOW = \"■\";\nconst ALPHABET = `${EOW}ABCDE`;\nconst newTrie = () => null;\nconst newNode = () => ({links: new Array(ALPHABET.length).fill(null)});\nconst isEmpty = (trie) => !trie; // null or undefined\n```", "```\nconst _find = (trie, [first, . . .rest]) => {\n❶ const i = ALPHABET.indexOf(first);\n❷ if (isEmpty(trie)) {\n   return null;\n❸} else if (first === EOW) {\n   return isEmpty(trie.links[i]) ? null : trie.links[i].data;\n❹} else {\n   return _find(trie.links[i], rest);\n }\n};\n```", "```\nconst find = (trie, wordToFind) =>\n❶ !!wordToFind ? _find(trie, wordToFind + EOW) : null;\n```", "```\n❶ const _add = (trie, [first, . . .rest], data) => {\n❷ if (first) {\n  ❸ if (isEmpty(trie)) {\n      trie = newNode();\n    }\n ❹ const i = ALPHABET.indexOf(first);\n    if (first === EOW) {\n    ❺ trie.links[i] = {data};\n    } else {\n    ❻ trie.links[i] = _add(trie.links[i], rest, data);\n    }\n  }\n  return trie;\n};\n```", "```\nconst add = (trie, wordToAdd, dataToAdd = wordToAdd) =>\n  _add(trie, wordToAdd + EOW, dataToAdd);\n```", "```\n❶ const _remove = (trie, [first, . . .rest]) => {\n❷ if (isEmpty(trie)) {\n    // nothing to do\n  } else if (!first) {\n  ❸ trie = null;\n  } else {\n  ❹ const i = ALPHABET.indexOf(first);\n  ❺ trie.links[i] = _remove(trie.links[i], rest);\n  ❻ if (trie.links.every((t) => isEmpty(t))) {\n      trie = null;\n    }\n  }\n❼ return trie;\n};\n```", "```\nconst remove = (trie, wordToRemove) => _remove(trie, wordToRemove + EOW);\n```", "```\nconst EOW = \"■\";\nconst newTrie = () => null;\n**const newNode = () => ({links: {}});**\nconst isEmpty = (trie) => !trie; // null or undefined\n```", "```\nconst _find = (trie, [first, . . .rest]) => {\n  if (isEmpty(trie)) {\n    return null;\n  } else if (first === EOW) {\n **return isEmpty(trie.links[first]) ? null : trie.links[first].data;**\n **} else {**\n **return _find(trie.links[first], rest);**\n  }\n};\n\nconst find = (trie, wordToFind) =>\n  !!wordToFind && _find(trie, wordToFind + EOW);\n```", "```\nconst _add = (trie, [first, . . .rest], data) => {\n  if (first) {\n    if (isEmpty(trie)) {\n      trie = newNode();\n    }\n    if (first === EOW) {\n **trie.links[first] = {data};**\n    } else {\n **trie.links[first] = _add(trie.links[first], rest, data);**\n    }\n  }\n  return trie;\n};\n\nconst add = (trie, wordToAdd, dataToAdd = wordToAdd) =>\n  _add(trie, wordToAdd + EOW, dataToAdd);\n```", "```\nconst _remove = (trie, [first, . . .rest]) => {\n  if (isEmpty(trie)) {\n    // nothing to do\n  } else if (!first) {\n    trie = null;\n  } else {\n  ❶ trie.links[first] = _remove(trie.links[first], rest);\n    if (isEmpty(trie.links[first])) {\n    ❷ delete trie.links[first];\n    ❸ if (Object.keys(trie.links).length === 0) {\n        trie = null;\n      }\n }\n  }\n  return trie;\n};\n\nconst remove = (trie, wordToRemove) => _remove(trie, wordToRemove + EOW);\n```", "```\nconst EOW = \"■\";\nconst newRadixTree = () => null;\nconst newNode = () => ({links: {}});\nconst isEmpty = (rt) => !rt;\n```", "```\nconst _commonLength = (str1, str2) => {\n  let i = 0;\n❶ while (str1[i] && str1[i] === str2[i]) {\n ❷ i++;\n  }\n  return i;\n};\n```", "```\nconst _find = (trie, wordToFind) => {\n❶ if (isEmpty(trie)) {\n    return false;\n  } else {\n  ❷ const linkWord = Object.keys(trie.links).find(\n      (v) => v[0] === wordToFind[0]\n    );\n\n  ❸ if (linkWord) {\n    ❹ if (wordToFind === linkWord) {\n        return trie.links[linkWord].data;\n      } else {\n      ❺ const common = _commonLength(linkWord, wordToFind);\n      ❻ return _find(\n          trie.links[linkWord.substring(0, common)],\n          wordToFind.substring(common)\n        );\n      }\n  ❼} else {\n      return false;\n    }\n  }\n};\n```", "```\nconst find = (trie, wordToFind) =>\n  !!wordToFind && _find(trie, wordToFind + EOW);\n```", "```\nconst _add = (trie, wordToAdd, data) => {\n❶ if (wordToAdd) {\n  ❷ if (isEmpty(trie)) {\n      trie = newNode();\n      trie.links[wordToAdd] = {data};\n    } else {\n    ❸ const linkWord = Object.keys(trie.links).find(\n        (v) => v[0] === wordToAdd[0]\n      );\n    ❹ if (linkWord) {\n        const common = _commonLength(linkWord, wordToAdd);\n        const prefix = linkWord.substring(0, common);\n        const oldSuffix = linkWord.substring(common);\n        const newSuffix = wordToAdd.substring(common);\n\n      ❺ if (linkWord === prefix) {\n          trie.links[linkWord] = _add(trie.links[linkWord], newSuffix, data);\n        } else {\n        ❻ trie.links[prefix] = {\n            links: {\n              [oldSuffix]: trie.links[linkWord],\n              [newSuffix]: {data}\n            }\n          };\n        ❼ delete trie.links[linkWord];\n        }\n      } else {\n      ❽ trie.links[wordToAdd] = {data};\n      }\n    }\n  }\n❾ return trie;\n};\n```", "```\nconst add = (trie, wordToAdd, dataToAdd = wordToAdd) =>\n  _add(trie, wordToAdd + EOW, dataToAdd);\n```", "```\nconst _remove = (trie, wordToRemove) => {\n❶ if (!isEmpty(trie) && wordToRemove > \"\") {\n  ❷ const linkWord = Object.keys(trie.links).find(\n      (v) => v[0] === wordToRemove[0]\n    );\n  ❸ if (linkWord && wordToRemove.startsWith(linkWord)) {\n      const common = _commonLength(linkWord, wordToRemove);\n      const prefix = linkWord.substring(0, common);\n\n    ❹ if (wordToRemove === prefix) {\n        delete trie.links[prefix];\n    ❺} else {\n        trie.links[prefix] = _remove(\n          trie.links[prefix],\n          wordToRemove.substring(common)\n        );\n      ❻ if (Object.keys(trie.links[prefix].links).length === 1) {\n          const single = Object.keys(trie.links[prefix].links)[0];\n          trie.links[prefix + single] = trie.links[prefix].links[single];\n          delete trie.links[prefix];\n        }\n      }\n    }\n  }\n❼ return trie;\n};\n```", "```\nconst remove = (trie, wordToRemove) => {\n❶ if (!isEmpty(trie)) {\n  ❷ _remove(trie, wordToRemove + EOW);\n  ❸ if (Object.keys(trie.links).length === 0) {\n      trie = null;\n    }\n  }\n  return trie;\n};\n```", "```\nconst EOW = \"■\";\n\nconst newTernary = () => null;\n\nconst newNode = (key) => ({\n  key,\n  left: null,\n  right: null,\n  middle: null\n});\n\nconst isEmpty = (tree) => tree === null;\n```", "```\ntree.middle = {data};\n```", "```\nconst _find = (tree, wordToFind) => {\n❶ if (isEmpty(tree)) {\n   return false;\n❷} else if (wordToFind.length === 0) {\n   return tree.data;\n❸} else if (tree.key === wordToFind[0]) {\n   return _find(tree.middle, wordToFind.substring(1));\n❹} else {\n   return _find(wordToFind < tree.key ? tree.left : tree.right, wordToFind);\n }\n};\n```", "```\nconst find = (trie, wordToFind) =>\n  !!wordToFind && _find(trie, wordToFind + EOW);\n```", "```\nconst _add = (tree, wordToAdd, data) => {\n❶ if (wordToAdd.length > 0) {\n  ❷ if (isEmpty(tree)) {\n      tree = newNode(wordToAdd[0]);\n    }\n  ❸ if (tree.key === wordToAdd[0]) {\n    ❹ tree.middle =  \n        wordToAdd[0] === EOW\n          ? {data}\n          : _add(tree.middle, wordToAdd.substring(1), data);\n  ❺} else {\n    ❻ const side = wordToAdd < tree.key ? \"left\" : \"right\";\n    ❼ tree[side] = _add(tree[side], wordToAdd, data);\n    }\n  }\n❽ return tree;\n};\n```", "```\nconst add = (tree, wordToAdd, data = wordToAdd) =>\n  _add(tree, wordToAdd + EOW, data);\n```", "```\nconst _remove = (tree, wordToRemove) => {\n❶ if (isEmpty(tree)) {\n    // nothing to do\n❷} else if (wordToRemove.length === 0) {\n    tree = null;\n  } else {\n  ❸ if (wordToRemove[0] === tree.key) {\n      tree.middle =\n        tree.key === EOW\n          ? null\n          : _remove(tree.middle, wordToRemove.substring(1));\n\n    ❹ if (isEmpty(tree.middle)) {\n      ❺ if (isEmpty(tree.left)) {\n          tree = tree.right;\n        } else if (isEmpty(tree.right)) {\n          tree = tree.left;\n      ❻} else {\n          let treeR = tree.right;\n          let prev = null;\n        ❼ while (!isEmpty(treeR.left)) {\n            prev = treeR;\n            treeR = treeR.left;\n          }\n        ❽ if (prev) {\n prev.left = treeR.right;\n            treeR.right = tree.right;\n          }\n\n       ❾ treeR.left = tree.left;\n          tree = treeR;\n        }\n      }\n  ❿} else {\n      const side = wordToRemove < tree.key ? \"left\" : \"right\";\n      tree[side] = _remove(tree[side], wordToRemove);\n    }\n  }\n\n  return tree;\n};\n```", "```\nconst remove = (tree, wordToRemove) => _remove(tree, wordToRemove + EOW);\n```"]