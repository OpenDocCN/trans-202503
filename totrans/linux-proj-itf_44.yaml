- en: Chapter 44. Pipes and FIFOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter describes pipes and FIFOs. Pipes are the oldest method of IPC
    on the UNIX system, having appeared in Third Edition UNIX in the early 1970s.
    Pipes provide an elegant solution to a frequent requirement: having created two
    processes to run different programs (commands), how can the shell allow the output
    produced by one process to be used as the input to the other process? Pipes can
    be used to pass data between related processes (the meaning of *related* will
    become clear later). FIFOs are a variation on the pipe concept. The important
    difference is that FIFOs can be used for communication between *any* processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every user of the shell is familiar with the use of pipes in commands such
    as the following, which counts the number of files in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to execute the above command, the shell creates two processes, executing
    *ls* and *wc*, respectively. (This is done using *fork()* and *exec()*, which
    are described in [Chapter 24](ch24.html "Chapter 24. Process Creation") and [Chapter 27](ch27.html
    "Chapter 27. Program Execution").) [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") shows how the two processes
    employ the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") is intended to illustrate
    how pipes got their name. We can think of a pipe as a piece of plumbing that allows
    data to flow from one process to another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a pipe to connect two processes](figs/web/44-1_PIPE-overview-scale90.png.jpg)Figure 44-1. Using
    a pipe to connect two processes'
  prefs: []
  type: TYPE_NORMAL
- en: One point to note in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") is that the two processes
    are connected to the pipe so that the writing process (*ls*) has its standard
    output (file descriptor 1) joined to the write end of the pipe, while the reading
    process (*wc*) has its standard input (file descriptor 0) joined to the read end
    of the pipe. In effect, these two processes are unaware of the existence of the
    pipe; they just read from and write to the standard file descriptors. The shell
    must do some work in order to set things up in this way, and we see how this is
    done in Section 44.4.
  prefs: []
  type: TYPE_NORMAL
- en: In the following paragraphs, we cover a number of important characteristics
    of pipes.
  prefs: []
  type: TYPE_NORMAL
- en: A pipe is a byte stream
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we say that a pipe is a byte stream, we mean that there is no concept of
    messages or message boundaries when using a pipe. The process reading from a pipe
    can read blocks of data of any size, regardless of the size of blocks written
    by the writing process. Furthermore, the data passes through the pipe sequentially—bytes
    are read from a pipe in exactly the order they were written. It is not possible
    to randomly access the data in a pipe using *lseek()*.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to implement the notion of discrete messages in a pipe, we must do
    this within our application. While this is feasible (refer to [A Client-Server
    Application Using FIFOs](ch44.html#a_client-server_application_using_fifos "A
    Client-Server Application Using FIFOs")), it may be preferable to use alternative
    IPC mechanisms, such as message queues and datagram sockets, which we discuss
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a pipe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Attempts to read from a pipe that is currently empty block until at least one
    byte has been written to the pipe. If the write end of a pipe is closed, then
    a process reading from the pipe will see end-of-file (i.e., *read()* returns 0)
    once it has read all remaining data in the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes are unidirectional
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data can travel only in one direction through a pipe. One end of the pipe is
    used for writing, and the other end is used for reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'On some other UNIX implementations—notably those derived from System V Release
    4—pipes are bidirectional (so-called *stream pipes*). Bidirectional pipes are
    not specified by any UNIX standards, so that, even on implementations where they
    are provided, it is best to avoid reliance on their semantics. As an alternative,
    we can use UNIX domain stream socket pairs (created using the *socketpair()* system
    call described in [Creating a Connected Socket Pair: *socketpair()*](ch57.html#creating_a_connected_socket_pair_colon_s
    "Creating a Connected Socket Pair: socketpair()")), which provide a standardized
    bidirectional communication mechanism that is semantically equivalent to stream
    pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Writes of up to `PIPE_BUF` bytes are guaranteed to be atomic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If multiple processes are writing to a single pipe, then it is guaranteed that
    their data won’t be intermingled if they write no more than `PIPE_BUF` bytes at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 requires that `PIPE_BUF` be at least `_POSIX_PIPE_BUF` (512). An implementation
    should define `PIPE_BUF` (in `<limits.h>`) and/or allow the call *fpathconf(fd,
    _PC_PIPE_BUF)* to return the actual upper limit for atomic writes. `PIPE_BUF`
    varies across UNIX implementations; for example, it is 512 bytes on FreeBSD 6.0,
    4096 bytes on Tru64 5.1, and 5120 bytes on Solaris 8\. On Linux, `PIPE_BUF` has
    the value 4096.
  prefs: []
  type: TYPE_NORMAL
- en: When writing blocks of data larger than `PIPE_BUF` bytes to a pipe, the kernel
    may transfer the data in multiple smaller pieces, appending further data as the
    reader removes bytes from the pipe. (The *write()* call blocks until all of the
    data has been written to the pipe.) When there is only a single process writing
    to a pipe (the usual case), this doesn’t matter. However, if there are multiple
    writer processes, then writes of large blocks may be broken into segments of arbitrary
    size (which may be smaller than `PIPE_BUF` bytes) and interleaved with writes
    by other processes.
  prefs: []
  type: TYPE_NORMAL
- en: The `PIPE_BUF` limit affects exactly when data is transferred to the pipe. When
    writing up to `PIPE_BUF` bytes, *write()* will block if necessary until sufficient
    space is available in the pipe so that it can complete the operation atomically.
    When more than `PIPE_BUF` bytes are being written, *write()* transfers as much
    data as possible to fill the pipe, and then blocks until data has been removed
    from the pipe by some reading process. If such a blocked *write()* is interrupted
    by a signal handler, then the call unblocks and returns a count of the number
    of bytes successfully transferred, which will be less than was requested (a so-called
    *partial write*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux 2.2, pipe writes of *any* size are atomic, unless interrupted by a
    signal handler. On Linux 2.4 and later, any write greater than `PIPE_BUF` bytes
    may be interleaved with writes by other processes. (The kernel code implementing
    pipes underwent substantial changes between kernel versions 2.2 and 2.4.)
  prefs: []
  type: TYPE_NORMAL
- en: Pipes have a limited capacity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A pipe is simply a buffer maintained in kernel memory. This buffer has a maximum
    capacity. Once a pipe is full, further writes to the pipe block until the reader
    removes some data from the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 makes no requirement about the capacity of a pipe. In Linux kernels before
    2.6.11, the pipe capacity is the same as the system page size (e.g., 4096 bytes
    on x86-32); since Linux 2.6.11, the pipe capacity is 65,536 bytes. Other UNIX
    implementations have different pipe capacities.
  prefs: []
  type: TYPE_NORMAL
- en: In general, an application never needs to know the exact capacity of a pipe.
    If we want to prevent the writer process(es) from blocking, the process(es) reading
    from the pipe should be designed to read data as soon as it is available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In theory, there is no reason why a pipe couldn’t operate with smaller capacities,
    even with a single-byte buffer. The reason for employing large buffer sizes is
    efficiency: each time a writer fills the pipe, the kernel must perform a context
    switch to allow the reader to be scheduled so that it can empty some data from
    the pipe. Employing a larger buffer size means that fewer context switches are
    required.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Linux 2.6.35, the capacity of a pipe can be modified. The Linux-specific
    call *fcntl(fd, F_SETPIPE_SZ, size)* changes the capacity of the pipe referred
    to by *fd* to be at least *size* bytes. An unprivileged process can change the
    pipe capacity to any value in the range from the system page size up to the value
    in `/proc/sys/fs/pipe-max-size`. The default value for `pipe-max-size` is 1,048,576
    bytes. A privileged (`CAP_SYS_RESOURCE`) process can override this limit. When
    allocating space for the pipe, the kernel may round *size* up to some value convenient
    for the implementation. The *fcntl(fd, F_GETPIPE_SZ)* call returns the actual
    size allocated for the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Using Pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *pipe()* system call creates a new pipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call to *pipe()* returns two open file descriptors in the array
    *filedes*: one for the read end of the pipe (*filedes[0]*) and one for the write
    end (*filedes[1]*).'
  prefs: []
  type: TYPE_NORMAL
- en: As with any file descriptor, we can use the *read()* and *write()* system calls
    to perform I/O on the pipe. Once written to the write end of a pipe, data is immediately
    available to be read from the read end. A *read()* from a pipe obtains the lesser
    of the number of bytes requested and the number of bytes currently available in
    the pipe (but blocks if the pipe is empty).
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the *stdio* functions (*printf()*, *scanf()*, and so on) with
    pipes by first using *fdopen()* to obtain a file stream corresponding to one of
    the descriptors in *filedes* ([Mixing Library Functions and System Calls for File
    I/O](ch13.html#mixing_library_functions_and_system_call "Mixing Library Functions
    and System Calls for File I/O")). However, when doing this, we must be aware of
    the *stdio* buffering issues described in Section 44.6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call *ioctl(fd, FIONREAD, &cnt)* returns the number of unread bytes in the
    pipe or FIFO referred to by the file descriptor *fd*. This feature is also available
    on some other implementations, but is not specified in SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 44-2](ch44.html#process_file_descriptors_after_creating "Figure 44-2. Process
    file descriptors after creating a pipe") shows the situation after a pipe has
    been created by *pipe()*, with the calling process having file descriptors referring
    to each end.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Process file descriptors after creating a pipe](figs/web/44-2_PIPE-creation-scale90.png.jpg)Figure 44-2. Process
    file descriptors after creating a pipe'
  prefs: []
  type: TYPE_NORMAL
- en: A pipe has few uses within a single process (we consider one in [The Self-Pipe
    Trick](ch63.html#the_self-pipe_trick "The Self-Pipe Trick")). Normally, we use
    a pipe to allow communication between two processes. To connect two processes
    using a pipe, we follow the *pipe()* call with a call to *fork()*. During a *fork()*,
    the child process inherits copies of its parent’s file descriptors ([File Sharing
    Between Parent and Child](ch24.html#file_sharing_between_parent_and_child "File
    Sharing Between Parent and Child")), bringing about the situation shown on the
    left side of [Figure 44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from "Figure 44-3. Setting
    up a pipe to transfer data from a parent to a child").
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a pipe to transfer data from a parent to a child](figs/web/44-3_PIPE-after-fork-scale90.png.jpg)Figure 44-3. Setting
    up a pipe to transfer data from a parent to a child'
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible for the parent and child to both read from and write to
    the pipe, this is not usual. Therefore, immediately after the *fork()*, one process
    closes its descriptor for the write end of the pipe, and the other closes its
    descriptor for the read end. For example, if the parent is to send data to the
    child, then it would close its read descriptor for the pipe, *filedes[0]*, while
    the child would close its write descriptor for the pipe, *filedes[1]*, bringing
    about the situation shown on the right side of [Figure 44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from
    "Figure 44-3. Setting up a pipe to transfer data from a parent to a child"). The
    code to create this setup is shown in [Example 44-1](ch44.html#steps_in_creating_a_pipe_to_transfer_dat
    "Example 44-1. Steps in creating a pipe to transfer data from a parent to a child").
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-1. Steps in creating a pipe to transfer data from a parent to a child
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'One reason that it is not usual to have both the parent and child reading from
    a single pipe is that if two processes try to simultaneously read from a pipe,
    we can’t be sure which process will be the first to succeed—the two processes
    race for data. Preventing such races would require the use of some synchronization
    mechanism. However, if we require bidirectional communication, there is a simpler
    way: just create two pipes, one for sending data in each direction between the
    two processes. (If employing this technique, then we need to be wary of deadlocks
    that may occur if both processes block while trying to read from empty pipes or
    while trying to write to pipes that are already full.)'
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to have multiple processes writing to a pipe, it is typical
    to have only a single writer. (We show one example of where it is useful to have
    multiple writers to a pipe in Section 44.3.) By contrast, there are situations
    where it can be useful to have multiple writers on a FIFO, and we see an example
    of this in Section 44.8.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.27, Linux supports a new, nonstandard system call,
    *pipe2()*. This system call performs the same task as *pipe()*, but supports an
    additional argument, *flags*, that can be used to modify the behavior of the system
    call. Two flags are supported. The `O_CLOEXEC` flag causes the kernel to enable
    the close-on-exec flag (`FD_CLOEXEC`) for the two new file descriptors. This flag
    is useful for the same reasons as the *open()* `O_CLOEXEC` flag described in [File
    descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The `O_NONBLOCK` flag causes the
    kernel to mark both underlying open file descriptions as nonblocking, so that
    future I/O operations will be nonblocking. This saves additional calls to *fcntl()*
    to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes allow communication between related processes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the discussion so far, we have talked about using pipes for communication
    between a parent and a child process. However, pipes can be used for communication
    between any two (or more) related processes, as long as the pipe was created by
    a common ancestor before the series of *fork()* calls that led to the existence
    of the processes. (This is what we meant when we referred to *related processes*
    at the beginning of this chapter.) For example, a pipe could be used for communication
    between a process and its grandchild. The first process creates the pipe, and
    then forks a child that in turn forks to yield the grandchild. A common scenario
    is that a pipe is used for communication between two siblings—their parent creates
    the pipe, and then creates the two children. This is what the shell does when
    building a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an exception to the statement that pipes can be used to communicate
    only between related processes. Passing a file descriptor over a UNIX domain socket
    (a technique that we briefly describe in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors")) makes it possible to pass a file descriptor for a
    pipe to an unrelated process.
  prefs: []
  type: TYPE_NORMAL
- en: Closing unused pipe file descriptors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Closing unused pipe file descriptors is more than a matter of ensuring that
    a process doesn’t exhaust its limited set of file descriptors—it is essential
    to the correct use of pipes. We now consider why the unused file descriptors for
    both the read and write ends of the pipe must be closed.
  prefs: []
  type: TYPE_NORMAL
- en: The process reading from the pipe closes its write descriptor for the pipe,
    so that, when the other process completes its output and closes its write descriptor,
    the reader sees end-of-file (once it has read any outstanding data in the pipe).
  prefs: []
  type: TYPE_NORMAL
- en: If the reading process doesn’t close the write end of the pipe, then, after
    the other process closes its write descriptor, the reader won’t see end-of-file,
    even after it has read all data from the pipe. Instead, a *read()* would block
    waiting for data, because the kernel knows that there is still at least one write
    descriptor open for the pipe. That this descriptor is held open by the reading
    process itself is irrelevant; in theory, that process could still write to the
    pipe, even if it is blocked trying to read. For example, the *read()* might be
    interrupted by a signal handler that writes data to the pipe. (This is a realistic
    scenario, as we’ll see in [The Self-Pipe Trick](ch63.html#the_self-pipe_trick
    "The Self-Pipe Trick").)
  prefs: []
  type: TYPE_NORMAL
- en: The writing process closes its read descriptor for the pipe for a different
    reason. When a process tries to write to a pipe for which no process has an open
    read descriptor, the kernel sends the `SIGPIPE` signal to the writing process.
    By default, this signal kills a process. A process can instead arrange to catch
    or ignore this signal, in which case the *write()* on the pipe fails with the
    error `EPIPE` (broken pipe). Receiving the `SIGPIPE` signal or getting the `EPIPE`
    error is a useful indication about the status of the pipe, and this is why unused
    read descriptors for the pipe should be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the treatment of a *write()* that is interrupted by a `SIGPIPE` handler
    is special. Normally, when a *write()* (or other “slow” system call) is interrupted
    by a signal handler, the call is either automatically restarted or fails with
    the error `EINTR`, depending on whether the handler was installed with the *sigaction()*
    `SA_RESTART` flag ([Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")). The behavior in the case of `SIGPIPE`
    is different because it makes no sense either to automatically restart the *write()*
    or to simply indicate that the *write()* was interrupted by a handler (thus implying
    that the *write()* could usefully be manually restarted). In neither case can
    a subsequent *write()* attempt succeed, because the pipe will still be broken.
  prefs: []
  type: TYPE_NORMAL
- en: If the writing process doesn’t close the read end of the pipe, then, even after
    the other process closes the read end of the pipe, the writing process will still
    be able to write to the pipe. Eventually, the writing process will fill the pipe,
    and a further attempt to write will block indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: One final reason for closing unused file descriptors is that it is only after
    all file descriptors in all processes that refer to a pipe are closed that the
    pipe is destroyed and its resources released for reuse by other processes. At
    this point, any unread data in the pipe is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Example 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa
    "Example 44-2. Using a pipe to communicate between a parent and child process")
    demonstrates the use of a pipe for communication between parent and child processes.
    This example demonstrates the byte-stream nature of pipes referred to earlier—the
    parent writes its data in a single operation, while the child reads data from
    the pipe in small blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The main program calls *pipe()* to create a pipe ![](figs/web/U001.png), and
    then calls *fork()* to create a child ![](figs/web/U002.png). After the *fork()*,
    the parent process closes its file descriptor for the read end of the pipe ![](figs/web/U008.png),
    and writes the string given as the program’s command-line argument to the write
    end of the pipe ![](figs/web/U009.png). The parent then closes the read end of
    the pipe ![](figs/web/U010.png), and calls *wait()* to wait for the child to terminate
    ![](figs/web/U011.png). After closing its file descriptor for the write end of
    the pipe ![](figs/web/U003.png), the child process enters a loop where it reads
    ![](figs/web/U004.png) blocks of data (of up to `BUF_SIZE` bytes) from the pipe
    and writes ![](figs/web/U006.png) them to standard output. When the child encounters
    end-of-file on the pipe ![](figs/web/U005.png), it exits the loop ![](figs/web/U007.png),
    writes a trailing newline character, closes its descriptor for the read end of
    the pipe, and terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of what we might see when running the program in [Example 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa
    "Example 44-2. Using a pipe to communicate between a parent and child process"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 44-2. Using a pipe to communicate between a parent and child process
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pipes as a Method of Process Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Avoiding Race Conditions by Synchronizing with Signals](ch24.html#avoiding_race_conditions_by_synchronizin
    "Avoiding Race Conditions by Synchronizing with Signals"), we looked at how signals
    could be used to synchronize the actions of parent and child processes in order
    to avoid race conditions. Pipes can be used to achieve a similar result, as shown
    by the skeleton program in [Example 44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro
    "Example 44-3. Using a pipe to synchronize multiple processes"). This program
    creates multiple child processes (one for each command-line argument), each of
    which is intended to accomplish some action, simulated in the example program
    by sleeping for some time. The parent waits until all children have completed
    their actions.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the synchronization, the parent builds a pipe ![](figs/web/U001.png)
    before creating the child processes ![](figs/web/U002.png). Each child inherits
    a file descriptor for the write end of the pipe and closes this descriptor once
    it has completed its action ![](figs/web/U003.png). After all of the children
    have closed their file descriptors for the write end of the pipe, the parent’s
    *read()* ![](figs/web/U005.png) from the pipe will complete, returning end-of-file
    (0). At this point, the parent is free to carry on to do other work. (Note that
    closing the unused write end of the pipe in the parent ![](figs/web/U004.png)
    is essential to the correct operation of this technique; otherwise, the parent
    would block forever when trying to read from the pipe.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of what we see when we use the program in [Example 44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro
    "Example 44-3. Using a pipe to synchronize multiple processes") to create three
    children that sleep for 4, 2, and 6 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 44-3. Using a pipe to synchronize multiple processes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Synchronization using pipes has an advantage over the earlier example of synchronization
    using signals: it can be used to coordinate the actions of one process with multiple
    other (related) processes. The fact that multiple (standard) signals can’t be
    queued makes signals unsuitable in this case. (Conversely, signals have the advantage
    that they can be broadcast by one process to all of the members of a process group.)'
  prefs: []
  type: TYPE_NORMAL
- en: Other synchronization topologies are possible (e.g., using multiple pipes).
    Furthermore, this technique could be extended so that, instead of closing the
    pipe, each child writes a message to the pipe containing its process ID and some
    status information. Alternatively, each child might write a single byte to the
    pipe. The parent process could then count and analyze these messages. This approach
    guards against the possibility of the child accidentally terminating, rather than
    explicitly closing the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pipes to Connect Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a pipe is created, the file descriptors used for the two ends of the pipe
    are the next lowest-numbered descriptors available. Since, in normal circumstances,
    descriptors 0, 1, and 2 are already in use for a process, some higher-numbered
    descriptors will be allocated for the pipe. So how do we bring about the situation
    shown in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes "Figure 44-1. Using
    a pipe to connect two processes"), where two filters (i.e., programs that read
    from *stdin* and write to *stdout*) are connected using a pipe, such that the
    standard output of one program is directed into the pipe and the standard input
    of the other is taken from the pipe? And in particular, how can we do this without
    modifying the code of the filters themselves?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to use the techniques described in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors") for duplicating file descriptors. Traditionally,
    the following series of calls was used to accomplish the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The end result of the above steps is that the process’s standard output is bound
    to the write end of the pipe. A corresponding set of calls can be used to bind
    a process’s standard input to the read end of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these steps depend on the assumption that file descriptors 0, 1,
    and 2 for a process are already open. (The shell normally ensures this for each
    program it executes.) If file descriptor 0 was already closed prior to the above
    steps, then we would erroneously bind the process’s standard *input* to the write
    end of the pipe. To avoid this possibility, we can replace the calls to *close()*
    and *dup()* with the following *dup2()* call, which allows us to explicitly specify
    the descriptor to be bound to the pipe end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After duplicating *pfd[1]*, we now have two file descriptors referring to the
    write end of the pipe: descriptor 1 and *pfd[1]*. Since unused pipe file descriptors
    should be closed, after the *dup2()* call, we close the superfluous descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code we have shown so far relies on standard output having been previously
    open. Suppose that, prior to the *pipe()* call, standard input and standard output
    had both been closed. In this case, *pipe()* would have allocated these two descriptors
    to the pipe, perhaps with *pfd[0]* having the value 0 and *pfd[1]* having the
    value 1\. Consequently, the preceding *dup2()* and *close()* calls would be equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, it is good defensive programming practice to bracket these calls
    with an `if` statement of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Example 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc "Example 44-4. Using
    a pipe to connect ls and wc") uses the techniques described in this section to
    bring about the setup shown in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes"). After building a pipe,
    this program creates two child processes. The first child binds its standard output
    to the write end of the pipe and then execs *ls*. The second child binds its standard
    input to the read end of the pipe and then execs *wc*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-4. Using a pipe to connect *ls* and *wc*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program in [Example 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc
    "Example 44-4. Using a pipe to connect ls and wc"), we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Talking to a Shell Command via a Pipe: *popen()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common use for pipes is to execute a shell command and either read its output
    or send it some input. The *popen()* and *pclose()* functions are provided to
    simplify this task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file stream, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns termination status of child process, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *popen()* function creates a pipe, and then forks a child process that execs
    a shell, which in turn creates a child process to execute the string given in
    *command*. The *mode* argument is a string that determines whether the calling
    process will read from the pipe (*mode* is *r*) or write to it (*mode* is *w*).
    (Since pipes are unidirectional, two-way communication with the executed *command*
    is not possible.) The value of *mode* determines whether the standard output of
    the executed command is connected to the write end of the pipe or its standard
    input is connected to the read end of the pipe, as shown in [Figure 44-4](ch44.html#overview_of_process_relationships_and_pi
    "Figure 44-4. Overview of process relationships and pipe usage for popen()").
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of process relationships and pipe usage for popen()](figs/web/44-4_PIPE-popen.png.jpg)Figure 44-4. Overview
    of process relationships and pipe usage for *popen()*'
  prefs: []
  type: TYPE_NORMAL
- en: On success, *popen()* returns a file stream pointer that can be used with the
    *stdio* library functions. If an error occurs (e.g., *mode* is not *r* or *w*,
    pipe creation fails, or the *fork()* to create the child fails), then *popen()*
    returns `NULL` and sets *errno* to indicate the cause of the error.
  prefs: []
  type: TYPE_NORMAL
- en: After the *popen()* call, the calling process uses the pipe to read the output
    of *command* or to send input to it. Just as with pipes created using *pipe()*,
    when reading from the pipe, the calling process encounters end-of-file once *command*
    has closed the write end of the pipe; when writing to the pipe, it is sent a `SIGPIPE`
    signal, and gets the `EPIPE` error, if *command* has closed the read end of the
    pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once I/O is complete, the *pclose()* function is used to close the pipe and
    wait for the child shell to terminate. (The *fclose()* function should not be
    used, since it doesn’t wait for the child.) On success, *pclose()* yields the
    termination status ([The Wait Status Value](ch26.html#the_wait_status_value "The
    Wait Status Value")) of the child shell (which is the termination status of the
    last command that the shell executed, unless the shell was killed by a signal).
    As with *system()* ([Executing a Shell Command: *system()*](ch27.html#executing_a_shell_command_colon_system_o
    "Executing a Shell Command: system()")), if a shell could not be execed, then
    *pclose()* returns a value as though the child shell had terminated with the call
    *_exit(127)*. If some other error occurs, *pclose()* returns -1\. One possible
    error is that the termination status could not be obtained. We explain how this
    may occur shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: When performing a wait to obtain the status of the child shell, SUSv3 requires
    that *pclose()*, like *system()*, should automatically restart the internal call
    that it makes to *waitpid()* if that call is interrupted by a signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, we can make the same statements for *popen()* as were made in [Executing
    a Shell Command: *system()*](ch27.html#executing_a_shell_command_colon_system_o
    "Executing a Shell Command: system()") for *system()*. Using *popen()* offers
    convenience. It builds the pipe, performs descriptor duplication, closes unused
    descriptors, and handles all of the details of *fork()* and *exec()* on our behalf.
    In addition, shell processing is performed on the command. This convenience comes
    at the cost of efficiency. At least two extra processes must be created: one for
    the shell and one or more for the command(s) executed by the shell. As with *system()*,
    *popen()* should never be used from privileged programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are several similarities between *system()* and *popen()* plus
    *pclose()*, there are also significant differences. These stem from the fact that,
    with *system()*, the execution of the shell command is encapsulated within a single
    function call, whereas with *popen()*, the calling process runs in parallel with
    the shell command and then calls *pclose()*. The differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the calling process and the executed command are operating in parallel,
    SUSv3 requires that *popen()* should *not* ignore `SIGINT` and `SIGQUIT`. If generated
    from the keyboard, these signals are sent to both the calling process and the
    executed command. This occurs because both processes reside in the same process
    group, and terminal-generated signals are sent to all of the members of the (foreground)
    process group, as described in Section 34.5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the calling process may create other child processes between the execution
    of *popen()* and *pclose()*, SUSv3 requires that *popen()* should *not* block
    `SIGCHLD`. This means that if the calling process performs a wait operation before
    the *pclose()* call, it may retrieve the status of the child created by *popen()*.
    In this case, when *pclose()* is later called, it will return -1, with *errno*
    set to `ECHILD`, indicating that *pclose()* could not retrieve the status of the
    child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op "Example 44-5. Globbing
    filename patterns with popen()") demonstrates the use of *popen()* and *pclose()*.
    This program repeatedly reads a filename wildcard pattern ![](figs/web/U002.png),
    and then uses *popen()* to obtain the results from passing this pattern to the
    *ls* command ![](figs/web/U005.png). (Techniques similar to this were used on
    older UNIX implementations to perform filename generation, also known as *globbing*,
    prior to the existence of the *glob()* library function.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-5. Globbing filename patterns with *popen()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell session demonstrates the use of the program in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()"). In this example, we
    first provide a pattern that matches two filenames, and then a pattern that matches
    no filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The construction of the command ![](figs/web/U001.png)![](figs/web/U004.png)
    for globbing in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()") requires some explanation.
    Actual globbing of a pattern is performed by the shell. The *ls* command is merely
    being used to list the matching filenames, one per line. We could have tried using
    the *echo* command instead, but this would have had the undesirable result that
    if a pattern matched no filenames, then the shell would leave the pattern unchanged,
    and *echo* would simply display the pattern. By contrast, if *ls* is given the
    name of a file that doesn’t exist, it prints an error message on *stderr* (which
    we dispose of by redirecting *stderr* to `/dev/null`), prints nothing on *stdout*,
    and exits with a status of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the input checking performed in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()") ![](figs/web/U003.png).
    This is done to prevent invalid input causing *popen()* to execute an unexpected
    shell command. Suppose that these checks were omitted, and the user entered the
    following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The program would then pass the following command to *popen()*, with disastrous
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Such checking of input is always required in programs that use *popen()* (or
    *system()*) to execute a shell command built from user input. (An alternative
    would be for the application to quote any characters other than those being checked
    for, so that those characters don’t undergo special processing by the shell.)
  prefs: []
  type: TYPE_NORMAL
- en: Pipes and *stdio* Buffering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the file stream pointer returned by a call to *popen()* doesn’t refer
    to a terminal, the *stdio* library applies block buffering to the file stream
    ([Buffering in the *stdio* Library](ch13.html#buffering_in_the_stdio_library "Buffering
    in the stdio Library")). This means that when we call *popen()* with a *mode*
    of *w*, then, by default, output is sent to the child process at the other end
    of the pipe only when the *stdio* buffer is filled or we close the pipe with *pclose()*.
    In many cases, this presents no problem. If, however, we need to ensure that the
    child process receives data on the pipe immediately, then we can either use periodic
    calls to *fflush()* or disable *stdio* buffering using the call *setbuf(fp, NULL)*.
    This technique can also be used if we create a pipe using the *pipe()* system
    call and then use *fdopen()* to obtain a *stdio* stream corresponding to the write
    end of the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: If the process calling *popen()* is reading from the pipe (i.e., *mode* is *r*),
    things may not be so straightforward. In this case, if the child process is using
    the *stdio* library, then—unless it includes explicit calls to *fflush()* or *setbuf()*—its
    output will be available to the calling process only when the child either fills
    the *stdio* buffer or calls *fclose()*. (The same statement applies if we are
    reading from a pipe created using *pipe()* and the process writing on the other
    end is using the *stdio* library.) If this is a problem, there is little we can
    do unless we can modify the source code of the program running in the child process
    to include calls to *setbuf()* of *fflush()*.
  prefs: []
  type: TYPE_NORMAL
- en: If modifying the source code is not an option, then instead of using a pipe,
    we could use a pseudoterminal. A pseudoterminal is an IPC channel that appears
    to the process on one end as though it is a terminal. Consequently, the *stdio*
    library line buffers output. We describe pseudoterminals in [Chapter 64](ch64.html
    "Chapter 64. Pseudoterminals").
  prefs: []
  type: TYPE_NORMAL
- en: FIFOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Semantically, a FIFO is similar to a pipe. The principal difference is that
    a FIFO has a name within the file system and is opened in the same way as a regular
    file. This allows a FIFO to be used for communication between unrelated processes
    (e.g., a client and server).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a FIFO has been opened, we use the same I/O system calls as are used with
    pipes and other files (i.e., *read()*, *write()*, and *close()*). Just as with
    pipes, a FIFO has a write end and a read end, and data is read from the pipe in
    the same order as it is written. This fact gives FIFOs their name: *first in,
    first out*. FIFOs are also sometimes known as *named pipes*.'
  prefs: []
  type: TYPE_NORMAL
- en: As with pipes, when all descriptors referring to a FIFO have been closed, any
    outstanding data is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a FIFO from the shell using the *mkfifo* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The *pathname* is the name of the FIFO to be created, and the *-m* option is
    used to specify a permission *mode* in the same way as for the *chmod* command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When applied to a FIFO (or pipe), *fstat()* and *stat()* return a file type
    of `S_IFIFO` in the *st_mode* field of the *stat* structure ([Retrieving File
    Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving
    File Information: stat()")). When listed with *ls -l*, a FIFO is shown with the
    type *p* in the first column, and *ls -F* appends an the pipe symbol (`|`) to
    the FIFO pathname.'
  prefs: []
  type: TYPE_NORMAL
- en: The *mkfifo()* function creates a new FIFO with the given *pathname*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *mode* argument specifies the permissions for the new FIFO. These permissions
    are specified by ORing the desired combination of constants from [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories"). As usual, these permissions are masked against
    the process umask value ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Historically, FIFOs were created using the system call *mknod(pathname, S_IFIFO,
    0)*. POSIX.1-1990 specified *mkfifo()* as a simpler API avoiding the generality
    of *mknod()*, which allows creation of various types of files, including device
    files. (SUSv3 specifies *mknod()*, but weakly, defining only its use for creating
    FIFOs.) Most UNIX implementations provide *mkfifo()* as a library function layered
    on top of *mknod()*.
  prefs: []
  type: TYPE_NORMAL
- en: Once a FIFO has been created, any process can open it, subject to the usual
    file permission checks ([Permission-Checking Algorithm](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm")).
  prefs: []
  type: TYPE_NORMAL
- en: Opening a FIFO has somewhat unusual semantics. Generally, the only sensible
    use of a FIFO is to have a reading process and a writing process on each end.
    Therefore, by default, opening a FIFO for reading (the *open()* `O_RDONLY` flag)
    blocks until another process opens the FIFO for writing (the *open()* `O_WRONLY`
    flag). Conversely, opening the FIFO for writing blocks until another process opens
    the FIFO for reading. In other words, opening a FIFO synchronizes the reading
    and writing processes. If the opposite end of a FIFO is already open (perhaps
    because a pair of processes have already opened each end of the FIFO), then *open()*
    succeeds immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Under most UNIX implementations (including Linux), it is possible to circumvent
    the blocking behavior when opening FIFOs by specifying the `O_RDWR` flag when
    opening a FIFO. In this case, *open()* returns immediately with a file descriptor
    that can be used for reading and writing on the FIFO. Doing this rather subverts
    the I/O model for FIFOs, and SUSv3 explicitly notes that opening a FIFO with the
    `O_RDWR` flag is unspecified; therefore, for portability reasons, this technique
    should be avoided. In circumstances where we need to prevent blocking when opening
    a FIFO, the *open()* `O_NONBLOCK` flag provides a standardized method for doing
    so (refer to [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1 "Nonblocking
    I/O")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoiding the use of the `O_RDWR` flag when opening a FIFO can be desirable for
    a another reason. After such an *open()*, the calling process will never see end-of-file
    when reading from the resulting file descriptor, because there will always be
    at least one descriptor open for writing to the FIFO—the same descriptor from
    which the process is reading.
  prefs: []
  type: TYPE_NORMAL
- en: Using FIFOs and *tee(1)* to create a dual pipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the characteristics of shell pipelines is that they are linear; each
    process in the pipeline reads data produced by its predecessor and sends data
    to its successor. Using FIFOs, it is possible to create a fork in a pipeline,
    so that a duplicate copy of the output of a process is sent to another process
    in addition to its successor in the pipeline. In order to do this, we need to
    use the *tee* command, which writes two copies of what it reads from its standard
    input: one to standard output and the other to the file named in its command-line
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the *file* argument to *tee* a FIFO allows us to have two processes simultaneously
    reading the duplicate output produced by *tee*. We demonstrate this in the following
    shell session, which creates a FIFO named `myfifo`, starts a background *wc* command
    that opens the FIFO for reading (this will block until the FIFO is opened for
    writing), and then executes a pipeline that sends the output of *ls* to *tee*,
    which both passes the output further down the pipeline to *sort* and sends it
    to the `myfifo` FIFO. (The *-k5n* option to *sort* causes the output of *ls* to
    be sorted in increasing numerical order on the fifth space-delimited field.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Diagrammatically, the above commands create the situation shown in [Figure 44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1
    "Figure 44-5. Using a FIFO and tee(1) to create a dual pipeline").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *tee* program is so named because of its shape. We can consider *tee* as
    functioning similarly to a pipe, but with an additional branch that sends duplicate
    output. Diagrammatically, this has the shape of a capital letter *T* (see [Figure 44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1
    "Figure 44-5. Using a FIFO and tee(1) to create a dual pipeline")). In addition
    to the purpose described here, *tee* is also useful for debugging pipelines and
    for saving the results produced at some intervening point in a complex pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a FIFO and tee(1) to create a dual pipeline](figs/web/44-5_PIPE-fifo-and-tee-scale90.png.jpg)Figure 44-5. Using
    a FIFO and *tee(1)* to create a dual pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: A Client-Server Application Using FIFOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we present a simple client-server application that employs
    FIFOs for IPC. The server provides the (trivial) service of assigning unique sequential
    numbers to each client that requests them. In the course of discussing this application,
    we introduce a few concepts and techniques in server design.
  prefs: []
  type: TYPE_NORMAL
- en: Application overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the example application, all clients send their requests to the server using
    a single server FIFO. The header file ([Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c"))
    defines the well-known name (`/tmp/seqnum_sv`) that the server uses for its FIFO.
    This name is fixed, so that all clients know how to contact the server. (In this
    example application, we create the FIFOs in the `/tmp` directory, since this allows
    us to conveniently run the programs without change on most systems. However, as
    noted in [Pitfalls When Performing File Operations and File I/O](ch38.html#pitfalls_when_performing_file_operations
    "Pitfalls When Performing File Operations and File I/O"), creating files in publicly
    writable directories such as `/tmp` can lead to various security vulnerabilities
    and should be avoided in real-world applications.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In client-server applications, we’ll repeatedly encounter the concept of a *well-known
    address* or name used by a server to make its service visible to clients. Using
    a well-known address is one solution to the problem of how clients can know where
    to contact a server. Another possible solution is to provide some kind of name
    server with which servers can register the names of their services. Each client
    then contacts the name server to obtain the location of the service it desires.
    This solution allows the location of servers to be flexible, at the cost of some
    extra programming effort. Of course, clients and servers then need to know where
    to contact the name server; typically, it resides at a well-known address.
  prefs: []
  type: TYPE_NORMAL
- en: It is not, however, possible to use a single FIFO to send responses to all clients,
    since multiple clients would race to read from the FIFO, and possibly read each
    other’s response messages rather than their own. Therefore, each client creates
    a unique FIFO that the server uses for delivering the response for that client,
    and the server needs to know how to find each client’s FIFO. One possible way
    to do this is for the client to generate its FIFO pathname, and then pass the
    pathname as part of its request message. Alternatively, the client and server
    can agree on a convention for constructing a client FIFO pathname, and, as part
    of its request, the client can pass the server the information required to construct
    the pathname specific to this client. This latter solution is used in our example.
    Each client’s FIFO name is built from a template (`CLIENT_FIFO_TEMPLATE`) consisting
    of a pathname containing the client’s process ID. The inclusion of the process
    ID provides an easy way of generating a name unique to this client.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 44-6](ch44.html#using_fifos_in_a_single-server_comma_mul "Figure 44-6. Using
    FIFOs in a single-server, multiple-client application") shows how this application
    uses FIFOs for communication between the client and server processes of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: The header file ([Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c"))
    defines the formats for the request messages sent from clients to the server,
    and for the response messages sent from the server to clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using FIFOs in a single-server, multiple-client application](figs/web/44-6_PIPE-seqnum-scale90.png.jpg)Figure 44-6. Using
    FIFOs in a single-server, multiple-client application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the data in pipes and FIFOs is a byte stream; boundaries between
    multiple messages are not preserved. This means that when multiple messages are
    being delivered to a single process, such as the server in our example, then the
    sender and receiver must agree on some convention for separating the messages.
    Various approaches are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminate each message with a *delimiter character*, such as a newline character.
    (For an example of this technique, see the *readLine()* function in [Example 59-1](ch59.html#reading_data_a_line_at_a_time
    "Example 59-1. Reading data a line at a time"), in [Data Representation](ch59.html#data_representation
    "Data Representation").) In this case, either the delimiter character must be
    one that never appears as part of the message, or we must adopt a convention for
    escaping the delimiter if it does occur within the message. For example, if we
    use a newline delimiter, then the characters \ plus newline could be used to represent
    a real newline character within the message, while \\ could represent a real \.
    One drawback of this approach is that the process reading messages must scan data
    from the FIFO a byte at a time until the delimiter character is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a *fixed-size header with a length field* in each message specifying
    the number of bytes in the remaining variable-length component of the message.
    In this case, the reading process first reads the header from the FIFO, and then
    uses the header’s length field to determine the number of bytes to read for the
    remainder of the message. This approach has the advantage of efficiently allowing
    messages of arbitrary size, but could lead to problems if a malformed message
    (e.g., bad *length* field) is written to the pipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *fixed-length messages*, and have the server always read messages of this
    fixed size. This has the advantage of being simple to program. However, it places
    an upper limit on our message size and means that some channel capacity is wasted
    (since short messages must be padded to the fixed length). Furthermore, if one
    of the clients accidentally or deliberately sends a message that is not of the
    right length, then all subsequent messages will be out of step; in this situation,
    the server can’t easily recover.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three techniques are illustrated in [Figure 44-7](ch44.html#separating_messages_in_a_byte_stream
    "Figure 44-7. Separating messages in a byte stream"). Be aware that for each of
    these techniques, the total length of each message must be smaller than `PIPE_BUF`
    bytes in order to avoid the possibility of messages being broken up by the kernel
    and interleaved with messages from other writers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the three techniques described in the main text, a single channel (FIFO)
    is used for all messages from all clients. An alternative is to use a *single
    connection* for each message. The sender opens the communication channel, sends
    its message, and then closes the channel. The reading process knows that the message
    is complete when it encounters end-of-file. If multiple writers hold a FIFO open,
    then this approach is not feasible, because the reader won’t see end-of-file when
    one of the writers closes the FIFO. This approach is, however, feasible when using
    stream sockets, where a server process creates a unique communication channel
    for each incoming client connection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating messages in a byte stream](figs/web/44-7_PIPE-msg-formats.png.jpg)Figure 44-7. Separating
    messages in a byte stream'
  prefs: []
  type: TYPE_NORMAL
- en: In our example application, we use the third of the techniques described above,
    with each client sending messages of a fixed size to the server. This message
    is defined by the *request* structure defined in [Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c").
    Each request to the server includes the client’s process ID, which enables the
    server to construct the name of the FIFO used by the client to receive a response.
    The request also contains a field (*seqLen*) specifying how many sequence numbers
    should be allocated to this client. The response message sent from server to client
    consists of a single field, *seqNum*, which is the starting value of the range
    of sequence numbers allocated to this client.
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-6. Header file for `fifo_seqnum_server.c` and `fifo_seqnum_client.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Server program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") is the code for the server. The server performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the server’s well-known FIFO ![](figs/web/U001.png) and open the FIFO
    for reading ![](figs/web/U002.png). The server must be run before any clients,
    so that the server FIFO exists by the time a client attempts to open it. The server’s
    *open()* blocks until the first client opens the other end of the server FIFO
    for writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the server’s FIFO once more ![](figs/web/U003.png), this time for writing.
    This will never block, since the FIFO has already been opened for reading. This
    second open is a convenience to ensure that the server doesn’t see end-of-file
    if all clients close the write end of the FIFO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the `SIGPIPE` signal ![](figs/web/U004.png), so that if the server attempts
    to write to a client FIFO that doesn’t have a reader, then, rather than being
    sent a `SIGPIPE` signal (which kills a process by default), it receives an `EPIPE`
    error from the *write()* system call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter a loop that reads and responds to each incoming client request ![](figs/web/U005.png).
    To send the response, the server constructs the name of the client FIFO ![](figs/web/U006.png)
    and then opens that FIFO ![](figs/web/U007.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the server encounters an error in opening the client FIFO, it abandons that
    client’s request ![](figs/web/U008.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of an *iterative server*, in which the server reads and
    handles each client request before going on to handle the next client. An iterative
    server design is suitable when each client request can be quickly processed and
    responded to, so that other client requests are not delayed. An alternative design
    is a *concurrent server*, in which the main server process employs a separate
    child process (or thread) to handle each client request. We discuss server design
    further in [Chapter 60](ch60.html "Chapter 60. Sockets: Server Design").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-7. An iterative server using FIFOs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Client program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 44-8](ch44.html#client_for_the_sequence-number_server "Example 44-8. Client
    for the sequence-number server") is the code for the client. The client performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a FIFO to be used for receiving a response from the server ![](figs/web/U002.png).
    This is done before sending the request, in order to ensure that the FIFO exists
    by the time the server attempts to open it and send a response message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct a message for the server containing the client’s process ID and a
    number (taken from an optional command-line argument) specifying the length of
    the sequence that the client wishes the server to assign to it ![](figs/web/U004.png).
    (If no command-line argument is supplied, the default sequence length is 1.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the server FIFO ![](figs/web/U005.png) and send the message to the server
    ![](figs/web/U006.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the client FIFO ![](figs/web/U007.png), and read and print the server’s
    response ![](figs/web/U008.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only other detail of note is the exit handler ![](figs/web/U001.png), established
    with *atexit()* ![](figs/web/U003.png), which ensures that the client’s FIFO is
    deleted when the process exits. Alternatively, we could have simply placed an
    *unlink()* call immediately after the *open()* of the client FIFO. This would
    work because, at that point, after they have both performed blocking *open()*
    calls, the server and the client would each hold open file descriptors for the
    FIFO, and removing the FIFO name from the file system doesn’t affect these descriptors
    or the open file descriptions to which they refer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what we see when we run the client and server programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Example 44-8. Client for the sequence-number server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Nonblocking I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted earlier, when a process opens one end of a FIFO, it blocks if the
    other end of the FIFO has not yet been opened. Sometimes, it is desirable not
    to block, and for this purpose, the `O_NONBLOCK` flag can be specified when calling
    *open()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the other end of the FIFO is already open, then the `O_NONBLOCK` flag has
    no effect on the *open()* call—it successfully opens the FIFO immediately, as
    usual. The `O_NONBLOCK` flag changes things only if the other end of the FIFO
    is not yet open, and the effect depends on whether we are opening the FIFO for
    reading or writing:'
  prefs: []
  type: TYPE_NORMAL
- en: If the FIFO is being opened for reading, and no process currently has the write
    end of the FIFO open, then the *open()* call succeeds immediately (just as though
    the other end of the FIFO was already open).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the FIFO is being opened FIFO for writing, and the other end of the FIFO
    is not already open for reading, then *open()* fails, setting *errno* to `ENXIO`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asymmetry of the `O_NONBLOCK` flag depending on whether the FIFO is being
    opened for reading or for writing can be explained as follows. It is okay to open
    a FIFO for reading when there is no writer at the other end of the FIFO, since
    any attempt to read from the FIFO simply returns no data. However, attempting
    to write to a FIFO for which there is no reader would result in the generation
    of the `SIGPIPE` signal and an `EPIPE` error from *write()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 44-1](ch44.html#semantics_of_open_open_parenthesis_close "Table 44-1. Semantics
    of open() for a FIFO") summarizes the semantics of opening a FIFO, including the
    effects of `O_NONBLOCK` described above.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-1. Semantics of *open()* for a FIFO
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of *open()* | Result of *open()* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| open for | additional flags | other end of FIFO open | other end of FIFO
    closed |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| reading | none (blocking) | succeeds immediately | blocks |'
  prefs: []
  type: TYPE_TB
- en: '| `O_NONBLOCK` | succeeds immediately | succeeds immediately |'
  prefs: []
  type: TYPE_TB
- en: '| writing | none (blocking) | succeeds immediately | blocks |'
  prefs: []
  type: TYPE_TB
- en: '| `O_NONBLOCK` | succeeds immediately | fails (`ENXIO`) |'
  prefs: []
  type: TYPE_TB
- en: 'Using the `O_NONBLOCK` flag when opening a FIFO serves two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows a single process to open both ends of a FIFO. The process first opens
    the FIFO for reading specifying `O_NONBLOCK`, and then opens the FIFO for writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prevents deadlocks between processes opening two FIFOs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *deadlock* is a situation where two or more process are blocked because each
    is waiting on the other process(es) to complete some action. The two processes
    shown in [Figure 44-8](ch44.html#deadlock_between_processes_opening_two_f "Figure 44-8. Deadlock
    between processes opening two FIFOs") are deadlocked. Each process is blocked
    waiting to open a FIFO for reading. This blocking would not happen if each process
    could perform its second step (opening the other FIFO for writing). This particular
    deadlock problem could be solved by reversing the order of steps 1 and 2 in process
    Y, while leaving the order in process X unchanged, or vice versa. However, such
    an arrangement of steps may not be easy to achieve in some applications. Instead,
    we can resolve the problem by having either process, or both, specify the `O_NONBLOCK`
    flag when opening the FIFOs for reading.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deadlock between processes opening two FIFOs](figs/web/44-8_PIPE-deadlock-scale90.png.jpg)Figure 44-8. Deadlock
    between processes opening two FIFOs'
  prefs: []
  type: TYPE_NORMAL
- en: Nonblocking *read()* and *write()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `O_NONBLOCK` flag affects not only the semantics of *open()* but also—because
    the flag then remains set for the open file description—the semantics of subsequent
    *read()* and *write()* calls. We describe these effects in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to change the state of the `O_NONBLOCK` flag for a FIFO
    (or another type of file) that is already open. Scenarios where this need may
    arise include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We opened a FIFO using `O_NONBLOCK`, but we want subsequent *read()* and *write()*
    calls to operate in blocking mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to enable nonblocking mode for a file descriptor that was returned by
    *pipe()*. More generally, we might want to change the nonblocking status of any
    file descriptor that was obtained other than from a call to *open()*—for example,
    one of the three standard descriptors that are automatically opened for each new
    program run by the shell or a file descriptor returned by *socket()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some application-specific purpose, we need to switch the setting of the
    `O_NONBLOCK` setting of a file descriptor on and off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these purposes, we can use *fcntl()* to enable or disable the `O_NONBLOCK`
    open file status flag. To enable the flag, we write the following (omitting error
    checking):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And to disable it, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Semantics of *read()* and *write()* on Pipes and FIFOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 44-2](ch44.html#semantics_of_reading_n_bytes_from_a_pipe "Table 44-2. Semantics
    of reading n bytes from a pipe or FIFO containing p bytes") summarizes the operation
    of *read()* for pipes and FIFOs, and includes the effect of the `O_NONBLOCK` flag.'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between blocking and nonblocking reads occurs when no data
    is present and the write end is open. In this case, a normal *read()* blocks,
    while a nonblocking *read()* fails with the error `EAGAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-2. Semantics of reading *n* bytes from a pipe or FIFO containing *p*
    bytes
  prefs: []
  type: TYPE_NORMAL
- en: '| `O_NONBLOCK` enabled? | Data bytes available in pipe or FIFO (*p*) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *p = 0*, write end open | *p = 0*, write end closed | *p < n* | *p >= n*
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | block | return 0 (EOF) | read *p* bytes | read *n* bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | fail (`EAGAIN`) | return 0 (EOF) | read *p* bytes | read *n* bytes
    |'
  prefs: []
  type: TYPE_TB
- en: The impact of the `O_NONBLOCK` flag when writing to a pipe or FIFO is made complex
    by interactions with the `PIPE_BUF` limit. The *write()* behavior is summarized
    in [Table 44-3](ch44.html#semantics_of_writing_n_bytes_to_a_pipe_o "Table 44-3. Semantics
    of writing n bytes to a pipe or FIFO").
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-3. Semantics of writing *n* bytes to a pipe or FIFO
  prefs: []
  type: TYPE_NORMAL
- en: '| `O_NONBLOCK` enabled? | Read end open | Read end closed |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *n <= PIPE_BUF* | *n > PIPE_BUF* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | Atomically write *n* bytes; may block until sufficient data is read
    for *write()* to be performed | Write *n* bytes; may block until sufficient data
    read for *write()* to complete; data may be interleaved with writes by other processes
    | `SIGPIPE`+`EPIPE` |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | If sufficient space is available to immediately write *n* bytes, then
    *write()* succeeds atomically; otherwise, it fails (`EAGAIN`) | If there is sufficient
    space to immediately write some bytes, then write between 1 and *n* bytes (which
    may be interleaved with data written by other processes); otherwise, *write()*
    fails (`EAGAIN`) |'
  prefs: []
  type: TYPE_TB
- en: The `O_NONBLOCK` flag causes a *write()* on a pipe or FIFO to fail (with the
    error `EAGAIN`) in any case where data can’t be transferred immediately. This
    means that if we are writing up to `PIPE_BUF` bytes, then the *write()* will fail
    if there is not sufficient space in the pipe or FIFO, because the kernel can’t
    complete the operation immediately and can’t perform a partial write, since that
    would break the requirement that writes of up to `PIPE_BUF` bytes are atomic.
  prefs: []
  type: TYPE_NORMAL
- en: When writing more than `PIPE_BUF` bytes at a time, a write is not required to
    be atomic. For this reason, *write()* transfers as many bytes as possible (a partial
    write) to fill up the pipe or FIFO. In this case, the return value from *write()*
    is the number of bytes actually transferred, and the caller must retry later in
    order to write the remaining bytes. However, if the pipe or FIFO is full, so that
    not even one byte can be transferred, then *write()* fails with the error `EAGAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pipes were the first method of IPC under the UNIX system, and they are used
    frequently by the shell, as well as in other applications. A pipe is a unidirectional,
    limited-capacity byte stream that can be used for communication between related
    processes. Although blocks of data of any size can be written to a pipe, only
    writes that do not exceed `PIPE_BUF` bytes are guaranteed to be atomic. As well
    as being used as a method of IPC, pipes can also be used for process synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: When using pipes, we must be careful to close unused descriptors in order to
    ensure that reading processes detect end-of-file and writing processes receive
    the `SIGPIPE` signal or the `EPIPE` error. (Usually, it is easiest to have the
    application writing to a pipe ignore `SIGPIPE` and detect a “broken” pipe via
    the `EPIPE` error.)
  prefs: []
  type: TYPE_NORMAL
- en: The *popen()* and *pclose()* functions allow a program to transfer data to or
    from a standard shell command, without needing to handle the details of creating
    a pipe, execing a shell, and closing unused file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: FIFOs operate in exactly the same way as pipes, except that they are created
    using *mkfifo()*, have a name in the file system, and can be opened by any process
    with appropriate permissions. By default, opening a FIFO for reading blocks until
    another process opens the FIFO for writing, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of this chapter, we looked at a number of related topics. First,
    we saw how to duplicate file descriptors in such a manner that the standard input
    or output of a filter can be bound to a pipe. While presenting a client-server
    example using FIFOs, we touched on a number of topics in client-server design,
    including the use of a well-known address for a server and iterative versus concurrent
    server design. In developing the example FIFO application, we noted that, although
    data transmitted through a pipe is a byte stream, it is sometimes useful for communicating
    processes to package the data into messages, and we looked at various ways in
    which this could be accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we noted the effect of the `O_NONBLOCK` (nonblocking I/O) flag when
    opening and performing I/O on a FIFO. The `O_NONBLOCK` flag is useful if we don’t
    want to block while opening a FIFO. It is also useful if we don’t want reads to
    block if no data is available, or writes to block if there is insufficient space
    within a pipe or FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The implementation of pipes is discussed in [Bach, 1986] and [Bovet & Cesati,
    2005]. Useful details about pipes and FIFOs can also be found in [Vahalia, 1996].
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program that uses two pipes to enable bidirectional communication between
    a parent and child process. The parent process should loop reading a block of
    text from standard input and use one of the pipes to send the text to the child,
    which converts it to uppercase and sends it back to the parent via the other pipe.
    The parent reads the data coming back from the child and echoes it on standard
    output before continuing around the loop once more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement *popen()* and *pclose()*. Although these functions are simplified
    by not requiring the signal handling employed in the implementation of *system()*
    ([Implementing *system()*](ch27.html#implementing_system_open_parenthesis_clo
    "Implementing system()")), you will need to be careful to correctly bind the pipe
    ends to file streams in each process, and to ensure that all unused descriptors
    referring to the pipe ends are closed. Since children created by multiple calls
    to *popen()* may be running at one time, you will need to maintain a data structure
    that associates the file stream pointers allocated by *popen()* with the corresponding
    child process IDs. (If using an array for this purpose, the value returned by
    the *fileno()* function, which obtains the file descriptor corresponding to a
    file stream, can be used to index the array.) Obtaining the correct process ID
    from this structure will allow *pclose()* to select the child upon which to wait.
    This structure will also assist with the SUSv3 requirement that any still-open
    file streams created by earlier calls to *popen()* must be closed in the new child
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) always starts assigning
    sequence numbers from 0 each time it is started. Modify the program to use a backup
    file that is updated each time a sequence number is assigned. (The *open()* `O_SYNC`
    flag, described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"), may be useful.) At startup, the
    program should check for the existence of this file, and if it is present, use
    the value it contains to initialize the sequence number. If the backup file can’t
    be found on startup, the program should create a new file and start assigning
    sequence numbers beginning at 0\. (An alternative to this technique would be to
    use memory-mapped files, described in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings").)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to the server in [Example 44-7](ch44.html#an_iterative_server_using_fifos
    "Example 44-7. An iterative server using FIFOs") (`fifo_seqnum_server.c`) so that
    if the program receives the `SIGINT` or `SIGTERM` signals, it removes the server
    FIFO and terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) performs a second `O_WRONLY`
    open of the FIFO so that it never sees end-of-file when reading from the reading
    descriptor (*serverFd*) of the FIFO. Instead of doing this, an alternative approach
    could be tried: whenever the server sees end-of-file on the reading descriptor,
    it closes the descriptor, and then once more opens the FIFO for reading. (This
    open would block until the next client opened the FIFO for writing.) What is wrong
    with this approach?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) assumes that the client
    process is well behaved. If a misbehaving client created a client FIFO and sent
    a request to the server, but did not open its FIFO, then the server’s attempt
    to open the client FIFO would block, and other client’s requests would be indefinitely
    delayed. (If done maliciously, this would constitute a *denial-of-service attack*.)
    Devise a scheme to deal with this problem. Extend the server (and possibly the
    client in [Example 44-8](ch44.html#client_for_the_sequence-number_server "Example 44-8. Client
    for the sequence-number server")) accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write programs to verify the operation of nonblocking opens and nonblocking
    I/O on FIFOs (see [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1 "Nonblocking
    I/O")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
