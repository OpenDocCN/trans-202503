- en: Chapter 44. Pipes and FIFOs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 44 章. 管道和 FIFO
- en: 'This chapter describes pipes and FIFOs. Pipes are the oldest method of IPC
    on the UNIX system, having appeared in Third Edition UNIX in the early 1970s.
    Pipes provide an elegant solution to a frequent requirement: having created two
    processes to run different programs (commands), how can the shell allow the output
    produced by one process to be used as the input to the other process? Pipes can
    be used to pass data between related processes (the meaning of *related* will
    become clear later). FIFOs are a variation on the pipe concept. The important
    difference is that FIFOs can be used for communication between *any* processes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了管道和 FIFO。管道是 UNIX 系统中最早的进程间通信方法，早在 1970 年代初的 UNIX 第三版中就已出现。管道为一个常见需求提供了优雅的解决方案：在创建了两个进程以运行不同程序（命令）后，shell
    如何让一个进程产生的输出作为另一个进程的输入？管道可以用于在相关进程之间传递数据（*相关*的含义将在后面明确）。FIFO 是管道概念的变种。重要的区别是，FIFO
    可以用于 *任何* 进程之间的通信。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'Every user of the shell is familiar with the use of pipes in commands such
    as the following, which counts the number of files in a directory:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 shell 用户都熟悉使用管道的命令，例如下面的命令，用于计算目录中包含的文件数量：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to execute the above command, the shell creates two processes, executing
    *ls* and *wc*, respectively. (This is done using *fork()* and *exec()*, which
    are described in [Chapter 24](ch24.html "Chapter 24. Process Creation") and [Chapter 27](ch27.html
    "Chapter 27. Program Execution").) [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") shows how the two processes
    employ the pipe.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行上述命令，shell 创建了两个进程，分别执行 *ls* 和 *wc*。 （这是通过 *fork()* 和 *exec()* 完成的，相关内容在[第
    24 章](ch24.html "第 24 章. 进程创建")和[第 27 章](ch27.html "第 27 章. 程序执行")中有介绍。）[图 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "图 44-1. 使用管道连接两个进程")展示了这两个进程如何使用管道。
- en: Among other things, [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") is intended to illustrate
    how pipes got their name. We can think of a pipe as a piece of plumbing that allows
    data to flow from one process to another.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 44-1](ch44.html#using_a_pipe_to_connect_two_processes "图 44-1. 使用管道连接两个进程")的目的之一是说明管道名称的由来。我们可以把管道想象成一段管道，它允许数据从一个进程流向另一个进程。'
- en: '![Using a pipe to connect two processes](figs/web/44-1_PIPE-overview-scale90.png.jpg)Figure 44-1. Using
    a pipe to connect two processes'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用管道连接两个进程](figs/web/44-1_PIPE-overview-scale90.png.jpg)图 44-1. 使用管道连接两个进程'
- en: One point to note in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes") is that the two processes
    are connected to the pipe so that the writing process (*ls*) has its standard
    output (file descriptor 1) joined to the write end of the pipe, while the reading
    process (*wc*) has its standard input (file descriptor 0) joined to the read end
    of the pipe. In effect, these two processes are unaware of the existence of the
    pipe; they just read from and write to the standard file descriptors. The shell
    must do some work in order to set things up in this way, and we see how this is
    done in Section 44.4.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 44-1](ch44.html#using_a_pipe_to_connect_two_processes "图 44-1. 使用管道连接两个进程")中需要注意的一点是，两个进程通过管道连接，使得写入进程（*ls*）的标准输出（文件描述符
    1）与管道的写入端相连接，而读取进程（*wc*）的标准输入（文件描述符 0）则与管道的读取端相连接。实际上，这两个进程并不知晓管道的存在；它们只不过是从标准文件描述符读取和写入数据而已。为了实现这种设置，shell
    必须做一些工作，我们将在第 44.4 节看到如何实现这一点。
- en: In the following paragraphs, we cover a number of important characteristics
    of pipes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将介绍管道的一些重要特性。
- en: A pipe is a byte stream
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道是一个字节流
- en: When we say that a pipe is a byte stream, we mean that there is no concept of
    messages or message boundaries when using a pipe. The process reading from a pipe
    can read blocks of data of any size, regardless of the size of blocks written
    by the writing process. Furthermore, the data passes through the pipe sequentially—bytes
    are read from a pipe in exactly the order they were written. It is not possible
    to randomly access the data in a pipe using *lseek()*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说管道是一个字节流时，我们的意思是使用管道时并没有消息或消息边界的概念。读取管道的进程可以读取任意大小的数据块，而不考虑写入进程写入的数据块大小。此外，数据会按顺序通过管道——字节会按照它们写入的顺序从管道中读取。不能使用
    *lseek()* 随机访问管道中的数据。
- en: If we want to implement the notion of discrete messages in a pipe, we must do
    this within our application. While this is feasible (refer to [A Client-Server
    Application Using FIFOs](ch44.html#a_client-server_application_using_fifos "A
    Client-Server Application Using FIFOs")), it may be preferable to use alternative
    IPC mechanisms, such as message queues and datagram sockets, which we discuss
    in later chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在管道中实现离散消息的概念，必须在我们的应用程序中进行实现。虽然这是可行的（参考[使用FIFO的客户端-服务器应用程序](ch44.html#a_client-server_application_using_fifos
    "使用FIFO的客户端-服务器应用程序")），但使用其他的IPC机制（如消息队列和数据报套接字）可能更为合适，我们将在后续章节中讨论这些。
- en: Reading from a pipe
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从管道中读取数据
- en: Attempts to read from a pipe that is currently empty block until at least one
    byte has been written to the pipe. If the write end of a pipe is closed, then
    a process reading from the pipe will see end-of-file (i.e., *read()* returns 0)
    once it has read all remaining data in the pipe.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试从当前为空的管道读取数据，读取操作会阻塞，直到至少有一个字节被写入管道。如果管道的写入端已关闭，则在进程读取完管道中的所有剩余数据后，会看到文件结束（即，*read()*返回0）。
- en: Pipes are unidirectional
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道是单向的
- en: Data can travel only in one direction through a pipe. One end of the pipe is
    used for writing, and the other end is used for reading.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据只能在管道中单向传输。管道的一端用于写入，另一端用于读取。
- en: 'On some other UNIX implementations—notably those derived from System V Release
    4—pipes are bidirectional (so-called *stream pipes*). Bidirectional pipes are
    not specified by any UNIX standards, so that, even on implementations where they
    are provided, it is best to avoid reliance on their semantics. As an alternative,
    we can use UNIX domain stream socket pairs (created using the *socketpair()* system
    call described in [Creating a Connected Socket Pair: *socketpair()*](ch57.html#creating_a_connected_socket_pair_colon_s
    "Creating a Connected Socket Pair: socketpair()")), which provide a standardized
    bidirectional communication mechanism that is semantically equivalent to stream
    pipes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些其他UNIX实现中——特别是那些衍生自System V Release 4的实现——管道是双向的（即所谓的*流管道*）。双向管道并未被任何UNIX标准规定，因此即使在提供双向管道的实现中，也最好避免依赖其语义。作为替代，我们可以使用UNIX域流套接字对（通过*socketpair()*系统调用创建，详见[创建一个连接的套接字对：*socketpair()*](ch57.html#creating_a_connected_socket_pair_colon_s
    "创建一个连接的套接字对：socketpair()")），它提供了一种标准化的双向通信机制，其语义等同于流管道。
- en: Writes of up to `PIPE_BUF` bytes are guaranteed to be atomic
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入不超过`PIPE_BUF`字节的数据保证是原子的
- en: If multiple processes are writing to a single pipe, then it is guaranteed that
    their data won’t be intermingled if they write no more than `PIPE_BUF` bytes at
    a time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个进程向同一个管道写入数据，则可以保证，如果它们每次写入的数据不超过`PIPE_BUF`字节，数据不会互相交错。
- en: SUSv3 requires that `PIPE_BUF` be at least `_POSIX_PIPE_BUF` (512). An implementation
    should define `PIPE_BUF` (in `<limits.h>`) and/or allow the call *fpathconf(fd,
    _PC_PIPE_BUF)* to return the actual upper limit for atomic writes. `PIPE_BUF`
    varies across UNIX implementations; for example, it is 512 bytes on FreeBSD 6.0,
    4096 bytes on Tru64 5.1, and 5120 bytes on Solaris 8\. On Linux, `PIPE_BUF` has
    the value 4096.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求`PIPE_BUF`至少为`_POSIX_PIPE_BUF`（512）。一个实现应该在`<limits.h>`中定义`PIPE_BUF`，并/或允许调用*fpathconf(fd,
    _PC_PIPE_BUF)*来返回实际的原子写入上限。`PIPE_BUF`在不同的UNIX实现中有所不同；例如，在FreeBSD 6.0中为512字节，在Tru64
    5.1中为4096字节，在Solaris 8中为5120字节。在Linux中，`PIPE_BUF`的值为4096。
- en: When writing blocks of data larger than `PIPE_BUF` bytes to a pipe, the kernel
    may transfer the data in multiple smaller pieces, appending further data as the
    reader removes bytes from the pipe. (The *write()* call blocks until all of the
    data has been written to the pipe.) When there is only a single process writing
    to a pipe (the usual case), this doesn’t matter. However, if there are multiple
    writer processes, then writes of large blocks may be broken into segments of arbitrary
    size (which may be smaller than `PIPE_BUF` bytes) and interleaved with writes
    by other processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当向管道写入大于`PIPE_BUF`字节的数据块时，内核可能会将数据分成多个较小的部分进行传输，并在读取器从管道中移除字节时追加更多数据。（*write()*
    调用会阻塞，直到所有数据都已写入管道。）当只有单个进程向管道写入数据时（即通常情况），这不会有问题。然而，如果有多个写入进程，则较大的数据块写入可能会被拆分成任意大小的段（这些段可能小于`PIPE_BUF`字节），并与其他进程的写入交织在一起。
- en: The `PIPE_BUF` limit affects exactly when data is transferred to the pipe. When
    writing up to `PIPE_BUF` bytes, *write()* will block if necessary until sufficient
    space is available in the pipe so that it can complete the operation atomically.
    When more than `PIPE_BUF` bytes are being written, *write()* transfers as much
    data as possible to fill the pipe, and then blocks until data has been removed
    from the pipe by some reading process. If such a blocked *write()* is interrupted
    by a signal handler, then the call unblocks and returns a count of the number
    of bytes successfully transferred, which will be less than was requested (a so-called
    *partial write*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`PIPE_BUF` 限制决定数据何时传输到管道。当写入不超过 `PIPE_BUF` 字节时，*write()* 会在必要时阻塞，直到管道中有足够的空间以便可以原子性地完成操作。当写入超过
    `PIPE_BUF` 字节时，*write()* 会尽可能多地将数据写入管道，然后阻塞，直到有读取进程从管道中移除数据。如果这样的阻塞 *write()*
    被信号处理程序中断，则该调用会解除阻塞并返回成功传输的字节数，这个字节数将小于请求的字节数（所谓的 *部分写入*）。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux 2.2, pipe writes of *any* size are atomic, unless interrupted by a
    signal handler. On Linux 2.4 and later, any write greater than `PIPE_BUF` bytes
    may be interleaved with writes by other processes. (The kernel code implementing
    pipes underwent substantial changes between kernel versions 2.2 and 2.4.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.2 上，*任何*大小的管道写入都是原子的，除非被信号处理程序中断。在 Linux 2.4 及更高版本中，任何大于 `PIPE_BUF`
    字节的写入可能会与其他进程的写入交错进行。（在 2.2 和 2.4 版本之间，管道实现的内核代码经历了显著的变化。）
- en: Pipes have a limited capacity
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道有一个有限的容量
- en: A pipe is simply a buffer maintained in kernel memory. This buffer has a maximum
    capacity. Once a pipe is full, further writes to the pipe block until the reader
    removes some data from the pipe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 管道只是内核内存中维护的一个缓冲区。这个缓冲区有一个最大容量。一旦管道满了，进一步写入管道会阻塞，直到读取进程从管道中移除一些数据。
- en: SUSv3 makes no requirement about the capacity of a pipe. In Linux kernels before
    2.6.11, the pipe capacity is the same as the system page size (e.g., 4096 bytes
    on x86-32); since Linux 2.6.11, the pipe capacity is 65,536 bytes. Other UNIX
    implementations have different pipe capacities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 对管道容量没有要求。在 2.6.11 之前的 Linux 内核中，管道容量与系统页面大小相同（例如，x86-32 上为 4096 字节）；从
    Linux 2.6.11 开始，管道容量为 65,536 字节。其他 UNIX 实现的管道容量各不相同。
- en: In general, an application never needs to know the exact capacity of a pipe.
    If we want to prevent the writer process(es) from blocking, the process(es) reading
    from the pipe should be designed to read data as soon as it is available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用程序不需要知道管道的确切容量。如果我们想防止写入进程阻塞，则应设计读取管道的进程，以便在数据可用时立即读取。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In theory, there is no reason why a pipe couldn’t operate with smaller capacities,
    even with a single-byte buffer. The reason for employing large buffer sizes is
    efficiency: each time a writer fills the pipe, the kernel must perform a context
    switch to allow the reader to be scheduled so that it can empty some data from
    the pipe. Employing a larger buffer size means that fewer context switches are
    required.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，管道可以使用更小的容量来操作，甚至是一个字节的缓冲区。采用大缓冲区的原因是效率：每次写入进程填满管道时，内核必须执行上下文切换，以允许调度读取进程，从而让它能从管道中清除一些数据。使用更大的缓冲区意味着需要更少的上下文切换。
- en: Starting with Linux 2.6.35, the capacity of a pipe can be modified. The Linux-specific
    call *fcntl(fd, F_SETPIPE_SZ, size)* changes the capacity of the pipe referred
    to by *fd* to be at least *size* bytes. An unprivileged process can change the
    pipe capacity to any value in the range from the system page size up to the value
    in `/proc/sys/fs/pipe-max-size`. The default value for `pipe-max-size` is 1,048,576
    bytes. A privileged (`CAP_SYS_RESOURCE`) process can override this limit. When
    allocating space for the pipe, the kernel may round *size* up to some value convenient
    for the implementation. The *fcntl(fd, F_GETPIPE_SZ)* call returns the actual
    size allocated for the pipe.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 2.6.35 开始，管道的容量可以修改。Linux 特有的调用 *fcntl(fd, F_SETPIPE_SZ, size)* 将管道
    *fd* 的容量更改为至少 *size* 字节。一个非特权进程可以将管道容量更改为从系统页面大小到 `/proc/sys/fs/pipe-max-size`
    中的任何值。`pipe-max-size` 的默认值是 1,048,576 字节。具有特权的（`CAP_SYS_RESOURCE`）进程可以覆盖此限制。在为管道分配空间时，内核可能会将
    *size* 向上舍入到某个方便实现的值。*fcntl(fd, F_GETPIPE_SZ)* 调用返回为管道分配的实际大小。
- en: Creating and Using Pipes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用管道
- en: The *pipe()* system call creates a new pipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*pipe()* 系统调用创建一个新的管道。'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: 'A successful call to *pipe()* returns two open file descriptors in the array
    *filedes*: one for the read end of the pipe (*filedes[0]*) and one for the write
    end (*filedes[1]*).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用*pipe()*会返回一个包含两个打开文件描述符的数组*filedes*：一个用于管道的读端（*filedes[0]*），另一个用于写端（*filedes[1]*）。
- en: As with any file descriptor, we can use the *read()* and *write()* system calls
    to perform I/O on the pipe. Once written to the write end of a pipe, data is immediately
    available to be read from the read end. A *read()* from a pipe obtains the lesser
    of the number of bytes requested and the number of bytes currently available in
    the pipe (but blocks if the pipe is empty).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何文件描述符一样，我们可以使用*read()*和*write()*系统调用对管道进行I/O操作。写入管道的写入端的数据会立即可供从读端读取。*read()*从管道读取时会获取请求的字节数和管道中当前可用字节数中的较小者（如果管道为空，则会阻塞）。
- en: We can also use the *stdio* functions (*printf()*, *scanf()*, and so on) with
    pipes by first using *fdopen()* to obtain a file stream corresponding to one of
    the descriptors in *filedes* ([Mixing Library Functions and System Calls for File
    I/O](ch13.html#mixing_library_functions_and_system_call "Mixing Library Functions
    and System Calls for File I/O")). However, when doing this, we must be aware of
    the *stdio* buffering issues described in Section 44.6.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过首先使用*fdopen()*来获取与*filedes*中的一个描述符对应的文件流，进而使用*stdio*函数（*printf()*, *scanf()*等）与管道一起使用（[混合库函数和系统调用进行文件I/O](ch13.html#mixing_library_functions_and_system_call
    "混合库函数和系统调用进行文件I/O")）。然而，在这样做时，我们必须注意第44.6节中描述的*stdio*缓冲问题。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call *ioctl(fd, FIONREAD, &cnt)* returns the number of unread bytes in the
    pipe or FIFO referred to by the file descriptor *fd*. This feature is also available
    on some other implementations, but is not specified in SUSv3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*ioctl(fd, FIONREAD, &cnt)*返回管道或FIFO中未读取的字节数，该管道或FIFO由文件描述符*fd*引用。这个功能在一些其他实现中也可用，但在SUSv3中没有指定。
- en: '[Figure 44-2](ch44.html#process_file_descriptors_after_creating "Figure 44-2. Process
    file descriptors after creating a pipe") shows the situation after a pipe has
    been created by *pipe()*, with the calling process having file descriptors referring
    to each end.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图44-2](ch44.html#process_file_descriptors_after_creating "图44-2. 创建管道后的进程文件描述符")显示了通过*pipe()*创建管道后的情况，其中调用进程拥有指向每一端的文件描述符。'
- en: '![Process file descriptors after creating a pipe](figs/web/44-2_PIPE-creation-scale90.png.jpg)Figure 44-2. Process
    file descriptors after creating a pipe'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建管道后的进程文件描述符](figs/web/44-2_PIPE-creation-scale90.png.jpg)图44-2. 创建管道后的进程文件描述符'
- en: A pipe has few uses within a single process (we consider one in [The Self-Pipe
    Trick](ch63.html#the_self-pipe_trick "The Self-Pipe Trick")). Normally, we use
    a pipe to allow communication between two processes. To connect two processes
    using a pipe, we follow the *pipe()* call with a call to *fork()*. During a *fork()*,
    the child process inherits copies of its parent’s file descriptors ([File Sharing
    Between Parent and Child](ch24.html#file_sharing_between_parent_and_child "File
    Sharing Between Parent and Child")), bringing about the situation shown on the
    left side of [Figure 44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from "Figure 44-3. Setting
    up a pipe to transfer data from a parent to a child").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个进程内，管道的用途很少（我们在[自管道技巧](ch63.html#the_self-pipe_trick "自管道技巧")中讨论了一个例子）。通常，我们使用管道来允许两个进程之间的通信。要使用管道连接两个进程，我们需要在*pipe()*调用后紧接着调用*fork()*。在*fork()*过程中，子进程会继承父进程的文件描述符副本（[父子进程之间的文件共享](ch24.html#file_sharing_between_parent_and_child
    "父子进程之间的文件共享")），从而导致如[图44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from
    "图44-3. 设置管道将数据从父进程传输到子进程")左侧所示的情况。
- en: '![Setting up a pipe to transfer data from a parent to a child](figs/web/44-3_PIPE-after-fork-scale90.png.jpg)Figure 44-3. Setting
    up a pipe to transfer data from a parent to a child'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置管道将数据从父进程传输到子进程](figs/web/44-3_PIPE-after-fork-scale90.png.jpg)图44-3. 设置管道将数据从父进程传输到子进程'
- en: While it is possible for the parent and child to both read from and write to
    the pipe, this is not usual. Therefore, immediately after the *fork()*, one process
    closes its descriptor for the write end of the pipe, and the other closes its
    descriptor for the read end. For example, if the parent is to send data to the
    child, then it would close its read descriptor for the pipe, *filedes[0]*, while
    the child would close its write descriptor for the pipe, *filedes[1]*, bringing
    about the situation shown on the right side of [Figure 44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from
    "Figure 44-3. Setting up a pipe to transfer data from a parent to a child"). The
    code to create this setup is shown in [Example 44-1](ch44.html#steps_in_creating_a_pipe_to_transfer_dat
    "Example 44-1. Steps in creating a pipe to transfer data from a parent to a child").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管父进程和子进程都可以读写管道，但这种情况并不常见。因此，在*fork()*调用后，一个进程会关闭管道写端的描述符，另一个则关闭管道读端的描述符。例如，如果父进程要向子进程发送数据，那么父进程会关闭管道的读描述符，*filedes[0]*，而子进程则会关闭管道的写描述符，*filedes[1]*，从而形成[图 44-3](ch44.html#setting_up_a_pipe_to_transfer_data_from
    "图 44-3. 设置管道以将数据从父进程传输到子进程")右侧所示的情况。创建该设置的代码见[示例 44-1](ch44.html#steps_in_creating_a_pipe_to_transfer_dat
    "示例 44-1. 创建管道以将数据从父进程传输到子进程")。
- en: Example 44-1. Steps in creating a pipe to transfer data from a parent to a child
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 44-1. 创建管道以将数据从父进程传输到子进程的步骤
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'One reason that it is not usual to have both the parent and child reading from
    a single pipe is that if two processes try to simultaneously read from a pipe,
    we can’t be sure which process will be the first to succeed—the two processes
    race for data. Preventing such races would require the use of some synchronization
    mechanism. However, if we require bidirectional communication, there is a simpler
    way: just create two pipes, one for sending data in each direction between the
    two processes. (If employing this technique, then we need to be wary of deadlocks
    that may occur if both processes block while trying to read from empty pipes or
    while trying to write to pipes that are already full.)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程和子进程同时从单一管道中读取数据并不常见，原因之一是，如果两个进程试图同时读取管道中的数据，我们无法确定哪个进程会第一个成功——这两个进程争夺数据。为了防止这种竞争条件，通常需要使用某种同步机制。然而，如果我们需要双向通信，有一种更简单的方法：创建两个管道，每个方向一个，用于在两个进程之间传输数据。（如果采用这种方法，我们需要警惕死锁问题，尤其是当两个进程在尝试从空管道读取数据或尝试写入已满管道时发生阻塞。）
- en: While it is possible to have multiple processes writing to a pipe, it is typical
    to have only a single writer. (We show one example of where it is useful to have
    multiple writers to a pipe in Section 44.3.) By contrast, there are situations
    where it can be useful to have multiple writers on a FIFO, and we see an example
    of this in Section 44.8.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多个进程可以向管道写入数据，但通常情况下只有一个写入者。（在第44.3节中，我们展示了一个多写入者的管道应用示例。）相反，在某些情况下，多个写入者对FIFO队列的使用是有益的，相关示例见第44.8节。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.27, Linux supports a new, nonstandard system call,
    *pipe2()*. This system call performs the same task as *pipe()*, but supports an
    additional argument, *flags*, that can be used to modify the behavior of the system
    call. Two flags are supported. The `O_CLOEXEC` flag causes the kernel to enable
    the close-on-exec flag (`FD_CLOEXEC`) for the two new file descriptors. This flag
    is useful for the same reasons as the *open()* `O_CLOEXEC` flag described in [File
    descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The `O_NONBLOCK` flag causes the
    kernel to mark both underlying open file descriptions as nonblocking, so that
    future I/O operations will be nonblocking. This saves additional calls to *fcntl()*
    to achieve the same result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本2.6.27开始，Linux支持一个新的非标准系统调用，*pipe2()*。该系统调用执行与*pipe()*相同的任务，但支持一个额外的参数，*flags*，可以用来修改系统调用的行为。支持两种标志。`O_CLOEXEC`标志使内核为两个新的文件描述符启用执行时关闭标志（`FD_CLOEXEC`）。这个标志的用途与[文件描述符号返回的*open()*](ch04.html#file_descriptor_number_returned_by-id1
    "文件描述符号返回的open()")中的*open()* `O_CLOEXEC`标志相同。`O_NONBLOCK`标志使内核将两个底层打开的文件描述符标记为非阻塞，因此以后的I/O操作将是非阻塞的。这避免了额外调用*fcntl()*来实现相同的结果。
- en: Pipes allow communication between related processes
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道允许相关进程之间的通信
- en: In the discussion so far, we have talked about using pipes for communication
    between a parent and a child process. However, pipes can be used for communication
    between any two (or more) related processes, as long as the pipe was created by
    a common ancestor before the series of *fork()* calls that led to the existence
    of the processes. (This is what we meant when we referred to *related processes*
    at the beginning of this chapter.) For example, a pipe could be used for communication
    between a process and its grandchild. The first process creates the pipe, and
    then forks a child that in turn forks to yield the grandchild. A common scenario
    is that a pipe is used for communication between two siblings—their parent creates
    the pipe, and then creates the two children. This is what the shell does when
    building a pipeline.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的讨论，我们谈到了使用管道进行父子进程之间的通信。然而，管道也可以用于任何两个（或更多）相关进程之间的通信，只要管道是在一系列*fork()*
    调用之前由共同的祖先进程创建的。（这就是我们在本章开始时提到的*相关进程*的含义。）例如，管道可以用于进程与其孙子进程之间的通信。第一个进程创建管道，然后派生一个子进程，该子进程再派生出孙子进程。一个常见的场景是管道用于两个兄弟进程之间的通信——它们的父进程创建管道，然后创建这两个子进程。这正是
    shell 在构建管道时所做的。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is an exception to the statement that pipes can be used to communicate
    only between related processes. Passing a file descriptor over a UNIX domain socket
    (a technique that we briefly describe in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors")) makes it possible to pass a file descriptor for a
    pipe to an unrelated process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外，关于管道只能在相关进程之间通信的说法。通过 UNIX 域套接字传递文件描述符（这是我们在[传递文件描述符](ch61.html#passing_file_descriptors
    "Passing File Descriptors")中简要描述的技术）使得可以将管道的文件描述符传递给一个不相关的进程。
- en: Closing unused pipe file descriptors
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭未使用的管道文件描述符
- en: Closing unused pipe file descriptors is more than a matter of ensuring that
    a process doesn’t exhaust its limited set of file descriptors—it is essential
    to the correct use of pipes. We now consider why the unused file descriptors for
    both the read and write ends of the pipe must be closed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭未使用的管道文件描述符不仅仅是确保进程不会耗尽其有限的文件描述符集的问题——它对管道的正确使用至关重要。我们现在来讨论为什么管道的读写端未使用的文件描述符必须被关闭。
- en: The process reading from the pipe closes its write descriptor for the pipe,
    so that, when the other process completes its output and closes its write descriptor,
    the reader sees end-of-file (once it has read any outstanding data in the pipe).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道读取的进程会关闭其管道的写入描述符，这样，当另一个进程完成输出并关闭其写入描述符时，读取进程就会看到文件结束符（只要它读取了管道中所有未读的数据）。
- en: If the reading process doesn’t close the write end of the pipe, then, after
    the other process closes its write descriptor, the reader won’t see end-of-file,
    even after it has read all data from the pipe. Instead, a *read()* would block
    waiting for data, because the kernel knows that there is still at least one write
    descriptor open for the pipe. That this descriptor is held open by the reading
    process itself is irrelevant; in theory, that process could still write to the
    pipe, even if it is blocked trying to read. For example, the *read()* might be
    interrupted by a signal handler that writes data to the pipe. (This is a realistic
    scenario, as we’ll see in [The Self-Pipe Trick](ch63.html#the_self-pipe_trick
    "The Self-Pipe Trick").)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取进程没有关闭管道的写入端，那么，在另一个进程关闭其写入描述符后，读取进程即使已经从管道中读取了所有数据，仍然不会看到文件结束符。相反，*read()*
    会阻塞，等待数据，因为内核知道管道仍然至少有一个写入描述符是打开的。该描述符由读取进程本身持有并不重要；理论上，即使读取进程被阻塞在读取操作上，它仍然可以向管道写入数据。例如，*read()*
    可能会被一个信号处理程序中断，该信号处理程序会向管道写入数据。（这是一个现实的场景，正如我们在[自管道技巧](ch63.html#the_self-pipe_trick
    "The Self-Pipe Trick")中将看到的那样。）
- en: The writing process closes its read descriptor for the pipe for a different
    reason. When a process tries to write to a pipe for which no process has an open
    read descriptor, the kernel sends the `SIGPIPE` signal to the writing process.
    By default, this signal kills a process. A process can instead arrange to catch
    or ignore this signal, in which case the *write()* on the pipe fails with the
    error `EPIPE` (broken pipe). Receiving the `SIGPIPE` signal or getting the `EPIPE`
    error is a useful indication about the status of the pipe, and this is why unused
    read descriptors for the pipe should be closed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 写入过程关闭管道的读描述符是出于不同的原因。当一个进程尝试向一个没有进程打开的读描述符的管道写入数据时，内核会向写入进程发送`SIGPIPE`信号。默认情况下，这个信号会终止进程。进程可以选择捕获或忽略这个信号，在这种情况下，管道上的*write()*调用会失败，并返回错误`EPIPE`（管道破裂）。接收到`SIGPIPE`信号或出现`EPIPE`错误是管道状态的有用指示，因此应该关闭未使用的管道读描述符。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the treatment of a *write()* that is interrupted by a `SIGPIPE` handler
    is special. Normally, when a *write()* (or other “slow” system call) is interrupted
    by a signal handler, the call is either automatically restarted or fails with
    the error `EINTR`, depending on whether the handler was installed with the *sigaction()*
    `SA_RESTART` flag ([Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")). The behavior in the case of `SIGPIPE`
    is different because it makes no sense either to automatically restart the *write()*
    or to simply indicate that the *write()* was interrupted by a handler (thus implying
    that the *write()* could usefully be manually restarted). In neither case can
    a subsequent *write()* attempt succeed, because the pipe will still be broken.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*write()*被`SIGPIPE`处理程序中断的处理方式是特殊的。通常，当*write()*（或其他“慢”系统调用）被信号处理程序中断时，调用会自动重新启动，或者会因错误`EINTR`而失败，具体取决于处理程序是否使用*sigaction()*的`SA_RESTART`标志安装（[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")）。在`SIGPIPE`的情况下，行为有所不同，因为自动重启*write()*或仅仅表明*write()*被处理程序中断（从而暗示*write()*可以手动重启）没有任何意义。在这两种情况下，后续的*write()*尝试都无法成功，因为管道仍然是破损的。
- en: If the writing process doesn’t close the read end of the pipe, then, even after
    the other process closes the read end of the pipe, the writing process will still
    be able to write to the pipe. Eventually, the writing process will fill the pipe,
    and a further attempt to write will block indefinitely.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果写入进程没有关闭管道的读端，那么即使另一个进程关闭了管道的读端，写入进程仍然可以继续向管道写入数据。最终，写入进程会填满管道，进一步的写入尝试将会无限阻塞。
- en: One final reason for closing unused file descriptors is that it is only after
    all file descriptors in all processes that refer to a pipe are closed that the
    pipe is destroyed and its resources released for reuse by other processes. At
    this point, any unread data in the pipe is lost.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭未使用的文件描述符的另一个原因是，只有在所有引用管道的进程中的所有文件描述符都关闭后，管道才会被销毁，其资源会被释放以供其他进程重用。此时，管道中任何未读取的数据都会丢失。
- en: Example program
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa
    "Example 44-2. Using a pipe to communicate between a parent and child process")
    demonstrates the use of a pipe for communication between parent and child processes.
    This example demonstrates the byte-stream nature of pipes referred to earlier—the
    parent writes its data in a single operation, while the child reads data from
    the pipe in small blocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa "Example 44-2.
    使用管道在父进程和子进程之间进行通信")中的程序演示了使用管道在父进程和子进程之间进行通信。这个示例展示了之前提到的管道的字节流特性——父进程一次性写入数据，而子进程则从管道中小块读取数据。'
- en: The main program calls *pipe()* to create a pipe ![](figs/web/U001.png), and
    then calls *fork()* to create a child ![](figs/web/U002.png). After the *fork()*,
    the parent process closes its file descriptor for the read end of the pipe ![](figs/web/U008.png),
    and writes the string given as the program’s command-line argument to the write
    end of the pipe ![](figs/web/U009.png). The parent then closes the read end of
    the pipe ![](figs/web/U010.png), and calls *wait()* to wait for the child to terminate
    ![](figs/web/U011.png). After closing its file descriptor for the write end of
    the pipe ![](figs/web/U003.png), the child process enters a loop where it reads
    ![](figs/web/U004.png) blocks of data (of up to `BUF_SIZE` bytes) from the pipe
    and writes ![](figs/web/U006.png) them to standard output. When the child encounters
    end-of-file on the pipe ![](figs/web/U005.png), it exits the loop ![](figs/web/U007.png),
    writes a trailing newline character, closes its descriptor for the read end of
    the pipe, and terminates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序调用*pipe()*创建管道![](figs/web/U001.png)，然后调用*fork()*创建子进程![](figs/web/U002.png)。在*fork()*之后，父进程关闭管道的读取端文件描述符![](figs/web/U008.png)，并将作为程序命令行参数传入的字符串写入管道的写入端![](figs/web/U009.png)。然后，父进程关闭管道的读取端![](figs/web/U010.png)，并调用*wait()*等待子进程终止![](figs/web/U011.png)。子进程关闭管道的写入端文件描述符![](figs/web/U003.png)后，进入一个循环，从管道中读取![](figs/web/U004.png)最多`BUF_SIZE`字节的数据块，并将它们写入![](figs/web/U006.png)标准输出。当子进程在管道上遇到文件结束符![](figs/web/U005.png)时，它退出循环![](figs/web/U007.png)，写入一个尾随换行符，关闭读取端文件描述符，并终止。
- en: 'Here’s an example of what we might see when running the program in [Example 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa
    "Example 44-2. Using a pipe to communicate between a parent and child process"):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行程序时可能会看到的一个示例，来自[示例 44-2](ch44.html#using_a_pipe_to_communicate_between_a_pa
    "示例 44-2. 使用管道在父进程和子进程之间进行通信")：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 44-2. Using a pipe to communicate between a parent and child process
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 44-2. 使用管道在父进程和子进程之间进行通信
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pipes as a Method of Process Synchronization
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道作为进程同步的方法
- en: In [Avoiding Race Conditions by Synchronizing with Signals](ch24.html#avoiding_race_conditions_by_synchronizin
    "Avoiding Race Conditions by Synchronizing with Signals"), we looked at how signals
    could be used to synchronize the actions of parent and child processes in order
    to avoid race conditions. Pipes can be used to achieve a similar result, as shown
    by the skeleton program in [Example 44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro
    "Example 44-3. Using a pipe to synchronize multiple processes"). This program
    creates multiple child processes (one for each command-line argument), each of
    which is intended to accomplish some action, simulated in the example program
    by sleeping for some time. The parent waits until all children have completed
    their actions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[通过信号同步避免竞态条件](ch24.html#avoiding_race_conditions_by_synchronizin "通过信号同步避免竞态条件")中，我们探讨了如何利用信号来同步父子进程的操作，以避免竞态条件。管道也可以用来实现类似的结果，如[示例
    44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro "示例 44-3. 使用管道同步多个进程")中的骨架程序所示。这个程序创建多个子进程（每个子进程对应一个命令行参数），每个子进程执行某些操作，在示例程序中通过睡眠一段时间来模拟。父进程会等待直到所有子进程完成其操作。
- en: To perform the synchronization, the parent builds a pipe ![](figs/web/U001.png)
    before creating the child processes ![](figs/web/U002.png). Each child inherits
    a file descriptor for the write end of the pipe and closes this descriptor once
    it has completed its action ![](figs/web/U003.png). After all of the children
    have closed their file descriptors for the write end of the pipe, the parent’s
    *read()* ![](figs/web/U005.png) from the pipe will complete, returning end-of-file
    (0). At this point, the parent is free to carry on to do other work. (Note that
    closing the unused write end of the pipe in the parent ![](figs/web/U004.png)
    is essential to the correct operation of this technique; otherwise, the parent
    would block forever when trying to read from the pipe.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行同步，父进程在创建子进程之前建立一个管道![](figs/web/U001.png)。每个子进程继承管道的写入端文件描述符，并在完成操作后关闭此描述符![](figs/web/U003.png)。当所有子进程都关闭了管道的写入端文件描述符后，父进程对管道的*read()*操作![](figs/web/U005.png)会完成，并返回文件结束符（0）。此时，父进程可以自由地继续执行其他工作。（请注意，父进程关闭管道中未使用的写入端![](figs/web/U004.png)对于此技术的正确操作至关重要，否则父进程在尝试从管道读取时会永远阻塞。）
- en: 'The following is an example of what we see when we use the program in [Example 44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro
    "Example 44-3. Using a pipe to synchronize multiple processes") to create three
    children that sleep for 4, 2, and 6 seconds:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使用[示例 44-3](ch44.html#using_a_pipe_to_synchronize_multiple_pro "示例 44-3.
    使用管道同步多个进程")中的程序创建三个子进程，它们分别睡眠 4、2 和 6 秒时的结果：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 44-3. Using a pipe to synchronize multiple processes
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 44-3. 使用管道同步多个进程
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Synchronization using pipes has an advantage over the earlier example of synchronization
    using signals: it can be used to coordinate the actions of one process with multiple
    other (related) processes. The fact that multiple (standard) signals can’t be
    queued makes signals unsuitable in this case. (Conversely, signals have the advantage
    that they can be broadcast by one process to all of the members of a process group.)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道进行同步相较于之前使用信号的同步方法有一个优势：它可以用来协调一个进程与多个其他（相关）进程的操作。由于多个（标准）信号不能排队，这使得信号在这种情况下不适用。（相反，信号的优势在于它们可以由一个进程广播到所有进程组成员。）
- en: Other synchronization topologies are possible (e.g., using multiple pipes).
    Furthermore, this technique could be extended so that, instead of closing the
    pipe, each child writes a message to the pipe containing its process ID and some
    status information. Alternatively, each child might write a single byte to the
    pipe. The parent process could then count and analyze these messages. This approach
    guards against the possibility of the child accidentally terminating, rather than
    explicitly closing the pipe.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他同步拓扑结构也是可能的（例如，使用多个管道）。此外，这种技术可以扩展，以便每个子进程在不关闭管道的情况下，向管道写入包含其进程 ID 和一些状态信息的消息。或者，每个子进程可能会向管道写入一个字节。父进程随后可以计算并分析这些消息。这种方法可以防止子进程意外终止，而不是显式地关闭管道。
- en: Using Pipes to Connect Filters
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用管道连接过滤器
- en: When a pipe is created, the file descriptors used for the two ends of the pipe
    are the next lowest-numbered descriptors available. Since, in normal circumstances,
    descriptors 0, 1, and 2 are already in use for a process, some higher-numbered
    descriptors will be allocated for the pipe. So how do we bring about the situation
    shown in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes "Figure 44-1. Using
    a pipe to connect two processes"), where two filters (i.e., programs that read
    from *stdin* and write to *stdout*) are connected using a pipe, such that the
    standard output of one program is directed into the pipe and the standard input
    of the other is taken from the pipe? And in particular, how can we do this without
    modifying the code of the filters themselves?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个管道时，用于管道两端的文件描述符是可用的下一个最低编号的描述符。由于在正常情况下，描述符 0、1 和 2 已经被进程占用，所以会为管道分配一些较高编号的描述符。那么，我们如何实现[图
    44-1](ch44.html#using_a_pipe_to_connect_two_processes "图 44-1. 使用管道连接两个进程")中所示的情况，其中两个过滤器（即从
    *stdin* 读取并写入 *stdout* 的程序）通过管道连接，使得一个程序的标准输出被定向到管道，而另一个程序的标准输入则来自管道呢？尤其是，我们如何在不修改过滤器代码的情况下实现这一点？
- en: 'The answer is to use the techniques described in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors") for duplicating file descriptors. Traditionally,
    the following series of calls was used to accomplish the desired result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用[复制文件描述符](ch05.html#duplicating_file_descriptors "复制文件描述符")中描述的技术来复制文件描述符。传统上，使用以下一系列调用来完成所需的结果：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The end result of the above steps is that the process’s standard output is bound
    to the write end of the pipe. A corresponding set of calls can be used to bind
    a process’s standard input to the read end of the pipe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤的最终结果是，进程的标准输出被绑定到管道的写端。可以使用一组相应的调用将进程的标准输入绑定到管道的读端。
- en: 'Note that these steps depend on the assumption that file descriptors 0, 1,
    and 2 for a process are already open. (The shell normally ensures this for each
    program it executes.) If file descriptor 0 was already closed prior to the above
    steps, then we would erroneously bind the process’s standard *input* to the write
    end of the pipe. To avoid this possibility, we can replace the calls to *close()*
    and *dup()* with the following *dup2()* call, which allows us to explicitly specify
    the descriptor to be bound to the pipe end:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些步骤依赖于假设进程的文件描述符 0、1 和 2 已经打开。（shell 通常会为每个执行的程序确保这一点。）如果文件描述符 0 在上述步骤之前已被关闭，那么我们就会错误地将进程的标准*输入*绑定到管道的写端。为了避免这种可能性，我们可以将对*close()*和*dup()*的调用替换为以下*dup2()*调用，这允许我们明确指定要绑定到管道端的描述符：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After duplicating *pfd[1]*, we now have two file descriptors referring to the
    write end of the pipe: descriptor 1 and *pfd[1]*. Since unused pipe file descriptors
    should be closed, after the *dup2()* call, we close the superfluous descriptor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制*pfd[1]*之后，我们现在有两个文件描述符指向管道的写端：描述符1和*pfd[1]*。由于未使用的管道文件描述符应当被关闭，因此在*dup2()*调用后，我们关闭多余的描述符：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code we have shown so far relies on standard output having been previously
    open. Suppose that, prior to the *pipe()* call, standard input and standard output
    had both been closed. In this case, *pipe()* would have allocated these two descriptors
    to the pipe, perhaps with *pfd[0]* having the value 0 and *pfd[1]* having the
    value 1\. Consequently, the preceding *dup2()* and *close()* calls would be equivalent
    to the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的代码依赖于标准输出已经被打开。假设在调用*pipe()*之前，标准输入和标准输出都已关闭。在这种情况下，*pipe()*将这两个描述符分配给管道，可能是*pfd[0]*的值为0，*pfd[1]*的值为1。因此，之前的*dup2()*和*close()*调用将等同于以下代码：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Therefore, it is good defensive programming practice to bracket these calls
    with an `if` statement of the following form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，良好的防御性编程实践是将这些调用括起来，使用以下形式的`if`语句：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example program
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc "Example 44-4. Using
    a pipe to connect ls and wc") uses the techniques described in this section to
    bring about the setup shown in [Figure 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "Figure 44-1. Using a pipe to connect two processes"). After building a pipe,
    this program creates two child processes. The first child binds its standard output
    to the write end of the pipe and then execs *ls*. The second child binds its standard
    input to the read end of the pipe and then execs *wc*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc "示例 44-4. 使用管道连接 ls 和
    wc") 中的程序使用了本节描述的技术，完成了在[图 44-1](ch44.html#using_a_pipe_to_connect_two_processes
    "图 44-1. 使用管道连接两个进程")中显示的设置。构建管道后，该程序创建了两个子进程。第一个子进程将其标准输出绑定到管道的写端，然后执行*ls*。第二个子进程将其标准输入绑定到管道的读端，然后执行*wc*。'
- en: Example 44-4. Using a pipe to connect *ls* and *wc*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 44-4. 使用管道连接*ls*和*wc*
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the program in [Example 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc
    "Example 44-4. Using a pipe to connect ls and wc"), we see the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行[示例 44-4](ch44.html#using_a_pipe_to_connect_ls_and_wc "示例 44-4. 使用管道连接
    ls 和 wc")中的程序时，我们看到如下输出：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Talking to a Shell Command via a Pipe: *popen()*'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过管道与 Shell 命令交互：*popen()*
- en: A common use for pipes is to execute a shell command and either read its output
    or send it some input. The *popen()* and *pclose()* functions are provided to
    simplify this task.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的一个常见用途是执行一个 shell 命令，并读取其输出或发送输入给它。*popen()* 和 *pclose()* 函数被提供来简化这一任务。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file stream, or `NULL` on error
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文件流，或在出错时返回`NULL`
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns termination status of child process, or -1 on error
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 返回子进程的终止状态，或在出错时返回-1
- en: The *popen()* function creates a pipe, and then forks a child process that execs
    a shell, which in turn creates a child process to execute the string given in
    *command*. The *mode* argument is a string that determines whether the calling
    process will read from the pipe (*mode* is *r*) or write to it (*mode* is *w*).
    (Since pipes are unidirectional, two-way communication with the executed *command*
    is not possible.) The value of *mode* determines whether the standard output of
    the executed command is connected to the write end of the pipe or its standard
    input is connected to the read end of the pipe, as shown in [Figure 44-4](ch44.html#overview_of_process_relationships_and_pi
    "Figure 44-4. Overview of process relationships and pipe usage for popen()").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*popen()* 函数创建一个管道，然后分叉一个子进程，该子进程执行一个 shell，进而创建一个子进程来执行 *command* 中给定的字符串。*mode*
    参数是一个字符串，决定调用进程是从管道中读取（*mode* 为 *r*）还是向其写入（*mode* 为 *w*）。(由于管道是单向的，因此与执行的 *command*
    进行双向通信是不可能的。) *mode* 的值决定了执行的命令的标准输出是否连接到管道的写端，或者其标准输入是否连接到管道的读端，如[图 44-4](ch44.html#overview_of_process_relationships_and_pi
    "图 44-4. *popen()* 的进程关系和管道使用概览")所示。'
- en: '![Overview of process relationships and pipe usage for popen()](figs/web/44-4_PIPE-popen.png.jpg)Figure 44-4. Overview
    of process relationships and pipe usage for *popen()*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![popen() 的进程关系和管道使用概览](figs/web/44-4_PIPE-popen.png.jpg)图 44-4. *popen()*
    的进程关系和管道使用概览'
- en: On success, *popen()* returns a file stream pointer that can be used with the
    *stdio* library functions. If an error occurs (e.g., *mode* is not *r* or *w*,
    pipe creation fails, or the *fork()* to create the child fails), then *popen()*
    returns `NULL` and sets *errno* to indicate the cause of the error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功时，*popen()* 返回一个文件流指针，可以与 *stdio* 库函数一起使用。如果发生错误（例如，*mode* 不是 *r* 或 *w*，管道创建失败，或者
    *fork()* 创建子进程失败），则 *popen()* 返回 `NULL` 并设置 *errno* 以指示错误的原因。
- en: After the *popen()* call, the calling process uses the pipe to read the output
    of *command* or to send input to it. Just as with pipes created using *pipe()*,
    when reading from the pipe, the calling process encounters end-of-file once *command*
    has closed the write end of the pipe; when writing to the pipe, it is sent a `SIGPIPE`
    signal, and gets the `EPIPE` error, if *command* has closed the read end of the
    pipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *popen()* 调用后，调用进程通过管道读取 *command* 的输出或向其发送输入。与使用 *pipe()* 创建的管道一样，当从管道读取时，一旦
    *command* 关闭管道的写端，调用进程会遇到文件结束；当向管道写入时，如果 *command* 关闭了管道的读端，则会发送 `SIGPIPE` 信号，并返回
    `EPIPE` 错误。
- en: 'Once I/O is complete, the *pclose()* function is used to close the pipe and
    wait for the child shell to terminate. (The *fclose()* function should not be
    used, since it doesn’t wait for the child.) On success, *pclose()* yields the
    termination status ([The Wait Status Value](ch26.html#the_wait_status_value "The
    Wait Status Value")) of the child shell (which is the termination status of the
    last command that the shell executed, unless the shell was killed by a signal).
    As with *system()* ([Executing a Shell Command: *system()*](ch27.html#executing_a_shell_command_colon_system_o
    "Executing a Shell Command: system()")), if a shell could not be execed, then
    *pclose()* returns a value as though the child shell had terminated with the call
    *_exit(127)*. If some other error occurs, *pclose()* returns -1\. One possible
    error is that the termination status could not be obtained. We explain how this
    may occur shortly.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 I/O 完成，使用 *pclose()* 函数关闭管道并等待子 shell 终止。（不应使用 *fclose()* 函数，因为它不会等待子进程。）成功时，*pclose()*
    返回子 shell 的终止状态（[终止状态值](ch26.html#the_wait_status_value "终止状态值")）（即 shell 执行的最后一个命令的终止状态，除非该
    shell 被信号终止）。与 *system()* 一样（[执行 shell 命令：*system()*](ch27.html#executing_a_shell_command_colon_system_o
    "执行 Shell 命令：system()")），如果无法执行 shell，则 *pclose()* 返回一个值，表示子 shell 已以 *_exit(127)*
    调用终止。如果发生其他错误，*pclose()* 返回 -1。可能的错误之一是无法获得终止状态。我们将在稍后解释这种情况如何发生。
- en: When performing a wait to obtain the status of the child shell, SUSv3 requires
    that *pclose()*, like *system()*, should automatically restart the internal call
    that it makes to *waitpid()* if that call is interrupted by a signal handler.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行等待以获取子 shell 的状态时，SUSv3 要求 *pclose()* 与 *system()* 一样，如果 *waitpid()* 调用被信号处理程序中断，应自动重新启动该调用。
- en: 'In general, we can make the same statements for *popen()* as were made in [Executing
    a Shell Command: *system()*](ch27.html#executing_a_shell_command_colon_system_o
    "Executing a Shell Command: system()") for *system()*. Using *popen()* offers
    convenience. It builds the pipe, performs descriptor duplication, closes unused
    descriptors, and handles all of the details of *fork()* and *exec()* on our behalf.
    In addition, shell processing is performed on the command. This convenience comes
    at the cost of efficiency. At least two extra processes must be created: one for
    the shell and one or more for the command(s) executed by the shell. As with *system()*,
    *popen()* should never be used from privileged programs.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以对*popen()*做出与在[执行Shell命令：*system()*](ch27.html#executing_a_shell_command_colon_system_o
    "执行Shell命令：system()")中对*system()*所做的相同描述。使用*popen()*提供了便利，它会为我们建立管道、执行描述符复制、关闭未使用的描述符，并处理所有关于*fork()*和*exec()*的细节。此外，命令还会经过Shell处理。这种便利是以效率为代价的。至少必须创建两个额外的进程：一个用于Shell，另一个或多个用于Shell执行的命令。与*system()*一样，*popen()*不应从特权程序中使用。
- en: 'While there are several similarities between *system()* and *popen()* plus
    *pclose()*, there are also significant differences. These stem from the fact that,
    with *system()*, the execution of the shell command is encapsulated within a single
    function call, whereas with *popen()*, the calling process runs in parallel with
    the shell command and then calls *pclose()*. The differences are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*popen()*和*pclose()*与*system()*有许多相似之处，但也有显著的不同。这些不同源于这样的事实：在*system()*中，Shell命令的执行被封装在一个单独的函数调用中，而在*popen()*中，调用进程与Shell命令并行运行，然后调用*pclose()*。这些差异如下：
- en: Since the calling process and the executed command are operating in parallel,
    SUSv3 requires that *popen()* should *not* ignore `SIGINT` and `SIGQUIT`. If generated
    from the keyboard, these signals are sent to both the calling process and the
    executed command. This occurs because both processes reside in the same process
    group, and terminal-generated signals are sent to all of the members of the (foreground)
    process group, as described in Section 34.5.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于调用进程和执行的命令并行运行，SUSv3要求*popen()*不得忽略`SIGINT`和`SIGQUIT`信号。如果这些信号是从键盘生成的，它们会被发送到调用进程和执行的命令。这是因为这两个进程属于同一个进程组，终端生成的信号会发送到该（前台）进程组的所有成员，如第34.5节所述。
- en: Since the calling process may create other child processes between the execution
    of *popen()* and *pclose()*, SUSv3 requires that *popen()* should *not* block
    `SIGCHLD`. This means that if the calling process performs a wait operation before
    the *pclose()* call, it may retrieve the status of the child created by *popen()*.
    In this case, when *pclose()* is later called, it will return -1, with *errno*
    set to `ECHILD`, indicating that *pclose()* could not retrieve the status of the
    child.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于调用进程可能在执行*popen()*和*pclose()*之间创建其他子进程，SUSv3要求*popen()*不得屏蔽`SIGCHLD`。这意味着如果调用进程在调用*pclose()*之前执行了等待操作，它可能会获取由*popen()*创建的子进程的状态。在这种情况下，当*pclose()*被调用时，它将返回-1，并且*errno*会被设置为`ECHILD`，表示*pclose()*无法获取子进程的状态。
- en: Example program
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op "Example 44-5. Globbing
    filename patterns with popen()") demonstrates the use of *popen()* and *pclose()*.
    This program repeatedly reads a filename wildcard pattern ![](figs/web/U002.png),
    and then uses *popen()* to obtain the results from passing this pattern to the
    *ls* command ![](figs/web/U005.png). (Techniques similar to this were used on
    older UNIX implementations to perform filename generation, also known as *globbing*,
    prior to the existence of the *glob()* library function.)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 44-5](ch44.html#globbing_filename_patterns_with_popen_op "示例 44-5. 使用popen()进行文件名模式的通配符匹配")演示了如何使用*popen()*和*pclose()*。该程序反复读取一个文件名通配符模式
    ![](figs/web/U002.png)，然后使用*popen()*将该模式传递给*ls*命令，获取其结果 ![](figs/web/U005.png)。(类似的技术曾在旧版UNIX实现中用于执行文件名生成，也称为*globbing*，在*glob()*库函数存在之前。)'
- en: Example 44-5. Globbing filename patterns with *popen()*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 44-5. 使用*popen()*进行文件名模式的通配符匹配
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following shell session demonstrates the use of the program in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()"). In this example, we
    first provide a pattern that matches two filenames, and then a pattern that matches
    no filename:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Shell会话演示了[示例 44-5](ch44.html#globbing_filename_patterns_with_popen_op "示例 44-5.
    使用popen()进行文件名模式的通配符匹配")程序的使用。在此示例中，我们首先提供一个匹配两个文件名的模式，然后提供一个不匹配任何文件名的模式：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The construction of the command ![](figs/web/U001.png)![](figs/web/U004.png)
    for globbing in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()") requires some explanation.
    Actual globbing of a pattern is performed by the shell. The *ls* command is merely
    being used to list the matching filenames, one per line. We could have tried using
    the *echo* command instead, but this would have had the undesirable result that
    if a pattern matched no filenames, then the shell would leave the pattern unchanged,
    and *echo* would simply display the pattern. By contrast, if *ls* is given the
    name of a file that doesn’t exist, it prints an error message on *stderr* (which
    we dispose of by redirecting *stderr* to `/dev/null`), prints nothing on *stdout*,
    and exits with a status of 1.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 44-5](ch44.html#globbing_filename_patterns_with_popen_op "示例 44-5. 使用 popen()
    进行文件名模式匹配") 中构建命令 ![](figs/web/U001.png)![](figs/web/U004.png) 进行文件名模式匹配需要一些解释。实际的模式匹配是由
    shell 执行的。*ls* 命令仅用于列出匹配的文件名，每行一个。我们本可以尝试使用*echo*命令，但这样会导致不理想的结果：如果模式未匹配任何文件名，shell
    会保持模式不变，*echo* 命令则会简单地显示该模式。相比之下，如果*ls*被给定一个不存在的文件名，它会在*stderr*上打印错误信息（我们通过将*stderr*重定向到`/dev/null`来处理），在*stdout*上不打印任何内容，并且以状态码1退出。'
- en: 'Note also the input checking performed in [Example 44-5](ch44.html#globbing_filename_patterns_with_popen_op
    "Example 44-5. Globbing filename patterns with popen()") ![](figs/web/U003.png).
    This is done to prevent invalid input causing *popen()* to execute an unexpected
    shell command. Suppose that these checks were omitted, and the user entered the
    following input:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在[示例 44-5](ch44.html#globbing_filename_patterns_with_popen_op "示例 44-5. 使用
    popen() 进行文件名模式匹配")中执行的输入检查！[](figs/web/U003.png)。这是为了防止无效输入导致*popen()*执行意外的 shell
    命令。假设这些检查被省略，用户输入了以下内容：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The program would then pass the following command to *popen()*, with disastrous
    results:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序将传递以下命令给*popen()*，并导致灾难性的结果：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such checking of input is always required in programs that use *popen()* (or
    *system()*) to execute a shell command built from user input. (An alternative
    would be for the application to quote any characters other than those being checked
    for, so that those characters don’t undergo special processing by the shell.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*popen()*（或*system()*)执行由用户输入构建的 shell 命令的程序中，始终需要进行此类输入检查。（另一种选择是让应用程序引用所有未检查的字符，以便这些字符不被
    shell 进行特殊处理。）
- en: Pipes and *stdio* Buffering
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和*stdio*缓冲
- en: Since the file stream pointer returned by a call to *popen()* doesn’t refer
    to a terminal, the *stdio* library applies block buffering to the file stream
    ([Buffering in the *stdio* Library](ch13.html#buffering_in_the_stdio_library "Buffering
    in the stdio Library")). This means that when we call *popen()* with a *mode*
    of *w*, then, by default, output is sent to the child process at the other end
    of the pipe only when the *stdio* buffer is filled or we close the pipe with *pclose()*.
    In many cases, this presents no problem. If, however, we need to ensure that the
    child process receives data on the pipe immediately, then we can either use periodic
    calls to *fflush()* or disable *stdio* buffering using the call *setbuf(fp, NULL)*.
    This technique can also be used if we create a pipe using the *pipe()* system
    call and then use *fdopen()* to obtain a *stdio* stream corresponding to the write
    end of the pipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过调用*popen()*返回的文件流指针不指向终端，*stdio*库对文件流应用了块缓冲（[stdio 库中的缓冲](ch13.html#buffering_in_the_stdio_library
    "stdio 库中的缓冲")）。这意味着当我们以*popen()*调用并指定模式为*w*时，默认情况下，输出只有在*stdio*缓冲区填满或我们使用*pclose()*关闭管道时，才会发送到管道另一端的子进程。在许多情况下，这不会造成问题。然而，如果我们需要确保子进程立即接收到管道上的数据，我们可以定期调用*fflush()*，或者使用*setbuf(fp,
    NULL)*禁用*stdio*缓冲。此技术还可以在我们使用*pipe()*系统调用创建管道，并使用*fdopen()*获取与管道写端对应的*stdio*流时使用。
- en: If the process calling *popen()* is reading from the pipe (i.e., *mode* is *r*),
    things may not be so straightforward. In this case, if the child process is using
    the *stdio* library, then—unless it includes explicit calls to *fflush()* or *setbuf()*—its
    output will be available to the calling process only when the child either fills
    the *stdio* buffer or calls *fclose()*. (The same statement applies if we are
    reading from a pipe created using *pipe()* and the process writing on the other
    end is using the *stdio* library.) If this is a problem, there is little we can
    do unless we can modify the source code of the program running in the child process
    to include calls to *setbuf()* of *fflush()*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 *popen()* 的进程正在从管道中读取（即 *mode* 为 *r*），情况可能并非如此简单。在这种情况下，如果子进程使用的是 *stdio*
    库，则除非显式调用 *fflush()* 或 *setbuf()*，否则其输出只有在子进程填充 *stdio* 缓冲区或调用 *fclose()* 时才会传递给调用进程。（如果我们是从使用
    *pipe()* 创建的管道读取，并且另一端的进程使用的是 *stdio* 库，情况也是如此。）如果这是一个问题，除非我们能够修改子进程中运行的程序的源代码并添加对
    *setbuf()* 或 *fflush()* 的调用，否则几乎无能为力。
- en: If modifying the source code is not an option, then instead of using a pipe,
    we could use a pseudoterminal. A pseudoterminal is an IPC channel that appears
    to the process on one end as though it is a terminal. Consequently, the *stdio*
    library line buffers output. We describe pseudoterminals in [Chapter 64](ch64.html
    "Chapter 64. Pseudoterminals").
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法修改源代码，我们可以选择使用伪终端而不是管道。伪终端是一个 IPC 通道，在一端看起来像是一个终端。因此，*stdio* 库会对输出进行行缓冲。我们在[第64章](ch64.html
    "第64章. 伪终端")中描述了伪终端。
- en: FIFOs
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIFO
- en: Semantically, a FIFO is similar to a pipe. The principal difference is that
    a FIFO has a name within the file system and is opened in the same way as a regular
    file. This allows a FIFO to be used for communication between unrelated processes
    (e.g., a client and server).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，FIFO 类似于管道。主要区别在于，FIFO 在文件系统中有一个名称，并且以与常规文件相同的方式打开。这使得 FIFO 可以用于不相关进程之间的通信（例如，客户端和服务器）。
- en: 'Once a FIFO has been opened, we use the same I/O system calls as are used with
    pipes and other files (i.e., *read()*, *write()*, and *close()*). Just as with
    pipes, a FIFO has a write end and a read end, and data is read from the pipe in
    the same order as it is written. This fact gives FIFOs their name: *first in,
    first out*. FIFOs are also sometimes known as *named pipes*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 FIFO 被打开，我们就可以像使用管道和其他文件一样使用相同的 I/O 系统调用（即 *read()*, *write()*, 和 *close()*）。就像管道一样，FIFO
    也有写端和读端，数据按照写入的顺序从管道中读取。这个事实赋予了 FIFO 它们的名字：*先进先出*。FIFO 有时也被称为 *命名管道*。
- en: As with pipes, when all descriptors referring to a FIFO have been closed, any
    outstanding data is discarded.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与管道一样，当所有引用 FIFO 的描述符都已关闭时，任何未处理的数据都会被丢弃。
- en: 'We can create a FIFO from the shell using the *mkfifo* command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *mkfifo* 命令从 shell 中创建 FIFO：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *pathname* is the name of the FIFO to be created, and the *-m* option is
    used to specify a permission *mode* in the same way as for the *chmod* command.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname* 是要创建的 FIFO 的名称，* -m * 选项用于指定权限 *mode*，与 *chmod* 命令的用法相同。'
- en: 'When applied to a FIFO (or pipe), *fstat()* and *stat()* return a file type
    of `S_IFIFO` in the *st_mode* field of the *stat* structure ([Retrieving File
    Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving
    File Information: stat()")). When listed with *ls -l*, a FIFO is shown with the
    type *p* in the first column, and *ls -F* appends an the pipe symbol (`|`) to
    the FIFO pathname.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于 FIFO（或管道）时，*fstat()* 和 *stat()* 会在 *stat* 结构的 *st_mode* 字段返回文件类型 `S_IFIFO`（[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")）。当使用 *ls -l* 列出时，FIFO 会在第一列显示类型 *p*，而 *ls -F* 会在 FIFO 路径名后附加管道符号（`|`）。
- en: The *mkfifo()* function creates a new FIFO with the given *pathname*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkfifo()* 函数创建一个新的 FIFO，并使用给定的 *pathname*。'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *mode* argument specifies the permissions for the new FIFO. These permissions
    are specified by ORing the desired combination of constants from [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories"). As usual, these permissions are masked against
    the process umask value ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*mode* 参数指定了新 FIFO 的权限。这些权限通过将所需的常量组合从 [表 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits") 与 [目录权限](ch15.html#permissions_on_directories
    "Permissions on Directories") 进行按位 OR 运算来指定。像往常一样，这些权限会与进程的 umask 值进行掩码操作（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")）。'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Historically, FIFOs were created using the system call *mknod(pathname, S_IFIFO,
    0)*. POSIX.1-1990 specified *mkfifo()* as a simpler API avoiding the generality
    of *mknod()*, which allows creation of various types of files, including device
    files. (SUSv3 specifies *mknod()*, but weakly, defining only its use for creating
    FIFOs.) Most UNIX implementations provide *mkfifo()* as a library function layered
    on top of *mknod()*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，FIFO（先进先出队列）是通过系统调用 *mknod(pathname, S_IFIFO, 0)* 创建的。POSIX.1-1990 规范指定了
    *mkfifo()*，它是一个更简单的 API，避免了 *mknod()* 的通用性，后者允许创建各种类型的文件，包括设备文件。（SUSv3 规范了 *mknod()*，但较为宽泛，仅定义了它用于创建
    FIFO。）大多数 UNIX 实现将 *mkfifo()* 作为一个库函数，建立在 *mknod()* 之上。
- en: Once a FIFO has been created, any process can open it, subject to the usual
    file permission checks ([Permission-Checking Algorithm](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm")).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 FIFO 被创建，任何进程都可以打开它，前提是进行常规的文件权限检查（[权限检查算法](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm")）。
- en: Opening a FIFO has somewhat unusual semantics. Generally, the only sensible
    use of a FIFO is to have a reading process and a writing process on each end.
    Therefore, by default, opening a FIFO for reading (the *open()* `O_RDONLY` flag)
    blocks until another process opens the FIFO for writing (the *open()* `O_WRONLY`
    flag). Conversely, opening the FIFO for writing blocks until another process opens
    the FIFO for reading. In other words, opening a FIFO synchronizes the reading
    and writing processes. If the opposite end of a FIFO is already open (perhaps
    because a pair of processes have already opened each end of the FIFO), then *open()*
    succeeds immediately.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 FIFO 具有一些不寻常的语义。通常，FIFO 的唯一合理用法是每端都有一个读进程和一个写进程。因此，默认情况下，打开 FIFO 以进行读取（*open()*
    的 `O_RDONLY` 标志）会阻塞，直到另一个进程以写入模式打开 FIFO（*open()* 的 `O_WRONLY` 标志）。反之，打开 FIFO 以进行写入会阻塞，直到另一个进程以读取模式打开
    FIFO。换句话说，打开 FIFO 会同步读写进程。如果 FIFO 的另一端已经打开（可能是因为一对进程已经打开了 FIFO 的两端），那么 *open()*
    会立即成功。
- en: Under most UNIX implementations (including Linux), it is possible to circumvent
    the blocking behavior when opening FIFOs by specifying the `O_RDWR` flag when
    opening a FIFO. In this case, *open()* returns immediately with a file descriptor
    that can be used for reading and writing on the FIFO. Doing this rather subverts
    the I/O model for FIFOs, and SUSv3 explicitly notes that opening a FIFO with the
    `O_RDWR` flag is unspecified; therefore, for portability reasons, this technique
    should be avoided. In circumstances where we need to prevent blocking when opening
    a FIFO, the *open()* `O_NONBLOCK` flag provides a standardized method for doing
    so (refer to [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1 "Nonblocking
    I/O")).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 UNIX 实现中（包括 Linux），通过在打开 FIFO 时指定 `O_RDWR` 标志，可以绕过打开 FIFO 时的阻塞行为。在这种情况下，*open()*
    会立即返回一个文件描述符，可以用于在 FIFO 上进行读写。这样做实际上破坏了 FIFO 的 I/O 模型，SUSv3 明确指出，使用 `O_RDWR` 标志打开
    FIFO 是未指定的；因此，出于可移植性考虑，这种技术应该避免使用。在需要防止在打开 FIFO 时发生阻塞的情况下，*open()* 的 `O_NONBLOCK`
    标志提供了一种标准化的做法（参见 [非阻塞 I/O](ch44.html#nonblocking_i_solidus_o-id1 "Nonblocking
    I/O")）。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Avoiding the use of the `O_RDWR` flag when opening a FIFO can be desirable for
    a another reason. After such an *open()*, the calling process will never see end-of-file
    when reading from the resulting file descriptor, because there will always be
    at least one descriptor open for writing to the FIFO—the same descriptor from
    which the process is reading.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在打开 FIFO 时使用 `O_RDWR` 标志可能是出于另一个原因的考虑。经过这样的 *open()* 调用后，调用进程在从结果文件描述符读取时永远不会遇到文件结束标志，因为总会至少有一个描述符用于写入
    FIFO——就是进程读取的同一个描述符。
- en: Using FIFOs and *tee(1)* to create a dual pipeline
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用FIFO和*tee(1)*创建双重管道
- en: 'One of the characteristics of shell pipelines is that they are linear; each
    process in the pipeline reads data produced by its predecessor and sends data
    to its successor. Using FIFOs, it is possible to create a fork in a pipeline,
    so that a duplicate copy of the output of a process is sent to another process
    in addition to its successor in the pipeline. In order to do this, we need to
    use the *tee* command, which writes two copies of what it reads from its standard
    input: one to standard output and the other to the file named in its command-line
    argument.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Shell管道的一个特点是它们是线性的；管道中的每个进程读取前一个进程生成的数据，并将数据发送给下一个进程。通过使用FIFO，可以在管道中创建一个分支，使得一个进程的输出副本除了传递给管道中的下一个进程外，还发送给另一个进程。为了实现这一点，我们需要使用*tee*命令，它将从标准输入读取的内容写出两份：一份写到标准输出，另一份写到命令行参数指定的文件中。
- en: Making the *file* argument to *tee* a FIFO allows us to have two processes simultaneously
    reading the duplicate output produced by *tee*. We demonstrate this in the following
    shell session, which creates a FIFO named `myfifo`, starts a background *wc* command
    that opens the FIFO for reading (this will block until the FIFO is opened for
    writing), and then executes a pipeline that sends the output of *ls* to *tee*,
    which both passes the output further down the pipeline to *sort* and sends it
    to the `myfifo` FIFO. (The *-k5n* option to *sort* causes the output of *ls* to
    be sorted in increasing numerical order on the fifth space-delimited field.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将*tee*的*file*参数设置为FIFO，允许我们让两个进程同时读取*tee*生成的重复输出。我们在下面的Shell会话中演示了这一点，首先创建一个名为`myfifo`的FIFO，启动一个后台的*wc*命令，它打开FIFO进行读取（直到FIFO被打开进行写入时它才会继续），然后执行一个管道命令，将*ls*的输出发送到*tee*，*tee*既将输出传递到管道中进一步处理到*sort*，又将其发送到`myfifo`
    FIFO中。（*sort*的*-k5n*选项会根据*ls*输出的第五个以空格分隔的字段对结果进行升序排序。）
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Diagrammatically, the above commands create the situation shown in [Figure 44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1
    "Figure 44-5. Using a FIFO and tee(1) to create a dual pipeline").
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从图示来看，上述命令创建了[图44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1 "图44-5.
    使用FIFO和tee(1)创建双重管道")所示的情况。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *tee* program is so named because of its shape. We can consider *tee* as
    functioning similarly to a pipe, but with an additional branch that sends duplicate
    output. Diagrammatically, this has the shape of a capital letter *T* (see [Figure 44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1
    "Figure 44-5. Using a FIFO and tee(1) to create a dual pipeline")). In addition
    to the purpose described here, *tee* is also useful for debugging pipelines and
    for saving the results produced at some intervening point in a complex pipeline.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*tee*程序的名称来源于其形状。我们可以将*tee*视为类似管道的功能，但它有一个额外的分支来发送重复的输出。从图示来看，它的形状像大写字母*T*（见[图44-5](ch44.html#using_a_fifo_and_tee_open_parenthesis_1
    "图44-5. 使用FIFO和tee(1)创建双重管道")）。除了这里描述的目的外，*tee*还用于调试管道和保存复杂管道中某个中间点生成的结果。'
- en: '![Using a FIFO and tee(1) to create a dual pipeline](figs/web/44-5_PIPE-fifo-and-tee-scale90.png.jpg)Figure 44-5. Using
    a FIFO and *tee(1)* to create a dual pipeline'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用FIFO和tee(1)创建双重管道](figs/web/44-5_PIPE-fifo-and-tee-scale90.png.jpg)图44-5.
    使用FIFO和*tee(1)*创建双重管道'
- en: A Client-Server Application Using FIFOs
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FIFO的客户端-服务器应用
- en: In this section, we present a simple client-server application that employs
    FIFOs for IPC. The server provides the (trivial) service of assigning unique sequential
    numbers to each client that requests them. In the course of discussing this application,
    we introduce a few concepts and techniques in server design.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们展示了一个简单的客户端-服务器应用，它使用FIFO进行进程间通信（IPC）。服务器提供一个（简单的）服务，即为每个请求的客户端分配唯一的顺序号。在讨论这个应用的过程中，我们介绍了一些服务器设计中的概念和技术。
- en: Application overview
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用概述
- en: In the example application, all clients send their requests to the server using
    a single server FIFO. The header file ([Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c"))
    defines the well-known name (`/tmp/seqnum_sv`) that the server uses for its FIFO.
    This name is fixed, so that all clients know how to contact the server. (In this
    example application, we create the FIFOs in the `/tmp` directory, since this allows
    us to conveniently run the programs without change on most systems. However, as
    noted in [Pitfalls When Performing File Operations and File I/O](ch38.html#pitfalls_when_performing_file_operations
    "Pitfalls When Performing File Operations and File I/O"), creating files in publicly
    writable directories such as `/tmp` can lead to various security vulnerabilities
    and should be avoided in real-world applications.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，所有客户端通过使用单个服务器 FIFO 向服务器发送请求。头文件 ([示例 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "示例 44-6. FIFO 的头文件定义")) 定义了服务器用于其 FIFO 的著名名称 (`/tmp/seqnum_sv`)。这个名称是固定的，因此所有客户端都知道如何联系服务器。（在此示例应用程序中，我们将
    FIFO 创建在 `/tmp` 目录中，因为这使得我们可以在大多数系统上便捷地运行程序而无需修改。然而，如在[执行文件操作和文件 I/O 时的陷阱](ch38.html#pitfalls_when_performing_file_operations
    "执行文件操作和文件 I/O 时的陷阱")中所述，创建文件在公共可写目录（如 `/tmp`）中可能会导致各种安全漏洞，应在实际应用中避免。）
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In client-server applications, we’ll repeatedly encounter the concept of a *well-known
    address* or name used by a server to make its service visible to clients. Using
    a well-known address is one solution to the problem of how clients can know where
    to contact a server. Another possible solution is to provide some kind of name
    server with which servers can register the names of their services. Each client
    then contacts the name server to obtain the location of the service it desires.
    This solution allows the location of servers to be flexible, at the cost of some
    extra programming effort. Of course, clients and servers then need to know where
    to contact the name server; typically, it resides at a well-known address.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器应用中，我们会反复遇到 *著名地址* 或名称的概念，该概念由服务器使用以使其服务对客户端可见。使用著名地址是解决客户端如何知道在哪里联系服务器的一个方案。另一种可能的解决方案是提供某种名称服务器，服务器可以将其服务的名称注册到该服务器中。然后，每个客户端联系名称服务器以获取它所需服务的位置。这种解决方案允许服务器的位置灵活变化，但需要一些额外的编程工作。当然，客户端和服务器还需要知道如何联系名称服务器；通常，它位于一个著名地址。
- en: It is not, however, possible to use a single FIFO to send responses to all clients,
    since multiple clients would race to read from the FIFO, and possibly read each
    other’s response messages rather than their own. Therefore, each client creates
    a unique FIFO that the server uses for delivering the response for that client,
    and the server needs to know how to find each client’s FIFO. One possible way
    to do this is for the client to generate its FIFO pathname, and then pass the
    pathname as part of its request message. Alternatively, the client and server
    can agree on a convention for constructing a client FIFO pathname, and, as part
    of its request, the client can pass the server the information required to construct
    the pathname specific to this client. This latter solution is used in our example.
    Each client’s FIFO name is built from a template (`CLIENT_FIFO_TEMPLATE`) consisting
    of a pathname containing the client’s process ID. The inclusion of the process
    ID provides an easy way of generating a name unique to this client.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无法使用单个 FIFO 向所有客户端发送响应，因为多个客户端会竞争从 FIFO 中读取，并可能读取到其他客户端的响应消息，而不是自己的响应。因此，每个客户端都会创建一个唯一的
    FIFO，服务器使用该 FIFO 来发送该客户端的响应，服务器需要知道如何找到每个客户端的 FIFO。一种可能的方法是客户端生成其 FIFO 路径名，然后将路径名作为请求消息的一部分传递。或者，客户端和服务器可以就构造客户端
    FIFO 路径名的约定达成一致，客户端可以将构造该客户端特定路径名所需的信息作为请求的一部分传递给服务器。在我们的示例中使用了后一种解决方案。每个客户端的
    FIFO 名称是从一个模板 (`CLIENT_FIFO_TEMPLATE`) 构建的，该模板包含一个包含客户端进程 ID 的路径名。进程 ID 的包含提供了一种生成对该客户端唯一名称的简便方法。
- en: '[Figure 44-6](ch44.html#using_fifos_in_a_single-server_comma_mul "Figure 44-6. Using
    FIFOs in a single-server, multiple-client application") shows how this application
    uses FIFOs for communication between the client and server processes of our application.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 44-6](ch44.html#using_fifos_in_a_single-server_comma_mul "图 44-6. 在单服务器多个客户端应用中使用
    FIFO") 展示了该应用如何使用 FIFO 在客户端和服务器进程之间进行通信。'
- en: The header file ([Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c"))
    defines the formats for the request messages sent from clients to the server,
    and for the response messages sent from the server to clients.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件（[示例 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u "示例 44-6. fifo_seqnum_server.c
    和 fifo_seqnum_client.c 的头文件")）定义了从客户端发送到服务器的请求消息格式，以及从服务器发送到客户端的响应消息格式。
- en: '![Using FIFOs in a single-server, multiple-client application](figs/web/44-6_PIPE-seqnum-scale90.png.jpg)Figure 44-6. Using
    FIFOs in a single-server, multiple-client application'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![在单服务器多客户端应用中使用FIFO](figs/web/44-6_PIPE-seqnum-scale90.png.jpg)图 44-6. 在单服务器多客户端应用中使用FIFO'
- en: 'Recall that the data in pipes and FIFOs is a byte stream; boundaries between
    multiple messages are not preserved. This means that when multiple messages are
    being delivered to a single process, such as the server in our example, then the
    sender and receiver must agree on some convention for separating the messages.
    Various approaches are possible:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，管道和FIFO中的数据是字节流；多个消息之间的边界不会被保留。这意味着当多个消息被传递到单个进程时（例如我们示例中的服务器），发送方和接收方必须就如何分隔消息达成某种约定。可以采用多种方法：
- en: Terminate each message with a *delimiter character*, such as a newline character.
    (For an example of this technique, see the *readLine()* function in [Example 59-1](ch59.html#reading_data_a_line_at_a_time
    "Example 59-1. Reading data a line at a time"), in [Data Representation](ch59.html#data_representation
    "Data Representation").) In this case, either the delimiter character must be
    one that never appears as part of the message, or we must adopt a convention for
    escaping the delimiter if it does occur within the message. For example, if we
    use a newline delimiter, then the characters \ plus newline could be used to represent
    a real newline character within the message, while \\ could represent a real \.
    One drawback of this approach is that the process reading messages must scan data
    from the FIFO a byte at a time until the delimiter character is found.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*定界符字符*结束每个消息，例如换行符。（有关此技术的示例，请参见[示例 59-1](ch59.html#reading_data_a_line_at_a_time
    "示例 59-1. 一次读取一行数据")，位于[数据表示](ch59.html#data_representation "数据表示")一节。）在这种情况下，定界符字符必须是消息中永远不会出现的字符，或者如果它确实出现在消息中，我们必须采用某种约定来转义该定界符。例如，如果我们使用换行符作为定界符，则可以使用字符
    \ 加换行符来表示消息中的实际换行符，而 \\ 可以表示实际的 \。这种方法的一个缺点是，读取消息的进程必须从FIFO中逐字节扫描数据，直到找到定界符字符。
- en: Include a *fixed-size header with a length field* in each message specifying
    the number of bytes in the remaining variable-length component of the message.
    In this case, the reading process first reads the header from the FIFO, and then
    uses the header’s length field to determine the number of bytes to read for the
    remainder of the message. This approach has the advantage of efficiently allowing
    messages of arbitrary size, but could lead to problems if a malformed message
    (e.g., bad *length* field) is written to the pipe.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个消息中包含一个*固定大小的头部和长度字段*，该字段指定消息中剩余可变长度部分的字节数。在这种情况下，读取过程首先从FIFO中读取头部，然后使用头部的长度字段确定读取剩余消息所需的字节数。这种方法的优点是可以高效地处理任意大小的消息，但如果写入管道的是格式不正确的消息（例如，错误的*长度*字段），可能会导致问题。
- en: Use *fixed-length messages*, and have the server always read messages of this
    fixed size. This has the advantage of being simple to program. However, it places
    an upper limit on our message size and means that some channel capacity is wasted
    (since short messages must be padded to the fixed length). Furthermore, if one
    of the clients accidentally or deliberately sends a message that is not of the
    right length, then all subsequent messages will be out of step; in this situation,
    the server can’t easily recover.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*固定长度的消息*，并使服务器始终读取该固定大小的消息。这种方法的优点是编程简单。然而，它对消息的大小设置了上限，并且意味着某些通道容量将被浪费（因为短消息必须填充到固定长度）。此外，如果某个客户端意外或故意发送了长度不正确的消息，那么所有后续的消息都会不同步；在这种情况下，服务器很难恢复。
- en: These three techniques are illustrated in [Figure 44-7](ch44.html#separating_messages_in_a_byte_stream
    "Figure 44-7. Separating messages in a byte stream"). Be aware that for each of
    these techniques, the total length of each message must be smaller than `PIPE_BUF`
    bytes in order to avoid the possibility of messages being broken up by the kernel
    and interleaved with messages from other writers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the three techniques described in the main text, a single channel (FIFO)
    is used for all messages from all clients. An alternative is to use a *single
    connection* for each message. The sender opens the communication channel, sends
    its message, and then closes the channel. The reading process knows that the message
    is complete when it encounters end-of-file. If multiple writers hold a FIFO open,
    then this approach is not feasible, because the reader won’t see end-of-file when
    one of the writers closes the FIFO. This approach is, however, feasible when using
    stream sockets, where a server process creates a unique communication channel
    for each incoming client connection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating messages in a byte stream](figs/web/44-7_PIPE-msg-formats.png.jpg)Figure 44-7. Separating
    messages in a byte stream'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In our example application, we use the third of the techniques described above,
    with each client sending messages of a fixed size to the server. This message
    is defined by the *request* structure defined in [Example 44-6](ch44.html#header_file_for_fifo_underscore_seqnum_u
    "Example 44-6. Header file for fifo_seqnum_server.c and fifo_seqnum_client.c").
    Each request to the server includes the client’s process ID, which enables the
    server to construct the name of the FIFO used by the client to receive a response.
    The request also contains a field (*seqLen*) specifying how many sequence numbers
    should be allocated to this client. The response message sent from server to client
    consists of a single field, *seqNum*, which is the starting value of the range
    of sequence numbers allocated to this client.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-6. Header file for `fifo_seqnum_server.c` and `fifo_seqnum_client.c`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Server program
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") is the code for the server. The server performs
    the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Create the server’s well-known FIFO ![](figs/web/U001.png) and open the FIFO
    for reading ![](figs/web/U002.png). The server must be run before any clients,
    so that the server FIFO exists by the time a client attempts to open it. The server’s
    *open()* blocks until the first client opens the other end of the server FIFO
    for writing.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the server’s FIFO once more ![](figs/web/U003.png), this time for writing.
    This will never block, since the FIFO has already been opened for reading. This
    second open is a convenience to ensure that the server doesn’t see end-of-file
    if all clients close the write end of the FIFO.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the `SIGPIPE` signal ![](figs/web/U004.png), so that if the server attempts
    to write to a client FIFO that doesn’t have a reader, then, rather than being
    sent a `SIGPIPE` signal (which kills a process by default), it receives an `EPIPE`
    error from the *write()* system call.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter a loop that reads and responds to each incoming client request ![](figs/web/U005.png).
    To send the response, the server constructs the name of the client FIFO ![](figs/web/U006.png)
    and then opens that FIFO ![](figs/web/U007.png).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the server encounters an error in opening the client FIFO, it abandons that
    client’s request ![](figs/web/U008.png).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of an *iterative server*, in which the server reads and
    handles each client request before going on to handle the next client. An iterative
    server design is suitable when each client request can be quickly processed and
    responded to, so that other client requests are not delayed. An alternative design
    is a *concurrent server*, in which the main server process employs a separate
    child process (or thread) to handle each client request. We discuss server design
    further in [Chapter 60](ch60.html "Chapter 60. Sockets: Server Design").'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Example 44-7. An iterative server using FIFOs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Client program
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 44-8](ch44.html#client_for_the_sequence-number_server "Example 44-8. Client
    for the sequence-number server") is the code for the client. The client performs
    the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Create a FIFO to be used for receiving a response from the server ![](figs/web/U002.png).
    This is done before sending the request, in order to ensure that the FIFO exists
    by the time the server attempts to open it and send a response message.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct a message for the server containing the client’s process ID and a
    number (taken from an optional command-line argument) specifying the length of
    the sequence that the client wishes the server to assign to it ![](figs/web/U004.png).
    (If no command-line argument is supplied, the default sequence length is 1.)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the server FIFO ![](figs/web/U005.png) and send the message to the server
    ![](figs/web/U006.png).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the client FIFO ![](figs/web/U007.png), and read and print the server’s
    response ![](figs/web/U008.png).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only other detail of note is the exit handler ![](figs/web/U001.png), established
    with *atexit()* ![](figs/web/U003.png), which ensures that the client’s FIFO is
    deleted when the process exits. Alternatively, we could have simply placed an
    *unlink()* call immediately after the *open()* of the client FIFO. This would
    work because, at that point, after they have both performed blocking *open()*
    calls, the server and the client would each hold open file descriptors for the
    FIFO, and removing the FIFO name from the file system doesn’t affect these descriptors
    or the open file descriptions to which they refer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what we see when we run the client and server programs:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 44-8. Client for the sequence-number server
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Nonblocking I/O
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As noted earlier, when a process opens one end of a FIFO, it blocks if the
    other end of the FIFO has not yet been opened. Sometimes, it is desirable not
    to block, and for this purpose, the `O_NONBLOCK` flag can be specified when calling
    *open()*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the other end of the FIFO is already open, then the `O_NONBLOCK` flag has
    no effect on the *open()* call—it successfully opens the FIFO immediately, as
    usual. The `O_NONBLOCK` flag changes things only if the other end of the FIFO
    is not yet open, and the effect depends on whether we are opening the FIFO for
    reading or writing:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: If the FIFO is being opened for reading, and no process currently has the write
    end of the FIFO open, then the *open()* call succeeds immediately (just as though
    the other end of the FIFO was already open).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the FIFO is being opened FIFO for writing, and the other end of the FIFO
    is not already open for reading, then *open()* fails, setting *errno* to `ENXIO`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asymmetry of the `O_NONBLOCK` flag depending on whether the FIFO is being
    opened for reading or for writing can be explained as follows. It is okay to open
    a FIFO for reading when there is no writer at the other end of the FIFO, since
    any attempt to read from the FIFO simply returns no data. However, attempting
    to write to a FIFO for which there is no reader would result in the generation
    of the `SIGPIPE` signal and an `EPIPE` error from *write()*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 44-1](ch44.html#semantics_of_open_open_parenthesis_close "Table 44-1. Semantics
    of open() for a FIFO") summarizes the semantics of opening a FIFO, including the
    effects of `O_NONBLOCK` described above.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-1. Semantics of *open()* for a FIFO
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of *open()* | Result of *open()* |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| open for | additional flags | other end of FIFO open | other end of FIFO
    closed |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| reading | none (blocking) | succeeds immediately | blocks |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `O_NONBLOCK` | succeeds immediately | succeeds immediately |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| writing | none (blocking) | succeeds immediately | blocks |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `O_NONBLOCK` | succeeds immediately | fails (`ENXIO`) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: 'Using the `O_NONBLOCK` flag when opening a FIFO serves two main purposes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: It allows a single process to open both ends of a FIFO. The process first opens
    the FIFO for reading specifying `O_NONBLOCK`, and then opens the FIFO for writing.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prevents deadlocks between processes opening two FIFOs.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *deadlock* is a situation where two or more process are blocked because each
    is waiting on the other process(es) to complete some action. The two processes
    shown in [Figure 44-8](ch44.html#deadlock_between_processes_opening_two_f "Figure 44-8. Deadlock
    between processes opening two FIFOs") are deadlocked. Each process is blocked
    waiting to open a FIFO for reading. This blocking would not happen if each process
    could perform its second step (opening the other FIFO for writing). This particular
    deadlock problem could be solved by reversing the order of steps 1 and 2 in process
    Y, while leaving the order in process X unchanged, or vice versa. However, such
    an arrangement of steps may not be easy to achieve in some applications. Instead,
    we can resolve the problem by having either process, or both, specify the `O_NONBLOCK`
    flag when opening the FIFOs for reading.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Deadlock between processes opening two FIFOs](figs/web/44-8_PIPE-deadlock-scale90.png.jpg)Figure 44-8. Deadlock
    between processes opening two FIFOs'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Nonblocking *read()* and *write()*
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `O_NONBLOCK` flag affects not only the semantics of *open()* but also—because
    the flag then remains set for the open file description—the semantics of subsequent
    *read()* and *write()* calls. We describe these effects in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to change the state of the `O_NONBLOCK` flag for a FIFO
    (or another type of file) that is already open. Scenarios where this need may
    arise include the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We opened a FIFO using `O_NONBLOCK`, but we want subsequent *read()* and *write()*
    calls to operate in blocking mode.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to enable nonblocking mode for a file descriptor that was returned by
    *pipe()*. More generally, we might want to change the nonblocking status of any
    file descriptor that was obtained other than from a call to *open()*—for example,
    one of the three standard descriptors that are automatically opened for each new
    program run by the shell or a file descriptor returned by *socket()*.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some application-specific purpose, we need to switch the setting of the
    `O_NONBLOCK` setting of a file descriptor on and off.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these purposes, we can use *fcntl()* to enable or disable the `O_NONBLOCK`
    open file status flag. To enable the flag, we write the following (omitting error
    checking):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And to disable it, we write the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Semantics of *read()* and *write()* on Pipes and FIFOs
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 44-2](ch44.html#semantics_of_reading_n_bytes_from_a_pipe "Table 44-2. Semantics
    of reading n bytes from a pipe or FIFO containing p bytes") summarizes the operation
    of *read()* for pipes and FIFOs, and includes the effect of the `O_NONBLOCK` flag.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between blocking and nonblocking reads occurs when no data
    is present and the write end is open. In this case, a normal *read()* blocks,
    while a nonblocking *read()* fails with the error `EAGAIN`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-2. Semantics of reading *n* bytes from a pipe or FIFO containing *p*
    bytes
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| `O_NONBLOCK` enabled? | Data bytes available in pipe or FIFO (*p*) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| *p = 0*, write end open | *p = 0*, write end closed | *p < n* | *p >= n*
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| No | block | return 0 (EOF) | read *p* bytes | read *n* bytes |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| Yes | fail (`EAGAIN`) | return 0 (EOF) | read *p* bytes | read *n* bytes
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: The impact of the `O_NONBLOCK` flag when writing to a pipe or FIFO is made complex
    by interactions with the `PIPE_BUF` limit. The *write()* behavior is summarized
    in [Table 44-3](ch44.html#semantics_of_writing_n_bytes_to_a_pipe_o "Table 44-3. Semantics
    of writing n bytes to a pipe or FIFO").
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Table 44-3. Semantics of writing *n* bytes to a pipe or FIFO
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| `O_NONBLOCK` enabled? | Read end open | Read end closed |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| *n <= PIPE_BUF* | *n > PIPE_BUF* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| No | Atomically write *n* bytes; may block until sufficient data is read
    for *write()* to be performed | Write *n* bytes; may block until sufficient data
    read for *write()* to complete; data may be interleaved with writes by other processes
    | `SIGPIPE`+`EPIPE` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| Yes | If sufficient space is available to immediately write *n* bytes, then
    *write()* succeeds atomically; otherwise, it fails (`EAGAIN`) | If there is sufficient
    space to immediately write some bytes, then write between 1 and *n* bytes (which
    may be interleaved with data written by other processes); otherwise, *write()*
    fails (`EAGAIN`) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: The `O_NONBLOCK` flag causes a *write()* on a pipe or FIFO to fail (with the
    error `EAGAIN`) in any case where data can’t be transferred immediately. This
    means that if we are writing up to `PIPE_BUF` bytes, then the *write()* will fail
    if there is not sufficient space in the pipe or FIFO, because the kernel can’t
    complete the operation immediately and can’t perform a partial write, since that
    would break the requirement that writes of up to `PIPE_BUF` bytes are atomic.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: When writing more than `PIPE_BUF` bytes at a time, a write is not required to
    be atomic. For this reason, *write()* transfers as many bytes as possible (a partial
    write) to fill up the pipe or FIFO. In this case, the return value from *write()*
    is the number of bytes actually transferred, and the caller must retry later in
    order to write the remaining bytes. However, if the pipe or FIFO is full, so that
    not even one byte can be transferred, then *write()* fails with the error `EAGAIN`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pipes were the first method of IPC under the UNIX system, and they are used
    frequently by the shell, as well as in other applications. A pipe is a unidirectional,
    limited-capacity byte stream that can be used for communication between related
    processes. Although blocks of data of any size can be written to a pipe, only
    writes that do not exceed `PIPE_BUF` bytes are guaranteed to be atomic. As well
    as being used as a method of IPC, pipes can also be used for process synchronization.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: When using pipes, we must be careful to close unused descriptors in order to
    ensure that reading processes detect end-of-file and writing processes receive
    the `SIGPIPE` signal or the `EPIPE` error. (Usually, it is easiest to have the
    application writing to a pipe ignore `SIGPIPE` and detect a “broken” pipe via
    the `EPIPE` error.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The *popen()* and *pclose()* functions allow a program to transfer data to or
    from a standard shell command, without needing to handle the details of creating
    a pipe, execing a shell, and closing unused file descriptors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: FIFOs operate in exactly the same way as pipes, except that they are created
    using *mkfifo()*, have a name in the file system, and can be opened by any process
    with appropriate permissions. By default, opening a FIFO for reading blocks until
    another process opens the FIFO for writing, and vice versa.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In the course of this chapter, we looked at a number of related topics. First,
    we saw how to duplicate file descriptors in such a manner that the standard input
    or output of a filter can be bound to a pipe. While presenting a client-server
    example using FIFOs, we touched on a number of topics in client-server design,
    including the use of a well-known address for a server and iterative versus concurrent
    server design. In developing the example FIFO application, we noted that, although
    data transmitted through a pipe is a byte stream, it is sometimes useful for communicating
    processes to package the data into messages, and we looked at various ways in
    which this could be accomplished.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we noted the effect of the `O_NONBLOCK` (nonblocking I/O) flag when
    opening and performing I/O on a FIFO. The `O_NONBLOCK` flag is useful if we don’t
    want to block while opening a FIFO. It is also useful if we don’t want reads to
    block if no data is available, or writes to block if there is insufficient space
    within a pipe or FIFO.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The implementation of pipes is discussed in [Bach, 1986] and [Bovet & Cesati,
    2005]. Useful details about pipes and FIFOs can also be found in [Vahalia, 1996].
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program that uses two pipes to enable bidirectional communication between
    a parent and child process. The parent process should loop reading a block of
    text from standard input and use one of the pipes to send the text to the child,
    which converts it to uppercase and sends it back to the parent via the other pipe.
    The parent reads the data coming back from the child and echoes it on standard
    output before continuing around the loop once more.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement *popen()* and *pclose()*. Although these functions are simplified
    by not requiring the signal handling employed in the implementation of *system()*
    ([Implementing *system()*](ch27.html#implementing_system_open_parenthesis_clo
    "Implementing system()")), you will need to be careful to correctly bind the pipe
    ends to file streams in each process, and to ensure that all unused descriptors
    referring to the pipe ends are closed. Since children created by multiple calls
    to *popen()* may be running at one time, you will need to maintain a data structure
    that associates the file stream pointers allocated by *popen()* with the corresponding
    child process IDs. (If using an array for this purpose, the value returned by
    the *fileno()* function, which obtains the file descriptor corresponding to a
    file stream, can be used to index the array.) Obtaining the correct process ID
    from this structure will allow *pclose()* to select the child upon which to wait.
    This structure will also assist with the SUSv3 requirement that any still-open
    file streams created by earlier calls to *popen()* must be closed in the new child
    process.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) always starts assigning
    sequence numbers from 0 each time it is started. Modify the program to use a backup
    file that is updated each time a sequence number is assigned. (The *open()* `O_SYNC`
    flag, described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"), may be useful.) At startup, the
    program should check for the existence of this file, and if it is present, use
    the value it contains to initialize the sequence number. If the backup file can’t
    be found on startup, the program should create a new file and start assigning
    sequence numbers beginning at 0\. (An alternative to this technique would be to
    use memory-mapped files, described in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings").)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to the server in [Example 44-7](ch44.html#an_iterative_server_using_fifos
    "Example 44-7. An iterative server using FIFOs") (`fifo_seqnum_server.c`) so that
    if the program receives the `SIGINT` or `SIGTERM` signals, it removes the server
    FIFO and terminates.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) performs a second `O_WRONLY`
    open of the FIFO so that it never sees end-of-file when reading from the reading
    descriptor (*serverFd*) of the FIFO. Instead of doing this, an alternative approach
    could be tried: whenever the server sees end-of-file on the reading descriptor,
    it closes the descriptor, and then once more opens the FIFO for reading. (This
    open would block until the next client opened the FIFO for writing.) What is wrong
    with this approach?'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs") (`fifo_seqnum_server.c`) assumes that the client
    process is well behaved. If a misbehaving client created a client FIFO and sent
    a request to the server, but did not open its FIFO, then the server’s attempt
    to open the client FIFO would block, and other client’s requests would be indefinitely
    delayed. (If done maliciously, this would constitute a *denial-of-service attack*.)
    Devise a scheme to deal with this problem. Extend the server (and possibly the
    client in [Example 44-8](ch44.html#client_for_the_sequence-number_server "Example 44-8. Client
    for the sequence-number server")) accordingly.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write programs to verify the operation of nonblocking opens and nonblocking
    I/O on FIFOs (see [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1 "Nonblocking
    I/O")).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
