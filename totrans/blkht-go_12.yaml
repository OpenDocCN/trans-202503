- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: WINDOWS SYSTEM INTERACTION AND ANALYSIS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOWS系统交互与分析
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: There are countless ways of developing Microsoft Windows attacks—too many to
    cover in this chapter. Instead of discussing them all, we’ll introduce and investigate
    a few techniques that can help you attack Windows, whether initially or during
    your post-exploitation adventures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种开发微软Windows攻击的方法——太多了，无法在本章中一一覆盖。我们不会讨论所有方法，而是介绍并研究一些技术，这些技术无论是在最初阶段还是在后期利用过程中，都可以帮助你攻击Windows系统。
- en: After discussing the Microsoft API documentation and some safety concerns, we’ll
    cover three topics. First, we’ll use Go’s core `syscall` package to interact with
    various system-level Windows APIs by performing a process injection. Second, we’ll
    explore Go’s core package for the Windows Portable Executable (PE) format and
    write a PE file format parser. Third, we’ll discuss techniques for using C code
    with native Go code. You’ll need to know these applied techniques in order to
    build a novel Windows attack.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完微软API文档和一些安全问题后，我们将讨论三个主题。首先，我们将使用Go的核心`syscall`包，通过执行进程注入来与各种系统级Windows
    API进行交互。第二，我们将探索Go的核心包，用于处理Windows便携式可执行文件（PE）格式，并编写一个PE文件格式解析器。第三，我们将讨论使用C代码与原生Go代码结合的技术。你需要掌握这些应用技术，才能构建出创新的Windows攻击。
- en: The Windows API’s OpenProcess() Function
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows API的OpenProcess()函数
- en: In order to attack Windows, you need to understand the Windows API. Let’s explore
    the Windows API documentation by examining the `OpenProcess()` function, used
    to obtain a handle on a remote process. You can find the `OpenProcess()` documentation
    at [*https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/*](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/).
    [Figure 12-1](ch12.xhtml#ch12fig1) shows the function’s object property details.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要攻击Windows系统，你需要了解Windows API。我们将通过查看`OpenProcess()`函数来探索Windows API文档，该函数用于获取远程进程的句柄。你可以在[*https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/*](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/)找到`OpenProcess()`的文档。*图12-1*展示了该函数的对象属性详细信息。
- en: '![Image](Images/12fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/12fig01.jpg)'
- en: '*Figure 12-1: The Windows API object structure for* OpenProcess()'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：* OpenProcess()的Windows API对象结构'
- en: In this particular instance, we can see that the object looks very similar to
    a struct type in Go. However, the C++ struct field types don’t necessarily reconcile
    with Go types, and Microsoft data types don’t always match Go data types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们可以看到该对象看起来非常像Go中的结构体类型。然而，C++结构体字段类型未必与Go类型相匹配，微软数据类型也不总是与Go数据类型对接。
- en: The Windows data type definition reference, located at [*https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/*](https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/),
    can be helpful when reconciling a Windows data type with Go’s respective data
    type. [Table 12-1](ch12.xhtml#ch12tab1) covers the type conversion we’ll use in
    the process injection examples later in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows数据类型定义参考位于[*https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/*](https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/)，在将Windows数据类型与Go的相应数据类型对照时，这一参考非常有帮助。[表12-1](ch12.xhtml#ch12tab1)展示了我们将在本章后面使用的类型转换。
- en: '**Table 12-1:** Mapping Windows Data Types to Go Data Types'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** 将Windows数据类型映射到Go数据类型'
- en: '| **Windows data Type** | **Go data type** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **Windows数据类型** | **Go数据类型** |'
- en: '| `BOOLEAN` | `byte` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `BOOLEAN` | `byte` |'
- en: '| `BOOL` | `int32` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `BOOL` | `int32` |'
- en: '| `BYTE` | `byte` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `BYTE` | `byte` |'
- en: '| `DWORD` | `uint32` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `DWORD` | `uint32` |'
- en: '| `DWORD32` | `uint32` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `DWORD32` | `uint32` |'
- en: '| `DWORD64` | `uint64` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `DWORD64` | `uint64` |'
- en: '| `WORD` | `uint16` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `WORD` | `uint16` |'
- en: '| `HANDLE` | `uintptr (unsigned integer pointer)` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `HANDLE` | `uintptr（无符号整数指针）` |'
- en: '| `LPVOID` | `uintptr` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `LPVOID` | `uintptr` |'
- en: '| `SIZE_T` | `uintptr` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `SIZE_T` | `uintptr` |'
- en: '| `LPCVOID` | `uintptr` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `LPCVOID` | `uintptr` |'
- en: '| `HMODULE` | `uintptr` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `HMODULE` | `uintptr` |'
- en: '| `LPCSTR` | `uintptr` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `LPCSTR` | `uintptr` |'
- en: '| `LPDWORD` | `uintptr` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `LPDWORD` | `uintptr` |'
- en: The Go documentation defines the `uintptr` data type as “an integer type that
    is large enough to hold the bit pattern of any pointer.” This is a special data
    type, as you’ll see when we discuss Go’s `unsafe` package and type conversions
    later in “The unsafe.Pointer and uintptr Types” on [page 266](#page_266). For
    now, let’s finish walking through the Windows API documentation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Go 文档将 `uintptr` 数据类型定义为“足够大的整数类型，可以容纳任何指针的位模式。”这是一个特殊的数据类型，正如您将在后面讨论 Go 的 `unsafe`
    包和类型转换时看到的那样，特别是在“unsafe.Pointer 和 uintptr 类型”部分，位于[第 266 页](#page_266)。现在，让我们继续完成
    Windows API 文档的阅读。
- en: Next, you should look at an object’s parameters; the Parameters section of the
    documentation provides details. For example, the first parameter, `dwDesiredAccess`,
    provides specifics regarding the level of access the process handle should possess.
    After that, the Return Value section defines expected values for both a successful
    and failed system call ([Figure 12-2](ch12.xhtml#ch12fig2)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该查看对象的参数；文档中的参数部分提供了详细信息。例如，第一个参数 `dwDesiredAccess` 提供了有关进程句柄应具有的访问级别的具体信息。之后，返回值部分定义了系统调用成功和失败的预期值（见[图
    12-2](ch12.xhtml#ch12fig2)）。
- en: '![Image](Images/12fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig02.jpg)'
- en: '*Figure 12-2: The definition for the expected return value*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：预期返回值的定义*'
- en: We’ll take advantage of a `GetLastError` error message when using the `syscall`
    package in our upcoming example code, although this will deviate from the standard
    error handling (such as if `err != nil` syntax) ever so slightly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的示例代码中，我们将利用 `syscall` 包中的 `GetLastError` 错误消息，尽管这会稍微偏离标准的错误处理方式（例如 `err
    != nil` 语法）。
- en: Our last section of the Windows API document, Requirements, provides important
    details, as shown in [Figure 12-3](ch12.xhtml#ch12fig3). The last line defines
    the *dynamic link library (DLL)*, which contains exportable functions (such as
    `OpenProcess()`) and will be necessary when we build out our Windows DLL module’s
    variable declarations. Said another way, we cannot call the relevant Windows API
    function from Go without knowing the appropriate Windows DLL module. This will
    become clearer as we progress into our upcoming process injection example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Windows API 文档的最后一部分“要求”提供了重要的细节，如[图 12-3](ch12.xhtml#ch12fig3)所示。最后一行定义了
    *动态链接库（DLL）*，该库包含可导出的函数（例如 `OpenProcess()`），并且在我们构建 Windows DLL 模块的变量声明时将是必需的。换句话说，我们不能在
    Go 中调用相关的 Windows API 函数，除非知道适当的 Windows DLL 模块。随着我们继续进行下一个进程注入示例，这一点会变得更加清晰。
- en: '![Image](Images/12fig03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig03.jpg)'
- en: '*Figure 12-3: The Requirements section defines the library required to call
    the API.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：要求部分定义了调用 API 所需的库。*'
- en: The unsafe.Pointer and uintptr Types
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: unsafe.Pointer 和 uintptr 类型
- en: In dealing with the Go `syscall` package, we’ll most certainly need to step
    around Go’s type-safety protections. The reason is that we’ll need, for example,
    to establish shared memory structures and perform type conversions between Go
    and C. This section provides the groundwork you need in order to manipulate memory,
    but you should also explore Go’s official documentation further.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Go 的 `syscall` 包时，我们必须绕过 Go 的类型安全保护。原因是我们需要进行例如建立共享内存结构，并在 Go 和 C 之间执行类型转换等操作。本节为您提供了操控内存所需的基础知识，但您还应该进一步探索
    Go 的官方文档。
- en: 'We’ll bypass Go’s safety precautions by using Go’s `unsafe` package (mentioned
    in [Chapter 9](ch09.xhtml#ch9)), which contains operations that step around the
    type safety of Go programs. Go has laid out four fundamental guidelines to help
    us out:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 Go 的 `unsafe` 包（在[第 9 章](ch09.xhtml#ch9)中提到）绕过 Go 的安全措施，该包包含可以绕过 Go
    程序类型安全性的操作。Go 提供了四个基本准则来帮助我们：
- en: A pointer value of any type can be converted to an `unsafe.Pointer`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型的指针值都可以转换为 `unsafe.Pointer`。
- en: An `unsafe.Pointer` can be converted to a pointer value of any type.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsafe.Pointer` 可以转换为任何类型的指针值。'
- en: A `uintptr` can be converted to an `unsafe.Pointer`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uintptr` 可以转换为 `unsafe.Pointer`。'
- en: An `unsafe.Pointer` can be converted to a `uintptr`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsafe.Pointer` 可以转换为 `uintptr`。'
- en: '**WARNING**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Keep in mind that packages that import the* `unsafe` *package may not be portable,
    and that although Go typically ensures Go version 1 compatibility, using the*
    `unsafe` *package breaks all guarantees of this.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，导入了 `unsafe` 包的包可能不具备可移植性，并且尽管 Go 通常确保 Go 版本 1 的兼容性，使用 `unsafe` 包会破坏所有关于这一点的保证。*'
- en: The `uintptr` type allows you to perform type conversion or arithmetic between
    native safe types, among other uses. Although `uintptr` is an integer type, it’s
    used extensively to represent a memory address. When used with type-safe pointers,
    Go’s native garbage collector will maintain relevant references at runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`uintptr` 类型允许你在原生安全类型之间进行类型转换或运算等操作。虽然 `uintptr` 是一个整数类型，但它广泛用于表示内存地址。当与类型安全的指针一起使用时，Go
    的原生垃圾回收器会在运行时维护相关的引用。'
- en: However, the situation changes when `unsafe.Pointer` is introduced. Recall that
    `uintptr` is essentially just an unsigned integer. If a pointer value is created
    using `unsafe.Pointer` and then assigned to `uintptr`, there’s no guarantee that
    Go’s garbage collector will maintain the integrity of the referenced memory location’s
    value. [Figure 12-4](ch12.xhtml#ch12fig4) helps to further describe the issue.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当引入 `unsafe.Pointer` 时，情况发生了变化。回想一下，`uintptr` 本质上只是一个无符号整数。如果通过 `unsafe.Pointer`
    创建一个指针值，然后将其分配给 `uintptr`，则不能保证 Go 的垃圾回收器会维护被引用内存位置的值的完整性。[图 12-4](ch12.xhtml#ch12fig4)
    有助于进一步描述这个问题。
- en: '![Image](Images/12fig04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig04.jpg)'
- en: '*Figure 12-4: A potentially dangerous pointer when using* uintptr *and* unsafe.Pointer'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：使用* uintptr *和* unsafe.Pointer 时可能存在的危险指针'
- en: The top half of the image depicts `uintptr` with a reference value to a Go type-safe
    pointer. As such, it will maintain its reference at runtime, along with austere
    garbage collection. The lower half of the image demonstrates that `uintptr`, although
    it references an `unsafe.Pointer` type, can be garbage collected, considering
    Go doesn’t preserve nor manage pointers to arbitrary data types. [Listing 12-1](ch12.xhtml#ch12list1)
    represents the issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的上半部分展示了 `uintptr` 与一个 Go 类型安全指针的引用值。因此，它将在运行时维护其引用，并且会进行严格的垃圾回收。图片的下半部分展示了虽然
    `uintptr` 引用了一个 `unsafe.Pointer` 类型，但它可以被垃圾回收，因为 Go 不会保存或管理指向任意数据类型的指针。[清单 12-1](ch12.xhtml#ch12list1)
    展示了这个问题。
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: Using* uintptr *both securely and insecurely with* unsafe.Pointer'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-1：使用* uintptr *同时安全和不安全地与* unsafe.Pointer 配合使用'
- en: This code listing could be someone’s attempt at creating a state machine, for
    example. It has three variables, assigned their respective pointer values of `onload`
    ❶, `receive` ❷, and `success` ❸ by calling the `createEvents()` ❽ function. We
    then create a map containing a key of type `string` along with a value of type
    `interface{}`. We use the `interface{}` type because it can receive disparate
    data types. In this case, we’ll use it to receive both `unsafe.Pointer` ❹ and
    `uintptr` ❺ values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例可能是某人在尝试创建状态机的代码。例如，它有三个变量，通过调用`createEvents()` ❽ 函数将它们的指针值分别赋值为 `onload`
    ❶、`receive` ❷ 和 `success` ❸。然后，我们创建一个包含`string`类型的键以及`interface{}`类型的值的映射。我们使用`interface{}`类型，因为它可以接收不同的数据类型。在这种情况下，我们将它用来接收`unsafe.Pointer`
    ❹ 和 `uintptr` ❺ 的值。
- en: At this point, you most likely have spotted the dangerous pieces of code. Although
    the `mapEvents["messageRecieve"]` map entry ❹ is of type `unsafe.Pointer`, it
    still maintains its original reference to the `receive` ❷ variable and will provide
    the same consistent output ❻ as it did originally. Contrarily, the `mapEvents["messageSuccess"]`
    map entry ❺ is of type `uintptr`. This means that as soon as the `unsafe.Pointer`
    value referencing the `success` variable is assigned to a `uintptr` type, the
    `success` variable ❸ is free to be garbage collected. Again, `uintptr` is just
    a type holding a literal integer of a memory address, not a reference to a pointer.
    As a result, there’s no guarantee that the expected output ❼ will be produced,
    as the value may no longer be present.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你很可能已经发现了危险的代码部分。尽管 `mapEvents["messageRecieve"]` 映射条目 ❹ 的类型是 `unsafe.Pointer`，但它仍然保持对
    `receive` ❷ 变量的原始引用，并将提供与最初相同的一致输出 ❻。相反，`mapEvents["messageSuccess"]` 映射条目 ❺ 的类型是
    `uintptr`。这意味着，一旦引用 `success` 变量的 `unsafe.Pointer` 值被分配给 `uintptr` 类型，`success`
    变量 ❸ 就可以被垃圾回收。再次提醒，`uintptr` 只是一个保存内存地址字面值的类型，而不是指针的引用。因此，无法保证会产生预期的输出 ❼，因为该值可能不再存在。
- en: Is there a safe way to use `uintptr` with `unsafe.Pointer`? We can do so by
    taking advantage of `runtime.Keepalive`, which can prevent the garbage collection
    of a variable. Let’s take a look at this by modifying our prior code block ([Listing
    12-2](ch12.xhtml#ch12list2)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种安全的方法可以将 `uintptr` 与 `unsafe.Pointer` 一起使用呢？我们可以通过利用 `runtime.Keepalive`
    来做到这一点，它可以防止变量被垃圾回收。让我们通过修改之前的代码块（[清单 12-2](ch12.xhtml#ch12list2)）来查看这一点。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-2: [Listing 7-2](ch07.xhtml#ch7list2): Using the* runtime.KeepAlive()
    *function to prevent garbage collection of a variable*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-2：[清单 7-2](ch07.xhtml#ch7list2)：使用* runtime.KeepAlive() *函数来防止变量的垃圾回收*'
- en: Seriously, we’ve added only one small line of code ❸! This line, `runtime.KeepAlive(success)`,
    tells the Go runtime to ensure that the `success` variable remains accessible
    until it’s explicitly released or the run state ends. This means that although
    the `success` variable ❶ is stored as `uintptr` ❷, it can’t be garbage collected
    because of the explicit `runtime.KeepAlive()` directive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的，我们只添加了一行小小的代码❸！这行代码 `runtime.KeepAlive(success)` 告诉 Go 运行时确保 `success` 变量在显式释放或运行状态结束之前始终保持可访问。这意味着尽管
    `success` 变量❶被存储为 `uintptr` ❷，它不能被垃圾回收，因为有了显式的 `runtime.KeepAlive()` 指令。
- en: Be aware that the Go `syscall` package extensively uses `uintptr(unsafe``.Pointer()``)`
    throughout, and although certain functions, like `syscall9()`, have type safety
    through exception, not all the functions employ this. Further, as you hack about
    your own project code, you’ll almost certainly run into situations that warrant
    manipulating heap or stack memory in an unsafe manner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go 的 `syscall` 包广泛使用 `uintptr(unsafe``.Pointer()``)`，尽管某些函数，如 `syscall9()`，通过异常提供类型安全，但并非所有函数都使用这种方式。此外，在你自己项目代码的黑客攻击过程中，你几乎肯定会遇到需要以不安全的方式操作堆或栈内存的情况。
- en: Performing Process Injection with the syscall Package
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 syscall 包进行进程注入
- en: Often, we need to inject our own code into a process. This may be because we
    want to gain remote command line access to a system (shell), or even debug a runtime
    application when the source code isn’t available. Understanding the mechanics
    of process injection will also help you perform more interesting tasks, such as
    loading memory-resident malware or hooking functions. Either way, this section
    demonstrates how to use Go to interact with the Microsoft Windows APIs in order
    to perform process injection. We’ll inject a payload stored on a disk into existing
    process memory. [Figure 12-5](ch12.xhtml#ch12fig5) describes the overall chain
    of events.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要将自己的代码注入到一个进程中。这可能是因为我们希望获得对系统的远程命令行访问（shell），或者在源代码不可用时调试运行中的应用程序。了解进程注入的机制还将帮助你执行更有趣的任务，例如加载驻留内存中的恶意软件或钩取函数。不管怎样，本节将演示如何使用
    Go 语言与 Microsoft Windows API 交互以执行进程注入。我们将把存储在磁盘上的有效载荷注入到现有进程的内存中。[图 12-5](ch12.xhtml#ch12fig5)
    描述了整个事件链。
- en: '![Image](Images/12fig05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/12fig05.jpg)'
- en: '*Figure 12-5: Basic process injection*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：基本进程注入*'
- en: In step 1, we use the `OpenProcess()` Windows function to establish a process
    handle, along with the desired process access rights. This is a requirement for
    process-level interaction, whether we’re dealing with a local or remote process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用 `OpenProcess()` Windows 函数来建立进程句柄，并设置所需的进程访问权限。这是进行进程级交互的必要条件，无论我们处理的是本地进程还是远程进程。
- en: Once the requisite process handle has been obtained, we use it in step 2, along
    with the `VirtualAllocEx()` Windows function, to allocate virtual memory within
    the remote process. This is a requirement for loading byte-level code, such as
    shellcode or a DLL, into the remote processes’ memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了必要的进程句柄，我们将在第 2 步中使用它，并结合 `VirtualAllocEx()` Windows 函数，为远程进程分配虚拟内存。这是将字节级代码（例如
    shellcode 或 DLL）加载到远程进程内存中的必要条件。
- en: In step 3, we load byte-level code into memory by using the `WriteProcessMemory()`
    Windows function. At this point in the injection process, we, as attackers, get
    to decide how creative to be with our shellcode or DLL. This is also the place
    where you might need to inject debugging code when attempting to understand a
    running program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步中，我们通过使用 `WriteProcessMemory()` Windows 函数将字节级代码加载到内存中。在注入过程中，我们作为攻击者，决定如何创意地编写我们的
    shellcode 或 DLL。这也是你可能需要注入调试代码的地方，尤其是在试图理解一个正在运行的程序时。
- en: Finally, in step 4, we use the `CreateRemoteThread()` Windows function as a
    means to call a native exported Windows DLL function, such as `LoadLibraryA()`,
    located in *Kernel32.dll*, so that we can execute the code previously placed within
    the process by using `WriteProcessMemory()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第 4 步中，我们使用 `CreateRemoteThread()` Windows 函数作为调用本地导出的 Windows DLL 函数（例如位于
    *Kernel32.dll* 中的 `LoadLibraryA()`）的方法，以便我们可以执行之前通过 `WriteProcessMemory()` 放置在进程中的代码。
- en: The four steps we just described provide a fundamental process injection example.
    We’ll define a few additional files and functions within our overall process injection
    example that aren’t necessarily described here, although we’ll describe them in
    detail as we encounter them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的四个步骤提供了一个基本的进程注入示例。我们将在整体进程注入示例中定义一些额外的文件和函数，尽管这些内容不一定在这里详细描述，但我们会在遇到时逐一说明。
- en: Defining the Windows DLLs and Assigning Variables
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 Windows DLL 并分配变量
- en: The first step is to create the *winmods* file in [Listing 12-3](ch12.xhtml#ch12list3).
    (All the code listings at the root location of / exist under the provided github
    repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
    This file defines the native Windows DLL, which maintains exported system-level
    APIs, that we’ll call by using the Go `syscall` package. The *winmods* file contains
    declarations and assignments of more Windows DLL module references than required
    for our sample project, but we’ll document them so that you can leverage those
    in more advanced injection code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建 *winmods* 文件，见 [清单 12-3](ch12.xhtml#ch12list3)。（所有位于根位置的代码清单都存在于提供的 GitHub
    仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中。）此文件定义了原生的 Windows DLL，包含我们将通过 Go 的 `syscall` 包调用的导出系统级 API。*winmods* 文件包含比我们的示例项目所需更多的
    Windows DLL 模块引用的声明和分配，但我们会记录它们，方便你在更高级的注入代码中使用。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-3: The* winmods *file (*[/ch-12/procInjector/winsys/winmods.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/winmods.go)*)*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：* winmods *文件 (*[/ch-12/procInjector/winsys/winmods.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/winmods.go)*)*'
- en: 'We use the `NewLazyDLL()` method to load the `Kernel32` DLL ❶. `Kernel32` manages
    much of the internal Windows process functionality, such as addressing, handling,
    memory allocation, and more. (It’s worth noting that, as of Go version 1.12.2,
    you can use a couple of new functions to better load DLLs and prevent system DLL
    hijacking attacks: `LoadLibraryEx()` and `NewLazySystemDLL()`.)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `NewLazyDLL()` 方法加载 `Kernel32` DLL ❶。`Kernel32` 管理 Windows 内部的许多进程功能，例如寻址、处理、内存分配等。（值得注意的是，从
    Go 版本 1.12.2 开始，你可以使用几个新函数来更好地加载 DLL 并防止系统 DLL 劫持攻击：`LoadLibraryEx()` 和 `NewLazySystemDLL()`。）
- en: Before we can interact with the DLL, we must establish a variable that we can
    use in our code. We do this by calling `module.NewProc` for each API that we’ll
    need to use. At ❷, we call it against `OpenProcess()` and assign it to an exported
    variable called `ProcOpenProcess`. The use of `OpenProcess()` is arbitrary; it’s
    intended to demonstrate the technique for assigning any exported Windows DLL function
    to a descriptive variable name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与 DLL 交互之前，必须建立一个可以在代码中使用的变量。我们通过调用 `module.NewProc` 为每个需要使用的 API 进行定义。在
    ❷ 处，我们调用 `OpenProcess()` 并将其分配给一个名为 `ProcOpenProcess` 的导出变量。使用 `OpenProcess()`
    是任意的；它旨在演示如何将任何导出的 Windows DLL 函数分配给一个描述性变量名的技巧。
- en: Obtaining a Process Token with the OpenProcess Windows API
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 OpenProcess Windows API 获取进程令牌
- en: Next, we build out the `OpenProcessHandle()` function, which we’ll use to obtain
    a process handle token. We will likely use the terms *token* and *handle* interchangeably
    throughout the code, but realize that every process within a Windows system has
    a unique process token. This provides a means to enforce relevant security models,
    such as *Mandatory Integrity Control*, a complex security model (and one that
    is worth investigating in order to get more acquainted with process-level mechanics).
    The security models consist of such items as process-level rights and privileges,
    for example, and dictate how both unprivileged and elevated processes can interact
    with one another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建 `OpenProcessHandle()` 函数，用于获取进程句柄令牌。我们可能会在代码中交替使用 *token*（令牌）和 *handle*（句柄）这两个术语，但要明白，每个
    Windows 系统中的进程都有一个唯一的进程令牌。它提供了一种执行相关安全模型的手段，例如 *强制完整性控制*，这是一种复杂的安全模型（值得研究，以更好地了解进程级别的机制）。这些安全模型包括进程级别的权限和特权，例如，并规定了普通进程和提升权限进程如何相互作用。
- en: First, let’s take a look at the C++ `OpenProcess()` data structure as defined
    within the Window API documentation ([Listing 12-4](ch12.xhtml#ch12list4)). We’ll
    define this object as if we intended to call it from native Windows C++ code.
    However, we won’t be doing this, because we’ll be defining this object to be used
    with Go’s `syscall` package. Therefore, we’ll need to translate this object to
    standard Go data types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看C++ `OpenProcess()`数据结构，按照Windows API文档中的定义（[Listing 12-4](ch12.xhtml#ch12list4)）。我们将定义这个对象，就像我们打算从本机Windows
    C++代码中调用它一样。然而，我们并不会这么做，因为我们将定义这个对象以便与Go的`syscall`包一起使用。因此，我们需要将这个对象转换为标准的Go数据类型。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 12-4: An arbitrary Windows C++ object and data types*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-4: 任意的Windows C++对象和数据类型*'
- en: The first necessary task is to translate `DWORD` ❶ to a usable type that Go
    maintains. A `DWORD` is defined by Microsoft as a 32-bit unsigned integer, which
    corresponds to Go’s `uint32` type. The `DWORD` value states that it must contain
    `dwDesiredAccess` or, as the documentation states, “one or more of the process
    access rights.” Process access rights define the actions we wish to take upon
    a process, given a valid process token.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要做的任务是将`DWORD` ❶转换为Go所支持的可用类型。`DWORD`由微软定义为32位无符号整数，等同于Go的`uint32`类型。`DWORD`值表明它必须包含`dwDesiredAccess`，或者正如文档所述，“一个或多个进程访问权限。”进程访问权限定义了在有效的进程令牌下，我们希望对进程执行的操作。
- en: We want to declare a variety of process access rights. Since these values won’t
    change, we place such relevant values in a Go constants file, as shown in [Listing
    12-5](ch12.xhtml#ch12list5). Each line in this list defines a process access right.
    The list contains almost every available process access right, but we will use
    only the ones necessary for obtaining a process handle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要声明多种进程访问权限。由于这些值不会变化，因此我们将相关值放入Go常量文件中，如[Listing 12-5](ch12.xhtml#ch12list5)所示。列表中的每一行定义了一个进程访问权限。该列表包含了几乎所有可用的进程访问权限，但我们只会使用获取进程句柄所必需的那些。
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 12-5: A constants section declaring process access rights (*[/ch-12/procInjector/winsys/constants.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/constants.go)*)*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-5: 声明进程访问权限的常量部分 (*[/ch-12/procInjector/winsys/constants.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/constants.go)*)*'
- en: All the process access rights we defined in [Listing 12-5](ch12.xhtml#ch12list5)
    reconcile with their respective constant hexadecimal values, which is the format
    they need to be in to assign them to a Go variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[Listing 12-5](ch12.xhtml#ch12list5)中定义的所有进程访问权限都与它们各自的常量十六进制值相匹配，这就是它们需要的格式，以便将它们分配给Go变量。
- en: One issue that we’d like to describe prior to reviewing [Listing 12-6](ch12.xhtml#ch12list6)
    is that most of the following process injection functions, not just `OpenProcessHandle()`,
    will consume a custom object of type `Inject` and return a value of type `error`.
    The `Inject` struct object ([Listing 12-6](ch12.xhtml#ch12list6)) will contain
    various values that will be provided to the relevant Windows function via `syscall`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看[Listing 12-6](ch12.xhtml#ch12list6)之前，有一个问题我们想要描述，那就是，接下来大多数进程注入函数，不仅仅是`OpenProcessHandle()`，将会使用一个类型为`Inject`的自定义对象，并返回一个`error`类型的值。`Inject`结构体对象（[Listing
    12-6](ch12.xhtml#ch12list6)）将包含将通过`syscall`传递给相关Windows函数的各种值。
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-6: The* Inject *struct used to hold certain process injection data
    types* ([/ch-12 /procInjector/winsys/models.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/models.go))'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-6: 用于保存特定进程注入数据类型的* Inject *结构体* ([/ch-12 /procInjector/winsys/models.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/models.go))'
- en: '[Listing 12-7](ch12.xhtml#ch12list7) illustrates our first actual function,
    `OpenProcessHandle()`. Let’s take a look at the following code block and discuss
    the various details.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-7](ch12.xhtml#ch12list7)展示了我们的第一个实际函数，`OpenProcessHandle()`。让我们查看以下代码块并讨论其中的各种细节。'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-7: The* OpenProcessHandle() *function used to obtain a process
    handle* ([/ch-12 /procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go))'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-7: 用于获取进程句柄的* OpenProcessHandle() *函数* ([/ch-12 /procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go))'
- en: The code starts by assigning process access rights to the `uint32` variable
    called `rights` ❶. The actual values assigned include `PROCESS_CREATE_THREAD`,
    which allows us to create a thread on our remote process. Following that is `PROCESS_QUERY_INFORMAITON`,
    which gives us the ability to generically query details about the remote process.
    The last three process access rights, `PROCESS_VM_OPERATION`, `PROCESS_VM_WRITE`,
    and `PROCESS_VM_READ`, all provide the access rights to manage the remote process
    virtual memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过将进程访问权限分配给名为`rights`的`uint32`变量来开始❶。实际分配的值包括`PROCESS_CREATE_THREAD`，它允许我们在远程进程上创建线程。接下来是`PROCESS_QUERY_INFORMAITON`，它使我们能够通用地查询远程进程的详细信息。最后三个进程访问权限，`PROCESS_VM_OPERATION`、`PROCESS_VM_WRITE`和`PROCESS_VM_READ`，都提供了管理远程进程虚拟内存的访问权限。
- en: The next declared variable, `inheritHandle` ❷, dictates whether our new process
    handle will inherit the existing handle. We pass in `0` to indicate a Boolean
    false value, as we want a new process handle. Immediately following is the `processID`
    ❸ variable containing the PID of the victim process. All the while, we reconcile
    our variable types with the Windows API documentation, such that both our declared
    variables are of type `uint32`. This pattern continues until we make the system
    call by using `ProcOpenProcess.Call()` ❻`.`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个声明的变量`inheritHandle` ❷决定了我们的新进程句柄是否会继承现有句柄。我们传入`0`表示布尔值的假（false），因为我们希望获得一个新的进程句柄。紧随其后的是`processID`
    ❸变量，包含了受害进程的PID。与此同时，我们根据Windows API文档协调我们的变量类型，确保我们声明的两个变量都是`uint32`类型。这种模式一直延续，直到我们通过使用`ProcOpenProcess.Call()`
    ❻进行系统调用为止。
- en: The `.Call()` method consumes a varying number of `uintptr` values, which, if
    we were to look at the `Call()` function signature, would be declared literally
    as `...uintptr`. Additionally, the return types are designated as `uintptr` ❹
    and `error` ❺. Further, the error type is named `lastErr` ❺, which you’ll find
    referenced in the Windows API documentation, and contains the returned error value
    as defined by the actual called function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Call()`方法消耗不定数量的`uintptr`值，如果我们查看`Call()`函数签名，实际上它会声明为`...uintptr`。此外，返回类型被指定为`uintptr`
    ❹和`error` ❺。另外，错误类型命名为`lastErr` ❺，你会在Windows API文档中找到它的引用，并且它包含了由实际调用的函数定义的返回错误值。'
- en: Manipulating Memory with the VirtualAllocEx Windows API
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用VirtualAllocEx Windows API操作内存
- en: Now that we have a remote process handle, we need a means to allocate virtual
    memory within the remote process. This is necessary in order to set aside a region
    of memory and initialize it prior to writing to it. Let’s build that out now.
    Place the function defined in [Listing 12-8](ch12.xhtml#ch12list8) immediately
    after the function defined in [Listing 12-7](ch12.xhtml#ch12list7). (We will continue
    to append functions, one after another, as we navigate the process injection code.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了远程进程句柄，需要一种方法在远程进程内分配虚拟内存。这是必要的，以便在写入内存之前为其预留一块内存区域并进行初始化。让我们现在来实现这一点。将[Listing
    12-8](ch12.xhtml#ch12list8)中定义的函数紧接着[Listing 12-7](ch12.xhtml#ch12list7)中定义的函数放置。（随着我们继续操作过程注入代码，函数会一个接一个地追加。）
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-8: Allocating a region of memory in the remote process via* VirtualAllocEx
    ([/ch-12/procInjector /winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go))'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-8: 通过* VirtualAllocEx ([/ch-12/procInjector /winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go))
    *分配远程进程中的内存区域*'
- en: 'Unlike the previous `OpenProcess()` system call, we introduce a new detail
    via the `nullRef` variable ❶. The `nil` keyword is reserved by Go for all `null`
    intents. However, it’s a typed value, which means that passing it directly via
    a `syscall` without a type will result in either a runtime error or a type-conversion
    error—either way, a bad situation. The fix is simple in this case: we declare
    a variable that resolves to a `0` value, such as an integer. The `0` value can
    now be reliably passed and interpreted as a `null` value by the receiving Windows
    function.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`OpenProcess()`系统调用不同，我们通过`nullRef`变量引入了一个新的细节❶。`nil`关键字被Go语言保留用于所有`null`的用途。然而，它是一个类型化的值，这意味着如果直接通过`syscall`传递它而不指定类型，将导致运行时错误或类型转换错误——无论哪种情况，都是不好的。此问题的解决方法很简单：我们声明一个解析为`0`值的变量，例如整数。现在，`0`值可以被可靠地传递并被接收的Windows函数解释为`null`值。
- en: Writing to Memory with the WriteProcessMemory Windows API
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用WriteProcessMemory Windows API写入内存
- en: Next, we’ll use the `WriteProcessMemory()` function to write to the remote process’s
    memory region previously initialized using the `VirtualAllocEx()` function. In
    [Listing 12-9](ch12.xhtml#ch12list9), we’ll keep things simple by calling a DLL
    by file path, rather than writing the entire DLL code into memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `WriteProcessMemory()` 函数将数据写入先前通过 `VirtualAllocEx()` 函数初始化的远程进程内存区域。在
    [示例 12-9](ch12.xhtml#ch12list9) 中，我们将通过文件路径调用 DLL，而不是将整个 DLL 代码写入内存，从而简化处理。
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-9: Writing the DLL file path to remote process memory (*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-9：将 DLL 文件路径写入远程进程内存*（*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*）'
- en: The first noticeable `syscall` function is `BytePtrFromString()` ❶, which is
    a convenience function that consumes a `string` and returns the base index-0 pointer
    location of a `byte` slice, which we’ll assign to `dllPathBytes`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个显著的 `syscall` 函数是 `BytePtrFromString()` ❶，它是一个便捷函数，接受一个 `string` 并返回一个 `byte`
    切片的基地址指针位置，我们将其赋值给 `dllPathBytes`。
- en: Finally, we get to see `unsafe.Pointer` in action. The third argument to the
    `ProcWriteProcessMemory.Call` is defined within the Windows API specification
    as “`lpBuffer`—a pointer to the buffer that contains data to be written in the
    address space of the specified process.” In order to pass the Go pointer value
    defined in `dllPathBytes` over to the receiving Windows function, we use `unsafe.Pointer`
    to circumvent type conversions. One final point to make here is that `uintptr`
    and `unsafe.Pointer` ❷ are acceptably safe, since both are being used inline and
    without the intent of assigning the return value to a variable for later reuse.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到 `unsafe.Pointer` 的实际应用。`ProcWriteProcessMemory.Call` 的第三个参数在 Windows
    API 规范中定义为 “`lpBuffer`——指向包含要写入指定进程地址空间数据的缓冲区的指针。” 为了将 `dllPathBytes` 中定义的 Go
    指针值传递给接收的 Windows 函数，我们使用 `unsafe.Pointer` 来绕过类型转换。这里需要最后提到的一点是，`uintptr` 和 `unsafe.Pointer`
    ❷ 是可以安全使用的，因为它们都在内联中使用，并且没有将返回值分配给变量以便后续重用的意图。
- en: Finding LoadLibraryA with the GetProcessAddress Windows API
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 GetProcessAddress Windows API 查找 LoadLibraryA
- en: '*Kernel32.dll* exports a function called `LoadLibraryA()`, which is available
    on all Windows versions. Microsoft documentation states that `LoadLibraryA()`
    “loads the specified module into the address space of the calling process. The
    specified module may cause other modules to be loaded.” We need to obtain the
    memory location of `LoadLibraryA()` before creating a remote thread necessary
    to execute our actual process injection. We can do this with the `GetLoadLibAddress()`
    function—one of those supporting functions mentioned earlier ([Listing 12-10](ch12.xhtml#ch12list10)).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kernel32.dll* 导出了一个名为 `LoadLibraryA()` 的函数，它在所有 Windows 版本中都可用。微软文档中指出，`LoadLibraryA()`
    “将指定模块加载到调用进程的地址空间中。指定的模块可能会导致其他模块被加载。” 在创建必要的远程线程以执行我们的实际进程注入之前，我们需要获取 `LoadLibraryA()`
    的内存位置。我们可以通过 `GetLoadLibAddress()` 函数来实现这一点——这是前面提到的支持函数之一（[示例 12-10](ch12.xhtml#ch12list10)）。'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 12-10: Obtaining the* LoadLibraryA() *memory address by using the*
    GetProcessAddress() *Windows function (*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-10：通过使用* GetProcessAddress() *Windows 函数获取* LoadLibraryA() *内存地址*（*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*）'
- en: 'We use the `GetProcessAddress()` Windows function to identify the base memory
    address of `LoadLibraryA()` necessary to call the `CreateRemoteThread()` function.
    The `ProcGetProcAddress.Call()` ❷ function takes two arguments: the first is a
    handle to `Kernel32.dll` ❸ that contains the exported function we’re interested
    in (`LoadLibraryA()`), and the second is the base index-0 pointer location ❹ of
    a `byte` slice returned from the literal string `"LoadLibraryA"` ❶.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `GetProcessAddress()` Windows 函数来识别调用 `CreateRemoteThread()` 函数所需的 `LoadLibraryA()`
    基本内存地址。`ProcGetProcAddress.Call()` ❷ 函数接受两个参数：第一个是包含我们感兴趣的导出函数（`LoadLibraryA()`）的
    `Kernel32.dll` ❸ 的句柄，第二个是从字面字符串 `"LoadLibraryA"` ❶ 返回的 `byte` 切片的基地址指针位置 ❹。
- en: Executing the Malicious DLL Using the CreateRemoteThread Windows API
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 CreateRemoteThread Windows API 执行恶意 DLL
- en: We’ll use the `CreateRemoteThread()` Windows function to create a thread against
    the remote process’ virtual memory region. If that region happens to be `LoadLibraryA()`,
    we now have a means to load and execute the region of memory containing the file
    path to our malicious DLL. Let’s review the code in [Listing 12-11](ch12.xhtml#ch12list11).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `CreateRemoteThread()` Windows 函数，在远程进程的虚拟内存区域中创建一个线程。如果该区域恰好是 `LoadLibraryA()`，我们现在就有办法加载并执行包含我们恶意
    DLL 文件路径的内存区域。让我们回顾一下[清单 12-11](ch12.xhtml#ch12list11)中的代码。
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 12-11: Executing the process injection by using the* CreateRemoteThread()
    *Windows function (*[/ch-12 /procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-11：使用* CreateRemoteThread() *Windows 函数执行进程注入 (*[/ch-12 /procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
- en: The `ProcCreateRemoteThread.Call()` ❶ function takes a total of seven arguments,
    although we’ll use only three of them in this example. The relevant arguments
    are `RemoteProcHandle` ❷ containing the victim process’s handle, `LoadLibAddr`
    ❸ containing the start routine to be called by the thread (in this case, `LoadLibraryA()`),
    and, lastly, the pointer ❹ to the virtually allocated memory holding the payload
    location.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcCreateRemoteThread.Call()` ❶ 函数总共有七个参数，尽管我们在这个示例中只使用了其中的三个。相关的参数是包含受害者进程句柄的
    `RemoteProcHandle` ❷，包含线程要调用的启动例程（在本例中是 `LoadLibraryA()`）的 `LoadLibAddr` ❸，以及最后，指向包含有效负载位置的虚拟分配内存的指针
    ❹。'
- en: Verifying Injection with the WaitforSingleObject Windows API
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 WaitforSingleObject Windows API 验证注入
- en: We’ll use the `WaitforSingleObject()` Windows function to identify when a particular
    object is in a signaled state. This is relevant to process injection because we
    want to wait for our thread to execute in order to avoid bailing out prematurely.
    Let’s briefly discuss the function definition in [Listing 12-12](ch12.xhtml#ch12list12).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `WaitforSingleObject()` Windows 函数来识别何时某个特定对象处于已信号状态。这与进程注入相关，因为我们希望等待线程执行完成，以避免过早退出。让我们简要讨论一下在[清单
    12-12](ch12.xhtml#ch12list12)中的函数定义。
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 12-12: Using the* WaitforSingleObject() *Windows function to ensure
    successful thread execution (*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-12：使用* WaitforSingleObject() *Windows 函数确保线程执行成功 (*[/ch-12/procInjector/winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
- en: Three notable events are occurring in this code block. First, the `ProcWaitForSingleObject.Call()`
    system call ❶ is passed the thread handle returned in [Listing 12-11](ch12.xhtml#ch12list11).
    A wait value of `INFINITE` is passed as the second argument to declare an infinite
    expiration time associated with the event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块中发生了三个值得注意的事件。首先，`ProcWaitForSingleObject.Call()` 系统调用 ❶ 被传入在[清单 12-11](ch12.xhtml#ch12list11)中返回的线程句柄。`INFINITE`
    的等待值作为第二个参数传入，声明事件的过期时间为无限。
- en: Next, `ProcGetExitCodeThread.Call()` ❷ determines whether the thread terminated
    successfully. If it did, the `LoadLibraryA` function should have been called,
    and our DLL will have been executed. Finally, as we do for the responsible cleanup
    of almost any handle, we passed the `ProcCloseHandle.Call()` system call ❸ so
    that that thread object handle closes cleanly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ProcGetExitCodeThread.Call()` ❷ 判断线程是否成功终止。如果成功，应该已经调用了 `LoadLibraryA`
    函数，并且我们的 DLL 已经执行。最后，正如我们几乎对任何句柄进行负责任的清理一样，我们调用了 `ProcCloseHandle.Call()` 系统调用
    ❸，确保线程对象句柄能够被干净地关闭。
- en: Cleaning Up with the VirtualFreeEx Windows API
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 VirtualFreeEx Windows API 进行清理
- en: We use the `VirtualFreeEx()` Windows function to release, or decommit, the virtual
    memory that we allocated in [Listing 12-8](ch12.xhtml#ch12list8) via `VirtualAllocEx()`.
    This is necessary to clean up memory responsibly, since initialized memory regions
    can be rather large, considering the overall size of the code being injected into
    the remote process, such as an entire DLL. Let’s take a look at this block of
    code ([Listing 12-13](ch12.xhtml#ch12list13)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `VirtualFreeEx()` Windows 函数释放或取消分配我们在[清单 12-8](ch12.xhtml#ch12list8)中通过
    `VirtualAllocEx()` 分配的虚拟内存。这对于负责任地清理内存是必要的，因为已初始化的内存区域可能相当大，考虑到注入到远程进程中的代码整体大小，如整个
    DLL。让我们看看这段代码块（[清单 12-13](ch12.xhtml#ch12list13)）。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 12-13: Freeing virtual memory by using the* VirtualFreeEx() *Windows
    function (*[/ch-12/procInjector /winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-13：使用* VirtualFreeEx() *Windows 函数释放虚拟内存 (*[/ch-12/procInjector /winsys/inject.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go)*)*'
- en: The `ProcVirtualFreeEx.Call()` function ❶ takes four arguments. The first is
    the remote process handle ❷ associated with the process that is to have its memory
    freed. The next argument is a pointer ❸ to the location of memory to be freed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcVirtualFreeEx.Call()` 函数 ❶ 有四个参数。第一个是与要释放内存的进程相关联的远程进程句柄 ❷。下一个参数是指向要释放的内存位置的指针
    ❸。'
- en: Notice that a variable named `size` ❹ is assigned a `0` value. This is necessary,
    as defined within the Windows API specification, to release the entire region
    of memory back into a reclaimable state. Finally, we pass the `MEM_RELEASE` operation
    ❺ to completely free the process memory (and our discussion on process injection).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个名为 `size` ❹ 的变量被赋值为 `0`。这是必要的，因为根据 Windows API 规范定义，这样做是为了将整个内存区域释放回可回收的状态。最后，我们传递
    `MEM_RELEASE` 操作 ❺ 来完全释放进程内存（以及我们关于进程注入的讨论）。
- en: Additional Exercises
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 附加练习
- en: 'Like many of the other chapters in this book, this chapter will provide the
    most value if you code and experiment along the way. Therefore, we conclude this
    section with a few challenges or possibilities to expand upon the ideas already
    covered:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像本书中的许多其他章节一样，本章如果你在过程中编写代码并进行实验，将提供最大的价值。因此，我们以几个挑战或扩展已涵盖内容的可能性结束这一部分：
- en: One of the most important aspects of creating code injection is maintaining
    a usable tool chain sufficient for inspecting and debugging process execution.
    Download and install both the Process Hacker and Process Monitor tools. Then,
    using Process Hacker, locate the memory addresses of both `Kernel32` and `LoadLibrary`.
    While you’re at it, locate the process handle and take a look at the integrity
    level, along with inherent privileges. Now inject your code into the same victim
    process and locate the thread.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码注入时最重要的方面之一是保持一个足够强大的工具链，以便检查和调试进程执行。下载并安装 Process Hacker 和 Process Monitor
    工具。然后，使用 Process Hacker 定位 `Kernel32` 和 `LoadLibrary` 的内存地址。同时，定位进程句柄并查看其完整性级别以及固有权限。现在，将你的代码注入到同一受害者进程中并定位线程。
- en: You can expand the process injection example to be less trivial. For example,
    instead of loading the payload from a disk file path, use MsfVenom or Cobalt Strike
    to generate shellcode and load it directly into process memory. This will require
    you to modify `VirtualAllocEx` and `LoadLibrary`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将进程注入示例扩展为更加复杂的形式。例如，不是从磁盘文件路径加载有效载荷，可以使用 MsfVenom 或 Cobalt Strike 生成 shellcode
    并将其直接加载到进程内存中。这将需要你修改 `VirtualAllocEx` 和 `LoadLibrary`。
- en: 'Create a DLL and load the entire contents into memory. This is similar to the
    previous exercise: the exception is that you’ll be loading an entire DLL rather
    than shellcode. Use Process Monitor to set a path filter, process filter, or both,
    and observe the system DLL load order. What prevents DLL load order hijacking?'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 DLL 并将其全部内容加载到内存中。这与前面的练习类似：不同之处在于，你将加载一个完整的 DLL，而不是 shellcode。使用 Process
    Monitor 设置路径过滤器、进程过滤器或两者，然后观察系统 DLL 加载顺序。是什么阻止了 DLL 加载顺序劫持？
- en: 'You can use a project called Frida (*[https://www.frida.re/](https://www.frida.re/)*)
    to inject the Google Chrome V8 JavaScript engine into the victim process. It has
    a strong following with mobile security practitioners as well as developers: you
    can use it to perform runtime analysis, in-process debugging, and instrumentation.
    You can also use Frida with other operating systems, such as Windows. Create your
    own Go code, inject Frida into a victim process, and use Frida to run JavaScript
    within the same process. Becoming familiar with the way Frida works will require
    some research, but we promise it’s well worth it.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个名为 Frida 的项目 (*[https://www.frida.re/](https://www.frida.re/)*)，将 Google
    Chrome V8 JavaScript 引擎注入受害者进程。它在移动安全从业者和开发人员中有着广泛的用户群体：你可以使用它进行运行时分析、进程内调试和插桩。你还可以在其他操作系统上使用
    Frida，例如 Windows。编写你自己的 Go 代码，将 Frida 注入到受害者进程中，并使用 Frida 在同一进程内运行 JavaScript。熟悉
    Frida 的工作方式需要一些研究，但我们保证这绝对值得。
- en: The Portable Executable File
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植可执行文件
- en: Sometimes we need a vehicle to deliver our malicious code. This could be a newly
    minted executable (delivered through an exploit in preexisting code), or a modified
    executable that already exists on the system, for example. If we wanted to modify
    an existing executable, we would need to understand the structure of the Windows
    *Portable Executable (PE)* file binary data format, as it dictates how to construct
    an executable, along with the executable’s capabilities. In this section, we’ll
    cover both the PE data structure and Go’s PE package, and build a PE binary parser,
    which you can use to navigate the structure of a PE binary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要一个载体来传递我们的恶意代码。这可以是一个新创建的可执行文件（通过现有代码中的漏洞进行传递），或者是系统上已经存在的修改版可执行文件。例如，如果我们想修改一个现有的可执行文件，我们需要理解Windows
    *便携式可执行文件（PE）*的二进制数据格式，因为它规定了如何构建可执行文件以及可执行文件的功能。在本节中，我们将介绍PE数据结构和Go的PE包，并构建一个PE二进制解析器，您可以使用它来浏览PE二进制文件的结构。
- en: Understanding the PE File Format
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解PE文件格式
- en: 'First, let’s discuss the PE data structure format. The Windows PE file format
    is a data structure most often represented as an executable, object code, or a
    DLL. The PE format also maintains references for all resources used during the
    initial operating system loading of the PE binary, including the export address
    table (EAT) used to maintain exported functions by ordinal, the export name table
    used to maintain exported functions by name, the import address table (IAT), import
    name table, thread local storage, and resource management, among other structures.
    You can find the PE format specification at [*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/).
    [Figure 12-6](ch12.xhtml#ch12fig6) shows the PE data structure: a visual representation
    of a Windows binary.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论PE数据结构格式。Windows PE文件格式是一种数据结构，通常表现为可执行文件、目标代码或DLL。PE格式还维护了所有在初始操作系统加载PE二进制文件时使用的资源的引用，包括用于按序号维护导出函数的导出地址表（EAT），用于按名称维护导出函数的导出名称表，导入地址表（IAT）、导入名称表、线程局部存储和资源管理等其他结构。你可以在[*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/)上找到PE格式规范。[图12-6](ch12.xhtml#ch12fig6)展示了PE数据结构：Windows二进制文件的可视化表示。
- en: '![Image](Images/12fig06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/12fig06.jpg)'
- en: '*Figure 12-6: The Windows PE file format*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：Windows PE文件格式*'
- en: We will examine each of these top-down sections as we build out the PE parser.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建PE解析器时，我们将逐一检查这些自上而下的各个部分。
- en: Writing a PE Parser
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写PE解析器
- en: Throughout the following sections, we will write the individual parser components
    necessary to analyze each PE section within the Windows binary executable. As
    an example, we’ll use the PE format associated with the Telegram messaging application
    binary located at [*https://telegram.org*](https://telegram.org), since this app
    is both less trivial than the often overused putty SSH binary example, and is
    distributed as a PE format. You can use almost any Windows binary executable,
    and we encourage you to investigate others.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的各个部分中，我们将编写分析Windows二进制可执行文件中每个PE部分所需的单独解析器组件。作为示例，我们将使用与Telegram消息应用程序二进制文件相关的PE格式，该二进制文件位于[*https://telegram.org*](https://telegram.org)，因为这个应用程序比经常被过度使用的Putty
    SSH二进制示例更不简单，而且它是以PE格式分发的。你几乎可以使用任何Windows二进制可执行文件，我们鼓励你去调查其他的二进制文件。
- en: Loading the PE binary and File I/O
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加载PE二进制文件和文件I/O
- en: In [Listing 12-14](ch12.xhtml#ch12list14), we’ll start by using the Go PE package
    to prepare the Telegram binary for further parsing. You can place all the code
    that we create when writing this parser in a single file within a `main()` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单12-14](ch12.xhtml#ch12list14)中，我们将首先使用Go的PE包准备Telegram二进制文件以供进一步解析。你可以将我们在编写此解析器时创建的所有代码放在一个文件中的`main()`函数内。
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 12-14: File I/O for PE binary (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-14：PE二进制文件的文件I/O（*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: Prior to reviewing each of the PE structure components, we need to stub out
    the initial import ❶ and file I/O by using the Go PE package. We use `os.Open()`
    ❷ and then `pe.NewFile()` ❸ to create a file handle and a PE file object, respectively.
    This is necessary because we intend to parse the PE file contents by using a `Reader`
    object, such as a file or binary reader.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查每个PE结构组件之前，我们需要通过使用Go的PE包来设置初始导入❶和文件I/O。我们使用`os.Open()`❷和`pe.NewFile()`❸分别创建文件句柄和PE文件对象。这是必要的，因为我们打算通过使用`Reader`对象（如文件或二进制读取器）来解析PE文件内容。
- en: Parsing the DOS Header and the DOS Stub
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析DOS头和DOS存根
- en: 'The first section of the top-down PE data structure illustrated in [Figure
    12-6](ch12.xhtml#ch12fig6) starts with a DOS header. The following unique value
    is always present within any Windows DOS-based executable binary: `0x4D 0x5A`
    (or `MZ` in ASCII), which aptly declares the file as a Windows executable. Another
    value universally present on all PE files is located at offset `0x3C`. The value
    at this offset points to another offset containing the signature of a PE file:
    aptly, `0x50 0x45 0x00 0x00` (or `PE` in ASCII).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层向下的PE数据结构的第一部分，如[图12-6](ch12.xhtml#ch12fig6)所示，从DOS头开始。以下的唯一值在任何基于Windows
    DOS的可执行二进制文件中总是存在：`0x4D 0x5A`（或ASCII中的`MZ`），它恰当地声明了该文件为Windows可执行文件。所有PE文件中普遍存在的另一个值位于偏移量`0x3C`。该偏移量的值指向另一个偏移量，包含PE文件的签名：恰当地是`0x50
    0x45 0x00 0x00`（或ASCII中的`PE`）。
- en: The header that immediately follows is the DOS Stub, which always provides the
    hex values for `This program cannot be run in DOS mode`; the exception to this
    occurs when a compiler’s `/STUB` linker option provides an arbitrary string value.
    If you take your favorite hex editor and open the Telegram application, it should
    be similar to [Figure 12-7](ch12.xhtml#ch12fig7). All of these values are present.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的头部是DOS存根，它总是提供`This program cannot be run in DOS mode`的十六进制值；这种情况的例外发生在编译器的`/STUB`链接器选项提供任意字符串值时。如果你使用你喜欢的十六进制编辑器打开Telegram应用程序，它应该类似于[图12-7](ch12.xhtml#ch12fig7)。所有这些值都是存在的。
- en: '![Image](Images/12fig07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/12fig07.jpg)'
- en: '*Figure 12-7: A typical PE binary format file header*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：典型的PE二进制格式文件头*'
- en: So far, we have described the DOS Header and Stub while also looking at the
    hexadecimal representation through a hex editor. Now, let’s take a look at parsing
    those same values with Go code, as provided in [Listing 12-15](ch12.xhtml#ch12list15).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了DOS头和存根，并通过十六进制编辑器查看了十六进制表示。现在，让我们通过[示例12-15](ch12.xhtml#ch12list15)中的Go代码来看一下如何解析这些相同的值。
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 12-15: Parsing the DOS Header and Stub values (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例12-15：解析DOS头和存根值 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: Starting from the beginning of the file, we use a Go `file` `Reader` ❶ instance
    to read 96 bytes onward in order to confirm the initial binary signature ❷. Recall
    that the first 2 bytes provide the ASCII value `MZ`. The PE package offers convenience
    objects to help marshal PE data structures into something more easily consumable.
    It will, however, still require manual binary readers and bitwise functionality
    to get it there. We perform a binary read of the offset value ❸ referenced at
    `0x3c`, and then read exactly 4 bytes ❹ composed of the value `0x50 0x45` (`PE`)
    followed by 2 `0x00` bytes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件的开始处，我们使用Go的`file` `Reader`❶实例向后读取96字节，以确认初始二进制签名❷。回想一下，前两个字节提供ASCII值`MZ`。PE包提供了方便的对象，帮助将PE数据结构转换为更易于使用的形式。然而，它仍然需要手动二进制读取器和按位功能来实现。我们执行了对偏移量值❸的二进制读取，该值在`0x3c`处引用，然后准确地读取了4个字节❹，由`0x50
    0x45`（`PE`）后跟2个`0x00`字节组成。
- en: Parsing the COFF File Header
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析COFF文件头
- en: Continuing down the PE file structure, and immediately following the DOS Stub,
    is the COFF File Header. Let’s parse the COFF File Header by using the code defined
    in [Listing 12-16](ch12.xhtml#ch12list16), and then discuss some of its more interesting
    properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 继续深入PE文件结构，紧接着DOS存根的是COFF文件头。让我们通过使用[示例12-16](ch12.xhtml#ch12list16)中定义的代码来解析COFF文件头，然后讨论其中一些更有趣的属性。
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-16: Parsing the COFF File Header (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例12-16：解析COFF文件头 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: We create a new `SectionReader` ❶ that starts from the beginning of the file
    at position 0 and reads to the max value of an `int64`. Then the `sr.Seek()` function
    ❷ resets the position to start reading immediately, following the PE signature
    offset and value (recall the literal values `PE + 0x00 + 0x00`). Finally, we perform
    a binary read ❸ to marshal the bytes into the `pefile` object’s `FileHeader` struct.
    Recall that we created `pefile` earlier when we called `pe.Newfile()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`SectionReader` ❶，它从文件的开头（位置0）开始，读取到`int64`的最大值。然后，`sr.Seek()`函数 ❷将位置重置，以便立即开始读取，紧接着PE签名的偏移量和值（回想一下字面值`PE
    + 0x00 + 0x00`）。最后，我们执行二进制读取 ❸，将字节转储到`pefile`对象的`FileHeader`结构体中。回想一下，我们之前在调用`pe.Newfile()`时已经创建了`pefile`。
- en: The Go documentation defines `type FileHeader` with the struct defined in [Listing
    12-17](ch12.xhtml#ch12list17). This struct aligns quite well with Microsoft’s
    documented PE COFF File Header format (defined at [*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Go文档中定义了`type FileHeader`，该结构体在[Listing 12-17](ch12.xhtml#ch12list17)中有定义。这个结构体与微软文档中描述的PE
    COFF文件头格式非常匹配（定义于[*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/)）。
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 12-17: The Go PE package’s native PE File Header struct*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-17: Go PE包的本地PE文件头结构*'
- en: The single item to note in this struct outside of the `Machine` value (in other
    words, the PE target system architecture), is the `NumberOfSections` property.
    This property contains the number of sections defined within the Section Table,
    which immediately follows the headers. You’ll need to update the `NumberOfSections`
    value if you intend to backdoor a PE file by adding a new section. However, other
    strategies may not require updating this value, such as searching other executable
    sections (such as `CODE`, `.text`, and so on) for contiguous unused `0x00` or
    `0xCC` values (a method to locate sections of memory that you can use to implant
    shellcode), as the number of sections remain unchanged.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构体中，除了`Machine`值（换句话说，就是PE目标系统架构）外，唯一需要注意的项是`NumberOfSections`属性。这个属性包含了在Section
    Table中定义的sections的数量，Section Table紧跟在文件头之后。如果你打算通过添加新section来给PE文件植入后门，你需要更新`NumberOfSections`的值。然而，其他一些策略可能不需要更新这个值，例如，搜索其他可执行的sections（如`CODE`、`.text`等），以寻找连续的未使用`0x00`或`0xCC`值（这种方法用于定位可以植入shellcode的内存区域），因为sections的数量不会改变。
- en: In closing, you can use the following print statements to output some of the
    more interesting COFF File Header values ([Listing 12-18](ch12.xhtml#ch12list18)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用以下打印语句输出一些更有趣的COFF文件头值（[Listing 12-18](ch12.xhtml#ch12list18)）。
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12-18: Writing COFF File Header values to terminal output (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-18: 将COFF文件头值写入终端输出 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: You can locate the `NumberOfSections` value by calculating the offset of the
    PE signature + 4 bytes + 2 bytes—in other words, by adding 6 bytes. In our code,
    we already defined `pe_sig_offset,` so we’d just add 6 bytes to that value ❶.
    We’ll discuss sections in more detail when we examine the Section Table structure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算PE签名的偏移量 + 4字节 + 2字节来定位`NumberOfSections`的值——换句话说，就是加上6字节。在我们的代码中，我们已经定义了`pe_sig_offset`，所以我们只需要在这个值上加上6字节
    ❶。我们将在检查Section Table结构时更详细地讨论sections。
- en: 'The produced output describes the `Machine Architecture` ❷ value of `0x14c`:
    an `IMAGE_FILE_MACHINE_I386` as detailed in [*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types).
    The number of sections ❸ is `0x8`, dictating that eight entries exist within the
    Section Table. The Optional Header (which will be discussed next) has a variable
    length depending on architecture: the value is `0xe0` (224 in decimal), which
    corresponds to a 32-bit system ❹. The last two sections can be considered more
    of convenience output. Specifically, the `Sections Field Offset` ❺ provides the
    offset to the number of sections, while the `Section Table Offset` ❻ provides
    the offset for the location of the Section Table. Both offset values would require
    modification if adding shellcode, for example.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出描述了`Machine Architecture` ❷值为`0x14c`：一个`IMAGE_FILE_MACHINE_I386`，如[*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types)中详细说明的那样。节的数量❸是`0x8`，意味着在节表中有八个条目。可选头（接下来会讨论）具有可变长度，取决于体系结构：该值为`0xe0`（十进制为224），对应32位系统❹。最后两个节可以视为更方便的输出。具体来说，`Sections
    Field Offset` ❺提供了节的数量的偏移量，而`Section Table Offset` ❻则提供了节表位置的偏移量。如果添加shellcode，这两个偏移量值需要进行修改。
- en: Parsing the Optional Header
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析可选头
- en: The next header in the PE file structure is the *Optional Header*. An executable
    binary image will have an Optional Header that provides important data to the
    loader, which loads the executable into virtual memory. A lot of data is contained
    within this header, so we’ll cover only a few items in order to get you used to
    navigating this structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: PE文件结构中的下一个头是*可选头*。一个可执行的二进制镜像将具有一个可选头，为加载器提供重要数据，加载器将可执行文件加载到虚拟内存中。这个头部包含了大量数据，因此我们只会介绍其中几个项目，以帮助你熟悉如何浏览这个结构。
- en: To get started, we need to perform a binary read of the relevant byte length
    based on architecture, as described in [Listing 12-19](ch12.xhtml#ch12list19).
    If you were writing more comprehensive code, you’d want to check architectures
    (for example, `x86` versus `x86_64`) throughout in order to use the appropriate
    PE data structures.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要根据架构执行相关字节长度的二进制读取，如[示例 12-19](ch12.xhtml#ch12list19)中所述。如果你正在编写更为全面的代码，你会希望检查整个过程中使用的架构（例如，`x86`与`x86_64`），以便使用适当的PE数据结构。
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 12-19: Reading the Optional Header bytes (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-19：读取可选头字节 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: 'In this code block, we’re initializing two variables, `sizeOfOptionalHeader32`
    ❶ and `sizeOfOptionalHeader64` ❷, with 224 bytes and 240 bytes, respectively.
    This is an `x86` binary, so we’ll use the former variable in our code. Immediately
    following the variable declarations are initializations of `pe.OptionalHeader32`
    ❸ and `pe.OptionalHeader64` ❹ interfaces, which will contain the `OptionalHeader`
    data. Finally, we perform the binary read ❺ and marshal it to the relevant data
    structure: the `oh32` based on a 32-bit binary.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们初始化了两个变量，`sizeOfOptionalHeader32` ❶和`sizeOfOptionalHeader64` ❷，分别为224字节和240字节。这是一个`x86`二进制文件，因此我们将在代码中使用前者变量。紧接着变量声明的是`pe.OptionalHeader32`
    ❸和`pe.OptionalHeader64` ❹接口的初始化，它们将包含`OptionalHeader`数据。最后，我们执行二进制读取❺，并将其转换为相关的数据结构：基于32位二进制的`oh32`。
- en: Let’s describe some of the more notable items of the Optional Header. The corresponding
    print statements and subsequent output are provided in [Listing 12-20](ch12.xhtml#ch12list20).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一些可选头中更值得注意的项目。相关的打印语句和后续输出可以在[示例 12-20](ch12.xhtml#ch12list20)中找到。
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 12-20: Writing Optional Header values to terminal output (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-20：将可选头值写入终端输出 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: Assuming that the objective is to backdoor a PE file, you’ll need to know both
    the `ImageBase` ❷ and `Entry Point` ❶ in order to hijack and memory jump to the
    location of the shellcode or to a new section defined by the number of `Section
    Table` entries. The `ImageBase` is the address of the first byte of the image
    once it is loaded into memory, whereas the `Entry Point` is the address of the
    executable code relative to the `ImageBase`. The `Size of Image` ❸ is the actual
    size of the image, in its entirety, when loaded into memory. This value will need
    to be adjusted to accommodate any increase in image size, which could happen if
    you added a new section containing shellcode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设目标是通过后门进入PE文件，你需要知道`ImageBase` ❷和`Entry Point` ❶才能劫持并跳转到shellcode的位置，或者跳转到由`Section
    Table`条目数量定义的新部分。`ImageBase`是加载到内存中后图像的第一个字节的地址，而`Entry Point`是相对于`ImageBase`的可执行代码地址。`Size
    of Image` ❸是图像加载到内存时的实际大小。该值需要调整以适应任何图像大小的增加，如果你添加了一个包含shellcode的新部分，可能会发生这种情况。
- en: 'The `Sections Alignment` ❹ will provide the byte alignment when sections are
    loaded into memory: `0x1000` is a rather standard value. The `File Alignment`
    ❺ provides the byte alignment of the sections on raw disk: `0x200 (512K)` is also
    a common value. You’ll need to modify these values in order to get working code,
    and you’ll have to use a hex editor and a debugger if you’re planning to perform
    all this manually.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sections Alignment` ❹将在部分加载到内存时提供字节对齐：`0x1000`是一个相当标准的值。`File Alignment` ❺提供原始磁盘上部分的字节对齐：`0x200
    (512K)`也是一个常见的值。如果你打算手动执行这些操作，你需要修改这些值，并且必须使用十六进制编辑器和调试器。'
- en: The Optional Header contains numerous entries. Instead of describing every single
    one of them, we recommend that you explore the documentation at [*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only)
    to gain a comprehensive understanding of each entry.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可选头部包含多个条目。我们建议你查看文档[*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only)，以全面了解每个条目。
- en: Parsing the Data Directory
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析数据目录
- en: At runtime, the Windows executable must know important information, such as
    how to consume a linked DLL or how to allow other application processes to consume
    resources that the executable has to offer. The binary also needs to manage granular
    data, such as thread storage. This is the primary function of the Data Directory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Windows可执行文件必须知道重要信息，例如如何使用链接的DLL，或者如何允许其他应用程序进程使用可执行文件所提供的资源。该二进制文件还需要管理细粒度的数据，例如线程存储。这是数据目录的主要功能。
- en: The *Data Directory* is the last 128 bytes of the Optional Header and pertains
    specifically to a binary image. We use it to maintain a table of references containing
    both an individual directory’s offset address to the data location and the size
    of the data. Exactly 16 directory entries are defined within the *WINNT.H* header,
    which is a core Windows header file that defines various data types and constants
    to be used throughout the Windows operating system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据目录*是可选头部的最后128字节，专门涉及二进制镜像。我们使用它来维护一个包含每个目录的偏移地址和数据大小的引用表。在*WINNT.H*头文件中定义了恰好16个目录条目，这是一个核心的Windows头文件，用于定义各种数据类型和常量，供整个Windows操作系统使用。'
- en: Note that not all of the directories are in use, as some are reserved or unimplemented
    by Microsoft. The entire list of data directories and details of their intended
    use can be referenced at [*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only).
    Again, a lot of information is associated with each individual directory, so we
    recommend you take some time to really research and get familiar with their structures.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有目录都在使用中，因为有些是微软保留的或未实现的。有关数据目录的完整列表及其预定用途的详细信息，可以参考[*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only*](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only)。再次提醒，许多信息与每个单独的目录相关，因此我们建议你花时间真正研究并熟悉它们的结构。
- en: Let’s explore a couple of directory entries within the Data Directory by using
    the code in [Listing 12-21](ch12.xhtml#ch12list21).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 12-21: Parsing the Data Directory for address offset and size (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The Data Directory list ❶ is statically defined by Microsoft, meaning that the
    literal individual directory names will remain in a consistently ordered list.
    As such, they are considered to be constants. We will use a slice variable, `winnt_datadirs`,
    to store the individual directory entries so we can reconcile names to index positions.
    Specifically, the Go PE package implements the Data Directory as a struct object,
    so we’re required to iterate over each entry to extract the individual directory
    entries, along with their respective address offset and size attributes. The `for`
    loop is 0-index based, so we just output each slice entry relative to its index
    position ❷.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The directory entries being displayed to standard output are the `IMAGE``_DIRECTORY_ENTRY_EXPORT`
    ❸, or the EAT, and the `IMAGE_DIRECTORY_ENTRY_IMPORT` ❻, or the IAT. Each of these
    directories maintains a table of exported and imported functions, respectively,
    relative to the running Windows executable. Looking further at `IMAGE_DIRECTORY_ENTRY_EXPORT`,
    you will see the virtual address ❹ containing the offset of the actual table data,
    along with the size ❺ of the data contained within.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the Section Table
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *Section Table*, the last PE byte structure, immediately follows the Optional
    Header. It contains the details of each relevant section in the Windows executable
    binary, such as executable code and initialized data location offsets. The number
    of entries matches the `NumberOfSections` defined within the COFF File Header.
    You can locate the Section Table at the PE signature offset + `0xF8`. Let’s take
    a look at this section within a hex editor ([Figure 12-8](ch12.xhtml#ch12fig8)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/12fig08.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: The Section Table, as observed using a hex editor*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: This particular Section Table starts with `.text`, but it might start with a
    `CODE` section, depending on the binary’s compiler. The `.text` (or `CODE`) section
    contains the executable code, whereas the next section, `.rodata`, contains read-only
    constant data. The `.rdata` section contains resource data, and the `.data` section
    contains initialized data. Each section is at least 40 bytes in length.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: You can access the Section Table within the COFF File Header. You can also access
    each section individually, using the code in [Listing 12-22](ch12.xhtml#ch12list22).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 12-22: Parsing a specific section from the Section Table (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The other option is to iterate over the entire Section Table, as shown in [Listing
    12-23](ch12.xhtml#ch12list23).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 12-23: Parsing all sections from a Section Table (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-23：从节表中解析所有节 (*[/ch-12/peParser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go)*)*'
- en: Here, we’re iterating over all the sections within the Section Table ❶ and writing
    the `name` ❷, `virtual size` ❹, `virtual address` ❺, `raw size` ❻, and `raw offset`
    ❼ to standard output. Also, we calculate the next 40-byte offset address ❽ in
    the event that we’d want to append a new section. The `characteristics` value
    ❸ describes how the section is to behave as part of the binary. For example, the
    `.text` section provides a value of 0x60000020\. Referencing the relevant `Section
    Flags` data at *[https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags)*
    ([Table 12-2](ch12.xhtml#ch12tab2)), we can see that three separate attributes
    make up the value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历节表 ❶ 中的所有节，并将 `name` ❷、`virtual size` ❹、`virtual address` ❺、`raw size`
    ❻ 和 `raw offset` ❼ 写入标准输出。此外，我们还计算下一个 40 字节的偏移地址 ❽，以防我们想要附加一个新的节。`characteristics`
    值 ❸ 描述了该节作为二进制文件的一部分的行为方式。例如，`.text` 节提供了值 0x60000020。参考 *[https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags)*
    ([表 12-2](ch12.xhtml#ch12tab2)) 中的相关 `Section Flags` 数据，我们可以看到由三个独立的属性构成该值。
- en: '**Table 12-2:** Characteristics of Section Flags'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-2：** 节标志的特性'
- en: '| **Flag** | **Value** | **Description** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **值** | **描述** |'
- en: '| `IMAGE_SCN_CNT_CODE` | 0x00000020 | The section contains executable code.
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `IMAGE_SCN_CNT_CODE` | 0x00000020 | 该节包含可执行代码。 |'
- en: '| `IMAGE_SCN_MEM_EXECUTE` | 0x20000000 | The section can be executed as code.
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `IMAGE_SCN_MEM_EXECUTE` | 0x20000000 | 该节可以作为代码执行。 |'
- en: '| `IMAGE_SCN_MEM_READ` | 0x40000000 | The section can be read. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `IMAGE_SCN_MEM_READ` | 0x40000000 | 该节可以被读取。 |'
- en: The first value, 0x00000020 (`IMAGE_SCN_CNT_CODE`), states that the section
    contains executable code. The second value, 0x20000000 (`IMAGE_SCN_MEM_EXECUTE`),
    states that the section can be executed as code. Lastly, the third value, 0x40000000
    (`IMAGE_SCN_MEM_READ`), allows the section to be read. Therefore, adding all these
    together provides the value 0x60000020\. If you’re adding a new section, keep
    in mind that you’ll need to update all these properties with their appropriate
    values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值 0x00000020 (`IMAGE_SCN_CNT_CODE`) 表示该节包含可执行代码。第二个值 0x20000000 (`IMAGE_SCN_MEM_EXECUTE`)
    表示该节可以作为代码执行。最后，第三个值 0x40000000 (`IMAGE_SCN_MEM_READ`) 允许该节被读取。因此，将这些值加在一起得到 0x60000020。如果你要添加一个新的节，记住你需要更新所有这些属性及其相应的值。
- en: This wraps up our discussion of the PE file data structure. It was a brief overview,
    we know. Each section could be its own chapter. However, it should be enough to
    allow you to use Go as a means to navigate arbitrary data structures. The PE data
    structure is quite involved and it’s well worth the time and effort necessary
    to become familiar with all of its components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 PE 文件数据结构的讨论。虽然这只是一个简短的概述，每个节本身都可以成为一章。然而，它应该足以让你利用 Go 作为导航任意数据结构的工具。PE
    数据结构非常复杂，值得花时间和精力熟悉其所有组成部分。
- en: Additional Exercises
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外练习
- en: 'Take the knowledge you just learned about the PE file data structure and expand
    upon it. Here are some additional ideas that will help reinforce your understanding,
    while also providing a chance to explore more of the Go PE package:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 利用你刚刚学到的 PE 文件数据结构的知识，并在此基础上进行扩展。这里有一些额外的想法，可以帮助你加深理解，同时也为你提供了一个探索更多 Go PE 包的机会：
- en: Obtain various Windows binaries and use a hex editor and a debugger to explore
    the various offset values. Identify how various binaries are different, such as
    their number of sections. Use the parser that you built in this chapter to both
    explore and verify your manual observations.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取各种 Windows 二进制文件，并使用十六进制编辑器和调试器来探索不同的偏移值。识别不同二进制文件之间的差异，例如它们的节数。使用你在本章中构建的解析器来探索和验证你手动观察到的内容。
- en: Explore new areas of the PE file structure, such as the EAT and IAT. Now, rebuild
    the parser to support DLL navigation.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 PE 文件结构的新领域，如 EAT 和 IAT。现在，重新构建解析器以支持 DLL 导航。
- en: Add a new section to an existing PE file to include your shiny new shellcode.
    Update the entire section to include the appropriate number of sections, entry
    point, and raw and virtual values. Do this all over again, but this time, instead
    of adding a new section, use an existing section and create a code cave.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One topic that we didn’t discuss was how to handle PE files that have been code
    packed, either with common packers, such as UPX, or more obscure packers. Find
    a binary that has been packed, identify how it was packed and what packer was
    used, and then research the appropriate technique to unpack the code.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C with Go
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another method of accessing the Windows API is to leverage C. By directly using
    C, you could take advantage of an existing library that is available only in C,
    create a DLL (which we can’t do using Go alone), or simply call the Windows API.
    In this section, we’ll first install and configure a C toolchain that is compatible
    with Go. We will then look at examples of how to use C code in Go programs and
    how to include Go code in C programs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Installing a C Windows Toolchain
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To compile programs that contain a combination of Go and C, you’ll need a suitable
    C toolchain that can be used to build portions of C code. On Linux and macOS,
    you can install the GNU Compiler Collection (GCC) by using a package manager.
    On Windows, installing and configuring a toolchain is a bit more involved and
    can lead to frustration if you’re not familiar with the many options available.
    The best option we found is to use MSYS2, which packages MinGW-w64, a project
    created to support the GCC toolchain on Windows. Download and install this from
    [*https://www.msys2.org*/](https://www.msys2.org/) and follow the instructions
    on that page to install your C toolchain. Also, remember to add the compiler to
    your `PATH` variable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Message Box Using C and the Windows API
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have a C toolchain configured and installed, let’s look at a simple
    Go program that leverages embedded C code. [Listing 12-24](ch12.xhtml#ch12list24)
    contains C that uses the Windows API to create a message box, which gives us a
    visual display of the Windows API in use.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 12-24: Go using C (*[/ch-12/messagebox/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/messagebox/main.go)*)*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: C code can be provided through external file `include` statements ❶. It can
    also be embedded directly in a Go file. Here we are using both methods. To embed
    C code into a Go file, we use a comment, inside of which we define a function
    that will create a `MessageBox` ❷. Go supports comments for many compile-time
    options, including compiling C code. Immediately after the closing comment tag,
    we use `import "C"` to tell the Go compiler to use CGO, a package that allows
    the Go compiler to link native C code at build time ❸. Within the Go code, we
    can now call functions defined in C, and we call the `C.box()` function, which
    executes the function defined in the body of our C code ❹.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Build the sample code by using `go build`. When executed, you should get a message
    box.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*Though the CGO package is extremely convenient, allowing you to call C libraries
    from Go code as well as call Go libraries from C code, using it gets rid of Go’s
    memory manager and garbage disposal. If you want to reap the benefits of Go’s
    memory manager, you should allocate memory within Go and then pass it to C. Otherwise,
    Go’s memory manager won’t know about allocations you’ve made using the C memory
    manager, and those allocations won’t be freed unless you call C’s native free()
    method. Not freeing the memory correctly can have adverse effects on your Go code.
    Finally, just like opening file handles in Go, use defer within your Go function
    to ensure that any C memory that Go references is garbage collected.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Building Go into C
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as we can embed C code into Go programs, we can embed Go code into C programs.
    This is useful because, as of this writing, the Go compiler can’t build our programs
    into DLLs. That means we can’t build utilities such as reflective DLL injection
    payloads (like the one we created earlier in this chapter) with Go alone.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: However, we can build our Go code into a C archive file, and then use C to build
    the archive file into a DLL. In this section, we’ll build a DLL by converting
    our Go code into a C archive file. Then we’ll convert that DLL into shellcode
    by using existing tools, so we can inject and execute it in memory. Let’s start
    with the Go code ([Listing 12-25](ch12.xhtml#ch12list25)), saved in a file called
    *main.go*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-25: The Go payload (*[/ch-12/dllshellcode/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-12/dllshellcode/main.go)*)*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We import C to include CGO into our build ❶. Next, we use a comment to tell
    Go that we want to export a function in our C archive ❷. Finally, we define the
    function we want to convert into C ❸. The `main()` function ❹ can remain empty.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the C archive, execute the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We should now have two files, an archive file called *dllshellcode.a* and an
    associated header file called *dllshellcode.h*. We can’t use these quite yet.
    We have to build a shim in C and force the compiler to include *dllshellcode.a*.
    One elegant solution is to use a function table. Create a file that contains the
    code in [Listing 12-26](ch12.xhtml#ch12list26). Call this file *scratch.c*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 12-26: A function table saved in the* scratch.c *file (*[/ch-12/dllshellcode/scratch.c](https://github.com/blackhat-go/bhg/blob/master/ch-12/dllshellcode/scratch.c)*)*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use GCC to build the *scratch.c* C file into a DLL by using the
    following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To convert our DLL into shellcode, we’ll use sRDI ([*https://github.com/monoxgas/sRDI/*](https://github.com/monoxgas/sRDI/)),
    an excellent utility that has a ton of functionality. To begin, download the repo
    by using Git on Windows and, optionally, a GNU/Linux machine, as you may find
    GNU/Linux to be a more readily available Python 3 environment. You’ll need Python
    3 for this exercise, so install it if it’s not already installed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'From the *sRDI* directory, execute a `python3` shell. Use the following code
    to generate a hash of the exported function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The sRDI tools will use the hash to identify a function from the shellcode we’ll
    generate later.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll leverage PowerShell utilities to generate and execute shellcode.
    For convenience, we will use some utilities from PowerSploit ([*https://github.com/PowerShellMafia/PowerSploit*](https://github.com/PowerShellMafia/PowerSploit)*/)*,
    which is a suite of PowerShell utilities we can leverage to inject shellcode.
    You can download this using Git. From the *PowerSploit\CodeExecution* directory,
    launch a new PowerShell shell:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now import two PowerShell modules from PowerSploit and sRDI:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With both modules imported, we can use `ConvertTo-Shellcode` from sRDI to generate
    shellcode from the DLL, and then pass this into `Invoke-Shellcode` from PowerSploit
    to demonstrate the injection. Once this executes, you should observe your Go code
    executing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The message `YO FROM Go` indicates that we have successfully launched our Go
    payload from within a C binary that was converted into shellcode. This unlocks
    a whole host of possibilities.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That was quite a lot to discuss, and yet it just scratches the surface. We
    started the chapter with a brief discussion about navigating the Windows API documentation
    so you’d be familiar with reconciling Windows objects to usable Go objects: these
    include functions, parameters, data types, and return values. Next, we discussed
    the use of `uintptr` and `unsafe.Pointer` to perform disparate type conversions
    necessary when interacting with the Go `syscall` package, along with the potential
    pitfalls to avoid. We then tied everything together with a demonstration of process
    injection, which used various Go system calls to interact with Windows process
    internals.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: From there, we discussed the PE file format structure, and then built a parser
    to navigate the different file structures. We demonstrated various Go objects
    that make navigating the binary PE file a bit more convenient and finished up
    with notable offsets that may be interesting when backdooring a PE file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you built a toolchain to interoperate with Go and native C code. We
    briefly discussed the CGO package while focusing on creating C code examples and
    exploring novel tools for creating native Go DLLs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Take this chapter and expand on what you’ve learned. We urge you to continuously
    build, break, and research the many attack disciplines. The Windows attack surface
    is constantly evolving, and having the right knowledge and tooling will only help
    to make the adversarial journey more attainable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
