<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Rubinius: Ruby Implemented with Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="rubinius_ruby_implemented_with_ruby"/>Chapter 11. Rubinius: Ruby Implemented with Ruby</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00252"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Rubinius uses Ruby to implement Ruby.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1929"/>Like JRuby, Rubinius is an alternative implementation of Ruby. Much of Rubinius’s internal source code is written in Ruby itself instead of in only C or Java. Rubinius implements built-in classes, such as <code class="literal">Array</code>, <code class="literal">String</code>, and <code class="literal">Integer</code>, just as you would—with Ruby code!</p><p>This design offers a unique opportunity for you to learn about Ruby internals. If you aren’t sure how a particular Ruby feature or method works, you can read the Ruby code inside Rubinius to find out, without special knowledge of C or Java programming.</p><p><a class="indexterm" id="iddle1875"/><a class="indexterm" id="iddle1936"/>Rubinius also includes a sophisticated virtual machine written in C++. This machine executes your Ruby program and, like JRuby, supports JIT and true concurrency and uses a sophisticated garbage collection algorithm.</p><p>This chapter starts with a high-level overview of Rubinius and an example of how to use backtrace output to dig through the Rubinius source code. Later in the chapter, we’ll learn how Rubinius and MRI implement the <code class="literal">Array</code> class, including how Ruby saves data into an array and what happens when you remove an element from an array.</p><div class="sidebar"><a id="roadmap-id00042"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch11.html#rubinius_kernel_and_virtual_machine" title="The Rubinius Kernel and Virtual Machine">The Rubinius Kernel and Virtual Machine</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch11.html#tokenization_and_parsing-id00043" title="Tokenization and Parsing">Tokenization and Parsing</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#using_ruby_to_compile_ruby" title="Using Ruby to Compile Ruby">Using Ruby to Compile Ruby</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#rubinius_bytecode_instructions" title="Rubinius Bytecode Instructions">Rubinius Bytecode Instructions</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#ruby_and_cplusplus_working_together" title="Ruby and C++ Working Together">Ruby and C++ Working Together</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#implementing_ruby_objects_with_cplusplus" title="Implementing Ruby Objects with C++ Objects">Implementing Ruby Objects with C++ Objects</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch11.html#experiment_11-1_comparing_backtraces_in" title="Experiment 11-1: Comparing Backtraces in MRI and Rubinius">Experiment 11-1: Comparing Backtraces in MRI and Rubinius</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch11.html#backtraces_in_rubinius" title="Backtraces in Rubinius">Backtraces in Rubinius</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch11.html#arrays_in_rubinius_and_mri" title="Arrays in Rubinius and MRI">Arrays in Rubinius and MRI</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch11.html#arrays_inside_of_mri" title="Arrays Inside of MRI">Arrays Inside of MRI</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#rarray_c_structure_definition" title="The RArray C Structure Definition">The RArray C Structure Definition</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#arrays_inside_of_rubinius" title="Arrays Inside of Rubinius">Arrays Inside of Rubinius</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch11.html#experiment_11-2_exploring_the_rubinius_i" title="Experiment 11-2: Exploring the Rubinius Implementation of Array#shift">Experiment 11-2: Exploring the Rubinius Implementation of Array#shift</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch11.html#reading_arrayhashshift" title="Reading Array#shift">Reading Array#shift</a></p></li><li class="listitem"><p><a class="xref" href="ch11.html#modifying_arrayhashshift" title="Modifying Array#shift">Modifying Array#shift</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch11.html#summary-id00044" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="The Rubinius Kernel and Virtual Machine"><div class="titlepage"><div><div><h1 class="title"><a id="rubinius_kernel_and_virtual_machine"/>The Rubinius Kernel and Virtual Machine</h1></div></div></div><p>To run a Ruby program using Rubinius (see <a class="xref" href="ch11.html#rubinius_consists_of_a_cplusplus_virtual" title="Figure 11-1. Rubinius consists of a C++ virtual machine and a Ruby kernel.">Figure 11-1</a>), you typically use the <code class="literal">ruby</code> command (as with MRI) or <code class="literal">rbx</code> because the <code class="literal">ruby</code> command is actually a symbolic link to the executable <span class="emphasis"><em>rbx</em></span> in Rubinius.</p><div class="figure"><a id="rubinius_consists_of_a_cplusplus_virtual"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00253"/><img alt="Rubinius consists of a C++ virtual machine and a Ruby kernel." src="httpatomoreillycomsourcenostarchimages1854317.png.jpg"/></div></div><p class="title">Figure 11-1. Rubinius consists of a C++ virtual machine and a Ruby kernel.</p></div><p>As with MRI, you launch Rubinius using an executable that reads and executes the Ruby program specified on the command line. But the Rubinius executable is completely different from the standard Ruby executable. As the preceding figure shows, Rubinius consists of two major pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="The Rubinius kernel"><span class="title"><strong><span class="strong"><strong>The Rubinius kernel</strong></span></strong></span>. This is the part of Rubinius written in Ruby. It implements a lot of the language, including the definitions of many built-in, core classes, such as <code class="literal">String</code> and <code class="literal">Array</code>. The Rubinius kernel is compiled into bytecode instructions that are installed onto your computer.</p></li><li class="listitem"><p title="The Rubinius virtual machine"><span class="title"><strong><span class="strong"><strong>The Rubinius virtual machine</strong></span></strong></span>. The Rubinius virtual machine is written in C++. It executes the bytecode instructions from the Rubinius kernel and performs a range of other low-level tasks, such as garbage collection. The Rubinius executable contains a compiled, machine-language version of this virtual machine.</p></li></ul></div><p><a class="xref" href="ch11.html#closer_view_of_rubinius_internals" title="Figure 11-2. A closer view of Rubinius internals">Figure 11-2</a> takes a closer look at Rubinius’s virtual machine and kernel. The Rubinius kernel contains a set of Ruby classes, such as <code class="literal">String</code>, <code class="literal">Array</code>, and <code class="literal">Object</code>, as well as other Ruby classes that perform various tasks, such as compiling or loading code. The Rubinius virtual machine at the left of the figure is the <span class="emphasis"><em>rbx</em></span> executable that you launch from the command line. The C++ virtual machine contains code to perform garbage collection, just-in-time compilation (and many other tasks), as well as additional code for built-in classes, such as <code class="literal">String</code> or <code class="literal">Array</code>. In fact, as indicated by the arrows, each Ruby class built into Rubinius consists of both C++ and Ruby code working together. Rubinius defines certain methods using Ruby and other methods using C++.</p><div class="figure"><a id="closer_view_of_rubinius_internals"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00254"/><img alt="A closer view of Rubinius internals" src="httpatomoreillycomsourcenostarchimages1854319.png"/></div></div><p class="title">Figure 11-2. A closer view of Rubinius internals</p></div><p>Why implement Ruby using two languages? Because C++ speeds up Rubinius programs and allows them to interact with the operating system directly at a low level. The use of C++ instead of C also allows Rubinius to use an elegant object-oriented design internally. And the use of Ruby to implement built-in classes and other features makes it easy for Ruby developers to read and understand much of the Rubinius source code.</p><div class="sect2" title="Tokenization and Parsing"><div class="titlepage"><div><div><h2 class="title"><a id="tokenization_and_parsing-id00043"/>Tokenization and Parsing</h2></div></div></div><p>Rubinius processes your Ruby program in much the same way that MRI does, as shown in <a class="xref" href="ch11.html#how_rubinius_processes_your_code" title="Figure 11-3. How Rubinius processes your code">Figure 11-3</a>.</p><div class="figure"><a id="how_rubinius_processes_your_code"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00255"/><img alt="How Rubinius processes your code" src="httpatomoreillycomsourcenostarchimages1854321.png.jpg"/></div></div><p class="title">Figure 11-3. How Rubinius processes your code</p></div><p><a class="indexterm" id="iddle1094"/><a class="indexterm" id="iddle1183"/><a class="indexterm" id="iddle1550"/><a class="indexterm" id="iddle1561"/><a class="indexterm" id="iddle1931"/><a class="indexterm" id="iddle1933"/>Rubinius generates an LALR parser using Bison during its build process, just as MRI does. When you run your program, the parser converts your code into a token stream, an abstract syntax tree (AST) structure, and then a series of high-level virtual machine instructions called <span class="emphasis"><em>Rubinius instructions</em></span>. <a class="xref" href="ch11.html#how_mri_and_rubinius_transform_your_code" title="Figure 11-4. How MRI and Rubinius transform your code internally">Figure 11-4</a> compares the forms that your code takes inside MRI and Rubinius.</p><p>At first, Rubinius and MRI work similarly, but instead of interpreting your code as MRI does, Rubinius uses a compiler framework called the Low-Level Virtual Machine (LLVM) to compile your code again into lower-level instructions. LLVM, in turn, may compile these instructions all the way to machine language, using a JIT compiler.</p><div class="figure"><a id="how_mri_and_rubinius_transform_your_code"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00256"/><img alt="How MRI and Rubinius transform your code internally" src="httpatomoreillycomsourcenostarchimages1854323.png.jpg"/></div></div><p class="title">Figure 11-4. How MRI and Rubinius transform your code internally</p></div></div><div class="sect2" title="Using Ruby to Compile Ruby"><div class="titlepage"><div><div><h2 class="title"><a id="using_ruby_to_compile_ruby"/>Using Ruby to Compile Ruby</h2></div></div></div><p>One of the most fascinating aspects of Rubinius is how it implements a Ruby compiler with a combination of Ruby and C++. When you run a program using Rubinius, your code is processed by both C++ and Ruby code, as shown in <a class="xref" href="ch11.html#high-level_overview_of_how_rubinius_co" title="Figure 11-5. A high-level overview of how Rubinius compiles your code">Figure 11-5</a>.</p><div class="figure"><a id="high-level_overview_of_how_rubinius_co"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00257"/><img alt="A high-level overview of how Rubinius compiles your code" src="httpatomoreillycomsourcenostarchimages1854325.png.jpg"/></div></div><p class="title">Figure 11-5. A high-level overview of how Rubinius compiles your code</p></div><p>At the top left of the diagram, Rubinius, like MRI, uses C code to parse Ruby code with a series of grammar rules. At right, Rubinius starts to process your Ruby program using Ruby code, representing each node in the AST with an instance of a Ruby class. Each Ruby AST node knows how to generate <a class="indexterm" id="iddle1095"/><a class="indexterm" id="iddle1876"/><a class="indexterm" id="iddle1932"/>Rubinius instructions for its piece of your program during compilation. Finally, at bottom left, the LLVM framework further compiles the Rubinius instructions into LLVM instructions and ultimately into machine language.</p></div><div class="sect2" title="Rubinius Bytecode Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="rubinius_bytecode_instructions"/>Rubinius Bytecode Instructions</h2></div></div></div><p>To get a sense of Rubinius instructions, let’s run a short program using Rubinius (see <a class="xref" href="ch11.html#using_rubinius_to_calculate_2_plus_2_equ" title="Example 11-1. Using Rubinius to calculate 2 + 2 = 4 (simple.rb)">Example 11-1</a>).</p><div class="example"><a id="using_rubinius_to_calculate_2_plus_2_equ"/><p class="title">Example 11-1. Using Rubinius to calculate 2 + 2 = 4 <span class="emphasis"><em>(simple.rb)</em></span></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>cat simple.rb</strong></span>
puts 2+2
$ <span class="strong"><strong>rbx simple.rb</strong></span>
4</pre></div></div><p>When we rerun <span class="emphasis"><em>simple.rb</em></span> using the <code class="literal">rbx compile</code> command with the <code class="literal">-B</code> option, Rubinius displays the bytecode instructions its compiler generates, as shown in <a class="xref" href="ch11.html#displaying_rubinius_bytecode_instruction" title="Example 11-2. Displaying Rubinius bytecode instructions using the rbx compile command with the -B option">Example 11-2</a>.</p><div class="example"><a id="displaying_rubinius_bytecode_instruction"/><p class="title">Example 11-2. Displaying Rubinius bytecode instructions using the <code class="literal">rbx compile</code> command with the <code class="literal">-B</code> option</p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>rbx compile simple.rb -B</strong></span>
    ============= :__script__ ==============
    Arguments:   0 required, 0 post, 0 total
    Arity:       0
    Locals:      0
    Stack size:  3
    Literals:    2: :+, :puts
    Lines to IP: 1: 0..12
    
    0000:  push_self
    0001:  meta_push_2
    0002:  meta_push_2
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> 0003:  send_stack                 :+, 1
    0006:  allow_private
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 0007:  send_stack                 :puts, 1
    0010:  pop
    0011:  push_true
    0012:  ret
    ----------------------------------------</pre></div></div><p>The instructions vaguely resemble MRI’s YARV instructions. Each instruction typically pushes a value onto an internal stack, operates on stack values, or executes a method such as the <code class="literal">+</code> at <span class="inlinemediaobject"><a id="inline_id00420"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> or <code class="literal">puts</code> at <span class="inlinemediaobject"><a id="inline_id00421"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><p><a class="xref" href="ch11.html#puts_method_in_rubinius_is_implement" title="Figure 11-6. The puts method in Rubinius is implemented with Ruby code.">Figure 11-6</a> shows both the Ruby code and corresponding Rubinius instructions for <span class="emphasis"><em>simple.rb</em></span> and part of the <code class="literal">Kernel</code> module.</p><div class="figure"><a id="puts_method_in_rubinius_is_implement"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00258"/><img alt="The puts method in Rubinius is implemented with Ruby code." src="httpatomoreillycomsourcenostarchimages1854327.png.jpg"/></div></div><p class="title">Figure 11-6. The <code class="literal">puts</code> method in Rubinius is implemented with Ruby code.</p></div><p><a class="indexterm" id="iddle1097"/><a class="indexterm" id="iddle1938"/>You can see Ruby code at the top of the figure: the <code class="literal">puts 2+2</code> code at left and Rubinius’s definition of the <code class="literal">puts</code> method at right. Rubinius implements built-in Ruby classes, such as the <code class="literal">Kernel</code> module, in Ruby; therefore, when we call the <code class="literal">puts</code> method, Rubinius simply passes control to the Ruby code for the <code class="literal">Kernel#puts</code> method contained inside the Rubinius kernel.</p><p>The lower portion of the figure shows the Rubinius instructions into which the Ruby code is compiled. At left are the instructions for <code class="literal">puts 2+2</code>, and at right is the compiled version of the <code class="literal">Kernel#puts</code> method. Rubinius compiles its built-in Ruby code and your Ruby code in the same manner (except that Rubinius compiles the built-in Ruby code during the Rubinius build process).</p></div><div class="sect2" title="Ruby and C++ Working Together"><div class="titlepage"><div><div><h2 class="title"><a id="ruby_and_cplusplus_working_together"/>Ruby and C++ Working Together</h2></div></div></div><p>In order to handle certain low-level technical details and to speed things up, Rubinius uses C++ code in its virtual machine to help implement built-in classes and modules. That is, it uses both Ruby and C++ to implement the language’s core classes.</p><p>To understand how this works, let’s execute this short Ruby script in Rubinius (see <a class="xref" href="ch11.html#calling_the_stringhashleft_square_bracke" title="Example 11-3. Calling the String#[] method">Example 11-3</a>).</p><div class="example"><a id="calling_the_stringhashleft_square_bracke"/><p class="title">Example 11-3. Calling the <code class="literal">String#[]</code> method</p><div class="example-contents"><pre class="programlisting">str = "The quick brown fox..."
puts str[4]
 =&gt; q</pre></div></div><p><a class="indexterm" id="iddle1119"/><a class="indexterm" id="iddle1409"/><a class="indexterm" id="iddle1651"/><a class="indexterm" id="iddle1655"/><a class="indexterm" id="iddle1748"/><a class="indexterm" id="iddle1937"/><a class="indexterm" id="iddle2020"/><a class="indexterm" id="iddle2022"/>This simple program prints the fifth character (the letter <span class="emphasis"><em>q</em></span> at index 4) in the sample string. Because the <code class="literal">String#[]</code> method is part of a built-in Ruby class, Rubinius implements it using Ruby code, as shown in <a class="xref" href="ch11.html#rubinius_implements_built-in_classes_wit" title="Figure 11-7. Rubinius implements built-in classes with a combination of Ruby and C++ code.">Figure 11-7</a>.</p><div class="figure"><a id="rubinius_implements_built-in_classes_wit"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00259"/><img alt="Rubinius implements built-in classes with a combination of Ruby and C++ code." src="httpatomoreillycomsourcenostarchimages1854329.png.jpg"/></div></div><p class="title">Figure 11-7. Rubinius implements built-in classes with a combination of Ruby and C++ code.</p></div><p>On the left of the figure is the Ruby script that prints the letter <span class="emphasis"><em>q</em></span>. On the right is the Ruby code that Rubinius uses to implement the <code class="literal">String#[]</code> method, taken from a Rubinius source code file called <span class="emphasis"><em>string.rb</em></span> (named after the <code class="literal">String</code> class). (We’ll learn how to find Rubinius source code files in <a class="xref" href="ch11.html#experiment_11-1_comparing_backtraces_in" title="Experiment 11-1: Comparing Backtraces in MRI and Rubinius">Experiment 11-1: Comparing Backtraces in MRI and Rubinius</a>.)</p><p>Notice that the beginning of <code class="literal">String#[]</code> starts with the method call <code class="literal">Rubinius.primitive</code>. This indicates that Rubinius actually uses C++ code to implement this method; <code class="literal">Rubinius.primitive</code> is a directive that tells the Rubinius compiler to generate a call to the corresponding C++ code. The code that actually implements <code class="literal">String#[]</code> is a C++ method called <code class="literal">String::aref</code>, shown at the bottom right of <a class="xref" href="ch11.html#rubinius_implements_built-in_classes_wit" title="Figure 11-7. Rubinius implements built-in classes with a combination of Ruby and C++ code.">Figure 11-7</a>.</p></div><div class="sect2" title="Implementing Ruby Objects with C++ Objects"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_ruby_objects_with_cplusplus"/>Implementing Ruby Objects with C++ Objects</h2></div></div></div><p>Ruby’s use of the object-oriented C++ allows its virtual machine to represent each Ruby object internally using a corresponding C++ object (see <a class="xref" href="ch11.html#rubinius_represents_classes_and_objects" title="Figure 11-8. Rubinius represents classes and objects using C++ objects.">Figure 11-8</a>).</p><p>Rubinius uses C++ objects the way that MRI uses the <code class="literal">RClass</code> and <code class="literal">RObject</code> C structures. When you define a class, Rubinius creates an instance of the <code class="literal">Class</code> C++ class. When you create a Ruby object, Rubinius creates an <a class="indexterm" id="iddle1065"/><a class="indexterm" id="iddle1266"/><a class="indexterm" id="iddle1706"/><a class="indexterm" id="iddle1737"/>instance of the <code class="literal">Object</code> C++ class. A <code class="literal">klass_</code> pointer in the <code class="literal">pythagoras</code> object indicates it is an instance of <code class="literal">Mathematician</code>, just as the <code class="literal">klass</code> pointer in the <code class="literal">RObject</code> C structure does in MRI.</p><div class="figure"><a id="rubinius_represents_classes_and_objects"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00260"/><img alt="Rubinius represents classes and objects using C++ objects." src="httpatomoreillycomsourcenostarchimages1854331.png"/></div></div><p class="title">Figure 11-8. Rubinius represents classes and objects using C++ objects.</p></div></div></div><div class="sect1" title="Experiment 11-1: Comparing Backtraces in MRI and Rubinius"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_11-1_comparing_backtraces_in"/>Experiment 11-1: Comparing Backtraces in MRI and Rubinius</h1></div></div></div><p>Recall that Ruby displays a backtrace when an exception occurs in order to help you find the problem. <a class="xref" href="ch11.html#ruby_script_that_raises_an_exception" title="Example 11-4. A Ruby script that raises an exception">Example 11-4</a> shows a simple example.</p><div class="example"><a id="ruby_script_that_raises_an_exception"/><p class="title">Example 11-4. A Ruby script that raises an exception</p><div class="example-contents"><pre class="programlisting">10.times do |n|
  puts n
  raise "Stop Here"
end</pre></div></div><p>We call <code class="literal">raise</code> to tell Ruby to stop the first time it executes the block after displaying the value of the parameter <code class="literal">n</code>. <a class="xref" href="ch11.html#how_mri_displays_a_backtrace_for_an_exce" title="Example 11-5. How MRI displays a backtrace for an exception">Example 11-5</a> shows the output from running <a class="xref" href="ch11.html#ruby_script_that_raises_an_exception" title="Example 11-4. A Ruby script that raises an exception">Example 11-4</a> with MRI.</p><div class="example"><a id="how_mri_displays_a_backtrace_for_an_exce"/><p class="title">Example 11-5. How MRI displays a backtrace for an exception</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby iterate.rb</strong></span>
0
iterate.rb:3:in 'block in &lt;main&gt;': Stop Here (RuntimeError)
    from iterate.rb:1:in 'times'
    from iterate.rb:1:in '&lt;main&gt;'</pre></div></div><p>You probably see output like this many times while developing a Ruby program. However, one subtle detail is worth a closer look. <a class="xref" href="ch11.html#mri_displays_where_built-in_cfunc_method" title="Figure 11-9. MRI displays where built-in CFUNC methods are called, not where they are defined.">Figure 11-9</a> shows a diagram of the MRI backtrace output.</p><div class="figure"><a id="mri_displays_where_built-in_cfunc_method"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00261"/><img alt="MRI displays where built-in CFUNC methods are called, not where they are defined." src="httpatomoreillycomsourcenostarchimages1854333.png"/></div></div><p class="title">Figure 11-9. MRI displays where built-in CFUNC methods are called, not where they are defined.</p></div><p><a class="indexterm" id="iddle1135"/><a class="indexterm" id="iddle1448"/><a class="indexterm" id="iddle1930"/>Notice that line 3 of <span class="emphasis"><em>iterate.rb</em></span>, containing the call to <code class="literal">raise</code>, is at the top of the call stack. At the bottom of the call stack, MRI displays <code class="literal">iterate.rb:1</code>, where the short script began.</p><p>Notice, too, that MRI’s backtrace contains a broken link: <span class="emphasis"><em>iterate.rb</em></span> doesn’t contain a definition for the method <code class="literal">times</code>. Instead, MRI refers to the line of code that <span class="emphasis"><em>calls</em></span> the <code class="literal">times</code> method: <code class="literal">10.times do</code>. The actual <code class="literal">times</code> method is implemented with C code inside MRI—a CFUNC method. MRI displays the location of calls to CFUNC methods in backtraces, not the location of the actual C implementation of these methods.</p><div class="sect2" title="Backtraces in Rubinius"><div class="titlepage"><div><div><h2 class="title"><a id="backtraces_in_rubinius"/>Backtraces in Rubinius</h2></div></div></div><p>Unlike MRI, Rubinius implements built-in methods using Ruby, not C. This implementation allows Rubinius to include accurate source file and line number information about built-in methods in backtraces. To demonstrate, let’s run <a class="xref" href="ch11.html#ruby_script_that_raises_an_exception" title="Example 11-4. A Ruby script that raises an exception">Example 11-4</a> again using Rubinius. <a class="xref" href="ch11.html#how_rubinius_displays_a_backtrace_for_an" title="Example 11-6. How Rubinius displays a backtrace for an exception">Example 11-6</a> shows the result.</p><div class="example"><a id="how_rubinius_displays_a_backtrace_for_an"/><p class="title">Example 11-6. How Rubinius displays a backtrace for an exception</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>rbx iterate.rb</strong></span>
0
An exception occurred running iterate.rb
    Stop Here (RuntimeError)

Backtrace:
          { } in Object#__script__ at iterate.rb:3
             Integer(Fixnum)#times at kernel/common/integer.rb:83
                 Object#__script__ at iterate.rb:1
  Rubinius::CodeLoader#load_script at kernel/delta/codeloader.rb:68
  Rubinius::CodeLoader.load_script at kernel/delta/codeloader.rb:119
           Rubinius::Loader#script at kernel/loader.rb:645
             Rubinius::Loader#main at kernel/loader.rb:844</pre></div></div><p>Rubinius displays much more information! To understand this output a bit better, see <a class="xref" href="ch11.html#like_mricomma_rubinius_includes_informat" title="Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.">Figure 11-10</a> and <a class="xref" href="ch11.html#rubinius_includes_information_about_its" title="Figure 11-11. Rubinius includes information about its kernel in backtraces.">Figure 11-11</a>.</p><p>At left in <a class="xref" href="ch11.html#like_mricomma_rubinius_includes_informat" title="Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.">Figure 11-10</a> is a simplified version of the backtrace information Rubinius displayed while running <span class="emphasis"><em>iterate.rb</em></span>. Rubinius displays the two lines in the backtrace corresponding to <span class="emphasis"><em>iterate.rb</em></span> just as MRI does. But Rubinius <a class="indexterm" id="iddle1175"/><a class="indexterm" id="iddle1449"/><a class="indexterm" id="iddle1451"/><a class="indexterm" id="iddle1551"/><a class="indexterm" id="iddle1642"/>also includes new entries in the Ruby call stack that correspond to Ruby source code files inside the Rubinius kernel. We can guess that the <span class="emphasis"><em>loader.rb</em></span> and <span class="emphasis"><em>codeloader.rb</em></span> files contain code that load and execute our script.</p><div class="figure"><a id="like_mricomma_rubinius_includes_informat"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00262"/><img alt="Like MRI, Rubinius includes information about your program in backtraces." src="httpatomoreillycomsourcenostarchimages1854335.png"/></div></div><p class="title">Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.</p></div><p>But the most interesting entry in the call stack is <code class="literal">kernel/common/integer.rb:83</code>. This entry tells us where the <code class="literal">Integer#times</code> method is implemented inside the Rubinius kernel, as shown in <a class="xref" href="ch11.html#rubinius_includes_information_about_its" title="Figure 11-11. Rubinius includes information about its kernel in backtraces.">Figure 11-11</a>.</p><div class="figure"><a id="rubinius_includes_information_about_its"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00263"/><img alt="Rubinius includes information about its kernel in backtraces." src="httpatomoreillycomsourcenostarchimages1854337.png.jpg"/></div></div><p class="title">Figure 11-11. Rubinius includes information about its kernel in backtraces.</p></div><p>The backtrace information on the left of the figure is the same as that in <a class="xref" href="ch11.html#like_mricomma_rubinius_includes_informat" title="Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.">Figure 11-10</a>. The arrow points from the second level of the Ruby call stack to the code that calls the <code class="literal">puts n</code> block—the <code class="literal">yield</code> instruction in the <code class="literal">Integer#times</code> method.</p><p>Using Rubinius, <span class="emphasis"><em>iterate.rb</em></span> becomes part of a larger Ruby program: the Rubinius kernel. When we call <code class="literal">10.times</code>, Rubinius calls the Ruby code shown at the right, which then executes our block using the <code class="literal">yield</code> keyword on line 83.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note01"/>Note</h3><p><a class="indexterm" id="iddle1032"/><a class="indexterm" id="iddle1123"/><a class="indexterm" id="iddle1126"/><a class="indexterm" id="iddle1243"/><a class="indexterm" id="iddle1705"/><span class="emphasis"><em>The path</em></span> kernel/common/integer.rb <span class="emphasis"><em>refers to a location in the Rubinius source code tree. If you installed Rubinius using a binary installer, you’ll need to download the source code from</em></span> <a class="ulink" href="http://rubini.us/">http://rubini.us/</a> <span class="emphasis"><em>or GitHub in order to read it.</em></span></p></div><p>Rubinius implements <code class="literal">Integer#times</code> by counting from 0 up to the specified integer (minus one), calling the block each time through the loop. Let’s take a closer look at <code class="literal">Integer#times</code>, as shown in <a class="xref" href="ch11.html#rubinius_implementation_of_integerha" title="Example 11-7. The Rubinius implementation of Integer#times, from kernel/common/integer.rb">Example 11-7</a>.</p><div class="example"><a id="rubinius_implementation_of_integerha"/><p class="title">Example 11-7. <span class="emphasis"><em>The Rubinius implementation of <code class="literal">Integer#times</code>, from</em></span> kernel/common/integer.rb</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> def times
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   return to_enum(:times) unless block_given?

<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   i = 0
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>   while i &lt; self
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>     yield i
        i += 1
      end
<img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/>   self
    end</pre></div></div><p>The definition of the <code class="literal">times</code> method starts at <span class="inlinemediaobject"><a id="inline_id00428"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. At <span class="inlinemediaobject"><a id="inline_id00429"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> Rubinius returns the result of <code class="literal">to_enum</code> if a block is not provided, as shown below. (The <code class="literal">to_enum</code> method returns a new enumerator object, which allows you to perform the enumeration later if you prefer.)</p><a id="pro_id00073"/><pre class="programlisting">p 10.times
 =&gt; #&lt;Enumerable::Enumerator:0x120 @generator=nil @args=[] @lookahead=[]     @object=10 @iter=:times&gt;</pre><p>Rubinius continues to execute the rest of the method if you provide a block. At <span class="inlinemediaobject"><a id="inline_id00430"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> Rubinius creates a counter <code class="literal">i</code> and initializes it to 0. Next, it uses a while loop at <span class="inlinemediaobject"><a id="inline_id00431"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> to perform the iteration. Notice that the while loop condition <code class="literal">i &lt; self</code> refers to the value of <code class="literal">self</code>. Inside <code class="literal">Integer#times</code>, <code class="literal">self</code> is set to the current integer object, or 10 in our script. At <span class="inlinemediaobject"><a id="inline_id00432"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> Rubinius yields to (calls) the given block, passing in the current value of <code class="literal">i</code>. This calls our <code class="literal">puts n</code> block. Finally, at <span class="inlinemediaobject"><a id="inline_id00433"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span> Rubinius returns <code class="literal">self</code>, which means the return value of <code class="literal">10.times</code> will be 10.</p></div></div><div class="sect1" title="Arrays in Rubinius and MRI"><div class="titlepage"><div><div><h1 class="title"><a id="arrays_in_rubinius_and_mri"/>Arrays in Rubinius and MRI</h1></div></div></div><p>Arrays are so ubiquitous in Ruby that it’s easy to take them for granted. But how do they work inside Ruby? Where does Ruby save objects that you place into an array, and how does it represent array objects internally? In the following sections, we’ll look at the internal data structures that Rubinius and MRI use to hold values in an array.</p><div class="sect2" title="Arrays Inside of MRI"><div class="titlepage"><div><div><h2 class="title"><a id="arrays_inside_of_mri"/>Arrays Inside of MRI</h2></div></div></div><p><a class="indexterm" id="iddle1849"/><a class="indexterm" id="iddle1960"/><a class="indexterm" id="iddle2070"/>Suppose you put the first six numbers from the Fibonacci sequence into an array.</p><a id="pro_id00074"/><pre class="programlisting">fibonacci_sequence = [1, 1, 2, 3, 5, 8]</pre><p>As <a class="xref" href="ch11.html#mri_uses_the_rarray_c_structure_to_repre" title="Figure 11-12. MRI uses the RArray C structure to represent arrays.">Figure 11-12</a> illustrates, MRI creates a C structure for the array but saves its elements elsewhere.</p><div class="figure"><a id="mri_uses_the_rarray_c_structure_to_repre"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00264"/><img alt="MRI uses the RArray C structure to represent arrays." src="httpatomoreillycomsourcenostarchimages1854339.png.jpg"/></div></div><p class="title">Figure 11-12. MRI uses the <code class="literal">RArray</code> C structure to represent arrays.</p></div><p>MRI uses one <code class="literal">RArray</code> structure to represent each array you create. Like <code class="literal">RString</code>, <code class="literal">RObject</code>, and other C structures, <code class="literal">RArray</code> uses the inner <code class="literal">RBasic</code> structure to hold the <code class="literal">klass</code> pointer and other technical information. (In this case, the <code class="literal">klass</code> pointer points to the <code class="literal">RClass</code> structure for the <code class="literal">Array</code> class.)</p><p>Below <code class="literal">RBasic</code> are a few additional values specific to arrays—<code class="literal">ptr</code>, <code class="literal">len</code>, and <code class="literal">capa</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">ptr</code> is a pointer to a memory segment Ruby allocates separately to store the array elements. The Fibonacci numbers appear in this memory segment at the right side of <a class="xref" href="ch11.html#mri_uses_the_rarray_c_structure_to_repre" title="Figure 11-12. MRI uses the RArray C structure to represent arrays.">Figure 11-12</a>.</p></li><li class="listitem"><p><code class="literal">len</code> is the length of the array—that is, the number of values saved in the separate memory segment.</p></li><li class="listitem"><p><code class="literal">capa</code> tracks the capacity of the memory segment. This number is often larger than <code class="literal">len</code>. MRI avoids continually resizing the memory segment each time you change the size of the array; instead, as you add array elements, it occasionally increases the size of the separate memory segment, each time allocating more memory than the new elements require.</p></li></ul></div><p>Each value in the separate memory segment is actually a <code class="literal">VALUE</code> pointer to a Ruby object. In this case, the Fibonacci numbers would be saved directly inside the <code class="literal">VALUE</code> pointers because they are simple integers.</p><div class="sidebar"><a id="rarray_c_structure_definition"/><p class="title">The RArray C Structure Definition</p><p><a class="indexterm" id="iddle1850"/><a class="xref" href="ch11.html#definition_of_rarray_left_parenthesi" title="Example 11-8. The definition of RArray (from include/ruby/ruby.h)">Example 11-8</a> shows the definition of <code class="literal">RArray</code> from the MRI C source code.</p><div class="example"><a id="definition_of_rarray_left_parenthesi"/><p class="title">Example 11-8. <span class="emphasis"><em>The definition of <code class="literal">RArray</code> (from</em></span> include/ruby/ruby.h<span class="emphasis"><em>)</em></span></p><div class="example-contents"><pre class="programlisting">    #define RARRAY_EMBED_LEN_MAX 3struct RArray {
      struct RBasic basic;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   union {
        struct {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>       long len;
          union {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>         long capa;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>         VALUE shared;
          } aux;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>       VALUE *ptr;
        } heap;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/>     VALUE ary[RARRAY_EMBED_LEN_MAX];
      } as;
    };</pre></div></div><p>This definition shows a few values that are missing from <a class="xref" href="ch11.html#mri_uses_the_rarray_c_structure_to_repre" title="Figure 11-12. MRI uses the RArray C structure to represent arrays.">Figure 11-12</a>. First, at <span class="inlinemediaobject"><a id="inline_id00440"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, notice that MRI uses a C <code class="literal">union</code> keyword to declare two alternative definitions for <code class="literal">RArray</code>. The first, an inner <code class="literal">struct</code>, defines <code class="literal">len</code> at <span class="inlinemediaobject"><a id="inline_id00441"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, <code class="literal">capa</code> at <span class="inlinemediaobject"><a id="inline_id00442"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>, <code class="literal">shared</code> at <span class="inlinemediaobject"><a id="inline_id00443"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>, and <code class="literal">ptr</code> at <span class="inlinemediaobject"><a id="inline_id00444"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span>. As with strings, MRI uses copy-on-write optimization with arrays, allowing two or more arrays to share the same underlying data. For arrays that share data, the <code class="literal">shared</code> value at <span class="inlinemediaobject"><a id="inline_id00445"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> refers to another <code class="literal">RArray</code> that contains the shared data.</p><p>The second half of the union at <span class="inlinemediaobject"><a id="inline_id00446"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span> defines <code class="literal">ary</code>, a C array of <code class="literal">VALUE</code> pointers in <code class="literal">RArray</code>. This is an optimization that allows MRI to save the array data for arrays with three or fewer elements inside the <code class="literal">RArray</code> structure itself, avoiding the need to allocate the separate memory segment at all. MRI optimizes four other C structures in a similar way: <code class="literal">RString</code>, <code class="literal">RObject</code>, <code class="literal">RStruct</code> (used by the <code class="literal">Struct</code> class), and <code class="literal">RBignum</code> (used by the <code class="literal">Bignum</code> class).</p></div></div><div class="sect2" title="Arrays Inside of Rubinius"><div class="titlepage"><div><div><h2 class="title"><a id="arrays_inside_of_rubinius"/>Arrays Inside of Rubinius</h2></div></div></div><p>Now let’s see how Rubinius saves the same Fibonacci array internally. We learned earlier that Rubinius represents each Ruby object with a corresponding C++ object. This representation is true of arrays as well. For example, <a class="xref" href="ch11.html#rubinius_uses_cplusplus_objects_to_repre" title="Figure 11-13. Rubinius uses C++ objects to represent arrays.">Figure 11-13</a> shows the C++ object that Rubinius would use to represent <code class="literal">fibonacci_sequence</code>.</p><div class="figure"><a id="rubinius_uses_cplusplus_objects_to_repre"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00265"/><img alt="Rubinius uses C++ objects to represent arrays." src="httpatomoreillycomsourcenostarchimages1854341.png"/></div></div><p class="title">Figure 11-13. Rubinius uses C++ objects to represent arrays.</p></div><p><a class="indexterm" id="iddle1030"/><a class="indexterm" id="iddle2058"/>The combined four blocks represent an instance of the <code class="literal">Array</code> C++ class. Rubinius creates a C++ array object each time you create an array. From left to right, the fields are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">ObjectHeader</code> contains technical information that Rubinius keeps track of inside each object, including a class pointer and an array of instance variables. <code class="literal">ObjectHeader</code> corresponds to the <code class="literal">RBasic</code> C structure in MRI and is one of the C++ superclasses of the <code class="literal">Array</code> C++ class inside the Rubinius virtual machine.</p></li><li class="listitem"><p><code class="literal">total_</code> is the length of the array, which is 6 for <code class="literal">fibonacci_sequence</code>.</p></li><li class="listitem"><p><code class="literal">tuple_</code> is a pointer to an instance of another C++ class, called <code class="literal">Tuple</code>, that contains the array data.</p></li><li class="listitem"><p><code class="literal">start_</code> indicates where the array data starts inside the tuple object. (The tuple may contain more data than your array needs.) Initially, Rubinius sets this to 0.</p></li></ul></div><p>Rubinius doesn’t save the array data in the C++ array object. It saves it in a tuple object, as shown in <a class="xref" href="ch11.html#rubinius_saves_array_data_in_tuple_objec" title="Figure 11-14. Rubinius saves array data in tuple objects.">Figure 11-14</a>.</p><div class="figure"><a id="rubinius_saves_array_data_in_tuple_objec"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00266"/><img alt="Rubinius saves array data in tuple objects." src="httpatomoreillycomsourcenostarchimages1854343.png"/></div></div><p class="title">Figure 11-14. Rubinius saves array data in tuple objects.</p></div><p>Each tuple contains the same object header information as arrays. Rubinius saves this header information in every C++ object. Following the object header, tuple objects contain a value called <code class="literal">full_size_</code>, which keeps track of the size of this tuple object in bytes. Following this value, Rubinius saves the actual data values in a C++ array called <code class="literal">fields</code>. These data values are our six Fibonacci numbers, as shown at the right of <a class="xref" href="ch11.html#rubinius_saves_array_data_in_tuple_objec" title="Figure 11-14. Rubinius saves array data in tuple objects.">Figure 11-14</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note02"/>Note</h3><p><span class="emphasis"><em>Array data values are saved in the tuple C++ object. If we had created a larger array, Rubinius would have used a larger tuple object. If we change the size of an array, Rubinius allocates another tuple of the appropriate size or, as we’ll see in <a class="xref" href="ch11.html#experiment_11-2_exploring_the_rubinius_i" title="Experiment 11-2: Exploring the Rubinius Implementation of Array#shift">Experiment 11-2: Exploring the Rubinius Implementation of Array#shift</a>, it can optimize certain array methods in order to avoid allocating new objects and speed up your program.</em></span></p></div></div></div><div class="sect1" title="Experiment 11-2: Exploring the Rubinius Implementation of Array#shift"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_11-2_exploring_the_rubinius_i"/>Experiment 11-2: Exploring the Rubinius Implementation of Array#shift</h1></div></div></div><p><a class="indexterm" id="iddle1034"/><a class="indexterm" id="iddle1265"/><a class="indexterm" id="iddle1606"/><a class="indexterm" id="iddle1654"/><a class="indexterm" id="iddle1885"/><a class="indexterm" id="iddle1995"/>We’ve seen that Rubinius uses C++ objects to represent arrays, but remember that Rubinius uses a combination of Ruby and C++ code to implement methods in the <code class="literal">Array</code> class. In this experiment, we’ll learn more about how arrays work by looking at how Rubinius implements the <code class="literal">Array#shift</code> method.</p><p>But first a quick review of what <code class="literal">Array#shift</code> does. As you may know, calling <code class="literal">shift</code> removes one element from the beginning of an array and <span class="emphasis"><em>shifts</em></span> the remaining elements to the left, as shown in <a class="xref" href="ch11.html#arrayhashshift_removes_the_first_element" title="Example 11-9. Array#shift removes the first element from an array, shifting the remaining elements over.">Example 11-9</a>.</p><div class="example"><a id="arrayhashshift_removes_the_first_element"/><p class="title">Example 11-9. <code class="literal">Array#shift</code> removes the first element from an array, shifting the remaining elements over.</p><div class="example-contents"><pre class="programlisting">    fibonacci_sequence = [1, 1, 2, 3, 5, 8]
    p fibonacci_sequence.shift
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; 1
    p fibonacci_sequence
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  =&gt; [1, 2, 3, 5, 8]</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00449"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> <code class="literal">Array#shift</code> returns the first element of <code class="literal">fibonacci_sequence</code>. We can see from the output at <span class="inlinemediaobject"><a id="inline_id00450"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> that <code class="literal">Array#shift</code> also removes the first element from the array, shifting the other five elements. But how does Ruby implement <code class="literal">Array#shift</code> internally? Does it actually copy the remaining array elements to the left, or does it copy them into a new array?</p><div class="sect2" title="Reading Array#shift"><div class="titlepage"><div><div><h2 class="title"><a id="reading_arrayhashshift"/>Reading Array#shift</h2></div></div></div><p>First, let’s find out where the <code class="literal">Array#shift</code> method is located inside Rubinius. Because we don’t have a backtrace to refer to as in <a class="xref" href="ch11.html#experiment_11-1_comparing_backtraces_in" title="Experiment 11-1: Comparing Backtraces in MRI and Rubinius">Experiment 11-1: Comparing Backtraces in MRI and Rubinius</a>, we can ask Rubinius where to find the method using <code class="literal">source_location</code>.</p><a id="pro_id00075"/><pre class="programlisting">p Array.instance_method(:shift).source_location
 =&gt; ["kernel/common/array.rb", 848]</pre><p>This output tells us that Rubinius defines the <code class="literal">Array#shift</code> method at line 848 in the file <span class="emphasis"><em>kernel/common/array.rb</em></span> in the Rubinius source tree. <a class="xref" href="ch11.html#implementation_of_arrayhashshift_ins" title="Example 11-10. The implementation of Array#shift inside the Rubinius kernel">Example 11-10</a> shows the Rubinius implementation of <code class="literal">Array#shift</code>.</p><div class="example"><a id="implementation_of_arrayhashshift_ins"/><p class="title">Example 11-10. The implementation of <code class="literal">Array#shift</code> inside the Rubinius kernel</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> def shift(n=undefined)
      Rubinius.check_frozen

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   if undefined.equal?(n)
        return nil if @total == 0
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     obj = @tuple.at @start
        @tuple.put @start, nil
        @start += 1
        @total -= 1

        obj
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>   else
        n = Rubinius::Type.coerce_to(n, Fixnum, :to_int)
        raise ArgumentError, "negative array size" if n &lt; 0

        Array.new slice!(0, n)
      end
    end</pre></div></div><p><a class="indexterm" id="iddle1687"/>At <span class="inlinemediaobject"><a id="inline_id00455"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> <code class="literal">shift</code> takes an optional parameter <code class="literal">n</code>. If <code class="literal">shift</code> is called without a parameter <code class="literal">n</code>, as in <a class="xref" href="ch11.html#arrayhashshift_removes_the_first_element" title="Example 11-9. Array#shift removes the first element from an array, shifting the remaining elements over.">Example 11-9</a>, it will remove the first element and shift the remaining elements by one position. If you provide a parameter <code class="literal">n</code> to <code class="literal">shift</code>, it will remove <code class="literal">n</code> elements and shift the remaining elements <code class="literal">n</code> positions to the left. At <span class="inlinemediaobject"><a id="inline_id00456"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> Rubinius checks whether the parameter <code class="literal">n</code> was supplied. If <code class="literal">n</code> was specified, it jumps to <span class="inlinemediaobject"><a id="inline_id00457"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> and uses <code class="literal">Array#slice!</code> to remove the first <code class="literal">n</code> elements and return them.</p></div><div class="sect2" title="Modifying Array#shift"><div class="titlepage"><div><div><h2 class="title"><a id="modifying_arrayhashshift"/>Modifying Array#shift</h2></div></div></div><p>Now let’s see what happens when you call <code class="literal">shift</code> with no parameters. How does Rubinius shift the array by one element? Unfortunately, the <code class="literal">Tuple#at</code> method called at <span class="inlinemediaobject"><a id="inline_id00458"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> is implemented by the C++ code inside the Rubinius virtual machine. (You won’t find a definition for <code class="literal">at</code> in the Ruby <span class="emphasis"><em>kernel/common/tuple.rb</em></span> file.) This means we won’t be able to read the entire algorithm in Ruby.</p><p>We can, however, add Ruby code to Rubinius to display information about the array data when we call <code class="literal">shift</code>. Because the Rubinius kernel is written with Ruby, we can change it like any other Ruby program! First, we’ll add a few lines of code to <code class="literal">Array#shift</code>, as shown in <a class="xref" href="ch11.html#adding_debug_code_to_the_rubinius_kernel" title="Example 11-11. Adding debug code to the Rubinius kernel">Example 11-11</a>.</p><div class="example"><a id="adding_debug_code_to_the_rubinius_kernel"/><p class="title">Example 11-11. Adding debug code to the Rubinius kernel</p><div class="example-contents"><pre class="programlisting">    if undefined.equal?(n)
      return nil if @total == 0

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   fibonacci_array = (self == [1, 1, 2, 3, 5, 8])
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   puts "Start: #{@start} Total: #@total} Tuple: #{@tuple.inspect}" if  fibonacci_array

      obj = @tuple.at @start
      @tuple.put @start, nil
      @start += 1
      @total -= 1

<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   puts "Start: #{@start} Total: #{@total} Tuple: #{@tuple.inspect}" if  fibonacci_array

      obj
    end</pre></div></div><p><a class="indexterm" id="iddle1184"/><a class="indexterm" id="iddle1934"/>At <span class="inlinemediaobject"><a id="inline_id00462"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we check whether this array is our Fibonacci array. Rubinius uses this method for every array in the system, but we want to display only information about our array. Then, at <span class="inlinemediaobject"><a id="inline_id00463"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we display the values of <code class="literal">@start</code>, <code class="literal">@total</code>, and <code class="literal">@tuple</code>. Under the hood, <code class="literal">@tuple</code> is a C++ object, but in Rubinius it also functions as a Ruby object, allowing us to call its <code class="literal">inspect</code> method. At <span class="inlinemediaobject"><a id="inline_id00464"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> we display the same values once they’ve been changed by the <code class="literal">Array#shift</code> code.</p><p>Now we need to rebuild Rubinius to include our code changes. <a class="xref" href="ch11.html#rebuilding_rubinius" title="Example 11-12. Rebuilding Rubinius">Example 11-12</a> shows the output produced by the <code class="literal">rake install</code> command. (Run this at the root of the Rubinius source code tree.)</p><div class="example"><a id="rebuilding_rubinius"/><p class="title">Example 11-12. Rebuilding Rubinius</p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>rake install</strong></span>

    --<span class="emphasis"><em>snip</em></span>--

    RBC kernel/common/hash.rb
    RBC kernel/common/hash19.rb
    RBC kernel/common/hash_hamt.rb
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> RBC kernel/common/array.rb
    RBC kernel/common/array19.rb
    RBC kernel/common/kernel.rb

    --<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The Rubinius build process recompiled the <span class="emphasis"><em>array.rb</em></span> source code file at <span class="inlinemediaobject"><a id="inline_id00466"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, along with many other kernel files. (<code class="literal">RBC</code> refers to the Rubinius compiler.)</p><div class="note" title="Note"><h3 class="title"><a id="ch11note03"/>Note</h3><p><span class="emphasis"><em>Don’t try to use this sort of code change in a production environment.</em></span></p></div><p>Now to rerun <a class="xref" href="ch11.html#arrayhashshift_removes_the_first_element" title="Example 11-9. Array#shift removes the first element from an array, shifting the remaining elements over.">Example 11-9</a> using our modified version of Rubinius. <a class="xref" href="ch11.html#using_our_modified_version_of_arrayhashs" title="Example 11-13. Using our modified version of Array#shift">Example 11-13</a> shows the output interspersed with our original code.</p><div class="example"><a id="using_our_modified_version_of_arrayhashs"/><p class="title">Example 11-13. Using our modified version of <code class="literal">Array#shift</code></p><div class="example-contents"><pre class="programlisting">    fibonacci_sequence = [1, 1, 2, 3, 5, 8]
    p fibonacci_sequence.shift
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> Start: 0 Total: 6 Tuple: #&lt;Rubinius::Tuple: 1, 1, 2, 3, 5, 8&gt;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> Start: 1 Total: 5 Tuple: #&lt;Rubinius::Tuple: nil, 1, 2, 3, 5, 8&gt; =&gt; 1
    p fibonacci_sequence
     =&gt; [1, 2, 3, 5, 8]</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00469"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and <span class="inlinemediaobject"><a id="inline_id00470"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> our new Ruby code inside <code class="literal">Array#shift</code> displays the internal contents of <code class="literal">fibonacci_sequence</code>: the <code class="literal">@start</code>, <code class="literal">@total</code>, and <code class="literal">@tuple</code> instance variables. Comparing <span class="inlinemediaobject"><a id="inline_id00471"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> with <span class="inlinemediaobject"><a id="inline_id00472"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, we can see how <code class="literal">Array#shift</code> works internally. Rubinius hasn’t allocated a new array object; it’s reused the underlying tuple object. Rubinius has done the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changed <code class="literal">@total</code> from 6 to 5 because the length of the array has decreased by 1</p></li><li class="listitem"><p>Changed <code class="literal">@start</code> from 0 to 1, which allowed it to continue to use the same value for <code class="literal">@tuple</code>; now the array contents start at the second value (index 1) in <code class="literal">@tuple</code>, not the first (index 0)</p></li><li class="listitem"><p>Changed the first value in <code class="literal">@tuple</code> from 1 to <code class="literal">nil</code> because the first value is no longer used by the array</p></li></ul></div><p>Creating new objects and allocating new memory can take a long time because Rubinius might have to ask for memory from the operating system. Its reuse of the underlying data in the tuple object, without copying or allocating memory for a new array, allows Rubinius to run faster.</p><p><a class="xref" href="ch11.html#tuple_holding_our_fibonacci_numbers" title="Figure 11-15. The tuple holding our Fibonacci numbers before calling Array#shift">Figure 11-15</a> and <a class="xref" href="ch11.html#same_tuple_after_calling_arrayhashsh" title="Figure 11-16. The same tuple after calling Array#shift">Figure 11-16</a> summarize how <code class="literal">Array#shift</code> works. <a class="xref" href="ch11.html#tuple_holding_our_fibonacci_numbers" title="Figure 11-15. The tuple holding our Fibonacci numbers before calling Array#shift">Figure 11-15</a> shows the array before calling <code class="literal">Array#shift</code>: <code class="literal">@start</code> pointed to the first value in the tuple, and <code class="literal">@length</code> was 6.</p><div class="figure"><a id="tuple_holding_our_fibonacci_numbers"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00267"/><img alt="The tuple holding our Fibonacci numbers before calling Array#shift" src="httpatomoreillycomsourcenostarchimages1854345.png.jpg"/></div></div><p class="title">Figure 11-15. The tuple holding our Fibonacci numbers before calling <code class="literal">Array#shift</code></p></div><p><a class="xref" href="ch11.html#same_tuple_after_calling_arrayhashsh" title="Figure 11-16. The same tuple after calling Array#shift">Figure 11-16</a> shows the tuple after calling <code class="literal">Array#shift</code>; Rubinius has simply changed the values of <code class="literal">@start</code> and <code class="literal">@length</code> and set the first value in the tuple to <code class="literal">nil</code>.</p><div class="figure"><a id="same_tuple_after_calling_arrayhashsh"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00268"/><img alt="The same tuple after calling Array#shift" src="httpatomoreillycomsourcenostarchimages1854347.png"/></div></div><p class="title">Figure 11-16. The same tuple after calling <code class="literal">Array#shift</code></p></div><p>As you might guess, MRI uses a similar optimization for <code class="literal">Array#shift</code> by keeping track of where the array data starts in the original array. However, the C code it uses is more complex and difficult to understand. The Rubinius kernel gives us a much clearer view of this algorithm.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00044"/>Summary</h1></div></div></div><p>We’ve learned in this chapter that Rubinius uses a virtual machine implemented with C++ to run your Ruby code. Like YARV, the Rubinius virtual machine was custom designed to run Ruby programs, and it uses a compiler to convert your Ruby program into bytecode internally. We saw that these Rubinius instructions resemble YARV instructions; they operate on stack values in a similar way.</p><p>But what sets Rubinius apart from other Ruby implementations is its Ruby language kernel. The Rubinius kernel implements many built-in Ruby classes, such as <code class="literal">Array</code>, using Ruby code. This innovative design provides a window into Ruby internals<code class="literal">—you</code> can use Rubinius to learn how Ruby works internally without having to know C or Java. You can learn how Ruby implements strings, arrays, or other classes simply by reading the Ruby source code in the Rubinius kernel. Rubinius isn’t just a Ruby implementation; it’s a valuable learning resource for the Ruby community.</p></div></div></body></html>