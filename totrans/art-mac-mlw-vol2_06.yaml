- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 5 PERSISTENCE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 持久化
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Arguably one of the best ways to detect malicious threats on macOS is to focus
    on persistence. Here, *persistence* refers to the means by which software, including
    malware, installs itself on a system to ensure it will automatically re-execute
    upon startup, user login, or some other deterministic event. Otherwise, it might
    never run again if the user logs out or the system reboots. In this chapter, I
    focus solely on enumerating persistent items. In [Part II](part2.xhtml), where
    I cover approaches that allow events to be observed as they occur, I’ll discuss
    how to leverage Apple’s Endpoint Security to monitor for persistence events.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，检测 macOS 恶意威胁的最佳方法之一就是关注持久化。在这里，*持久化*指的是软件（包括恶意软件）安装自身到系统中的方式，以确保它在启动时、用户登录时或某些其他确定性事件发生时自动重新执行。否则，如果用户注销或系统重启，它可能永远不会再次运行。在本章中，我将重点列举持久化项目。在[第二部分](part2.xhtml)中，我将介绍如何利用
    Apple 的 Endpoint Security 来监控持久化事件。
- en: 'As a shared characteristic of most malware, persistence serves as a robust
    detection mechanism capable of uncovering most infections. On macOS, malware generally
    persists in one of two ways: as launch items (daemons or agents) or as login items.
    In this chapter, I’ll show you exactly how to enumerate such items to reveal almost
    any Mac malware specimen.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为大多数恶意软件的共同特征，持久化是一个强大的检测机制，能够揭示大多数感染。在 macOS 上，恶意软件通常以两种方式持久化：作为启动项（守护进程或代理）或作为登录项。在本章中，我将向你展示如何精确列举这些项目，以揭示几乎任何
    macOS 恶意软件样本。
- en: Of course, not all macOS malware persists. For example, ransomware that encrypts
    user files or stealers that grab and exfiltrate sensitive user data often have
    no need to run multiple times, and thus rarely install themselves persistently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有 macOS 恶意软件都会持久化。例如，加密用户文件的勒索软件或窃取并外泄敏感用户数据的窃取者通常不需要多次运行，因此很少将自己持久化安装。
- en: On the other hand, legitimate programs designed to run continuously, such as
    auto-updaters, security tools, or even simple helper utilities, also tend to persist.
    Thus, the fact that something is persistently installed doesn’t mean our code
    should flag it as malicious.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，设计用于持续运行的合法程序，如自动更新器、安全工具，甚至是简单的辅助工具，也往往会持续存在。因此，某个程序持续安装并不意味着我们的代码应该将其标记为恶意程序。
- en: Examples of Persistent Malware
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化恶意软件的示例
- en: 'Because this chapter focuses on uncovering malware that persists as either
    a login item or a launch item, let’s start with a brief example of each. Initially
    disclosed by the researcher Taha Karim, the WindTail malware targeted employees
    working in government and critical infrastructure in the Middle East.^([1](#chapter5-1))
    In a detailed research paper,^([2](#chapter5-2)) I noted that the malware, which
    often masquerades as a PowerPoint presentation named *Final_Presentation*, persists
    itself as a login item to ensure that it automatically re-executes each time the
    user logs in. In the malware’s application bundle, we find its main binary, a
    file named *usrnode*. Decompiling this file uncovers the persistence logic at
    the start of its main function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本章的重点是揭示作为登录项或启动项持久化的恶意软件，我们从每种类型的简短示例开始。WindTail 恶意软件最早由研究员 Taha Karim 公开，主要针对中东地区政府和关键基础设施的员工。^([1](#chapter5-1))
    在一篇详细的研究论文中，^([2](#chapter5-2)) 我提到，这款恶意软件通常伪装成名为 *Final_Presentation* 的 PowerPoint
    演示文稿，并将自己作为登录项持久化，以确保每次用户登录时它都会自动重新执行。在该恶意软件的应用程序包中，我们可以找到它的主二进制文件，名为 *usrnode*。反编译该文件后，揭示了其主函数开头的持久化逻辑：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the malware determines where on the host it’s running from, it invokes
    the LSSharedFileListCreate and LSSharedFileListInsertItemURL functions to install
    itself as a persistent login item. This login item makes the malware visible in
    the Login Items pane of the System Preferences application ([Figure 5-1](chapter5.xhtml#fig5-1)).
    Apparently, the malware authors considered this an acceptable trade-off for persistence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件确定它在主机上运行的位置，它会调用 LSSharedFileListCreate 和 LSSharedFileListInsertItemURL
    函数，将自己安装为一个持久化的登录项。这个登录项会使恶意软件出现在“系统偏好设置”应用程序的“登录项”面板中（[图5-1](chapter5.xhtml#fig5-1)）。显然，恶意软件的作者认为这是为持久化而做的一个可以接受的妥协。
- en: '![](../images/Figure5-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.jpg)'
- en: 'Figure 5-1: WindTail persists itself as a login item named Final_Presentation.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：WindTail 将自己作为名为 Final_Presentation 的登录项持久化。
- en: Let’s take a look at another persistent macOS malware specimen. Named DazzleSpy,
    this sophisticated nation-state malware leveraged zero-day vulnerabilities to
    remotely infect macOS users.^([3](#chapter5-3)) While DazzleSpy’s infection vector
    posed detection challenges, the malware’s approach to persistence was rather obvious,
    giving defenders a straightforward way to detect it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个其他的持久化 macOS 恶意软件样本。名为 DazzleSpy，这种复杂的国家级恶意软件利用了零日漏洞，远程感染了 macOS 用户。^([3](#chapter5-3))
    尽管 DazzleSpy 的感染途径提出了检测挑战，但其持久化方法却相当明显，为防御者提供了一个简单的检测途径。
- en: 'After gaining initial code execution and escaping the browser sandbox, DazzleSpy
    would persist itself as a launch agent that masqueraded as an Apple software updater.
    To persist as a launch agent, an item usually creates a property list in one of
    the *LaunchAgents* directories. DazzleSpy creates a property list within the current
    user’s *Library/LaunchAgents* directory and names its property list *com.apple.softwareupdate.plist*.
    The malware’s binary hardcodes references to the launch agent directory, as well
    as to the name of the plist, making them readily visible in the output of the
    strings command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得初始代码执行权限并成功逃逸浏览器沙箱后，DazzleSpy 会将自身保持为一个伪装成 Apple 软件更新程序的启动代理。为了作为启动代理保持存在，项目通常会在
    *LaunchAgents* 目录下创建一个属性列表。DazzleSpy 在当前用户的 *Library/LaunchAgents* 目录中创建一个属性列表，并将其命名为
    *com.apple.softwareupdate.plist*。该恶意软件的二进制文件硬编码了对启动代理目录的引用，以及对该 plist 文件名称的引用，使它们在
    `strings` 命令的输出中显而易见：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we load the malware in a decompiler, we find a class method named installDaemon
    that makes use of these strings. As its name implies, the method will persistently
    install the malware (albeit not as a launch daemon, but rather as an agent):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在反编译器中加载恶意软件，我们会发现一个名为 installDaemon 的类方法，它使用了这些字符串。顾名思义，该方法将持久化安装恶意软件（尽管不是作为启动守护进程，而是作为一个代理）：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From this decompilation, we can see that the malware first dynamically builds
    a path to the current user’s *Library/LaunchAgents* directory and then appends
    the string *com.apple.softwareupdate.plist* to it. It then builds a dictionary
    with keys such as RunAtLoad, Label, and ProgramArguments, whose values describe
    how to restart the persisted item, how to identify it, and its path. To complete
    the persistence, the malware writes this dictionary to the property list file
    in the launch agent directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次反编译中，我们可以看到恶意软件首先动态构建一个指向当前用户 *Library/LaunchAgents* 目录的路径，然后将字符串 *com.apple.softwareupdate.plist*
    追加到该路径中。接着，它构建一个包含 RunAtLoad、Label 和 ProgramArguments 等键的字典，这些值描述了如何重新启动持久化项目、如何识别该项目以及它的路径。为了完成持久化，恶意软件将这个字典写入启动代理目录中的属性列表文件。
- en: 'By executing the malware on an isolated analysis machine under the watchful
    eye of a file monitor, we can confirm DazzleSpy’s persistence. As expected, the
    file monitor shows the binary (*softwareupdate*) creating its property list file
    in the current user’s *LaunchAgents* directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在一个隔离的分析机器上执行恶意软件，并在文件监控器的监视下，我们可以确认 DazzleSpy 的持久性。如预期的那样，文件监控器显示该二进制文件 (*softwareupdate*)
    在当前用户的 *LaunchAgents* 目录中创建了其属性列表文件：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, by examining the contents of this newly created file, we can find the
    path to which the malware has persistently installed itself, */Users/User/ .local/softwareupdate*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过检查新创建的文件的内容，我们可以找到恶意软件持久安装的路径，*/Users/User/.local/softwareupdate*：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The malware set the RunAtLoad key to true, so macOS will automatically restart
    the specified binary each time the user logs in. In other words, DazzleSpy has
    attained persistence.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件将 RunAtLoad 键设置为 true，因此每次用户登录时，macOS 都会自动重新启动指定的二进制文件。换句话说，DazzleSpy 已经获得了持久性。
- en: At the start of this chapter, I mentioned that legitimate software also persists.
    How can you determine whether a persisted item is malicious? Arguably the best
    way involves examining the item’s code signing information using the approaches
    described in [Chapter 3](chapter3.xhtml). Legitimate items should be signed by
    readily recognizable companies and notarized by Apple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我提到过合法软件也会保持持久性。那么，如何判断一个持久化的项目是否是恶意的呢？可以说，最好的方法是检查该项目的代码签名信息，使用 [第 3
    章](chapter3.xhtml) 中描述的方法。合法项目应该由公认的公司签名并且通过 Apple 的认证。
- en: Malicious persisted items often have common characteristics too. Consider DazzleSpy,
    which runs from the hidden *.local* directory and isn’t signed or notarized. The
    name of the malware’s property list, *com.apple .softwareupdate*, suggests that
    this persistent item belongs to Apple. However, Apple never installs persistent
    components to users’ *LaunchAgents* directories, and all of its launch items reference
    binaries signed solely by Apple proper. In these respects, DazzleSpy isn’t an
    outlier; most malicious persistent items are equally easy to classify as suspicious
    due to such anomalies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意持久化项目通常也有一些共同的特征。以DazzleSpy为例，它从隐藏的*.local*目录中运行，并且没有签名或经过公证。该恶意软件的属性列表名称*com.apple.softwareupdate*表明这个持久化项目属于Apple。然而，Apple从未将持久化组件安装到用户的*LaunchAgents*目录中，所有的启动项都引用仅由Apple公司签名的二进制文件。在这些方面，DazzleSpy并不是一个特例；由于这些异常，大多数恶意持久化项目也同样容易被归类为可疑。
- en: Background Task Management
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景任务管理
- en: How can we determine whether an item has persisted? A naive approach is to simply
    enumerate all *.plist* files found in the launch item directories, which include
    the system and user *LaunchDaemon* and *LaunchAgent* directories. However, as
    of macOS 13, Apple encourages developers to move their launch items directly into
    their application bundles.^([4](#chapter5-4)) These changes essentially deprecate
    persistence via a user’s launch item directories, meaning that manually enumerating
    persistent items requires scanning every application bundle, which is inefficient.
    Moreover, software can persist as login items, which don’t leverage property lists
    or dedicated directories.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定某个项目是否已持久化？一种简单的方法是枚举所有在启动项目录中找到的*.plist*文件，这些目录包括系统和用户的*LaunchDaemon*和*LaunchAgent*目录。然而，从macOS
    13开始，Apple鼓励开发者将启动项直接移到他们的应用程序包中。^([4](#chapter5-4))这些变化实际上使得通过用户的启动项目录来持久化变得不再推荐，这意味着手动枚举持久化项目需要扫描每个应用程序包，这样做效率低下。此外，软件还可以作为登录项持久化，而这些登录项并不使用属性列表或专用目录。
- en: Luckily, starting with macOS 13, Apple has consolidated the management of the
    most common persistence mechanisms (including launch agents, launch daemons, and
    login items) into a proprietary subsystem named *Background Task Management*.
    This subsystem provides the list of login and launch items that populate the Login
    Items pane in the System Preferences application ([Figure 5-2](chapter5.xhtml#fig5-2)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从macOS 13开始，Apple已将最常见的持久化机制（包括启动代理、启动守护进程和登录项）的管理整合到了一个名为*背景任务管理*的专有子系统中。这个子系统提供了在“系统偏好设置”应用中显示的登录项和启动项的列表（[图5-2](chapter5.xhtml#fig5-2)）。
- en: '![](../images/Figure5-2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.jpg)'
- en: 'Figure 5-2: Login and launch items shown in the System Preferences app'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：在“系统偏好设置”应用中显示的登录项和启动项
- en: On my computer, several of my Objective-See tools install themselves as login
    items, while Adobe’s cloud-syncing app and Google Chrome’s updater install persistent
    launch items.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，我的几个Objective-See工具会将自己安装为登录项，而Adobe的云同步应用程序和Google Chrome的更新程序则会安装为持久启动项。
- en: Of course, we want the ability to obtain this list of persistent items programmatically,
    as any persistent malware will likely show up here as well. Although the components
    of the Background Task Management subsystem are proprietary and closed source,
    dynamic analysis reveals that the subsystem stores detailed metadata about the
    persistent items it tracks in a single database file. For our purposes, the presence
    of this centralized database is a godsend. Unfortunately, as its format is proprietary
    and undocumented, we have a bit of work in front of us if we’d like to use it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望能够以编程方式获取这些持久化项目的列表，因为任何持久化的恶意软件很可能也会出现在这里。尽管背景任务管理子系统的组件是专有和闭源的，但动态分析表明，子系统将其跟踪的持久化项目的详细元数据存储在一个单独的数据库文件中。对于我们的目的来说，这个集中式数据库的存在是个福音。不幸的是，由于其格式是专有且没有文档记录，如果我们希望使用它，还需要做一些工作。
- en: Examining the Subsystem
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查子系统
- en: 'Let’s walk through the Background Task Management subsystem’s interactions
    with this database. Understanding these operations will help us create a tool
    capable of programmatically extracting its contents. Using a file monitor, we
    can see that when an item is persisted, the Background Task Management daemon,
    *backgroundtaskmanagementd*, updates a file in the */private/var/db/com.apple.backgroundtaskmanagement/*
    directory. To perform this operation atomically, it first creates a temporary
    file, then moves it into the *com.apple.backgroundtaskmanagement* directory via
    a rename operation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍 Background Task Management 子系统与此数据库的交互过程。理解这些操作将帮助我们创建一个能够编程提取其内容的工具。通过文件监控，我们可以看到，当一个项被持久化时，Background
    Task Management 守护进程 *backgroundtaskmanagementd* 会更新 */private/var/db/com.apple.backgroundtaskmanagement/*
    目录中的文件。为了原子性地执行此操作，它首先创建一个临时文件，然后通过重命名操作将其移入 *com.apple.backgroundtaskmanagement*
    目录：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we disassemble the daemon’s binary, located in the */System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/Resources/*
    directory, we find references to a format string, BackgroundItems-v%ld.btm, in
    storeNameForDatabaseVersion:, a method of the BTMStore class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们反汇编位于 */System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/Resources/*
    目录中的守护进程的二进制文件，我们会发现 BTMStore 类的 storeNameForDatabaseVersion: 方法中有一个格式字符串引用，BackgroundItems-v%ld.btm：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Further reverse engineering reveals that the name of the database contains
    a version number, which increases as newer versions of macOS are released. In
    the examples shown here, we’ve abstracted this version number with an x, but on
    your system, it’s likely to be 8 or higher. Using the file command, we can see
    that the contents of the *BackgroundItems-vx.btm* file are stored as a binary
    property list. To view these details yourself, be sure to supply the correct version
    number for your system when running the command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的逆向工程揭示，数据库的名称包含一个版本号，随着新版 macOS 的发布，版本号会递增。在这里展示的示例中，我们将版本号抽象为 x，但在你的系统中，版本号可能是
    8 或更高。使用 `file` 命令，我们可以看到 *BackgroundItems-vx.btm* 文件的内容以二进制属性列表的形式存储。要查看这些详细信息，请确保在运行命令时为你的系统提供正确的版本号：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can convert the contents of a binary property into XML using plutil. Unfortunately,
    the resulting XML contains not only spelling mistakes but also serialized objects
    that aren’t readily human readable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 plutil 将二进制属性的内容转换为 XML。不幸的是，结果 XML 不仅包含拼写错误，还包含一些无法轻易被人类读取的序列化对象：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Serialization* is the process of taking an initialized, in-memory object and
    converting it to a format in which it can be saved (for example, to a file). While
    serialization is an efficient way for programs to interact with objects, serialized
    objects aren’t generally human readable. Moreover, if the objects are of an undocumented
    class, we must first understand the internal details of the class before we can
    write code that makes sense of them.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化* 是将一个已初始化的内存中的对象转换为可以保存的格式（例如，保存到文件）的过程。虽然序列化是程序与对象交互的高效方式，但序列化对象通常不可被人类读取。此外，如果对象属于一个未记录的类，我们必须首先理解该类的内部细节，才能编写代码以理解它们。'
- en: 'As part of the Background Task Management subsystem, Apple ships a command
    line utility named sfltool that can interact with *BackgroundItems-vx .btm* files.
    If executed with the dumpbtm flag, the tool will deserialize and print out the
    file’s contents:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Background Task Management 子系统的一部分，Apple 提供了一个名为 sfltool 的命令行工具，它可以与 *BackgroundItems-vx
    .btm* 文件进行交互。如果使用 dumpbtm 标志执行该工具，它将反序列化并打印出文件的内容：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the deserialized objects include DazzleSpy (*softwareupdate*)
    and Wireshark’s *ChmodBPF* daemon. As sfltool can produce deserialized output
    from the proprietary database, reverse engineering it should help us understand
    its deserialization and parsing logic. This, in turn, should enable us to write
    our own parser capable of enumerating all persistent items managed by the Background
    Task Management subsystem, including any malware.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，反序列化后的对象包括 DazzleSpy (*softwareupdate*) 和 Wireshark 的 *ChmodBPF* 守护进程。由于
    sfltool 能够从专有数据库生成反序列化输出，逆向工程它应该有助于我们理解其反序列化和解析逻辑。反过来，这应该能使我们编写出能够枚举 Background
    Task Management 子系统管理的所有持久化项（包括任何恶意软件）的解析器。
- en: Dissecting sfltool
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解剖 sfltool
- en: 'While the focus of this book is not on reverse engineering, I’ll briefly discuss
    how to dissect sfltool so you can understand its interactions with other Background
    Task Management components and the ever-so-important *.btm* file. In a terminal,
    let’s begin by streaming messages from the system log while running sfltool with
    the dumpbtm flag:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的重点不在于反向工程，但我将简要讨论如何剖析 sfltool，以便你理解它与其他后台任务管理组件及极其重要的 *.btm* 文件的交互。在终端中，让我们通过运行带有
    dumpbtm 标志的 sfltool 来开始流式读取系统日志消息：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the log output (which I’ve slightly modified for brevity),
    the Background Task Management daemon has received a message from a process with
    an ID of 52886 corresponding to the running instance of sfltool. You can see that
    the tool has made an XPC connection to the daemon. If the connection succeeds,
    sfltool can then invoke remote methods found within the daemon. For example, from
    the log messages, you see that it invoked the daemon’s dumpDatabaseWithAuthorization:
    method to get the contents of the Background Task Management database.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你在日志输出中看到的（我稍作修改以便简洁），后台任务管理守护进程收到了来自进程 ID 为 52886 的消息，该进程对应于正在运行的 sfltool
    实例。你可以看到该工具已成功建立了 XPC 连接。如果连接成功，sfltool 就可以调用守护进程中的远程方法。例如，从日志消息中，你可以看到它调用了守护进程的
    dumpDatabaseWithAuthorization: 方法来获取后台任务管理数据库的内容。'
- en: In [Listing 5-1](chapter5.xhtml#Lis5-1), we try to implement this same approach.
    We leverage the private BackgroundTaskManagement framework, which implements necessary
    classes, such as BTMManager, and methods including the client-side dumpDatabaseWithAuthorization:error:.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在[列表 5-1](chapter5.xhtml#Lis5-1)中，我们尝试实现相同的方法。我们利用了私有的 BackgroundTaskManagement
    框架，该框架实现了必要的类，如 BTMManager，以及包括客户端方法 dumpDatabaseWithAuthorization:error: 在内的函数。'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-1: Attempting to dump the Background Task Management database'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-1：尝试转储后台任务管理数据库
- en: 'Unfortunately, this approach fails. As shown in the following log messages,
    the failure appears to be due to the fact that our binary (which, in this instance,
    has a process ID of 20987) doesn’t possess a private Apple entitlement needed
    to connect to the Background Task Management daemon:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法失败了。正如以下日志信息所示，失败似乎是因为我们的二进制文件（在此实例中，其进程 ID 为 20987）没有连接到后台任务管理守护进程所需的私人
    Apple 权限：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can confirm that this is why we can’t connect to the daemon by reverse engineering
    the code in the daemon responsible for handling new XPC connections from clients:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过反向工程守护进程中负责处理来自客户端的新 XPC 连接的代码来确认，正是这个原因导致我们无法连接到守护进程：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this disassembly, you can see the check for the private entitlement *com.apple.private.coreservices.canmanagebackgroundtasks*,
    which matches the one we saw in the logs. If the client doesn’t hold it (or the
    newer *com.apple .private.backgroundtaskmanagement.manage* entitlement), the system
    will deny the connection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个反汇编中，你可以看到对私人权限 *com.apple.private.coreservices.canmanagebackgroundtasks*
    的检查，这与我们在日志中看到的匹配。如果客户端没有该权限（或更新后的 *com.apple.private.backgroundtaskmanagement.manage*
    权限），系统将拒绝连接。
- en: 'Using the codesign utility, you can see that sfltool indeed contains the necessary
    entitlement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 codesign 工具，你可以看到 sfltool 确实包含了所需的权限：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since we can’t obtain the private Apple entitlement needed to connect to the
    Background Task Management daemon for our own program, we’re left having to access
    and parse the database directly from disk.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法获取到连接到后台任务管理守护进程所需的私人 Apple 权限，我们只能直接从磁盘访问并解析数据库。
- en: 'When given full disk access, it’s easy to access the database’s contents. However,
    parsing its contents requires a bit more work, as it contains undocumented serialized
    objects. Luckily, continued reverse engineering reveals that once the daemon has
    read the contents of the database, its deserialization logic starts in a method
    named _decodeRootData:error:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '当获得完全磁盘访问权限时，访问数据库内容是很容易的。然而，解析其内容需要更多的工作，因为它包含了未记录的序列化对象。幸运的是，继续反向工程可以揭示，当守护进程读取数据库内容后，它的反序列化逻辑会在一个名为
    _decodeRootData:error: 的方法中开始。'
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the Background Task Management daemon reads the contents of the database,
    it performs deserialization by following these standard steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当后台任务管理守护进程读取数据库内容时，它会按照以下标准步骤执行反序列化操作：
- en: 1.  Reading the contents of the database into memory as an NSData object
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将数据库内容作为 NSData 对象读入内存
- en: 2.  Initializing an NSKeyedUnarchiver object with this data
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用这些数据初始化一个 NSKeyedUnarchiver 对象
- en: '3.  Deserializing the objects in the unarchiver via a call to the NSKeyedUnarchiver
    decodeObjectOfClass:forKey: method'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过调用 NSKeyedUnarchiver 的 `decodeObjectOfClass:forKey:` 方法反序列化解档器中的对象
- en: 'Take note of the serialized class name, Storage, and its key in the archiver,
    store, as these will come into play shortly. Also note that when the decodeObjectOfClass:forKey:
    method is invoked, the initWithCoder: method of any embedded object is also automatically
    invoked behind the scenes. This allows objects to perform their own deserialization.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意序列化类名 `Storage` 及其在归档器中的键 `store`，因为它们稍后会发挥作用。还要注意，当调用 `decodeObjectOfClass:forKey:`
    方法时，任何嵌入对象的 `initWithCoder:` 方法也会自动在后台调用。这允许对象执行自己的反序列化操作。
- en: Writing a Background Task Management Database Parser
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写后台任务管理数据库解析器
- en: We’re now ready to write our own parser. Let’s take what we’ve learned through
    reverse engineering and write a tool capable of deserializing the metadata of
    all persistent items found in the Background Task Management database. I’ll walk
    through the relevant code snippets here, but you can find the entire code for
    this parser, dubbed *DumpBTM*, in Objective-See’s GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM).
    At the end of this discussion, I’ll show how you can make use of this library
    in your own code to programmatically obtain a list of items persisting on any
    macOS system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写自己的解析器。让我们将通过逆向工程学到的知识应用到编写一个能够反序列化后台任务管理数据库中所有持久化项元数据的工具。我将在这里展示相关的代码片段，但你可以在
    Objective-See 的 GitHub 仓库中找到这个解析器的完整代码，名为 *DumpBTM*，地址是 [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)。在这次讨论的最后，我将展示如何在你的代码中使用这个库，以编程方式获取任何
    macOS 系统上持久化项的列表。
- en: Finding the Database Path
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找数据库路径
- en: Let’s begin by writing some code that dynamically finds the path of the database.
    Although it’s located in the */private/var/db/com.apple.backgroundtaskmanagement/*
    directory, Apple occasionally bumps up the version number in the name across releases
    of macOS. Even with these name changes, though, finding the database is easy enough
    through its unique extension, *.btm*. The code in [Listing 5-2](chapter5.xhtml#Lis5-2)
    uses a simple predicate to find all *.btm* files in the *com.apple.backgroundtaskmanagement*
    directory. There should only be one, but to be safe, the code grabs the one with
    the highest version.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先编写一些代码来动态查找数据库的路径。虽然它位于 `*/private/var/db/com.apple.backgroundtaskmanagement/*`
    目录中，但 Apple 会在 macOS 版本发布时偶尔修改名称中的版本号。尽管如此，通过其独特的扩展名 `*.btm*`，仍然可以轻松找到该数据库。[列表
    5-2](chapter5.xhtml#Lis5-2) 中的代码使用一个简单的谓词来查找 *com.apple.backgroundtaskmanagement*
    目录中的所有 `*.btm*` 文件。应该只有一个文件，但为了安全起见，代码会选择版本号最高的那个。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-2: Finding the most recent Background Task Management database'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-2：查找最新的后台任务管理数据库
- en: First, the code creates a list of all files in the directory ❶. Then, via the
    predicate self.absoluteString ENDSWITH '.btm' and the method filteredArrayUsingPredicate:,
    it creates a second list containing solely *.btm* files ❷. It then returns the
    last file in this list, which should be the one with the highest version ❸.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码会创建一个目录中所有文件的列表 ❶。然后，通过谓词 `self.absoluteString ENDSWITH '.btm'` 和方法 `filteredArrayUsingPredicate:`，它创建第二个列表，其中仅包含
    `*.btm*` 文件 ❷。接着，它返回这个列表中的最后一个文件，这个文件应该是版本号最高的那个 ❸。
- en: Deserializing Background Task Management Files
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反序列化后台任务管理文件
- en: I noted that the serialized objects in the Background Task Management file are
    instances of undocumented classes specific to the subsystem. To deserialize them,
    we must, at a minimum, provide a class declaration. We found these classes embedded
    in the daemon, including the top-level object in the serialized database that
    belongs to an undocumented class named Storage. Recall that we also saw this class
    name in the plutil output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到后台任务管理文件中的序列化对象是特定于子系统的未文档化类的实例。为了反序列化这些对象，我们至少需要提供一个类声明。我们发现这些类嵌入在守护进程中，包括序列化数据库中的顶级对象，它属于一个名为
    `Storage` 的未文档化类。回想一下，我们也在 `plutil` 输出中看到了这个类名。
- en: This class contains various instance variables that describe its properties,
    including a dictionary called itemsByUserIdentifier. To deserialize the Storage
    object, we create the declaration shown in [Listing 5-3](chapter5.xhtml#Lis5-3).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含描述其属性的各种实例变量，包括一个名为 `itemsByUserIdentifier` 的字典。为了反序列化 `Storage` 对象，我们创建了
    [列表 5-3](chapter5.xhtml#Lis5-3) 中所示的声明。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-3: The Storage class interface'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-3：`Storage` 类接口
- en: Further reverse engineering reveals more details about the Storage class’s itemsByUserIdentifier
    dictionary. For example, it contains key-value pairs whose values are of another
    undocumented Background Task Management class named ItemRecord. The ItemRecord
    class contains metadata about each persistent item managed by the subsystem, such
    as its path, its code signing information, and its state (for example, enabled
    or disabled).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的逆向工程揭示了 Storage 类的 itemsByUserIdentifier 字典的更多细节。例如，它包含了键值对，其中值是另一个未文档化的背景任务管理类——ItemRecord。ItemRecord
    类包含了有关子系统管理的每个持久项的元数据，如其路径、代码签名信息以及其状态（例如启用或禁用）。
- en: Again, as ItemRecord is an undocumented class, making use of it in our code
    requires providing a declaration extracted from the daemon. [Listing 5-4](chapter5.xhtml#Lis5-4)
    shows such a declaration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于 ItemRecord 是一个未文档化的类，因此在我们的代码中使用它需要提供从守护进程中提取的声明。[第 5-4 列表](chapter5.xhtml#Lis5-4)
    显示了这样的声明。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-4: The ItemRecord class interface'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5-4 列表：ItemRecord 类接口
- en: 'With the relevant classes declared, we’re almost ready to trigger the serialization
    of all objects in the Background Task Management file. However, as the deserialization
    process invokes each object’s initWithCoder: method, and each object conforms
    to the NSSecureCoding protocol, we should provide an implementation of this method
    to keep the linker happy and ensure that deserialization succeeds. To reimplement
    the initWithCoder: methods for the undocumented objects, we can use a disassembler
    to find their implementations. For example, here is the decompilation of the ItemRecord
    object’s initWithCoder: method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '在声明了相关的类之后，我们几乎准备好触发背景任务管理文件中所有对象的序列化过程。然而，由于反序列化过程会调用每个对象的 initWithCoder:
    方法，并且每个对象都遵循 NSSecureCoding 协议，我们应该提供该方法的实现，以保持链接器正常工作并确保反序列化成功。为了重新实现那些未文档化对象的
    initWithCoder: 方法，我们可以使用反汇编器找到它们的实现。例如，这是 ItemRecord 对象的 initWithCoder: 方法的反编译结果：'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can easily mimic the method in our own code ([Listing 5-5](chapter5.xhtml#Lis5-5)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地在自己的代码中模仿该方法（[第 5-5 列表](chapter5.xhtml#Lis5-5)）。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 5-5: A reimplementation of the ItemRecord initWithCoder: method'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '第 5-5 列表：ItemRecord 的 initWithCoder: 方法的重新实现'
- en: 'In our reimplementation of the ItemRecord object’s initWithCoder: method, we
    deserialize the properties of the object, including its UUID, executable path,
    team identifier, and more. This is as easy as invoking the decodeObjectOfClass:forKey:
    method for each property on the serialized object that is passed in as an NSCoder.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们重新实现 ItemRecord 对象的 initWithCoder: 方法时，我们会反序列化该对象的属性，包括其 UUID、可执行路径、团队标识符等。这和调用
    decodeObjectOfClass:forKey: 方法来处理传入的序列化对象中的每个属性一样简单，该对象作为一个 NSCoder 被传入。'
- en: 'However, there is a simpler way to access these methods. As you saw in the
    disassembly, the Background Task Management daemon contains class implementations
    of serialized Storage and ItemRecord objects, including their initWithCoder: methods.
    Thus, if we load and link the daemon binary into our process’s address space,
    we’ll have access to those methods without needing to reimplement them ourselves.
    As all executables are now compiled in a position-independent manner, we can link
    to anything we’d like in our own program, including the daemon. [Listing 5-6](chapter5.xhtml#Lis5-6)
    contains the code to load and link the daemon, then makes use of its objects when
    triggering the full deserialization of the objects stored in the database.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，有一种更简单的方法可以访问这些方法。正如你在反汇编中看到的，背景任务管理守护进程包含了序列化的 Storage 和 ItemRecord 对象的类实现，包括它们的
    initWithCoder: 方法。因此，如果我们将守护进程的二进制文件加载并链接到我们的进程地址空间中，我们就能访问这些方法，而无需自己重新实现它们。由于所有可执行文件现在都是以位置无关的方式编译的，我们可以在自己的程序中链接任何我们想要的内容，包括守护进程。[第
    5-6 列表](chapter5.xhtml#Lis5-6) 包含了加载和链接守护进程的代码，接着在触发完整反序列化数据库中存储的对象时使用了它的对象。'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-6: Deserializing Background Task Management objects'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5-6 列表：反序列化背景任务管理对象
- en: After invoking the dlopen function ❶, which loads and links the Background Task
    Management daemon into a process’s memory space, the code invokes a helper function
    we’ve written to get the path of the system’s Background Task Management database
    file ❷. Once it has found and loaded the contents of the database into memory
    ❸, the code initializes a keyed unarchiver object with the database data ❹.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 dlopen 函数 ❶ 后，该函数加载并将背景任务管理守护进程链接到进程的内存空间，接着代码调用我们编写的一个辅助函数来获取系统背景任务管理数据库文件的路径
    ❷。一旦找到并加载数据库的内容到内存中 ❸，代码就会用数据库数据初始化一个带键的反归档对象 ❹。
- en: 'Now the code is ready to trigger the deserialization of the objects in the
    database via the keyed archiver’s decodeObjectOfClass:forKey: method. Previously,
    I noted that the class of the database’s top-level object is named Storage. As
    it’s undocumented, we dynamically resolve it via NSClassFromString(@"Storage").
    This resolution succeeds because we’ve loaded the daemon that implements this
    class into our process space. For the key required to begin the deserialization,
    we mimic the daemon by specifying the string "store" ❺.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码已准备好通过键归档器的decodeObjectOfClass:forKey:方法触发数据库中对象的反序列化。如前所述，数据库顶级对象的类名是Storage。由于它没有文档，我们通过NSClassFromString(@"Storage")动态解析它。解析成功，因为我们已经将实现此类的守护进程加载到我们的进程空间中。为了开始反序列化所需的键，我们模仿守护进程，指定字符串"store"❺。
- en: 'Behind the scenes, this code will trigger an invocation of the Storage class’s
    initWithCoder: method, giving it a chance to deserialize the top-level Storage
    object in the database. Recall that this object includes a dictionary containing
    an ItemRecord object describing each persisted item. An invocation to the ItemRecord
    class’s initWithCoder: method will automatically deserialize these embedded objects.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这段代码将触发调用Storage类的initWithCoder:方法，从而有机会反序列化数据库中的顶级Storage对象。回想一下，这个对象包含一个字典，其中包含一个ItemRecord对象，描述每个持久化的项目。调用ItemRecord类的initWithCoder:方法将自动反序列化这些嵌套的对象。
- en: Accessing Metadata
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问元数据
- en: Once we’ve completed the deserialization, we can access the metadata about each
    item persisted on the system and managed by Background Task Management ([Listing
    5-7](chapter5.xhtml#Lis5-7)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了反序列化，就可以访问系统上每个持久化项目的元数据，并由后台任务管理（[列表5-7](chapter5.xhtml#Lis5-7)）进行管理。
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-7: Printing deserialized items'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-7：打印反序列化的项目
- en: 'Accessing the metadata is as simple as iterating over the deserialized Storage
    object’s itemsByUserIdentifier dictionary ❶, which organizes the persistent items
    by user UUID ❷. For all ItemRecord objects, we can invoke the class’s dumpVerboseDescription
    method ❸ to print out each object in a nicely formatted manner. Because we didn’t
    declare this method in the class interface, we instead use the Objective-C performSelector:
    method to invoke it by name.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元数据就像遍历反序列化的Storage对象的itemsByUserIdentifier字典❶一样简单，该字典按用户UUID❷组织持久化项。对于所有的ItemRecord对象，我们可以调用该类的dumpVerboseDescription方法❸，以优雅的格式打印出每个对象。因为我们没有在类接口中声明此方法，所以我们使用Objective-C的performSelector:方法按名称调用它。
- en: 'Compiling and running the code produces output that provides the same information
    as Apple’s closed source sfltool:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码会生成输出，提供与Apple的闭源sfltool相同的信息：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because most macOS malware persists, this ability to programmatically enumerate
    persistently installed items is incredibly important. However, these enumerations
    will also include legitimate items, such as Wireshark’s *ChmodBPF* demon, as shown
    here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数macOS恶意软件是持久化的，因此能够通过编程方式枚举持久安装的项目是非常重要的。然而，这些枚举还会包括合法项，例如Wireshark的*ChmodBPF*守护进程，如这里所示。
- en: Identifying Malicious Items
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别恶意项
- en: 'Of course, when attempting to programmatically detect malware, just printing
    out the persistent items isn’t all that helpful. As you just saw, the Background
    Task Management database includes metadata about persistently installed items
    that are benign, so the code must closely examine each. For example, the first
    item shown in the tool’s output is likely suspicious; its name suggests that it’s
    a core Apple component, but it’s running from a hidden directory and is unsigned.
    (Spoiler alert: it’s DazzleSpy.) On the other hand, the second item’s code signing
    information, including its developer name and team ID, identifies it as a legitimate
    component of the network monitoring and analysis tool Wireshark.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在尝试通过编程方式检测恶意软件时，单纯打印出持久化的项目并不是特别有帮助。如你刚刚看到的，后台任务管理数据库包括关于持久安装项目的元数据，这些项目可能是良性的，因此代码必须仔细检查每个项目。例如，工具输出中的第一个项目可能是可疑的；它的名字表明它是一个核心Apple组件，但它是从一个隐藏目录运行并且没有签名。（剧透：它是DazzleSpy。）另一方面，第二个项目的代码签名信息，包括其开发者名称和团队ID，将其识别为网络监控和分析工具Wireshark的合法组件。
- en: To programmatically extract information from each item, you can directly access
    relevant properties of the ItemRecord object. For example, [Listing 5-8](chapter5.xhtml#Lis5-8)
    updates the code we wrote in [Listing 5-7](chapter5.xhtml#Lis5-7) to access the
    path to each item’s property list, its name, and its executable path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式提取每个项的信息，你可以直接访问 ItemRecord 对象的相关属性。例如，[列表 5-8](chapter5.xhtml#Lis5-8)
    更新了我们在 [列表 5-7](chapter5.xhtml#Lis5-7) 中编写的代码，来访问每个项的属性列表路径、名称和可执行路径。
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-8: Accessing ItemRecord properties'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：访问 ItemRecord 属性
- en: I’ve excerpted the code presented here from the *DumpBTM* project, a complete
    Background Task Management parser. Compiled into a library for easy linking into
    other projects, *DumpBTM* also allows us to extract the metadata of each persistent
    item into a dictionary to cleanly abstract away the internals of the undocumented
    Background Task Management objects ([Listing 5-9](chapter5.xhtml#Lis5-9)). Other
    code can then ingest this dictionary, for example, to examine each item for anomalies
    or apply heuristics to classify them as benign or potentially malicious.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 *DumpBTM* 项目中摘录了这里展示的代码，*DumpBTM* 是一个完整的后台任务管理解析器，已编译成一个库，便于链接到其他项目中。*DumpBTM*
    还允许我们将每个持久性项的元数据提取到一个字典中，以便清晰地抽象掉未公开的后台任务管理对象的内部结构（[列表 5-9](chapter5.xhtml#Lis5-9)）。其他代码可以读取这个字典，例如，检查每个项是否存在异常，或者应用启发式算法将它们分类为良性或可能是恶意的。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-9: Extracting properties into a dictionary'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-9：将属性提取到字典中
- en: To extract an ItemRecord object’s properties, we simply create a dictionary
    and add each property to it with a key of our choosing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取 ItemRecord 对象的属性，我们只需创建一个字典，并将每个属性添加到字典中，键可以是我们选择的任何值。
- en: In the *DumpBTM* library, an exported function named parseBTM invokes the toDictionary
    function shown here. I’ll end this chapter by showing how your code could make
    use of the library by invoking parseBTM to obtain a dictionary containing metadata
    of all the persistent items stored in the Background Task Management database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *DumpBTM* 库中，一个名为 parseBTM 的导出函数调用了这里展示的 toDictionary 函数。我将在本章结束时展示如何通过调用
    parseBTM 来使用这个库，获取包含所有持久性项元数据的字典，这些元数据存储在后台任务管理数据库中。
- en: Using DumpBTM in Your Own Code
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你自己的代码中使用 DumpBTM
- en: 'When you compile *DumpBTM*, you’ll find two files in its *library/lib* directory:
    the library’s header file (*dumpBTM.h*) and the compiled library *libDumpBTM.a*.
    Add both files to your project. Include the header file in your source code using
    either an #include or an #import directive, as this file contains the library’s
    exported function definitions and constants. If you link in the compiled library
    at compile time, your code should be able to invoke the library’s exported functions
    ([Listing 5-10](chapter5.xhtml#Lis5-10)).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '当你编译 *DumpBTM* 时，你会在其 *library/lib* 目录下找到两个文件：库的头文件（*dumpBTM.h*）和已编译的库 *libDumpBTM.a*。将这两个文件添加到你的项目中。通过
    #include 或 #import 指令在源代码中包含头文件，因为这个文件包含了库的导出函数定义和常量。如果你在编译时链接已编译的库，那么你的代码应该能够调用库的导出函数（[列表
    5-10](chapter5.xhtml#Lis5-10)）。'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 5-10: Enumerating persistent items'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-10：枚举持久性项
- en: After importing the library’s header file ❶, we invoke its exported parseBTM
    function ❷. This function returns a dictionary containing all persistent items
    managed by the Background Task Management subsystem and stored in its database,
    keyed by unique user identifiers. You can see that the code iterates over each
    user identifier, then over each persistent item ❸.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 导入库的头文件 ❶ 后，我们调用其导出的 parseBTM 函数 ❷。这个函数返回一个字典，包含由后台任务管理子系统管理并存储在其数据库中的所有持久性项，键值为唯一的用户标识符。你可以看到代码如何迭代每个用户标识符，然后遍历每个持久性项
    ❸。
- en: Conclusion
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: The ability to identify persistently installed items is crucial to detecting
    malware. In this chapter, you learned how to programmatically interact with macOS’s
    Background Task Management database, which contains the metadata of all persistent
    launch and login items. Though this process required a brief foray into the internals
    of the Background Task Management subsystem, we were able to build a complete
    parser capable of fully deserializing all objects in the database, providing us
    with a list of persistently installed items.^([5](#chapter5-5))
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 识别持久性安装项的能力对于检测恶意软件至关重要。在本章中，你学习了如何以编程方式与 macOS 的后台任务管理数据库进行交互，该数据库包含所有持久性启动项和登录项的元数据。虽然这个过程涉及了对后台任务管理子系统内部的一些简要探讨，但我们能够构建一个完整的解析器，能够完全反序列化数据库中的所有对象，从而为我们提供持久性安装项的列表。^([5](#chapter5-5))
- en: Note, however, that some malware leverages more creative persistence mechanisms
    that the Background Task Management subsystem doesn’t track, and we won’t find
    this malware in the subsystem’s database. Not to worry; in [Chapter 10](chapter10.xhtml),
    we’ll dive into KnockKnock, a tool that uses approaches beyond Background Task
    Management to comprehensively uncover persistent malware found anywhere on the
    operating system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，某些恶意软件利用了更加创意性的持久性机制，这些机制不会被后台任务管理子系统追踪，因此我们无法在该子系统的数据库中找到这些恶意软件。请不用担心；在[第10章](chapter10.xhtml)中，我们将深入探讨KnockKnock，这是一种超越后台任务管理的方法，能够全面揭示操作系统中任何地方存在的持久性恶意软件。
- en: This chapter wraps up [Part I](part1.xhtml) and the discussion of data collection.
    You’re now ready to explore the world of real-time monitoring, which can build
    the foundations of a proactive detection approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了[第一部分](part1.xhtml)及数据收集的讨论。现在你已经准备好探索实时监控的世界，它可以为主动检测方法奠定基础。
- en: Notes
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter5_1).  Thomas Brewster, “Hackers Are Exposing an Apple Mac Weakness
    in Middle East Espionage,” Forbes, August 30, 2018, [*https://<wbr>www<wbr>.forbes<wbr>.com<wbr>/sites<wbr>/thomasbrewster<wbr>/2018<wbr>/08<wbr>/30<wbr>/apple<wbr>-mac<wbr>-loophole<wbr>-breached<wbr>-in<wbr>-middle<wbr>-east<wbr>-hacks<wbr>/#4b6706016fd6*](https://www.forbes.com/sites/thomasbrewster/2018/08/30/apple-mac-loophole-breached-in-middle-east-hacks/#4b6706016fd6).'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter5_1).  托马斯·布鲁斯特，"黑客正在揭露中东间谍活动中的苹果Mac弱点"，《福布斯》，2018年8月30日，[*https://<wbr>www<wbr>.forbes<wbr>.com<wbr>/sites<wbr>/thomasbrewster<wbr>/2018<wbr>/08<wbr>/30<wbr>/apple<wbr>-mac<wbr>-loophole<wbr>-breached<wbr>-in<wbr>-middle<wbr>-east<wbr>-hacks<wbr>/#4b6706016fd6*](https://www.forbes.com/sites/thomasbrewster/2018/08/30/apple-mac-loophole-breached-in-middle-east-hacks/#4b6706016fd6).'
- en: '[  2](#chapter5_2).  Patrick Wardle, “Cyber Espionage in the Middle East: Unravelling
    OSX.WindTail,” VirusBulletin, October 3, 2019, [*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/magazine<wbr>/2019<wbr>/VB2019<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/magazine/2019/VB2019-Wardle.pdf).'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter5_2).  帕特里克·沃德尔，"中东的网络间谍活动：解开OSX.WindTail的真相"，《病毒公告》，2019年10月3日，[*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/magazine<wbr>/2019<wbr>/VB2019<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/magazine/2019/VB2019-Wardle.pdf).'
- en: '[  3](#chapter5_3).  Marc-Etienne M. Léveillé and Anton Cherepanov, “Watering
    Hole Deploys New macOS Malware, DazzleSpy, in Asia,” We Live Security, January
    25, 2022, [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/01<wbr>/25<wbr>/watering<wbr>-hole<wbr>-deploys<wbr>-new<wbr>-macos<wbr>-malware<wbr>-dazzlespy<wbr>-asia<wbr>/*](https://www.welivesecurity.com/2022/01/25/watering-hole-deploys-new-macos-malware-dazzlespy-asia/).'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter5_3).  马克-埃蒂安·M·莱维耶和安东·切列潘诺夫，"水坑攻击在亚洲部署了新的macOS恶意软件DazzleSpy"，《We
    Live Security》，2022年1月25日，[*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2022<wbr>/01<wbr>/25<wbr>/watering<wbr>-hole<wbr>-deploys<wbr>-new<wbr>-macos<wbr>-malware<wbr>-dazzlespy<wbr>-asia<wbr>/*](https://www.welivesecurity.com/2022/01/25/watering-hole-deploys-new-macos-malware-dazzlespy-asia/).'
- en: '[  4](#chapter5_4).  “Updating Helper Executables from Earlier Versions of
    macOS,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/servicemanagement<wbr>/updating<wbr>_helper<wbr>_executables<wbr>_from<wbr>_earlier<wbr>_versions<wbr>_of<wbr>_macos*](https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter5_4).  “更新来自早期版本macOS的辅助执行文件”，苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/servicemanagement<wbr>/updating<wbr>_helper<wbr>_executables<wbr>_from<wbr>_earlier<wbr>_versions<wbr>_of<wbr>_macos*](https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos).'
- en: '[  5](#chapter5_5).  If you’re interested in learning more about the internals
    of the Background Task Management subsystem, including how to reverse engineer
    it to understand its components, see my 2023 DEF CON talk, “Demystifying (& Bypassing)
    macOS’s Background Task Management,” [*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/demystifying<wbr>-and<wbr>-bypassing<wbr>-macoss<wbr>-background<wbr>-task<wbr>-management*](https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management).'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter5_5).  如果你有兴趣了解更多关于后台任务管理子系统的内部结构，包括如何逆向工程以理解其组件，可以参阅我在2023年DEF
    CON大会上的演讲：“揭秘（与绕过）macOS的后台任务管理”，[*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/demystifying<wbr>-and<wbr>-bypassing<wbr>-macoss<wbr>-background<wbr>-task<wbr>-management*](https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management).'
