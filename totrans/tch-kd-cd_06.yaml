- en: 'Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 随机的乐趣与游戏：大胆尝试，挑战一下！
- en: In [Chapter 5](ch05.html "Chapter 5. Conditions (What If?)"), we programmed
    the computer to make decisions based on conditions. In this chapter, we’ll program
    the computer to pick a number between 1 and 10, to play Rock-Paper-Scissors, and
    even to roll dice or pick a card!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章 条件（如果？）")中，我们编写了程序让计算机根据条件做出决策。在这一章中，我们将编程让计算机在1到10之间选择一个数字，进行石头剪刀布游戏，甚至掷骰子或抽牌！
- en: The common element in these games is the idea of *randomness*. We want the computer
    to pick a number at random between 1 and 10, and we guess what that number is.
    We want the computer to randomly pick rock, paper, or scissors, and then we choose
    what to play and see who wins. These examples—plus dice games, card games, and
    so on—are called *games of chance*. When we roll five dice to play Yahtzee, we
    usually get a different result every time we roll. That element of chance is what
    makes these games fun.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些游戏的共同元素是*随机性*的概念。我们希望计算机在1到10之间随机选择一个数字，我们猜测那个数字是什么。我们希望计算机随机选择石头、剪刀或布，然后我们选择出招并看看谁赢了。这些例子——加上骰子游戏、纸牌游戏等等——都叫做*机会游戏*。当我们掷五个骰子来玩Yahtzee时，我们通常每次掷出的结果都会不同。正是这种随机性让这些游戏充满乐趣。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188917.png.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2188917.png.jpg)'
- en: We can program the computer to behave randomly. Python has a module called `random`
    that allows us to simulate random choices. We can use the `random` module to draw
    random shapes on the screen and program games of chance. Let’s start with a guessing
    game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编程让计算机执行随机行为。Python有一个叫做`random`的模块，允许我们模拟随机选择。我们可以使用`random`模块在屏幕上绘制随机形状，也可以编程制作机会游戏。让我们从一个猜数字游戏开始。
- en: A Guessing Game
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个猜数字游戏
- en: We can use random numbers in the classic Hi-Lo guessing game. One player picks
    a number between 1 and 10 (or 1 and 100), and the other tries to guess the number.
    If the guess is too high, the guesser tries a lower number. If they guessed too
    low, they try a higher number. When they guess the right number, they win!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在经典的Hi-Lo猜数字游戏中使用随机数字。一个玩家选择一个1到10之间（或1到100之间）的数字，另一个玩家尝试猜测这个数字。如果猜测太高，猜测者就尝试一个更小的数字。如果猜测太低，他们会尝试一个更大的数字。当他们猜对时，他们就赢了！
- en: We already know how to compare numbers with the `if` statement, and we know
    how to keep guessing using `input()` and a `while` loop. The only new skill we
    need to learn is how to generate a random number. We can do this with the `random`
    module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用`if`语句比较数字，也知道如何通过`input()`和`while`循环来保持猜测。我们唯一需要学习的新技能是如何生成一个随机数字。我们可以通过`random`模块来实现这一点。
- en: 'First, we have to import the `random` module with the command `import random`.
    You can try this in the Python shell by typing **`import random`** and pressing
    ENTER. The module has a few different functions for generating a random number.
    We’ll use `randint()`, short for *random integer*. The `randint()` function expects
    us to give it two arguments—that is, two pieces of information—between its parentheses:
    the lowest and highest numbers we want. Specifying a lowest number and a highest
    number in the parentheses will tell `randint()` what range to choose randomly
    from. Type the following in IDLE:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用命令`import random`导入`random`模块。你可以在Python Shell中输入**`import random`**并按下ENTER键来试试。这个模块有几个不同的函数来生成随机数字。我们将使用`randint()`，它是*随机整数*的缩写。`randint()`函数期望我们在它的括号内提供两个参数——也就是两个信息——：我们想要的最低值和最高值。指定括号中的最低值和最高值将告诉`randint()`从什么范围中随机选择。请在IDLE中输入以下内容：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python will respond with a random number between 1 and 10, *inclusive* (which
    means the random number can include 1 and 10). Try the `random.randint(1, 10)`
    command a few times and see the different numbers you get back. (Tip: you can
    use ALT-P, or CONTROL-P on a Mac, to repeat the most recently entered line without
    having to type it all again.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python将返回一个介于1到10之间的随机数字，*包括*（这意味着随机数字可以是1和10）。尝试运行`random.randint(1, 10)`命令几次，看看返回的不同数字。（提示：你可以使用ALT-P，或在Mac上使用CONTROL-P，重复最近输入的行，而无需重新输入整个命令。）
- en: If you run that line enough (at least 10 times), you’ll notice that numbers
    sometimes repeat, but there’s no pattern in the numbers as far as you can tell.
    We call these [*pseudorandom*](apd.html#gloss01_040) numbers because they’re not
    *actually* random (the `randint` command tells the computer what number to “pick”
    next based on a complex mathematical pattern), but they *seem* random.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行那行代码足够多次（至少10次），你会注意到数字有时会重复，但从你所见，它们没有任何规律。我们称这些为[*伪随机*](apd.html#gloss01_040)数，因为它们并不是*真正*随机的（`randint`命令基于复杂的数学模式告诉计算机接下来应该“选择”哪个数字），但它们*看起来*是随机的。
- en: 'Let’s put the `random` module to work in a program called *GuessingGame.py*.
    Type the following in a new IDLE window or download the program from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为*GuessingGame.py*的程序中使用`random`模块。请在新的IDLE窗口中键入以下内容，或者从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载该程序：
- en: GuessingGame.py
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GuessingGame.py
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At ➊, we import the `random` module, which gives us access to all functions
    defined in `random`, including `randint()`. At ➋, we write the module name, `random`,
    followed by a dot and the name of the function we want to use, `randint()`. We
    pass `randint()` the arguments `1` and `10` so it generates a pseudorandom number
    between 1 and 10, and we store the number in the variable `the_number`. This will
    be the secret number the user is trying to guess.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们导入了`random`模块，它为我们提供了对`random`中所有已定义函数的访问，包括`randint()`。在➋处，我们写下模块名称`random`，后面跟一个点和我们要使用的函数名`randint()`。我们将`1`和`10`作为参数传递给`randint()`，让它生成一个1到10之间的伪随机数字，并将该数字存储在变量`the_number`中。这将是用户尝试猜测的秘密数字。
- en: At ➌, we ask the user for a guess between 1 and 10, evaluate the number, and
    store it in the variable `guess`. Our game loop starts with the `while` statement
    at ➍. We’re using the `!=` (not equal to) operator to see if the guess is not
    equal to the secret number. If the user guesses the number on the first try, `guess
    != the_number` evaluates to `False` and the `while` loop doesn’t run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们要求用户在1到10之间猜一个数字，评估这个数字并将其存储在变量`guess`中。我们的游戏循环从➍处的`while`语句开始。我们使用`!=`（不等于）运算符检查猜测是否不等于秘密数字。如果用户第一次猜对了，`guess
    != the_number`的结果为`False`，那么`while`循环就不会执行。
- en: As long as the user’s guess is not equal to the secret number, we check with
    two `if` statements at ➎ and ➏ to see if the guess was too high (`guess > the_number`)
    or too low (`guess < the_number`) and then print a message to the user asking
    for another guess. At ➐, we accept another guess from the user and start the loop
    again, until the user guesses correctly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户的猜测不等于秘密数字，我们会通过两个`if`语句在➎和➏处检查猜测是太高（`guess > the_number`）还是太低（`guess <
    the_number`），然后打印一条消息要求用户再次猜测。在➐处，我们接受用户的另一个猜测并重新开始循环，直到用户猜对为止。
- en: At ➑, the user has guessed the number, so we tell them it was the right number,
    and our program ends. See [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers") for a few sample runs of the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在➑处，用户已经猜出了数字，所以我们告诉他们这是正确的数字，然后程序结束。有关程序的一些示例运行，请参见[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "图6-1. 我们的 GuessingGame.py 程序，要求用户猜测三个随机数字是更大还是更小")。
- en: '![Our GuessingGame.py program, asking the user to guess higher or lower for
    three random numbers](httpatomoreillycomsourcenostarchimages2188919.png.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![我们的 GuessingGame.py 程序，要求用户猜测三个随机数字是更大还是更小](httpatomoreillycomsourcenostarchimages2188919.png.jpg)'
- en: Figure 6-1. Our *GuessingGame.py* program, asking the user to guess higher or
    lower for three random numbers
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 我们的*GuessingGame.py*程序，要求用户猜测三个随机数字是更大还是更小
- en: In the first run of the program in [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers"), the user guessed 5, and the computer responded that
    5 was too high. The user guessed lower with 2, but 2 was too low. Then the user
    gave 3 a shot, and that was right! Guessing halfway between the lowest and highest
    possible numbers each time, as in the examples in [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers"), is a strategy called a *binary search*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski "图6-1. 我们的GuessingGame.py程序，询问用户猜测更高或更低的三个随机数字")中程序的第一次运行中，用户猜测了5，计算机回应说5太高了。用户猜了2，结果是太低了。然后用户猜了3，正好！每次在最低和最高可能数字之间猜测一半的数字，就像[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "图6-1. 我们的GuessingGame.py程序，询问用户猜测更高或更低的三个随机数字")中的例子一样，这种策略叫做*二分查找*。
- en: If players learn to use this strategy, they can guess a number between 1 and
    10 in four tries or less, every time! Give it a shot!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家学会了使用这个策略，他们每次都可以在四次尝试内猜出1到10之间的数字！试试看吧！
- en: To make the program more interesting, you could change the arguments you pass
    to the `randint()` function to generate a number between 1 and 100 or an even
    higher number (be sure to change the `input()` prompts as well). You could also
    make a variable called `number_of_tries` and add 1 to it every time the user guesses,
    to keep track of the user’s number of tries. Print the number of tries at the
    end of the program to let the user know how well they did. For an additional challenge,
    you could add an outer loop that asks the user if they want to play again after
    they guess the number correctly. Try these on your own, and go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample solutions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序更有趣，你可以改变传递给`randint()`函数的参数，生成1到100之间的数字，或者更大的数字（记得也要修改`input()`的提示）。你还可以创建一个名为`number_of_tries`的变量，每次用户猜测时将其加1，以跟踪用户的尝试次数。在程序结束时打印出尝试次数，让用户知道他们表现如何。为了增加额外的挑战，你可以添加一个外循环，在用户猜对数字后询问他们是否想重新开始游戏。自己试试这些，并访问*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*查看示例解决方案。
- en: Colorful Random Spirals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五彩斑斓的随机螺旋线
- en: 'The `random` module has other handy functions besides `randint()`. Let’s use
    them to help us create an interesting visual: a screen full of spirals of random
    sizes and colors like the one in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py").'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块除了`randint()`之外还有其他有用的函数。让我们使用它们来帮助我们创建一个有趣的视觉效果：屏幕上充满了像[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2. 屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py")那样的随机大小和颜色的螺旋线。'
- en: '![Spirals of random sizes and colors at random locations on the screen, from
    RandomSpirals.py](httpatomoreillycomsourcenostarchimages2188921.png.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py](httpatomoreillycomsourcenostarchimages2188921.png.jpg)'
- en: Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from *RandomSpirals.py*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. 屏幕上随机位置的随机大小和颜色的螺旋线，来自*RandomSpirals.py*
- en: 'Think about how you could write a program like the one that created [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py"). You know *almost* all of the tricks needed to draw random
    spirals like these. First, you can draw spirals of various colors using loops.
    You can generate random numbers and use one to control how many times each spiral’s
    `for` loop runs. This changes its size: more iterations create a bigger spiral,
    while fewer iterations create a smaller spiral. Let’s look at what else we’ll
    need and build the program step by step. (The final version is [RandomSpirals.py](ch06.html#randomspiralsdotpy
    "RandomSpirals.py").)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你如何编写一个程序，像创建[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra "图6-2.
    屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py")那样的程序。你几乎*已经掌握*了绘制这些随机螺旋线所需的所有技巧。首先，你可以使用循环绘制不同颜色的螺旋线。你可以生成随机数，并使用其中一个来控制每个螺旋线的`for`循环运行的次数。这会改变它的大小：更多的迭代生成更大的螺旋，而较少的迭代生成较小的螺旋。让我们看看还需要什么，并一步一步构建程序。（最终版本是[RandomSpirals.py](ch06.html#randomspiralsdotpy
    "RandomSpirals.py")。）
- en: Pick a Color, Any Color
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一种颜色，任意颜色
- en: One new tool we’ll need is the ability to choose a random color. We can easily
    do this with another method in the `random` module, `random.choice()`. The `random.choice()`
    function takes a list or other collection as the argument (the part inside the
    parentheses), and it returns a randomly selected element from that collection.
    In our case, we could create a list of colors, and then pass that list to the
    `random.choice()` method to get a random color for each spiral.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的一个新工具是选择随机颜色的能力。我们可以使用`random`模块中的另一个方法`random.choice()`来轻松实现这一点。`random.choice()`函数将列表或其他集合作为参数（括号内的部分），并返回该集合中的随机选择元素。在我们的案例中，我们可以创建一个颜色列表，然后将该列表传递给`random.choice()`方法，为每个螺旋图形选择一个随机颜色。
- en: 'You can try this in the command line shell in IDLE:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在IDLE的命令行窗口中尝试以下操作：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we created our old friend `colors` and set it equal to a list
    of color names. Then we used the `random.choice()` function, passing it `colors`
    as its argument. The function chooses a color at random from the list. The first
    time, we got orange, the second time blue, the third time white, and so on. This
    function can give us a random color to set as our turtle’s pen color before it
    draws each new spiral.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了我们以前的老朋友`colors`并将其设置为一个颜色名称的列表。然后我们使用`random.choice()`函数，将`colors`作为参数传递给它。该函数会从列表中随机选择一个颜色。第一次，我们得到了橙色，第二次是蓝色，第三次是白色，依此类推。这个函数可以为我们提供一个随机颜色，用来在绘制每个新螺旋图形之前设置我们的乌龟的笔颜色。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188923.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188923.png.jpg)'
- en: Getting Coordinated
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取坐标
- en: One remaining problem is how to get the spirals to spread out all over the screen,
    including the upper-right and lower-left corners. To place spirals randomly on
    the turtle screen, we need to understand the x- and y-coordinate system used in
    our Turtle environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个剩下的问题是如何让螺旋图形在整个屏幕上展开，包括右上角和左下角。为了将螺旋图形随机放置在乌龟屏幕上，我们需要了解在我们的Turtle环境中使用的x和y坐标系统。
- en: Cartesian Coordinates
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笛卡尔坐标
- en: If you’ve taken a geometry course, you’ve seen (*x*, *y*) coordinates drawn
    on graph paper as in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates").
    These are *Cartesian* coordinates, named after French mathematician René Descartes,
    who labeled points on a grid with a pair of numbers we call the *x-* and *y-coordinates*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经上过几何学课程，你一定见过在图表纸上绘制的(*x*, *y*)坐标，如同[图6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "图6-3. 一个包含四个点及其笛卡尔（x, y）坐标的图表")所示。这些是*笛卡尔*坐标，得名于法国数学家勒内·笛卡尔，他用一对数字标记网格上的点，这些数字我们称之为*x-坐标*和*y-坐标*。
- en: In the graph in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates"),
    the dark horizontal line is called the *x-axis*, and it runs from left to right.
    The dark vertical line is the *y-axis*, running from bottom to top. We call the
    point where these lines meet, (0, 0), the *origin* because all other points on
    the grid are labeled with coordinates measured from, or *originating* from, that
    point. Think of the origin, (0, 0), as the center of your screen. Every other
    point you want to find can be labeled with an x- and y-coordinate by starting
    at the origin and moving left or right, down or up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-3](ch06.html#graph_with_four_points_and_their_cartesi "图6-3. 一个包含四个点及其笛卡尔（x,
    y）坐标的图表")中的图表中，深色的横线叫做*x轴*，它从左到右延伸。深色的竖线叫做*y轴*，从下到上延伸。我们称这两条线相交的点(0, 0)为*原点*，因为网格上的所有其他点都是以该点为起点，按坐标测量而得的。可以将原点(0,
    0)视为你的屏幕的中心。你想找到的每个其他点，都可以通过从原点出发，向左或向右、向下或向上移动来标记其x和y坐标。
- en: '![A graph with four points and their Cartesian (x, y) coordinates](httpatomoreillycomsourcenostarchimages2188925.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个点及其笛卡尔（x, y）坐标的图表](httpatomoreillycomsourcenostarchimages2188925.png)'
- en: Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. 一个包含四个点及其笛卡尔（x, y）坐标的图表
- en: 'We label points on a graph with this pair of coordinates inside parentheses,
    separated by a comma: (*x*, *y*)*.* The first number, the x-coordinate, tells
    us how far to move left or right, while the second number, the y-coordinate, tells
    us how far to move up or down. Positive x-values tell us to move right from the
    origin; negative x-values tell us to move left. Positive y-values tell us to move
    up from the origin, and negative y-values tell us to move down.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一对坐标放在括号内并用逗号分隔来标记图上的点：（*x*，*y*）。第一个数字x坐标告诉我们要向左或向右移动多远，而第二个数字y坐标告诉我们要向上或向下移动多远。正的x值告诉我们从原点向右移动；负的x值告诉我们向左移动。正的y值告诉我们从原点向上移动，负的y值告诉我们向下移动。
- en: Look at the points labeled in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates").
    The point in the upper right is labeled with the x- and y-coordinates (4, 3).
    To find the location of this point, we start at the origin (0, 0) and move 4 spaces
    to the right (because the x-coordinate, 4, is positive) and then 3 spaces up (because
    the y-coordinate, 3, is positive).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图6-3](ch06.html#graph_with_four_points_and_their_cartesi "图6-3：带有四个点及其笛卡尔坐标系（x，y）的图")中标记的各个点。右上方的点标注了x和y坐标(4,
    3)。为了找到这个点的位置，我们从原点(0, 0)开始，向右移动4个单位（因为x坐标4是正数），然后向上移动3个单位（因为y坐标3是正数）。
- en: To get to the point in the lower right, (3, –3), we go back to the origin and
    then move right 3 spaces or units. This time, the y-coordinate is –3, so we move
    *down* 3 units. Moving right 3 and down 3 puts us at (3, –3). For (–4, 2), we
    move *left* 4 units from the origin and then up 2 units to the point in the upper
    left. Finally, for (–3, –2), we move left 3 units and then down 2 units to the
    lower-left point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达右下角的点(3, –3)，我们先回到原点，然后向右移动3个单位。由于这次y坐标是–3，所以我们向*下*移动3个单位。向右移动3个单位并向下移动3个单位后，我们到达(3,
    –3)的位置。对于(–4, 2)，我们从原点向*左*移动4个单位，再向上移动2个单位，最终到达左上方的点。最后，对于(–3, –2)，我们向左移动3个单位，再向下移动2个单位，最终到达左下方的点。
- en: Setting a Random Turtle Position
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置随机海龟位置
- en: In turtle graphics, we can move the turtle from the origin (0, 0) to any other
    location by telling the computer the x- and y-coordinates of the new location
    with the `turtle.setpos(x,y)` command. The function name `setpos()` is short for
    *set position*. It sets the position of the turtle to the x- and y-coordinates
    we give it. For example, `turtle.setpos(10,10)` would move the turtle right 10
    units and up 10 units from the center of the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在海龟图形中，我们可以通过告诉计算机新位置的x和y坐标，使用`turtle.setpos(x, y)`命令将海龟从原点(0, 0)移动到任何其他位置。函数名`setpos()`是*设置位置*的缩写。它将海龟的位置设置为我们给定的x和y坐标。例如，`turtle.setpos(10,10)`将把海龟从屏幕中心向右移动10个单位并向上移动10个单位。
- en: On the computer, the unit we usually use is our old friend the [*pixel*](apd.html#gloss01_038).
    So `turtle.setpos(10,10)` would move the turtle right 10 pixels and up 10 pixels
    from the center of the screen. Because pixels are so tiny—about 1/70 of an inch
    (0.3 millimeters) or smaller on most displays—we might want to move 100 pixels
    or more at a time. `setpos()` can handle any coordinates we give it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，我们通常使用的单位是我们老朋友[*像素*](apd.html#gloss01_038)。所以`turtle.setpos(10,10)`将把海龟从屏幕中心向右移动10个像素并向上移动10个像素。由于像素非常小——在大多数显示器上大约是1/70英寸（0.3毫米）或更小——我们可能希望一次移动100个像素或更多。`setpos()`可以处理我们给定的任何坐标。
- en: 'To move the turtle to a random location on the screen, we’ll generate a random
    pair of numbers, `x` and `y`, then use `turtle.setpos(x,y)` to move the turtle
    to those coordinates. Before we move the turtle, though, we’ll need to lift the
    turtle’s pen with `turtle.penup()`. After we’ve set the new position, we’ll call
    `turtle.pendown()` to put the pen back down and enable the turtle to draw again.
    If we forget to lift the pen, the turtle will draw a line as it moves to wherever
    we tell it to go with `setpos()`. As you can see in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py"), we don’t want extra lines between our spirals. Our code
    will look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将海龟移动到屏幕上的一个随机位置，我们将生成一对随机数字 `x` 和 `y`，然后使用 `turtle.setpos(x,y)` 将海龟移动到这些坐标。但在移动海龟之前，我们需要用
    `turtle.penup()` 抬起海龟的笔。在设置新位置后，我们会调用 `turtle.pendown()` 将笔放下，允许海龟再次绘图。如果我们忘记抬起笔，海龟在通过
    `setpos()` 移动到指定位置时会绘制一条线。正如你在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2：屏幕上随机位置的随机大小和颜色的螺旋，来自 RandomSpirals.py")中看到的那样，我们不希望螺旋之间有额外的线条。我们的代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `setpos()` function combined with a couple of random numbers as (*x*, *y*)
    coordinates will let us place spirals in different locations, but how do we know
    what range to use for our random numbers? That question brings us to the last
    issue we have to resolve in our quest for random spirals.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`setpos()` 函数结合几个随机数字作为 (*x*, *y*) 坐标，可以让我们把螺旋图形放置在不同的位置，但我们如何知道应该使用什么范围来生成随机数呢？这个问题引出了我们在寻找随机螺旋时必须解决的最后一个问题。'
- en: How Big Is Our Canvas?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的画布有多大？
- en: 'Now that we know how to position spirals at random locations on the window,
    or canvas, we have one problem remaining: how do we know how big our canvas is?
    We can generate a random number for the x- and y-coordinates of a location and
    draw a spiral at that location, but how can we make sure that the location we
    choose is on the visible window—not off the window to the right, left, top, or
    bottom? Then, how can we make sure we cover the entire drawing window, from left
    to right, top to bottom?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将螺旋图形随机放置在窗口或画布的不同位置，但仍然有一个问题：我们如何知道画布的大小呢？我们可以为一个位置生成随机的 x 和 y 坐标，并在该位置绘制一个螺旋，但我们如何确保所选的位置在可视窗口内，而不是位于窗口的右侧、左侧、顶部或底部之外呢？然后，我们如何确保从左到右、从上到下覆盖整个绘图窗口呢？
- en: To answer the question about canvas size, we need to use two more functions,
    `turtle.window_width()` and `turtle.window_height()`. First, `window_width()`
    tells us how wide our turtle window is, in pixels. The same goes for `window_height()`;
    we get the number of pixels from the bottom of our turtle window to the top. For
    example, our turtle window in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py") is 960 pixels wide and 810 pixels tall.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答有关画布大小的问题，我们需要使用两个额外的函数，`turtle.window_width()` 和 `turtle.window_height()`。首先，`window_width()`
    会告诉我们海龟窗口的宽度，单位是像素。同样，`window_height()` 会告诉我们从海龟窗口底部到顶部的像素数。例如，我们的海龟窗口在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2：屏幕上随机位置的随机大小和颜色的螺旋，来自 RandomSpirals.py")中宽度为960像素，高度为810像素。
- en: '`turtle.window_width()` and `turtle.window_height()` will help us with random
    x- and y-coordinates, but we have one more obstacle. Remember that in turtle graphics,
    the center of the window is the origin, or (0, 0). If we just generate random
    numbers between 0 and `turtle.window_width()`, the first problem is that we will
    never draw anything in the lower left of the window: the coordinates there are
    negative in both the x- and y-directions (left and down), but a random number
    between 0 and our `window_width()` value is always positive. The second problem
    is that if we start from the center and go `window_width()` to the right, we’ll
    end up off the righthand edge of the window.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.window_width()` 和 `turtle.window_height()` 将帮助我们确定随机的 x 和 y 坐标，但我们还面临一个障碍。记住，在海龟图形中，窗口的中心是原点，即
    (0, 0)。如果我们只是生成介于 0 和 `turtle.window_width()` 之间的随机数，第一个问题是我们永远无法在窗口的左下角绘制任何东西：那里坐标在
    x 轴和 y 轴上都是负数（向左和向下），但一个介于 0 和 `window_width()` 之间的随机数总是正数。第二个问题是，如果我们从中心开始，向右移动
    `window_width()`，我们就会超出窗口的右边界。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188927.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188927.png.jpg)'
- en: We have to figure out not just how wide and tall the window is but also what
    the range of the coordinates is. For example, if our window is 960 pixels wide
    and the origin (0, 0) is at the center of our window, we need to know how many
    pixels we can move to the right and left without leaving the visible window. Because
    (0, 0) is in the middle of our window, halfway across, we just divide the width
    in half. If the origin is in the middle of a window that is 960 pixels across,
    there are 480 pixels to the right of the origin and 480 pixels to the left of
    the origin. The range of x-coordinate values would be from –480 (left 480 pixels
    from the origin) to +480 (480 pixels right of the origin) or, in other words,
    from –960/2 to +960/2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要弄清楚窗口的宽度和高度，还需要了解坐标的范围。例如，如果我们的窗口宽度为960像素，并且原点(0, 0)位于窗口的中心，我们需要知道可以向右和向左移动多少像素而不超出可视窗口。因为原点(0,
    0)位于窗口的正中间，所以我们只需要将宽度除以二。如果原点位于一个宽度为960像素的窗口的中心，那么原点右侧有480像素，左侧也有480像素。x坐标的范围将是从–480（从原点向左480像素）到+480（从原点向右480像素），换句话说，就是从–960/2到+960/2。
- en: To make our range work for any size window, we would say the x-coordinates go
    from `-turtle.window_width()//2` to `+turtle.window_ width()//2`. Our origin is
    also in the middle of the window from bottom to top, so there are `turtle.window_height()//2`
    pixels above and below the origin. We use integer division, the `//` operator,
    in these calculations to make sure we’ll get an integer result when we divide
    by 2; a window could measure an odd number of pixels wide, and we want to keep
    all our pixel measurements in whole numbers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的范围适用于任何大小的窗口，我们可以这样写，x坐标的范围从`-turtle.window_width()//2`到`+turtle.window_width()//2`。我们的原点也位于窗口从上到下的中间，所以原点上方和下方各有`turtle.window_height()//2`像素。我们在这些计算中使用整数除法，即`//`运算符，以确保在除以2时得到整数结果；因为窗口的宽度可能是奇数像素，我们希望保持所有像素测量值为整数。
- en: 'Now that we know how to calculate the size of our canvas, we can use these
    expressions to limit the range of our random coordinates. Then we can be sure
    that any random coordinates we generate will be visible in our window. The `random`
    module in Python has a function that lets us generate a random number within a
    specified range: `randrange()`. We just tell the `randrange()` function to use
    negative one-half the window width as the start value for the range and positive
    one-half the window width as the end value for the range (we’ll have to import
    both `turtle` and `random` in our program to make these lines work):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何计算画布的大小了，我们可以使用这些表达式来限制随机坐标的范围。这样，我们就能确保生成的任何随机坐标都能在我们的窗口中可见。Python中的`random`模块有一个函数，可以让我们在指定的范围内生成一个随机数：`randrange()`。我们只需要告诉`randrange()`函数，以窗口宽度的一半负值作为范围的起始值，以窗口宽度的一半正值作为范围的结束值（我们需要在程序中导入`turtle`和`random`，才能让这些代码行生效）：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines of code will use the `randrange()` function to generate a pair of
    (*x*, *y*) coordinate values that are always on the viewing window and cover the
    full area of the viewing window from left to right, bottom to top.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行将使用`randrange()`函数生成一对(*x*, *y*)坐标值，这些坐标始终位于视图窗口内，并覆盖视图窗口的整个区域，从左到右，从下到上。
- en: Putting It All Together
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有部分整合在一起
- en: Now we have all the pieces—we just have to put them together to build a program
    that will draw random spirals in different colors, sizes, and locations. Here’s
    our finished *RandomSpirals.py* program; in just about 20 lines, it creates the
    kaleidoscope-like picture in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py").
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的部分——我们只需要将它们组合在一起，构建一个程序，用于在不同的颜色、大小和位置上绘制随机的螺旋线。以下是我们完成的*RandomSpirals.py*程序；仅用大约20行代码，它就能在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2. 在屏幕上随机位置绘制随机大小和颜色的螺旋线，来自RandomSpirals.py")中创建出类似万花筒的图像。
- en: RandomSpirals.py
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RandomSpirals.py
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First we import the `random` and `turtle` modules and set up our turtle window
    and a list of colors. At our `for` loop (`n` will go from `0` to `49` to give
    us 50 spirals total), things get interesting. At ➊, we pass `colors` to `random.choice()`
    to have the function choose a random color from the list. We pass the random color
    choice to `t.pencolor()` to set the turtle’s pen color to that random color. At
    ➋, `random.randint(10,40)` picks a random number from 10 to 40\. We store that
    number in the variable `size`, which we’ll use at ➑ to tell Python how many lines
    to draw in a spiral. The lines at ➌ and ➍ are exactly the ones we built earlier
    to generate a random pair of coordinate values (*x*, *y*) that give us a random
    location on our viewing window.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, we lift the turtle’s pen off the virtual paper before we move the turtle
    to its new random location. At ➏, we move the turtle to its new location by setting
    its position to `x` and `y`, the random coordinates chosen by `randrange()` earlier.
    Now that the turtle is in position, we put the pen back down at ➐ so we’ll be
    able to see the spiral we’re about to draw. At ➑, we have a `for` loop to draw
    each line of the spiral. For `m` in `range(size)`, the turtle will move forward
    a distance of `m*2`, drawing a line segment of length `m*2` (`m` is `0`, `1`,
    `2`, `3`, and so on, so the length of the segment is 0, 2, 4, 6, and so on). The
    turtle will then rotate left 91 degrees and get ready to draw the next segment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The turtle starts in the center of the spiral, draws a segment (length 0), and
    rotates left; that’s the first time through the loop. The next time through, `m`
    is `1`, so the turtle draws a segment of length 2, then rotates. As Python iterates
    through the loop, the turtle will move outward from the center of the spiral,
    drawing longer and longer line segments. We use the randomly generated `size`,
    an integer between 10 and 40, as the number of lines we draw in our spiral.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: After we finish drawing the current spiral, we go back to the top of our outer
    `for` loop. We pick a new random color, size, and location; lift the pen; move
    it to the new location; put down the pen; and go through the inner `for` loop
    to draw a new spiral of some new random size. After drawing this spiral, we go
    back to the outer loop and repeat the entire process. We do this 50 times, giving
    us 50 spirals of assorted colors and shapes spread randomly across the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Rock-Paper-Scissors
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One game that we have the skills to program now is Rock-Paper-Scissors. Two
    players (or one player and the computer) each pick one of three possible items
    (rock, paper, or scissors); both show their choice; and the winner is decided
    by three rules: rock crushes scissors, scissors cut paper, paper covers rock.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this game, we’ll create a list of choices (like our `colors` list
    in *RandomSpirals.py*) and we’ll use `random.choice()` to pick one of the three
    items from the list as the computer’s choice. Then, we’ll ask the user for their
    choice and use a series of `if` statements to determine the winner. The user will
    be playing against the computer!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump into the code. Type *RockPaperScissors.py* into a new window in IDLE
    or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: RockPaperScissors.py
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ➊, we import the `random` module to get access to the functions that help
    us make random choices. At ➋, we set up the list of the three items—rock, paper,
    and scissors—and call the list `choices`. We print the simple rules of the game
    to make sure the user knows them. At ➌, we prompt the user to input their choice
    of `rock`, `paper`, `scissors`, or `quit` and store their choice in the variable
    `player`. At ➍, we begin the game loop by checking whether the user chose `quit`
    at the input prompt; if they did, the game ends.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: As long as the user has not entered `quit`, the game begins. After changing
    the player’s input to lowercase for easy comparison in our `if` statements, we
    tell the computer to pick an item. At ➎, we tell the computer to pick at random
    one of the items in the list `choices` and store the item in the variable `computer`.
    Once the computer’s choice is stored, it’s time to begin testing to see who won.
    At ➏, we check whether the player and the computer picked the same item; if so,
    we tell the user that the outcome was a tie. Otherwise, we check at ➐ whether
    the user selected `rock`. Inside the `elif` statement at ➐, we nest an `if` statement
    to see whether the computer picked `scissors`. If our player picks rock and the
    computer chooses scissors, rock crushes scissors, and the player wins! If it’s
    not rock and rock, and if the computer didn’t pick scissors, then the computer
    must have picked paper, and we print that the computer wins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'At the remaining two `elif` statements, ➑ and ➒, we do the same testing to
    check for wins when the user picks paper or scissors. If none of those statements
    was true, we let the user know they’ve entered something that did not compute:
    either they made a choice that doesn’t exist, or they misspelled their choice.
    Finally, at ➓, we ask the user for their next choice before beginning the game
    loop all over again (a new round). See [Figure 6-4](ch06.html#thanks_to_random_choices_by_the_computer
    "Figure 6-4. Thanks to random choices by the computer, RockPaperScissors.py is
    a fun game!") for a sample run of the program.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Thanks to random choices by the computer, RockPaperScissors.py is a fun game!](httpatomoreillycomsourcenostarchimages2188929.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. Thanks to random choices by the computer, *RockPaperScissors.py*
    is a fun game!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the user wins, sometimes the computer wins, and sometimes they tie.
    Because the outcome is somewhat random, the game is fun enough to play to pass
    a little time. Now that we have a sense of how a game with two players can use
    the computer’s random choices, let’s try creating a card game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Pick a Card, Any Card
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that makes card games fun is randomness. No two rounds turn out exactly
    the same (unless you’re bad at shuffling), so you can play again and again without
    getting bored.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We can program a simple card game with the skills we’ve learned. Our first try
    at this won’t show graphical playing cards (we need to learn more tricks to make
    that possible), but we can generate a random card name (“two of diamonds” or “king
    of spades,” for example) just by using an [*array*](apd.html#gloss01_006), or
    list, of strings, like we did with color names in our spiral programs. We could
    program a game like War in which two players each pull a random card from the
    deck, and the player with the higher card wins; we just need some way of comparing
    cards to see which is higher. Let’s see how that might work, step by step. (The
    final program is [HighCard.py](ch06.html#highcarddotpy "HighCard.py").)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Stacking the Deck
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to think about how to build a virtual deck of cards in our program.
    As I mentioned, we won’t draw the cards yet, but we at least need the card names
    to simulate a deck. Fortunately, card names are just strings (`"two of diamonds"`,
    `"king of spades"`), and we know how to build an array of strings—we’ve done it
    with color names since the very first chapter!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: An *array* is an ordered or numbered collection of similar things. In many programming
    languages, arrays are a special type of collection. In Python, though, lists can
    be used like arrays. We’ll see how to treat a list like an array in this section,
    accessing individual elements in the array one at a time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'We could build a list of all the card names by creating an array name (`cards`)
    and setting it equal to a list of all 52 card names:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But ouch—we’re going to have to type 52 long strings of card names! Our code
    will be 52 lines long before we even program the game part, and we’ll be so tired
    from typing that we won’t have energy left to play the game. There’s got to be
    a better way. Let’s think like a programmer! All of that typing is repetitive,
    and we want to let the computer do the repetitive work. The suit names (*diamonds*,
    *hearts*, *clubs*, *spades*) are going to be repeated 13 times each, for the 13
    cards in each suit. The face values (*two* through *ace*) are going to be repeated
    4 times each, because there are 4 suits. Worse, we’re typing the word *of* 52
    times!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ran into repetition before, we used loops to make the problem easier.
    If we wanted to generate the whole deck of cards, a loop would do the job nicely.
    But we don’t need the whole deck to play a single hand of War: we just need two
    cards, the computer’s card and the player’s. If a loop won’t help us avoid repeating
    all those suits and face values, we need to break the problem down further.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In War, each player shows one card, and the higher card wins. So as we’ve discussed,
    we need just 2 cards, not 52\. Let’s start with one card. A card name consists
    of a face value (two through ace) and a suit name (clubs through spades). Those
    look like good possibilities for lists of strings: one list for faces and one
    for suits. Instead of using a list of 52 repeated entries for each separate card,
    we pick a face value at random from the list of 13 possibilities, then pick a
    suit name at random from the 4 possible choices. This approach should let us generate
    any single card in the deck.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'We replace our long array `cards` with two much shorter arrays, `suits` and
    `faces`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We reduced 52 lines of code to about 3! That’s smart programming. Now let’s
    see how to use these two arrays to deal a card.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Dealing Cards
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188931.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: We already know how to use the `random.choice()` function to pick an item at
    random from a list. So to deal a card, we simply use `random.choice()` to pick
    a face value from a list of faces and a suit name from a list of suits. Once we
    have a random face and a random suit, all we do to complete a card name is add
    the word *of* between them (*two of diamonds*, for example).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we might deal the same card twice or more in a row using `random.choice()`
    this way. We’re not forcing the program to check whether a card has already been
    dealt, so you might get two aces of spades in a row, for example. The computer’s
    not cheating; we’re just not telling it to deal from a single deck. It’s like
    this program is dealing cards from an *infinite deck*, so it can keep dealing
    forever without running out.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you try running this code, you’ll get a new, random card every time. To deal
    a second card, you’d use similar code, but you’d store the random choices in variables
    called `your_face` and `your_suit`. You’d change the `print` statement so it printed
    the name of this new card. Now we’re getting closer to our game of War, but we
    need some way to compare the computer’s card and the user’s card to see who wins.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Counting Cards
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a reason we listed face card values in ascending order, from two through
    ace. We want the cards’ `faces` list to be ordered by value from lowest to highest
    so that we can compare cards against each other and see which card in any pair
    has the higher value. It’s important to determine which of two cards is higher,
    since in War the higher card wins each hand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Item in a List
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fortunately, because of the way lists and arrays work in Python, we can determine
    where a value occurs in a list, and we can use that information to decide whether
    one card is higher than another. The position number of an item in a list or array
    is called the *index* of that item. We usually refer to each item in an array
    by its index.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: For a visual representation of the `suits` array and the index of each suit,
    see [Table 6-1](ch06.html#suits_array "Table 6-1. The suits Array").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1. The `suits` Array
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| **value** | `"clubs"` | `"diamonds"` | `"hearts"` | `"spades"` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| [*index*](apd.html#gloss01_026) | `0` | `1` | `2` | `3` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: When we create our list `suits`, Python automatically assigns an index to each
    value in the list. The computer starts counting at zero, so the index of `"clubs"`
    is `0`, `"diamonds"` is at index `1`, and so on. The function to find the index
    of an item in a list is `.index()`, and it can be used on any list or array in
    Python.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the index of the suit name `"clubs"` in the list `suits`, we call the
    function `suits.index("clubs")`. It’s like we’re asking the `suits` array which
    index corresponds to the value `"clubs"`. Let’s try that in our Python shell.
    Enter the following lines:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we create the array of suit values, `suits`, we ask Python what the index
    of the value `"clubs"` is, and it responds with the correct index, `0`. In the
    same way, the index of `"spades"` is `3`, and diamonds and hearts are at index
    locations `1` and `2`, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Which Card is Higher?
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We created our `faces` array with values in order from `two` to `ace`, so the
    value `two`, the first item in `faces`, would get the index `0`, all the way through
    the `ace` at index `12` (the 13th location, starting from 0). We can use the index
    to test which card value is higher—in other words, which face value’s index is
    larger. Our lowest card is `two`, and its index is the smallest, `0`; the `ace`
    is our highest card, and its index is the largest, `12`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If we generate two random face card values (`my_face` and `your_face`), we can
    compare the index of `my_face` with the index of `your_face` to see which card
    is higher, as follows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use `random.choice()` twice to pull two random values out of the `faces`
    array, and then we store the values in `my_face` and `your_face`. We use `faces.index(my_face)`
    to find the index of `my_face` in `faces`, and we use `faces.index(your_face)`
    to get the index of `your_face`. If the index of `my_face` is higher, my card
    has a higher face value, and the program prints `I win!`. Otherwise, if the index
    of `my_face` is lower than the index of `your_face`, your card’s face value is
    higher, and the program prints `You win!`. Because of the way we ordered our list,
    a higher card will always correspond to a higher index. With this handy tool,
    we’ve got almost everything we need to build a “high card” game like War. (We
    haven’t added the ability to test for a tie game yet, but we’ll add that as part
    of the complete program in [Putting It All Together](ch06.html#putting_it_all_together-id00009
    "Putting It All Together").)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Keeping It Going
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final tool we need is a loop so the user can keep playing as long as they
    want. We’re going to build this loop a little differently so that we can reuse
    it in other games.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to decide which kind of loop to use. Remember that a `for` loop
    usually means we know exactly the number of times we want to do something. Because
    we can’t always predict how many times someone will want to play our game, a `for`
    loop is not the right fit. A `while` loop can keep going until some condition
    becomes false—for example, when the user presses a key to end the program. The
    `while` loop is what we’ll use for our game loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop needs a condition to check, so we’re going to create a variable
    that we’ll use as our *flag*, or signal, to end the program. Let’s call our flag
    variable `keep_going` and set it equal to `True` to start:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because we start with `keep_going = True`, the program will enter the loop at
    least the first time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll ask the user if they want to keep going. Rather than make the user
    enter `Y` or `yes` every time they want to play, let’s make it easier by just
    asking them to press ENTER.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we set a variable `answer` equal to an input function. Then we use an `if`
    statement to check whether `answer == ""` to see if the user pressed ENTER only
    or if they pressed other keys before ENTER. (The empty string `""` tells us the
    user didn’t type any other characters before pressing ENTER.) If the user wants
    to exit, all they have to do is make `answer` equal anything other than the empty
    string, `""`. In other words, they just have to press any key or keys before pressing
    ENTER, and the Boolean expression `answer == ""` will evaluate to `False`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Our `if` statement checks whether `answer == ""` is `True`, and if so, it stores
    `True` in our flag variable `keep_going`. But do you notice some repetition there?
    If `answer == ""` is `True`, we assign the value `True` to `keep_going`; if `answer
    == ""` evaluates to `False`, we need to assign the value `False` to `keep_going`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be simpler if we just set `keep_going` equal to whatever `answer ==
    ""` evaluates to. We can replace our code with the following, more concise code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line hasn’t changed. The second line sets `keep_going` equal to the
    result of the Boolean expression `answer == ""`. If that’s `True`, `keep_going`
    will be `True`, and our loop will continue. If that’s `False`, `keep_going` will
    be `False`, and our loop will end.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the whole loop together:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we add the `while` statement, so our loop will continue as long as `keep_going`
    evaluates to `True`. In the final program, we will “wrap” this `while` loop around
    the code to play a single hand. We’ll do this by putting the `while` statement
    before the code that chooses the cards, and by putting the prompt to hit a key
    after the code that tells who wins. Remember to indent the code inside the loop!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting all those components together, we can build a War-like game that we’ll
    call *HighCard.py*. The computer draws a card for itself and a card for the player,
    checks to see which card is higher, and declares the winner. Type the code for
    *HighCard.py* into a new IDLE window or go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    to download it and play.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: HighCard.py
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the game, and it’ll print the computer’s card and your card, followed by
    an announcement of who won and a prompt that offers you the opportunity to play
    again or exit. Play a few rounds and you’ll notice that the cards are random enough
    to make the outcome fun—sometimes the computer wins, sometimes you win, but it’s
    a fun game thanks to the element of chance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Roll the Dice: Creating a Yahtzee-Style Game'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used arrays in our card game to help simplify the code needed to deal a card,
    and to test which card was higher in value based on its position in the list of
    cards. In this section, we’ll use the array concept to generate five random dice
    and check to see if we roll three of a kind, four of a kind, or five of a kind,
    like a simplified version of the dice game Yahtzee.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In Yahtzee, you have five dice. Each die has six sides, with each side showing
    a number of dots from one to six. In the full game, the user rolls all five dice,
    trying to get points by rolling three dice of the same value (which we call *three
    of a kind*) and other various “hands,” similar to the card game poker. Rolling
    five of the same value (say, all five dice land with the six-dot side facing up)
    is called a Yahtzee and scores the highest points possible. In our simplified
    version of the game, we’re just going to simulate the roll of five dice and check
    whether the user rolled three of a kind, four of a kind, or Yahtzee and let them
    know the outcome.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188933.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Setting Up the Game
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the game’s objective, let’s talk about how we’ll code
    the game. First, we’ll need to set up a game loop so that the user can keep rolling
    until they want to quit. Second, we’ll need to set up a hand of five simulated
    dice as an array that can hold five random values, from 1 to 6, representing the
    value of each of the rolled dice. Third, we’ll simulate the roll of the dice by
    assigning a random value from 1 to 6 in each of the five array slots. Finally,
    we need to compare the five rolled dice to each other to see whether we have three,
    four, or five of the same value and let the user know the outcome.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: That last part is perhaps the most challenging. We could check for a Yahtzee
    by seeing if all five dice are a 1, or if all five dice are a 2, and so on, but
    that would mean a long list of complex `if` statement conditions. Since we don’t
    care whether we have five 1s, five 2s, or five 6s—we just care that we have five
    of a kind—we could simplify this process by checking to see if the first die’s
    value equals the second die’s value and the second die’s value equals the third
    die’s value, all the way to the fifth die. Then, no matter what the value of the
    five of a kind, we know all five dice are the same, and we have a Yahtzee.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Five of a kind seems easy enough to test for, but let’s try to figure out how
    we might test for four of a kind. A possible hand for four of a kind might be
    an array of values like `[1, 1, 1, 1, 2]` (here we rolled four 1s and a 2). However,
    the array `[2, 1, 1, 1, 1]` would also be a four of a kind with four 1s, as would
    `[1, 1, 2, 1, 1]`, `[1, 2, 1, 1, 1]`, and `[1, 1, 1, 2, 1]`. That’s five possible
    configurations just to test for four 1s! That sounds like it’s going to take a
    long set of `if` conditions. . . .
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, as a skilled programmer, you know that there’s usually an easier
    way to do things. What all five arrays in the previous paragraph have in common
    is that there are four 1s in the list of values; the problem is that the fifth
    value, the 2, can be in any of the five different array positions. We could test
    for four of a kind much more easily if the four 1s were side by side, with the
    other value (the 2) off by itself. If we could sort the array in order from lowest
    to highest or highest to lowest, for example, all of the 1s would be grouped together,
    reducing the five different cases to just two: `[1, 1, 1, 1, 2]` or `[2, 1, 1,
    1, 1]`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Sorting the Dice
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists, collections, and arrays in Python have a built-in sort function, `sort()`,
    that allows us to sort the elements in the array by value in order from smallest
    to largest or vice versa. For example, if our dice array were called `dice`, we
    could sort the values with `dice.sort()`. By default, `sort()` will order the
    elements in `dice` from smallest to largest, or in *ascending* order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'For our test to see if the array of dice contains four of a kind, sorting the
    array means we only have to test for two cases: four matching low values and a
    high value (as in `[1, 1, 1, 1, 2]`), or a low value and four matching high values
    (like `[1, 3, 3, 3, 3]`). In the first case, we know that if the dice are sorted
    and the first and fourth dice are equal in value, we have four of a kind or better.
    In the second case, again with sorted dice, if the second and fifth dice are equal
    in value, we have four of a kind or better.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'We say four of a kind *or better*, because the first and fourth dice are also
    the same in a five of a kind. This brings us to our first logic challenge: if
    a user rolls five of a kind, they have also rolled four of a kind, and we only
    want to give them credit for the larger score. We’ll handle this with an `if-elif`
    chain so that if a user gets Yahtzee, they don’t also get four of a kind and three
    of a kind; only the highest hand wins. Combining this `if-elif` sequence with
    what we learned about sorting the dice to check for four of a kind, the code would
    look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, if we have already sorted the dice array, we notice a shortcut: if the
    first and last dice have the same value (`if dice[0] == dice[4]`), we know we
    have a Yahtzee! Remember that we number our array positions from 0 through 4 for
    the first through fifth dice. If we don’t have five of a kind, we check for both
    cases of four of a kind (the first four dice are the same, `dice[0] == dice[3]`,
    or the last four dice are the same, `dice[1] == dice[4]`). We use the Boolean
    operator `or` here to recognize four of a kind if *either* of the two cases evaluates
    to `True` (the first four *or* the last four).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Dice
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re referring to each die in the array individually by its index, or position:
    `dice[0]` refers to the first item in the dice array, and `dice[4]` refers to
    the fifth item because we start counting from zero. This is the way we can check
    the value of any of the dice individually or compare them to one another. Just
    as in our `suits[]` array back in [Table 6-1](ch06.html#suits_array "Table 6-1. The
    suits Array"), each entry in the `dice[]` array is an individual value. When we
    call on `dice[0]` to see if it’s equal to `dice[3]`, we’re looking at the value
    in the first `dice` element and comparing it to the value in the fourth `dice`
    element. If the array is sorted, and these are the same, we have four of a kind.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for three of a kind, we add another `elif` statement, and we put the
    three-of-a-kind test after the four-of-a-kind test so that we test for three of
    a kind only if there’s no five of a kind and no four of a kind; we want the highest
    hand to be reported. There are three possible cases of three of a kind if we’re
    working with sorted dice: the first three dice match, the middle three, or the
    last three. In code, that would be:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we can test for various winning hands in our dice game, let’s add the
    game loop and the `dice` array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the complete *FiveDice.py* program. Type the code in a new window or
    download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: FiveDice.py
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After we import the `random` module and start the game loop with a `while` statement,
    the next few lines deserve a little explanation. At ➊, we set up an array called
    `dice` that holds five values, and we initialize all those values to zero. The
    square brackets, `[` and `]`, are the same ones we used for our very first lists
    of colors, as well as for the arrays of card face values and suit names earlier
    in this chapter. At ➋, we set up a `for` loop to run five times for the five dice,
    using the range from 0 to 4; these will be the array positions, or index numbers,
    of the five dice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: At ➌, we set each individual die, from `dice[0]` to `dice[4]`, equal to a random
    integer from 1 to 6 to represent our five dice and their randomly rolled values.
    At ➍, we show the user what dice they rolled by printing the contents of the `dice`
    array; the result of this `print` statement is shown in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind.").
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![A sample run of our dice program. Notice that we rolled several three of
    a kinds and one four of a kind.](httpatomoreillycomsourcenostarchimages2188935.png.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. A sample run of our dice program. Notice that we rolled several
    three of a kinds and one four of a kind.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, we call the `.sort()` function on the `dice` array. This makes it easy
    to test for various hands—like five of a kind, four of a kind, and so on—by arranging
    the rolled dice values from smallest to largest, grouping like values. So, for
    example, if we roll `[3, 6, 3, 5, 3]`, the `dice.sort()` function turns that into
    `[3, 3, 3, 5, 6]`. The `if` statement checks if the first value is equal to the
    fifth value; in this case, since the first and fifth values (`3` and `6`) aren’t
    equal, we know not all the dice landed on the same value and it’s not five of
    a kind. The first `elif` checks for four of a kind by comparing the first and
    fourth values (`3` and `5`) and second and fifth values (`3` and `6`); again,
    there are no matches here, so it’s not four of a kind. The second `elif` checks
    for three of a kind; since the first and third values, `3` and `3`, are equal,
    we know the first three values are equal. We inform the user that they got three
    of a kind and then prompt them to press keys depending on whether they want to
    continue playing or exit, as shown in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind.").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Run the program and press ENTER several times to see what you roll.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that you roll three of a kind fairly often, as much as once every
    five or six rolls. Four of a kind is rarer, occurring about once every 50 rolls.
    We rolled four of a kind only once in a screen full of attempts in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind."). The Yahtzee is even rarer: you could roll
    several hundred times before getting a Yahtzee, but because of the random-number
    generator, you might roll one the first few times you try. Even though it’s not
    as complex as the real game, our simplified version of Yahtzee is interesting
    enough to play because of its random nature.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how randomness can make a game interesting and fun by adding the
    element of chance to dice and card games, Rock-Paper-Scissors, and a guessing
    game. We also enjoyed the kaleidoscope-like graphics we created using a random
    number generator to place colorful spirals all over the screen. In the next section,
    we’ll combine what you’ve learned about random numbers and loops with a bit of
    geometry to turn the random spirals program into a true virtual kaleidoscope that
    generates a different set of reflected images every time you run it!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188937.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Running the numbers on Yahtzee
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in the math behind Yahtzee and why five of a kind is so
    rare, here’s a quick explanation. First, there are five dice, each with six sides,
    so the number of possible combinations is 6 × 6 × 6 × 6 × 6 = 6⁵ = 7,776\. There
    are 7,776 ways to roll five normal, six-sided dice. To figure out the probability
    of rolling five dice with the same face value (five of a kind), we have to figure
    out how many possible Yahtzees there are: five 1s, five 2s, and so on up through
    five 6s. So there are six possible Yahtzee hands of five of a kind that we can
    roll with our five dice. Divide 6 Yahtzees by the 7,776 total possible rolls,
    and you get the probability that you’ll roll five of a kind: 6/7,776, or 1/1,296.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s right: the odds that you’ll roll five of a kind on a single roll are
    just 1 out of 1,296\. So don’t get discouraged if you roll for a long time before
    you get your first five of a kind. On average, you’ll get one every 1,300 rolls
    or so. No wonder they give 50 points for a Yahtzee!'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Kaleidoscope
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The random spiral color graphic from [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py") looked a bit like a kaleidoscope. To make it look more
    like a real kaleidoscope, let’s add an important feature that our spiral program
    was missing: reflections.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In a kaleidoscope, it’s the positioning of the mirrors that makes random colors
    and shapes into a lovely pattern. In this closing example, we’re going to mimic
    the mirror effect by modifying our *RandomSpiral.py* program to “reflect” the
    spirals four times on the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188939.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: To understand how to achieve this mirror effect, we need to talk more about
    Cartesian coordinates. Let’s take a look at four points, (4, 2), (–4, 2), (–4,
    –2), and (4, –2), as shown in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)").
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare (4, 2) and (–4, 2), the top two points. If the vertical y-axis were
    a mirror, these two points would be mirror images of each other; we call (4, 2)
    a reflection of (–4, 2) *about* the y-axis. Something similar occurs with (4,
    2) and (4, –2), the two points on the right, but with the horizontal x-axis as
    the imaginary mirror: (4, –2) is the reflection of (4, 2) about the x-axis.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Four points reflected about the x- and y-axes starting with (4, 2)](httpatomoreillycomsourcenostarchimages2188941.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. Four points reflected about the x- and y-axes starting with (4,
    2)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at each pair of (*x*, *y*) coordinates in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)"),
    you’ll notice something: all four (*x*, *y*) coordinates use the same numbers,
    4 and 2, just with different signs, + or –, depending on their location. We can
    create any four reflected points around the x- and y-axes by changing the signs
    on the two coordinates as follows: (*x*, *y*), (*–x*, *y*), (*–x*, *–y*), (*x*,
    *–y*). If you’d like, you can try drawing this on a piece of graph paper with
    any pair of (*x*, *y*) coordinates. Try (2, 3), for example: (2, 3), (–2, 3),
    (–2, –3), and (2, –3) are four reflected points above and below the x-axis and
    on either side of the y-axis.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, we can build the outline of a kaleidoscope program as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Pick a random location (*x*, *y*) in the upper right of the screen and draw
    a spiral there.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the same spiral at (*–x*, *y*) in the upper left of the screen.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the same spiral at (*–x*, *–y*) in the lower left of the screen.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the same spiral at (*x*, *–y*) in the lower right of the screen.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we repeat these steps over and over, we’ll have a lovely kaleidoscope effect
    with our random spirals.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Let’s step through the full code for *Kaleidoscope.py* and see this in action.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Kaleidoscope.py
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our program begins with the `turtle` and `random` modules imported as usual,
    but at ➊ we do something new: we change the speed of the turtle to the fastest
    value possible with `t.speed(0)`. The `speed()` function in turtle graphics takes
    an argument from 0 to 10, with `1` as the slow animation setting, `10` as the
    fast animation setting, and `0` meaning no animation (draw as fast as the computer
    can go). It’s an odd scale from 1 to 10, then 0, but just remember that if you
    want the fastest turtle possible, set the speed to `0`. You’ll notice when you
    run the program that the spirals appear almost instantly. You can make this change
    to any of our previous drawing programs if you’d like the turtle to move faster.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Our `for` loop looks just like the one from our *RandomSpirals.py* program,
    until we get to ➋ and ➌. At ➋, we cut the horizontal range for our random number
    in half, to just the positive x-coordinate values (the right side of the screen,
    from `x = 0` to `x = turtle.window_ width()//2`), and at ➌, we restrict the vertical
    range to the upper half of the screen, from `y = 0` to `y = turtle.window_height()//2`.
    Remember that we’re doing integer division with the `//` operator to keep our
    pixel measurements in whole numbers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: These two lines of code give us a random (*x*, *y*) coordinate pair in the upper
    right of the screen every time. We set the turtle pen’s position to that point
    at ➍, and we draw the first spiral with the `for` loop immediately after. Then,
    we change the signs of each of the coordinate values, like we did in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)"),
    to create the three reflections of this point in the upper left (*–x*, *y*) at
    ➎, lower left (*–x*, *–y*) at ➏, and lower right (*x*, *–y*) at ➐. See [Figure 6-7](ch06.html#mirroredsolidusrepeated_effect_in_kaleid
    "Figure 6-7. The mirrored/repeated effect in Kaleidoscope.py.") for an example
    of the patterns *Kaleidoscope.py* can produce.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the three reflections for each spiral by looking in the other
    three corners of the screen. These are not true mirror images: we don’t start
    at the same angle for each spiral, and we don’t turn right in our reflected spirals
    and left in the originals. However, these are tweaks you can make to the program
    if you’d like. See this chapter’s Programming Challenges for ideas to make this
    kaleidoscope program even cooler.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![The mirrored/repeated effect in Kaleidoscope.py.](httpatomoreillycomsourcenostarchimages2188943.png.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7. The mirrored/repeated effect in *Kaleidoscope.py*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before this chapter, we had no way of making a computer behave randomly. Now
    we can make a computer roll dice; draw random cards from a deck; draw spirals
    of random color, shape, size, and location; and even beat us now and then at Rock-Paper-Scissors.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The tool that made these programs possible was the `random` module. We used
    `random.randint(1, 10)` to generate a random number between 1 and 10 in our guessing
    game. We added the `random.choice()` function to pick a random color out of a
    list in our random spirals program. You learned how to use the functions `turtle.window_width()`
    and `turtle.window_height()` to find the width and height of our turtle screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to use Cartesian coordinates to find an (*x*, *y*) location
    on the screen, and you used the `random.randrange()` function to generate a number
    in the range between our left and right x-coordinate values and top and bottom
    y-coordinate values. We then used `turtle.setpos(x,y)` to move the turtle to any
    position on the drawing screen.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We combined our ability to choose an item from a list at random using `random.choice()`
    with our ability to test and compare variables using `if`-`elif` statements to
    build a “user versus computer” version of Rock-Paper-Scissors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You learned the concept of an array, and we made our card game easier to code
    by building one array of suit names and one array of face values. We used `random.choice()`
    on each array to simulate dealing a card. We ordered the face values from least
    to greatest and used the `.index()` function to find the location of an element
    in an array. We used the index of each of two card face values to see which card
    had a higher index value and which player won a hand of the card game War. We
    built a reusable game loop with user input, a flag variable `keep_going`, and
    a `while` statement; we can put the loop into any game or app that a user might
    want to play or run multiple times in a row.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: We extended our understanding of arrays by building a simplified version of
    Yahtzee. We created an array of five values from 1 to 6 to simulate five dice,
    used `randint()` to simulate rolling the dice, and used `sort()` on the dice array
    to make it easier to check for winning hands. We saw that, in a sorted array,
    if the first and last values are the same, all elements in the array are the same.
    In our game, this meant we had five of a kind. We used compound `if` statements
    joined by the `or` operator to test for two cases of four of a kind and three
    cases of three of a kind. We used `if-elif` statements to control the logic of
    our program so that five of a kind wasn’t also counted as four of a kind, and
    so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We worked more with Cartesian coordinates in the kaleidoscope program and simulated
    the effect of reflections by changing the signs of (*x*, *y*) coordinate values.
    We repeated each spiral of random size, color, and location four times on the
    screen to create our kaleidoscope effect. You learned how to increase the turtle’s
    drawing speed with `t.speed(0)`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers and choices add an element of chance to make a game more interesting.
    Just about every game you’ve played has an element of chance. Now that you can
    build randomness into programs, you can code games people love to play.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be able to do the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Import the `random` module into your programs.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `random.randint()` to generate a random integer number in a given range.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `random.choice()` to pick a value at random out of a list or array.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `random.choice()` to generate 52 card values from two arrays of strings
    containing only the faces and suits.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the size of your drawing window with `turtle.window_ width()` and
    `turtle.window_height()`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the turtle to any position on the drawing screen with `turtle.setpos(x,y)`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `random.randrange()` function to generate a random number in any range.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the index of an element in a list or array with the `.index()` function.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a `while` game loop using a Boolean flag variable like `keep_going`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct an array of similar types of values, assign values to elements in
    the array by their index (as in `dice[0] = 2`), and use array elements like regular
    variables.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort lists or arrays with the `.sort()` function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflect points about the x- and y-axes by changing the signs of the points’
    (*x*, *y*) coordinate values.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the turtle’s drawing speed with the `.speed()` function.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Challenges
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter’s challenge problems, we’ll extend the *Kaleidoscope.py* and
    *HighCard.py* programs. (If you get stuck, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample answers.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**#1: RANDOM SIDES AND THICKNESS**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Add more randomness to *Kaleidoscope.py* by adding two more random variables.
    Add a variable `sides` for the number of sides and then use that variable to change
    the angle we turn each time in the spiral loop (and therefore, the number of sides
    in the spiral) by using `360/sides + 1` as your angle instead of `91`. Next, create
    a variable called `thick` that will store a random number between 1 and 6 for
    the turtle pen’s thickness. Add the line `t.width(thick)` in the right place to
    change the thickness of the lines of each spiral in our random kaleidoscope.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**#2: REALISTIC MIRRORED SPIRALS**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know some geometry, two more tweaks make this kaleidoscope even more
    realistic. First, keep track of the direction (between 0 and 360 degrees) the
    turtle is pointing before drawing the first spiral by getting the result of `t.heading()`
    and storing it in a variable called `angle`. Then, before drawing each mirrored
    spiral, change the angle to the correct mirrored direction by pointing the turtle
    with `t.setheading()`. Hint: the second angle will be `180 - angle`, the third
    spiral’s angle will be `angle - 180`, and the fourth will be `360 - angle`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Then, try turning left after each drawn line for the first and third spirals
    and turning right each time for the second and fourth spirals. If you implement
    these improvements, your spirals should really look like mirror images of each
    other in size, shape, color, thickness, and orientation. If you like, you can
    even keep the shapes from overlapping so much by changing the range of the x-
    and y-coordinate values to `random.randrange(size,turtle.window_width()//2)` and
    `random.randrange(size,turtle.window_height()//2)`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**#3: WAR**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn *HighCard.py* into the full game of War by making three changes. First,
    keep score: create two variables to keep track of how many hands the computer
    has won and how many the user has won. Second, simulate playing one full deck
    of cards by dealing 26 hands (perhaps by using a `for` loop instead of our `while`
    loop or by keeping track of the number of hands played so far) and then declare
    a winner based on which player has more points. Third, handle ties by remembering
    how many ties have happened in a row; then, the next time one of the players wins,
    add the number of recent ties to that winner’s score and set the number of ties
    back to zero for the next round.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
