- en: 'Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 随机的乐趣与游戏：大胆尝试，挑战一下！
- en: In [Chapter 5](ch05.html "Chapter 5. Conditions (What If?)"), we programmed
    the computer to make decisions based on conditions. In this chapter, we’ll program
    the computer to pick a number between 1 and 10, to play Rock-Paper-Scissors, and
    even to roll dice or pick a card!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章 条件（如果？）")中，我们编写了程序让计算机根据条件做出决策。在这一章中，我们将编程让计算机在1到10之间选择一个数字，进行石头剪刀布游戏，甚至掷骰子或抽牌！
- en: The common element in these games is the idea of *randomness*. We want the computer
    to pick a number at random between 1 and 10, and we guess what that number is.
    We want the computer to randomly pick rock, paper, or scissors, and then we choose
    what to play and see who wins. These examples—plus dice games, card games, and
    so on—are called *games of chance*. When we roll five dice to play Yahtzee, we
    usually get a different result every time we roll. That element of chance is what
    makes these games fun.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些游戏的共同元素是*随机性*的概念。我们希望计算机在1到10之间随机选择一个数字，我们猜测那个数字是什么。我们希望计算机随机选择石头、剪刀或布，然后我们选择出招并看看谁赢了。这些例子——加上骰子游戏、纸牌游戏等等——都叫做*机会游戏*。当我们掷五个骰子来玩Yahtzee时，我们通常每次掷出的结果都会不同。正是这种随机性让这些游戏充满乐趣。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188917.png.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2188917.png.jpg)'
- en: We can program the computer to behave randomly. Python has a module called `random`
    that allows us to simulate random choices. We can use the `random` module to draw
    random shapes on the screen and program games of chance. Let’s start with a guessing
    game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编程让计算机执行随机行为。Python有一个叫做`random`的模块，允许我们模拟随机选择。我们可以使用`random`模块在屏幕上绘制随机形状，也可以编程制作机会游戏。让我们从一个猜数字游戏开始。
- en: A Guessing Game
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个猜数字游戏
- en: We can use random numbers in the classic Hi-Lo guessing game. One player picks
    a number between 1 and 10 (or 1 and 100), and the other tries to guess the number.
    If the guess is too high, the guesser tries a lower number. If they guessed too
    low, they try a higher number. When they guess the right number, they win!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在经典的Hi-Lo猜数字游戏中使用随机数字。一个玩家选择一个1到10之间（或1到100之间）的数字，另一个玩家尝试猜测这个数字。如果猜测太高，猜测者就尝试一个更小的数字。如果猜测太低，他们会尝试一个更大的数字。当他们猜对时，他们就赢了！
- en: We already know how to compare numbers with the `if` statement, and we know
    how to keep guessing using `input()` and a `while` loop. The only new skill we
    need to learn is how to generate a random number. We can do this with the `random`
    module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用`if`语句比较数字，也知道如何通过`input()`和`while`循环来保持猜测。我们唯一需要学习的新技能是如何生成一个随机数字。我们可以通过`random`模块来实现这一点。
- en: 'First, we have to import the `random` module with the command `import random`.
    You can try this in the Python shell by typing **`import random`** and pressing
    ENTER. The module has a few different functions for generating a random number.
    We’ll use `randint()`, short for *random integer*. The `randint()` function expects
    us to give it two arguments—that is, two pieces of information—between its parentheses:
    the lowest and highest numbers we want. Specifying a lowest number and a highest
    number in the parentheses will tell `randint()` what range to choose randomly
    from. Type the following in IDLE:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用命令`import random`导入`random`模块。你可以在Python Shell中输入**`import random`**并按下ENTER键来试试。这个模块有几个不同的函数来生成随机数字。我们将使用`randint()`，它是*随机整数*的缩写。`randint()`函数期望我们在它的括号内提供两个参数——也就是两个信息——：我们想要的最低值和最高值。指定括号中的最低值和最高值将告诉`randint()`从什么范围中随机选择。请在IDLE中输入以下内容：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python will respond with a random number between 1 and 10, *inclusive* (which
    means the random number can include 1 and 10). Try the `random.randint(1, 10)`
    command a few times and see the different numbers you get back. (Tip: you can
    use ALT-P, or CONTROL-P on a Mac, to repeat the most recently entered line without
    having to type it all again.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python将返回一个介于1到10之间的随机数字，*包括*（这意味着随机数字可以是1和10）。尝试运行`random.randint(1, 10)`命令几次，看看返回的不同数字。（提示：你可以使用ALT-P，或在Mac上使用CONTROL-P，重复最近输入的行，而无需重新输入整个命令。）
- en: If you run that line enough (at least 10 times), you’ll notice that numbers
    sometimes repeat, but there’s no pattern in the numbers as far as you can tell.
    We call these [*pseudorandom*](apd.html#gloss01_040) numbers because they’re not
    *actually* random (the `randint` command tells the computer what number to “pick”
    next based on a complex mathematical pattern), but they *seem* random.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行那行代码足够多次（至少10次），你会注意到数字有时会重复，但从你所见，它们没有任何规律。我们称这些为[*伪随机*](apd.html#gloss01_040)数，因为它们并不是*真正*随机的（`randint`命令基于复杂的数学模式告诉计算机接下来应该“选择”哪个数字），但它们*看起来*是随机的。
- en: 'Let’s put the `random` module to work in a program called *GuessingGame.py*.
    Type the following in a new IDLE window or download the program from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为*GuessingGame.py*的程序中使用`random`模块。请在新的IDLE窗口中键入以下内容，或者从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载该程序：
- en: GuessingGame.py
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GuessingGame.py
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At ➊, we import the `random` module, which gives us access to all functions
    defined in `random`, including `randint()`. At ➋, we write the module name, `random`,
    followed by a dot and the name of the function we want to use, `randint()`. We
    pass `randint()` the arguments `1` and `10` so it generates a pseudorandom number
    between 1 and 10, and we store the number in the variable `the_number`. This will
    be the secret number the user is trying to guess.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们导入了`random`模块，它为我们提供了对`random`中所有已定义函数的访问，包括`randint()`。在➋处，我们写下模块名称`random`，后面跟一个点和我们要使用的函数名`randint()`。我们将`1`和`10`作为参数传递给`randint()`，让它生成一个1到10之间的伪随机数字，并将该数字存储在变量`the_number`中。这将是用户尝试猜测的秘密数字。
- en: At ➌, we ask the user for a guess between 1 and 10, evaluate the number, and
    store it in the variable `guess`. Our game loop starts with the `while` statement
    at ➍. We’re using the `!=` (not equal to) operator to see if the guess is not
    equal to the secret number. If the user guesses the number on the first try, `guess
    != the_number` evaluates to `False` and the `while` loop doesn’t run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们要求用户在1到10之间猜一个数字，评估这个数字并将其存储在变量`guess`中。我们的游戏循环从➍处的`while`语句开始。我们使用`!=`（不等于）运算符检查猜测是否不等于秘密数字。如果用户第一次猜对了，`guess
    != the_number`的结果为`False`，那么`while`循环就不会执行。
- en: As long as the user’s guess is not equal to the secret number, we check with
    two `if` statements at ➎ and ➏ to see if the guess was too high (`guess > the_number`)
    or too low (`guess < the_number`) and then print a message to the user asking
    for another guess. At ➐, we accept another guess from the user and start the loop
    again, until the user guesses correctly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户的猜测不等于秘密数字，我们会通过两个`if`语句在➎和➏处检查猜测是太高（`guess > the_number`）还是太低（`guess <
    the_number`），然后打印一条消息要求用户再次猜测。在➐处，我们接受用户的另一个猜测并重新开始循环，直到用户猜对为止。
- en: At ➑, the user has guessed the number, so we tell them it was the right number,
    and our program ends. See [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers") for a few sample runs of the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在➑处，用户已经猜出了数字，所以我们告诉他们这是正确的数字，然后程序结束。有关程序的一些示例运行，请参见[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "图6-1. 我们的 GuessingGame.py 程序，要求用户猜测三个随机数字是更大还是更小")。
- en: '![Our GuessingGame.py program, asking the user to guess higher or lower for
    three random numbers](httpatomoreillycomsourcenostarchimages2188919.png.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![我们的 GuessingGame.py 程序，要求用户猜测三个随机数字是更大还是更小](httpatomoreillycomsourcenostarchimages2188919.png.jpg)'
- en: Figure 6-1. Our *GuessingGame.py* program, asking the user to guess higher or
    lower for three random numbers
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 我们的*GuessingGame.py*程序，要求用户猜测三个随机数字是更大还是更小
- en: In the first run of the program in [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers"), the user guessed 5, and the computer responded that
    5 was too high. The user guessed lower with 2, but 2 was too low. Then the user
    gave 3 a shot, and that was right! Guessing halfway between the lowest and highest
    possible numbers each time, as in the examples in [Figure 6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower
    for three random numbers"), is a strategy called a *binary search*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski "图6-1. 我们的GuessingGame.py程序，询问用户猜测更高或更低的三个随机数字")中程序的第一次运行中，用户猜测了5，计算机回应说5太高了。用户猜了2，结果是太低了。然后用户猜了3，正好！每次在最低和最高可能数字之间猜测一半的数字，就像[图6-1](ch06.html#our_guessinggamedotpy_programcomma_aski
    "图6-1. 我们的GuessingGame.py程序，询问用户猜测更高或更低的三个随机数字")中的例子一样，这种策略叫做*二分查找*。
- en: If players learn to use this strategy, they can guess a number between 1 and
    10 in four tries or less, every time! Give it a shot!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家学会了使用这个策略，他们每次都可以在四次尝试内猜出1到10之间的数字！试试看吧！
- en: To make the program more interesting, you could change the arguments you pass
    to the `randint()` function to generate a number between 1 and 100 or an even
    higher number (be sure to change the `input()` prompts as well). You could also
    make a variable called `number_of_tries` and add 1 to it every time the user guesses,
    to keep track of the user’s number of tries. Print the number of tries at the
    end of the program to let the user know how well they did. For an additional challenge,
    you could add an outer loop that asks the user if they want to play again after
    they guess the number correctly. Try these on your own, and go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample solutions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序更有趣，你可以改变传递给`randint()`函数的参数，生成1到100之间的数字，或者更大的数字（记得也要修改`input()`的提示）。你还可以创建一个名为`number_of_tries`的变量，每次用户猜测时将其加1，以跟踪用户的尝试次数。在程序结束时打印出尝试次数，让用户知道他们表现如何。为了增加额外的挑战，你可以添加一个外循环，在用户猜对数字后询问他们是否想重新开始游戏。自己试试这些，并访问*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*查看示例解决方案。
- en: Colorful Random Spirals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五彩斑斓的随机螺旋线
- en: 'The `random` module has other handy functions besides `randint()`. Let’s use
    them to help us create an interesting visual: a screen full of spirals of random
    sizes and colors like the one in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py").'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块除了`randint()`之外还有其他有用的函数。让我们使用它们来帮助我们创建一个有趣的视觉效果：屏幕上充满了像[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2. 屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py")那样的随机大小和颜色的螺旋线。'
- en: '![Spirals of random sizes and colors at random locations on the screen, from
    RandomSpirals.py](httpatomoreillycomsourcenostarchimages2188921.png.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py](httpatomoreillycomsourcenostarchimages2188921.png.jpg)'
- en: Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from *RandomSpirals.py*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. 屏幕上随机位置的随机大小和颜色的螺旋线，来自*RandomSpirals.py*
- en: 'Think about how you could write a program like the one that created [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py"). You know *almost* all of the tricks needed to draw random
    spirals like these. First, you can draw spirals of various colors using loops.
    You can generate random numbers and use one to control how many times each spiral’s
    `for` loop runs. This changes its size: more iterations create a bigger spiral,
    while fewer iterations create a smaller spiral. Let’s look at what else we’ll
    need and build the program step by step. (The final version is [RandomSpirals.py](ch06.html#randomspiralsdotpy
    "RandomSpirals.py").)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你如何编写一个程序，像创建[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra "图6-2.
    屏幕上随机位置的随机大小和颜色的螺旋线，来自RandomSpirals.py")那样的程序。你几乎*已经掌握*了绘制这些随机螺旋线所需的所有技巧。首先，你可以使用循环绘制不同颜色的螺旋线。你可以生成随机数，并使用其中一个来控制每个螺旋线的`for`循环运行的次数。这会改变它的大小：更多的迭代生成更大的螺旋，而较少的迭代生成较小的螺旋。让我们看看还需要什么，并一步一步构建程序。（最终版本是[RandomSpirals.py](ch06.html#randomspiralsdotpy
    "RandomSpirals.py")。）
- en: Pick a Color, Any Color
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一种颜色，任意颜色
- en: One new tool we’ll need is the ability to choose a random color. We can easily
    do this with another method in the `random` module, `random.choice()`. The `random.choice()`
    function takes a list or other collection as the argument (the part inside the
    parentheses), and it returns a randomly selected element from that collection.
    In our case, we could create a list of colors, and then pass that list to the
    `random.choice()` method to get a random color for each spiral.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的一个新工具是选择随机颜色的能力。我们可以使用`random`模块中的另一个方法`random.choice()`来轻松实现这一点。`random.choice()`函数将列表或其他集合作为参数（括号内的部分），并返回该集合中的随机选择元素。在我们的案例中，我们可以创建一个颜色列表，然后将该列表传递给`random.choice()`方法，为每个螺旋图形选择一个随机颜色。
- en: 'You can try this in the command line shell in IDLE:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在IDLE的命令行窗口中尝试以下操作：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we created our old friend `colors` and set it equal to a list
    of color names. Then we used the `random.choice()` function, passing it `colors`
    as its argument. The function chooses a color at random from the list. The first
    time, we got orange, the second time blue, the third time white, and so on. This
    function can give us a random color to set as our turtle’s pen color before it
    draws each new spiral.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了我们以前的老朋友`colors`并将其设置为一个颜色名称的列表。然后我们使用`random.choice()`函数，将`colors`作为参数传递给它。该函数会从列表中随机选择一个颜色。第一次，我们得到了橙色，第二次是蓝色，第三次是白色，依此类推。这个函数可以为我们提供一个随机颜色，用来在绘制每个新螺旋图形之前设置我们的乌龟的笔颜色。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188923.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188923.png.jpg)'
- en: Getting Coordinated
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取坐标
- en: One remaining problem is how to get the spirals to spread out all over the screen,
    including the upper-right and lower-left corners. To place spirals randomly on
    the turtle screen, we need to understand the x- and y-coordinate system used in
    our Turtle environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个剩下的问题是如何让螺旋图形在整个屏幕上展开，包括右上角和左下角。为了将螺旋图形随机放置在乌龟屏幕上，我们需要了解在我们的Turtle环境中使用的x和y坐标系统。
- en: Cartesian Coordinates
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笛卡尔坐标
- en: If you’ve taken a geometry course, you’ve seen (*x*, *y*) coordinates drawn
    on graph paper as in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates").
    These are *Cartesian* coordinates, named after French mathematician René Descartes,
    who labeled points on a grid with a pair of numbers we call the *x-* and *y-coordinates*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经上过几何学课程，你一定见过在图表纸上绘制的(*x*, *y*)坐标，如同[图6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "图6-3. 一个包含四个点及其笛卡尔（x, y）坐标的图表")所示。这些是*笛卡尔*坐标，得名于法国数学家勒内·笛卡尔，他用一对数字标记网格上的点，这些数字我们称之为*x-坐标*和*y-坐标*。
- en: In the graph in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates"),
    the dark horizontal line is called the *x-axis*, and it runs from left to right.
    The dark vertical line is the *y-axis*, running from bottom to top. We call the
    point where these lines meet, (0, 0), the *origin* because all other points on
    the grid are labeled with coordinates measured from, or *originating* from, that
    point. Think of the origin, (0, 0), as the center of your screen. Every other
    point you want to find can be labeled with an x- and y-coordinate by starting
    at the origin and moving left or right, down or up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-3](ch06.html#graph_with_four_points_and_their_cartesi "图6-3. 一个包含四个点及其笛卡尔（x,
    y）坐标的图表")中的图表中，深色的横线叫做*x轴*，它从左到右延伸。深色的竖线叫做*y轴*，从下到上延伸。我们称这两条线相交的点(0, 0)为*原点*，因为网格上的所有其他点都是以该点为起点，按坐标测量而得的。可以将原点(0,
    0)视为你的屏幕的中心。你想找到的每个其他点，都可以通过从原点出发，向左或向右、向下或向上移动来标记其x和y坐标。
- en: '![A graph with four points and their Cartesian (x, y) coordinates](httpatomoreillycomsourcenostarchimages2188925.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个点及其笛卡尔（x, y）坐标的图表](httpatomoreillycomsourcenostarchimages2188925.png)'
- en: Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. 一个包含四个点及其笛卡尔（x, y）坐标的图表
- en: 'We label points on a graph with this pair of coordinates inside parentheses,
    separated by a comma: (*x*, *y*)*.* The first number, the x-coordinate, tells
    us how far to move left or right, while the second number, the y-coordinate, tells
    us how far to move up or down. Positive x-values tell us to move right from the
    origin; negative x-values tell us to move left. Positive y-values tell us to move
    up from the origin, and negative y-values tell us to move down.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一对坐标放在括号内并用逗号分隔来标记图上的点：（*x*，*y*）。第一个数字x坐标告诉我们要向左或向右移动多远，而第二个数字y坐标告诉我们要向上或向下移动多远。正的x值告诉我们从原点向右移动；负的x值告诉我们向左移动。正的y值告诉我们从原点向上移动，负的y值告诉我们向下移动。
- en: Look at the points labeled in [Figure 6-3](ch06.html#graph_with_four_points_and_their_cartesi
    "Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates").
    The point in the upper right is labeled with the x- and y-coordinates (4, 3).
    To find the location of this point, we start at the origin (0, 0) and move 4 spaces
    to the right (because the x-coordinate, 4, is positive) and then 3 spaces up (because
    the y-coordinate, 3, is positive).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图6-3](ch06.html#graph_with_four_points_and_their_cartesi "图6-3：带有四个点及其笛卡尔坐标系（x，y）的图")中标记的各个点。右上方的点标注了x和y坐标(4,
    3)。为了找到这个点的位置，我们从原点(0, 0)开始，向右移动4个单位（因为x坐标4是正数），然后向上移动3个单位（因为y坐标3是正数）。
- en: To get to the point in the lower right, (3, –3), we go back to the origin and
    then move right 3 spaces or units. This time, the y-coordinate is –3, so we move
    *down* 3 units. Moving right 3 and down 3 puts us at (3, –3). For (–4, 2), we
    move *left* 4 units from the origin and then up 2 units to the point in the upper
    left. Finally, for (–3, –2), we move left 3 units and then down 2 units to the
    lower-left point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达右下角的点(3, –3)，我们先回到原点，然后向右移动3个单位。由于这次y坐标是–3，所以我们向*下*移动3个单位。向右移动3个单位并向下移动3个单位后，我们到达(3,
    –3)的位置。对于(–4, 2)，我们从原点向*左*移动4个单位，再向上移动2个单位，最终到达左上方的点。最后，对于(–3, –2)，我们向左移动3个单位，再向下移动2个单位，最终到达左下方的点。
- en: Setting a Random Turtle Position
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置随机海龟位置
- en: In turtle graphics, we can move the turtle from the origin (0, 0) to any other
    location by telling the computer the x- and y-coordinates of the new location
    with the `turtle.setpos(x,y)` command. The function name `setpos()` is short for
    *set position*. It sets the position of the turtle to the x- and y-coordinates
    we give it. For example, `turtle.setpos(10,10)` would move the turtle right 10
    units and up 10 units from the center of the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在海龟图形中，我们可以通过告诉计算机新位置的x和y坐标，使用`turtle.setpos(x, y)`命令将海龟从原点(0, 0)移动到任何其他位置。函数名`setpos()`是*设置位置*的缩写。它将海龟的位置设置为我们给定的x和y坐标。例如，`turtle.setpos(10,10)`将把海龟从屏幕中心向右移动10个单位并向上移动10个单位。
- en: On the computer, the unit we usually use is our old friend the [*pixel*](apd.html#gloss01_038).
    So `turtle.setpos(10,10)` would move the turtle right 10 pixels and up 10 pixels
    from the center of the screen. Because pixels are so tiny—about 1/70 of an inch
    (0.3 millimeters) or smaller on most displays—we might want to move 100 pixels
    or more at a time. `setpos()` can handle any coordinates we give it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，我们通常使用的单位是我们老朋友[*像素*](apd.html#gloss01_038)。所以`turtle.setpos(10,10)`将把海龟从屏幕中心向右移动10个像素并向上移动10个像素。由于像素非常小——在大多数显示器上大约是1/70英寸（0.3毫米）或更小——我们可能希望一次移动100个像素或更多。`setpos()`可以处理我们给定的任何坐标。
- en: 'To move the turtle to a random location on the screen, we’ll generate a random
    pair of numbers, `x` and `y`, then use `turtle.setpos(x,y)` to move the turtle
    to those coordinates. Before we move the turtle, though, we’ll need to lift the
    turtle’s pen with `turtle.penup()`. After we’ve set the new position, we’ll call
    `turtle.pendown()` to put the pen back down and enable the turtle to draw again.
    If we forget to lift the pen, the turtle will draw a line as it moves to wherever
    we tell it to go with `setpos()`. As you can see in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py"), we don’t want extra lines between our spirals. Our code
    will look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将海龟移动到屏幕上的一个随机位置，我们将生成一对随机数字 `x` 和 `y`，然后使用 `turtle.setpos(x,y)` 将海龟移动到这些坐标。但在移动海龟之前，我们需要用
    `turtle.penup()` 抬起海龟的笔。在设置新位置后，我们会调用 `turtle.pendown()` 将笔放下，允许海龟再次绘图。如果我们忘记抬起笔，海龟在通过
    `setpos()` 移动到指定位置时会绘制一条线。正如你在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2：屏幕上随机位置的随机大小和颜色的螺旋，来自 RandomSpirals.py")中看到的那样，我们不希望螺旋之间有额外的线条。我们的代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `setpos()` function combined with a couple of random numbers as (*x*, *y*)
    coordinates will let us place spirals in different locations, but how do we know
    what range to use for our random numbers? That question brings us to the last
    issue we have to resolve in our quest for random spirals.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`setpos()` 函数结合几个随机数字作为 (*x*, *y*) 坐标，可以让我们把螺旋图形放置在不同的位置，但我们如何知道应该使用什么范围来生成随机数呢？这个问题引出了我们在寻找随机螺旋时必须解决的最后一个问题。'
- en: How Big Is Our Canvas?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的画布有多大？
- en: 'Now that we know how to position spirals at random locations on the window,
    or canvas, we have one problem remaining: how do we know how big our canvas is?
    We can generate a random number for the x- and y-coordinates of a location and
    draw a spiral at that location, but how can we make sure that the location we
    choose is on the visible window—not off the window to the right, left, top, or
    bottom? Then, how can we make sure we cover the entire drawing window, from left
    to right, top to bottom?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将螺旋图形随机放置在窗口或画布的不同位置，但仍然有一个问题：我们如何知道画布的大小呢？我们可以为一个位置生成随机的 x 和 y 坐标，并在该位置绘制一个螺旋，但我们如何确保所选的位置在可视窗口内，而不是位于窗口的右侧、左侧、顶部或底部之外呢？然后，我们如何确保从左到右、从上到下覆盖整个绘图窗口呢？
- en: To answer the question about canvas size, we need to use two more functions,
    `turtle.window_width()` and `turtle.window_height()`. First, `window_width()`
    tells us how wide our turtle window is, in pixels. The same goes for `window_height()`;
    we get the number of pixels from the bottom of our turtle window to the top. For
    example, our turtle window in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py") is 960 pixels wide and 810 pixels tall.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答有关画布大小的问题，我们需要使用两个额外的函数，`turtle.window_width()` 和 `turtle.window_height()`。首先，`window_width()`
    会告诉我们海龟窗口的宽度，单位是像素。同样，`window_height()` 会告诉我们从海龟窗口底部到顶部的像素数。例如，我们的海龟窗口在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2：屏幕上随机位置的随机大小和颜色的螺旋，来自 RandomSpirals.py")中宽度为960像素，高度为810像素。
- en: '`turtle.window_width()` and `turtle.window_height()` will help us with random
    x- and y-coordinates, but we have one more obstacle. Remember that in turtle graphics,
    the center of the window is the origin, or (0, 0). If we just generate random
    numbers between 0 and `turtle.window_width()`, the first problem is that we will
    never draw anything in the lower left of the window: the coordinates there are
    negative in both the x- and y-directions (left and down), but a random number
    between 0 and our `window_width()` value is always positive. The second problem
    is that if we start from the center and go `window_width()` to the right, we’ll
    end up off the righthand edge of the window.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.window_width()` 和 `turtle.window_height()` 将帮助我们确定随机的 x 和 y 坐标，但我们还面临一个障碍。记住，在海龟图形中，窗口的中心是原点，即
    (0, 0)。如果我们只是生成介于 0 和 `turtle.window_width()` 之间的随机数，第一个问题是我们永远无法在窗口的左下角绘制任何东西：那里坐标在
    x 轴和 y 轴上都是负数（向左和向下），但一个介于 0 和 `window_width()` 之间的随机数总是正数。第二个问题是，如果我们从中心开始，向右移动
    `window_width()`，我们就会超出窗口的右边界。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188927.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188927.png.jpg)'
- en: We have to figure out not just how wide and tall the window is but also what
    the range of the coordinates is. For example, if our window is 960 pixels wide
    and the origin (0, 0) is at the center of our window, we need to know how many
    pixels we can move to the right and left without leaving the visible window. Because
    (0, 0) is in the middle of our window, halfway across, we just divide the width
    in half. If the origin is in the middle of a window that is 960 pixels across,
    there are 480 pixels to the right of the origin and 480 pixels to the left of
    the origin. The range of x-coordinate values would be from –480 (left 480 pixels
    from the origin) to +480 (480 pixels right of the origin) or, in other words,
    from –960/2 to +960/2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要弄清楚窗口的宽度和高度，还需要了解坐标的范围。例如，如果我们的窗口宽度为960像素，并且原点(0, 0)位于窗口的中心，我们需要知道可以向右和向左移动多少像素而不超出可视窗口。因为原点(0,
    0)位于窗口的正中间，所以我们只需要将宽度除以二。如果原点位于一个宽度为960像素的窗口的中心，那么原点右侧有480像素，左侧也有480像素。x坐标的范围将是从–480（从原点向左480像素）到+480（从原点向右480像素），换句话说，就是从–960/2到+960/2。
- en: To make our range work for any size window, we would say the x-coordinates go
    from `-turtle.window_width()//2` to `+turtle.window_ width()//2`. Our origin is
    also in the middle of the window from bottom to top, so there are `turtle.window_height()//2`
    pixels above and below the origin. We use integer division, the `//` operator,
    in these calculations to make sure we’ll get an integer result when we divide
    by 2; a window could measure an odd number of pixels wide, and we want to keep
    all our pixel measurements in whole numbers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的范围适用于任何大小的窗口，我们可以这样写，x坐标的范围从`-turtle.window_width()//2`到`+turtle.window_width()//2`。我们的原点也位于窗口从上到下的中间，所以原点上方和下方各有`turtle.window_height()//2`像素。我们在这些计算中使用整数除法，即`//`运算符，以确保在除以2时得到整数结果；因为窗口的宽度可能是奇数像素，我们希望保持所有像素测量值为整数。
- en: 'Now that we know how to calculate the size of our canvas, we can use these
    expressions to limit the range of our random coordinates. Then we can be sure
    that any random coordinates we generate will be visible in our window. The `random`
    module in Python has a function that lets us generate a random number within a
    specified range: `randrange()`. We just tell the `randrange()` function to use
    negative one-half the window width as the start value for the range and positive
    one-half the window width as the end value for the range (we’ll have to import
    both `turtle` and `random` in our program to make these lines work):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何计算画布的大小了，我们可以使用这些表达式来限制随机坐标的范围。这样，我们就能确保生成的任何随机坐标都能在我们的窗口中可见。Python中的`random`模块有一个函数，可以让我们在指定的范围内生成一个随机数：`randrange()`。我们只需要告诉`randrange()`函数，以窗口宽度的一半负值作为范围的起始值，以窗口宽度的一半正值作为范围的结束值（我们需要在程序中导入`turtle`和`random`，才能让这些代码行生效）：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines of code will use the `randrange()` function to generate a pair of
    (*x*, *y*) coordinate values that are always on the viewing window and cover the
    full area of the viewing window from left to right, bottom to top.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行将使用`randrange()`函数生成一对(*x*, *y*)坐标值，这些坐标始终位于视图窗口内，并覆盖视图窗口的整个区域，从左到右，从下到上。
- en: Putting It All Together
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有部分整合在一起
- en: Now we have all the pieces—we just have to put them together to build a program
    that will draw random spirals in different colors, sizes, and locations. Here’s
    our finished *RandomSpirals.py* program; in just about 20 lines, it creates the
    kaleidoscope-like picture in [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py").
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的部分——我们只需要将它们组合在一起，构建一个程序，用于在不同的颜色、大小和位置上绘制随机的螺旋线。以下是我们完成的*RandomSpirals.py*程序；仅用大约20行代码，它就能在[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "图6-2. 在屏幕上随机位置绘制随机大小和颜色的螺旋线，来自RandomSpirals.py")中创建出类似万花筒的图像。
- en: RandomSpirals.py
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RandomSpirals.py
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First we import the `random` and `turtle` modules and set up our turtle window
    and a list of colors. At our `for` loop (`n` will go from `0` to `49` to give
    us 50 spirals total), things get interesting. At ➊, we pass `colors` to `random.choice()`
    to have the function choose a random color from the list. We pass the random color
    choice to `t.pencolor()` to set the turtle’s pen color to that random color. At
    ➋, `random.randint(10,40)` picks a random number from 10 to 40\. We store that
    number in the variable `size`, which we’ll use at ➑ to tell Python how many lines
    to draw in a spiral. The lines at ➌ and ➍ are exactly the ones we built earlier
    to generate a random pair of coordinate values (*x*, *y*) that give us a random
    location on our viewing window.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`random`和`turtle`模块，并设置我们的海龟窗口和颜色列表。在我们的`for`循环中（`n`将从`0`到`49`，总共绘制50个螺旋），事情变得有趣起来。在➊处，我们将`colors`传递给`random.choice()`，让这个函数从列表中随机选择一种颜色。然后我们将随机选择的颜色传递给`t.pencolor()`，以将海龟的笔颜色设置为该随机颜色。在➋处，`random.randint(10,40)`从10到40之间随机选取一个数字。我们将这个数字存储在变量`size`中，并在➑处使用它来告诉Python绘制螺旋的线条数。➌和➍处的代码正是我们之前编写的，用来生成一对随机坐标值（*x*，*y*），从而给我们提供一个随机位置，用于在视图窗口中显示螺旋。
- en: At ➎, we lift the turtle’s pen off the virtual paper before we move the turtle
    to its new random location. At ➏, we move the turtle to its new location by setting
    its position to `x` and `y`, the random coordinates chosen by `randrange()` earlier.
    Now that the turtle is in position, we put the pen back down at ➐ so we’ll be
    able to see the spiral we’re about to draw. At ➑, we have a `for` loop to draw
    each line of the spiral. For `m` in `range(size)`, the turtle will move forward
    a distance of `m*2`, drawing a line segment of length `m*2` (`m` is `0`, `1`,
    `2`, `3`, and so on, so the length of the segment is 0, 2, 4, 6, and so on). The
    turtle will then rotate left 91 degrees and get ready to draw the next segment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎处，我们在将海龟移动到新的随机位置之前，先抬起海龟的笔。在➏处，我们通过设置海龟的位置为`x`和`y`，即之前通过`randrange()`选择的随机坐标，来将海龟移动到新位置。现在海龟已到达目标位置，我们在➐处放下笔，这样我们就能看到我们即将绘制的螺旋。在➑处，我们有一个`for`循环来绘制螺旋的每一条线。在`range(size)`中，海龟会前进`m*2`的距离，绘制一段长度为`m*2`的线段（`m`为`0`，`1`，`2`，`3`，以此类推，所以线段的长度分别为0、2、4、6等）。然后海龟会向左旋转91度，为绘制下一段线段做好准备。
- en: The turtle starts in the center of the spiral, draws a segment (length 0), and
    rotates left; that’s the first time through the loop. The next time through, `m`
    is `1`, so the turtle draws a segment of length 2, then rotates. As Python iterates
    through the loop, the turtle will move outward from the center of the spiral,
    drawing longer and longer line segments. We use the randomly generated `size`,
    an integer between 10 and 40, as the number of lines we draw in our spiral.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟从螺旋的中心开始，绘制一个长度为0的线段，然后向左旋转；这就是第一次进入循环。下一次进入时，`m`为`1`，于是海龟绘制一个长度为2的线段，然后旋转。随着Python在循环中迭代，海龟将从螺旋的中心向外移动，绘制越来越长的线段。我们使用随机生成的`size`，它是一个介于10到40之间的整数，表示我们在螺旋中绘制的线条数。
- en: After we finish drawing the current spiral, we go back to the top of our outer
    `for` loop. We pick a new random color, size, and location; lift the pen; move
    it to the new location; put down the pen; and go through the inner `for` loop
    to draw a new spiral of some new random size. After drawing this spiral, we go
    back to the outer loop and repeat the entire process. We do this 50 times, giving
    us 50 spirals of assorted colors and shapes spread randomly across the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制完当前螺旋之后，我们回到外部`for`循环的顶部。我们选择一个新的随机颜色、大小和位置；抬起笔；将海龟移动到新位置；放下笔；然后进入内部`for`循环绘制一个新的随机大小的螺旋。绘制完这个螺旋后，我们返回外部循环并重复整个过程。我们这样做50次，最终得到50个颜色和形状各异的螺旋，随机分布在屏幕上。
- en: Rock-Paper-Scissors
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 石头剪刀布
- en: 'One game that we have the skills to program now is Rock-Paper-Scissors. Two
    players (or one player and the computer) each pick one of three possible items
    (rock, paper, or scissors); both show their choice; and the winner is decided
    by three rules: rock crushes scissors, scissors cut paper, paper covers rock.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了编程的技能，可以编写一个游戏：石头剪刀布。两个玩家（或一个玩家和计算机）各自选择三个可能项之一（石头、剪刀或布）；然后双方展示各自的选择；胜者根据三个规则判定：石头压剪刀，剪刀剪布，布包石头。
- en: To simulate this game, we’ll create a list of choices (like our `colors` list
    in *RandomSpirals.py*) and we’ll use `random.choice()` to pick one of the three
    items from the list as the computer’s choice. Then, we’ll ask the user for their
    choice and use a series of `if` statements to determine the winner. The user will
    be playing against the computer!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个游戏，我们将创建一个选择列表（就像我们在 *RandomSpirals.py* 中的 `colors` 列表），然后使用 `random.choice()`
    从列表中随机选择三个项目中的一个作为计算机的选择。接着，我们将询问用户的选择，并使用一系列 `if` 语句来确定胜者。用户将与计算机对战！
- en: Let’s jump into the code. Type *RockPaperScissors.py* into a new window in IDLE
    or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入代码吧。在 IDLE 中新建一个窗口，输入 *RockPaperScissors.py*，或者从 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载它。
- en: RockPaperScissors.py
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RockPaperScissors.py
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ➊, we import the `random` module to get access to the functions that help
    us make random choices. At ➋, we set up the list of the three items—rock, paper,
    and scissors—and call the list `choices`. We print the simple rules of the game
    to make sure the user knows them. At ➌, we prompt the user to input their choice
    of `rock`, `paper`, `scissors`, or `quit` and store their choice in the variable
    `player`. At ➍, we begin the game loop by checking whether the user chose `quit`
    at the input prompt; if they did, the game ends.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们导入 `random` 模块，以便访问帮助我们做出随机选择的函数。在 ➋，我们设置包含三项（石头、纸和剪刀）的列表，并将其命名为 `choices`。我们打印游戏的简单规则，确保用户了解它们。在
    ➌，我们提示用户输入他们的选择：`rock`、`paper`、`scissors` 或 `quit`，并将他们的选择存储在变量 `player` 中。在 ➍，我们通过检查用户是否在输入提示中选择了
    `quit` 来开始游戏循环；如果选择了，游戏结束。
- en: As long as the user has not entered `quit`, the game begins. After changing
    the player’s input to lowercase for easy comparison in our `if` statements, we
    tell the computer to pick an item. At ➎, we tell the computer to pick at random
    one of the items in the list `choices` and store the item in the variable `computer`.
    Once the computer’s choice is stored, it’s time to begin testing to see who won.
    At ➏, we check whether the player and the computer picked the same item; if so,
    we tell the user that the outcome was a tie. Otherwise, we check at ➐ whether
    the user selected `rock`. Inside the `elif` statement at ➐, we nest an `if` statement
    to see whether the computer picked `scissors`. If our player picks rock and the
    computer chooses scissors, rock crushes scissors, and the player wins! If it’s
    not rock and rock, and if the computer didn’t pick scissors, then the computer
    must have picked paper, and we print that the computer wins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户没有输入 `quit`，游戏就开始了。在将玩家输入转换为小写以便在我们的 `if` 语句中进行比较后，我们让计算机选择一个项目。在 ➎，我们让计算机从列表
    `choices` 中随机选择一个项目，并将该项目存储在变量 `computer` 中。计算机的选择存储后，就可以开始测试谁赢了。在 ➏，我们检查玩家和计算机是否选择了相同的项目；如果是这样，我们告诉用户结果是平局。否则，我们在
    ➐ 检查用户是否选择了 `rock`。在 ➐ 的 `elif` 语句中，我们嵌套一个 `if` 语句来检查计算机是否选择了 `scissors`。如果玩家选择了石头，而计算机选择了剪刀，那么石头砸剪刀，玩家获胜！如果不是石头对石头，并且计算机没有选择剪刀，那么计算机一定选择了纸，并且我们会打印出计算机获胜。
- en: 'At the remaining two `elif` statements, ➑ and ➒, we do the same testing to
    check for wins when the user picks paper or scissors. If none of those statements
    was true, we let the user know they’ve entered something that did not compute:
    either they made a choice that doesn’t exist, or they misspelled their choice.
    Finally, at ➓, we ask the user for their next choice before beginning the game
    loop all over again (a new round). See [Figure 6-4](ch06.html#thanks_to_random_choices_by_the_computer
    "Figure 6-4. Thanks to random choices by the computer, RockPaperScissors.py is
    a fun game!") for a sample run of the program.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩下的两个 `elif` 语句中，➑ 和 ➒，我们做相同的测试，以检查玩家选择纸或剪刀时谁获胜。如果这些语句都不成立，我们会告诉用户他们输入了一个无法识别的选项：要么是选择的项目不存在，要么是他们拼写错误。最后，在
    ➓，我们让用户输入下一个选择，然后重新开始游戏循环（即新的一轮）。请参见 [图 6-4](ch06.html#thanks_to_random_choices_by_the_computer
    "图 6-4。感谢计算机的随机选择，RockPaperScissors.py 是一款有趣的游戏！")，了解程序的示例运行。
- en: '![Thanks to random choices by the computer, RockPaperScissors.py is a fun game!](httpatomoreillycomsourcenostarchimages2188929.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![感谢计算机的随机选择，RockPaperScissors.py 是一款有趣的游戏！](httpatomoreillycomsourcenostarchimages2188929.png.jpg)'
- en: Figure 6-4. Thanks to random choices by the computer, *RockPaperScissors.py*
    is a fun game!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4。感谢计算机的随机选择，*RockPaperScissors.py* 是一款有趣的游戏！
- en: Sometimes the user wins, sometimes the computer wins, and sometimes they tie.
    Because the outcome is somewhat random, the game is fun enough to play to pass
    a little time. Now that we have a sense of how a game with two players can use
    the computer’s random choices, let’s try creating a card game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用户获胜，有时计算机获胜，有时则是平局。由于结果具有一定的随机性，游戏足够有趣，可以用来打发一些时间。现在我们对两人对战的游戏如何利用计算机的随机选择有了初步的了解，接下来让我们尝试创建一个扑克牌游戏。
- en: Pick a Card, Any Card
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选一张牌，任意一张牌
- en: One thing that makes card games fun is randomness. No two rounds turn out exactly
    the same (unless you’re bad at shuffling), so you can play again and again without
    getting bored.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让扑克牌游戏有趣的一件事就是随机性。每一轮的结果都不完全相同（除非你洗牌技术差），所以你可以一遍又一遍地玩，而不会觉得无聊。
- en: We can program a simple card game with the skills we’ve learned. Our first try
    at this won’t show graphical playing cards (we need to learn more tricks to make
    that possible), but we can generate a random card name (“two of diamonds” or “king
    of spades,” for example) just by using an [*array*](apd.html#gloss01_006), or
    list, of strings, like we did with color names in our spiral programs. We could
    program a game like War in which two players each pull a random card from the
    deck, and the player with the higher card wins; we just need some way of comparing
    cards to see which is higher. Let’s see how that might work, step by step. (The
    final program is [HighCard.py](ch06.html#highcarddotpy "HighCard.py").)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们学到的技能编写一个简单的扑克牌游戏。我们第一次尝试时不会显示图形牌面（我们需要学更多技巧才能实现），但我们可以通过使用一个[*数组*](apd.html#gloss01_006)，或字符串列表，像在螺旋程序中使用颜色名称一样，生成一个随机的卡牌名称（比如“二点红心”或“黑桃国王”）。我们可以编写一个像“战争”游戏的程序，在游戏中两名玩家各自从牌组中抽一张随机卡牌，拥有更大卡牌的一方获胜；我们只需要找到一种方法来比较卡牌大小。让我们一步一步看看这个过程是如何工作的。（最终的程序是[HighCard.py](ch06.html#highcarddotpy
    "HighCard.py")。）
- en: Stacking the Deck
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆叠牌组
- en: First, we need to think about how to build a virtual deck of cards in our program.
    As I mentioned, we won’t draw the cards yet, but we at least need the card names
    to simulate a deck. Fortunately, card names are just strings (`"two of diamonds"`,
    `"king of spades"`), and we know how to build an array of strings—we’ve done it
    with color names since the very first chapter!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑如何在程序中构建一个虚拟的牌组。正如我之前提到的，我们暂时不会绘制牌面，但至少需要卡牌的名称来模拟牌组。幸运的是，卡牌名称只是字符串（`"二点红心"`,
    `"黑桃国王"`），而且我们知道如何构建字符串数组——从第一章开始，我们就已经用颜色名称做过类似的事情了！
- en: An *array* is an ordered or numbered collection of similar things. In many programming
    languages, arrays are a special type of collection. In Python, though, lists can
    be used like arrays. We’ll see how to treat a list like an array in this section,
    accessing individual elements in the array one at a time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是一个有序的或编号的相似事物的集合。在许多编程语言中，数组是一种特殊类型的集合。然而，在Python中，列表可以像数组一样使用。在本节中，我们将看到如何将列表当作数组来处理，逐个访问数组中的元素。'
- en: 'We could build a list of all the card names by creating an array name (`cards`)
    and setting it equal to a list of all 52 card names:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个数组名称（`cards`），并将其设置为包含所有52张卡牌名称的列表，来构建一个包含所有卡牌名称的列表：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But ouch—we’re going to have to type 52 long strings of card names! Our code
    will be 52 lines long before we even program the game part, and we’ll be so tired
    from typing that we won’t have energy left to play the game. There’s got to be
    a better way. Let’s think like a programmer! All of that typing is repetitive,
    and we want to let the computer do the repetitive work. The suit names (*diamonds*,
    *hearts*, *clubs*, *spades*) are going to be repeated 13 times each, for the 13
    cards in each suit. The face values (*two* through *ace*) are going to be repeated
    4 times each, because there are 4 suits. Worse, we’re typing the word *of* 52
    times!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但哎呀——我们得输入52个长字符串的卡牌名称！在我们甚至开始编写游戏部分之前，代码就已经有52行了，而且我们会因为输入太多而感到疲惫，甚至没力气玩游戏。肯定有更好的方法。让我们像程序员一样思考！这些输入是重复的，我们想让计算机来做这些重复的工作。花色名称（*方块*,
    *红心*, *梅花*, *黑桃*）每个会重复13次，因为每个花色有13张卡牌。面值（*二点*到*王牌*）每个会重复4次，因为有4种花色。更糟的是，我们还要输入52次*of*这个词！
- en: 'When we ran into repetition before, we used loops to make the problem easier.
    If we wanted to generate the whole deck of cards, a loop would do the job nicely.
    But we don’t need the whole deck to play a single hand of War: we just need two
    cards, the computer’s card and the player’s. If a loop won’t help us avoid repeating
    all those suits and face values, we need to break the problem down further.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前遇到重复时，我们使用了循环来简化问题。如果我们想生成整个卡牌堆，循环会做得很好。但我们并不需要整个卡牌堆来玩一局战争游戏：我们只需要两张卡牌，计算机的卡牌和玩家的卡牌。如果循环不能帮助我们避免重复所有这些花色和面值，我们需要进一步拆解问题。
- en: 'In War, each player shows one card, and the higher card wins. So as we’ve discussed,
    we need just 2 cards, not 52\. Let’s start with one card. A card name consists
    of a face value (two through ace) and a suit name (clubs through spades). Those
    look like good possibilities for lists of strings: one list for faces and one
    for suits. Instead of using a list of 52 repeated entries for each separate card,
    we pick a face value at random from the list of 13 possibilities, then pick a
    suit name at random from the 4 possible choices. This approach should let us generate
    any single card in the deck.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在战争游戏中，每个玩家出一张卡牌，较高的卡牌获胜。所以，正如我们讨论过的，我们只需要两张卡牌，而不是52张。让我们从一张卡牌开始。卡牌名称由一个面值（从二到A）和一个花色名称（从梅花到黑桃）组成。这些看起来非常适合用作字符串列表：一个列表存储面值，一个列表存储花色。我们不再使用包含52个重复条目的列表来表示每一张卡牌，而是从13个可能的面值中随机选择一个面值，然后从4个可能的花色中随机选择一个花色。这个方法应该能帮助我们生成卡牌堆中的任何一张卡。
- en: 'We replace our long array `cards` with two much shorter arrays, `suits` and
    `faces`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前的长数组`cards`替换成了两个更短的数组，`suits`和`faces`：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We reduced 52 lines of code to about 3! That’s smart programming. Now let’s
    see how to use these two arrays to deal a card.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把52行代码减少到了大约3行！这真是聪明的编程。现在让我们来看如何使用这两个数组发牌。
- en: Dealing Cards
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发牌
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188931.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages2188931.png.jpg)'
- en: We already know how to use the `random.choice()` function to pick an item at
    random from a list. So to deal a card, we simply use `random.choice()` to pick
    a face value from a list of faces and a suit name from a list of suits. Once we
    have a random face and a random suit, all we do to complete a card name is add
    the word *of* between them (*two of diamonds*, for example).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用`random.choice()`函数从列表中随机选择一个项目。所以要发牌，我们只需使用`random.choice()`从花色列表中随机选取一个面值，并从套牌列表中随机选取一个花色。一旦我们有了随机的面值和花色，完成卡片名称的唯一操作就是在它们之间加上*of*这个词（例如，*two
    of diamonds*）。
- en: Notice that we might deal the same card twice or more in a row using `random.choice()`
    this way. We’re not forcing the program to check whether a card has already been
    dealt, so you might get two aces of spades in a row, for example. The computer’s
    not cheating; we’re just not telling it to deal from a single deck. It’s like
    this program is dealing cards from an *infinite deck*, so it can keep dealing
    forever without running out.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`random.choice()`这种方式，我们可能会连续发出相同的卡牌。我们没有强制程序检查卡牌是否已经发出，所以你可能会连续两次发到黑桃A。例如，计算机并没有作弊；我们只是没有告诉它只能从一副牌中发牌。这就像程序从一个*无限的牌堆*中发牌一样，它可以永远发下去而不会用完。
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you try running this code, you’ll get a new, random card every time. To deal
    a second card, you’d use similar code, but you’d store the random choices in variables
    called `your_face` and `your_suit`. You’d change the `print` statement so it printed
    the name of this new card. Now we’re getting closer to our game of War, but we
    need some way to compare the computer’s card and the user’s card to see who wins.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这段代码，每次都会得到一张新的随机卡牌。要发第二张卡牌，你可以使用类似的代码，但你会把随机选出的值存储在名为`your_face`和`your_suit`的变量中。你需要修改`print`语句，以便打印这张新卡的名称。现在，我们离战争游戏的实现更近了一步，但我们还需要一种方法来比较计算机的卡和玩家的卡，看看谁赢了。
- en: Counting Cards
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数卡牌
- en: There’s a reason we listed face card values in ascending order, from two through
    ace. We want the cards’ `faces` list to be ordered by value from lowest to highest
    so that we can compare cards against each other and see which card in any pair
    has the higher value. It’s important to determine which of two cards is higher,
    since in War the higher card wins each hand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将面牌值按升序排列的原因，从二到王牌，是希望卡牌的`faces`列表按从低到高的顺序排列，以便我们能相互比较卡牌，看看任意一对卡牌中哪一张的值更高。确定两张卡牌中哪一张更高很重要，因为在战争游戏中，较高的卡牌获胜。
- en: Finding an Item in a List
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在列表中查找项目
- en: Fortunately, because of the way lists and arrays work in Python, we can determine
    where a value occurs in a list, and we can use that information to decide whether
    one card is higher than another. The position number of an item in a list or array
    is called the *index* of that item. We usually refer to each item in an array
    by its index.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于 Python 中列表和数组的工作方式，我们可以确定一个值在列表中出现的位置，并且可以利用这个信息来判断一张牌是否比另一张大。列表或数组中一个项的位置编号称为该项的*索引*。我们通常通过索引来引用数组中的每一项。
- en: For a visual representation of the `suits` array and the index of each suit,
    see [Table 6-1](ch06.html#suits_array "Table 6-1. The suits Array").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `suits` 数组及每个花色的索引的可视化表示，请参见 [表 6-1](ch06.html#suits_array "表 6-1. The suits
    Array")。
- en: Table 6-1. The `suits` Array
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1. `suits` 数组
- en: '| **value** | `"clubs"` | `"diamonds"` | `"hearts"` | `"spades"` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **值** | `"clubs"` | `"diamonds"` | `"hearts"` | `"spades"` |'
- en: '| [*index*](apd.html#gloss01_026) | `0` | `1` | `2` | `3` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| [*索引*](apd.html#gloss01_026) | `0` | `1` | `2` | `3` |'
- en: When we create our list `suits`, Python automatically assigns an index to each
    value in the list. The computer starts counting at zero, so the index of `"clubs"`
    is `0`, `"diamonds"` is at index `1`, and so on. The function to find the index
    of an item in a list is `.index()`, and it can be used on any list or array in
    Python.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建列表 `suits` 时，Python 会自动为列表中的每个值分配一个索引。计算机从零开始计数，因此 `"clubs"` 的索引是 `0`，`"diamonds"`
    的索引是 `1`，以此类推。查找列表中某个项的索引的函数是 `.index()`，它可以用于 Python 中的任何列表或数组。
- en: 'To find the index of the suit name `"clubs"` in the list `suits`, we call the
    function `suits.index("clubs")`. It’s like we’re asking the `suits` array which
    index corresponds to the value `"clubs"`. Let’s try that in our Python shell.
    Enter the following lines:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找花色名称 `"clubs"` 在列表 `suits` 中的索引，我们调用函数 `suits.index("clubs")`。就像我们在询问 `suits`
    数组哪个索引对应于值 `"clubs"`。让我们在 Python shell 中试试这个操作。输入以下行：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we create the array of suit values, `suits`, we ask Python what the index
    of the value `"clubs"` is, and it responds with the correct index, `0`. In the
    same way, the index of `"spades"` is `3`, and diamonds and hearts are at index
    locations `1` and `2`, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了花色值的数组 `suits` 后，我们向 Python 询问值 `"clubs"` 的索引是什么，它会返回正确的索引 `0`。同样，`"spades"`
    的索引是 `3`，而 `"diamonds"` 和 `"hearts"` 分别位于索引 `1` 和 `2`。
- en: Which Card is Higher?
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪张牌更大？
- en: We created our `faces` array with values in order from `two` to `ace`, so the
    value `two`, the first item in `faces`, would get the index `0`, all the way through
    the `ace` at index `12` (the 13th location, starting from 0). We can use the index
    to test which card value is higher—in other words, which face value’s index is
    larger. Our lowest card is `two`, and its index is the smallest, `0`; the `ace`
    is our highest card, and its index is the largest, `12`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从 `two` 到 `ace` 的 `faces` 数组，因此值 `two`（即 `faces` 中的第一个项）会得到索引 `0`，直到
    `ace` 位于索引 `12`（从 0 开始的第 13 个位置）。我们可以通过索引来判断哪张牌的值更大——换句话说，哪个面值的索引更大。我们最小的牌是 `two`，它的索引是最小的
    `0`；最大的牌是 `ace`，它的索引是最大的 `12`。
- en: If we generate two random face card values (`my_face` and `your_face`), we can
    compare the index of `my_face` with the index of `your_face` to see which card
    is higher, as follows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生成两个随机的面牌值（`my_face` 和 `your_face`），我们可以比较 `my_face` 的索引与 `your_face` 的索引，看看哪张牌更大，如下所示。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use `random.choice()` twice to pull two random values out of the `faces`
    array, and then we store the values in `my_face` and `your_face`. We use `faces.index(my_face)`
    to find the index of `my_face` in `faces`, and we use `faces.index(your_face)`
    to get the index of `your_face`. If the index of `my_face` is higher, my card
    has a higher face value, and the program prints `I win!`. Otherwise, if the index
    of `my_face` is lower than the index of `your_face`, your card’s face value is
    higher, and the program prints `You win!`. Because of the way we ordered our list,
    a higher card will always correspond to a higher index. With this handy tool,
    we’ve got almost everything we need to build a “high card” game like War. (We
    haven’t added the ability to test for a tie game yet, but we’ll add that as part
    of the complete program in [Putting It All Together](ch06.html#putting_it_all_together-id00009
    "Putting It All Together").)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`random.choice()`两次，从`faces`数组中抽取两个随机值，然后将这些值存储在`my_face`和`your_face`中。我们使用`faces.index(my_face)`来查找`my_face`在`faces`中的索引，使用`faces.index(your_face)`来获取`your_face`的索引。如果`my_face`的索引较大，那么我的卡牌面值较高，程序会输出`我赢了！`。否则，如果`my_face`的索引低于`your_face`的索引，那么你的卡牌面值较高，程序会输出`你赢了！`。由于我们按顺序排列了列表，更高的卡牌总是对应较高的索引。有了这个方便的工具，我们几乎拥有了构建“高牌”游戏（如战争游戏）所需的一切。（我们还没有加入检测平局的功能，但我们会在[完整程序整合](ch06.html#putting_it_all_together-id00009
    "Putting It All Together")部分添加这个功能。）
- en: Keeping It Going
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让游戏继续进行
- en: The final tool we need is a loop so the user can keep playing as long as they
    want. We’re going to build this loop a little differently so that we can reuse
    it in other games.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最终工具是一个循环，让用户可以继续玩游戏，直到他们愿意为止。我们将稍微不同地构建这个循环，以便能够在其他游戏中重用它。
- en: First, we need to decide which kind of loop to use. Remember that a `for` loop
    usually means we know exactly the number of times we want to do something. Because
    we can’t always predict how many times someone will want to play our game, a `for`
    loop is not the right fit. A `while` loop can keep going until some condition
    becomes false—for example, when the user presses a key to end the program. The
    `while` loop is what we’ll use for our game loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定使用哪种类型的循环。记住，`for`循环通常意味着我们确切知道我们想要做某件事的次数。因为我们无法总是预测玩家会玩多少次游戏，所以`for`循环不适合我们的需求。`while`循环可以一直执行，直到某个条件为假——例如，当用户按下某个键以结束程序时。`while`循环将是我们游戏循环的选择。
- en: 'The `while` loop needs a condition to check, so we’re going to create a variable
    that we’ll use as our *flag*, or signal, to end the program. Let’s call our flag
    variable `keep_going` and set it equal to `True` to start:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环需要一个条件来检查，因此我们将创建一个变量，作为我们的*标志*，即结束程序的信号。我们将这个标志变量命名为`keep_going`，并将其初始值设置为`True`：'
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because we start with `keep_going = True`, the program will enter the loop at
    least the first time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们开始时将`keep_going = True`，程序将至少进入一次循环。
- en: Next we’ll ask the user if they want to keep going. Rather than make the user
    enter `Y` or `yes` every time they want to play, let’s make it easier by just
    asking them to press ENTER.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们会问用户是否想继续玩游戏。为了让用户不必每次都输入`Y`或`yes`，我们可以通过让他们按ENTER键来简化操作。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we set a variable `answer` equal to an input function. Then we use an `if`
    statement to check whether `answer == ""` to see if the user pressed ENTER only
    or if they pressed other keys before ENTER. (The empty string `""` tells us the
    user didn’t type any other characters before pressing ENTER.) If the user wants
    to exit, all they have to do is make `answer` equal anything other than the empty
    string, `""`. In other words, they just have to press any key or keys before pressing
    ENTER, and the Boolean expression `answer == ""` will evaluate to `False`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将变量`answer`设置为一个输入函数。然后，我们使用`if`语句检查`answer == ""`，以判断用户是否仅按了ENTER键，还是在按ENTER键之前按了其他键。（空字符串`""`告诉我们用户在按ENTER之前没有输入其他字符。）如果用户想退出，他们只需让`answer`等于空字符串以外的任何值`""`。换句话说，他们只需要在按ENTER键之前按下任意键，布尔表达式`answer
    == ""`将评估为`False`。
- en: Our `if` statement checks whether `answer == ""` is `True`, and if so, it stores
    `True` in our flag variable `keep_going`. But do you notice some repetition there?
    If `answer == ""` is `True`, we assign the value `True` to `keep_going`; if `answer
    == ""` evaluates to `False`, we need to assign the value `False` to `keep_going`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`if`语句检查`answer == ""`是否为`True`，如果是，它会将`True`存储在我们的标志变量`keep_going`中。但你注意到有些重复吗？如果`answer
    == ""`为`True`，我们将值`True`赋给`keep_going`；如果`answer == ""`评估为`False`，我们需要将值`False`赋给`keep_going`。
- en: 'It would be simpler if we just set `keep_going` equal to whatever `answer ==
    ""` evaluates to. We can replace our code with the following, more concise code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接将`keep_going`设置为`answer == ""`的结果，那会更简单。我们可以用下面的更简洁的代码替换我们的代码：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line hasn’t changed. The second line sets `keep_going` equal to the
    result of the Boolean expression `answer == ""`. If that’s `True`, `keep_going`
    will be `True`, and our loop will continue. If that’s `False`, `keep_going` will
    be `False`, and our loop will end.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行没有变化。第二行将`keep_going`设置为布尔表达式`answer == ""`的结果。如果结果是`True`，则`keep_going`将为`True`，我们的循环将继续。如果结果是`False`，则`keep_going`将为`False`，我们的循环将结束。
- en: 'Let’s see the whole loop together:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下整个循环：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we add the `while` statement, so our loop will continue as long as `keep_going`
    evaluates to `True`. In the final program, we will “wrap” this `while` loop around
    the code to play a single hand. We’ll do this by putting the `while` statement
    before the code that chooses the cards, and by putting the prompt to hit a key
    after the code that tells who wins. Remember to indent the code inside the loop!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加入了`while`语句，因此只要`keep_going`的值为`True`，我们的循环就会继续。在最终的程序中，我们将“包裹”这个`while`循环，用来执行一次完整的游戏回合。我们通过将`while`语句放在选择卡片的代码前面，并在宣布谁赢之后放置提示信息来实现这一点。记得缩进循环中的代码！
- en: Putting It All Together
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有部分整合在一起
- en: Putting all those components together, we can build a War-like game that we’ll
    call *HighCard.py*. The computer draws a card for itself and a card for the player,
    checks to see which card is higher, and declares the winner. Type the code for
    *HighCard.py* into a new IDLE window or go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    to download it and play.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组件组合在一起，我们可以构建一个类似于战争游戏的游戏，我们将其命名为*HighCard.py*。计算机会为自己和玩家各抽一张牌，检查哪张牌更大，并宣布胜者。输入*HighCard.py*的代码到一个新的IDLE窗口中，或访问*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载并开始游戏。
- en: HighCard.py
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HighCard.py
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the game, and it’ll print the computer’s card and your card, followed by
    an announcement of who won and a prompt that offers you the opportunity to play
    again or exit. Play a few rounds and you’ll notice that the cards are random enough
    to make the outcome fun—sometimes the computer wins, sometimes you win, but it’s
    a fun game thanks to the element of chance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，它将打印出计算机的卡片和你的卡片，接着宣布谁赢了，并提示你选择是继续玩还是退出。玩几轮后，你会注意到卡片的随机性足以让游戏结果变得有趣——有时计算机赢，有时你赢，但因为有了随机性，游戏充满了乐趣。
- en: 'Roll the Dice: Creating a Yahtzee-Style Game'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掷骰子：创建一个Yahtzee风格的游戏
- en: We used arrays in our card game to help simplify the code needed to deal a card,
    and to test which card was higher in value based on its position in the list of
    cards. In this section, we’ll use the array concept to generate five random dice
    and check to see if we roll three of a kind, four of a kind, or five of a kind,
    like a simplified version of the dice game Yahtzee.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的纸牌游戏中，我们使用了数组来简化发牌所需的代码，并根据纸牌在卡片列表中的位置来测试哪张卡片更高。在这一部分中，我们将使用数组的概念来生成五个随机的骰子，并检查我们是否掷出了三同号、四同号或五同号，类似于简化版的骰子游戏Yahtzee。
- en: In Yahtzee, you have five dice. Each die has six sides, with each side showing
    a number of dots from one to six. In the full game, the user rolls all five dice,
    trying to get points by rolling three dice of the same value (which we call *three
    of a kind*) and other various “hands,” similar to the card game poker. Rolling
    five of the same value (say, all five dice land with the six-dot side facing up)
    is called a Yahtzee and scores the highest points possible. In our simplified
    version of the game, we’re just going to simulate the roll of five dice and check
    whether the user rolled three of a kind, four of a kind, or Yahtzee and let them
    know the outcome.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yahtzee中，你有五个骰子。每个骰子有六个面，每个面上显示从一到六的点数。在完整的游戏中，玩家掷出所有五个骰子，试图通过掷出三个相同的点数（我们称之为*三同号*）以及其他各种“组合”，类似于扑克牌游戏。在我们的简化版中，如果五个骰子都掷出相同的点数（比如全部是六点面朝上），那就叫做Yahtzee，得分是可能的最高分。在我们简化的游戏中，我们只会模拟五个骰子的掷骰，并检查用户是否掷出了三同号、四同号或Yahtzee，并告知他们结果。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188933.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages2188933.png.jpg)'
- en: Setting Up the Game
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏
- en: Now that we understand the game’s objective, let’s talk about how we’ll code
    the game. First, we’ll need to set up a game loop so that the user can keep rolling
    until they want to quit. Second, we’ll need to set up a hand of five simulated
    dice as an array that can hold five random values, from 1 to 6, representing the
    value of each of the rolled dice. Third, we’ll simulate the roll of the dice by
    assigning a random value from 1 to 6 in each of the five array slots. Finally,
    we need to compare the five rolled dice to each other to see whether we have three,
    four, or five of the same value and let the user know the outcome.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了游戏的目标，让我们来讨论如何编写这个游戏。首先，我们需要设置一个游戏循环，让用户可以一直掷骰子，直到他们想退出。其次，我们需要设置一个五个模拟骰子的手牌数组，该数组可以存储五个随机值，从1到6，表示每个骰子的点数。第三，我们将通过为数组中的五个位置赋予从1到6的随机值来模拟掷骰子。最后，我们需要将五个掷出的骰子彼此比较，看看是否有三个、四个或五个相同的值，并告诉用户结果。
- en: That last part is perhaps the most challenging. We could check for a Yahtzee
    by seeing if all five dice are a 1, or if all five dice are a 2, and so on, but
    that would mean a long list of complex `if` statement conditions. Since we don’t
    care whether we have five 1s, five 2s, or five 6s—we just care that we have five
    of a kind—we could simplify this process by checking to see if the first die’s
    value equals the second die’s value and the second die’s value equals the third
    die’s value, all the way to the fifth die. Then, no matter what the value of the
    five of a kind, we know all five dice are the same, and we have a Yahtzee.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一部分可能是最具挑战性的。我们可以通过检查是否所有五个骰子的值都为1，或者是否所有五个骰子的值都为2，以此类推来检查是否有一个 Yahtzee，但这将意味着需要一长串复杂的
    `if` 条件。由于我们并不关心是否是五个1、五个2还是五个6——我们只关心是否有五个相同的骰子——我们可以通过检查第一个骰子的值是否等于第二个骰子的值，第二个骰子的值是否等于第三个骰子的值，一直到第五个骰子，来简化这一过程。这样，无论五个相同的骰子是什么值，我们都知道所有五个骰子都是一样的，我们就有了
    Yahtzee。
- en: Five of a kind seems easy enough to test for, but let’s try to figure out how
    we might test for four of a kind. A possible hand for four of a kind might be
    an array of values like `[1, 1, 1, 1, 2]` (here we rolled four 1s and a 2). However,
    the array `[2, 1, 1, 1, 1]` would also be a four of a kind with four 1s, as would
    `[1, 1, 2, 1, 1]`, `[1, 2, 1, 1, 1]`, and `[1, 1, 1, 2, 1]`. That’s five possible
    configurations just to test for four 1s! That sounds like it’s going to take a
    long set of `if` conditions. . . .
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 五个相同的值似乎很容易测试，但让我们试着找出如何测试四个相同的值。四个相同的手牌可能是像 `[1, 1, 1, 1, 2]` 这样的数组（这里我们掷出了四个1和一个2）。然而，数组
    `[2, 1, 1, 1, 1]` 也是一个四个相同的手牌，里面有四个1，数组 `[1, 1, 2, 1, 1]`、`[1, 2, 1, 1, 1]` 和
    `[1, 1, 1, 2, 1]` 也是如此。这就有五种可能的配置来测试是否有四个1！这听起来需要一长串复杂的 `if` 条件……
- en: 'Fortunately, as a skilled programmer, you know that there’s usually an easier
    way to do things. What all five arrays in the previous paragraph have in common
    is that there are four 1s in the list of values; the problem is that the fifth
    value, the 2, can be in any of the five different array positions. We could test
    for four of a kind much more easily if the four 1s were side by side, with the
    other value (the 2) off by itself. If we could sort the array in order from lowest
    to highest or highest to lowest, for example, all of the 1s would be grouped together,
    reducing the five different cases to just two: `[1, 1, 1, 1, 2]` or `[2, 1, 1,
    1, 1]`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，作为一名熟练的程序员，你知道通常有更简单的方法来做这件事。前一段中的五个数组共有一个特点：在值的列表中有四个1；问题在于第五个值，2，可能位于五个不同的数组位置中的任何一个。如果这四个1能并排在一起，其他值（2）则单独放置，我们可以更轻松地测试是否有四个相同的值。例如，如果我们能按从低到高或从高到低的顺序对数组进行排序，所有的1将被分到一起，从而将五种不同的情况减少为仅两种：[1,
    1, 1, 1, 2] 或 [2, 1, 1, 1, 1]。
- en: Sorting the Dice
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投掷骰子
- en: Lists, collections, and arrays in Python have a built-in sort function, `sort()`,
    that allows us to sort the elements in the array by value in order from smallest
    to largest or vice versa. For example, if our dice array were called `dice`, we
    could sort the values with `dice.sort()`. By default, `sort()` will order the
    elements in `dice` from smallest to largest, or in *ascending* order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，列表、集合和数组有一个内置的排序函数`sort()`，允许我们按从小到大的顺序或反向排序数组中的元素。例如，如果我们的骰子数组叫做`dice`，我们可以通过`dice.sort()`来排序这些值。默认情况下，`sort()`会按从小到大的顺序，或按*升序*排列`dice`中的元素。
- en: 'For our test to see if the array of dice contains four of a kind, sorting the
    array means we only have to test for two cases: four matching low values and a
    high value (as in `[1, 1, 1, 1, 2]`), or a low value and four matching high values
    (like `[1, 3, 3, 3, 3]`). In the first case, we know that if the dice are sorted
    and the first and fourth dice are equal in value, we have four of a kind or better.
    In the second case, again with sorted dice, if the second and fifth dice are equal
    in value, we have four of a kind or better.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试数组是否包含四个相同的骰子时，排序数组意味着我们只需要测试两种情况：四个低值相同和一个高值（如`[1, 1, 1, 1, 2]`），或者一个低值和四个高值相同（如`[1,
    3, 3, 3, 3]`）。在第一种情况下，我们知道如果骰子已经排序，并且第一和第四个骰子值相同，那么我们就得到了四个相同的骰子或更好的组合。在第二种情况下，同样是排序后的骰子，如果第二个和第五个骰子值相同，那么我们也得到了四个相同的骰子或更好的组合。
- en: 'We say four of a kind *or better*, because the first and fourth dice are also
    the same in a five of a kind. This brings us to our first logic challenge: if
    a user rolls five of a kind, they have also rolled four of a kind, and we only
    want to give them credit for the larger score. We’ll handle this with an `if-elif`
    chain so that if a user gets Yahtzee, they don’t also get four of a kind and three
    of a kind; only the highest hand wins. Combining this `if-elif` sequence with
    what we learned about sorting the dice to check for four of a kind, the code would
    look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说四个相同的骰子*或更好*，因为在五个相同的骰子中，第一和第四个骰子也相同。这就引出了我们的第一个逻辑挑战：如果用户投出了五个相同的骰子，那么他们也投出了四个相同的骰子，我们只希望为他们计算更高的分数。我们将使用`if-elif`链来处理这个问题，这样如果用户投出了雅兹（Yahtzee），他们就不会同时得到四个相同和三个相同的骰子；只有最高的组合会获胜。将这个`if-elif`序列与我们关于排序骰子检查四个相同的知识结合起来，代码应该如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, if we have already sorted the dice array, we notice a shortcut: if the
    first and last dice have the same value (`if dice[0] == dice[4]`), we know we
    have a Yahtzee! Remember that we number our array positions from 0 through 4 for
    the first through fifth dice. If we don’t have five of a kind, we check for both
    cases of four of a kind (the first four dice are the same, `dice[0] == dice[3]`,
    or the last four dice are the same, `dice[1] == dice[4]`). We use the Boolean
    operator `or` here to recognize four of a kind if *either* of the two cases evaluates
    to `True` (the first four *or* the last four).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们已经对骰子数组进行了排序，我们可以发现一个快捷方式：如果第一个和最后一个骰子值相同（`if dice[0] == dice[4]`），那么我们就知道我们有一个“雅兹（Yahtzee）！”记住，我们的数组位置是从0到4，分别代表第一到第五个骰子。如果我们没有五个相同的骰子，我们会检查两种四个相同的情况（前四个骰子相同，`dice[0]
    == dice[3]`，或者后四个骰子相同，`dice[1] == dice[4]`）。我们在这里使用布尔操作符`or`来判断四个相同的骰子是否存在，如果*任意*一种情况评估为`True`（前四个*或*后四个）。
- en: Testing the Dice
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试骰子
- en: 'We’re referring to each die in the array individually by its index, or position:
    `dice[0]` refers to the first item in the dice array, and `dice[4]` refers to
    the fifth item because we start counting from zero. This is the way we can check
    the value of any of the dice individually or compare them to one another. Just
    as in our `suits[]` array back in [Table 6-1](ch06.html#suits_array "Table 6-1. The
    suits Array"), each entry in the `dice[]` array is an individual value. When we
    call on `dice[0]` to see if it’s equal to `dice[3]`, we’re looking at the value
    in the first `dice` element and comparing it to the value in the fourth `dice`
    element. If the array is sorted, and these are the same, we have four of a kind.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过索引或位置来引用数组中的每个骰子：`dice[0]`表示骰子数组中的第一个元素，`dice[4]`表示第五个元素，因为我们从零开始计数。这是我们检查任何一个骰子值的方法，或者将它们彼此比较。就像在我们之前的`suits[]`数组中一样，在[表6-1](ch06.html#suits_array
    "表6-1. 花色数组")中，每个`dice[]`数组中的条目都是一个单独的值。当我们调用`dice[0]`来检查它是否等于`dice[3]`时，我们是在查看第一个`dice`元素的值，并将其与第四个`dice`元素的值进行比较。如果数组已排序，并且这两个值相同，那么我们就得到了四个相同的骰子。
- en: 'To test for three of a kind, we add another `elif` statement, and we put the
    three-of-a-kind test after the four-of-a-kind test so that we test for three of
    a kind only if there’s no five of a kind and no four of a kind; we want the highest
    hand to be reported. There are three possible cases of three of a kind if we’re
    working with sorted dice: the first three dice match, the middle three, or the
    last three. In code, that would be:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试三张相同的骰子，我们添加另一个`elif`语句，并将三张相同的骰子测试放在四张相同的骰子测试之后，这样只有在没有五张相同和四张相同的情况下，才会测试三张相同的骰子；我们希望报告最高的组合。如果我们使用排序后的骰子，三张相同的骰子有三种可能的情况：前面三张骰子相同，中间三张骰子相同，或者最后三张骰子相同。在代码中，应该是：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we can test for various winning hands in our dice game, let’s add the
    game loop and the `dice` array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在骰子游戏中测试各种获胜组合，让我们添加游戏循环和`dice`数组。
- en: Putting It All Together
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: Here’s the complete *FiveDice.py* program. Type the code in a new window or
    download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的*FiveDice.py*程序。可以在新窗口中输入代码或从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载它。
- en: FiveDice.py
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FiveDice.py
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After we import the `random` module and start the game loop with a `while` statement,
    the next few lines deserve a little explanation. At ➊, we set up an array called
    `dice` that holds five values, and we initialize all those values to zero. The
    square brackets, `[` and `]`, are the same ones we used for our very first lists
    of colors, as well as for the arrays of card face values and suit names earlier
    in this chapter. At ➋, we set up a `for` loop to run five times for the five dice,
    using the range from 0 to 4; these will be the array positions, or index numbers,
    of the five dice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入`random`模块并通过`while`语句开始游戏循环之后，接下来的几行代码值得稍作解释。在 ➊ 处，我们设置了一个名为`dice`的数组，包含五个值，并将这些值初始化为零。方括号`[`和`]`与我们在本章前面用于列出颜色、卡片面值和花色名称时所使用的方括号相同。在
    ➋ 处，我们设置了一个`for`循环，循环五次，针对五个骰子，使用从 0 到 4 的范围；这些将是五个骰子的数组位置或索引号。
- en: At ➌, we set each individual die, from `dice[0]` to `dice[4]`, equal to a random
    integer from 1 to 6 to represent our five dice and their randomly rolled values.
    At ➍, we show the user what dice they rolled by printing the contents of the `dice`
    array; the result of this `print` statement is shown in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind.").
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们将每个单独的骰子，从`dice[0]`到`dice[4]`，设为一个从 1 到 6 的随机整数，表示我们的五个骰子及其随机掷出的值。在
    ➍ 处，我们通过打印`dice`数组的内容来展示玩家掷出的骰子；此`print`语句的结果显示在[图 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "图 6-5. 我们骰子程序的示例运行。注意，我们掷出了几个三相同和一个四相同。")中。
- en: '![A sample run of our dice program. Notice that we rolled several three of
    a kinds and one four of a kind.](httpatomoreillycomsourcenostarchimages2188935.png.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![我们骰子程序的示例运行。注意，我们掷出了几个三相同和一个四相同。](httpatomoreillycomsourcenostarchimages2188935.png.jpg)'
- en: Figure 6-5. A sample run of our dice program. Notice that we rolled several
    three of a kinds and one four of a kind.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5. 我们骰子程序的示例运行。注意，我们掷出了几个三相同和一个四相同。
- en: At ➎, we call the `.sort()` function on the `dice` array. This makes it easy
    to test for various hands—like five of a kind, four of a kind, and so on—by arranging
    the rolled dice values from smallest to largest, grouping like values. So, for
    example, if we roll `[3, 6, 3, 5, 3]`, the `dice.sort()` function turns that into
    `[3, 3, 3, 5, 6]`. The `if` statement checks if the first value is equal to the
    fifth value; in this case, since the first and fifth values (`3` and `6`) aren’t
    equal, we know not all the dice landed on the same value and it’s not five of
    a kind. The first `elif` checks for four of a kind by comparing the first and
    fourth values (`3` and `5`) and second and fifth values (`3` and `6`); again,
    there are no matches here, so it’s not four of a kind. The second `elif` checks
    for three of a kind; since the first and third values, `3` and `3`, are equal,
    we know the first three values are equal. We inform the user that they got three
    of a kind and then prompt them to press keys depending on whether they want to
    continue playing or exit, as shown in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind.").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，我们对`dice`数组调用`.sort()`函数。通过将掷出的骰子值从小到大排序并将相同的值分组，这使得测试各种手牌变得简单——比如五个相同、四个相同，等等。所以，例如，如果我们掷出了`[3,
    6, 3, 5, 3]`，`dice.sort()`函数会将其转为`[3, 3, 3, 5, 6]`。`if`语句检查第一个值是否等于第五个值；在这种情况下，由于第一个和第五个值（`3`和`6`）不相等，我们知道并非所有的骰子都落在相同的值上，所以它不是五个相同。第一个`elif`通过比较第一个和第四个值（`3`和`5`）以及第二个和第五个值（`3`和`6`）来检查四个相同；同样，这里没有匹配项，所以它不是四个相同。第二个`elif`检查三个相同；由于第一个和第三个值`3`和`3`相等，我们知道前三个值相等。我们通知玩家他们得到了三个相同，并提示他们根据是否继续玩游戏或退出游戏按下相应的键，如[图
    6-5](ch06.html#sample_run_of_our_dice_programdot_notice "图 6-5. 我们骰子程序的示例运行。注意，我们掷出了几个三相同和一个四相同。")所示。
- en: Run the program and press ENTER several times to see what you roll.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并按几次 ENTER 键查看你掷出的骰子结果。
- en: 'You’ll notice that you roll three of a kind fairly often, as much as once every
    five or six rolls. Four of a kind is rarer, occurring about once every 50 rolls.
    We rolled four of a kind only once in a screen full of attempts in [Figure 6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "Figure 6-5. A sample run of our dice program. Notice that we rolled several three
    of a kinds and one four of a kind."). The Yahtzee is even rarer: you could roll
    several hundred times before getting a Yahtzee, but because of the random-number
    generator, you might roll one the first few times you try. Even though it’s not
    as complex as the real game, our simplified version of Yahtzee is interesting
    enough to play because of its random nature.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，你经常会掷出三张相同的点数，大约每五到六次掷骰子就能出现一次。四个相同点数则更为罕见，大约每50次掷骰子才会出现一次。在[图6-5](ch06.html#sample_run_of_our_dice_programdot_notice
    "图6-5：我们的掷骰子程序运行示例。注意到我们掷出了多个三张相同的点数和一次四张相同的点数。")中，我们只在屏幕满是尝试的情况下掷出了四张相同的点数。雅兹更为罕见：你可能需要掷几百次才会得到雅兹，但由于随机数生成器的存在，你也许在前几次尝试时就能掷出雅兹。尽管它没有真正的游戏复杂，但我们简化版的雅兹依然足够有趣，因为它具有随机性。
- en: We’ve seen how randomness can make a game interesting and fun by adding the
    element of chance to dice and card games, Rock-Paper-Scissors, and a guessing
    game. We also enjoyed the kaleidoscope-like graphics we created using a random
    number generator to place colorful spirals all over the screen. In the next section,
    we’ll combine what you’ve learned about random numbers and loops with a bit of
    geometry to turn the random spirals program into a true virtual kaleidoscope that
    generates a different set of reflected images every time you run it!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，随机性如何通过为掷骰子、扑克牌游戏、剪刀石头布、猜谜游戏等增加运气元素，来让游戏变得有趣和好玩。我们也喜欢通过使用随机数生成器在屏幕上布置五光十色的螺旋，创造出万花筒般的图形。在接下来的章节中，我们将结合你学到的随机数、循环和一些几何知识，将随机螺旋程序转变为一个真正的虚拟万花筒，每次运行都会生成一组不同的反射图像！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188937.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188937.png.jpg)'
- en: Running the numbers on Yahtzee
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 计算雅兹的概率
- en: 'If you’re interested in the math behind Yahtzee and why five of a kind is so
    rare, here’s a quick explanation. First, there are five dice, each with six sides,
    so the number of possible combinations is 6 × 6 × 6 × 6 × 6 = 6⁵ = 7,776\. There
    are 7,776 ways to roll five normal, six-sided dice. To figure out the probability
    of rolling five dice with the same face value (five of a kind), we have to figure
    out how many possible Yahtzees there are: five 1s, five 2s, and so on up through
    five 6s. So there are six possible Yahtzee hands of five of a kind that we can
    roll with our five dice. Divide 6 Yahtzees by the 7,776 total possible rolls,
    and you get the probability that you’ll roll five of a kind: 6/7,776, or 1/1,296.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对雅兹背后的数学原理感兴趣，以及为什么五个相同点数这么罕见，下面是一个简要的解释。首先，有五颗骰子，每颗骰子有六个面，因此所有可能的组合数量是6
    × 6 × 6 × 6 × 6 = 6⁵ = 7,776。也就是说，掷出五颗正常六面骰子的方式一共有7,776种。要计算掷出五个相同点数（五个相同点数的概率），我们需要找出有多少种可能的雅兹：五个1、五个2，依此类推，直到五个6。因此，我们可以掷出六种不同的五个相同点数的雅兹。将6种雅兹除以7,776种可能的结果，你就得到了掷出五个相同点数的概率：6/7,776，或者1/1,296。
- en: 'That’s right: the odds that you’ll roll five of a kind on a single roll are
    just 1 out of 1,296\. So don’t get discouraged if you roll for a long time before
    you get your first five of a kind. On average, you’ll get one every 1,300 rolls
    or so. No wonder they give 50 points for a Yahtzee!'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：你在一次掷骰子中掷出五个相同点数的概率只有1/1,296。所以，如果你掷了很久才得到第一次五个相同的点数，不要灰心。平均来说，你大约每1,300次掷骰子能得到一次五个相同的点数。难怪“雅兹”会给50分！
- en: Kaleidoscope
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万花筒
- en: 'The random spiral color graphic from [Figure 6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra
    "Figure 6-2. Spirals of random sizes and colors at random locations on the screen,
    from RandomSpirals.py") looked a bit like a kaleidoscope. To make it look more
    like a real kaleidoscope, let’s add an important feature that our spiral program
    was missing: reflections.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[图6-2](ch06.html#spirals_of_random_sizes_and_colors_at_ra "图6-2：屏幕上随机大小和颜色的螺旋形图案，来自RandomSpirals.py")的随机螺旋色彩图形有点像万花筒。为了让它看起来更像真正的万花筒，我们来加入一个我们螺旋程序缺失的重要特性：反射。
- en: In a kaleidoscope, it’s the positioning of the mirrors that makes random colors
    and shapes into a lovely pattern. In this closing example, we’re going to mimic
    the mirror effect by modifying our *RandomSpiral.py* program to “reflect” the
    spirals four times on the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在万花筒中，是镜子的定位使随机的颜色和形状变成一个美丽的图案。在这个结尾的示例中，我们将通过修改我们的 *RandomSpiral.py* 程序，将螺旋图案在屏幕上“反射”四次，从而模仿镜面效果。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188939.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188939.png.jpg)'
- en: To understand how to achieve this mirror effect, we need to talk more about
    Cartesian coordinates. Let’s take a look at four points, (4, 2), (–4, 2), (–4,
    –2), and (4, –2), as shown in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)").
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何实现这种镜面效果，我们需要更详细地讨论笛卡尔坐标系。让我们看一下四个点：(4, 2)，(–4, 2)，(–4, –2)，(4, –2)，如[图6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "图6-6. 四个关于 x 和 y 轴对称的点，从 (4, 2) 开始")所示。
- en: 'Compare (4, 2) and (–4, 2), the top two points. If the vertical y-axis were
    a mirror, these two points would be mirror images of each other; we call (4, 2)
    a reflection of (–4, 2) *about* the y-axis. Something similar occurs with (4,
    2) and (4, –2), the two points on the right, but with the horizontal x-axis as
    the imaginary mirror: (4, –2) is the reflection of (4, 2) about the x-axis.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 (4, 2) 和 (–4, 2)，这两点位于顶部。如果竖直的 y 轴是镜子，那么这两点将是彼此的镜像；我们称 (4, 2) 为 (–4, 2) 关于
    y 轴的反射。类似的情况发生在 (4, 2) 和 (4, –2) 之间，这两点位于右侧，但以水平的 x 轴作为假想的镜子：(4, –2) 是 (4, 2)
    关于 x 轴的反射。
- en: '![Four points reflected about the x- and y-axes starting with (4, 2)](httpatomoreillycomsourcenostarchimages2188941.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![四个关于 x 和 y 轴对称的点，从 (4, 2) 开始](httpatomoreillycomsourcenostarchimages2188941.png)'
- en: Figure 6-6. Four points reflected about the x- and y-axes starting with (4,
    2)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6. 四个关于 x 和 y 轴对称的点，从 (4, 2) 开始
- en: 'If you look at each pair of (*x*, *y*) coordinates in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)"),
    you’ll notice something: all four (*x*, *y*) coordinates use the same numbers,
    4 and 2, just with different signs, + or –, depending on their location. We can
    create any four reflected points around the x- and y-axes by changing the signs
    on the two coordinates as follows: (*x*, *y*), (*–x*, *y*), (*–x*, *–y*), (*x*,
    *–y*). If you’d like, you can try drawing this on a piece of graph paper with
    any pair of (*x*, *y*) coordinates. Try (2, 3), for example: (2, 3), (–2, 3),
    (–2, –3), and (2, –3) are four reflected points above and below the x-axis and
    on either side of the y-axis.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看[图6-6](ch06.html#four_points_reflected_about_the_x-_and_y "图6-6. 四个关于 x
    和 y 轴对称的点，从 (4, 2) 开始")中的每一对 (*x*, *y*) 坐标，你会注意到一些事情：所有四个 (*x*, *y*) 坐标都使用相同的数字，4
    和 2，只是符号不同，+ 或 –，这取决于它们的位置。我们可以通过改变两个坐标的符号来创建任何四个关于 x 轴和 y 轴对称的点，方式如下：(*x*, *y*)，(*–x*,
    *y*)，(*–x*, *–y*)，(*x*, *–y*)。如果你愿意，可以尝试在一张坐标纸上绘制这些点，选择任意一对 (*x*, *y*) 坐标。例如，尝试
    (2, 3)：(2, 3)，(–2, 3)，(–2, –3)，(2, –3) 是四个关于 x 轴上下、y 轴两侧对称的点。
- en: 'With this knowledge, we can build the outline of a kaleidoscope program as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以按照以下方式构建万花筒程序的框架：
- en: Pick a random location (*x*, *y*) in the upper right of the screen and draw
    a spiral there.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右上角选择一个随机位置 (*x*, *y*) 并在该位置绘制一个螺旋图案。
- en: Draw the same spiral at (*–x*, *y*) in the upper left of the screen.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左上角的 (*–x*, *y*) 位置绘制相同的螺旋图案。
- en: Draw the same spiral at (*–x*, *–y*) in the lower left of the screen.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左下角的 (*–x*, *–y*) 位置绘制相同的螺旋图案。
- en: Draw the same spiral at (*x*, *–y*) in the lower right of the screen.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右下角的 (*x*, *–y*) 位置绘制相同的螺旋图案。
- en: If we repeat these steps over and over, we’ll have a lovely kaleidoscope effect
    with our random spirals.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一遍又一遍地重复这些步骤，就能获得一个美丽的万花筒效果，配合我们的随机螺旋图案。
- en: Let’s step through the full code for *Kaleidoscope.py* and see this in action.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过完整的 *Kaleidoscope.py* 代码一步步演示，并看到这一效果的实现。
- en: Kaleidoscope.py
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kaleidoscope.py
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our program begins with the `turtle` and `random` modules imported as usual,
    but at ➊ we do something new: we change the speed of the turtle to the fastest
    value possible with `t.speed(0)`. The `speed()` function in turtle graphics takes
    an argument from 0 to 10, with `1` as the slow animation setting, `10` as the
    fast animation setting, and `0` meaning no animation (draw as fast as the computer
    can go). It’s an odd scale from 1 to 10, then 0, but just remember that if you
    want the fastest turtle possible, set the speed to `0`. You’ll notice when you
    run the program that the spirals appear almost instantly. You can make this change
    to any of our previous drawing programs if you’d like the turtle to move faster.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序如常导入了` turtle`和`random`模块，但在➊处我们做了一些新的事情：我们通过`t.speed(0)`将海龟的速度设置为最快值。海龟图形中的`speed()`函数的参数范围从0到10，其中`1`是慢动画设置，`10`是快动画设置，`0`表示没有动画（以最快速度绘制）。这是一个从1到10再到0的奇怪刻度，但只要记住，如果你想要最快的海龟，只需将速度设置为`0`。你会注意到，当你运行程序时，螺旋几乎是瞬间出现的。如果你想让海龟更快地移动，你可以对我们之前的绘图程序做相同的修改。
- en: Our `for` loop looks just like the one from our *RandomSpirals.py* program,
    until we get to ➋ and ➌. At ➋, we cut the horizontal range for our random number
    in half, to just the positive x-coordinate values (the right side of the screen,
    from `x = 0` to `x = turtle.window_ width()//2`), and at ➌, we restrict the vertical
    range to the upper half of the screen, from `y = 0` to `y = turtle.window_height()//2`.
    Remember that we’re doing integer division with the `//` operator to keep our
    pixel measurements in whole numbers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`for`循环看起来和我们在*RandomSpirals.py*程序中使用的完全一样，直到到达➋和➌。在➋处，我们将随机数的横坐标范围缩小了一半，仅限于正的x坐标值（屏幕的右侧，从`x
    = 0`到`x = turtle.window_width()//2`），在➌处，我们将纵坐标范围限制为屏幕的上半部分，从`y = 0`到`y = turtle.window_height()//2`。记住，我们使用`//`运算符进行整数除法，以保持像素度量为整数。
- en: These two lines of code give us a random (*x*, *y*) coordinate pair in the upper
    right of the screen every time. We set the turtle pen’s position to that point
    at ➍, and we draw the first spiral with the `for` loop immediately after. Then,
    we change the signs of each of the coordinate values, like we did in [Figure 6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)"),
    to create the three reflections of this point in the upper left (*–x*, *y*) at
    ➎, lower left (*–x*, *–y*) at ➏, and lower right (*x*, *–y*) at ➐. See [Figure 6-7](ch06.html#mirroredsolidusrepeated_effect_in_kaleid
    "Figure 6-7. The mirrored/repeated effect in Kaleidoscope.py.") for an example
    of the patterns *Kaleidoscope.py* can produce.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码每次都会给我们一个随机的(*x*, *y*)坐标对，位于屏幕的右上角。在➋，我们将海龟画笔的位置设置到该点，然后立即通过`for`循环绘制第一个螺旋。接着，我们像在[图6-6](ch06.html#four_points_reflected_about_the_x-_and_y
    "图6-6. 关于x轴和y轴反射的四个点，起始点为(4, 2)")中做的那样，改变每个坐标值的符号，来创建该点的三个反射：左上角(*–x*, *y*)在➎，左下角(*–x*,
    *–y*)在➏，右下角(*x*, *–y*)在➐。请参见[图6-7](ch06.html#mirroredsolidusrepeated_effect_in_kaleid
    "图6-7. Kaleidoscope.py中的镜像/重复效果")，了解*Kaleidoscope.py*能够生成的图案示例。
- en: 'You can find the three reflections for each spiral by looking in the other
    three corners of the screen. These are not true mirror images: we don’t start
    at the same angle for each spiral, and we don’t turn right in our reflected spirals
    and left in the originals. However, these are tweaks you can make to the program
    if you’d like. See this chapter’s Programming Challenges for ideas to make this
    kaleidoscope program even cooler.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看屏幕其他三个角落来找到每个螺旋的三个反射。这些不是严格的镜像：我们并不是从相同的角度开始每个螺旋，且在反射的螺旋中我们不会向右转，而在原始螺旋中我们也不会向左转。然而，如果你愿意，可以对程序进行调整。有关如何让这个万花筒程序更酷的想法，请参考本章的编程挑战部分。
- en: '![The mirrored/repeated effect in Kaleidoscope.py.](httpatomoreillycomsourcenostarchimages2188943.png.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Kaleidoscope.py中的镜像/重复效果。](httpatomoreillycomsourcenostarchimages2188943.png.jpg)'
- en: Figure 6-7. The mirrored/repeated effect in *Kaleidoscope.py*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7. *Kaleidoscope.py*中的镜像/重复效果。
- en: What You Learned
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: Before this chapter, we had no way of making a computer behave randomly. Now
    we can make a computer roll dice; draw random cards from a deck; draw spirals
    of random color, shape, size, and location; and even beat us now and then at Rock-Paper-Scissors.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之前，我们没有办法让计算机表现出随机行为。现在，我们可以让计算机掷骰子；从牌堆中抽取随机卡片；绘制随机颜色、形状、大小和位置的螺旋；甚至偶尔在石头剪子布游戏中赢我们一局。
- en: The tool that made these programs possible was the `random` module. We used
    `random.randint(1, 10)` to generate a random number between 1 and 10 in our guessing
    game. We added the `random.choice()` function to pick a random color out of a
    list in our random spirals program. You learned how to use the functions `turtle.window_width()`
    and `turtle.window_height()` to find the width and height of our turtle screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使这些程序成为可能的工具是`random`模块。我们使用`random.randint(1, 10)`在猜数字游戏中生成1到10之间的随机数。在我们的随机螺旋程序中，我们加入了`random.choice()`函数，从列表中随机选择颜色。你还学习了如何使用`turtle.window_width()`和`turtle.window_height()`来获取海龟屏幕的宽度和高度。
- en: You also learned how to use Cartesian coordinates to find an (*x*, *y*) location
    on the screen, and you used the `random.randrange()` function to generate a number
    in the range between our left and right x-coordinate values and top and bottom
    y-coordinate values. We then used `turtle.setpos(x,y)` to move the turtle to any
    position on the drawing screen.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何使用笛卡尔坐标来找出屏幕上的(*x*, *y*)位置，并使用`random.randrange()`函数在我们定义的左、右x坐标值和上下y坐标值之间生成一个随机数。然后，我们使用`turtle.setpos(x,
    y)`将海龟移动到绘图屏幕的任意位置。
- en: We combined our ability to choose an item from a list at random using `random.choice()`
    with our ability to test and compare variables using `if`-`elif` statements to
    build a “user versus computer” version of Rock-Paper-Scissors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`random.choice()`从列表中随机选择项目的能力与使用`if`-`elif`语句来测试和比较变量的能力结合，构建了一个“用户对电脑”的猜拳游戏版本。
- en: You learned the concept of an array, and we made our card game easier to code
    by building one array of suit names and one array of face values. We used `random.choice()`
    on each array to simulate dealing a card. We ordered the face values from least
    to greatest and used the `.index()` function to find the location of an element
    in an array. We used the index of each of two card face values to see which card
    had a higher index value and which player won a hand of the card game War. We
    built a reusable game loop with user input, a flag variable `keep_going`, and
    a `while` statement; we can put the loop into any game or app that a user might
    want to play or run multiple times in a row.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了数组的概念，并通过构建一个花色名称数组和一个面值数组，使得我们的纸牌游戏更容易编码。我们在每个数组上使用了`random.choice()`来模拟发牌。我们将面值从小到大排序，并使用`.index()`函数来查找数组中元素的位置。我们使用每张牌的面值索引，比较哪个牌的索引值更大，从而判断哪个玩家赢得了“战争”纸牌游戏的一局。我们构建了一个可重用的游戏循环，包含用户输入、一个标志变量`keep_going`和一个`while`语句；我们可以将这个循环应用到任何用户想玩的游戏或应用中，或者在一系列游戏中多次运行。
- en: We extended our understanding of arrays by building a simplified version of
    Yahtzee. We created an array of five values from 1 to 6 to simulate five dice,
    used `randint()` to simulate rolling the dice, and used `sort()` on the dice array
    to make it easier to check for winning hands. We saw that, in a sorted array,
    if the first and last values are the same, all elements in the array are the same.
    In our game, this meant we had five of a kind. We used compound `if` statements
    joined by the `or` operator to test for two cases of four of a kind and three
    cases of three of a kind. We used `if-elif` statements to control the logic of
    our program so that five of a kind wasn’t also counted as four of a kind, and
    so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建简化版的“雅兹牌游戏”来扩展了对数组的理解。我们创建了一个包含从1到6的五个值的数组，模拟五颗骰子，使用`randint()`来模拟掷骰子，并对骰子数组使用`sort()`函数，使得检查获胜组合变得更容易。我们看到，在一个已排序的数组中，如果第一个和最后一个值相同，说明数组中的所有元素都相同。在我们的游戏中，这意味着我们得到了五个相同的点数。我们使用复合`if`语句，并通过`or`运算符将两种四个相同的情况和三种三个相同的情况结合。我们使用`if-elif`语句来控制程序逻辑，确保五个相同的点数不会被误判为四个相同的点数，依此类推。
- en: We worked more with Cartesian coordinates in the kaleidoscope program and simulated
    the effect of reflections by changing the signs of (*x*, *y*) coordinate values.
    We repeated each spiral of random size, color, and location four times on the
    screen to create our kaleidoscope effect. You learned how to increase the turtle’s
    drawing speed with `t.speed(0)`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在万花筒程序中更多地使用了笛卡尔坐标，并通过改变(*x*, *y*)坐标值的符号来模拟反射效果。我们在屏幕上重复每个随机大小、颜色和位置的螺旋形状四次，创造了万花筒效果。你学习了如何使用`t.speed(0)`来增加海龟的绘图速度。
- en: Random numbers and choices add an element of chance to make a game more interesting.
    Just about every game you’ve played has an element of chance. Now that you can
    build randomness into programs, you can code games people love to play.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数和随机选择为游戏增加了偶然性，使游戏更加有趣。你玩过的几乎每个游戏都有一定的偶然性。现在，你可以在程序中构建随机性，编写人们喜欢玩的游戏。
- en: 'At this point, you should be able to do the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该能够完成以下操作：
- en: Import the `random` module into your programs.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `random` 模块导入到你的程序中。
- en: Use `random.randint()` to generate a random integer number in a given range.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.randint()` 在给定范围内生成一个随机整数。
- en: Use `random.choice()` to pick a value at random out of a list or array.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.choice()` 从列表或数组中随机选择一个值。
- en: Use `random.choice()` to generate 52 card values from two arrays of strings
    containing only the faces and suits.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.choice()` 从两个仅包含面值和花色的字符串数组中生成52张牌的值。
- en: Determine the size of your drawing window with `turtle.window_ width()` and
    `turtle.window_height()`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `turtle.window_width()` 和 `turtle.window_height()` 确定绘图窗口的大小。
- en: Move the turtle to any position on the drawing screen with `turtle.setpos(x,y)`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `turtle.setpos(x,y)` 将乌龟移动到绘图屏幕的任何位置。
- en: Use the `random.randrange()` function to generate a random number in any range.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random.randrange()` 函数生成指定范围内的随机数。
- en: Find the index of an element in a list or array with the `.index()` function.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.index()` 函数查找列表或数组中元素的索引。
- en: Build a `while` game loop using a Boolean flag variable like `keep_going`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔标志变量如 `keep_going` 构建一个 `while` 游戏循环。
- en: Construct an array of similar types of values, assign values to elements in
    the array by their index (as in `dice[0] = 2`), and use array elements like regular
    variables.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个包含相似类型值的数组，通过索引为数组中的元素赋值（例如 `dice[0] = 2`），并像使用常规变量一样使用数组元素。
- en: Sort lists or arrays with the `.sort()` function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.sort()` 函数对列表或数组进行排序。
- en: Reflect points about the x- and y-axes by changing the signs of the points’
    (*x*, *y*) coordinate values.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变点的 (*x*, *y*) 坐标值的符号来反射点关于 x 轴和 y 轴的对称。
- en: Change the turtle’s drawing speed with the `.speed()` function.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.speed()` 函数来改变乌龟的绘图速度。
- en: Programming Challenges
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: For this chapter’s challenge problems, we’ll extend the *Kaleidoscope.py* and
    *HighCard.py* programs. (If you get stuck, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample answers.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的挑战问题，我们将扩展 *Kaleidoscope.py* 和 *HighCard.py* 程序。（如果你卡住了，可以访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    获取示例答案。）
- en: '**#1: RANDOM SIDES AND THICKNESS**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 随机边数和线条粗细**'
- en: Add more randomness to *Kaleidoscope.py* by adding two more random variables.
    Add a variable `sides` for the number of sides and then use that variable to change
    the angle we turn each time in the spiral loop (and therefore, the number of sides
    in the spiral) by using `360/sides + 1` as your angle instead of `91`. Next, create
    a variable called `thick` that will store a random number between 1 and 6 for
    the turtle pen’s thickness. Add the line `t.width(thick)` in the right place to
    change the thickness of the lines of each spiral in our random kaleidoscope.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加两个随机变量来为 *Kaleidoscope.py* 增加更多随机性。添加一个名为 `sides` 的变量来表示边数，然后使用该变量每次在螺旋循环中改变转角（因此，螺旋的边数），通过
    `360/sides + 1` 作为角度，而不是 `91`。接下来，创建一个名为 `thick` 的变量，用来存储一个1到6之间的随机数，表示乌龟笔的粗细。将
    `t.width(thick)` 这一行添加到正确的位置，以改变每个螺旋线条的粗细。
- en: '**#2: REALISTIC MIRRORED SPIRALS**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 逼真的镜像螺旋**'
- en: 'If you know some geometry, two more tweaks make this kaleidoscope even more
    realistic. First, keep track of the direction (between 0 and 360 degrees) the
    turtle is pointing before drawing the first spiral by getting the result of `t.heading()`
    and storing it in a variable called `angle`. Then, before drawing each mirrored
    spiral, change the angle to the correct mirrored direction by pointing the turtle
    with `t.setheading()`. Hint: the second angle will be `180 - angle`, the third
    spiral’s angle will be `angle - 180`, and the fourth will be `360 - angle`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解一些几何学，另外两个调整可以使这个万花筒更加逼真。首先，在绘制第一个螺旋之前，记录乌龟的方向（介于0到360度之间），通过调用 `t.heading()`
    获取结果，并将其存储在一个名为 `angle` 的变量中。然后，在绘制每个镜像螺旋之前，通过使用 `t.setheading()` 将乌龟指向正确的镜像方向。提示：第二个角度将是
    `180 - angle`，第三个螺旋的角度将是 `angle - 180`，第四个将是 `360 - angle`。
- en: Then, try turning left after each drawn line for the first and third spirals
    and turning right each time for the second and fourth spirals. If you implement
    these improvements, your spirals should really look like mirror images of each
    other in size, shape, color, thickness, and orientation. If you like, you can
    even keep the shapes from overlapping so much by changing the range of the x-
    and y-coordinate values to `random.randrange(size,turtle.window_width()//2)` and
    `random.randrange(size,turtle.window_height()//2)`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试在第一和第三个螺旋图形每绘制一条线后向左转，而在第二和第四个螺旋图形每次绘制一条线后向右转。如果你实现了这些改进，你的螺旋图形应该在大小、形状、颜色、粗细和方向上真正成为彼此的镜像。如果你愿意，你还可以通过将x和y坐标值的范围改为`random.randrange(size,turtle.window_width()//2)`和`random.randrange(size,turtle.window_height()//2)`来减少形状之间的重叠。
- en: '**#3: WAR**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3: 战争**'
- en: 'Turn *HighCard.py* into the full game of War by making three changes. First,
    keep score: create two variables to keep track of how many hands the computer
    has won and how many the user has won. Second, simulate playing one full deck
    of cards by dealing 26 hands (perhaps by using a `for` loop instead of our `while`
    loop or by keeping track of the number of hands played so far) and then declare
    a winner based on which player has more points. Third, handle ties by remembering
    how many ties have happened in a row; then, the next time one of the players wins,
    add the number of recent ties to that winner’s score and set the number of ties
    back to zero for the next round.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行三项修改，将*HighCard.py*转变为完整的战争游戏。首先，记录分数：创建两个变量来追踪计算机赢得了多少局，用户赢得了多少局。其次，通过发牌26局（可以使用`for`循环代替`while`循环，或者通过记录已经玩过的局数）来模拟一副完整的牌，并根据哪一方的得分更高来宣布胜者。第三，处理平局情况：记住连续发生过多少次平局；然后，下次其中一方获胜时，将最近的平局次数加到该玩家的得分中，并将平局次数重置为零，进入下一轮。
