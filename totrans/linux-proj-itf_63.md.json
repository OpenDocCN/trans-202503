["```\n#include <sys/time.h>         /* For portability */\n#include <sys/select.h>\n\nint `select`(int *nfds*, fd_set **readfds*, fd_set **writefds*, fd_set **exceptfds*,\n           struct timeval **timeout*);\n```", "```\n#include <sys/select.h>\n\nvoid `FD_ZERO`(fd_set **fdset*);\nvoid `FD_SET`(int *fd*, fd_set **fdset*);\nvoid `FD_CLR`(int *fd*, fd_set **fdset*);\n\nint `FD_ISSET`(int *fd*, fd_set **fdset*);\n```", "```\nstruct timeval {\n    time_t      tv_sec;         /* Seconds */\n    suseconds_t tv_usec;        /* Microseconds (long int) */\n};\n```", "```\n`altio/t_select.c`\n#include <sys/time.h>\n#include <sys/select.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s {timeout|-} fd-num[rw]...\\n\", progName);\n    fprintf(stderr, \"    - means infinite timeout; \\n\");\n    fprintf(stderr, \"    r = monitor for read\\n\");\n    fprintf(stderr, \"    w = monitor for write\\n\\n\");\n    fprintf(stderr, \"    e.g.: %s - 0rw 1w\\n\", progName);\n    exit(EXIT_FAILURE);\n}\nint\nmain(int argc, char *argv[])\n{\n    fd_set readfds, writefds;\n    int ready, nfds, fd, numRead, j;\n    struct timeval timeout;\n    struct timeval *pto;\n    char buf[10];                       /* Large enough to hold \"rw\\0\" */\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageError(argv[0]);\n\n    /* Timeout for select() is specified in argv[1] */\n\n    if (strcmp(argv[1], \"-\") == 0) {\n        pto = NULL;                     /* Infinite timeout */\n    } else {\n        pto = &timeout;\n        timeout.tv_sec = getLong(argv[1], 0, \"timeout\");\n        timeout.tv_usec = 0;            /* No microseconds */\n    }\n\n    /* Process remaining arguments to build file descriptor sets */\n\n    nfds = 0;\n    FD_ZERO(&readfds);\n    FD_ZERO(&writefds);\n\n    for (j = 2; j < argc; j++) {\n        numRead = sscanf(argv[j], \"%d%2[rw]\", &fd, buf);\n        if (numRead != 2)\n            usageError(argv[0]);\n        if (fd >= FD_SETSIZE)\n            cmdLineErr(\"file descriptor exceeds limit (%d)\\n\", FD_SETSIZE);\n\n        if (fd >= nfds)\n            nfds = fd + 1;              /* Record maximum fd + 1 */\n        if (strchr(buf, 'r') != NULL)\n            FD_SET(fd, &readfds);\n        if (strchr(buf, 'w') != NULL)\n            FD_SET(fd, &writefds);\n    }\n\n    /* We've built all of the arguments; now call select() */\n\n    ready = select(nfds, &readfds, &writefds, NULL, pto);\n                                        /* Ignore exceptional events */\n    if (ready == -1)\n        errExit(\"select\");\n\n    /* Display results of select() */\n\n    printf(\"ready = %d\\n\", ready);\nfor (fd = 0; fd < nfds; fd++)\n        printf(\"%d: %s%s\\n\", fd, FD_ISSET(fd, &readfds) ? \"r\" : \"\",\n                FD_ISSET(fd, &writefds) ? \"w\" : \"\");\n\n    if (pto != NULL)\n        printf(\"timeout after select(): %ld.%03ld\\n\",\n               (long) timeout.tv_sec, (long) timeout.tv_usec / 10000);\n    exit(EXIT_SUCCESS);\n}\n           `altio/t_select.c`\n```", "```\n$ `./t_select 10 0r`\n*Press Enter, so that a line of input is available on file descriptor 0*\nready = 1\n0: r\ntimeout after select(): 8.003\n$                                         *Next shell prompt is displayed*\n```", "```\n$ `./t_select 0 0r`\nready = 0\ntimeout after select(): 0.000\n```", "```\n$ `./t_select - 0r 1w`\nready = 1\n0:\n1: w\n```", "```\n#include <poll.h>\n\nint `poll`(struct pollfd *fds*[], nfds_t *nfds*, int *timeout*);\n```", "```\nstruct pollfd {\n    int   fd;               /* File descriptor */\n    short events;           /* Requested events bit mask */\n    short revents;          /* Returned events bit mask */\n};\n```", "```\n$ `./poll_pipes 10 3`\nWriting to fd:   4 (read fd:   3)\nWriting to fd:  14 (read fd:  13)\nWriting to fd:  14 (read fd:  13)\npoll() returned: 2\nReadable:   3\nReadable:  13\n```", "```\n`altio/poll_pipes.c`\n#include <time.h>\n#include <poll.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int numPipes, j, ready, randPipe, numWrites;\n    int (*pfds)[2];                     /* File descriptors for all pipes */\n    struct pollfd *pollFd;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s num-pipes [num-writes]\\n\", argv[0]);\n\n    /* Allocate the arrays that we use. The arrays are sized according\n       to the number of pipes specified on command line */\n\n    numPipes = getInt(argv[1], GN_GT_0, \"num-pipes\");\n\n    pfds = calloc(numPipes, sizeof(int [2]));\n    if (pfds == NULL)\n        errExit(\"malloc\");\n    pollFd = calloc(numPipes, sizeof(struct pollfd));\n    if (pollFd == NULL)\n        errExit(\"malloc\");\n\n    /* Create the number of pipes specified on command line */\n\n    for (j = 0; j < numPipes; j++)\n        if (pipe(pfds[j]) == -1)\n            errExit(\"pipe %d\", j);\n\n    /* Perform specified number of writes to random pipes */\n\n    numWrites = (argc > 2) ? getInt(argv[2], GN_GT_0, \"num-writes\") : 1;\n\n    srandom((int) time(NULL));\n    for (j = 0; j < numWrites; j++) {\n        randPipe = random() % numPipes;\n        printf(\"Writing to fd: %3d (read fd: %3d)\\n\",\n                pfds[randPipe][1], pfds[randPipe][0]);\n        if (write(pfds[randPipe][1], \"a\", 1) == -1)\n            errExit(\"write %d\", pfds[randPipe][1]);\n    }\n\n    /* Build the file descriptor list to be supplied to poll(). This list\n       is set to contain the file descriptors for the read ends of all of\n       the pipes. */\n\n    for (j = 0; j < numPipes; j++) {\n        pollFd[j].fd = pfds[j][0];\n        pollFd[j].events = POLLIN;\n    }\n\n    ready = poll(pollFd, numPipes, -1);         /* Nonblocking */\n    if (ready == -1)\n        errExit(\"poll\");\n\n    printf(\"poll() returned: %d\\n\", ready);\n\n    /* Check which pipes have data available for reading */\n\n    for (j = 0; j < numPipes; j++)\n        if (pollFd[j].revents & POLLIN)\n            printf(\"Readable: %d %3d\\n\", j, pollFd[j].fd);\n\n    exit(EXIT_SUCCESS);\n}\n     `altio/poll_pipes.c`\n```", "```\n#define POLLIN_SET  (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)\n                                     /* Ready for reading */\n#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n                                     /* Ready for writing */\n#define POLLEX_SET  (POLLPRI)        /* Exceptional condition */\n```", "```\n    fcntl(fd, F_SETOWN, pid);\n    ```", "```\n    flags = fcntl(fd, F_GETFL);                 /* Get current flags */\n    fcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);\n    ```", "```\n$ `./demo_sigio`\ncnt=37; read x\ncnt=100; read x\ncnt=159; read x\ncnt=223; read x\ncnt=288; read x\ncnt=333; read #\n```", "```\n`altio/demo_sigio.c`\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <termios.h>\n#include \"tty_functions.h\"      /* Declaration of ttySetCbreak() */\n#include \"tlpi_hdr.h\"\n\nstatic volatile sig_atomic_t gotSigio = 0;\n                                /* Set nonzero on receipt of SIGIO */\n\nstatic void\nsigioHandler(int sig)\n{\n    gotSigio = 1;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, j, cnt;\n    struct termios origTermios;\n    char ch;\n    struct sigaction sa;\n    Boolean done;\n\n    /* Establish handler for \"I/O possible\" signal */\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = sigioHandler;\n    if (sigaction(SIGIO, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    /* Set owner process that is to receive \"I/O possible\" signal */\n\n    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)\n        errExit(\"fcntl(F_SETOWN)\");\n\n    /* Enable \"I/O possible\" signaling and make I/O nonblocking\n       for file descriptor */\n\n    flags = fcntl(STDIN_FILENO, F_GETFL);\n    if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1)\n        errExit(\"fcntl(F_SETFL)\");\n\n    /* Place terminal in cbreak mode */\n\n    if (ttySetCbreak(STDIN_FILENO, &origTermios) == -1)\n        errExit(\"ttySetCbreak\");\n\n    for (done = FALSE, cnt = 0; !done ; cnt++) {\n        for (j = 0; j < 100000000; j++)\n            continue;                   /* Slow main loop down a little */\n\n        if (gotSigio) {                 /* Is input available? */\n\n            /* Read all available input until error (probably EAGAIN)\n               or EOF (not actually possible in cbreak mode) or a\n               hash (#) character is read */\n\n            while (read(STDIN_FILENO, &ch, 1) > 0 && !done) {\n                printf(\"cnt=%d; read %c\\n\", cnt, ch);\n                done = ch == '#';\n            }\n\n            gotSigio = 0;\n        }\n    }\n\n    /* Restore original terminal settings */\n\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &origTermios) == -1)\n        errExit(\"tcsetattr\");\n    exit(EXIT_SUCCESS);\n}\n     `altio/demo_sigio.c`\n```", "```\nfcntl(fd, F_SETOWN, pid);\n```", "```\nid = fcntl(fd, F_GETOWN);\nif (id == -1)\n    errExit(\"fcntl\");\n```", "```\nif (fcntl(fd, F_SETSIG, sig) == -1)\n    errExit(\"fcntl\");\n```", "```\nsig = fcntl(fd, F_GETSIG);\nif (sig == -1)\n    errExit(\"fcntl\");\n```", "```\nstruct f_owner_ex {\n    int   type;\n    pid_t pid;\n};\n```", "```\n#include <sys/epoll.h>\n\nint `epoll_create`(int *size*);\n```", "```\n#include <sys/epoll.h>\n\nint `epoll_ctl`(int *epfd*, int *op*, int *fd*, struct epoll_event **ev*);\n```", "```\nstruct epoll_event {\n    uint32_t     events;        /* epoll events (bit mask) */\n    epoll_data_t data;          /* User data */\n};\n```", "```\ntypedef union epoll_data {\n    void        *ptr;           /* Pointer to user-defined data */\n    int          fd;            /* File descriptor */\n    uint32_t     u32;           /* 32-bit integer */\n    uint64_t     u64;           /* 64-bit integer */\n} epoll_data_t;\n```", "```\nint epfd;\n    struct epoll_event ev;\n\n    epfd = epoll_create(5);\n    if (epfd == -1)\n        errExit(\"epoll_create\");\n\n    ev.data.fd = fd;\n    ev.events = EPOLLIN;\n    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)\n        errExit(\"epoll_ctl\");\n```", "```\n#include <sys/epoll.h>\n\nint `epoll_wait`(int *epfd*, struct epoll_event **evlist*, int\n *maxevents*, int *timeout*);\n```", "```\n`Terminal window 1`                   `Terminal window 2`\n$ `mkfifo p q`\n$ `./epoll_input p q`\n                                    $ `cat > p`\nOpened \"p\" on fd 4\n                                    *Type Control-Z to suspend cat*\n                                    [1]+  Stopped      cat >p\n                                    $ `cat > q`\nOpened \"q\" on fd 5\nAbout to epoll_wait()\n*Type Control-Z to suspend the epoll_input program*\n[1]+  Stopped     ./epoll_input p q\n```", "```\n`qqq`\n                                    *Type Control-D to terminate “cat > q”*\n                                    $ `fg %1`\n                                    cat >p\n                                    `ppp`\n```", "```\n$ `fg`\n./epoll_input p q\nAbout to epoll_wait()\nReady: 2\n  fd=4; events: EPOLLIN\n    read 4 bytes: ppp\n\n  fd=5; events: EPOLLIN EPOLLHUP\n    read 4 bytes: qqq\n\n    closing fd 5\nAbout to epoll_wait()\n```", "```\n*Type Control-D to terminate “cat >p”*\nReady: 1\n  fd=4; events: EPOLLHUP\n    closing fd 4\nAll file descriptors closed; bye\n```", "```\n`altio/epoll_input.c`\n    #include <sys/epoll.h>\n    #include <fcntl.h>\n    #include \"tlpi_hdr.h\"\n\n    #define MAX_BUF     1000        /* Maximum bytes fetched by a single read() */\n    #define MAX_EVENTS     5        /* Maximum number of events to be returned from\n                                       a single epoll_wait() call */\n\n    int\n    main(int argc, char *argv[])\n    {\n        int epfd, ready, fd, s, j, num0penFds;\n        struct epoll_event ev;\n        struct epoll_event evlist[MAX_EVENTS];\n        char buf[MAX_BUF];\n\n        if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s file...\\n\", argv[0]);\n\n    epfd = epoll_create(argc - 1);\n        if (epfd == -1)\n            errExit(\"epoll_create\");\n\n        /* Open each file on command line, and add it to the \"interest\n           list\" for the epoll instance */\n\n    for (j = 1; j < argc; j++) {\n            fd = open(argv[j], O_RDONLY);\n            if (fd == -1)\n                errExit(\"open\");\n            printf(\"Opened \\\"%s\\\" on fd %d\\n\", argv[j], fd);\n\n            ev.events = EPOLLIN;            /* Only interested in input events */\n            ev.data.fd = fd;\n        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1)\n                errExit(\"epoll_ctl\");\n        }\n\n        numOpenFds = argc - 1;\n\n    while (numOpenFds > 0) {\n\n            /* Fetch up to MAX_EVENTS items from the ready list */\n\n            printf(\"About to epoll_wait()\\n\");\n        ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);\n            if (ready == -1) {\n            if (errno == EINTR)\n                    continue;               /* Restart if interrupted by signal */\n                else\n                    errExit(\"epoll_wait\");\n            }\n\n                printf(\"Ready: %d\\n\", ready);\n\n            /* Deal with returned list of events */\n\n        for (j = 0; j < ready; j++) {\n                printf(\"  fd=%d; events: %s%s%s\\n\", evlist[j].data.fd,\n                        (evlist[j].events & EPOLLIN)  ? \"EPOLLIN \"  : \"\",\n                        (evlist[j].events & EPOLLHUP) ? \"EPOLLHUP \" : \"\",\n                        (evlist[j].events & EPOLLERR) ? \"EPOLLERR \" : \"\");\n\n            if (evlist[j].events & EPOLLIN) {\n                    s = read(evlist[j].data.fd, buf, MAX_BUF);\n                    if (s == -1)\n                        errExit(\"read\");\n                    printf(\"    read %d bytes: %.*s\\n\", s, s, buf);\n\n            } else if (evlist[j].events & (EPOLLHUP | EPOLLERR)) {\n\n                    /* If EPOLLIN and EPOLLHUP were both set, then there might\n                       be more than MAX_BUF bytes to read. Therefore, we close\n                       the file descriptor only if EPOLLIN was not set.\n                       We'll read further bytes after the next epoll_wait(). */\n\n                    printf(\"    closing fd %d\\n\", evlist[j].data.fd);\n                if (close(evlist[j].data.fd) == -1)\n                        errExit(\"close\");\n                    numOpenFds--;\n                }\n            }\n        }\n\n        printf(\"All file descriptors closed; bye\\n\");\n        exit(EXIT_SUCCESS);\n    }\n\n          `altio/epoll_input.c`\n```", "```\nint epfd, fd1, fd2;\n    struct epoll_event ev;\n    struct epoll_event evlist[MAX_EVENTS];\n\n    /* Omitted: code to open 'fd1' and create epoll file descriptor 'epfd' ... */\n\n    ev.data.fd = fd1\n    ev.events = EPOLLIN;\n    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, ev) == -1)\n        errExit(\"epoll_ctl\");\n\n    /* Suppose that 'fd1' now happens to become ready for input */\n\n    fd2 = dup(fd1);\n    close(fd1);\n    ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);\n    if (ready == -1)\n        errExit(\"epoll_wait\");\n```", "```\nstruct epoll_event ev;\n\nev.data.fd = fd\nev.events = EPOLLIN | EPOLLET;\nif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)\n    errExit(\"epoll_ctl\");\n```", "```\nsig_atomic_t gotSig = 0;\n\nvoid\nhandler(int sig)\n{\n    gotSig = 1;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n    ...\n\n    sa.sa_sigaction = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    if (sigaction(SIGUSR1, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    /* What if the signal is delivered now? */\n\n    ready = select(nfds, &readfds, NULL, NULL, NULL);\n    if (ready > 0) {\n        printf(\"%d file descriptors ready\\n\", ready);\n    } else if (ready == -1 && errno == EINTR) {\n        if (gotSig)\n            printf(\"Got signal\\n\");\n    } else {\n        /* Some other error */\n    }\n\n    ...\n}\n```", "```\n#include <sys/select.h>\n\nint `pselect`(int *nfds*, fd_set **readfds*, fd_set **writefds*, fd_set **exceptfds*,\n            struct timespec **timeout*, const sigset_t **sigmask*);\n```", "```\nready = pselect(nfds, &readfds, &writefds, &exceptfds, timeout, &sigmask);\n```", "```\nsigset_t origmask;\n\nsigprocmask(SIG_SETMASK, &sigmask, &origmask);\nready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\nsigprocmask(SIG_SETMASK, &origmask, NULL);        /* Restore signal mask */\n```", "```\nsigset_t emptyset, blockset;\n    struct sigaction sa;\n\n    sigemptyset(&blockset);\n    sigaddset(&blockset, SIGUSR1);\n\n    if (sigprocmask(SIG_BLOCK, &blockset, NULL) == -1)\n        errExit(\"sigprocmask\");\n\n    sa.sa_sigaction = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGUSR1, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    sigemptyset(&emptyset);\n    ready = pselect(nfds, &readfds, NULL, NULL, NULL, &emptyset);\n    if (ready == -1)\n        errExit(\"pselect\");\n```", "```\n*from* `altio/self_pipe.c`\nstatic int pfd[2];                      /* File descriptors for pipe */\n\nstatic void\nhandler(int sig)\n{\n    int savedErrno;                     /* In case we change 'errno' */\n\n    savedErrno = errno;\n    if (write(pfd[1], \"x\", 1) == -1 && errno != EAGAIN)\n        errExit(\"write\");\n    errno = savedErrno;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    fd_set readfds;\n    int ready, nfds, flags;\n    struct timeval timeout;\n    struct timeval *pto;\n    struct sigaction sa;\n    char ch;\n\n    /* ... Initialize 'timeout', 'readfds', and 'nfds' for select() */\n\n    if (pipe(pfd) == -1)\n        errExit(\"pipe\");\n\n    FD_SET(pfd[0], &readfds);           /* Add read end of pipe to 'readfds' */\n    nfds = max(nfds, pfd[0] + 1);       /* And adjust 'nfds' if required */\n\n    flags = fcntl(pfd[0], F_GETFL);\n    if (flags == -1)\n        errExit(\"fcntl-F_GETFL\");\n    flags |= O_NONBLOCK;                /* Make read end nonblocking */\n    if (fcntl(pfd[0], F_SETFL, flags) == -1)\n        errExit(\"fcntl-F_SETFL\");\n\n    flags = fcntl(pfd[1], F_GETFL);\n    if (flags == -1)\n        errExit(\"fcntl-F_GETFL\");\n    flags |= O_NONBLOCK;                /* Make write end nonblocking */\n    if (fcntl(pfd[1], F_SETFL, flags) == -1)\n        errExit(\"fcntl-F_SETFL\");\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;           /* Restart interrupted read()s */\n    sa.sa_handler = handler;\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    while ((ready = select(nfds, &readfds, NULL, NULL, pto)) == -1 &&\n            errno == EINTR)\n        continue;                       /* Restart if interrupted by signal */\n    if (ready == -1)                    /* Unexpected error */\n        errExit(\"select\");\n\n    if (FD_ISSET(pfd[0], &readfds)) {   /* Handler was called */\n        printf(\"A signal was caught\\n\");\n\n        for (;;) {                      /* Consume bytes from pipe */\n            if (read(pfd[0], &ch, 1) == -1) {\n                if (errno == EAGAIN)\n                    break;              /* No more bytes */\n                else\n                    errExit(\"read\");    /* Some other error */\n            }\n\n            /* Perform any actions that should be taken in response to signal */\n        }\n    }\n\n    /* Examine file descriptor sets returned by select() to see\n       which other file descriptors are ready */\n\n}\n      *from* `altio/self_pipe.c`\n```"]