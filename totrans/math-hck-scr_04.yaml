- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Finding Patterns in Sequences**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Humans are hardwired to look for patterns and predict what comes next. Patterns
    can be complicated in the real world, with lots of variables and outcomes in time
    (when will the moon be full again?) or space (is there a bear in that cave?).
    In this chapter, we’ll explore the patterns found in sequences of numbers. You’ll
    learn how to uncover the rules for how a sequence is formed and how to predict
    later numbers in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Sequences?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *sequence* is just a list of numbers. The numbers are listed in a particular
    order—there’s a first number, a second number, a third number, and so on—so we
    can say that sequences are ordered, or *indexed*, by the positive integers. When
    we write about the mathematics of sequences, we often show the index numbers as
    subscripts. For example, we might write a sequence as *a*[1], *a*[2], *a*[3],
    . . . , where each *a* is a value in the sequence, known as a *term* or an *element*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, the numbers in a sequence tell a story about how they were generated.
    Maybe there’s a rule that describes a formula for taking an index number and manipulating
    it to produce the corresponding element of the sequence. For example, if we wanted
    to study the sequence of odd numbers (1, 3, 5, 7, . . .), we might describe the
    *n*th odd number as 2*n* – 1\. We could arrive at this formula by thinking about
    the even numbers as multiples of 2 and odd numbers as 1 less than even numbers.
    We can do a quick check to make sure this works: the first odd number is when
    index *n* = 1, and 2 ⋅ 1 – 1 = 1\. Next, when *n* = 2, we get 2*n* – 1 = 2 ⋅ 2
    – 1 = 3, and so on. We can make the pattern explicit by saying *a*[*n*] = 2*n*
    – 1, or, in words, *double the index and subtract one*.'
  prefs: []
  type: TYPE_NORMAL
- en: Maybe each index *n* represents a mathematical object, like a geometric shape,
    and the corresponding number in the sequence can be found by examining or counting
    some feature of the object. For example, if we let each *n* represent a square
    of side length *n*, we might be interested in the sequence of the squares’ areas
    (1, 4, 9, 16, . . .). Or maybe we’d want the sequence of the squares’ perimeters
    instead (4, 8, 12, 16, . . .).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Next Value in a Sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It may be possible to find a formula for a sequence like the ones just described
    that’s based on a geometric or logical pattern. That formula can then give us
    useful insight into what’s going on with the sequence. For example, we might notice
    that the numbers in the area sequence are all perfect squares and recognize that
    this has to do with a square’s area being a product of its length and width. Likewise,
    we might notice that the numbers in the perimeter sequence are all multiples of
    4 and find a reason for this in a square’s four equal sides. If we write the sequence
    of areas as *s*[1], *s*[2], *s*[3], . . . , and the sequence of perimeters as
    *p*[1], *p*[2], *p*[3], . . . , we might then find the formulas *s*[*n*] = *n*²
    and *p*[*n*] = 4*n*. These formulas are correct algebraically, but we arrived
    at them based on the geometric descriptions of the sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a sequence’s pattern is best described by providing a recipe to produce
    later terms in the sequence based on earlier terms. A *recurrence* does this by
    giving a formula for *a*[*n*] that’s based not on the index *n* but on the values
    of previous elements. For example, the perimeter sequence could be generated by
    noting that *p*[1] = 4 and that each perimeter is 4 more than the previous one.
    The element before the element with index *n* has index *n* – 1, so the formula
    could be *p*[*n*] = *p*[*n* – 1] + 4\. As long as we have the starting value (which
    is *p*[1]), we can generate the rest of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of square areas also follows its own, more subtle recurrence. Given
    the starting element *s*[1] = 1, any later element *s*[*n*] can be calculated
    as *s*[*n* – 1] + 2*n* – 1\. This gives us another way to describe the sequence.
    In general, to specify a sequence by a recurrence you must provide an initial
    value (such as *p*[1] = 4) and a rule of formation (such as *p*[*n*] = *p*[*n*
    – 1] + 4). Recurrences can sometimes depend on two or more preceding terms instead
    of just one, in which case two or more initial values must be given. A famous
    example is the Fibonacci sequence, which we’ll explore soon.
  prefs: []
  type: TYPE_NORMAL
- en: Making Sequences in Scratch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Scratch, we can represent sequences as lists. A Scratch list can hold numbers
    or strings and can be up to 200,000 items long, which is generous for exploring
    patterns. Unlike many other programming languages, which index list items starting
    from 0, Scratch indexes its lists starting from 1\. This quirk makes Scratch lists
    especially useful for representing sequences, which are also typically indexed
    starting from 1\. As mentioned in [Chapter 3](ch03.xhtml#ch03), when Scratch displays
    a list on the stage, it includes the index numbers down the left side, so you
    can easily see an item’s position in the sequence. If the list is too long to
    fit on the stage, you can scroll down to see the later entries.
  prefs: []
  type: TYPE_NORMAL
- en: The Scratch blocks for working with lists are shown in [Figure 4-1](ch04.xhtml#ch4fig1).
    These blocks are available in the Variables section of the block palette.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg81_Image_85.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Scratch’s list manipulation blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, as well as adding items at the end of a list, we can insert items
    at any position in the list, which causes the indices of later items to shift
    (increase) by 1\. We can delete list items, which also shifts the later index
    numbers (reducing them by 1), and we can replace list items with other items,
    which leaves the later indices unchanged. We can look up an item’s index to see
    where in the list it occurs, and we can check if an item occurs in the list at
    all. We can also see how long the list is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 14: Fibonacci’s Rabbits'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll explore the *Fibonacci numbers*, a famous sequence described
    by a *two-term recurrence*. This means each number in the sequence is calculated
    based on the previous two. The sequence was first mentioned in western Europe
    in the book *Liber Abaci*, written by an Italian mathematician named Fibonacci
    in 1202\. Fibonacci used the sequence to describe the growth of a population of
    rabbits.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we’re given the first two numbers in the Fibonacci sequence, *f*[1] =
    1 and *f*[2] = 1, every other number is found using this rule of formation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_86.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In other words, we add the two previous numbers in the sequence to get the next
    one. The third number is 1 + 1 = 2, the fourth is 1 + 2 = 3, the fifth is 2 +
    3 = 5, and so on. For more, we can let Scratch do the work, as in [Figure 4-2](ch04.xhtml#ch4fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_87.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Generating the Fibonacci sequence using a two-term recurrence*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice in this code that to generate numbers in a two-term recurrence, we need
    to keep track of only the previous two values to calculate the next one. We first
    set the variables named `oldold` and `old` to the starting values (`1` and `1`).
    Then, in a loop ❶, we assign the `new` variable their sum, replace `oldold` with
    `old`, and replace `old` with `new`. With these replacements, we’re ready to calculate
    the next value of `new` the next time through the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 15: The Golden Ratio'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An interesting fact about the Fibonacci sequence is that the ratios of successive
    numbers approach a limiting value, meaning the value of *f*[*n*] divided by *f*[*n*
    – 1] gets closer and closer to a particular number (the *limit*) as the sequence
    goes on, without ever quite reaching it. This is known as a *convergent ratio*.
    For Fibonacci numbers, the limit is a famous mathematical constant called the
    *golden ratio*. Its exact value is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_88.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To prove that the Fibonacci numbers have a convergent ratio, we can modify the
    code from the previous project, adding another list that keeps track of the ratios
    of each number with the previous number in the sequence. [Figure 4-3](ch04.xhtml#ch4fig3)
    shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_89.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Tracking the ratios of successive Fibonacci terms*'
  prefs: []
  type: TYPE_NORMAL
- en: The code is similar to [Figure 4-2](ch04.xhtml#ch4fig2), but with an extra list
    to keep track of the `Fibonacci ratio`. We update this list with the value of
    `old / oldold` before calculating the next term in the sequence ➋. We let the
    list go through 40 iterations ➊ because that’s where the value of the ratio stabilizes.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) shows the initial results in the two lists
    after running the code shown in [Figure 4-3](ch04.xhtml#ch4fig3). You’ll have
    to scroll down to see the later values in the lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg84_Image_90.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: The first Fibonacci numbers and their ratios*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Fibonacci` list shows the Fibonacci sequence itself, while the `Fibonacci
    ratio` list shows the ratio between each term and the one that follows it. As
    you can see, the ratios bounce around above and below their limiting value. If
    you wanted to stop the program early, taking the average of two successive list
    elements in `Fibonacci ratio` would give a better approximation of the limiting
    value than either element alone.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We used a `repeat` loop to give the program what seemed like a reasonable number
    of terms to calculate, but it may be better to let it decide for itself how many
    terms it needs. For instance, we could have the program stop calculating Fibonacci
    numbers when the ratios have sufficiently converged to the limiting value. We
    could define this as the point when the ratio values are no longer changing, or
    when they change by less than a specified amount. [Figure 4-5](ch04.xhtml#ch4fig5)
    shows a modified Fibonacci program that uses this approach.
  prefs: []
  type: TYPE_NORMAL
- en: This program no longer stores the Fibonacci numbers in a list, since we’re interested
    only in how long it takes for the ratios to converge. We use a `repeat until`
    loop ➊ to monitor the ratios as more terms are calculated, stopping when the difference
    between the current and previous ratio is less than `0.0000001`. This accuracy
    level is configurable, but if we use too many digits (too small a number), we’ll
    run into the limitations of the IEEE 754 floating-point representation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `repeat until` condition uses an absolute value function (`abs`).
    This is necessary because the ratios seesaw around the limiting value, alternately
    too big and too small. This means the difference we calculate is alternately positive
    and negative, so `abs` converts the negative values to positive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg85_Image_91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Stopping the program when the ratio converges*'
  prefs: []
  type: TYPE_NORMAL
- en: The program includes a variable called `count` to keep track of how many terms
    we need to get to the specified accuracy level. After the loop ends, the program
    stores the final ratio in the `ratio` variable ➋. On the stage, only the first
    few digits of the ratio are shown, but you can click the ratio in the coding area
    to see all the digits that were calculated, as shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg85_Image_92.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Calculating the Fibonacci ratio*'
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, you might try setting the accuracy level to different values
    (`0.01`, `0.001`, . . .) to see how many terms it takes to reach that level of
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.1** Try changing the starting conditions for the Fibonacci recurrence by
    using different initial values for `old` and `oldold` in the original Fibonacci
    program ([Figure 4-2](ch04.xhtml#ch4fig2)). Setting `old` to `2` and `oldold`
    to `1` wouldn’t be very interesting, since that just gives the Fibonacci sequence
    shifted by one number. Setting `old` to `1` and `oldold` to `2`, however, gives
    a different sequence, called the *Lucas sequence*. See if you can find any relationships
    between Lucas numbers and Fibonacci numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.2** How could you make sense of Fibonacci numbers going backward? What
    should *f*[0] be to preserve the recurrence? How about *f*[–1] and *f*[–2]? Program
    a recurrence for negative integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.3** Play with the code in [Figure 4-2](ch04.xhtml#ch4fig2) to explore its
    limits. How far can the Fibonacci sequence go before the numbers it generates
    exceed flintmax? How far before the numbers exceed the absolute limit for Scratch’s
    floating-point representation and are reported as `Infinity`? The rate of growth
    is exponential, so it doesn’t take many steps before flintmax is exceeded!'
  prefs: []
  type: TYPE_NORMAL
- en: Figurate Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figurate numbers* come from sequences that count how many points it takes
    to build nested geometric figures. For example, in [Figure 4-7](ch04.xhtml#ch4fig7)
    we have squares that fit (“nest”) inside one another. The blue points are the
    points we want to count, in this case positioned on a grid. By drawing connections
    between the points, starting from the bottom-left corner, we can create increasingly
    larger squares that encompass more and more of the points.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_93.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Nested squares as figurate numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: The word *square* can be a noun or a verb. As a noun, it names a geometric object,
    a polygon with four equal sides and four equal angles. As a verb, it’s more often
    used for arithmetic, to describe the process of multiplying a number by itself.
    Of course, the arithmetic and geometry are related. The formula *A* = *s*², used
    to calculate the area of a (geometric) square by multiplying the length of a side
    *s* by itself, interprets the arithmetic in a geometrical way. Numbers are squares
    if they’re the result of multiplying a positive integer by itself (1² = 1, 2²
    = 4, 3² = 9, 16, 25, . . .).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows how we can arrange square numbers of
    points to form ever-growing geometric squares. We have a square with 4 points
    (2 rows of 2) inside a square with 9 points (3 rows of 3) inside a square with
    16 points (4 rows of 4) inside a square with 25 points (5 rows of 5). You can
    think of the bottom-left point itself as a square with 1 point, too. Each larger
    square adds a new set of connected points around the edges of the previous square.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, any kind of polygon can be nested to make a sequence of figurate numbers
    like the sequence of squares, as we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 16: Square, Triangular, and Pentagonal Numbers?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Scratch program in the next three figures draws nested *s*-sided polygons
    and counts the newly added points around the edges to generate a sequence. So
    far, we haven’t used many of Scratch’s graphics capabilities, but in this program
    we use the Pen extension to animate the drawing of various figures. (Click the
    **Add Extensions** icon in the bottom-left corner to add these Pen blocks.) Our
    program starts with the initial setup in [Figure 4-8](ch04.xhtml#ch4fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_94.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: The setup code for drawing nested polygons*'
  prefs: []
  type: TYPE_NORMAL
- en: This `initial setup` block erases previous drawings from the screen and asks
    the user for the number of sides (in the variable `number of sides`) and the number
    of polygons to nest (in the variable `reps`) ❶. The calculation of `side length`
    ➋, which is the distance on the stage between two adjacent points, makes sure
    the polygons will fit on the stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-9](ch04.xhtml#ch4fig9) shows the main logic of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_95.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Drawing the polygons*'
  prefs: []
  type: TYPE_NORMAL
- en: We draw the nested polygons in a loop that repeats `reps` times. We start drawing
    each polygon from the bottom-left corner, using the `go to` block to skip any
    dots that we’ve already drawn (since the polygons all share the same base). After
    drawing the first side with a custom `Draw n segment(s)` block, we rotate the
    pen ❶ depending on the number of sides of the polygon. The `counter` variable
    keeps track of the total number of points drawn. Once the current polygon is complete,
    we add `counter` to `end point list` ➋. This list keeps track of how many points
    we’ve drawn at the end of each completed polygon, building up our figurate number
    sequence. We use a custom `Highlight point` block to specify how the points are
    drawn. [Figure 4-10](ch04.xhtml#ch4fig10) shows these two custom blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_96.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Drawing points and lines*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Draw n segment(s)` block takes `n` steps along the side of a polygon, first
    drawing a large dot (`pen size 5`) and then drawing a thin line (`pen size 1`)
    to connect with the next dot. The `wait` block calculates a pause between each
    step ❶, but if you get tired of watching the drawing happen, you can speed it
    up by lowering the value in the numerator.
  prefs: []
  type: TYPE_NORMAL
- en: The custom `Highlight point` block simply changes the pen color to red and increases
    its size to mark the final dot in each polygon. Then, it changes the pen color
    back to blue and reduces the size again.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s use the drawing program to generate some sequences. For the number of
    sides *s* = 4 we get squares, both geometrically and arithmetically, as shown
    in [Figure 4-11](ch04.xhtml#ch4fig11). Geometrically, each added layer of dots
    around the existing ones forms a new, larger square. Arithmetically, the numbers
    accumulated in the `end point list` sequence are all perfect squares. We arrived
    at these numbers by counting points, starting from the lower-left corner and moving
    counterclockwise, expanding outward with each layer of nesting. As mentioned earlier,
    when we complete a square, the number of points counted so far is added to the
    list and the point is highlighted in red.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: Square figurate numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to restrict ourselves to squares. *Triangular numbers* are the
    sequence generated by arranging points in nested equilateral triangles, as shown
    in [Figure 4-12](ch04.xhtml#ch4fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_98.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Triangular figurate numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that each triangular number is built by adding the next integer to the
    triangular number that came before: 1, 1 + 2 = 3, 1 + 2 + 3 = 6, 1 + 2 + 3 + 4
    = 10, and so on. In other words, the *n*th triangular number is the sum of all
    the integers from 1 to *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we describe the pattern of the sequence of triangular numbers with a
    formula? Think about putting a copy of the *n*th triangle next to itself, rotated
    to make a parallelogram, as shown in [Figure 4-13](ch04.xhtml#ch4fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_99.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: We can make a formula for triangular numbers by thinking about
    two triangles arranged to make a parallelogram.*'
  prefs: []
  type: TYPE_NORMAL
- en: The parallelogram has *n* + 1 dots across the bottom and *n* rows of dots, so
    there are *n*(*n* + 1) dots in all. Since the parallelogram was made with two
    copies of the triangle, each triangle has *n*(*n* + 1) / 2 dots in it. There’s
    the formula for the *n*th triangular number.
  prefs: []
  type: TYPE_NORMAL
- en: We can make another sequence of figurate numbers, which will be of use in [Chapter
    7](ch07.xhtml#ch07), by counting points in nested pentagons. [Figure 4-14](ch04.xhtml#ch4fig14)
    shows the sequence of *pentagonal numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: Pentagonal figurate numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: There are other interesting sequences hidden in the nested pentagons. For example,
    if you count the points and write down just the numbers of those along the green
    path in [Figure 4-14](ch04.xhtml#ch4fig14), you get 1, 2, 6, 13, 23, 36, . . .
    , as the sequence. Another path that gives a sequence we’ll need in [Chapter 7](ch07.xhtml#ch07)
    starts at 2 and goes up and to the right, along the purple path in [Figure 4-14](ch04.xhtml#ch4fig14).
    Counting around the nested pentagons gives the numbers 2, 7, 15, 26, 40, 57, .
    . . , as the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even if you set the wait time in the `Draw n segment(s)` block ([Figure 4-10](ch04.xhtml#ch4fig10)
    ❶) to `0`, there’s still a delay in drawing the polygons and reporting the values
    of the sequence of figurate numbers. If you want the results right away, you can
    speed up the program by using Turbo Mode (see [Figure 4-15](ch04.xhtml#ch4fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg92_Image_101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: Turning on Turbo Mode*'
  prefs: []
  type: TYPE_NORMAL
- en: Turbo Mode is a feature that eliminates the short pause that Scratch usually
    inserts after running blocks that update the screen. To turn it on, select **Edit
    ▸ Turn on Turbo Mode** in the Scratch Editor or hold down SHIFT while clicking
    the green flag button. When Turbo Mode is activated, there’s an indication in
    the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting Values in a Sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you see the first few terms in a sequence, a natural question is “What
    comes next?” One possible answer is “Whatever you want!” If all you know is that
    there are some numbers listed one after the other, then any number can come next.
    But if you assume that the numbers mean something—that they’re generated by following
    some kind of rule—then figuring out what comes next requires discovering the rule
    and applying it to generate the later terms. There may be more than one rule that
    works, in which case you can pick the one that seems most natural or useful to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the sequence of square numbers in [Figure 4-11](ch04.xhtml#ch4fig11).
    We could predict the next number in the sequence by finding the rule that the
    *n*th element in the sequence is *n*². The element after 9² = 81 should, then,
    be 10² = 100\. Alternatively, we could notice that for each new (geometric) square,
    we’re building on the squares that came before by adding another shell of dots
    along the top and right sides. The *n*th shell adds the *n*th odd number (2*n*
    – 1) of points to the total (so the sequence could be described as 1, 1 + 3, 1
    + 3 + 5, 1 + 3 + 5 + 7, . . .). This is an example of an *addition rule*, and
    it highlights a different aspect of the pattern. Thinking this way, we would get
    from the ninth number in the sequence (81) to the tenth number by adding (2 ⋅
    10) – 1 = 19, giving us 81 + 19 = 100\. Either way, we make the same prediction,
    but we describe what’s going on differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 17: Difference Tables Make All the Difference'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One way to understand the pattern in a sequence built with some sort of addition
    rule is to undo the addition by doing a subtraction. A *difference table* for
    a sequence is another sequence built by subtracting each term of the original
    sequence from the next one. In this project, we’ll explore how to use Scratch
    to create difference tables.
  prefs: []
  type: TYPE_NORMAL
- en: If one difference table isn’t enough to reveal a sequence’s pattern, we can
    create a second difference table by finding the differences between adjacent numbers
    in the first difference table. These are known as the *second differences* of
    the original sequence. If necessary, we can then make a third difference table
    based on the second, and so on. Sometimes, interesting patterns emerge from this
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows some Scratch code to take in a sequence
    and generate its difference table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: Building a difference table to analyze a sequence*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `initialize` block clears out the data from the last time the program
    was run. Then, the `repeat until` loop ➊ prompts us to enter a sequence, one number
    at a time, until we let Scratch know we’re done by entering an `x`. The sequence
    is stored in the `seq` list. We then build the first difference table in the `1st`
    list by calculating the differences between adjacent values in the sequence ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The additional code in [Figure 4-17](ch04.xhtml#ch4fig17) finds the second and
    third differences, storing them in the `2nd` and `3rd` lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: Calculating the second and third differences*'
  prefs: []
  type: TYPE_NORMAL
- en: This code segment follows the same pattern we used to calculate the first difference
    table, except we use the `1st` and `2nd` lists as input instead of using `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 4-18](ch04.xhtml#ch4fig18) shows the result of running the difference
    table program for the first several values from the sequence of squares: 1, 4,
    9, 16, 25, 36, 49, 64, and 81.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: Difference tables for the sequence of squares*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference table confirms what we discussed earlier: the differences
    are successive odd numbers, meaning the *n*th number in the sequence is the sum
    of the first *n* odd numbers. The second differences are constant: they’re all
    equal to 2, since successive odd numbers are always 2 apart. The third differences
    are all 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third differences of 0 are a dead giveaway that the sequence’s underlying rule
    of formation can be given as a *quadratic polynomial*, an expression of the form
    *ax*² + *bx* + *c*. Writing the rule of formation then becomes a matter of determining
    the values of *a*, *b*, and *c*, known as *coefficients*. For the sequence of
    square numbers, it’s especially easy to write the quadratic polynomial: we can
    use *a* = 1, *b* = 0, and *c* = 0\. This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the triangular numbers from [Figure 4-13](ch04.xhtml#ch4fig13), we can
    use *a* = 1/2, *b* = 1/2, and *c* = 0\. Then we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the same rule we arrived at before by treating two copies of the triangle
    as a parallelogram.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here’s a Scratch trick to make programs with lists easier to use. Suppose you
    have a list of numbers from another program—for example, the pentagonal numbers
    you generated with the code from [Project 16](ch04.xhtml#ch04lev9) ([Figure 4-14](ch04.xhtml#ch4fig14))—and
    you want to bring them into your difference table program for analysis. Rather
    than copying over the numbers by hand, one by one, you can export the whole list
    from that project by right-clicking it and selecting **Export** (see [Figure 4-19](ch04.xhtml#ch4fig19)).
    This will save the list as a text file called *end point list.txt* (or whatever
    the name of the list is) in your default directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: Saving a list for later use*'
  prefs: []
  type: TYPE_NORMAL
- en: To use that list in the difference table program, ignore the prompt to enter
    a number and instead right-click the `seq` list on the stage. Click **Import**,
    as shown in [Figure 4-20](ch04.xhtml#ch4fig20), and select the file you just saved
    to upload it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: Recovering a list for further work*'
  prefs: []
  type: TYPE_NORMAL
- en: The `seq` list will now be populated with the pentagonal numbers, so you need
    to enter only an `x` into the prompt to have the differences calculated. [Figure
    4-21](ch04.xhtml#ch4fig21) shows the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: Difference tables for the sequence of pentagonal numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: What do you know? Again, the third differences are all 0, so the sequence of
    pentagonal numbers can be generated using a quadratic polynomial too!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.4** Write a Scratch program that takes any sequence with third differences
    of 0 and recovers the coefficients *a*, *b*, and *c* for that sequence’s quadratic
    polynomial, *ax*² + *bx* + *c*. Use the program to find the coefficients for the
    pentagonal numbers. If all you want is the pentagonal number formula, it might
    help to draw the *n*th pentagon the way a young child draws a house, as a square
    with a triangular roof on top, and see it as the *n*th square with the (*n* –
    1)st triangle on top.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.5** If you exported the list of primes generated by the sieving program
    from [Project 7](ch02.xhtml#ch02lev10), import it into the difference table program
    and see what happens. The first few results are shown here. As you can see, there
    isn’t such a neat pattern of differences. Write some code to find the largest
    difference in the table of first differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**4.6** Generate a sequence with this rule: the *n*th term of the sequence
    is the number of occurrences of the digit 1 in the binary representation of *n*.
    This sequence starts 1, 1, 2, 1, 2, 2, 3, . . . , (from counting 1s in the binary
    sequence 1, 10, 11, 100, 101, 110, 111, . . .). Write a Scratch program to calculate
    a few hundred terms of this sequence and see if you can find either a formula
    or a recurrence relation to predict future terms.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.7** What happens when you make a difference table of the Fibonacci sequence?'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.8** What happens when you make a difference table of the sequence of powers
    of 2?'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.9** Try creating a difference table of the sequence of cubes (1, 8, 27,
    64, 125, . . .). You can extend the code from [Figure 4-17](ch04.xhtml#ch4fig17)
    to get higher differences to explore difference tables for higher-degree polynomials.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists in Scratch are great for keeping track of sequences of numbers, and list
    arithmetic helps us make sense of the patterns that show up. Scratch graphics
    use geometry to animate sequences of figurate numbers, and difference tables make
    the patterns in these sequences easier to see. Scratch Cat has all the answers—your
    job is to ask the questions!
  prefs: []
  type: TYPE_NORMAL
