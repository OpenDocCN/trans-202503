- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**Finding Patterns in Sequences**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在序列中寻找模式**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Humans are hardwired to look for patterns and predict what comes next. Patterns
    can be complicated in the real world, with lots of variables and outcomes in time
    (when will the moon be full again?) or space (is there a bear in that cave?).
    In this chapter, we’ll explore the patterns found in sequences of numbers. You’ll
    learn how to uncover the rules for how a sequence is formed and how to predict
    later numbers in the sequence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人类天生就能寻找模式并预测接下来会发生什么。现实世界中的模式可能很复杂，涉及到很多变量和结果，可能是时间上的（比如下次月圆是什么时候？）或空间上的（比如那个洞里有熊吗？）。在本章中，我们将探索数字序列中的模式。你将学会如何揭示序列形成的规则，以及如何预测序列中的后续数字。
- en: What Are Sequences?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是序列？
- en: A *sequence* is just a list of numbers. The numbers are listed in a particular
    order—there’s a first number, a second number, a third number, and so on—so we
    can say that sequences are ordered, or *indexed*, by the positive integers. When
    we write about the mathematics of sequences, we often show the index numbers as
    subscripts. For example, we might write a sequence as *a*[1], *a*[2], *a*[3],
    . . . , where each *a* is a value in the sequence, known as a *term* or an *element*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *序列* 就是一系列数字。这些数字按照特定的顺序排列——有第一个数字、第二个数字、第三个数字，等等——所以我们可以说序列是由正整数 *索引* 或
    *排列* 的。当我们写关于序列的数学时，我们通常会将索引数字写作下标。例如，我们可能会将一个序列写作 *a*[1]，*a*[2]，*a*[3]，. . .
    ，其中每个 *a* 是序列中的一个值，称为 *项* 或 *元素*。
- en: 'Often, the numbers in a sequence tell a story about how they were generated.
    Maybe there’s a rule that describes a formula for taking an index number and manipulating
    it to produce the corresponding element of the sequence. For example, if we wanted
    to study the sequence of odd numbers (1, 3, 5, 7, . . .), we might describe the
    *n*th odd number as 2*n* – 1\. We could arrive at this formula by thinking about
    the even numbers as multiples of 2 and odd numbers as 1 less than even numbers.
    We can do a quick check to make sure this works: the first odd number is when
    index *n* = 1, and 2 ⋅ 1 – 1 = 1\. Next, when *n* = 2, we get 2*n* – 1 = 2 ⋅ 2
    – 1 = 3, and so on. We can make the pattern explicit by saying *a*[*n*] = 2*n*
    – 1, or, in words, *double the index and subtract one*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，序列中的数字讲述了它们是如何生成的。也许有一个规则描述了一个公式，用来获取索引数字并对其进行操作，以生成对应的序列元素。例如，如果我们想研究奇数的序列（1,
    3, 5, 7, . . .），我们可能会将第 *n* 个奇数描述为 2*n* – 1。我们可以通过将偶数看作是 2 的倍数，奇数则是比偶数少 1，来推导出这个公式。我们可以快速检查这个公式是否有效：当索引
    *n* = 1 时，第一个奇数是 2 ⋅ 1 – 1 = 1。接着，当 *n* = 2 时，我们得到 2*n* – 1 = 2 ⋅ 2 – 1 = 3，以此类推。我们可以通过以下方式明确模式：*a*[*n*]
    = 2*n* – 1，或者用语言来说就是：*将索引翻倍并减去 1*。
- en: Maybe each index *n* represents a mathematical object, like a geometric shape,
    and the corresponding number in the sequence can be found by examining or counting
    some feature of the object. For example, if we let each *n* represent a square
    of side length *n*, we might be interested in the sequence of the squares’ areas
    (1, 4, 9, 16, . . .). Or maybe we’d want the sequence of the squares’ perimeters
    instead (4, 8, 12, 16, . . .).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也许每个索引 *n* 代表一个数学对象，比如几何形状，而对应的序列中的数字可以通过检查或计数该对象的一些特征来找到。例如，如果我们让每个 *n* 代表一个边长为
    *n* 的正方形，我们可能对正方形面积的序列感兴趣（1, 4, 9, 16, . . .）。或者也许我们更想要正方形周长的序列（4, 8, 12, 16,
    . . .）。
- en: Finding the Next Value in a Sequence
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在序列中寻找下一个值
- en: It may be possible to find a formula for a sequence like the ones just described
    that’s based on a geometric or logical pattern. That formula can then give us
    useful insight into what’s going on with the sequence. For example, we might notice
    that the numbers in the area sequence are all perfect squares and recognize that
    this has to do with a square’s area being a product of its length and width. Likewise,
    we might notice that the numbers in the perimeter sequence are all multiples of
    4 and find a reason for this in a square’s four equal sides. If we write the sequence
    of areas as *s*[1], *s*[2], *s*[3], . . . , and the sequence of perimeters as
    *p*[1], *p*[2], *p*[3], . . . , we might then find the formulas *s*[*n*] = *n*²
    and *p*[*n*] = 4*n*. These formulas are correct algebraically, but we arrived
    at them based on the geometric descriptions of the sequences.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a sequence’s pattern is best described by providing a recipe to produce
    later terms in the sequence based on earlier terms. A *recurrence* does this by
    giving a formula for *a*[*n*] that’s based not on the index *n* but on the values
    of previous elements. For example, the perimeter sequence could be generated by
    noting that *p*[1] = 4 and that each perimeter is 4 more than the previous one.
    The element before the element with index *n* has index *n* – 1, so the formula
    could be *p*[*n*] = *p*[*n* – 1] + 4\. As long as we have the starting value (which
    is *p*[1]), we can generate the rest of the sequence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of square areas also follows its own, more subtle recurrence. Given
    the starting element *s*[1] = 1, any later element *s*[*n*] can be calculated
    as *s*[*n* – 1] + 2*n* – 1\. This gives us another way to describe the sequence.
    In general, to specify a sequence by a recurrence you must provide an initial
    value (such as *p*[1] = 4) and a rule of formation (such as *p*[*n*] = *p*[*n*
    – 1] + 4). Recurrences can sometimes depend on two or more preceding terms instead
    of just one, in which case two or more initial values must be given. A famous
    example is the Fibonacci sequence, which we’ll explore soon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Making Sequences in Scratch
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Scratch, we can represent sequences as lists. A Scratch list can hold numbers
    or strings and can be up to 200,000 items long, which is generous for exploring
    patterns. Unlike many other programming languages, which index list items starting
    from 0, Scratch indexes its lists starting from 1\. This quirk makes Scratch lists
    especially useful for representing sequences, which are also typically indexed
    starting from 1\. As mentioned in [Chapter 3](ch03.xhtml#ch03), when Scratch displays
    a list on the stage, it includes the index numbers down the left side, so you
    can easily see an item’s position in the sequence. If the list is too long to
    fit on the stage, you can scroll down to see the later entries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The Scratch blocks for working with lists are shown in [Figure 4-1](ch04.xhtml#ch4fig1).
    These blocks are available in the Variables section of the block palette.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg81_Image_85.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Scratch’s list manipulation blocks*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, as well as adding items at the end of a list, we can insert items
    at any position in the list, which causes the indices of later items to shift
    (increase) by 1\. We can delete list items, which also shifts the later index
    numbers (reducing them by 1), and we can replace list items with other items,
    which leaves the later indices unchanged. We can look up an item’s index to see
    where in the list it occurs, and we can check if an item occurs in the list at
    all. We can also see how long the list is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 14: Fibonacci’s Rabbits'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll explore the *Fibonacci numbers*, a famous sequence described
    by a *two-term recurrence*. This means each number in the sequence is calculated
    based on the previous two. The sequence was first mentioned in western Europe
    in the book *Liber Abaci*, written by an Italian mathematician named Fibonacci
    in 1202\. Fibonacci used the sequence to describe the growth of a population of
    rabbits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'After we’re given the first two numbers in the Fibonacci sequence, *f*[1] =
    1 and *f*[2] = 1, every other number is found using this rule of formation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_86.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: In other words, we add the two previous numbers in the sequence to get the next
    one. The third number is 1 + 1 = 2, the fourth is 1 + 2 = 3, the fifth is 2 +
    3 = 5, and so on. For more, we can let Scratch do the work, as in [Figure 4-2](ch04.xhtml#ch4fig2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_87.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Generating the Fibonacci sequence using a two-term recurrence*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Notice in this code that to generate numbers in a two-term recurrence, we need
    to keep track of only the previous two values to calculate the next one. We first
    set the variables named `oldold` and `old` to the starting values (`1` and `1`).
    Then, in a loop ❶, we assign the `new` variable their sum, replace `oldold` with
    `old`, and replace `old` with `new`. With these replacements, we’re ready to calculate
    the next value of `new` the next time through the loop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 15: The Golden Ratio'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An interesting fact about the Fibonacci sequence is that the ratios of successive
    numbers approach a limiting value, meaning the value of *f*[*n*] divided by *f*[*n*
    – 1] gets closer and closer to a particular number (the *limit*) as the sequence
    goes on, without ever quite reaching it. This is known as a *convergent ratio*.
    For Fibonacci numbers, the limit is a famous mathematical constant called the
    *golden ratio*. Its exact value is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_88.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: To prove that the Fibonacci numbers have a convergent ratio, we can modify the
    code from the previous project, adding another list that keeps track of the ratios
    of each number with the previous number in the sequence. [Figure 4-3](ch04.xhtml#ch4fig3)
    shows how.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明斐波那契数列具有收敛比值，我们可以修改前一个项目中的代码，添加另一个列表来跟踪每个数字与序列中前一个数字的比值。[图4-3](ch04.xhtml#ch4fig3)展示了如何做。
- en: '![Image](../images/pg83_Image_89.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg83_Image_89.jpg)'
- en: '*Figure 4-3: Tracking the ratios of successive Fibonacci terms*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：追踪连续斐波那契项的比值*'
- en: The code is similar to [Figure 4-2](ch04.xhtml#ch4fig2), but with an extra list
    to keep track of the `Fibonacci ratio`. We update this list with the value of
    `old / oldold` before calculating the next term in the sequence ➋. We let the
    list go through 40 iterations ➊ because that’s where the value of the ratio stabilizes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[图4-2](ch04.xhtml#ch4fig2)类似，只不过多了一个额外的列表来追踪`Fibonacci ratio`。我们在计算序列中的下一个项之前，用`old
    / oldold`的值更新这个列表 ➋。我们让列表经过40次迭代 ➊，因为这是比值稳定下来的地方。
- en: The Results
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) shows the initial results in the two lists
    after running the code shown in [Figure 4-3](ch04.xhtml#ch4fig3). You’ll have
    to scroll down to see the later values in the lists.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.xhtml#ch4fig4)显示了运行[图4-3](ch04.xhtml#ch4fig3)中代码后的两个列表中的初始结果。你需要向下滚动才能查看列表中的后续值。'
- en: '![Image](../images/pg84_Image_90.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg84_Image_90.jpg)'
- en: '*Figure 4-4: The first Fibonacci numbers and their ratios*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：前几个斐波那契数及其比值*'
- en: The `Fibonacci` list shows the Fibonacci sequence itself, while the `Fibonacci
    ratio` list shows the ratio between each term and the one that follows it. As
    you can see, the ratios bounce around above and below their limiting value. If
    you wanted to stop the program early, taking the average of two successive list
    elements in `Fibonacci ratio` would give a better approximation of the limiting
    value than either element alone.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fibonacci`列表显示了斐波那契数列本身，而`Fibonacci ratio`列表显示了每一项与其后续项之间的比值。正如你所看到的，比值在它们的极限值上下波动。如果你想提前停止程序，取`Fibonacci
    ratio`中两个连续列表元素的平均值，将比单独的元素提供更好的极限值近似。'
- en: Hacking the Code
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: We used a `repeat` loop to give the program what seemed like a reasonable number
    of terms to calculate, but it may be better to let it decide for itself how many
    terms it needs. For instance, we could have the program stop calculating Fibonacci
    numbers when the ratios have sufficiently converged to the limiting value. We
    could define this as the point when the ratio values are no longer changing, or
    when they change by less than a specified amount. [Figure 4-5](ch04.xhtml#ch4fig5)
    shows a modified Fibonacci program that uses this approach.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`repeat`循环来为程序提供看起来合理的计算项数，但最好是让程序自己决定需要多少项。例如，我们可以让程序在比值足够收敛到极限值时停止计算斐波那契数。我们可以将此定义为比值不再变化的时刻，或者当它们的变化小于指定的量时。[图4-5](ch04.xhtml#ch4fig5)展示了使用这种方法的修改版斐波那契程序。
- en: This program no longer stores the Fibonacci numbers in a list, since we’re interested
    only in how long it takes for the ratios to converge. We use a `repeat until`
    loop ➊ to monitor the ratios as more terms are calculated, stopping when the difference
    between the current and previous ratio is less than `0.0000001`. This accuracy
    level is configurable, but if we use too many digits (too small a number), we’ll
    run into the limitations of the IEEE 754 floating-point representation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不再将斐波那契数存储在列表中，因为我们只关心比值收敛所需的时间。我们使用`repeat until`循环 ➊ 来监控比值随着更多项的计算而变化，直到当前比值与前一个比值的差异小于`0.0000001`为止。这个精度水平是可配置的，但如果我们使用过多的数字（过小的数字），我们将遇到IEEE
    754浮点表示法的限制。
- en: Notice that the `repeat until` condition uses an absolute value function (`abs`).
    This is necessary because the ratios seesaw around the limiting value, alternately
    too big and too small. This means the difference we calculate is alternately positive
    and negative, so `abs` converts the negative values to positive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`repeat until`条件使用了绝对值函数（`abs`）。这是必要的，因为比值在极限值周围来回摆动，交替地过大或过小。这意味着我们计算的差异交替为正值和负值，因此`abs`将负值转换为正值。
- en: '![Image](../images/pg85_Image_91.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg85_Image_91.jpg)'
- en: '*Figure 4-5: Stopping the program when the ratio converges*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：当比值收敛时停止程序*'
- en: The program includes a variable called `count` to keep track of how many terms
    we need to get to the specified accuracy level. After the loop ends, the program
    stores the final ratio in the `ratio` variable ➋. On the stage, only the first
    few digits of the ratio are shown, but you can click the ratio in the coding area
    to see all the digits that were calculated, as shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序包含一个名为 `count` 的变量，用来跟踪需要多少项才能达到指定的准确度水平。在循环结束后，程序将最终的比率存储在 `ratio` 变量中
    ➋。在舞台上，只显示比率的前几位数字，但你可以点击编码区域中的比率，查看计算出的所有数字，如[图 4-6](ch04.xhtml#ch4fig6)所示。
- en: '![Image](../images/pg85_Image_92.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg85_Image_92.jpg)'
- en: '*Figure 4-6: Calculating the Fibonacci ratio*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：计算斐波那契比率*'
- en: As an experiment, you might try setting the accuracy level to different values
    (`0.01`, `0.001`, . . .) to see how many terms it takes to reach that level of
    accuracy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，你可以尝试将准确度设置为不同的值（`0.01`，`0.001`，……），看看需要多少项才能达到那个准确度水平。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**4.1** Try changing the starting conditions for the Fibonacci recurrence by
    using different initial values for `old` and `oldold` in the original Fibonacci
    program ([Figure 4-2](ch04.xhtml#ch4fig2)). Setting `old` to `2` and `oldold`
    to `1` wouldn’t be very interesting, since that just gives the Fibonacci sequence
    shifted by one number. Setting `old` to `1` and `oldold` to `2`, however, gives
    a different sequence, called the *Lucas sequence*. See if you can find any relationships
    between Lucas numbers and Fibonacci numbers.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.1** 尝试通过在原始斐波那契程序中使用不同的初始值来更改斐波那契递归的起始条件（[图 4-2](ch04.xhtml#ch4fig2)）。将
    `old` 设置为 `2`，`oldold` 设置为 `1` 并不会很有趣，因为这只是将斐波那契数列向右平移了一位。然而，如果将 `old` 设置为 `1`，`oldold`
    设置为 `2`，则会得到一个不同的数列，称为 *卢卡斯数列*。看看你是否能找到卢卡斯数与斐波那契数之间的关系。'
- en: '**4.2** How could you make sense of Fibonacci numbers going backward? What
    should *f*[0] be to preserve the recurrence? How about *f*[–1] and *f*[–2]? Program
    a recurrence for negative integers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2** 你如何理解斐波那契数列的反向计算？为了保持递归关系，*f*[0] 应该是什么？*f*[–1] 和 *f*[–2] 又应该是什么？编写一个针对负整数的递归程序。'
- en: '**4.3** Play with the code in [Figure 4-2](ch04.xhtml#ch4fig2) to explore its
    limits. How far can the Fibonacci sequence go before the numbers it generates
    exceed flintmax? How far before the numbers exceed the absolute limit for Scratch’s
    floating-point representation and are reported as `Infinity`? The rate of growth
    is exponential, so it doesn’t take many steps before flintmax is exceeded!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.3** 在[图 4-2](ch04.xhtml#ch4fig2)中的代码上进行修改，探索它的极限。斐波那契数列能走多远，才会超出 flintmax？在数字超过
    Scratch 浮点数表示的绝对限制并被报告为 `Infinity` 之前，能走多远？增长速度是指数级的，因此不需要很多步骤，flintmax 就会被超越！'
- en: Figurate Numbers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几何数
- en: '*Figurate numbers* come from sequences that count how many points it takes
    to build nested geometric figures. For example, in [Figure 4-7](ch04.xhtml#ch4fig7)
    we have squares that fit (“nest”) inside one another. The blue points are the
    points we want to count, in this case positioned on a grid. By drawing connections
    between the points, starting from the bottom-left corner, we can create increasingly
    larger squares that encompass more and more of the points.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*几何数* 来自那些计算构建嵌套几何图形所需点数的数列。例如，在[图 4-7](ch04.xhtml#ch4fig7)中，我们有一个内嵌的正方形序列。蓝色的点是我们要计数的点，这些点位于网格上。通过连接这些点，从左下角开始，我们可以绘制出越来越大的正方形，包含越来越多的点。'
- en: '![Image](../images/pg86_Image_93.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_93.jpg)'
- en: '*Figure 4-7: Nested squares as figurate numbers*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：作为几何数的嵌套正方形*'
- en: The word *square* can be a noun or a verb. As a noun, it names a geometric object,
    a polygon with four equal sides and four equal angles. As a verb, it’s more often
    used for arithmetic, to describe the process of multiplying a number by itself.
    Of course, the arithmetic and geometry are related. The formula *A* = *s*², used
    to calculate the area of a (geometric) square by multiplying the length of a side
    *s* by itself, interprets the arithmetic in a geometrical way. Numbers are squares
    if they’re the result of multiplying a positive integer by itself (1² = 1, 2²
    = 4, 3² = 9, 16, 25, . . .).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows how we can arrange square numbers of
    points to form ever-growing geometric squares. We have a square with 4 points
    (2 rows of 2) inside a square with 9 points (3 rows of 3) inside a square with
    16 points (4 rows of 4) inside a square with 25 points (5 rows of 5). You can
    think of the bottom-left point itself as a square with 1 point, too. Each larger
    square adds a new set of connected points around the edges of the previous square.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In fact, any kind of polygon can be nested to make a sequence of figurate numbers
    like the sequence of squares, as we’ll explore next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 16: Square, Triangular, and Pentagonal Numbers?'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Scratch program in the next three figures draws nested *s*-sided polygons
    and counts the newly added points around the edges to generate a sequence. So
    far, we haven’t used many of Scratch’s graphics capabilities, but in this program
    we use the Pen extension to animate the drawing of various figures. (Click the
    **Add Extensions** icon in the bottom-left corner to add these Pen blocks.) Our
    program starts with the initial setup in [Figure 4-8](ch04.xhtml#ch4fig8).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_94.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: The setup code for drawing nested polygons*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This `initial setup` block erases previous drawings from the screen and asks
    the user for the number of sides (in the variable `number of sides`) and the number
    of polygons to nest (in the variable `reps`) ❶. The calculation of `side length`
    ➋, which is the distance on the stage between two adjacent points, makes sure
    the polygons will fit on the stage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-9](ch04.xhtml#ch4fig9) shows the main logic of the program.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_95.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Drawing the polygons*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We draw the nested polygons in a loop that repeats `reps` times. We start drawing
    each polygon from the bottom-left corner, using the `go to` block to skip any
    dots that we’ve already drawn (since the polygons all share the same base). After
    drawing the first side with a custom `Draw n segment(s)` block, we rotate the
    pen ❶ depending on the number of sides of the polygon. The `counter` variable
    keeps track of the total number of points drawn. Once the current polygon is complete,
    we add `counter` to `end point list` ➋. This list keeps track of how many points
    we’ve drawn at the end of each completed polygon, building up our figurate number
    sequence. We use a custom `Highlight point` block to specify how the points are
    drawn. [Figure 4-10](ch04.xhtml#ch4fig10) shows these two custom blocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_96.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Drawing points and lines*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The `Draw n segment(s)` block takes `n` steps along the side of a polygon, first
    drawing a large dot (`pen size 5`) and then drawing a thin line (`pen size 1`)
    to connect with the next dot. The `wait` block calculates a pause between each
    step ❶, but if you get tired of watching the drawing happen, you can speed it
    up by lowering the value in the numerator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The custom `Highlight point` block simply changes the pen color to red and increases
    its size to mark the final dot in each polygon. Then, it changes the pen color
    back to blue and reduces the size again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s use the drawing program to generate some sequences. For the number of
    sides *s* = 4 we get squares, both geometrically and arithmetically, as shown
    in [Figure 4-11](ch04.xhtml#ch4fig11). Geometrically, each added layer of dots
    around the existing ones forms a new, larger square. Arithmetically, the numbers
    accumulated in the `end point list` sequence are all perfect squares. We arrived
    at these numbers by counting points, starting from the lower-left corner and moving
    counterclockwise, expanding outward with each layer of nesting. As mentioned earlier,
    when we complete a square, the number of points counted so far is added to the
    list and the point is highlighted in red.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_97.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: Square figurate numbers*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to restrict ourselves to squares. *Triangular numbers* are the
    sequence generated by arranging points in nested equilateral triangles, as shown
    in [Figure 4-12](ch04.xhtml#ch4fig12).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_98.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Triangular figurate numbers*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that each triangular number is built by adding the next integer to the
    triangular number that came before: 1, 1 + 2 = 3, 1 + 2 + 3 = 6, 1 + 2 + 3 + 4
    = 10, and so on. In other words, the *n*th triangular number is the sum of all
    the integers from 1 to *n*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: How can we describe the pattern of the sequence of triangular numbers with a
    formula? Think about putting a copy of the *n*th triangle next to itself, rotated
    to make a parallelogram, as shown in [Figure 4-13](ch04.xhtml#ch4fig13).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_99.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: We can make a formula for triangular numbers by thinking about
    two triangles arranged to make a parallelogram.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The parallelogram has *n* + 1 dots across the bottom and *n* rows of dots, so
    there are *n*(*n* + 1) dots in all. Since the parallelogram was made with two
    copies of the triangle, each triangle has *n*(*n* + 1) / 2 dots in it. There’s
    the formula for the *n*th triangular number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: We can make another sequence of figurate numbers, which will be of use in [Chapter
    7](ch07.xhtml#ch07), by counting points in nested pentagons. [Figure 4-14](ch04.xhtml#ch4fig14)
    shows the sequence of *pentagonal numbers*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_100.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: Pentagonal figurate numbers*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: There are other interesting sequences hidden in the nested pentagons. For example,
    if you count the points and write down just the numbers of those along the green
    path in [Figure 4-14](ch04.xhtml#ch4fig14), you get 1, 2, 6, 13, 23, 36, . . .
    , as the sequence. Another path that gives a sequence we’ll need in [Chapter 7](ch07.xhtml#ch07)
    starts at 2 and goes up and to the right, along the purple path in [Figure 4-14](ch04.xhtml#ch4fig14).
    Counting around the nested pentagons gives the numbers 2, 7, 15, 26, 40, 57, .
    . . , as the sequence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even if you set the wait time in the `Draw n segment(s)` block ([Figure 4-10](ch04.xhtml#ch4fig10)
    ❶) to `0`, there’s still a delay in drawing the polygons and reporting the values
    of the sequence of figurate numbers. If you want the results right away, you can
    speed up the program by using Turbo Mode (see [Figure 4-15](ch04.xhtml#ch4fig15)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg92_Image_101.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: Turning on Turbo Mode*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Turbo Mode is a feature that eliminates the short pause that Scratch usually
    inserts after running blocks that update the screen. To turn it on, select **Edit
    ▸ Turn on Turbo Mode** in the Scratch Editor or hold down SHIFT while clicking
    the green flag button. When Turbo Mode is activated, there’s an indication in
    the menu bar.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Predicting Values in a Sequence
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you see the first few terms in a sequence, a natural question is “What
    comes next?” One possible answer is “Whatever you want!” If all you know is that
    there are some numbers listed one after the other, then any number can come next.
    But if you assume that the numbers mean something—that they’re generated by following
    some kind of rule—then figuring out what comes next requires discovering the rule
    and applying it to generate the later terms. There may be more than one rule that
    works, in which case you can pick the one that seems most natural or useful to
    you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the sequence of square numbers in [Figure 4-11](ch04.xhtml#ch4fig11).
    We could predict the next number in the sequence by finding the rule that the
    *n*th element in the sequence is *n*². The element after 9² = 81 should, then,
    be 10² = 100\. Alternatively, we could notice that for each new (geometric) square,
    we’re building on the squares that came before by adding another shell of dots
    along the top and right sides. The *n*th shell adds the *n*th odd number (2*n*
    – 1) of points to the total (so the sequence could be described as 1, 1 + 3, 1
    + 3 + 5, 1 + 3 + 5 + 7, . . .). This is an example of an *addition rule*, and
    it highlights a different aspect of the pattern. Thinking this way, we would get
    from the ninth number in the sequence (81) to the tenth number by adding (2 ⋅
    10) – 1 = 19, giving us 81 + 19 = 100\. Either way, we make the same prediction,
    but we describe what’s going on differently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 17: Difference Tables Make All the Difference'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One way to understand the pattern in a sequence built with some sort of addition
    rule is to undo the addition by doing a subtraction. A *difference table* for
    a sequence is another sequence built by subtracting each term of the original
    sequence from the next one. In this project, we’ll explore how to use Scratch
    to create difference tables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: If one difference table isn’t enough to reveal a sequence’s pattern, we can
    create a second difference table by finding the differences between adjacent numbers
    in the first difference table. These are known as the *second differences* of
    the original sequence. If necessary, we can then make a third difference table
    based on the second, and so on. Sometimes, interesting patterns emerge from this
    process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows some Scratch code to take in a sequence
    and generate its difference table.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_102.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: Building a difference table to analyze a sequence*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: First, the `initialize` block clears out the data from the last time the program
    was run. Then, the `repeat until` loop ➊ prompts us to enter a sequence, one number
    at a time, until we let Scratch know we’re done by entering an `x`. The sequence
    is stored in the `seq` list. We then build the first difference table in the `1st`
    list by calculating the differences between adjacent values in the sequence ➋.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The additional code in [Figure 4-17](ch04.xhtml#ch4fig17) finds the second and
    third differences, storing them in the `2nd` and `3rd` lists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_103.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: Calculating the second and third differences*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: This code segment follows the same pattern we used to calculate the first difference
    table, except we use the `1st` and `2nd` lists as input instead of using `seq`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 4-18](ch04.xhtml#ch4fig18) shows the result of running the difference
    table program for the first several values from the sequence of squares: 1, 4,
    9, 16, 25, 36, 49, 64, and 81.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_104.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: Difference tables for the sequence of squares*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference table confirms what we discussed earlier: the differences
    are successive odd numbers, meaning the *n*th number in the sequence is the sum
    of the first *n* odd numbers. The second differences are constant: they’re all
    equal to 2, since successive odd numbers are always 2 apart. The third differences
    are all 0.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Third differences of 0 are a dead giveaway that the sequence’s underlying rule
    of formation can be given as a *quadratic polynomial*, an expression of the form
    *ax*² + *bx* + *c*. Writing the rule of formation then becomes a matter of determining
    the values of *a*, *b*, and *c*, known as *coefficients*. For the sequence of
    square numbers, it’s especially easy to write the quadratic polynomial: we can
    use *a* = 1, *b* = 0, and *c* = 0\. This gives us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_105.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'For the triangular numbers from [Figure 4-13](ch04.xhtml#ch4fig13), we can
    use *a* = 1/2, *b* = 1/2, and *c* = 0\. Then we get:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_106.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: This is the same rule we arrived at before by treating two copies of the triangle
    as a parallelogram.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here’s a Scratch trick to make programs with lists easier to use. Suppose you
    have a list of numbers from another program—for example, the pentagonal numbers
    you generated with the code from [Project 16](ch04.xhtml#ch04lev9) ([Figure 4-14](ch04.xhtml#ch4fig14))—and
    you want to bring them into your difference table program for analysis. Rather
    than copying over the numbers by hand, one by one, you can export the whole list
    from that project by right-clicking it and selecting **Export** (see [Figure 4-19](ch04.xhtml#ch4fig19)).
    This will save the list as a text file called *end point list.txt* (or whatever
    the name of the list is) in your default directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_107.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: Saving a list for later use*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To use that list in the difference table program, ignore the prompt to enter
    a number and instead right-click the `seq` list on the stage. Click **Import**,
    as shown in [Figure 4-20](ch04.xhtml#ch4fig20), and select the file you just saved
    to upload it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_108.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: Recovering a list for further work*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `seq` list will now be populated with the pentagonal numbers, so you need
    to enter only an `x` into the prompt to have the differences calculated. [Figure
    4-21](ch04.xhtml#ch4fig21) shows the results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_109.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: Difference tables for the sequence of pentagonal numbers*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: What do you know? Again, the third differences are all 0, so the sequence of
    pentagonal numbers can be generated using a quadratic polynomial too!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**4.4** Write a Scratch program that takes any sequence with third differences
    of 0 and recovers the coefficients *a*, *b*, and *c* for that sequence’s quadratic
    polynomial, *ax*² + *bx* + *c*. Use the program to find the coefficients for the
    pentagonal numbers. If all you want is the pentagonal number formula, it might
    help to draw the *n*th pentagon the way a young child draws a house, as a square
    with a triangular roof on top, and see it as the *n*th square with the (*n* –
    1)st triangle on top.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**4.5** If you exported the list of primes generated by the sieving program
    from [Project 7](ch02.xhtml#ch02lev10), import it into the difference table program
    and see what happens. The first few results are shown here. As you can see, there
    isn’t such a neat pattern of differences. Write some code to find the largest
    difference in the table of first differences.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_110.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '**4.6** Generate a sequence with this rule: the *n*th term of the sequence
    is the number of occurrences of the digit 1 in the binary representation of *n*.
    This sequence starts 1, 1, 2, 1, 2, 2, 3, . . . , (from counting 1s in the binary
    sequence 1, 10, 11, 100, 101, 110, 111, . . .). Write a Scratch program to calculate
    a few hundred terms of this sequence and see if you can find either a formula
    or a recurrence relation to predict future terms.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**4.7** What happens when you make a difference table of the Fibonacci sequence?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**4.8** What happens when you make a difference table of the sequence of powers
    of 2?'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**4.9** Try creating a difference table of the sequence of cubes (1, 8, 27,
    64, 125, . . .). You can extend the code from [Figure 4-17](ch04.xhtml#ch4fig17)
    to get higher differences to explore difference tables for higher-degree polynomials.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists in Scratch are great for keeping track of sequences of numbers, and list
    arithmetic helps us make sense of the patterns that show up. Scratch graphics
    use geometry to animate sequences of figurate numbers, and difference tables make
    the patterns in these sequences easier to see. Scratch Cat has all the answers—your
    job is to ask the questions!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
