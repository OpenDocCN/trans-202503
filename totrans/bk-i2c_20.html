<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_349" title="349"/>16</span><br/>&#13;
<span class="ChapterTitle">Bare-Metal Peripheral Programming</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Chapter 11 described how to program an I<sup>2</sup>C controller device at the register level. This chapter provides the complement to that information, showing how to program an MCU as an I<sup>2</sup>C peripheral at the machine register level, allowing you to create your own I<sup>2</sup>C peripherals. To do so, it explores a fairly comprehensive example of such programming running on the ATtiny84 MCU, a SparkFun Atto84 board.</p>&#13;
<p>Creating a software-based (bit-banging) I<sup>2</sup>C peripheral on such an MCU as simple and slow as the ATtiny84 is next to impossible (see Chapter 3, which punted on this task). Fortunately, the ATtiny84 provides hardware <span epub:type="pagebreak" id="Page_350" title="350"/>support that enables the peripheral programming covered in this chapter, fulfilling the promise in Chapter 3 to provide support for an I<sup>2</sup>C peripheral on the ATtiny84.</p>&#13;
<h2 id="h1-502468c16-0001">	16.1	The ATtiny as an I<sup>2</sup>C Peripheral</h2>&#13;
<p class="BodyFirst">The ATtiny84—and, in fact, most of the members of the Atmel ATtiny family—provides a couple of pieces of hardware that dramatically reduce the burden on software when processing I<sup>2</sup>C bus transactions. The first and arguably most important is the <em>Universal Serial Interface (</em><em>USI)</em>, a generic shift register than can handle up to 8 data bits before overflowing (though it can be programmed for fewer bits). On the ATtiny84, you can use the USI port to implement I<sup>2</sup>C, SPI, serial, USB, and other types of communication (hence the word <em>Universal</em> in its name). </p>&#13;
<p>You can either program the USI to accept data from an external pin and make that serial data available as an 8-bit byte (serial to parallel mode) or use the USI to accept an 8-bit data value and shift it out serially on some pin. By connecting the input and output on the USI to the SDA pin, you can enable the USI to receive data from the I<sup>2</sup>C bus or transmit data onto the I<sup>2</sup>C bus. You can also select the USI’s clock source, using either an internal timer or an external pin. This is useful for I<sup>2</sup>C operation—if you choose the external option and use the SCL pin at the clock source, you can shift data into the USI synchronized to the SCL clock signal.</p>&#13;
<p>Beyond the USI, the ATtiny84 also provides a start condition detector and a shift-register overflow interrupt that allow you to quickly handle important I<sup>2</sup>C conditions that are difficult to manage on an 8-MHz CPU’s software.</p>&#13;
<p>The USI and other support hardware are not a true I<sup>2</sup>C interface; indeed, Atmel often refers to this as the two-wire interface, since they don’t fully support the I<sup>2</sup>C standard. For example, the USI does not support glitch filtering or slew rate control. You’ll have to live with other compromises as well (such as having to do considerable work in software), because the USI was not designed specifically for I<sup>2</sup>C communications. It’s a jack of all trades, master of none. </p>&#13;
<p>The information in this chapter comes from two main sources. The first is the Atmel AVR312 application note, “Using the USI Module as a I<sup>2</sup>C Slave,” which describes how to implement I<sup>2</sup>C communication using the USI. The second and biggest source is the TinyWire library (see “For More Information” at the end of this chapter). This site lists many contributors, including BroHogan, Don Blake, Jochen Toppe, and Suovula; see the source code for complete details.</p>&#13;
<p>This chapter will not repeat the discussion of the ATtiny84 MCU registers appearing in Chapter 11. Please refer to section 11.2, “ATtiny Controller Programming,” in Chapter 11 for information concerning the registers and the USI.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_351" title="351"/>GPL License for the TinyWire Library</h2>&#13;
<p class="BoxBodyFirst">The source code appearing in this chapter is open source, so let’s get the legal stuff out of the way:</p>&#13;
<p>This library is free software; you can redistribute it or modify it under the terms of version 2.1 or later of the GNU General Public License, as published by the Free Software Foundation.</p>&#13;
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>&#13;
<p>As with any GNU/GPL source code, the adapted code in this chapter also inherits this license.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-502468c16-0002">	16.2	Introducing the Memory Peripheral</h2>&#13;
<p class="BodyFirst">With a generic microcontroller like the ATtiny84, you can create a wide variety of different peripheral lines. For example, you could easily use the device to build a small port expander or ADC, given the on-board digital I/O and analog input pins. Alternatively, you could create something fancier like a NeoPixel driver (see “For More Information”) or just about anything else you could connect to an Atto84 (minus two pins, needed for the SDA and SCL lines). </p>&#13;
<p>This chapter will show you how to create a simple 4-byte memory peripheral, something you probably won’t have any real-world use for. However, working with this almost trivial device has some advantages:</p>&#13;
<ul>&#13;
<li>Because it’s simple, it’s easy to understand. You won’t waste time trying to figure out how the device works in addition to the intended challenge: learning how to create an I<sup>2</sup>C peripheral device.</li>&#13;
<li>It reduces the amount of code you have to read (and the number of pages in this book you need to pay for).</li>&#13;
<li>It provides a framework for creating more complex devices: you can easily strip out the trivial memory device code and insert code for your own real-world device.</li>&#13;
</ul>&#13;
<p>This memory device supports four memory locations. You can read and write any number of these locations with a single operation. You can also specify a starting offset into the array; if the length you specify would go beyond the end of the array, the index simply wraps back around to the beginning.</p>&#13;
<p>The I<sup>2</sup>C write command takes the form shown in <a href="#figure16-1" id="figureanchor16-1">Figure 16-1</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_352" title="352"/><figure>&#13;
<img alt="" class="" height="144" src="image_fi/502468c16/f16001.png" width="845"/>&#13;
<figcaption><p><a id="figure16-1">Figure 16-1</a>: Peripheral write command</p></figcaption>&#13;
</figure>&#13;
<p>The write command actually serves two purposes: as you would expect by its name, it allows you to write data to the four memory locations (registers). It also lets you specify the memory address (register number) from which subsequent read commands will retrieve their data along with the amount of data to fetch. </p>&#13;
<p>Read commands take the form shown in <a href="#figure16-2" id="figureanchor16-2">Figure 16-2</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="64" src="image_fi/502468c16/f16002.png" width="659"/>&#13;
<figcaption><p><a id="figure16-2">Figure 16-2</a>: Peripheral read command</p></figcaption>&#13;
</figure>&#13;
<p>Notice that a command byte immediately follows the I<sup>2</sup>C address byte in an I<sup>2</sup>C write transaction. The LO 3 bits (sss) specify a data transfer length that must be in the range 0 to 4; larger values are clipped to 4. Bits 3 and 4 (rr) specify the starting offset into the register array (the register number). Bit 5 (d) specifies a data direction: a 0 means that the rrsss bits apply to the data that immediately follow the command byte, which will be written to the register, while a 1 tells the peripheral to ignore any further data (until a stop condition comes along) and use the rrsss bits for the next I<sup>2</sup>C read operation.</p>&#13;
<p>Consider the following I<sup>2</sup>C bus sequences:</p>&#13;
<pre><code>40 04 01 02 03 04&#13;
40 24&#13;
41 <var>ww xx yy zz</var></code></pre>&#13;
<p>The first byte of the first line is an I<sup>2</sup>C write operation to the device at address 0x20 (the memory peripheral). The command byte specifies d = 0 (memory write), rr = 0, and sss = 4. This writes the following 4 bytes (1, 2, 3, and 4) to memory locations 0 through 3. </p>&#13;
<p>The second line is also an I<sup>2</sup>C write operation. The command byte specifies d = 1 (memory read), rr = 0, and sss = 4. When the d bit is 0, there is no data payload after the command byte. This write operation appears to be specifying a memory read operation, which might seem odd; in reality, however, it’s just setting the peripheral’s read parameter registers in preparation for a data read. </p>&#13;
<p>The third line in this example is an I<sup>2</sup>C read operation (LO bit of the address byte contains 1). Immediately after the controller puts this address <span epub:type="pagebreak" id="Page_353" title="353"/>byte on the bus, the peripheral responds by returning 4 bytes (the number of bytes specified by the previous write command on line two). In this case, <var>ww</var>, <var>xx</var>, <var>yy</var>, and <var>zz</var> will actually be 01, 02, 03, and 04, as the command on the first line previously wrote those values to the registers.</p>&#13;
<p>This memory peripheral has some additional semantics, but you should now understand the core of what is happening in the code. I’ll refer you to the source code for more specific issues, such as address wraparound, multiple read operations, and so on. </p>&#13;
<h2 id="h1-502468c16-0003">	16.3	The Memory Peripheral Software Architecture</h2>&#13;
<p class="BodyFirst">The memory peripheral software has four main components:</p>&#13;
<ul>&#13;
<li>Initialization code</li>&#13;
<li>Interrupt service routines</li>&#13;
<li>Callbacks to the main program (from the ISRs)</li>&#13;
<li>The main loop</li>&#13;
</ul>&#13;
<p>The program is broken up into two pieces: the main file containing the Arduino <code>setup()</code> and <code>loop()</code> functions, as well as the callback functions, and a second file containing the library code that handles I<sup>2</sup>C operations—specifically, the ISRs and utility functions (which the following paragraphs briefly describe).</p>&#13;
<p>The <code>setup()</code> function calls the ISR library initialization function and sets up pointer addresses to the callback functions.  The main Arduino loop is empty (the CPU just idly spins when interrupt processing isn’t happening) because the ISRs handle all the work. In a more complex peripheral design, you’d probably handle background activities in the main loop.</p>&#13;
<p>There are three callback functions in this program, which the ISRs call in three situations:</p>&#13;
<ul>&#13;
<li>Before transmitting any data from the peripheral to the controller in response to an I<sup>2</sup>C read request</li>&#13;
<li>After transmitting the data from the peripheral to the controller in response to an I<sup>2</sup>C read request, when an ACK or a NAK is expected from the controller</li>&#13;
<li>Upon receiving data from the controller in response to an I<sup>2</sup>C write request</li>&#13;
</ul>&#13;
<p class="BodyContinued">These callbacks are generally responsible for supplying data to send to the controller (for an I<sup>2</sup>C read operation) or dealing with data arriving from a controller (for an I<sup>2</sup>C write operation).</p>&#13;
<p>The two main ISRs in the system handle two events: the presence of a start condition and the completion of a data byte transaction (receipt or transmission) on the I<sup>2</sup>C bus. Because these events happen infrequently and don’t demand too much processor time, I<sup>2</sup>C transactions don’t swamp <span epub:type="pagebreak" id="Page_354" title="354"/>the CPU as they did in the bit-banging approach (see Chapter 3 for the bit-banging approach).</p>&#13;
<h3 id="h2-502468c16-0001">16.3.1	The Main File</h3>&#13;
<p class="BodyFirst">This section walks through <em>attiny84_Periph.ino</em>, the main program for the memory peripheral device. Because of the size and complexity of this source file, I will break it up into pieces and describe each piece separately.</p>&#13;
<p>The first section covers the comments and <code>#include</code> statements you find in a typical C or C++ program:</p>&#13;
<pre><code>// attiny84_Periph.ino&#13;
//&#13;
// Implements a simple I2C peripheral&#13;
// running on a SparkFun Atto84 (ATtiny84).&#13;
//&#13;
// I2C protocol for this device:&#13;
//&#13;
// For I2C write operations:&#13;
//&#13;
//  |adrs+W| cmd | optional Data |&#13;
//&#13;
//  cmd:&#13;
//      00drrsss&#13;
//&#13;
// where d is 0 for write operation and 1 for read,&#13;
// rr specifies a "register number" (which is an index&#13;
// into "i2c_regs" array below), and sss is a size (0-4).&#13;
//&#13;
// For write operations (d = 0) then, there will be sss&#13;
// additional bytes (max 4) following the cmd byte.&#13;
// These bytes will be written to i2c_regs starting&#13;
// at offset rr (wrapping around to the beginning&#13;
// of the array if sss+rr &gt;= 4).&#13;
//&#13;
// For read operations (d = 1), any additional data beyond&#13;
// the cmd byte is ignored (up to the stop condition).&#13;
//&#13;
// For I2C read operations:&#13;
//&#13;
//  |adrs+R| Data |&#13;
//&#13;
// where "Data" is the number of bytes specified by the&#13;
// last I2C write operation with d = 1 (number of bytes will&#13;
// be sss). Data transferred is from i2c_regs starting at&#13;
// location rr (from the last write operation).&#13;
//&#13;
// Consecutive I2C read operations, without intervening&#13;
// writes, will read the same locations from the registers.&#13;
&#13;
#define I2C_PERIPH_ADDRESS 0x20 // The 7-bit address&#13;
&#13;
#define __AVR_ATtiny84__&#13;
<span epub:type="pagebreak" id="Page_355" title="355"/>extern "C" {&#13;
  #include &lt;inttypes.h&gt;&#13;
  #include "usiI2CPeriph.h"&#13;
  #include &lt;avr/interrupt.h&gt;&#13;
  }&#13;
&#13;
#include "Arduino.h"</code></pre>&#13;
<p>Next, the memory peripheral program stores the 4 bytes in the <code>i2c_regs</code> variable:</p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// 4-byte R/W register area&#13;
// for this sample program:&#13;
&#13;
volatile uint8_t i2c_regs[4] =&#13;
{&#13;
    0xDE,&#13;
    0xAD,&#13;
    0xBE,&#13;
    0xEF,&#13;
};&#13;
&#13;
// Tracks the current register pointer position&#13;
// for read and write operations.&#13;
//&#13;
// *_position holds the index into i2c_regs&#13;
// where I2C reads and writes will begin.&#13;
//&#13;
// *size holds the number of bytes for&#13;
// the read/write operation.&#13;
&#13;
volatile byte reg_position;    // For writes&#13;
volatile byte size;            // For writes&#13;
&#13;
volatile size_t read_position; // For reads&#13;
volatile size_t read_size;     // For reads&#13;
&#13;
const byte reg_size = sizeof( i2c_regs );&#13;
&#13;
// Command byte bits:&#13;
&#13;
#define cmdSizeMask (0b000111)&#13;
#define cmdRegMask  (0b011000)&#13;
#define cmdDirMask  (0b100000)</code></pre>&#13;
<p>This section of the program also contains the global variables that track the rr and sss values in the last command byte. There are two sets of these variables—one for memory read operations (d = 1) and one for memory write operations (d = 0). This section also includes some defines for command bit masks.</p>&#13;
<p><span epub:type="pagebreak" id="Page_356" title="356"/>The next section begins the callback routines. The interrupt service routines call the <code>requestHandledEvent()</code> function once it’s done transmitting a byte to the controller in response to an I<sup>2</sup>C read command: </p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// requestHandledEvent-&#13;
//&#13;
// Called after data has been shipped&#13;
// to the controller.&#13;
&#13;
void requestHandledEvent()&#13;
{&#13;
}</code></pre>&#13;
<p>At this point, the code expects an ACK or a NAK from the controller. Normally, this function would handle cleanup (such as clearing buffers, turning off electronic signals, and so on). However, since the memory peripheral requires no cleanup, this function simply returns. For this project, you technically could have skipped initializing the pointer to this function, since the library’s default condition is to do nothing; I’ve included it just so you’re aware of its presence in the system.</p>&#13;
<p>Next comes the <code>requestEvent()</code> callback function. The ISRs call this function when an I<sup>2</sup>C read command has arrived, before actually transmitting any data to the controller. </p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// requestEvent-&#13;
//&#13;
// Called before data has been shipped&#13;
// to the controller.&#13;
&#13;
void requestEvent()&#13;
{&#13;
        for( size_t i=0; i &lt; read_size; ++i )&#13;
        {&#13;
            size_t index = (read_position+i) %  reg_size;&#13;
            usiI2CTransmitByte( i2c_regs[index] );&#13;
        }&#13;
}</code></pre>&#13;
<p>In theory, you could use this function to initialize the output stream with the data that the ISRs will transmit to the controller, but this code uses <code>usiI2CTransmitByte()</code> for that purpose. Like the Arduino <code>Wire.write()</code> function, <code>requestEvent()</code> doesn’t actually transmit the data; the function just appends it to an internal buffer. The ISRs will handle the actual data transmission later. In this source code, this buffer has a limited length of 16 bytes. If you attempt to insert more than 16 bytes into the buffer, the code will block until space becomes available. For the memory peripheral device, <code>requestEvent()</code> just fetches the number of bytes specified by the <code>read_size</code> variable (filled in by the sss field of the command byte from the previous <span epub:type="pagebreak" id="Page_357" title="357"/>write operation), starting at the offset specified by the <code>read_position</code> global (from the rr field).</p>&#13;
<p>Next, the callback function <code>receiveEvent()</code> handles the data stream received from the controller during an I<sup>2</sup>C write operation. </p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// receiveEvent-&#13;
//&#13;
// Called when data has been received&#13;
// from the controller.&#13;
//&#13;
// Parse the received data and set up the&#13;
// position and size variables as needed.&#13;
// If optional data arrives, store it into&#13;
// the i2c_regs array.&#13;
//&#13;
// rcvCnt parameter specifies the&#13;
// number of bytes received.&#13;
&#13;
void receiveEvent( uint8_t rcvCnt )&#13;
{&#13;
    byte cmd;&#13;
&#13;
    // Punt if controller sent too&#13;
    // much data...&#13;
&#13;
    if( rcvCnt &gt; I2C_RX_BUFFER_SIZE )&#13;
    {&#13;
        return;&#13;
    }&#13;
&#13;
    // ...or too little:&#13;
&#13;
    if( rcvCnt &gt; 0 )&#13;
    {&#13;
        cmd             = usiI2CReceiveByte();&#13;
        size            = cmd &amp; cmdSizeMask;&#13;
&#13;
        // cmdSizeMask is 3 bits, but&#13;
        // the maximum size is 4.&#13;
        // Enforce that here:&#13;
&#13;
        if( size &gt; 4 )&#13;
        {&#13;
            size = 4;&#13;
        }&#13;
        reg_position    = cmd &amp; cmdRegMask;&#13;
        reg_position  &gt;&gt;= 3;&#13;
&#13;
        // Determine if the controller is&#13;
        // specifying a read operation or a&#13;
        // write operation. This is not the&#13;
<span epub:type="pagebreak" id="Page_358" title="358"/>        // R/W bit in the address byte (you&#13;
        // got here on an I2C write). The&#13;
        // direction bit specifies whether&#13;
        // whether you can expect an I2C&#13;
        // read operation after this command&#13;
        // to read the specified data.&#13;
&#13;
        if( cmd &amp; cmdDirMask )&#13;
        {&#13;
             // A read command, just set up&#13;
             // the count and pointer values&#13;
             // for any upcoming reads.&#13;
&#13;
            read_size = size;&#13;
            read_position = reg_position;&#13;
        }&#13;
        else // A write command&#13;
        {&#13;
            // Copy any additional data the&#13;
            // controller sends you to the&#13;
            // i2c_regs array. Note that&#13;
            // this code ignores any bytes&#13;
            // beyond the fourth one the&#13;
            // controller sends.&#13;
&#13;
            byte maxXfer = 4;&#13;
            while( --rcvCnt &amp;&amp; maxXfer-- )&#13;
            {&#13;
                i2c_regs[reg_position] = usiI2CReceiveByte();&#13;
                reg_position++;&#13;
                if( reg_position &gt;= reg_size )&#13;
                {&#13;
                    reg_position = 0;&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p>The <code>receiveEvent()</code> function is responsible for stripping out the bits from the command byte, parsing the command, and dealing with any additional data appearing beyond the command byte (that is, writing that data to the <code>i2c_regs</code> array).</p>&#13;
<p>Next, the <code>setup()</code> function calls the ISR library code’s initialization function <code>usiI2CPeripheralInit()</code>, which does most of the real work, and then sets up the address of the callback functions. </p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// Usual Arduino initialization code&#13;
// even for an I2C peripheral application.&#13;
&#13;
void setup()&#13;
<span epub:type="pagebreak" id="Page_359" title="359"/>{&#13;
&#13;
    // Initialize the peripheral code:&#13;
&#13;
    usiI2CPeripheralInit( I2C_PERIPH_ADDRESS );&#13;
&#13;
    // Set up callbacks to local functions:&#13;
&#13;
    usi_onReceiverPtr = receiveEvent;&#13;
    usi_onRequestPtr = requestEvent;&#13;
    usi_afterRequestPtr = requestHandledEvent;&#13;
}</code></pre>&#13;
<p>The <code>setup()</code> function must also initialize the pointers to the callback functions. Since the ISRs do all the real work, the main Arduino loop is empty:</p>&#13;
<pre><code>// attiny84_Periph.ino (cont.)&#13;
//&#13;
// The main loop does nothing but spin its&#13;
// wheels. All the work in this sample&#13;
// program is done inside the ISRs and&#13;
// callback functions. If this peripheral&#13;
// were a little more complex, background&#13;
// activities could be taken care of here.&#13;
&#13;
void loop()&#13;
{&#13;
    // Do nothing.&#13;
}</code></pre>&#13;
<p>If this peripheral device were a little more complex, the <code>main()</code> function could handle some background tasks while waiting for I<sup>2</sup>C commands to arrive.</p>&#13;
<h3 id="h2-502468c16-0002">16.3.2	The Interrupt Service Routine Library</h3>&#13;
<p class="BodyFirst">This section will discuss <em>usiI2CPeriph.c</em>, the source code for the ISR module. This is a modification of the original AVR two-wire peripheral code written by Donald Blake and modified by Jochen Toppe. I have made further modifications to adjust for the sample application in <em>attiny84_Periph.ino</em>.</p>&#13;
<p>As in the previous section, I’ll describe this code piece by piece. As this code is an implementation of the architecture that Atmel’s AVR312 application note describes, it wouldn’t hurt to have a copy of the application note available so you can reference it while reading this code (see “For More Information”).</p>&#13;
<p>As usual, the first part of the source file contains introductory comments, header file includes, and some important defines and macros:</p>&#13;
<pre><code>// usiI2CPeriph.c&#13;
//&#13;
// USI I2C Peripheral driver.&#13;
// &#13;
// Created by Donald R. Blake, donblake at worldnet.att.net.&#13;
// Adapted by Jochen Toppe, jochen.toppe at jtoee.com.&#13;
<span epub:type="pagebreak" id="Page_360" title="360"/>// Further modifications by Randall Hyde for "The Book of I2C."&#13;
// &#13;
// ----------------------------------------------------------&#13;
// &#13;
// Created from Atmel source files for Application Note &#13;
// AVR312: Using the USI Module as an I2C peripheral.&#13;
&#13;
#include &lt;avr/io.h&gt;&#13;
#include &lt;avr/interrupt.h&gt;&#13;
&#13;
#include "usiI2CPeriph.h"&#13;
&#13;
#define breakif(x) if(x) break&#13;
&#13;
// Device dependent defines:&#13;
&#13;
#define DDR_USI             DDRA&#13;
#define PORT_USI            PORTA&#13;
#define PIN_USI             PINA&#13;
#define PORT_USI_SDA        PORTA6&#13;
#define PORT_USI_SCL        PORTA4&#13;
#define PIN_USI_SDA         PINA6&#13;
#define PIN_USI_SCL         PINA4&#13;
#define USI_START_COND_INT  USISIF&#13;
#define USI_START_VECTOR    USI_START_vect&#13;
#define USI_OVERFLOW_VECTOR USI_OVF_vect&#13;
&#13;
// These macros make the stop condition detection code &#13;
// more readable.&#13;
&#13;
#define USI_PINS_SCL_SDA            \&#13;
    (                               \&#13;
            ( 1 &lt;&lt; PIN_USI_SDA )    \&#13;
        |   ( 1 &lt;&lt; PIN_USI_SCL )    \&#13;
    )&#13;
    &#13;
#define USI_PINS_SDA     ( 1 &lt;&lt; PIN_USI_SDA )&#13;
#define USI_PINS_SCL     ( 1 &lt;&lt; PIN_USI_SCL )</code></pre>&#13;
<p>The <code>DDRA</code>, <code>PORTA</code>, <code>PORTA6</code>, <code>PINA6</code>, <code>PINA4</code>, <code>USISIF</code>, <code>USI_START_vect</code>, and <code>USI_OVF_vect</code> definitions appear in the <em>avr/io.h</em> header file.</p>&#13;
<p>The <code>USI Overflow</code> ISR (from AVR312, <code>ISR( USI_OVERFLOW_VECTOR )</code> in this code) implements a state machine, as per AVR312. The <code>ISRstate_t</code> type definition provides meaningful names for each of the states this function implements. See the code comments for a description of each of these states:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
/***********************************************************&#13;
&#13;
                     typedef's&#13;
&#13;
************************************************************/&#13;
&#13;
<span epub:type="pagebreak" id="Page_361" title="361"/>// ISRstate_t are the different states possible for&#13;
// the ISR state machine that handles incoming&#13;
// bytes from the controller.&#13;
&#13;
typedef enum&#13;
{&#13;
    // Address byte has just arrived:&#13;
    &#13;
    USI_PERIPH_CHECK_ADDRESS                = 0x00,&#13;
    &#13;
    // Peripheral is transmitting bytes to&#13;
    // the controller (I2C read transaction).&#13;
    &#13;
    USI_PERIPH_SEND_DATA                    = 0x01,&#13;
    &#13;
    // Receive an ACK from controller after sending&#13;
    // a byte to it.&#13;
    &#13;
    USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA = 0x02,&#13;
    &#13;
    // Deals with ACK or NAK received from&#13;
    // controller after sending a byte&#13;
    // to the controller (I2C read).&#13;
    &#13;
    USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA   = 0x03,&#13;
    &#13;
    // Handle data coming to the peripheral&#13;
    // (I2C write operation).&#13;
    &#13;
    USI_PERIPH_REQUEST_DATA                 = 0x04,&#13;
    USI_PERIPH_GET_DATA_AND_SEND_ACK        = 0x05&#13;
} ISRstate_t;</code></pre>&#13;
<p>Next up are some global variables (local to this source file):</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
/***********************************************************&#13;
&#13;
                    local variables&#13;
&#13;
************************************************************/&#13;
&#13;
// periphAddress holds the 7-bit I2C address.&#13;
&#13;
static uint8_t              periphAddress;&#13;
static uint8_t              sleep_enable_bit;&#13;
static uint8_t              in_transaction;&#13;
static volatile ISRstate_t  ISRstate;&#13;
&#13;
&#13;
static uint8_t          rxBuf[I2C_RX_BUFFER_SIZE];&#13;
static volatile uint8_t rxHead;&#13;
static volatile uint8_t rxTail;&#13;
<span epub:type="pagebreak" id="Page_362" title="362"/>static volatile uint8_t rxCount;&#13;
&#13;
static uint8_t          txBuf[I2C_TX_BUFFER_SIZE];&#13;
static volatile uint8_t txHead;&#13;
static volatile uint8_t txTail;&#13;
static volatile uint8_t txCount;</code></pre>&#13;
<p>These variables are used as follows:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>periphAddress</code></span></span>  Holds the peripheral device’s I<sup>2</sup>C address (for example, 0x20 for the memory peripheral device)</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>sleep_enable_bit</code></span></span>  Saves the state of the SE bit in the MCUCR register as this bit gets overwritten by changes to the MCUCR in the ISRs</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>in_transaction</code></span></span>  A Boolean variable that tracks whether you’re in the middle of an I<sup>2</sup>C transaction (that is, you haven’t yet seen a stop condition) while entering and leaving the overflow ISR</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>ISRstate</code></span></span>  Holds the current state value (<code>ISRstate_t</code>) for the overflow ISR state machine</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>rx*</code></span> variables</span>  Receive buffer variables</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>tx*</code></span> variables</span>  Transmit buffer variables</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>usi_onRequestPtr</code></span></span>  Pointer to callback function that the overflow ISR calls after receiving the address byte but before returning any data to the controller device</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>usi_onReceiverPtr</code></span></span>  Pointer to the callback function that the overflow ISR calls after receiving the address byte but before reading any additional data sent by the controller device on an I<sup>2</sup>C write operation</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>usi_afterRequestPtr</code></span></span>  Pointer to callback function that the overflow ISR calls after processing all the bytes received from the controller on an I<sup>2</sup>C read operation</li>&#13;
</ol>&#13;
<p>There are also three function pointers appearing in the global declarations: <code>usi_afterRequestPtr</code>, <code>usi_onRequestPtr</code>, and <code>usi_onReceiverPtr</code>. In addition to these variables, this section defines two empty functions with which it initializes the callback pointers. Pre-initializing these function pointers spares the code from having to check if these pointers contain NULL.</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// Dummy functions so you don’t have to check if&#13;
// usi_afterRequestPtr or usi_onReceiverPtr are NULL.&#13;
&#13;
static void dummy1( void ){}&#13;
static void dummy2( uint8_t d ){}&#13;
&#13;
&#13;
void    (*usi_afterRequestPtr)( void )    = dummy1;&#13;
void    (*usi_onRequestPtr)( void )       = dummy1;&#13;
void    (*usi_onReceiverPtr)( uint8_t )   = dummy2;</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_363" title="363"/>Next are a couple of utility support functions private to this source file. </p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
/***********************************************************&#13;
&#13;
                    Local functions&#13;
&#13;
************************************************************/&#13;
&#13;
// Flushes the I2C buffers.&#13;
&#13;
static void flushI2CBuffers( void )&#13;
{&#13;
  rxTail = 0;&#13;
  rxHead = 0;&#13;
  rxCount = 0;&#13;
  txTail = 0;&#13;
  txHead = 0;&#13;
  txCount = 0;&#13;
} // End flushI2CBuffers</code></pre>&#13;
<p>The <code>startSetConditionMode()</code> function initializes the ATtiny84’s interrupt system to disable the USI overflow interrupt and enable the start condition interrupt. This happens, for example, when an I<sup>2</sup>C transaction is complete and the peripheral is waiting for another start condition to come along. Once the code initializes these interrupts, it can do something else (currently just spinning in the empty loop function) until the next start condition. </p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// startSetConditionMode-&#13;
//&#13;
// This initializes the interrupt system so that&#13;
// the code waits for the arrival of a start&#13;
// condition (and generates an interrupt when&#13;
// one arrives).&#13;
&#13;
static void setStartConditionMode( void )&#13;
{&#13;
    USICR =&#13;
            // Enable Start Condition Interrupt.&#13;
    &#13;
            ( 1 &lt;&lt; USISIE )&#13;
            &#13;
            // Disable Overflow Interrupt.&#13;
            &#13;
        |   ( 0 &lt;&lt; USIOIE )&#13;
        &#13;
            // Set USI in two-wire mode.&#13;
            &#13;
        |   ( 1 &lt;&lt; USIWM1 ) &#13;
        &#13;
<span epub:type="pagebreak" id="Page_364" title="364"/>            // No USI Counter overflow hold.&#13;
        &#13;
        |   ( 0 &lt;&lt; USIWM0 )&#13;
        &#13;
            // Shift Register Clock Source = external, &#13;
            // positive edge.&#13;
            &#13;
        |   ( 1 &lt;&lt; USICS1 )&#13;
        |   ( 0 &lt;&lt; USICS0 ) &#13;
        &#13;
            // 4-Bit Counter Source = external, &#13;
            // both edges.&#13;
&#13;
        |   ( 0 &lt;&lt; USICLK )&#13;
        &#13;
            // No toggle clock-port pin.&#13;
            &#13;
        |   ( 0 &lt;&lt; USITC );&#13;
        &#13;
    // Clear all interrupt flags, except Start Cond.&#13;
    &#13;
    USISR =&#13;
            ( 0 &lt;&lt; USI_START_COND_INT )&#13;
        |   ( 1 &lt;&lt; USIOIF )&#13;
        |   ( 1 &lt;&lt; USIPF )&#13;
        |   ( 1 &lt;&lt; USIDC )&#13;
        |   ( 0x0 &lt;&lt; USICNT0 );&#13;
}</code></pre>&#13;
<p>See section 11.2, “ATtiny Controller Programming,” in Chapter 11 for an explanation of the USICR and USISR registers that appear in this code. </p>&#13;
<p>The next section of the program introduces public functions that the main application can call, beginning with the main ISR initialization function. This programs the SDA and SCL lines as outputs, programs them high (the quiescent state), and sets up the system to wait for a start condition interrupt.</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
/***********************************************************&#13;
&#13;
                    Public functions&#13;
&#13;
************************************************************/&#13;
&#13;
// Initialize USI for I2C peripheral mode.&#13;
&#13;
void usiI2CPeripheralInit( uint8_t ownAddress )&#13;
{&#13;
    // Initialize the TX and RX buffers to empty.&#13;
&#13;
    flushI2CBuffers( );&#13;
<span epub:type="pagebreak" id="Page_365" title="365"/>    periphAddress = ownAddress;&#13;
&#13;
    // In two-wire (I2C) mode (USIWM1, USIWM0 = 1X),&#13;
    // the peripheral USI will pull SCL low when a &#13;
    // start condition is detected or a counter &#13;
    // overflow (only for USIWM1, USIWM0 = 11). This&#13;
    // inserts a wait state. SCL is released by the &#13;
    // ISRs (USI_START_vect and USI_OVERFLOW_vect).&#13;
    // &#13;
    // Set SCL and SDA as output.&#13;
    &#13;
    DDR_USI |= ( 1 &lt;&lt; PORT_USI_SCL ) | ( 1 &lt;&lt; PORT_USI_SDA );&#13;
&#13;
    // Set SCL high.&#13;
    &#13;
    PORT_USI |= ( 1 &lt;&lt; PORT_USI_SCL );&#13;
&#13;
    // Set SDA high.&#13;
    &#13;
    PORT_USI |= ( 1 &lt;&lt; PORT_USI_SDA );&#13;
&#13;
    // Set SDA as input.&#13;
    &#13;
    DDR_USI &amp;= ~( 1 &lt;&lt; PORT_USI_SDA );&#13;
&#13;
    USICR =&#13;
            // Enable Start Condition Interrupt.&#13;
            &#13;
            ( 1 &lt;&lt; USISIE )&#13;
            &#13;
            // Disable Overflow Interrupt.&#13;
            &#13;
       |    ( 0 &lt;&lt; USIOIE )&#13;
       &#13;
            // Set USI in two-wire mode.&#13;
        &#13;
       |    ( 1 &lt;&lt; USIWM1 ) &#13;
       &#13;
            // No USI Counter overflow hold.&#13;
&#13;
       |    ( 0 &lt;&lt; USIWM0 )&#13;
       &#13;
           // Shift Register Clock Source = external, &#13;
           // positive edge.&#13;
           // 4-Bit Counter Source = external, both edges.&#13;
       &#13;
        |   ( 1 &lt;&lt; USICS1 ) &#13;
        |   ( 0 &lt;&lt; USICS0 )&#13;
        |   ( 0 &lt;&lt; USICLK )&#13;
        &#13;
           // No toggle clock-port pin.&#13;
            &#13;
       |    ( 0 &lt;&lt; USITC );&#13;
<span epub:type="pagebreak" id="Page_366" title="366"/>&#13;
    // Clear all interrupt flags and reset overflow counter.&#13;
&#13;
    USISR = &#13;
            ( 1 &lt;&lt; USI_START_COND_INT ) &#13;
        |   ( 1 &lt;&lt; USIOIF ) &#13;
        |   ( 1 &lt;&lt; USIPF )&#13;
        |   ( 1 &lt;&lt; USIDC );&#13;
&#13;
    // The in_transaction variable remembers if the &#13;
    // usiI2CPeriph driver is in the middle of&#13;
    // an I2C transaction. Initialize it to 0.&#13;
    &#13;
    in_transaction = 0;&#13;
&#13;
} // end usiI2CPeripheralInit</code></pre>&#13;
<p>Up next are various functions for testing the presence of data in the transmit and receive buffers, as well as inserting data into, and extracting data from, these buffers:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// usiI2CDataInTransmitBuffer-&#13;
//&#13;
// Return 0 (false) if the transmit buffer is empty, true&#13;
// (nonzero) if data is available in the transmit buffer.&#13;
&#13;
bool usiI2CDataInTransmitBuffer( void )&#13;
{&#13;
    return txCount; // Actual count is nonzero&#13;
                    // if data available :)&#13;
} // End usiI2CDataInTransmitBuffer&#13;
&#13;
// usiI2CTransmitByte-&#13;
//&#13;
// Adds a byte to the transmission buffer, &#13;
// wait for bytes to be transmitted &#13;
// if buffer is full.&#13;
//&#13;
// Race condition warning: As this function&#13;
// modifies txCount, it should be called only&#13;
// from the USI_OVERFLOW_VECTOR ISR or code&#13;
// called from it. Otherwise, there could&#13;
// be problems with the updates of the global&#13;
// txBuf, txHead, and txCount variables (which&#13;
// are unprotected).&#13;
//&#13;
// In particular, it is safe to call this&#13;
// function from whomever usi_afterRequestPtr,&#13;
// usi_onRequestPtr, or usi_onReceiverPtr&#13;
// point at, but you must not call this&#13;
// code from the main Arduino loop or&#13;
<span epub:type="pagebreak" id="Page_367" title="367"/>// setup function.&#13;
&#13;
void usiI2CTransmitByte( uint8_t data )&#13;
{&#13;
&#13;
    // Wait for free space in buffer.&#13;
&#13;
    while( txCount == I2C_TX_BUFFER_SIZE ) ;&#13;
&#13;
    // Store data in buffer.&#13;
&#13;
    txBuf[txHead] = data;&#13;
    txHead = ( txHead + 1 ) &amp; I2C_TX_BUFFER_MASK;&#13;
    txCount++;&#13;
&#13;
}   // End usiI2CTransmitByte&#13;
&#13;
// usiI2CReceiveByte-&#13;
// &#13;
// Return a byte from the receive &#13;
// buffer, wait if buffer is empty. &#13;
// As above, call this only from the&#13;
// USI_OVERFLOW_VECTOR ISR or code&#13;
// called by it.&#13;
&#13;
uint8_t usiI2CReceiveByte( void )&#13;
{&#13;
    uint8_t rtn_byte;&#13;
&#13;
    // Wait for Rx data.&#13;
&#13;
    while( !rxCount ); &#13;
&#13;
    rtn_byte = rxBuf[rxTail];&#13;
&#13;
    // Calculate buffer index.&#13;
&#13;
    rxTail = ( rxTail + 1 ) &amp; I2C_RX_BUFFER_MASK;&#13;
    rxCount--;&#13;
&#13;
    // Return data from the buffer.&#13;
&#13;
    return rtn_byte;&#13;
&#13;
}   // End usiI2CReceiveByte&#13;
&#13;
// usiI2CAmountDataInReceiveBuffer-&#13;
//&#13;
// Returns the number of bytes in the&#13;
// receive buffer.&#13;
&#13;
uint8_t usiI2CAmountDataInReceiveBuffer( void )&#13;
{&#13;
    return rxCount;&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_368" title="368"/>Next comes the ISR that handles the arrival of a start condition on the I<sup>2</sup>C bus. Special hardware inside the ATtiny84 detects the presence of a start condition and triggers the interrupt that calls the following code:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
/********************************************************&#13;
&#13;
                USI Start Condition ISR&#13;
&#13;
*********************************************************/&#13;
&#13;
// USI_START_VECTOR interrupt service routine.&#13;
//&#13;
// This ISR gets invoked whenever a start condition&#13;
// appears on the I2C bus (assuming the USISIE/start&#13;
// condition interrupt is enabled in USICR).&#13;
//&#13;
// The global variable "in_transaction" is nonzero if&#13;
// this is a repeated start condition (that is, haven’t&#13;
// seen a stop condition since the last start).&#13;
&#13;
ISR( USI_START_VECTOR )&#13;
{&#13;
    uint8_t usi_pins;&#13;
&#13;
    // Notes about ISR. The compiler in the Arduino IDE handles &#13;
    // some of the basic ISR plumbing (unless the "ISR_NAKED" &#13;
    // attribute is applied):&#13;
    //&#13;
    //   * The AVR processor resets the SREG.I bit &#13;
    //     when jumping into an ISR.&#13;
    //   * The compiler automatically adds code to save SREG.&#13;
    //   * &lt; user’s ISR code goes here &gt;&#13;
    //   * The compiler automatically adds code to restore SREG.&#13;
    //   * The compiler automatically uses the RETI instruction &#13;
    //     to return from the ISR.&#13;
    //&#13;
    //     The RETI instruction enables interrupts after the &#13;
    //     return from ISR.&#13;
    //&#13;
    // cli() call is not necessary. Processor disables &#13;
    // interrupts when calling to an ISR.&#13;
    //&#13;
    // No need to save the SREG. The compiler does this &#13;
    // automatically when using the ISR construct without &#13;
    // modifying attributes.&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if( !in_transaction )&#13;
    {&#13;
        // Remember the sleep enable bit when entering the ISR.&#13;
&#13;
        sleep_enable_bit = MCUCR &amp; ( 1 &lt;&lt; SE );&#13;
&#13;
<span epub:type="pagebreak" id="Page_369" title="369"/>        // Clear the sleep enable bit to prevent the CPU from &#13;
        // entering sleep mode while executing this ISR.&#13;
&#13;
        MCUCR &amp;= ~( 1 &lt;&lt; SE );&#13;
    }&#13;
&#13;
    // Set default starting conditions for new I2C packet.&#13;
    &#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ISRstate = USI_PERIPH_CHECK_ADDRESS;&#13;
&#13;
    // Program SDA pin as input.&#13;
    &#13;
    DDR_USI &amp;= ~( 1 &lt;&lt; PORT_USI_SDA );&#13;
&#13;
    // The start condition is that the controller pulls SDA low&#13;
    // (while SCL is high).&#13;
    //&#13;
    // Wait for SCL to go low to ensure the start condition &#13;
    // has completed (the start detector will hold SCL low);&#13;
    // if a stop condition arises, then leave the interrupt to &#13;
    // prevent waiting forever. Don’t use USISR to test for &#13;
    // stop condition as in Application Note AVR312, because&#13;
    // the stop condition flag is going to be set from the last&#13;
    // I2C sequence.&#13;
    &#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> while&#13;
    (&#13;
            ( usi_pins = PIN_USI &amp; USI_PINS_SCL_SDA ) &#13;
        ==  USI_PINS_SCL &#13;
    ){&#13;
        // While SCL is high and SDA is low.&#13;
     }&#13;
&#13;
    // If SDA line was low at SCL edge, then start &#13;
    // condition occurred.&#13;
    &#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if( !( usi_pins &amp; USI_PINS_SDA ) )&#13;
    {&#13;
        // A stop condition did not occur.&#13;
&#13;
        // Execute callback if this is a repeated start.&#13;
&#13;
        if( in_transaction )&#13;
        {&#13;
            if( usiI2CAmountDataInReceiveBuffer() )&#13;
            {&#13;
                usi_onReceiverPtr&#13;
                (&#13;
                    usiI2CAmountDataInReceiveBuffer()&#13;
                );&#13;
            }&#13;
        }&#13;
&#13;
        // Now that you’ve seen a start condition,&#13;
<span epub:type="pagebreak" id="Page_370" title="370"/>        // you need to dynamically enable the&#13;
        // overflow interrupt that tells you when&#13;
        // you’ve received a byte of data.&#13;
        &#13;
     <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> USICR =&#13;
                // Keep start condition interrupt  &#13;
                // enabled to detect RESTART.&#13;
                &#13;
                ( 1 &lt;&lt; USISIE )&#13;
            &#13;
                // Enable overflow interrupt.&#13;
                &#13;
            |   ( 1 &lt;&lt; USIOIE )&#13;
            &#13;
                // Set USI in two-wire mode, hold SCL&#13;
                // low on USI Counter overflow.&#13;
                &#13;
            |   ( 1 &lt;&lt; USIWM1 ) &#13;
            |   ( 1 &lt;&lt; USIWM0 ) &#13;
            &#13;
                // Shift register clock source = external, &#13;
                // positive edge.&#13;
             &#13;
            |   ( 1 &lt;&lt; USICS1 )&#13;
            |   ( 0 &lt;&lt; USICS0 ) &#13;
&#13;
                // 4-Bit Counter Source = external, both edges.&#13;
             &#13;
            |   ( 0 &lt;&lt; USICLK )&#13;
            &#13;
                // No toggle clock-port pin.&#13;
            &#13;
            |   ( 0 &lt;&lt; USITC );&#13;
     &#13;
        // Remember that the USI is in a valid I2C transaction.&#13;
        &#13;
        in_transaction = 1;&#13;
&#13;
    }&#13;
    else // SDA was high&#13;
    {&#13;
         // A stop condition did occur; reset&#13;
         // the interrupts to look for a new&#13;
         // start condition.&#13;
&#13;
      <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> USICR =&#13;
                // Enable start condition interrupt.&#13;
             &#13;
                ( 1 &lt;&lt; USISIE )&#13;
                &#13;
                // Disable overflow interrupt.&#13;
            &#13;
            |   ( 0 &lt;&lt; USIOIE )&#13;
            &#13;
<span epub:type="pagebreak" id="Page_371" title="371"/>                // Set USI in two-wire mode.&#13;
                &#13;
            |   ( 1 &lt;&lt; USIWM1 ) &#13;
                &#13;
                // No USI counter overflow hold.&#13;
&#13;
            |   ( 0 &lt;&lt; USIWM0 )&#13;
            &#13;
                // Shift register clock source = external, &#13;
                // positive edge.&#13;
            &#13;
            |   ( 1 &lt;&lt; USICS1 )&#13;
            |   ( 0 &lt;&lt; USICS0 )&#13;
&#13;
                // 4-Bit counter source = external, &#13;
                // both edges.&#13;
&#13;
            |   ( 0 &lt;&lt; USICLK )&#13;
            &#13;
                // No toggle clock-port pin.&#13;
                &#13;
            |   ( 0 &lt;&lt; USITC );&#13;
&#13;
        // No longer in valid I2C transaction.&#13;
        &#13;
        in_transaction = 0;&#13;
        &#13;
        // Restore the sleep enable bit.&#13;
        &#13;
        MCUCR |= sleep_enable_bit;&#13;
&#13;
    }  // end if&#13;
&#13;
    USISR =&#13;
            // Clear interrupt flags - resetting the Start &#13;
            // Condition Flag will release SCL.&#13;
&#13;
            ( 1 &lt;&lt; USI_START_COND_INT ) &#13;
        |   ( 1 &lt;&lt; USIOIF )&#13;
        |   ( 1 &lt;&lt; USIPF ) &#13;
        |   ( 1 &lt;&lt; USIDC )&#13;
        &#13;
            // Set USI to sample 8 bits (count 16&#13;
            // external SCL pin toggles).&#13;
            &#13;
        |   ( 0x0 &lt;&lt; USICNT0);&#13;
&#13;
} // End ISR( USI_START_VECTOR )</code></pre>&#13;
<p>The <code>USI_START_VECTOR</code> interrupt service routine begins by turning off the sleep mode <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This prevents the CPU from sleeping while processing a byte coming in on the I<sup>2</sup>C pins. Next, the ISR set the state so that the code will process an address byte immediately following the start condition <span aria-label="annotation2" class="CodeAnnotation">❷</span>. </p>&#13;
<p><span epub:type="pagebreak" id="Page_372" title="372"/>The <code>while</code> loop waits until the SCL line goes low (the end of the start condition) <span aria-label="annotation3" class="CodeAnnotation">❸</span>, and then the code checks to see if this is an actual start condition (SDA line is low) or a stop condition (SDA line is high). If it’s a start condition, the ISR checks to see if this is a restart condition, meaning there was no stop condition since the last start <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Once the ISR has properly seen a start (or restart) condition, it enables the overflow interrupt to trigger when the USI receives the next full byte <span aria-label="annotation5" class="CodeAnnotation">❺</span>. In the event a stop condition arrived, the code resets the interrupts to look for a new start condition <span aria-label="annotation6" class="CodeAnnotation">❻</span>.</p>&#13;
<p>The USI Overflow interrupt service routine processes the bytes that arrive from the USI:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// USI Overflow ISR-&#13;
//&#13;
// Invoked when the shift register is full (programmable&#13;
// size, usually 1 or 8 bits). Because the byte coming&#13;
// in could be any part of an I2C transmission, this ISR&#13;
// uses a state machine to track the incoming bytes. This&#13;
// ISR handles controller reads and writes (peripheral&#13;
// writes and reads).&#13;
//&#13;
// Note that this ISR is disabled when waiting for a&#13;
// start condition to arrive (incoming bytes at that&#13;
// point are intended for a different device).&#13;
&#13;
ISR( USI_OVERFLOW_VECTOR )&#13;
{&#13;
  uint8_t finished;&#13;
  uint8_t usi_pins;&#13;
&#13;
  // This ISR is only ever entered because the &#13;
  // ISR(USI_START_VECTOR) interrupt routine ran &#13;
  // first. That routine saved the sleep mode and &#13;
  // disabled sleep.&#13;
  //&#13;
  // ISRstate is the state machine variable for&#13;
  // the overflow.&#13;
&#13;
  // Most of the time this routine exits, it has set up the &#13;
  // USI to shift in/out bits and is expected to have re-entered &#13;
  // because of the USI overflow interrupt. Track whether or&#13;
  // not the transaction is completely finished.&#13;
  &#13;
  finished = 0;</code></pre>&#13;
<p>Because each byte can have a different meaning, the overflow ISR tracks the arrivals with a state machine (and the <code>ISRstate</code> variable). The first byte to arrive after the start condition is the address-R/W byte. The LO bit (R/W) determines whether the state machine will handle memory read operations (R/W = 1, state =  <code>USI_PERIPH_SEND_DATA</code>) or memory write operations (R/W = 0, state =  <code>USI_PERIPH_REQUEST_DATA</code>).</p>&#13;
<p><span epub:type="pagebreak" id="Page_373" title="373"/>The following code is the start of the actual state machine, controlled by the <code>ISRstate</code> variable: </p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
&#13;
  switch ( ISRstate )&#13;
  {&#13;
&#13;
    // Address mode: &#13;
    // Check address and send ACK (and next &#13;
    // USI_PERIPH_SEND_DATA) if OK, else reset USI.&#13;
    &#13;
    case USI_PERIPH_CHECK_ADDRESS:&#13;
        if( &#13;
                ( USIDR == 0 ) &#13;
            ||  (( USIDR &gt;&gt; 1 ) == periphAddress ) &#13;
        ){&#13;
            if( USIDR &amp; 0x01 ) // Controller read request?&#13;
            {&#13;
                ISRstate = USI_PERIPH_SEND_DATA;&#13;
                usi_onRequestPtr();&#13;
&#13;
            }&#13;
            else    // Must be controller write operation&#13;
            {&#13;
                ISRstate = USI_PERIPH_REQUEST_DATA;&#13;
            }       // end if&#13;
&#13;
            // Acknowledge the start frame.&#13;
            // Sets up the USI to pull SDA low&#13;
            // and clock 1 bit (two edges).&#13;
            &#13;
            USIDR = 0; // Prepare ACK, acknowledge is a single 0 &#13;
            &#13;
            // Set SDA data direction as output.&#13;
            &#13;
            DDR_USI |= ( 1 &lt;&lt; PORT_USI_SDA );&#13;
            &#13;
            // Clear all interrupt flags, except start cond.&#13;
            &#13;
            USISR = &#13;
                    ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
                |   ( 1 &lt;&lt; USIOIF ) &#13;
                |   ( 1 &lt;&lt; USIPF )&#13;
                |   ( 1 &lt;&lt; USIDC )&#13;
                |   ( 0x0E &lt;&lt; USICNT0 ); // Shift 1 bit&#13;
        }&#13;
        else    // I2C transaction for some other device&#13;
        {&#13;
            setStartConditionMode();&#13;
            finished = 1;&#13;
        }&#13;
        break;</code></pre>&#13;
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_374" title="374"/>The first state appearing in this code is <code>USI_PERIPH_CHECK_ADDRESS</code>, which corresponds to the arrival of a start condition. This state checks the incoming I<sup>2</sup>C address byte and R/W bit. If the address doesn’t match, the code turns off the overflow interrupt enable, because the code will ignore all incoming bytes until a new start condition comes along; the current bus transactions are intended for some other device. If the address matches, however, this code changes the state based on the R/W bit. One state handles additional incoming bytes (an I<sup>2</sup>C write operation), while another handles outgoing bytes (an I<sup>2</sup>C read operation).</p>&#13;
<p>Next, the <code>USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA</code> state verifies that an ACK or a NAK came from the controller after the peripheral has transmitted a byte to the controller (an I<sup>2</sup>C read operation). </p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA-&#13;
//&#13;
// State that executes when you’ve received&#13;
// an ACK or a NAK from the controller after&#13;
// sending it a byte.&#13;
// Check reply and go to USI_PERIPH_SEND_DATA&#13;
// if OK, else reset USI.&#13;
&#13;
case USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA:&#13;
&#13;
    // Execute request callback after each byte’s&#13;
    // ACK or NAK has arrived.&#13;
  &#13;
    usi_afterRequestPtr();&#13;
&#13;
    if( USIDR )&#13;
    {&#13;
    // If NAK, the controller does not want more data.&#13;
&#13;
        setStartConditionMode();&#13;
        finished = 1;&#13;
    break;&#13;
    }&#13;
    &#13;
    // From here you just drop straight &#13;
    // into USI_PERIPH_SEND_DATA if the&#13;
    // controller sent an ACK.</code></pre>&#13;
<p>If a NAK arrived, you’re done transmitting data back to the controller; if an ACK arrived, the program continues transmitting more data. If this code were to receive an ACK from the controller, it would normally set the state to <code>USI_PERIPH_SEND_DATA</code>. However, this code simply falls down into that state and immediately transmits the next byte to the controller without changing the state (it will be set back to <code>USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA</code>, anyway).</p>&#13;
<p>Next, the <code>USI_PERIPH_SEND_DATA</code> state transmits a byte of data to the controller in response to a read operation. After transmitting a byte, it also sets <span epub:type="pagebreak" id="Page_375" title="375"/>the state to <code>USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA</code> to handle the ACK or NAK from the controller.</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// Controller read operation (peripheral write operation).&#13;
//&#13;
// Copy data from buffer to USIDR and set USI to shift byte&#13;
// next USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA.&#13;
&#13;
case USI_PERIPH_SEND_DATA:&#13;
&#13;
    // Get data from buffer.&#13;
    &#13;
    if( txCount )&#13;
    {&#13;
        USIDR = txBuf[ txTail ];&#13;
        txTail = ( txTail + 1 ) &amp; I2C_TX_BUFFER_MASK;&#13;
        txCount--;&#13;
&#13;
        ISRstate = &#13;
            USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA;&#13;
            &#13;
        DDR_USI |=  ( 1 &lt;&lt; PORT_USI_SDA );&#13;
        &#13;
        // Clear all interrupt flags, except start cond.&#13;
        &#13;
        USISR    =  &#13;
            ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
            |   ( 1 &lt;&lt; USIOIF ) &#13;
            |   ( 1 &lt;&lt; USIPF ) &#13;
            |   ( 1 &lt;&lt; USIDC) &#13;
            |   ( 0x0 &lt;&lt; USICNT0 ); // Shift 8 bits&#13;
    }&#13;
    else&#13;
    {&#13;
        // The buffer is empty.&#13;
        &#13;
        // Read an ACK:&#13;
        //&#13;
        // This might be necessary sometimes. See &#13;
        // http://www.avrfreaks.net/index.php?name=&#13;
        // PNphpBB2&amp;file=viewtopic&amp;p=805227#805227.&#13;
        &#13;
        DDR_USI &amp;= ~( 1 &lt;&lt; PORT_USI_SDA );&#13;
        USIDR = 0; // Must ship out a 0 bit for ACK&#13;
        &#13;
        USISR =     &#13;
                // Clear all interrupt flags, &#13;
                // except start cond.&#13;
                &#13;
                ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
            |   ( 1 &lt;&lt; USIOIF )&#13;
            |   ( 1 &lt;&lt; USIPF )&#13;
<span epub:type="pagebreak" id="Page_376" title="376"/>            |   ( 1 &lt;&lt; USIDC )&#13;
            &#13;
                // Set USI ctr to shift 1 bit.&#13;
                &#13;
            |   ( 0x0E &lt;&lt; USICNT0 );     &#13;
&#13;
        setStartConditionMode();&#13;
    } // end if&#13;
    break;</code></pre>&#13;
<p>Next, the <code>USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA</code> state sets up the USI to wait for a single bit, either the ACK or NAK, to arrive in the USI. This state also changes the state variable to <code>USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA</code>, which will process the ACK or NAK when it arrives.</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// This state sets up the state machine&#13;
// to accept an ACK from the controller&#13;
// device after sending a byte to the&#13;
// controller (an I2C read operation).&#13;
// &#13;
// Set USI to sample reply from controller&#13;
// next USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA.&#13;
&#13;
case USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA:&#13;
&#13;
    ISRstate = &#13;
        USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA;&#13;
    &#13;
    // Read an ACK:&#13;
    &#13;
    DDR_USI &amp;= ~( 1 &lt;&lt; PORT_USI_SDA );&#13;
    USIDR = 0; // Must ship out a zero bit for ACK&#13;
    USISR =     &#13;
            // Clear all interrupt flags, &#13;
            // except Start Cond.&#13;
            &#13;
            ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
        |   ( 1 &lt;&lt; USIOIF )&#13;
        |   ( 1 &lt;&lt; USIPF )&#13;
        |   ( 1 &lt;&lt; USIDC )&#13;
        &#13;
            // Set USI ctr to shift 1 bit.&#13;
            &#13;
        |   ( 0x0E &lt;&lt; USICNT0 );     &#13;
&#13;
    break;</code></pre>&#13;
<p>Next, the <code>USI_PERIPH_REQUEST_DATA</code> state sets up the system to expect the arrival of a byte from the controller (that is, an I<sup>2</sup>C write operation). This state gets set after the address byte or after an arbitrary byte is read from the controller (that is, some byte in a stream of bytes the controller is <span epub:type="pagebreak" id="Page_377" title="377"/>transmitting). This code delays until the SCL line goes high and then looks for a possible stop condition. If no stop condition occurs, then the system sets the state to <code>USI_PERIPH_GET_DATA_AND_SEND_ACK</code> and waits for the next byte to arrive:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// Controller-send / peripheral-receive- &#13;
//&#13;
// Set USI to sample data from controller, &#13;
// next: USI_PERIPH_GET_DATA_AND_SEND_ACK.&#13;
&#13;
case USI_PERIPH_REQUEST_DATA:&#13;
&#13;
    ISRstate = USI_PERIPH_GET_DATA_AND_SEND_ACK;&#13;
&#13;
    // Set USI to read data.&#13;
    //&#13;
    // Set SDA as input.&#13;
&#13;
    DDR_USI &amp;= ~( 1 &lt;&lt; PORT_USI_SDA );&#13;
&#13;
    // Clear all interrupt flags, except start cond.&#13;
&#13;
    USISR    =&#13;
        ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
    |   ( 1 &lt;&lt; USIOIF ) &#13;
    |   ( 1 &lt;&lt; USIPF )&#13;
    |   ( 1 &lt;&lt; USIDC )&#13;
    |   ( 0x0 &lt;&lt; USICNT0 ); // Read 8 bits&#13;
&#13;
    // With the code above, the USI has been set to catch the &#13;
    // next byte if the controller sends one. While that′s&#13;
    // going on, look for a stop condition here when the&#13;
    // SDA line goes high after the SCL line.&#13;
    //&#13;
    // Wait until SCL goes high.&#13;
&#13;
    while&#13;
    ( &#13;
        !(&#13;
                ( usi_pins = PIN_USI &amp; USI_PINS_SCL_SDA ) &#13;
            &amp;   USI_PINS_SCL &#13;
        )&#13;
    );&#13;
&#13;
    // If SDA line was high at SCL edge, &#13;
    // then not a stop condition.&#13;
&#13;
    breakif( usi_pins &amp; USI_PINS_SDA );&#13;
    while&#13;
    ( &#13;
            ( usi_pins = PIN_USI &amp; USI_PINS_SCL_SDA ) &#13;
        ==  USI_PINS_SCL&#13;
<span epub:type="pagebreak" id="Page_378" title="378"/>    ){&#13;
        // Wait until SCL goes low or SDA goes high.&#13;
    };&#13;
&#13;
    // If both SCL and SDA are high, then stop &#13;
    // condition occurred.&#13;
&#13;
    if( usi_pins == USI_PINS_SCL_SDA )&#13;
    {&#13;
        if( usiI2CAmountDataInReceiveBuffer() )&#13;
        {&#13;
            usi_onReceiverPtr&#13;
            ( &#13;
                usiI2CAmountDataInReceiveBuffer() &#13;
            );&#13;
        }&#13;
        setStartConditionMode();&#13;
        finished = 1;&#13;
    }&#13;
&#13;
    break;</code></pre>&#13;
<p>If a byte has arrived from the controller, the following state fetches that byte from the USI and adds it to the receive buffer. This code also sends the controller an ACK in response to the received byte:</p>&#13;
<pre><code>// usiI2CPeriph.c (cont.)&#13;
//&#13;
// This state sends an ACK to the&#13;
// controller after receiving a byte&#13;
// from the controller (I2C write).&#13;
//&#13;
// Copy data from USIDR and send ACK&#13;
// next USI_PERIPH_REQUEST_DATA.&#13;
&#13;
case USI_PERIPH_GET_DATA_AND_SEND_ACK:&#13;
&#13;
    // Put data into buffer and&#13;
    // check buffer size.&#13;
    &#13;
    if( rxCount &lt; I2C_RX_BUFFER_SIZE )&#13;
    {&#13;
        rxBuf[rxHead] = USIDR;&#13;
        rxHead = ( rxHead + 1 ) &amp; I2C_RX_BUFFER_MASK;&#13;
        rxCount++;&#13;
    } &#13;
    else &#13;
    {&#13;
        // Overrun, drop data.&#13;
    }&#13;
    &#13;
    // Next: USI_PERIPH_REQUEST_DATA&#13;
    // (keep accepting bytes from&#13;
    // the controller until a stop&#13;
<span epub:type="pagebreak" id="Page_379" title="379"/>    // condition happens).&#13;
    &#13;
    ISRstate = USI_PERIPH_REQUEST_DATA;&#13;
    &#13;
    // Send acknowledge.&#13;
    &#13;
    USIDR = 0; // Prepare ACK, acknowledge is a single 0 &#13;
    &#13;
    // Set SDA data direction as output.&#13;
    &#13;
    DDR_USI |= ( 1 &lt;&lt; PORT_USI_SDA );&#13;
    &#13;
    // Clear all interrupt flags, except start cond.&#13;
    &#13;
    USISR = &#13;
            ( 0 &lt;&lt; USI_START_COND_INT ) &#13;
        |   ( 1 &lt;&lt; USIOIF ) &#13;
        |   ( 1 &lt;&lt; USIPF )&#13;
        |   ( 1 &lt;&lt; USIDC )&#13;
        |   ( 0x0E &lt;&lt; USICNT0 ); // Shift 1 bit&#13;
        &#13;
    break;&#13;
&#13;
  }     // End switch&#13;
&#13;
  if(finished)&#13;
  {&#13;
        // No longer in valid I2C transaction.&#13;
&#13;
        in_transaction = 0;&#13;
&#13;
        // Restore the sleep enable bit.&#13;
        // This allows sleep but does&#13;
        // not cause sleep; must execute&#13;
        // the "sleep" instruction to &#13;
        // actually put MCU in sleep mode.&#13;
&#13;
        MCUCR |= sleep_enable_bit;&#13;
  }&#13;
} // End ISR( USI_OVERFLOW_VECTOR )</code></pre>&#13;
<p>This concludes the code to handle I<sup>2</sup>C peripherals on an ATtiny84. In addition to the code appearing in <em>attiny84_Periph.ino</em> and <em>usiI2CPeriph.c</em>, the full memory peripheral software has a small header file (<em>usiI2CPeriph.h</em>). I will not reproduce that header file here as it simply replicates information appearing in these two listings. See the online source files for the full source code.</p>&#13;
<p>It should be straightforward to modify the code in <em>attiny84_Periph.ino</em> to implement whatever peripheral you desire on the Atto84 device (assuming, of course, it’s powerful enough for the job). You could, for example, program it as an ADC—only 10 bits, because the Atto84 built-in ADC is a 10-bit ADC—or as a small GPIO expander. With a little more work, you could use it to create an I<sup>2</sup>C NeoPixel controller. Your imagination is limited only by the ATtiny84’s capabilities.</p>&#13;
<h3 id="h2-502468c16-0003"><span epub:type="pagebreak" id="Page_380" title="380"/>16.3.3	A Sample Controller Application </h3>&#13;
<p class="BodyFirst">If you compile the code in <em>attiny84_Periph.ino</em> and <em>usiI2CPeriph.c</em> and program it into a SparkFun Atto84 SBC, that code will happily start execution after power-up and . . . do nothing (nothing observable, anyway). Because that Atto84 becomes an I<sup>2</sup>C peripheral, you must connect it to an I<sup>2</sup>C controller device that is programmed to talk to the Atto84. <a href="#listing16-1" id="listinganchor16-1">Listing 16-1</a> is a simple Arduino program that you can use to exercise the memory peripheral.</p>&#13;
<pre><code>// <a href="#listinganchor16-1" id="listing16-1">Listing16-1</a>.ino&#13;
//&#13;
// A very simple Arduino application&#13;
// that exercises the Atto84 memory&#13;
// peripheral device.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
#define periph (0x20) // Peripheral address&#13;
&#13;
// Usual Arduino initialization code.&#13;
&#13;
void setup( void )&#13;
{&#13;
&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test reading ATTO84" );&#13;
    Wire.begin();    // Initialize I2C library&#13;
&#13;
    // Initialize the four registers on the&#13;
    // memory device with 0x12, 0x34, 0x56,&#13;
    // and 0x78.&#13;
&#13;
    Wire.beginTransmission( periph );&#13;
&#13;
    // cmd byte; d=0 (W), rr=00, sss=100 (4)&#13;
&#13;
    Wire.write( 0b000100 );&#13;
&#13;
    // Register initialization data.&#13;
&#13;
    Wire.write( 0x12 );&#13;
    Wire.write( 0x34 );&#13;
    Wire.write( 0x56 );&#13;
    Wire.write( 0x78 );&#13;
    Wire.endTransmission();&#13;
}&#13;
&#13;
// Arduino main loop.&#13;
&#13;
void loop( void )&#13;
<span epub:type="pagebreak" id="Page_381" title="381"/>{&#13;
    static int value =0;&#13;
&#13;
    // Send a command to the&#13;
    // memory peripheral to set&#13;
    // the read address and length:&#13;
    //&#13;
    // d = 1 (R), rr = 00, sss = 100 (4)&#13;
&#13;
    Wire.beginTransmission( periph );&#13;
    Wire.write( 0b100100 );&#13;
    Wire.endTransmission();&#13;
&#13;
    delayMicroseconds( 25 );&#13;
&#13;
    // Read the 4 bytes from&#13;
    // the memory peripheral and&#13;
    // display them in the&#13;
    // Arduino Serial window.&#13;
&#13;
    Wire.requestFrom( periph, 4 );&#13;
    uint8_t b = Wire.read();&#13;
    Serial.print( b, 16 );&#13;
    b=Wire.read();&#13;
    Serial.print( b, 16 );&#13;
    b=Wire.read();&#13;
    Serial.print( " " );&#13;
    Serial.print( b, 16 );&#13;
    b=Wire.read();&#13;
    Serial.println( b, 16 );&#13;
&#13;
    delay( 25 );&#13;
 }</code></pre>&#13;
<p>If you run this program on an Arduino-compatible system and connect its SDA and SCL lines to the Atto84 from the previous sections, this program will exercise the memory capabilities of that Atto84 I<sup>2</sup>C peripheral.</p>&#13;
<h2 id="h1-502468c16-0004">	16.4	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter covered how to program a SparkFun Atto84 (ATtiny84) as an I<sup>2</sup>C peripheral. It began with a brief discussion of the ATtiny84 Universal Serial Interface that it used to implement I<sup>2</sup>C communication in hardware. It then described a simple device implemented as an I<sup>2</sup>C peripheral: an I<sup>2</sup>C memory device. The meat of this chapter was the actual implementation of the I<sup>2</sup>C memory peripheral on the Atto84. Finally, the chapter concluded with a simple I<sup>2</sup>C controller application for an Arduino-compatible system that exercises the memory peripheral.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_382" title="382"/>For More Information</h2>&#13;
<ol class="none">&#13;
<li>Atmel AVR ATtiny84 datasheet: <a class="LinkURL" href="https://ww1.microchip.com/downloads/en/devicedoc/Atmel-7701_Automotive-Microcontrollers-ATtiny24-44-84_Datasheet.pdf">https://ww1.microchip.com/downloads/en/devicedoc/Atmel-7701_Automotive-Microcontrollers-ATtiny24-44-84_Datasheet.pdf</a></li>&#13;
<li>TinyWire library: <a class="LinkURL" href="https://github.com/rambo/TinyWire">https://github.com/rambo/TinyWire</a></li>&#13;
<li>AVR312 Application Note: <a class="LinkURL" href="https://ww1.microchip.com/downloads/en/AppNotes/Atmel-2560-Using-the-USI-Module-as-a-I2C-Slave_ApplicationNote_AVR312.pdf">https://ww1.microchip.com/downloads/en/AppNotes/Atmel-2560-Using-the-USI-Module-as-a-I2C-Slave_ApplicationNote_AVR312.pdf</a></li>&#13;
<li>SparkFun Atto84: <a class="LinkURL" href="https://www.sparkfun.com/products/14804">https://www.sparkfun.com/products/14804</a></li>&#13;
<li>More information on the SparkFun Atto84: <a class="LinkURL" href="https://learn.sparkfun.com/tutorials/atto84-hookup-guide?_ga=2.165544824.614200035.1610263644-640834246.1610134206">https://learn.sparkfun.com/tutorials/atto84-hookup-guide?_ga=2.165544824.614200035.1610263644-640834246.1610134206</a></li>&#13;
<li>NeoPixel library information: <a class="LinkURL" href="https://learn.adafruit.com/adafruit-neopixel-uberguide">https://learn.adafruit.com/adafruit-neopixel-uberguide</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>