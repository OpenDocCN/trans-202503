<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Security"><div class="titlepage"><div><div><h1 class="title"><a id="security"/>Chapter 11. Security</h1></div></div></div><p><a class="indexterm" id="iddle1206"/><a class="indexterm" id="iddle1214"/><a class="indexterm" id="iddle2140"/><a class="indexterm" id="iddle2141"/>When users sign up for an account on your website, they trust that you will keep
        their data safe and secure. Unfortunately, as the popularity of your application increases,
        so does the likelihood of attack. Even if your application is not popular yet, it can still
        fall victim to automated systems that scan the web looking for vulnerable sites.</p><p>In this chapter, you’ll learn about four of the most common security
        vulnerabilities and how to protect your site from them. We’ll discuss authorization,
        injection, cross-site scripting, and cross-site request forgery attacks.</p><div class="sect1" title="Authorization Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="authorization_attacks"/>Authorization Attacks</h1></div></div></div><p>You created an authentication system in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>, but
          authentication is not the same thing as authorization. <span class="emphasis"><em>Authentication</em></span>
          identifies a user. <span class="emphasis"><em>Authorization</em></span> specifies what a logged-in user can
          access within your application. Your <a class="indexterm" id="iddle1098"/><a class="indexterm" id="iddle1570"/><a class="indexterm" id="iddle1733"/><a class="indexterm" id="iddle1980"/><a class="indexterm" id="iddle2001"/><a class="indexterm" id="iddle2245"/><a class="indexterm" id="iddle2282"/><a class="indexterm" id="iddle2300"/>authentication system uses an email address and a password to identify a user.
          Authorization systems usually deal with roles or privileges.</p><p>At this point, you aren’t defining roles for the users in your application, but
          some privileges should be in place. For example, a user should be able to view and edit
          his or her own posts but only view posts belonging to another user. A user should also be
          able to moderate comments on his or her own posts, even if another user added the
          comment.</p><p>An <span class="emphasis"><em>authorization attack</em></span> occurs when a user manages to bypass
          privileges and access a resource that is owned by another user. The most common type of
          authorization attack is known as an <span class="emphasis"><em>insecure direct object reference</em></span>,
          which means the user can manipulate the URL to access a restricted resource in your
          application.</p><p>Let’s look at an example from your social app. This code sample creates a method
          to allow users to edit previously created text posts, but it includes a resource lookup
          that allows an insecure direct object reference:</p><a id="pro_id00347"/><pre class="programlisting">def edit
  @text_post = TextPost.find(params[:id])
end</pre><p>This method finds the <code class="literal">TextPost</code> to edit using the
            <code class="literal">id</code> parameter passed in as part of the URL, regardless of who
          originally created it. Because this code doesn’t check which user is trying to
          access the post, any authenticated user could edit any post in the application. All the
          user has to do is open one of his or her posts to edit, work out which part of the URL
          represents the post <code class="literal">id</code>, and change that value to another post’s
            <code class="literal">id</code>.</p><p>You only want users to be able to edit their own posts. This next listing shows a
          better way to handle this lookup:</p><a id="pro_id00348"/><pre class="programlisting">def edit
  <span class="strong"><strong>@text_post = current_user.text_posts.find(params[:id])</strong></span>
end</pre><p>By using <code class="literal">current_user.text_posts</code>, the <code class="literal">find</code>
          method is restricted to only posts belonging to the current user. Now if a user changes
          the <code class="literal">id</code> in the URL in an attempt to modify another user’s post,
          the <code class="literal">find</code> will fail and the user should see the 404 error page. If a
          resource is owned by a user, always reference that user when finding the resource in the
          database.</p><p>Now that you know the correct way to find a post to be edited, add the previous method
          to the text post controller at
            <span class="emphasis"><em>app/controllers/text_posts_controller.rb</em></span>. When the user submits the
            <code class="literal">edit</code> text post form, the changes are sent to the
            <code class="literal">update</code> action. Use the same authorization idea to add an
            <code class="literal">update</code> method for text posts:</p><a id="pro_id00349"/><pre class="programlisting">   def update
➊    @text_post = current_user.text_posts.find(params[:id])
➋    if @text_post.update(text_post_params)
       redirect_to post_path(@text_post), notice: "Post updated!"
    else
      render :edit, alert: "Error updating post."
    end
   end</pre><p><a class="indexterm" id="iddle1086"/><a class="indexterm" id="iddle1127"/><a class="indexterm" id="iddle1152"/><a class="indexterm" id="iddle1155"/><a class="indexterm" id="iddle1712"/><a class="indexterm" id="iddle1732"/><a class="indexterm" id="iddle2144"/><a class="indexterm" id="iddle2244"/><a class="indexterm" id="iddle2250"/>This method finds the correct text post ➊ belonging to the current user
          and calls the <code class="literal">update</code> method ➋ using the
            <code class="literal">params</code> from the text post form. If the call to
            <code class="literal">update</code> is successful, the text post is updated in the database and
          the user is redirected to the updated post. Otherwise, the <code class="literal">edit</code> view is
          rendered again with an error message.</p><p>Next, create the file <span class="emphasis"><em>app/views/text_posts/edit.html.erb</em></span> and add
          the <code class="literal">edit</code> view for text posts:</p><a id="pro_id00350"/><pre class="programlisting">&lt;div class="page-header"&gt;
  &lt;h1&gt;Edit Text Post&lt;/h1&gt;
&lt;/div&gt;

&lt;%= render 'form' %&gt;</pre><p>This view is the same as the <code class="literal">new</code> view for text posts except for the
          heading. This view reuses the form partial you created in the last chapter. Finally, add a
          link to the <code class="literal">edit</code> action in the <code class="literal">TextPost</code> partial at
            <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span>.</p><a id="pro_id00351"/><pre class="programlisting">      &lt;%= text_post.body %&gt;

➊     <span class="strong"><strong>&lt;% if text_post.user == current_user %&gt;</strong></span>
        <span class="strong"><strong>&lt;p&gt;</strong></span>
        <span class="strong"><strong>&lt;%= link_to 'Edit', edit_text_post_path(text_post),</strong></span>
              <span class="strong"><strong>class: "btn btn-default" %&gt;</strong></span>
        <span class="strong"><strong>&lt;/p&gt;</strong></span>
      <span class="strong"><strong>&lt;% end %&gt;</strong></span>
    &lt;/div&gt;
  &lt;/div&gt;</pre><p>This link should only appear if the text post belongs to the current user ➊.
          Editing image posts follows the same pattern. Add the <code class="literal">edit</code> and
            <code class="literal">update</code> methods, complete with authorization, to
            <span class="emphasis"><em>app/controllers/image_posts_controller.rb</em></span>, create an
            <code class="literal">edit</code> view for image posts at
            <span class="emphasis"><em>app/views/image_posts/edit.html.erb</em></span>, and add a link to the
            <code class="literal">edit</code> action in the <code class="literal">ImagePost</code> partial at
            <span class="emphasis"><em>app/views/image_posts/_image_post.html.erb</em></span>. These steps are covered
          in Exercise 1 at the end of this chapter.</p></div><div class="sect1" title="Injection Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="injection_attacks"/>Injection Attacks</h1></div></div></div><p>An <span class="emphasis"><em>injection attack</em></span> occurs when input from a user is executed as
          part of the application. Injection attacks are extremely common, especially in older
          applications.</p><p><a class="indexterm" id="iddle2185"/><a class="indexterm" id="iddle2290"/>The first rule of avoiding injection attacks is <span class="emphasis"><em>never trust input
            from the user</em></span>. If an application does not ensure that all data entered by a
          user is safe, then it is vulnerable to injection attacks. Keep this in mind as we look at
          two types of injection attacks in this section: SQL injection and cross-site
          scripting.</p><div class="sect2" title="SQL Injection"><div class="titlepage"><div><div><h2 class="title"><a id="sql_injection"/>SQL Injection</h2></div></div></div><p>In a <span class="emphasis"><em>SQL injection</em></span> attack, user input is added directly to an
            SQL statement. If a malicious user provides actual SQL code as input, he or she could
            bypass your application’s authorization system, query your application’s
            database, and obtain or delete restricted information.</p><p>For example, consider an application where the Rails built-in secure password
            feature is not used. Instead, the developer stores usernames and passwords in the
            database and has written his or her own <code class="literal">authenticate</code> method to verify
            a user’s credentials. This custom <code class="literal">User.authenticate</code> method
            shows what <span class="emphasis"><em>not</em></span> to do, as it’s vulnerable to SQL
            injection:</p><a id="pro_id00352"/><pre class="programlisting">  class User &lt; ActiveRecord::Base
➊   def self.authenticate(username, password)
➋     where("username = '#{username}' " +
            "AND password = '#{password}'").first
    end
  end</pre><p>This method accepts arguments for <code class="literal">username</code> and
              <code class="literal">password</code> ➊. These values are entered by the user and passed
            to the controller as parameters. These variables are then added to a
              <code class="literal">where</code> call using string interpolation ➋.</p><p>This method returns the correct user object for valid username and password
            combinations. For example, assuming a <code class="literal">User</code> with
              <code class="literal">username</code> tony and <code class="literal">password</code> secret, this method
            returns the <code class="literal">User</code>:</p><a id="pro_id00353"/><pre class="programlisting">User.authenticate("tony", "secret")
 =&gt; #&lt;User id: 1, username: ...&gt;</pre><p>The method call then generates the following SQL code:</p><a id="pro_id00354"/><pre class="programlisting">SELECT * FROM "users"
WHERE (username = 'tony' AND password = 'secret')
ORDER BY "users"."id" ASC
LIMIT 1</pre><p>This method also works correctly when passed invalid <code class="literal">username</code> and
              <code class="literal">password</code> combinations:</p><a id="pro_id00355"/><pre class="programlisting">User.authenticate("tony", "wrong")
 =&gt; nil</pre><p>In this case, the <code class="literal">password</code> is not valid so the method returns
              <code class="literal">nil</code>. So far, so good!</p><div class="sect3" title="Bypassing an Authentication System"><div class="titlepage"><div><div><h3 class="title"><a id="bypassing_an_authentication_system"/>Bypassing an Authentication System</h3></div></div></div><p><a class="indexterm" id="iddle1405"/><a class="indexterm" id="iddle2143"/><a class="indexterm" id="iddle2344"/>Unfortunately, savvy attackers know a handy SQL string that allows them to
              bypass completely this <code class="literal">authenticate</code> method: <code class="literal">' OR
                '1'='1</code>. In SQL, the statement <code class="literal">'1'='1'</code> evaluates to
                <code class="literal">TRUE</code>, so if it is added to any other conditional statement with
                <code class="literal">OR</code>, the entire conditional evaluates to
              <code class="literal">TRUE</code>.</p><p>Let’s see what happens when this string is passed to the authenticate method
              for <code class="literal">username</code> and <code class="literal">password</code>:</p><a id="pro_id00356"/><pre class="programlisting">User.authenticate("' OR '1'='1", "' OR '1'='1")
 =&gt; #&lt;User id: 1, username: ...&gt;</pre><p>I didn’t pass the method any valid data, so how did the
                <code class="literal">authenticate</code> method succeed? The SQL code generated by the method
              call shows the trick:</p><a id="pro_id00357"/><pre class="programlisting">SELECT * FROM "users"
WHERE (username = '' OR '1'='1' AND password = '' OR '1'='1')
ORDER BY "users"."id" ASC
LIMIT 1</pre><p>Even though there is no user with an empty string for <code class="literal">username</code>
              and <code class="literal">password</code>, the addition of <code class="literal">OR '1'='1'</code> causes
              the <code class="literal">WHERE</code> clause to evaluate to <code class="literal">TRUE</code> and the
              method returns the first user in the database. The attacker is now logged in as the
              first user. This attack is made worse by the fact that the first user in the database
              usually belongs to the application’s creator, who might also have special
              privileges.</p></div><div class="sect3" title="Preventing SQL Injection"><div class="titlepage"><div><div><h3 class="title"><a id="preventing_sql_injection"/>Preventing SQL Injection</h3></div></div></div><p>Thankfully, you can usually find SQL injection errors just by looking at your code
              carefully. If you see string interpolation inside a <code class="literal">where</code> method,
              assume it is dangerous and needs to be corrected.</p><p>If you must build your own query string, switch to hash conditions:</p><a id="pro_id00358"/><pre class="programlisting">def self.authenticate
  username = params[:username]
  password = params[:password]

  where(username: username,
        password: password).first
end</pre><p>Here, the string is completely removed from the call to the
                <code class="literal">where</code> method.</p></div></div><div class="sect2" title="Cross-Site Scripting"><div class="titlepage"><div><div><h2 class="title"><a id="cross-site_scripting"/>Cross-Site Scripting</h2></div></div></div><p><span class="emphasis"><em>Cross-site scripting (XSS)</em></span> is another common injection attack.
            In a cross-site scripting attack, an attacker is allowed to enter malicious JavaScript
            code into your application. Any text field can potentially be used in a cross-site
            scripting attack. When another user views a page with malicious JavaScript, the
            user’s browser executes the code as if it were part of your application.</p><p>Cross-site scripting vulnerabilities can be exploited to deface your website or even
            display fake log-in forms in an attempt to steal user credentials. The possibilities are
            almost endless if an attacker is able to inject code into your site.</p><div class="sect3" title="Built-in Protection"><div class="titlepage"><div><div><h3 class="title"><a id="built-in_protection"/>Built-in Protection</h3></div></div></div><p>Rails includes protection from cross-site scripting by default. Your application
              is safe from XSS attacks unless you explicitly bypass this protection. As a quick
              check, try entering the following JavaScript code in the body of a new text
              post:</p><a id="pro_id00359"/><pre class="programlisting"><span class="strong"><strong>&lt;script&gt;alert('XSS');&lt;/script&gt;</strong></span></pre><p>After saving this post, you should see that before displaying text on the page, as
              shown in <a class="xref" href="ch11.html#text_post_with_escaped_html" title="Figure 11-1. Text post with escaped HTML">Figure 11-1</a>, Rails first
                <span class="emphasis"><em>escapes</em></span> all HTML tags by replacing special characters with
              their corresponding character entities.</p><div class="figure"><a id="text_post_with_escaped_html"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00022"/><img alt="Text post with escaped HTML" src="httpatomoreillycomsourcenostarchimages2169102.png.jpg"/></div></div><p class="title">Figure 11-1. Text post with escaped HTML</p></div><p>For example, less-than signs are replaced with <code class="literal">&amp;lt;</code> and
              greater-than signs with <code class="literal">&amp;gt;</code>. Instead of being executed, the
              code is displayed on the page like any other text. So if you never plan to allow users
              to enter HTML into your site, your application is safe from cross-site
              scripting.</p><p>Unfortunately, users might like to enter HTML tags to format their posts in your
              application. In this case, your site will need to accept at least a few HTML tags. You
              can turn off the automatic escaping of HTML tags by using the <code class="literal">raw</code>
              helper method in your view. Open
                <span class="emphasis"><em>app/views/text_posts/_text_post.html.erb</em></span> and add
                <code class="literal">raw</code> before <code class="literal">text_post.body</code>:</p><a id="pro_id00360"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
  &lt;%= <span class="strong"><strong>raw</strong></span> text_post.body %&gt;
--<span class="emphasis"><em>snip</em></span>--</pre><p>Now when you refresh the page in your browser, the script tag will not be escaped,
              and you should see a pop-up window with the text “XSS,” as shown in <a class="xref" href="ch11.html#text_post_with_xss_vulnerability" title="Figure 11-2. Text post with XSS vulnerability">Figure 11-2</a>.</p><div class="figure"><a id="text_post_with_xss_vulnerability"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00023"/><img alt="Text post with XSS vulnerability" src="httpatomoreillycomsourcenostarchimages2169104.png.jpg"/></div></div><p class="title">Figure 11-2. Text post with XSS vulnerability</p></div><p>The trick is to let your application only accept safe tags, such as
                <code class="literal">&lt;strong&gt;</code> for bold, <code class="literal">&lt;em&gt;</code> for
              italics, and <code class="literal">&lt;p&gt;</code> for marking paragraphs, while rejecting
              dangerous tags such as <code class="literal">&lt;script&gt;</code>. You might be tempted to
              write your own helper method to deal with these dangerous tags, but thankfully, Rails
              provides the <code class="literal">sanitize</code> helper method to take care of this for
              you.</p></div><div class="sect3" title="The sanitize method"><div class="titlepage"><div><div><h3 class="title"><a id="sanitize_method"/>The sanitize method</h3></div></div></div><p>The <code class="literal">sanitize</code> helper method removes all HTML tags that are not
              explicitly allowed by its whitelist. You can see the list of allowed tags by entering
                <span class="strong"><strong><code class="literal">ActionView::Base.sanitized_allowed_tags</code></strong></span> in a Rails
              console.</p><p>Try a few examples of the <code class="literal">sanitize</code> method in the Rails console
              to familiarize yourself with how it works:</p><a id="pro_id00361"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>helper.sanitize("&lt;p&gt;Hello&lt;/p&gt;")</strong></span>
 =&gt; "&lt;p&gt;Hello&lt;/p&gt;"
irb(main):002:0&gt; <span class="strong"><strong>helper.sanitize("&lt;script&gt;alert('XSS')&lt;/script&gt;")</strong></span>
 =&gt; ""</pre><p>You can specify your own array of allowed tags by including a value for the
                <code class="literal">tags</code> key in the <code class="literal">options</code> hash:</p><a id="pro_id00362"/><pre class="programlisting">irb(main):003:0&gt; <span class="strong"><strong>helper.sanitize("&lt;p&gt;Hello&lt;/p&gt;", tags: ["em", "strong"])</strong></span>
 =&gt; "Hello"</pre><p>Now that you’ve seen the <code class="literal">sanitize</code> method in action,
              replace the <code class="literal">raw</code> method call with <code class="literal">sanitize</code> in the
                <code class="literal">TextPost</code> partial you edited earlier.</p><a id="pro_id00363"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
  &lt;%= <span class="strong"><strong>sanitize</strong></span> text_post.body %&gt;
--<span class="emphasis"><em>snip</em></span>--</pre><p>Refresh the page again and you should no longer see the alert.</p></div></div></div><div class="sect1" title="Cross-Site Request Forgery Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="cross-site_request_forgery_attacks"/>Cross-Site Request Forgery Attacks</h1></div></div></div><p><a class="indexterm" id="iddle1403"/><a class="indexterm" id="iddle1409"/><a class="indexterm" id="iddle1625"/><a class="indexterm" id="iddle2142"/>A <span class="emphasis"><em>cross-site request forgery (CSRF) attack</em></span> occurs when
          one of your application’s users visits another site that has been modified by an
          attacker to target your site specifically. The malicious site attempts to use your
          application’s trust in this user to submit requests to your application.</p><p>To exploit a CSRF vulnerability, the attacker must first find the vulnerability in
          your application. Next, he or she must create a page with a link to the vulnerability.
          Finally, the attacker must trick your application’s users into visiting the
          malicious page and activating the link.</p><div class="sect2" title="How CSRF Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_csrf_works"/>How CSRF Works</h2></div></div></div><p>Imagine you are building an online payment application. Your application includes a
              <code class="literal">transfer</code> action that accepts <code class="literal">amount</code> and
              <code class="literal">to</code> parameters that specify how much money to transfer to another
            user.</p><p>An attacker could study the requests generated by your site and attempt to replicate
            those requests on his or her own site using something as simple as an HTML image
            tag:</p><a id="pro_id00364"/><pre class="programlisting">&lt;img src="http://<span class="emphasis"><em>yoursite.com</em></span>/transfer?amount=100&amp;to=attacker"&gt;</pre><p>Every time someone visits this page, the user’s browser issues a GET request
            to your site when it tries to load this image. If the visitor is logged in to your site
            and your site is vulnerable to CSRF attacks, $100 is transferred from the
            visitor’s account to the attacker’s account.</p><p>You aren’t building a payment site, but your site is vulnerable to a CSRF
            attack. In <a class="xref" href="ch10.html" title="Chapter 10. Testing">Chapter 10</a>, you added a method for one user to
              <span class="emphasis"><em>follow</em></span> another user on the site. In doing that, you added the
            following line to <span class="emphasis"><em>config/routes.rb</em></span>:</p><a id="pro_id00365"/><pre class="programlisting">get 'follow/:id', to: 'users#follow', as: 'follow_user'</pre><p>By looking at the request created when I click the Follow button, I can create a
            malicious link to exploit this vulnerability. Assuming my account’s
              <code class="literal">id</code> is 10, the link would look like this:</p><a id="pro_id00366"/><pre class="programlisting">&lt;img src="http://<span class="emphasis"><em>yoursite.com</em></span>/follow/10"&gt;</pre><p>Now all I need to do is convince other users to visit a page containing this image
            tag and they will follow me automatically.</p></div><div class="sect2" title="Preventing CSRF"><div class="titlepage"><div><div><h2 class="title"><a id="preventing_csrf"/>Preventing CSRF</h2></div></div></div><p>You can prevent CSRF attacks in two steps. First, include a user-specific token with
            all requests that change state in your application, and ignore any request that does not
            include this token. Second, never use a GET request to change state. If a request could
            create or change data in the database or the session, it should use POST.</p><p><a class="indexterm" id="iddle1081"/><a class="indexterm" id="iddle1137"/><a class="indexterm" id="iddle1213"/><a class="indexterm" id="iddle1368"/><a class="indexterm" id="iddle1580"/><a class="indexterm" id="iddle2008"/>Rails takes care of including a secret token and denying requests by
            default. Open the application layout at
              <span class="emphasis"><em>app/views/layouts/application.html.erb</em></span> to see the code for
            including the token:</p><a id="pro_id00367"/><pre class="programlisting">&lt;%= csrf_meta_tags %&gt;</pre><p>Load your site in a web browser and then view source to see the
              <code class="literal">meta</code> tags generated by this method in the page’s
              <code class="literal">head</code>.</p><a id="pro_id00368"/><pre class="programlisting">&lt;meta content="authenticity_token" name="csrf-param" /&gt;
&lt;meta content="KA1Q/JoVfI+aV6/L4..." name="csrf-token" /&gt;</pre><p>You can also see the <code class="literal">authenticity_token</code> in a hidden field
            included with every form in your application. Every time you submit a form, the value
            from this hidden field is included with the other parameters. The
              <code class="literal">authenticity_token</code> is also automatically included with all POST
            requests.</p><p>Now open <span class="emphasis"><em>app/controllers/application_controller.rb</em></span> to see the
            code that actually denies invalid requests:</p><a id="pro_id00369"/><pre class="programlisting">protect_from_forgery with: :exception</pre><p>Here, Rails goes one step further and raises an exception for requests that
            don’t include the CSRF token. This exception is logged and can be used to track
            down attackers.</p><p>You must handle the second step yourself. Any time you add a controller action, make
            sure you do not use a GET request if the action could change data. The
              <code class="literal">follow</code> action added in <a class="xref" href="ch10.html" title="Chapter 10. Testing">Chapter 10</a> creates a record
            in the database, so it should be a POST request. The POST request automatically includes
            the <code class="literal">authenticity_token</code>, and Rails verifies the token thanks to the
              <code class="literal">protect_from_forgery</code> method in
              <code class="literal">ApplicationController</code>.</p><p>To correct this vulnerability in your application, open
              <span class="emphasis"><em>config/routes.rb</em></span> and change the <code class="literal">follow</code> action
            to use POST instead of GET:</p><a id="pro_id00370"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
<span class="strong"><strong>post</strong></span> 'follow/:id', to: 'users#follow', as: 'follow_user'
--<span class="emphasis"><em>snip</em></span>--</pre><p>Now update the link in <span class="emphasis"><em>app/views/users/show.html.erb</em></span> to use the
            POST method instead of the default GET:</p><a id="pro_id00371"/><pre class="programlisting">&lt;%= link_to "Follow", follow_user_path(@user),
      <span class="strong"><strong>method: :post</strong></span>, class: "btn btn-default" %&gt;</pre><p>With these two changes, the <code class="literal">follow</code> action should now be safe from
            CSRF attacks.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00025"/>Summary</h1></div></div></div><p><a class="indexterm" id="iddle1910"/><a class="indexterm" id="iddle1921"/>Malicious users and sites are unavoidable on the Web today. As your
          application gains popularity, the risk of attack rises. Thankfully, Rails provides the
          tools you need to protect your application and your users from attacks.</p><p>The security vulnerabilities covered in this chapter were taken from the Top 10 list
          published by The Open Web Application Security Project (OWASP). Visit <span class="emphasis"><em><a class="ulink" href="http://www.owasp.org/">http://www.owasp.org/</a></em></span> to find your local OWASP chapter and discuss
          application security at free meetings in your area.</p><p>Now that your application is functional and secure, we’ll look at performance in
          the next chapter. No one likes a slow web application! Here again, Rails provides several
          tools for improving your application’s performance, but you have to put them to
          use.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00026"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch11qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch11qa1qe1"/><a id="ch11qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. Users should also be able to edit their image posts. Add the
                  <code class="literal">edit</code> and <code class="literal">update</code> methods to the
                  <code class="literal">ImagePostsController</code> at
                  <span class="emphasis"><em>app/controllers/image_posts_controller.rb</em></span>. Also add the
                  <code class="literal">ImagePost edit</code> view at
                  <span class="emphasis"><em>app/views/image_posts/edit.html.erb</em></span>. Finally, add a link to
                the <code class="literal">edit</code> action in the <code class="literal">ImagePost</code> partial at
                  <span class="emphasis"><em>app/views/image_posts/_image_post.html.erb</em></span>. The methods and
                views should be similar to those you added for text posts.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch11qa1qe2"/><a id="ch11qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. Users should be able to moderate comments on their own posts. First, add a
                  <code class="literal">@can_moderate</code> instance variable inside the
                  <code class="literal">show</code> action in <code class="literal">PostsController</code>, as shown
                here:</p><a id="pro_id00372"/><pre class="programlisting">  --<span class="emphasis"><em>snip</em></span>--

  def show
    @post = Post.find(params[:id])
    <span class="strong"><strong>@can_moderate = (current_user == @post.user)</strong></span>
  end
end</pre><p>This variable is <code class="literal">true</code> if the <code class="literal">current_user</code>
                is the author of the post being displayed. Now update the comment partial at
                  <span class="emphasis"><em>app/views/comments/_comment.html.erb</em></span> to include a link to the
                  <code class="literal">destroy</code> action if the value of <code class="literal">@can_moderate</code>
                is <code class="literal">true.</code> Finally, add the <code class="literal">destroy</code> action to
                the <code class="literal">CommentsController</code> at
                  <span class="emphasis"><em>app/controllers/comments_controller.rb</em></span>. This action should
                find the correct comment using the <code class="literal">id</code> from the
                  <code class="literal">params</code> hash, call the <code class="literal">destroy</code> method on the
                comment, and then redirect to the <code class="literal">post_path</code> with a message
                indicating success or failure.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch11qa1qe3"/><a id="ch11qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. You need to correct one more CSRF vulnerability in your application. Open the
                routes file at <span class="emphasis"><em>config/routes.rb</em></span> and look at the
                  <code class="literal">logout</code> route:</p><a id="pro_id00373"/><pre class="programlisting">    --<span class="emphasis"><em>snip</em></span>--
    get 'login', to: 'sessions#new', as: 'login'
➊   get 'logout', to: 'sessions#destroy', as: 'logout'

    root 'posts#index'
  end</pre><p>This route leads to the <code class="literal">destroy</code> action in the
                  <code class="literal">SessionsController</code> and you’re using a GET request
                ➊ to access it. Change this route from <code class="literal">get</code> to
                  <code class="literal">delete</code> so a DELETE request is required. Also, add
                  <code class="literal">method: :delete</code> to the <span class="emphasis"><em>Log Out</em></span> link in the
                application layout at
                <span class="emphasis"><em>app/views/layouts/application.html.erb</em></span>.</p></td></tr></tbody></table></div></div></div></body></html>