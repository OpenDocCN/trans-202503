["```\n#include <fcntl.h>            /* Defines O_* constants */\n#include <sys/stat.h>         /* Defines mode constants */\n#include <mqueue.h>\n\nmqd_t `mq_open`(const char **name*, int *oflag*, ...\n              /* mode_t *mode*, struct mq_attr **attr* */);\n```", "```\n#include <mqueue.h>\n\nint `mq_close`(mqd_t *mqdes*);\n```", "```\n#include <mqueue.h>\n\nint `mq_unlink`(const char **name*);\n```", "```\n`pmsg/pmsg_unlink.c`\n#include <mqueue.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s mq-name\\n\", argv[0]);\n\n    if (mq_unlink(argv[1]) == -1)\n        errExit(\"mq_unlink\");\n    exit(EXIT_SUCCESS);\n}\n    `pmsg/pmsg_unlink.c`\n```", "```\nstruct mq_attr {\n    long mq_flags;        /* Message queue description flags: 0 or\n                             O_NONBLOCK [mq_getattr(), mq_setattr()] */\n    long mq_maxmsg;       /* Maximum number of messages on queue\n                             [mq_open(), mq_getattr()] */\n    long mq_msgsize;      /* Maximum message size (in bytes)\n                             [mq_open(), mq_getattr()] */\n    long mq_curmsgs;      /* Number of messages currently in queue\n                             [mq_getattr()] */\n};\n```", "```\n`pmsg/pmsg_create.c`\n#include <mqueue.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s [-cx] [-m maxmsg] [-s msgsize] mq-name \"\n            \"[octal-perms]\\n\", progName);\n    fprintf(stderr, \"    -c          Create queue (O_CREAT)\\n\");\n    fprintf(stderr, \"    -m maxmsg   Set maximum # of messages\\n\");\n    fprintf(stderr, \"    -s msgsize  Set maximum message size\\n\");\n    fprintf(stderr, \"    -x          Create exclusively (O_EXCL)\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    mode_t perms;\n    mqd_t mqd;\n    struct mq_attr attr, *attrp;\n\n    attrp = NULL;\n    attr.mq_maxmsg = 50;\n    attr.mq_msgsize = 2048;\n    flags = O_RDWR;\n\n    /* Parse command-line options */\n\n    while ((opt = getopt(argc, argv, \"cm:s:x\")) != -1) {\n        switch (opt) {\n        case 'c':\n            flags |= O_CREAT;\n            break;\n\n        case 'm':\n            attr.mq_maxmsg = atoi(optarg);\n            attrp = &attr;\n            break;\n\n        case 's':\n            attr.mq_msgsize = atoi(optarg);\n            attrp = &attr;\n            break;\n\n        case 'x':\n            flags |= O_EXCL;\n            break;\n\n        default:\n            usageError(argv[0]);\n        }\n    }\n\n    if (optind >= argc)\n        usageError(argv[0]);\n\n    perms = (argc <= optind + 1) ? (S_IRUSR | S_IWUSR) :\n                getInt(argv[optind + 1], GN_BASE_8, \"octal-perms\");\n\n    mqd = mq_open(argv[optind], flags, perms, attrp);\n    if (mqd == (mqd_t) -1)\n        errExit(\"mq_open\");\n\n    exit(EXIT_SUCCESS);\n}\n    `pmsg/pmsg_create.c`\n```", "```\n#include <mqueue.h>\n\nint `mq_getattr`(mqd_t *mqdes*, struct mq_attr **attr*);\n```", "```\n`pmsg/pmsg_getattr.c`\n#include <mqueue.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    mqd_t mqd;\n    struct mq_attr attr;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s mq-name\\n\", argv[0]);\n\n    mqd = mq_open(argv[1], O_RDONLY);\n    if (mqd == (mqd_t) -1)\n        errExit(\"mq_open\");\n\n    if (mq_getattr(mqd, &attr) == -1)\n        errExit(\"mq_getattr\");\n\n    printf(\"Maximum # of messages on queue:   %ld\\n\", attr.mq_maxmsg);\n    printf(\"Maximum message size:             %ld\\n\", attr.mq_msgsize);\n    printf(\"# of messages currently on queue: %ld\\n\", attr.mq_curmsgs);\n    exit(EXIT_SUCCESS);\n}\n    `pmsg/pmsg_getattr.c`\n```", "```\n$ `./pmsg_create -cx /mq`\n$ `./pmsg_getattr /mq`\nMaximum # of messages on queue:   10\nMaximum message size:             8192\n# of messages currently on queue: 0\n$ `./pmsg_unlink /mq`                             *Remove message queue*\n```", "```\n#include <mqueue.h>\n\nint `mq_setattr`(mqd_t *mqdes*, const struct mq_attr **newattr*,\n               struct mq_attr **oldattr*);\n```", "```\nif (mq_getattr(mqd, &attr) == -1)\n    errExit(\"mq_getattr\");\nattr.mq_flags |= O_NONBLOCK;\nif (mq_setattr(mqd, &attr, NULL) == -1)\n    errExit(\"mq_getattr\");\n```", "```\n#include <mqueue.h>\n\nint `mq_send`(mqd_t *mqdes*, const char **msg_ptr*, size_t *msg_len*,\n            unsigned int *msg_prio*);\n```", "```\n`pmsg/pmsg_send.c`\n#include <mqueue.h>\n#include <fcntl.h>              /* For definition of O_NONBLOCK */\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s [-n] name msg [prio]\\n\", progName);\n    fprintf(stderr, \"    -n           Use O_NONBLOCK flag\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    mqd_t mqd;\n    unsigned int prio;\n\n    flags = O_WRONLY;\n    while ((opt = getopt(argc, argv, \"n\")) != -1) {\n        switch (opt) {\n        case 'n':   flags |= O_NONBLOCK;        break;\n        default:    usageError(argv[0]);\n        }\n    }\n\n    if (optind + 1 >= argc)\n        usageError(argv[0]);\n\n    mqd = mq_open(argv[optind], flags);\n    if (mqd == (mqd_t) -1)\n        errExit(\"mq_open\");\n\n    prio = (argc > optind + 2) ? atoi(argv[optind + 2]) : 0;\n\n    if (mq_send(mqd, argv[optind + 1], strlen(argv[optind + 1]), prio) == -1)\n        errExit(\"mq_send\");\n    exit(EXIT_SUCCESS);\n}\n    `pmsg/pmsg_send.c`\n```", "```\n#include <mqueue.h>\n\nssize_t `mq_receive`(mqd_t *mqdes*, char **msg_ptr*, size_t *msg_len*,\n                   unsigned int **msg_prio*);\n```", "```\n$ `./pmsg_create -cx /mq`\n$ `./pmsg_send /mq msg-a 5`\n$ `./pmsg_send /mq msg-b 0`\n$ `./pmsg_send /mq msg-c 10`\n```", "```\n$ `./pmsg_receive /mq`\nRead 5 bytes; priority = 10\nmsg-c\n$ `./pmsg_receive /mq`\nRead 5 bytes; priority = 5\nmsg-a\n$ `./pmsg_receive /mq`\nRead 5 bytes; priority = 0\nmsg-b\n```", "```\n$ `./pmsg_receive /mq`\n*Blocks; we type Control-C to terminate the program*\n```", "```\n$ `./pmsg_receive -n /mq`\nERROR [EAGAIN/EWOULDBLOCK Resource temporarily unavailable] mq_receive\n```", "```\n`pmsg/pmsg_receive.c`\n#include <mqueue.h>\n#include <fcntl.h>              /* For definition of O_NONBLOCK */\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s [-n] name\\n\", progName);\n    fprintf(stderr, \"    -n           Use O_NONBLOCK flag\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    mqd_t mqd;\n    unsigned int prio;\n    void *buffer;\n    struct mq_attr attr;\n    ssize_t numRead;\n\n    flags = O_RDONLY;\n    while ((opt = getopt(argc, argv, \"n\")) != -1) {\n        switch (opt) {\n        case 'n':   flags |= O_NONBLOCK;        break;\n        default:    usageError(argv[0]);\n        }\n    }\n\n    if (optind >= argc)\n        usageError(argv[0]);\n\n    mqd = mq_open(argv[optind], flags);\n    if (mqd == (mqd_t) -1)\n        errExit(\"mq_open\");\n\n    if (mq_getattr(mqd, &attr) == -1)\n        errExit(\"mq_getattr\");\n\n    buffer = malloc(attr.mq_msgsize);\n    if (buffer == NULL)\n        errExit(\"malloc\");\n\n    numRead = mq_receive(mqd, buffer, attr.mq_msgsize, &prio);\n    if (numRead == -1)\n        errExit(\"mq_receive\");\n\n    printf(\"Read %ld bytes; priority = %u\\n\", (long) numRead, prio);\n    if (write(STDOUT_FILENO, buffer, numRead) == -1)\n        errExit(\"write\");\n    write(STDOUT_FILENO, \"\\n\", 1);\n\n    exit(EXIT_SUCCESS);\n}\n    `pmsg/pmsg_receive.c`\n```", "```\n#include <mqueue.h>\n#include <time.h>\n\nint `mq_timedsend`(mqd_t *mqdes*, const char **msg_ptr*, size_t *msg_len*,\n                 unsigned int *msg_prio*, const struct timespec **abs_timeout*);\n```", "```\nssize_t `mq_timedreceive`(mqd_t *mqdes*, char **msg_ptr*, size_t *msg_len*,\n                 unsigned int **msg_prio*, const struct timespec **abs_timeout*);\n```", "```\n#include <mqueue.h>\n\nint `mq_notify`(mqd_t *mqdes*, const struct sigevent **notification*);\n```", "```\nunion sigval {\n    int    sival_int;             /* Integer value for accompanying data */\n    void  *sival_ptr;             /* Pointer value for accompanying data */\n};\n\nstruct sigevent {\n    int    sigev_notify;          /* Notification method */\n    int    sigev_signo;           /* Notification signal for SIGEV_SIGNAL */\n    union sigval sigev_value;     /* Value passed to signal handler or\n                                     thread function */\n    void (*sigev_notify_function) (union sigval);\n                                  /* Thread notification function */\n    void  *sigev_notify_attributes;   /* Really 'pthread_attr_t' */\n};\n```", "```\n`pmsg/mq_notify_sig.c`\n    #include <signal.h>\n    #include <mqueue.h>\n    #include <fcntl.h>              /* For definition of O_NONBLOCK */\n    #include \"tlpi_hdr.h\"\n\n    #define NOTIFY_SIG SIGUSR1\n\n    static void\n    handler(int sig)\n    {\n        /* Just interrupt sigsuspend() */\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct sigevent sev;\n        mqd_t mqd;\n        struct mq_attr attr;\n        void *buffer;\n        ssize_t numRead;\n        sigset_t blockMask, emptyMask;\n        struct sigaction sa;\n\n        if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s mq-name\\n\", argv[0]);\n\n    mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);\n        if (mqd == (mqd_t) -1)\n            errExit(\"mq_open\");\n\n    if (mq_getattr(mqd, &attr) == -1)\n            errExit(\"mq_getattr\");\n\n    buffer = malloc(attr.mq_msgsize);\n        if (buffer == NULL)\n            errExit(\"malloc\");\n\n    sigemptyset(&blockMask);\n        sigaddset(&blockMask, NOTIFY_SIG);\n        if (sigprocmask(SIG_BLOCK, &blockMask, NULL) == -1)\n            errExit(\"sigprocmask\");\n\n            sigemptyset(&sa.sa_mask);\n        sa.sa_flags = 0;\n        sa.sa_handler = handler;\n        if (sigaction(NOTIFY_SIG, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n    sev.sigev_notify = SIGEV_SIGNAL;\n        sev.sigev_signo = NOTIFY_SIG;\n        if (mq_notify(mqd, &sev) == -1)\n            errExit(\"mq_notify\");\n\n        sigemptyset(&emptyMask);\n\n        for (;;) {\n        sigsuspend(&emptyMask);         /* Wait for notification signal */\n\n        if (mq_notify(mqd, &sev) == -1)\n                errExit(\"mq_notify\");\n\n        while ((numRead = mq_receive(mqd, buffer,\n attr.mq_msgsize, NULL)) >= 0)\n                printf(\"Read %ld bytes\\n\", (long) numRead);\n\n            if (errno != EAGAIN)            /* Unexpected error */\n                errExit(\"mq_receive\");\n        }\n    }\n        `pmsg/mq_notify_sig.c`\n```", "```\n`pmsg/mq_notify_thread.c`\n    #include <pthread.h>\n    #include <mqueue.h>\n    #include <fcntl.h>              /* For definition of O_NONBLOCK */\n    #include \"tlpi_hdr.h\"\n\n    static void notifySetup(mqd_t *mqdp);\n\n    static void                     /* Thread notification function */\nthreadFunc(union sigval sv)\n    {\n        ssize_t numRead;\n        mqd_t *mqdp;\n        void *buffer;\n        struct mq_attr attr;\n\n        mqdp = sv.sival_ptr;\n\n        if (mq_getattr(*mqdp, &attr) == -1)\n            errExit(\"mq_getattr\");\n\n        buffer = malloc(attr.mq_msgsize);\n        if (buffer == NULL)\n            errExit(\"malloc\");\n\n    notifySetup(mqdp);\n\n        while ((numRead = mq_receive(*mqdp, buffer, attr.mq_msgsize, NULL)) >= 0)\n            printf(\"Read %ld bytes\\n\", (long) numRead);\n\n        if (errno != EAGAIN)                        /* Unexpected error */\n            errExit(\"mq_receive\");\n\n        free(buffer);\n        pthread_exit(NULL);\n    }\n\n    static void\n    notifySetup(mqd_t *mqdp)\n    {\n        struct sigevent sev;\n\n        sev.sigev_notify = SIGEV_THREAD;            /* Notify via thread */\n        sev.sigev_notify_function = threadFunc;\n        sev.sigev_notify_attributes = NULL;\n                /* Could be pointer to pthread_attr_t structure */\n    sev.sigev_value.sival_ptr = mqdp;           /* Argument to threadFunc() */\n\n        if (mq_notify(*mqdp, &sev) == -1)\n            errExit(\"mq_notify\");\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        mqd_t mqd;\n\n        if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s mq-name\\n\", argv[0]);\n\n    mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);\n        if (mqd == (mqd_t) -1)\n            errExit(\"mq_open\");\n\n    notifySetup(&mqd);\n        pause();                    /* Wait for notifications via thread function */\n    }\n\n        `pmsg/mq_notify_thread.c`\n```", "```\n# `mount -t mqueue` ``*`source`*`` *`target`*\n```", "```\n$ `su` *Privilege is required for* *mount*\nPassword:\n# `mkdir /dev/mqueue`\n# `mount -t mqueue none /dev/mqueue`\n$ `exit`                                *Terminate**root* *shell session*\n```", "```\n$ `cat /proc/mounts | grep mqueue`\nnone /dev/mqueue mqueue rw 0 0\n$ `ls -ld /dev/mqueue`\ndrwxrwxrwt  2 root root 40 Jul 26 12:09 /dev/mqueue\n```", "```\n$ `./pmsg_create -c /newq`\n$ `ls /dev/mqueue`\nnewq\n$ `rm /dev/mqueue/newq`\n```", "```\n$ `./pmsg_create -c /mq` *Create a queue*\n$ `./pmsg_send /mq abcdefg` *Write 7 bytes to the queue*\n$ `cat /dev/mqueue/mq`\nQSIZE:7       NOTIFY:0    SIGNO:0    NOTIFY_PID:0\n```", "```\n$ `./mq_notify_sig /mq &` *Notify using* SIGUSR1 *(signal 10 on x86)*\n[1] 18158\n$ `cat /dev/mqueue/mq`\nQSIZE:7       NOTIFY:0    SIGNO:10   NOTIFY_PID:18158\n$ `kill %1`\n[1]   Terminated    ./mq_notify_sig /mq\n$ `./mq_notify_thread /mq &` *Notify using a thread*\n[2] 18160\n$ `cat /dev/mqueue/mq`\nQSIZE:7       NOTIFY:2    SIGNO:0    NOTIFY_PID:18160\n```"]