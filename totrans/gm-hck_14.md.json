["```\n// do this every 10 milliseconds (100 times a second)\nauto health = readMemory<int>(HEALTH_ADDRESS);\nif (health <= 500) {\n    // some code to tell the bot how to react\n}\n```", "```\n// still do this every 10 milliseconds\nstatic int previousHealth = 0;\nauto health = readMemory<int>(HEALTH_ADDRESS);\nif (health != previousHealth) {\n    if (health > previousHealth) {\n        // react to increase\n    } else {\n        // react to decrease\n    }\n    previousHealth = health;\n}\n```", "```\n// below is the drawIndexedPrimitive hook\nvoid onDrawIndexedPrimitive(...) {\n    if (numVertices == EVENT_VERT && primCount == EVENT_PRIM) {\n        // react, preferably after drawing is done\n    }\n}\n```", "```\nbool eventActive = false;\nbool eventActiveLastFrame = false;\n// below is the drawIndexedPrimitive hook\nvoid onDrawIndexedPrimitive(...) {\n    if (numVertices == EVENT_VERT && primCount == EVENT_PRIM)\n        eventActive = true;\n}\n\n// below is the endScene hook\nvoid onDrawFrame(...) {\n    if (eventActive) {\n        if (!eventActiveLastFrame) {\n            // react to event model appear\n        }\n        eventActiveLastFrame = true;\n    } else {\n        if (eventActiveLastFrame) {\n            // react to event model disappear\n        }\n        eventActiveLastFrame = false;\n    }\n    eventActive = false;\n}\n```", "```\nvoid parseNextPacket() {\n    if (!network->packetReady()) return;\n\n    auto packet = network->getPacket();\n    auto data = packet->decrypt();\n    switch (data->getType()) {\n        case PACKET_HEALTH_CHANGE:\n            onHealthChange(data->getMessage());\n            break;\n        case PACKET_MANA_CHANGE:\n            onManaChange(data->getMessage());\n            break;\n        // more cases for more packet types\n    }\n}\n```", "```\npacketHandlers[PACKET_HEALTH_CHANGE] = onHealthChange;\npacketHandlers[PACKET_MANA_CHANGE] = onManaChange;\n\nvoid parseNextPacket()\n{\n    if (!network->packetReady()) return;\n    auto packet = network->getPacket();\n    auto data = packet->decrypt();\n    auto handler = packetHandlers[data->getType()];\n    handler->invoke(data->getMessage());\n}\n```", "```\nvoid processNextPacket()\n{\n    if (!network->packetReady()) return;\n    auto packet = network->getPacket();\n    auto data = packet->decrypt();\n    dispatchPacket(data);\n}\n\nvoid dispatchPacket(data)\n{\n    switch (data->getType()) {\n    case PACKET_HEALTH_CHANGE:\n        processHealthChangePacket(data->getMessage());\n        break;\n    case PACKET_MANA_CHANGE:\n        processManaChangePacket(data->getMessage());\n        break;\n        // more cases for more data types\n    }\n}\n```", "```\nUINT SendInput(UINT inputCount, LPINPUT inputs, int size);\n```", "```\nINPUT input = {0};\ninput.type = INPUT_KEYBOARD;\ninput.ki.wVk = VK_F1;\n```", "```\nSendInput(1, &input, sizeof(input));\n// change input to key up\ninput.ki.dwFlags |= KEYEVENTF_KEYUP;\nSendInput(1, &input, sizeof(input));\n```", "```\nvoid sendKeyWithSendInput(WORD key, bool up)\n{\n    INPUT input = {0};\n    input.type = INPUT_KEYBOARD;\n    input.ki.wVk = key;\n    input.ki.dwFlags = 0;\n\n    if (up)\n        input.ki.dwFlags |= KEYEVENTF_KEYUP;\n    SendInput(1, &input, sizeof(input));\n}\nsendKeyWithSendInput(VK_F1, false); // press\nsendKeyWithSendInput(VK_F1, true);  // release\n```", "```\nsendKeyWithSendInput(VK_LSHIFT, false); // press shift\nsendKeyWithSendInput(VK_F1, false);     // press F1\nsendKeyWithSendInput(VK_F1, true);      // release F1\nsendKeyWithSendInput(VK_LSHIFT, true);  // release shift\n```", "```\nLRESULT SendMessage(\n    HWND window,\n    UINT message,\n    WPARAM wparam,\n    LPARAM lparam);\n```", "```\nauto window = FindWindowA(NULL, \"Title Of Game Window\");\n```", "```\nSendMessageA(window, WM_KEYDOWN, VK_F1, 0);\nSendMessageA(window, WM_KEYUP, VK_F1, 0);\n```", "```\nDWORD key = (DWORD)'W';\nSendMessageA(window, WM_KEYDOWN, key, 0);\nSendMessageA(window, WM_CHAR, key, 1);\nSendMessageA(window, WM_KEYUP, key, 1);\n```", "```\nvoid sendKeyWithSendMessage(HWND window, WORD key, char letter)\n{\n    SendMessageA(window, WM_KEYDOWN, key, 0);\n    if (letter != 0)\n        SendMessageA(window, WM_CHAR, letter, 1);\n    SendMessageA(window, WM_KEYUP, key, 1);\n}\n```", "```\nsendKeyWithSendMessage(window, VK_F1, 0);\nsendKeyWithSendMessage(window, 'W', 'W');\n```", "```\nvoid processInput() {\n    do {\n        auto input = getNextInput();\n        if (input.isKeyboard())\n            processKeyboardInput(input);\n        // handle other input types (e.g., mouse)\n    } while (!input.isEmpty());\n}\nvoid processKeyboardInput(input) {\n    if (input.isKeyPress()) {\n        if (input.getKey() == 'W')\n            step(FORWARD);\n        else if (input.getKey() == 'A')\n            step(BACKWARD);\n        // handle other keystrokes (e.g., 'S' and 'D')\n    }\n}\nvoid step(int direction) {\n    if (!map->canWalkOn(player->position))\n        return;\n    playerMovePacket packet(direction);\n    network->send(packet);\n}\n```", "```\ntypedef void _step(int direction);\nauto stepActor = (_step*)0xDEADBEEF;\n\nstepActor(FORWARD);\n```", "```\nvoid onHealthDecrease(int health, int delta) {\n    if (health <= 500)     // health below 500\n        castHealing();\n    else if (delta >= 400) // large drop in health\n        castHealing();\n}\n```", "```\nvoid onIncomingCrowdControl() {\n    // cast a shield to block the crowd control\n    castSpellShield();\n}\nvoid onReceiveCrowdControl() {\n    // cleanse crowd control that has already taken effect\n    castCleanse();\n}\n```", "```\nvoid onManaIncrease(int mana, int delta) {\n    if (delta >= 100) // player is using mana potions,\n        return;       // they must need the mana, abort\n    if (mana >= MAX_MANA - 10) // mana is nearly full, waste some\n        castManaWasteSpell();\n}\n```"]