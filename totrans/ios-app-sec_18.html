<html><head></head><body>
<h2 class="h2" id="ch14"><a id="page_233"/><strong><span class="big">14</span></strong><br/><strong>MOBILE PRIVACY CONCERNS</strong></h2>
<p class="noindent">People tend to carry location-aware mobile devices wherever they go, and they store tons of personal data on these devices, making privacy a constant concern in mobile security. Modern iOS devices allow applications (upon request) to read people’s location data, use the microphone, read contacts, access the M7 motion processor, and much more. Using these APIs responsibly not only is important to users but also can help reduce liability and increase the chances of the application being gracefully accepted into the App Store.</p>
<p class="indent">I discussed a fair bit of privacy-related content in <a href="ch10.html#ch10">Chapter 10</a>; this was largely in regard to accidental data leakage. In this chapter, I’ll cover privacy issues that affect both users and app authors when intentionally gathering and monitoring user data, as well as mitigations for some potential pitfalls.</p>
<h3 class="h3" id="ch14lev1sec01"><strong>Dangers of Unique Device Identifiers</strong></h3>
<p class="noindent">iOS’s <em>unique device identifiers (UDIDs)</em> stand as something of a cautionary tale. For most of iOS’s history, the UDID was used to uniquely identify an individual iOS device, which many applications then used to track user activity or associate a user ID with particular hardware. Some companies used these identifiers as access tokens to remote services, which turned out to be a spectacularly bad idea.</p>
<p class="indent"><a id="page_234"/>Because many organizations were in possession of a device’s UDID and because UDIDs weren’t considered sensitive, companies that did use the UDID effectively as an authenticator were suddenly in a situation where thousands of third parties had their users’ credentials. Software developers also widely assumed that the UDID was immutable, but tools had long been available to spoof UDIDs, either globally or to a specific application.</p>
<h4 class="h4" id="ch14lev2sec01"><em><strong>Solutions from Apple</strong></em></h4>
<p class="noindent">As a result of those issues, Apple now rejects newly submitted applications that use the <span class="literal">uniqueIdentifier</span> API, directing developers to instead use the <span class="literal">identifierForVendor</span> API. This API returns an instance of the <span class="literal">NSUUID</span> class. The <span class="literal">identifierForVendor</span> mechanism should return the same UUID for all applications written by the same vendor on an iOS device, and that UUID will be backed up and restored via iTunes. It is not immutable, however, and can be reset by the user.</p>
<p class="indent">Older applications in the App Store that use <span class="literal">uniqueIdentifier</span> are returned a string starting with <span class="literal">FFFFFFFF</span>, followed by the string normally returned by <span class="literal">identifierForVendor</span>. Similarly, applications using <span class="literal">gethostuuid</span> are now rejected from the App Store, and existing apps receive the <span class="literal">identifierForVendor</span> value when calling this function.</p>
<p class="indent">Applications that use the <span class="literal">NET_RT_IFLIST</span> sysctl or the <span class="literal">SIOCGIFCONF</span> ioctl to read the device’s MAC address now receive <span class="literal">02:00:00:00:00:00</span> instead. Of course, using a MAC address as any kind of token or authenticator has always been a terrible idea; MAC addresses leak over every network you connect to, and they’re easy to change. The nonspecific return value appropriately punishes developers who have taken this approach.</p>
<p class="indent">For advertising and tracking purposes, Apple introduced the property <span class="literal">advertisingIdentifier</span> of the <span class="literal">ASIdentifierManager</span> class. This property returns an NSUUID that is available to all application vendors, but like <span class="literal">uniqueIdentifier</span>, that NSUUID can be wiped or changed (as shown in <a href="ch14.html#ch14fig1">Figure 14-1</a>).</p>
<div class="image"><img alt="image" src="graphics/f14-01.jpg"/></div>
<p class="figcap"><a id="ch14fig1"/><em>Figure 14-1: The user interface for indicating that the</em> <span class="literal">advertisingIdentifier</span> <em>should be used for limited purposes</em></p>
<p class="indentb"><a id="page_235"/>The difference between this system and the original <span class="literal">uniqueIdentifier</span> API is that <span class="literal">advertisingIdentifier</span> is explicitly</p>
<p class="bull">• only for advertising and tracking;</p>
<p class="bull">• not immutable; and</p>
<p class="bull">• subject to user preferences.</p>
<p class="indentt">These aspects of <span class="literal">advertisingIdentifier</span> ostensibly give the user control over what tracking advertisers are allowed to use the mechanism for. Apple states that an application must check the value of <span class="literal">advertisingTrackingEnabled</span>, and if set to <span class="literal">NO</span>, the identifier can be used only for “frequency capping, conversion events, estimating the number of unique users, security and fraud detection, and debugging.”<sup><a href="footnote.html#fn119" id="fn_119">1</a></sup> Unfortunately, that list could encompass pretty much anything advertisers want to do with the <span class="literal">advertisingIdentifier</span>.</p>
<p class="indent">You can determine the value of <span class="literal">advertisingTrackingEnabled</span> as shown in <a href="ch14.html#ch14ex1">Listing 14-1</a>.</p>
<p class="programs"><span class="ent">➊</span> <span class="rose">BOOL</span> limittracking = [[ASIdentifierManager sharedManager]<br/>        advertisingTrackingEnabled];<br/><br/><span class="ent">➋</span> <span class="violet1">NSUUID *advid</span> = [[ASIdentifierManager sharedManager] advertisingIdentifier];</p>
<p class="listcap"><a id="ch14ex1"/><em>Listing 14-1: Determining whether limited ad tracking is enabled and fetching the</em> <span class="literal">advertisingIdentifier</span></p>
<p class="indent">The call to <span class="literal">advertisingTrackingEnabled</span> at <span class="ent">➊</span> reads the user preference for the advertising tracking ID before reading the <span class="literal">advertisingIdentifier</span> itself at <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch14lev2sec02"><em><strong>Rules for Working with Unique Identifiers</strong></em></h4>
<p class="noindent">There are a few general rules to follow when working with unique identifiers of any type. First, never assume identifiers are immutable. Any identifier supplied by the device can be changed by someone in physical possession of the device. Second, never assume a 1:1 relationship between devices and identifiers. Identifiers can be moved from one device to another and as such cannot be trusted to uniquely identify a single device. Because identifiers can change, aren’t unique, and may be widely distributed, you also shouldn’t use them to authenticate users. Finally, keep identifiers as anonymous as possible. They might be useful for tracking general trends in user behavior, but don’t tie an identifier to a user identity unless there’s a compelling need to do so.</p>
<h3 class="h3" id="ch14lev1sec02"><a id="page_236"/><strong>Mobile Safari and the Do Not Track Header</strong></h3>
<p class="noindent">Starting with iOS 6, Mobile Safari includes the option to enable the Do Not Track mechanism,<sup><a href="footnote.html#fn120" id="fn_120">2</a></sup> which tells the remote server that the user wants to opt out of being tracked by certain parties. This option is expressed with the <span class="literal">HTTP_DNT</span> header. When set to 1, the header indicates that the user consents to being tracked only by the site that is currently being visited. When set to 0, it indicates that the user doesn’t want to be tracked by any party. Users can enable this mode in the Safari settings (<a href="ch14.html#ch14fig2">Figure 14-2</a>).</p>
<div class="image"><img alt="image" src="graphics/f14-02.jpg"/></div>
<p class="figcap"><a id="ch14fig2"/><em>Figure 14-2: The user interface for enabling Do Not Track</em></p>
<p class="indent">At a minimum, it makes sense to assume that users want to protect details of their activity from third-party advertisers or analytics firms. This is the behavior specified by an <span class="literal">HTTP_DNT</span> value of 1, which is the header that iOS sends by default.</p>
<p class="indent">But the definition of tracking varies. The specification for the Do Not Track mechanism itself notes the following:</p>
<div class="blockquote">
<p class="noindent">The WG has not come to consensus regarding the definition of tracking and the scope of DNT. As such, a site cannot actually say with any confidence whether or not it is tracking, let alone describe the finer details in a tracking status resource.<sup><a href="footnote.html#fn121" id="fn_121">3</a></sup></p>
</div>
<p class="indent"><a id="page_237"/>According to the specification, websites can prompt the user to opt into specific tracking scenarios using the <span class="literal">storeSiteSpecificTrackingException</span> JavaScript API, but this functionality is not widely implemented at the time of this writing.</p>
<h3 class="h3" id="ch14lev1sec03"><strong>Cookie Acceptance Policy</strong></h3>
<p class="noindent">Cookies on iOS are managed via the <span class="literal">NSHTTPCookieStorage</span> API. The method <span class="literal">sharedHTTPCookieStorage</span> returns the cookie store, but despite the method’s name, iOS cookie storage is specific to each application. Cookies actually live in a database under the application main bundle directory.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>The name</em> <span class="literal"><em>sharedHTTPCookieStorage</em></span> <em>originates from OS X, where the OS uses a global cookie store shared among all applications.</em></p>
</div>
<p class="indentb">Cookies used by the URL loading system are accepted according to a systemwide shared <span class="literal">cookieAcceptPolicy</span>, which any application can specify. This policy can be set to any of the following:</p>
<p class="hanging"><span class="literal"><strong>NSHTTPCookieAcceptPolicyAlways</strong></span> Accept and store all received cookies. This is the default.</p>
<p class="hanging"><span class="literal"><strong>NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain</strong></span> Accept only first-party cookies.</p>
<p class="hanging"><span class="literal"><strong>NSHTTPCookieAcceptPolicyNever</strong></span> Never accept cookies.</p>
<p class="indentt">Note that on devices running anything older than iOS 7, the cookie acceptance policy is shared among applications, which could cause problems for your application. On such devices, when another running application changes its acceptance policy, your app’s policy changes as well. For example, an application that relies on third-party cookies for advertising revenue might repeatedly set its cookie policy to <span class="literal">NSHTTPCookieAcceptPolicyAlways</span>, changing yours to the same policy in the process.</p>
<p class="indent">Fortunately, you can specify your preferred <span class="literal">cookieAcceptPolicy</span> using events such as <span class="literal">didFinishLaunchingWithOptions</span>, and you can monitor for changes to the cookie acceptance policy while your program is running, as shown in <a href="ch14.html#ch14ex2">Listing 14-2</a>.</p>
<p class="programs"><span class="ent">➊</span> [[<span class="violet1">NSNotificationCenter</span> defaultCenter] addObserver:<span class="rose">self</span> selector:<span class="rose">@selector</span><br/>       (cookieNotificationHandler:)<br/>      name:<span class="violet1">NSHTTPCookieManagerAcceptPolicyChangedNotification</span> object:nil];<br/><br/>   - (<span class="rose">void</span>) cookieNotificationHandler:(<span class="violet1">NSNotification</span> *)notification {<br/>       <span class="violet1">NSHTTPCookieStorage</span> *cookieStorage = [<span class="violet1">NSHTTPCookieStorage</span><br/>        sharedHTTPCookieStorage];<br/><br/><span class="ent">➋</span>     [cookieStorage setCookieAcceptPolicy:<span class="violet1">NS</span><br/>       <span class="violet1">HTTPCookieAcceptPolicyOnlyFromMainDocumentDomain];</span><br/>   <span class="violet1">}</span></p>
<p class="listcap"><a id="ch14ex2"/><em>Listing 14-2: Registering to receive notifications when the cookie acceptance policy changes</em></p>
<p class="indent"><a id="page_238"/><a href="ch14.html#ch14ex2">Listing 14-2</a> registers an <span class="literal">NSNotificationCenter</span> at <span class="ent">➊</span>, which listens for <span class="literal">NSHTTPCookieManagerAcceptPolicyChangedNotification</span>. If the policy changes, the selector identified at <span class="ent">➊</span>, <span class="literal">cookieNotificationHandler</span>, will be called. In the <span class="literal">cookieNotificationHandler</span>, you set the policy to <span class="literal">NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain</span> at <span class="ent">➋</span>.</p>
<p class="indent">In iOS 7 and later, changes in cookie management policy affect only the running application. Applications can also specify different cookie management policies for different HTTP sessions via <span class="literal">NSURLSession</span>. For more on this, see “<a href="ch07.html#ch07lev1sec02">Using NSURLSession</a>” on <a href="ch07.html#page_117">page 117</a>.</p>
<h3 class="h3" id="ch14lev1sec04"><strong>Monitoring Location and Movement</strong></h3>
<p class="noindent">One of the most useful features of mobile platforms is their ability to make information and functionality relevant to a user’s current physical location and method of movement. iOS devices primarily determine location based on Wi-Fi and GPS, and they monitor body movement with the M7 motion processor.</p>
<p class="indent">Gathering location and movement data has dangers, however. In this section, I’ll discuss how gathering both types of data works and why you should take care when storing such information.</p>
<h4 class="h4" id="ch14lev2sec03"><em><strong>How Geolocation Works</strong></em></h4>
<p class="noindent">Wi-Fi geolocation scans for available wireless access points and queries a database that has a record of access points and their GPS coordinates. These databases are built by third parties that effectively wardrive entire cities and note the coordinates of each discovered access point. Of course, this can result in inaccurate results in some circumstances. For example, if someone travels with network equipment, or relocates it, the location data may not get updated for some time.</p>
<p class="indent">GPS can provide more specific navigation information, as well as motion information, to track users in transit. This requires the ability to contact GPS satellites, which is not always possible, so GPS is often used as a fallback or when a high degree of accuracy is required. GPS is also required to determine information such as speed or altitude.</p>
<h4 class="h4" id="ch14lev2sec04"><em><strong>The Risks of Storing Location Data</strong></em></h4>
<p class="noindent">Few aspects of mobile privacy have generated as much negative press as tracking users via geolocation data. While useful for an array of location-aware <a id="page_239"/>services, a number of issues arise when location data is recorded and stored over time. Most obvious are privacy concerns: users may object to their location data being stored long-term and correlated with other personal information.<sup><a href="footnote.html#fn122" id="fn_122">4</a></sup> Aside from PR concerns, some European countries have strict privacy and data protection laws, which must be taken into account.</p>
<p class="indent">A less obvious problem is that storing location data linked to specific users could leave you legally vulnerable. When you store location data along with data that links it to a specific individual, that data could be subpoenaed by law enforcement or litigators. This often occurs in divorce cases, where lawyers attempt to demonstrate infidelity by showing the physical comings and goings of one of the parties in the course of a relationship; toll authorities that use electronic tracking have had to respond to these inquiries for years.</p>
<h4 class="h4" id="ch14lev2sec05"><em><strong>Restricting Location Accuracy</strong></em></h4>
<p class="noindentb">Because precise historical location data raises such privacy and liability concerns, it’s important to use the least degree of accuracy necessary for your intended purpose. For example, if your application is designed to determine what city or neighborhood a user is in for the purpose of making a dinner reservation, you’ll only need to get a user’s location within a kilometer or so. If your purpose is to find the nearest ATM to a user, you’ll want to use something significantly narrower. The following are the geolocation accuracy constants available via the Core Location API:</p>
<p class="bull">• <span class="literal">kCLLocationAccuracyBestForNavigation</span></p>
<p class="bull">• <span class="literal">kCLLocationAccuracyBest</span></p>
<p class="bull">• <span class="literal">kCLLocationAccuracyNearestTenMeters</span></p>
<p class="bull">• <span class="literal">kCLLocationAccuracyHundredMeters</span></p>
<p class="bull">• <span class="literal">kCLLocationAccuracyKilometer</span></p>
<p class="bull">• <span class="literal">kCLLocationAccuracyThreeKilometers</span></p>
<p class="indentt">Restricting location accuracy to the least degree necessary is not only a best practice for privacy and legal reasons but also reduces power consumption. This is because less accurate methods use the rather quick Wi-Fi detection mechanisms and update less frequently, while the highest accuracy settings will often use GPS and update frequently.</p>
<p class="indent">If you do need to store multiple instances of a user’s location over time, ensure that procedures are in place to prune this data eventually. For instance, if you need to reference only a month’s worth of location data at a time, ensure that older data is properly sanitized or erased. If you’re using location data for analytics that don’t require linking to a specific user, omit or remove any data that uniquely identifies the user.</p>
<h4 class="h4" id="ch14lev2sec06"><a id="page_240"/><em><strong>Requesting Location Data</strong></em></h4>
<p class="noindent">Permission data is requested using <span class="literal">CLLocationManager</span>, which specifies an accuracy constant as well as whether your app needs location data when it’s backgrounded. <a href="ch14.html#ch14ex3">Listing 14-3</a> shows an example invocation.</p>
<p class="programs"><span class="ent">➊</span> [<span class="rose">self</span> setLocationManager:[[CLLocationManager <span class="violet">alloc</span>] <span class="violet">init</span>]];<br/><span class="ent">➋</span> [[<span class="rose">self</span> locationManager] <span class="violet">setDelegate</span><span class="rose">:self</span>];<br/><span class="ent">➌</span> [[<span class="rose">self</span> locationManager] setDesiredAccuracy:kCLLocationAccuracyHundredMeters];<br/><br/>   <span class="rose">if</span> ([[<span class="rose">self</span> locationManager] respondsToSelector:<br/>        <span class="rose">@selector</span>(requestWhenInUseAuthorization)]) {<br/><span class="ent">➍</span>     [[<span class="violet1">UIApplication</span> <span class="violet">sharedApplication</span><span class="violet1">] sendAction:</span><br/>        <span class="rose">@selector</span><span class="violet1">(requestWhenInUseAuthorization)</span><br/>                                                 <span class="violet1">to:[</span><span class="rose">self</span> <span class="violet1">locationManager]</span><br/>                                               <span class="violet1">from:</span><span class="rose">self</span><br/>                                           <span class="violet1">forEvent:nil];</span><br/><span class="ent">➎</span>     <span class="violet1">[[</span><span class="rose">self</span> <span class="violet1">locationManager]</span> <span class="violet">startUpdatingLocation</span><span class="violet1">];</span><br/>   <span class="violet1">}</span></p>
<p class="listcap"><a id="ch14ex3"/><em>Listing 14-3: Requesting location data permissions</em></p>
<p class="indent">Here, a <span class="literal">CLLocationManager</span> is allocated <span class="ent">➊</span> and its delegate is set to <span class="literal">self</span> <span class="ent">➋</span>. Then the desired accuracy of about 100 meters is set at <span class="ent">➌</span>. At <span class="ent">➍</span>, the permission request is sent, which will cause the authorization prompt to appear to the user. Finally, at <span class="ent">➎</span>, there’s a request for the manager to start monitoring the user’s location.</p>
<p class="indent">Note that as of iOS 8, the location manager won’t actually start unless you have a description of why you need location data. This is specified in your <em>Info.plist</em> file, using either <span class="literal">NSLocationWhenInUseUsageDescription</span> if you need to access location data only when the app is in use or <span class="literal">NSLocationAlwaysUsageDescription</span> if you’ll also need to get location information from the background. Add one of these to your plist file, along with a concise but specific rationale to be displayed to the user when they’re prompted to grant permission to location data.</p>
<h3 class="h3" id="ch14lev1sec05"><strong>Managing Health and Motion Information</strong></h3>
<p class="noindent">Some of the most sensitive information that applications can handle is health information about the user. On iOS, this data can be retrieved using the HealthKit API and the APIs provided by the device’s M7 motion processor, if it has one. You’ll take a brief look at how to read and write this data and how to request the minimum privileges necessary for an app to function.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>As of iOS 9, HealthKit is available only on iPhones, not on iPads.</em></p>
</div>
<h4 class="h4" id="ch14lev2sec07"><a id="page_241"/><em><strong>Reading and Writing Data from HealthKit</strong></em></h4>
<p class="noindent">HealthKit information can be requested either for reading or for both reading and writing (somewhat confusingly called <em>sharing</em> by Apple). In keeping with requesting only the permissions that are absolutely necessary, request read-only access if possible. <a href="ch14.html#ch14ex4">Listing 14-4</a> shows how permissions for specific health data are requested.</p>
<p class="programs">   <span class="rose">if</span> ([HKHealthStore <span class="violet">isHealthDataAvailable</span>]) {<br/>       HKHealthStore *healthStore = [[HKHealthStore <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➊</span>     HKObjectType *heartRate = [HKObjectType <span class="violet">quantityTypeForIdentifier</span>:<br/>        HKQuantityTypeIdentifierHeartRate];<br/><span class="ent">➋</span>     HKObjectType *dob = [HKObjectType <span class="violet">characteristicTypeForIdentifier</span>:<br/>        HKCharacteristicTypeIdentifierDateOfBirth];<br/><span class="ent">➌</span>     [healthStore <span class="violet">requestAuthorizationToShareTypes</span>:<br/>       [<span class="violet1">NSSet</span> <span class="violet">setWithObject</span>:heartRate]<br/>                   readTypes:[<span class="violet1">NSSet</span> <span class="violet">setWithObject</span>:dob]<br/><span class="ent">➍</span>                 completion:^(<span class="rose">BOOL</span> success, <span class="violet1">NSError</span> *error) {<br/>                                              <span class="rose">if</span> (!success) {<br/>                                                  <span class="green1"><span class="codeitalic">// Failure and sadness</span></span><br/><br/>                                              } <span class="rose">else</span> {<br/>                                                  <span class="green1"><span class="codeitalic">// We succeeded!</span></span><br/>                                              }<br/>                                          }];<br/>   }</p>
<p class="listcap"><a id="ch14ex4"/><em>Listing 14-4: Requesting health data permissions</em></p>
<p class="indent">At <span class="ent">➊</span> and <span class="ent">➋</span>, you specify two types of data that you’d like to access, namely, heart rate and date of birth. At <span class="ent">➌</span>, you request authorization to access these, with a <span class="literal">completion</span> block to handle success or failure. Note that the <span class="literal">requestAuthorizationToShareTypes</span> is requesting read/write access, presumably because this application is intended to track and record the user’s heart rate. The <span class="literal">readTypes</span> parameter specifies that you want to monitor the user’s heart rate but not write to it. In this case, you’re requesting the user’s date of birth (something rather unlikely to change) to infer their age. Finally, to allow you to distribute the application, you’ll need to enable the HealthKit entitlement in Xcode, as shown in <a href="ch14.html#ch14fig3">Figure 14-3</a>.</p>
<p class="indent">While HealthKit shows how to record steps, but there are more detailed ways to get motion data to help guess exactly what kind of activity the user is engaged in. This more detailed data can be retrieved using the M7 motion tracker.</p>
<div class="image"><a id="page_242"/><img alt="image" src="graphics/f14-03.jpg"/></div>
<p class="figcap"><a id="ch14fig3"/><em>Figure 14-3: Enabling the HealthKit entitlement in Xcode</em></p>
<h4 class="h4" id="ch14lev2sec08"><em><strong>The M7 Motion Processor</strong></em></h4>
<p class="noindent">The iPhone 5s introduced the M7 motion-tracking processor, which allows for the recording of detailed information about small movements while reducing the battery drain that this has incurred in the past. Fitness applications could use this data to determine the type of physical activity the user is currently engaging in and how many steps they’ve taken. Applications that monitor sleep quality could also take advantage of this to determine how deep the user is sleeping based upon slight movements. Obviously, the ability to determine when a user is asleep and what they’re doing outside of using the phone is a significant responsibility. Apple details the degree to which users can be tracked via the M7 as follows:</p>
<div class="blockquote">
<p class="noindent">M7 knows when you’re walking, running, or even driving. For example, Maps switches from driving to walking turn-by-turn navigation if, say, you park and continue on foot. Since M7 can tell when you’re in a moving vehicle, iPhone 5s won’t ask you to join Wi-Fi networks you pass by. And if your phone hasn’t moved for a while, like when you’re asleep, M7 reduces network pinging to spare your battery.<sup><a href="footnote.html#fn123" id="fn_123">5</a></sup></p>
</div>
<p class="indent">Use of the M7 processor is granted in a manner similar to basic geolocation permissions. But M7 has a quirk not present in other geolocation data access: applications have access to data that was recorded before they were granted permission to access location data. If you’re going to use this historic data, inform the user in your permissions message and, ideally, give them a choice as to whether to use or disregard this data.</p>
<h3 class="h3" id="ch14lev1sec06"><a id="page_243"/><strong>Requesting Permission to Collect Data</strong></h3>
<p class="noindent">When attempting to access sensitive data such as a user’s contacts, calendar, reminders, microphone, or motion data, the user will be prompted with an alert to grant or deny this access. To ensure that the user is presented with useful information as to why you need this access, define strings to be delivered to the user as part of the access prompt. Make these explanations simple but descriptive, as in <a href="ch14.html#ch14fig4">Figure 14-4</a>.</p>
<div class="image"><img alt="image" src="graphics/f14-04.jpg"/></div>
<p class="figcap"><a id="ch14fig4"/><em>Figure 14-4: Delivering the request to the user</em></p>
<p class="indent">You can set those messages in your app’s <em>Info.plist</em> file through Xcode, shown in <a href="ch14.html#ch14fig5">Figure 14-5</a>.</p>
<div class="image"><img alt="image" src="graphics/f14-05.jpg"/></div>
<p class="figcap"><a id="ch14fig5"/><em>Figure 14-5: Describing needs for various kinds of access in an</em> Info.plist</p>
<p class="indent">Additionally, ensure that your application handles the refusal of these permissions gracefully. Unlike Android, where permission granting is an all-or-nothing affair, iOS applications are expected by Apple to be able to handle having some permissions granted and others refused.</p>
<h3 class="h3" id="ch14lev1sec07"><a id="page_244"/><strong>Proximity Tracking with iBeacons</strong></h3>
<p class="noindent">Apple’s iBeacons are designed to measure your proximity to hardware and take certain actions when you’re within range. For example, an app could use the beacons to track your movements through a mall or store, or indicate that the car that just pulled up next to you is the Uber car you requested. iBeacon functionality is part of the Core Location API, which uses Bluetooth Low Energy (BTLE) on compatible devices to manage proximity monitoring.</p>
<p class="indent">In this section, I’ll first discuss how some applications check for iBeacons and how iOS devices can become iBeacons. I’ll end on privacy issues you should consider when using iBeacons in your own apps.</p>
<h4 class="h4" id="ch14lev2sec09"><em><strong>Monitoring for iBeacons</strong></em></h4>
<p class="noindent">Monitoring for iBeacons is accomplished by instantiating a Core Location <span class="literal">CLLocationManager</span> and passing a <span class="literal">CLBeaconRegion</span> to the manager’s <span class="literal">startMonitoringForRegion</span> method, as in <a href="ch14.html#ch14ex5">Listing 14-5</a>.</p>
<p class="programs"><span class="ent">➊</span> <span class="violet1">NSUUID *myUUID = [[NSUUID</span> <span class="violet">allo</span><span class="violet1">c] initWithUUIDString:</span><br/>        <span class="red">@"CE7B5250-C6DD-4522-A4EC-7108BCF3F7A4"</span><span class="violet1">];</span><br/>   <span class="violet1">NSString *myName =</span> <span class="red">@"My test beacon"</span><span class="violet1">;</span><br/><br/>   <span class="violet1">CLLocationManager *myManager = [[CLLocationManager</span> <span class="violet">alloc</span><span class="violet1">]</span> <span class="violet">init</span><span class="violet1">];</span><br/>   <span class="violet1">[myManager</span> <span class="violet">setDelegate</span><span class="violet1">:</span><span class="rose">self</span><span class="violet1">];</span><br/><br/><span class="ent">➋</span> <span class="violet1">CLBeaconRegion *region</span> = [[CLBeaconRegion <span class="violet">alloc</span>] initWithProximity<span class="violet1">UUID:myUUID</span><br/><span class="ent">➌</span>                                                             <span class="violet1">identifier:myName];</span><br/>   [<span class="violet1">myManager</span> <span class="violet">startMonitoringForRegion</span><span class="violet1">:region];</span></p>
<p class="listcap"><a id="ch14ex5"/><em>Listing 14-5: Initiating monitoring for a specific region defined by a UUID</em></p>
<p class="indent">The NSUUID generated at <span class="ent">➊</span> is assigned to a <span class="literal">CLBeaconRegion</span> <span class="ent">➋</span> and will be used to uniquely identify that beacon. The identifier <span class="ent">➌</span> will specify the symbolic name for the beacon. Note you can register to monitor for multiple regions with the same <span class="literal">CLLocationManager</span>.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>You can use the</em> <span class="literal"><em>uuidgen(1)</em></span> <em>command in the terminal to generate a unique UUID to use as a beacon identifier.</em></p>
</div>
<p class="indent">You’ll also need to implement a <span class="literal">locationManager</span> delegate method, as in <a href="ch14.html#ch14ex6">Listing 14-6</a>, to handle location updates.</p>
<p class="programs">- (<span class="rose">void</span>)locationManager:(CLLocationManager *)manager<br/>         <span class="violet">didEnterRegion</span>:(CLRegion *)region {<br/>  <span class="rose">if</span> ([[region identifier] <span class="violet">isEqualToString</span>:myName]) {<br/>    [<span class="rose">self</span> startRangingBeaconsInRegion:region];<br/>  }<br/>}</p>
<p class="listcap"><a id="ch14ex6"/><em>Listing 14-6: An example</em> <span class="literal">locationManager</span> <em>delegate method</em></p>
<p class="indent"><a id="page_245"/>This method will be called whenever a device running your application enters an iBeacon’s registered region; your app can then perform whatever logic is appropriate upon entering that region. Once the application gets the notification that the device has entered the range of a beacon, it can start <em>ranging</em>, or measuring the distance between the device and the beacon.</p>
<p class="indent">After an application has begun ranging a beacon, the <span class="literal">locationManager:didRangeBeacons:inRegion</span> delegate method (<a href="ch14.html#ch14ex7">Listing 14-7</a>) will be called periodically, allowing the application to make decisions based on the proximity of the beacon.</p>
<p class="programs">- (<span class="rose">void</span>)locationManager:(CLLocationManager *)manager didRangeBeacons:<br/>     (<span class="violet1">NSArray</span> *)beacons inRegion:(CLBeaconRegion *)region<br/>{<br/>  CLBeacon *beacon = [beacons <span class="violet">objectAtIndex</span>:0];<br/><br/>  <span class="rose">switch</span> ([beacon proximity]) {<br/>    <span class="rose">case</span> CLProximityImmediate:<br/>      <span class="green1"><span class="codeitalic">//</span></span><br/>      <span class="rose">break</span>;<br/>    <span class="rose">case</span> CLProximityNear:<br/>      <span class="green1"><span class="codeitalic">//</span></span><br/>      <span class="rose">break</span>;<br/>    <span class="rose">case</span> CLProximityFar:<br/>      <span class="green1"><span class="codeitalic">//</span></span><br/>      <span class="rose">break</span>;<br/>    <span class="rose">case</span> CLProximityUnknown:<br/>      <span class="green1"><span class="codeitalic">//</span></span><br/>      <span class="rose">break</span>;<br/>  }<br/>}</p>
<p class="listcap"><a id="ch14ex7"/><em>Listing 14-7: The</em> <span class="literal">locationManager</span> <em>callback for examining beacons</em></p>
<p class="indent">There are four constants representing proximity: <span class="literal">CLProximityImmediate</span>, <span class="literal">CLProximityNear</span>, <span class="literal">CLProximityFar</span>, and <span class="literal">CLProximityUnknown</span>. See <a href="ch14.html#ch14tab1">Table 14-1</a> for the meanings of these values.</p>
<p class="tablecap"><a id="page_246"/><a id="ch14tab1"/><strong>Table 14-1:</strong> Region Proximity (Range) Measurements</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Item class</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">CLProximityUnknown</span></p></td>
<td class="table" valign="top"><p class="table">The range is undetermined.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">CLProximityImmediate</span></p></td>
<td class="table" valign="top"><p class="table">The device is right next to the beacon.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">CLProximityNear</span></p></td>
<td class="table" valign="top"><p class="table">The device is within a few meters of the beacon.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">CLProximityFar</span></p></td>
<td class="table" valign="top"><p class="table">The device is within range but near the edge of the region.</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch14lev2sec10"><em><strong>Turning an iOS Device into an iBeacon</strong></em></h4>
<p class="noindent">BTLE iOS devices can also act as iBeacons, broadcasting their presence to the outside world, which can be used to detect and measure proximity between iOS devices. This is done via the CoreBluetooth framework, using a <span class="literal">CBPeripheralManager</span> instance and giving it a <span class="literal">CLBeaconRegion</span> with a chosen UUID (<a href="ch14.html#ch14ex8">Listing 14-8</a>).</p>
<p class="programs"><span class="ent">➊</span> <span class="violet1">NSUUID *myUUID = [[NSUUID</span> <span class="violet">alloc</span><span class="violet1">] initWithUUIDString:</span><br/>        <span class="red">@"CE7B5250-C6DD-4522-A4EC-7108BCF3F7A4"</span><span class="violet1">];</span><br/><span class="ent">➋</span> <span class="violet1">NSString *myName =</span> <span class="red">@"My test beacon"</span><span class="violet1">;</span><br/><br/><span class="ent">➌</span> <span class="violet1">CLBeaconRegion *region = [[CLBeaconRegion</span> <span class="violet">alloc</span><span class="violet1">] initWithProximityUUID:myUUID</span><br/>                                                              <span class="violet1">identifier:myName];</span><br/><br/><span class="ent">➍</span> <span class="violet1">NSDictionary *peripheralData = [region</span> <span class="violet">peripheralDataWithMeasuredPower</span><span class="violet1">:nil];</span><br/><br/><span class="ent">➎</span> <span class="violet1">CBPeripheralManager *manager = [[CBPeripheralManager</span> <span class="violet">alloc</span><span class="violet1">]</span> <span class="violet">initWithDelegate</span><span class="violet1">:</span><span class="rose">self</span><br/>                                                                        <span class="violet1">queue:nil];</span><br/><br/><span class="ent">➏</span> <span class="violet1">[manager startAdvertising:peripheralData];</span></p>
<p class="listcap"><a id="ch14ex8"/><em>Listing 14-8: Turning your application into an iBeacon</em></p>
<p class="indent">The code generates a UUID at <span class="ent">➊</span> and a symbolic name at <span class="ent">➋</span>, and then defines a region at <span class="ent">➌</span>. At <span class="ent">➍</span>, the <span class="literal">peripheralDataWithMeasuredPower</span> method returns a dictionary with the information needed to advertise the beacon (the <span class="literal">nil</span> parameter just tells the code to use the default signal strength parameters for the device). At <span class="ent">➎</span>, an instance of <span class="literal">CBPeripheralManager</span> is instantiated and finally the <span class="literal">peripheralData</span> <span class="ent">➏</span> is passed to the manager so it can begin advertising.</p>
<p class="indent">Now that you’ve taken a look at how iBeacons are managed, let’s look at some of the privacy implications of implementing them.</p>
<h4 class="h4" id="ch14lev2sec11"><a id="page_247"/><em><strong>iBeacon Considerations</strong></em></h4>
<p class="noindent">Obviously, iBeacons provide extremely detailed information about a user’s whereabouts. Beacons don’t have to be dumb transmitters; they can also be programmable devices or other iOS devices that can record location updates and deliver them to central servers. Users are likely to object to this data being tracked over the long term, so as with other geolocation data, avoid keeping any beacon logs for any longer than they’re specifically needed. Also, don’t tie the time and beacon information in such a way that they can be correlated with a specific user in the long term.</p>
<p class="indent">Your app should turn the device it’s installed on into a beacon sparingly. Becoming a beacon makes the device discoverable, so be sure to inform the user of your intentions in a manner that communicates that fact. If possible, perform Bluetooth advertising for only a limited time window, ceasing it once necessary data has been exchanged.</p>
<p class="indent">Now that you’ve looked at some of the many ways apps gather information about users, let’s look at some of the policy guidelines that will dictate how those apps handle personal data.</p>
<h3 class="h3" id="ch14lev1sec08"><strong>Establishing Privacy Policies</strong></h3>
<p class="noindent">For your own protection, always explicitly state a privacy policy in your application. If your app is set to Made for Kids, a privacy policy is both an App Store requirement and a legal one, as required by the Children’s Online Privacy Protection Act (COPPA).</p>
<p class="indentb">I’m no lawyer, so of course, I can’t give specific legal advice on how your policy should be implemented. However, I would advise you to include the following in your privacy policy:</p>
<p class="bull">• The information your app gathers and whether it is identifying or non-identifying (that is, whether it can be tied back to a specific user)</p>
<p class="bull">• The mechanisms by which information is gathered</p>
<p class="bull">• The reasons for gathering each type of data</p>
<p class="bull">• How that data is processed and stored</p>
<p class="bull">• The retention policy of the data (that is, how long data is stored)</p>
<p class="bull">• If and how the information you gather is shared with third parties</p>
<p class="bull">• How users can change data collection settings if desired</p>
<p class="bull">• Security mechanisms in place to protect user data</p>
<p class="bull">• A history of changes to the privacy policy</p>
<p class="indentt">The Electronic Frontier Foundation (EFF) provides a good template for developing an effective and informative privacy policy, which you can find at <em><a href="https://www.eff.org/policy">https://www.eff.org/policy</a></em>.</p>
<p class="indent"><a id="page_248"/>Do note that Apple has some specific requirements for how to implement privacy policies in the application and how they should be made available. Specifically, all applications that offer autorenewed or free subscriptions and apps that are categorized as Made for Kids must include a URL to a privacy policy. If the application is set to Made for Kids, the policy needs to be localized for each localization within the application.<sup><a href="footnote.html#fn124" id="fn_124">6</a></sup></p>
<h3 class="h3" id="ch14lev1sec09"><strong>Closing Thoughts</strong></h3>
<p class="noindent">In light of disclosures about massive government surveillance in the United States and abroad, consumer awareness and concern about companies gathering and correlating their personal information and habits is likely to increase. It’s also become clear that the more information you gather on your users, the greater your company risks exposure. Companies with the most detailed information on their users are those most attractive to government intrusion, either by subpoena, monitoring, or active hacking by intelligence agencies.</p>
<p class="indent">In summary, always clearly define your intentions and minimize data gathered to limit your exposure and to build and maintain trust with consumers.</p>
</body></html>