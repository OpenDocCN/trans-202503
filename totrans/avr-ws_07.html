<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch07">
  <div id="header0701" class="chapter">
   <h1 class="cn">
    <span class="page" id="p152">
    </span>
    <span class="page" id="p153">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch07">
     7
    </a>
   </h1>
   <h1 class="ctfm">
    Using Pulse-Width Modulation
   </h1>
  </div>
  <div class="figure" id="ct07">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   When you need a digital output to simulate an analog signal, such as operating an LED at partial brightness, you can use
   <i class="calibre5">
    pulse-width modulation (PWM)
   </i>
   to adjust the amount of time between each high and low signal from a digital output pin. PWM can generate various effects, such as adjusting the brightness of an LED, controlling the speed of an electric motor, and creating sounds using tools that convert electricity into vibrations.
  </p>
  <p class="calibre8">
   In this chapter, you will:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Learn how pulse-width modulation works and is generated by AVRs.
   </li>
   <li class="bl">
    • Use PWM with ATtiny85 and ATmega328P-PU microcontrollers.
   </li>
   <li class="bl">
    • Make varying tones of sound using piezo elements with PWM.
   </li>
   <li class="bl">
    • Learn how to use PWM to create colorful effects using RGB LEDs.
   </li>
  </ul>
  <div class="chapter">
   <h2 class="ah" id="ah0901">
    <span class="page" id="p154">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0901">
     Pulse-Width Modulation and Duty Cycles
    </a>
   </h2>
   <p class="paft">
    PWM allows us to control the perceived brightness of an LED, instead of simply switching it on and off as we’ve done in previous chapters. The LED’s brightness is determined by the
    <i class="calibre5">
     duty cycle
    </i>
    , or the length of time the PORT
    <i class="calibre5">
     x
    </i>
    pin is on (meaning the LED is lit) versus the length of time it is off (the LED is unlit). Duty cycle is expressed as the percentage of “on” time. The greater the duty cycle—that is, the longer the PORT
    <i class="calibre5">
     x
    </i>
    pin is on compared to off in each cycle—the greater the perceived brightness of the LED connected to the pin.
   </p>
   <p class="calibre8">
    Furthermore, the higher the frequency of the PWM signal is—that is, the faster the signal is turned on and off—the smoother the visual effect is. If you’re controlling a motor, a higher PWM frequency will make the rotational speed a closer approximation of the actual speed required.
   </p>
   <p class="calibre8">
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07001">
     Figure 7-1
    </a>
    shows four possible PWM duty cycles. The filled-in gray areas represent the amount of time that the LED is on; as you can see, this increases with the duty cycle.
   </p>
   <div class="figure" id="f07001">
    <p class="fig">
     <img alt="Diagram of four PWM duty cycles: 100%, 60%, 40%, and 20%" height="741" src="images/nsp-boxall502581-f07001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 7-1:
      </span>
      Various PWM duty cycles
     </p>
    </div>
   </div>
   <p class="calibre8">
    We can only use certain pins on our AVR microcontrollers for PWM. For the ATtiny85, we use PB0, PB1, and PB4; for the ATmega328P-PU, we use PB1 to PB3 and PD3, PD5, and PD6. To create a PWM signal, we need to set the required registers depending on the microcontroller used. I’ll demonstrate this for both microcontrollers in this chapter. Let’s begin with the ATtiny85.
   </p>
   <p class="hd" id="pro31">
    <span class="page" id="p155">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro31">
     <span class="ccust1">
      Project 31: Demonstrating PWM with the ATtiny85
     </span>
    </a>
   </p>
   <p class="paft">
    In this project, you’ll learn how to trigger the available PWM outputs offered by the ATtiny85 microcontroller. We trigger each output slightly differently, but the process is always simple.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0901">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0901">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATtiny85 microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Three LEDs
     </li>
     <li class="bll">
      • Three 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0017.xhtml#f07002">
      Figure 7-2
     </a>
     .
    </p>
    <div class="figure" id="f07002">
     <p class="fig">
      <img alt="Schematic diagram for Project 31" height="437" src="images/nsp-boxall502581-f07002.jpg" width="932" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 7-2:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
        Project 31
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller in the usual way.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0902">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0902">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 31
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 7
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. Once the project’s code has been uploaded to the microcontroller the LEDs connected to PB4, PB1, and PB0 should all start to fade on and off at the same time, repeatedly displaying rising then falling levels of brightness.
    </p>
    <p class="calibre8">
     Let’s see how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
      Project 31
     </a>
     .
    </p>
    <pre>
     <p class="clf">
      <span id="p156">
      </span>
      // Project 31 - Demonstrating PWM with the ATtiny85
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set PB4, PB1, PB0 as outputs
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRB |= (1 &lt;&lt; PORTB4)|(1 &lt;&lt; PORTB1)|(1 &lt;&lt; PORTB0);
     </p>
     <p class="clf">
      <!--<ccust1>2</ccust1>-->
      ❷ // PB0
     </p>
     <p class="cl">
      // Set timer mode to FAST PWM
     </p>
     <p class="cl">
      TCCR0A |= (1 &lt;&lt; WGM01)|(1 &lt;&lt; WGM00);
     </p>
     <p class="cl">
      // Connect PWM signal to pin (OC0A =&gt; PB0)
     </p>
     <p class="cl">
      TCCR0A |= (1 &lt;&lt; COM0A1);
     </p>
     <p class="cl">
      // No prescaler
     </p>
     <p class="cl">
      TCCR0B |= (1 &lt;&lt; CS00);
     </p>
     <p class="clf">
      <!--<ccust1>3</ccust1>-->
      ❸ // PB1
     </p>
     <p class="cl">
      // Connect PWM signal to pin (OC0B =&gt; PB0)
     </p>
     <p class="cl">
      TCCR0A |= (1 &lt;&lt; COM0B1);
     </p>
     <p class="clf">
      <!--<ccust1>4</ccust1>-->
      ❹ // PB4
     </p>
     <p class="cl">
      // Connect PWM signal to pin (OCR0B =&gt; PB4)
     </p>
     <p class="cl">
      TCCR1 |= (1 &lt;&lt; PWM1A)|(1 &lt;&lt; COM1A0);
     </p>
     <p class="cl">
      // Toggle PB4 when timer reaches OCR1B (target)
     </p>
     <p class="cl">
      GTCCR |= (1 &lt;&lt; COM1B0);
     </p>
     <p class="cl">
      // Clear PB4 when timer reaches OCR1C (top)
     </p>
     <p class="cl">
      GTCCR |= (1 &lt;&lt; PWM1B);
     </p>
     <p class="cl">
      // No prescaler
     </p>
     <p class="cl">
      TCCR1 |= (1 &lt;&lt; CS10);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t duty = 0;
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ for (duty = 1; duty &lt;100; duty++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR0A = duty;                   // PB0
     </p>
     <p class="cl">
      OCR0B = duty;                   // PB1
     </p>
     <p class="cl2">
      OCR1B = duty;                   // PB4
     </p>
     <p class="cl">
      delay_ms(10);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ for (duty = 100; duty &gt;0; --duty)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl2">
      OCR0A = duty;                   // PB0
     </p>
     <p class="cl">
      OCR0B = duty;                   // PB1
     </p>
     <p class="cl">
      OCR1B = duty;                   // PB4
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p157">
     </span>
     This code defines the function
     <code class="calibre23">
      initPWM()
     </code>
     . The function operates every pin at the same time, but we’ll go over how to initialize and operate each pin one by one.
    </p>
    <p class="calibre8">
     We first set the required pins, PORTB0, PORTB1, and PORTB4, to outputs
     <!--<ccust1>1</ccust1>-->
     ❶. Next, in turn we address the required three registers to enable PWM on PORTB0. To set the timer to fast PWM mode, we allocate the timer signal to pin PORTB0—note that we don’t use a prescaler, so the PWM can operate at its maximum frequency
     <!--<ccust1>2</ccust1>-->
     ❷. We only need to address one register to allow PWM over PORTB1
     <!--<ccust1>3</ccust1>-->
     ❸, but using PWM on PORTB4 requires a different timer, so we have to address different registers
     <!--<ccust1>4</ccust1>-->
     ❹.
    </p>
    <p class="calibre8">
     Now it’s time to assign values to the PWM pins to set their duty cycle. The microcontrollers require a value between 1 and 254, which maps out to a duty cycle of just over 0 to just under 100. (If you use 0, this is a 0 percent duty cycle—that is, the pin will be off. If you use 255, this is a 100 percent duty cycle, so the pin will be on continuously.)
    </p>
    <p class="calibre8">
     Three registers store the duty cycle value for our three PWM pins:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • OCR0A for PORTB0
     </li>
     <li class="bl">
      • OCR0B for PORTB1
     </li>
     <li class="bll">
      • OCR1B for PORTB4
     </li>
    </ul>
    <p class="calibre8">
     Next, we add a simple loop that causes the duty value to rise incrementally, increasing the brightness of the LEDs over time
     <!--<ccust1>5</ccust1>-->
     ❺. This process is then reversed by using another loop that decreases the brightness of the LEDs over time
     <!--<ccust1>6</ccust1>-->
     ❻.
    </p>
    <p class="calibre8">
     Experiment with adjusting the value in the
     <code class="calibre23">
      _delay_ms()
     </code>
     functions to alter the speed of the change in brightness. You may notice that there’s little to no difference in brightness between higher duty cycle values. That’s because during high-frequency PWM operations (anything faster than 50 cycles per second), the LED blinks too rapidly for the average human eye to perceive when it’s off.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0902">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0902">
     Individual PWM Pin Control for the ATtiny85
    </a>
   </h2>
   <p class="paft">
    Now that you’ve assembled and tested all the PWM pins using the ATtiny85, it’s time to learn how to use each PWM pin so you can apply them in your own projects.
   </p>
   <p class="calibre8">
    To activate all the PWM pins at once, simply use the
    <code class="calibre23">
     initPWM()
    </code>
    function as used in
    <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
     Project 31
    </a>
    . (You’ll learn how to deactivate them all later on.) To activate and deactivate each pin individually, follow the instructions in this list:
   </p>
   <div class="list">
    <p class="ulh">
     Activating PWM on ATtiny85 pin PORTB0
    </p>
    <ul class="calibre10">
     <li class="ul">
      To activate PWM on PORTB0, use the following:
      <pre>
       <p class="cl3f">
        DDRB |= (1 &lt;&lt; PORTB0);                 // Set PB0 as output
       </p>
       <p class="cl">
        TCCR0A |= (1 &lt;&lt; WGM01)|(1 &lt;&lt; WGM00);   // Set timer mode to FAST PWM
       </p>
       <p class="cl">
        <span id="p158">
        </span>
        // Connect PWM signal to pin (OC0A =&gt; PB0)
       </p>
       <p class="cl">
        TCCR0A |= (1 &lt;&lt; COM0A1);
       </p>
       <p class="cl3l">
        TCCR0B |= (1 &lt;&lt; CS00);                 // No prescaler
       </p>
      </pre>
      <p class="pcust1">
       You can then set the duty cycle by allocating a value between 1 and 254 inclusive to the OCR0A register.
      </p>
     </li>
     <li class="ulh1">
      Activating PWM on ATtiny85 pin PORTB1
     </li>
     <li class="ul">
      To activate PWM on PORTB1, use the following:
      <pre>
       <p class="cl3f">
        DDRB |= (1 &lt;&lt; PORTB1);                 // Set PB1 as output
       </p>
       <p class="cl">
        TCCR0A |= (1 &lt;&lt; WGM01)|(1 &lt;&lt; WGM00);   // Set timer mode to FAST PWM
       </p>
       <p class="cl">
        // Connect PWM signal to pin (OC0B =&gt; PB1)
       </p>
       <p class="cl">
        TCCR0A |= (1 &lt;&lt; COM0B1);
       </p>
       <p class="cl3l">
        TCCR0B |= (1 &lt;&lt; CS00);                 // No prescaler
       </p>
      </pre>
      <p class="pcust1">
       You can then set the duty cycle by allocating a value between 1 and 254 to the OCR0B register.
      </p>
     </li>
     <li class="ulh1">
      Activating PWM on ATtiny85 pin PORTB4
     </li>
     <li class="ul">
      To activate PWM on PORTB4, use the following:
      <pre>
       <p class="cl3f">
        DDRB |= (1 &lt;&lt; PORTB4);                 // Set PB4 as output
       </p>
       <p class="cl">
        // Connect PWM signal to pin (OCR0B =&gt; PB4)
       </p>
       <p class="cl">
        TCCR1 |= (1 &lt;&lt; PWM1A)|(1 &lt;&lt; COM1A0);
       </p>
       <p class="cl">
        // Toggle PB4 when timer reaches OCR1B (target)
       </p>
       <p class="cl">
        GTCCR |= (1 &lt;&lt; COM1B0);
       </p>
       <p class="cl">
        // Clear PB4 when timer reaches OCR1C (top)
       </p>
       <p class="cl">
        GTCCR |= (1 &lt;&lt; PWM1B);
       </p>
       <p class="cl3l">
        TCCR1 |= (1 &lt;&lt; CS10);                  // No prescaler
       </p>
      </pre>
      <p class="pcust1">
       You can then set the duty cycle by allocating a value between 1 and 254 to the OCR1B register.
      </p>
     </li>
     <li class="ulh1">
      Deactivating ATtiny85 PWM
     </li>
     <li class="ul">
      If your project needs to use a pin for both PWM and output on or off, then you must deactivate PWM mode before using
      <code class="calibre23">
       PORT
      </code>
      <code class="i1">
       x
      </code>
      <code class="calibre23">
       |=
      </code>
      commands. You’ll need to define
      <code class="calibre23">
       initPWM()
      </code>
      and
      <code class="calibre23">
       disablePWM()
      </code>
      functions to switch PWM on and off when required. Use the following code to disable PWM for all the pins (PORTB0, PORTB1, and PORTB4):
      <pre>
       <p class="cl3f">
        TCCR0A &amp;= ~(1 &lt;&lt; WGM01)&amp;~(1 &lt;&lt; WGM00); // Turn off fast PWM for PORTB0/1
       </p>
       <p class="cl">
        TCCR0A &amp;= ~(1 &lt;&lt; COM0A1);              // Disconnect PWM from PORTB0
       </p>
       <p class="cl">
        TCCR0A &amp;= ~(1 &lt;&lt; COM0B1);              // Disconnect PWM from PORTB1
       </p>
       <p class="cl">
        TCCR1 &amp;= ~(1 &lt;&lt; PWM1A)&amp;~(1 &lt;&lt; COM1A0); // Turn off PWM for PORTB4
       </p>
       <p class="cl">
        // Disconnect PWM from PORTB4 off timer/counter
       </p>
       <p class="cl">
        TCCR1 &amp;= ~(1 &lt;&lt; CS10);
       </p>
       <p class="cl">
        GTCCR &amp;= ~(1 &lt;&lt; PWM1B);                // Disable PWM for PORTB4
       </p>
       <p class="cl3l">
        GTCCR &amp;= ~(1 &lt;&lt; COM1B0);               // Disconnect PWM from PORTB4
       </p>
      </pre>
     </li>
    </ul>
   </div>
   <p class="calibre8">
    <span id="p159">
    </span>
    In general, it’s a good idea to keep these lines of code required to set up PWM in their own function, as in
    <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
     Project 31
    </a>
    . Now that we’ve reviewed the ins and outs of PWM on the ATtiny85, let’s have some fun making noise with a piezo element.
   </p>
   <p class="hd" id="pro32">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro32">
     <span class="ccust1">
      Project 32: Experimenting with Piezo and PWM
     </span>
    </a>
   </p>
   <p class="paft">
    A
    <i class="calibre5">
     piezo element
    </i>
    is a device that converts an electrical charge into a different form of energy. It can convert electrical energy into physical movement in the form of vibration, which generates sound waves that you can hear. By applying an electrical current and varying it using PWM, you can change the piezo’s tone. For this project you can use a small, prewired piezo like the one shown in
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07003">
     Figure 7-3
    </a>
    .
   </p>
   <div class="figure" id="f07003">
    <p class="fig">
     <img alt="A prewired piezo element used for making sounds or sensing vibrations" height="959" src="images/nsp-boxall502581-f07003.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 7-3:
      </span>
      A prewired 27 mm piezo element
     </p>
    </div>
   </div>
   <p class="calibre8">
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07004">
     Figure 7-4
    </a>
    shows the schematic symbol for our piezo element.
   </p>
   <div class="figure" id="f07004">
    <p class="fig">
     <img alt="Schematic symbol for a piezo element" height="409" src="images/nsp-boxall502581-f07004.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 7-4:
      </span>
      Schematic symbol for piezo element
     </p>
    </div>
   </div>
   <p class="calibre8">
    In this project, you’ll learn to change the pitch of sound from a piezo element by adjusting a trimpot. We’ll use an ADC to read the trimpot value, then use that value to determine the duty cycle for PWM control of the piezo element.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0903">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0903">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      <span id="p160">
      </span>
      • ATtiny85 microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Prewired piezo
     </li>
     <li class="bll">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      breadboard-compatible linear trimpot
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0017.xhtml#f07005">
      Figure 7-5
     </a>
     .
    </p>
    <div class="figure" id="f07005">
     <p class="fig">
      <img alt="Schematic diagram for Project 32" height="594" src="images/nsp-boxall502581-f07005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 7-5:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0017.xhtml#pro32">
        Project 32
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard in the same way you have for previous projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0904">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0904">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 32
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 7
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once the code has been uploaded to the microcontroller, slowly turn the trimpot in different directions, altering the piezo’s tone.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0017.xhtml#pro32">
      Project 32
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 32 - Experimenting with Piezo and PWM
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void startADC()
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; ADLAR)|(1 &lt;&lt; MUX1);
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN)|(1 &lt;&lt; ADPS1)|(1 &lt;&lt; ADPS0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB |= (1 &lt;&lt; PORTB0);            // Set PB0 as output
     </p>
     <p class="cl">
      <span id="p161">
      </span>
      TCCR0A |= (1 &lt;&lt; WGM01)|(1 &lt;&lt; WGM00);
     </p>
     <p class="cl">
      TCCR0A |= (1 &lt;&lt; COM0A1);
     </p>
     <p class="cl">
      TCCR0B |= (1 &lt;&lt; CS00);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ startADC();
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ initPWM();
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait until conversion completes
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="clf">
      <!--<ccust1>6</ccust1>-->
      ❻ OCR0A = ADCH;                  // Set PWM duty cycle with ADC value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code recalls that from
     <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
      Project 31
     </a>
     and the other PWM examples in this chapter. It accomplishes its goal of setting the duty cycle, as the code takes the 8-bit value of the ADC register and places it in the PWM register OCR0A.
    </p>
    <p class="calibre8">
     The code initializes the ADC and uses pin PORTB4 for the input
     <!--<ccust1>1</ccust1>-->
     ❶. It then initializes the PWM output on PB0
     <!--<ccust1>2</ccust1>-->
     ❷, as in
     <a class="url" href="nsp-boxall502581-0017.xhtml#pro31">
      Project 31
     </a>
     , starts the ADC
     <!--<ccust1>3</ccust1>-->
     ❸, and initializes the PWM
     <!--<ccust1>4</ccust1>-->
     ❹. Next, it reads the analog input
     <!--<ccust1>5</ccust1>-->
     ❺ and then finally assigns the ADC value (which falls between 0 and 255) to the PWM duty cycle register, thereby driving the piezo
     <!--<ccust1>6</ccust1>-->
     ❻.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0903">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0903">
     Individual PWM Pin Control for the ATmega328P-PU
    </a>
   </h2>
   <p class="paft">
    Now it’s time to move on to the PWM functions available for the ATmega328P-PU.
    <a class="url" href="nsp-boxall502581-0017.xhtml#tab0701">
     Table 7-1
    </a>
    lists the six ATmega328P-PU pins that can be used with PWM.
   </p>
   <table id="tab0701" class="calibre13">
    <thead class="calibre14">
     <tr class="calibre15">
      <th colspan="3" class="calibre16">
       <p class="th1">
        <span class="calibre4">
         Table 7-1
        </span>
        : ATmega328P-PU PWM Pins
       </p>
      </th>
     </tr>
     <tr class="calibre15">
      <th scope="col" class="calibre16">
       <p class="tch">
        Port register bit
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Physical pin
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Duty cycle register
       </p>
      </th>
     </tr>
    </thead>
    <tbody class="calibre17">
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTB1
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        15
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR1A
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTB2
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        16
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR1B
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTB3
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        17
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR2A
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTD3
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        5
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR2B
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTD5
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        11
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR0B
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        PORTD6
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        12
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        OCR0A
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="calibre8">
    Let’s go over how to activate (and deactivate) these pins for use with PWM.
   </p>
   <div class="list">
    <p class="ulh">
     <span id="p162">
     </span>
     Activating PWM on ATmega328P-PU pins PORTD5/6
    </p>
    <ul class="calibre10">
     <li class="ul">
      To activate PWM on PORTD5/6, use the following:
      <pre>
       <p class="cl3f">
        TCCR0A |= (1 &lt;&lt; WGM01)|(1 &lt;&lt; WGM00);
       </p>
       <p class="cl3l">
        TCCR0B |= (1 &lt;&lt; CS01);
       </p>
      </pre>
      <p class="pcust1">
       You can then connect the PWM output to pins PORTD5/6 with:
      </p>
      <pre>
       <p class="cl3f">
        TCCR0A |= (1 &lt;&lt; COM0A1);        // PWM to OCR0A - PD6
       </p>
       <p class="cl3l">
        TCCR0A |= (1 &lt;&lt; COM0B1);        // PWM to OCR0B - PD5
       </p>
      </pre>
      <p class="pcust1">
       Set the duty cycle by allocating a value between 1 and 254 to the duty cycle registers. If you want to control the pins directly, to use them as regular inputs or outputs, you will need to disconnect them from the PWM output. You can do this as follows:
      </p>
      <pre>
       <p class="cl3f">
        TCCR0A &amp;= ~(1 &lt;&lt; COM0A1);       // Disconnect PWM from OCR0A - PD6
       </p>
       <p class="cl">
        TCCR0A &amp;= ~(1 &lt;&lt; COM0B1);       // Disconnect PWM from OCR0B - PD5
       </p>
      </pre>
     </li>
    </ul>
   </div>
   <div class="list">
    <p class="ulh">
     Activating PWM on ATmega328P-PU pins PORTB1/2
    </p>
    <ul class="calibre10">
     <li class="ul">
      To activate PWM on PORTB1/2, use the following:
      <pre>
       <p class="cl3f">
        TCCR1A |= (1 &lt;&lt; WGM10);
       </p>
       <p class="cl">
        TCCR1B |= (1 &lt;&lt; WGM12);
       </p>
       <p class="cl3l">
        TCCR1B |= (1 &lt;&lt; CS11);
       </p>
      </pre>
      <p class="pcust1">
       You can then connect the PWM output to pins PORTB1/2 with:
      </p>
      <pre>
       <p class="cl3f">
        TCCR1A |= (1 &lt;&lt; COM1A1);        // PWM to OCR1A - PB1
       </p>
       <p class="cl3l">
        TCCR1A |= (1 &lt;&lt; COM1B1);        // PWM to OCR1B - PB2
       </p>
      </pre>
      <p class="pcust1">
       To disconnect the pins from PWM, use the following:
      </p>
      <pre>
       <p class="cl3f">
        TCCR1A &amp;= ~(1 &lt;&lt; COM1A1);       // Disconnect PWM from OCR1A - PB1
       </p>
       <p class="cl">
        TCCR1A &amp;= ~(1 &lt;&lt; COM1B1);       // Disconnect PWM from OCR1B - PB2
       </p>
      </pre>
     </li>
    </ul>
   </div>
   <div class="list">
    <p class="ulh">
     Activating PWM on ATmega328P-PU pins PORTB3 and PORTD3
    </p>
    <ul class="calibre10">
     <li class="ul">
      To activate PWM on PORTB3 and PORTD3, use the following:
      <pre>
       <p class="cl3f">
        TCCR2A |= (1 &lt;&lt; WGM20);
       </p>
       <p class="cl">
        TCCR2A |= (1 &lt;&lt; WGM21);
       </p>
       <p class="cl3l">
        TCCR2B |= (1 &lt;&lt; CS21);
       </p>
      </pre>
      <p class="pcust1">
       You can then connect the PWM output to pins PORTB3 and PORTD3 like so:
      </p>
      <pre>
       <p class="cl3f">
        TCCR2A |= (1 &lt;&lt; COM2A1);        // PWM to OCR2A - PB3
       </p>
       <p class="cl3l">
        TCCR2A |= (1 &lt;&lt; COM2B1);        // PWM to OCR2B - PD3
       </p>
      </pre>
      <p class="pcust1">
       To disconnect the pins from PWM, use the following:
      </p>
      <pre>
       <p class="cl3f">
        <span id="p163">
        </span>
        TCCR2A &amp;= ~(1 &lt;&lt; COM2A1);       // Disconnect PWM from OCR2A - PB3
       </p>
       <p class="cl3l">
        TCCR2A &amp;= ~(1 &lt;&lt; COM2B1);       // Disconnect PWM from OCR2B - PD3
       </p>
      </pre>
     </li>
    </ul>
   </div>
   <p class="calibre8">
    Remember that you can connect and disconnect pins from PWM when required only if you’ve run the activation code first.
   </p>
   <p class="calibre8">
    You’ve already seen a few ways to use PWM in this chapter, and next I’ll give you one more example: generating colors using RGB LEDs.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0904">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0904">
     The RGB LED
    </a>
   </h2>
   <p class="paft">
    An RGB LED is simply three LED elements—one red, one green, one blue—in a single enclosure, as shown in
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07006">
     Figure 7-6
    </a>
    . These LEDs are great for saving space, and you can also use them to create your own colors by changing the brightness of the individual elements. RGB LEDs are available in many sizes; one common option is 10 mm in diameter.
   </p>
   <div class="figure" id="f07006">
    <p class="fig">
     <img alt="A red, green, and blue light-emitting diode" height="1200" src="images/nsp-boxall502581-f07006.jpg" width="1057" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 7-6:
      </span>
      Typical RGB LED
     </p>
    </div>
   </div>
   <p class="calibre8">
    As you can see, RGB LEDs have four legs. As with the single-color LEDs discussed in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    , there two types of these LEDs available:
    <i class="calibre5">
     common anode
    </i>
    and
    <i class="calibre5">
     common cathode
    </i>
    . In the common-anode configuration, all three LED anodes are connected, while the cathodes are separate. The common-cathode configuration has three separate anodes, with all three cathodes connected.
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07007">
     Figure 7-7
    </a>
    shows the schematics for both.
   </p>
   <div class="figure" id="f07007">
    <p class="fig">
     <img alt="Schematic symbols for the two types of RGB LEDs" height="806" src="images/nsp-boxall502581-f07007.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 7-7:
      </span>
      Schematic symbols for RGB LEDs: common anode (left) and common cathode (right)
     </p>
    </div>
   </div>
   <p class="calibre8">
    The pinouts for each LED unfortunately may vary, so check with your supplier. However, if you cannot find this information, the longest pin is usually the common anode or cathode pin. You can order clear (where the body of the LED is transparent) or diffused (with a clouded LED body) RGB LEDs. I recommend the latter, as diffused LEDs work better at blending their three primary color elements to make color combinations.
   </p>
   <p class="calibre8">
    <span id="p164">
    </span>
    For the projects in this book, starting with the next one, we’ll use common-cathode RGB LEDs.
   </p>
   <p class="hd" id="pro33">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro33">
     <span class="ccust1">
      Project 33: Experimenting with RGB LEDs and PWM
     </span>
    </a>
   </p>
   <p class="paft">
    This project allows you to generate various colors by mixing two of the three primary colors in an RGB LED with varying brightness caused by PWM. The diagram in
    <a class="url" href="nsp-boxall502581-0017.xhtml#f07008">
     Figure 7-8
    </a>
    shows which color combinations will result in a given hue.
   </p>
   <div class="figure" id="f07008">
    <p class="fig">
     <img alt="A chart showing the colors that result when primary colors are mixed" height="1111" src="images/nsp-boxall502581-f07008.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 7-8:
      </span>
      Results of mixing red, green, and blue in various combinations
     </p>
    </div>
   </div>
   <p class="calibre8">
    For example, mixing red and green light will create a yellow glow. By increasing the brightness of one color while decreasing the brightness of the other color, you can run through multiple shades of yellow. This project mixes only two colors, but you can mix three at once to create a white light if you wish in your own projects. You’ll use the ATmega328P-PU microcontroller for this project; it has many more pins than the ATtiny85, so you can use it to work with the RGB LED and still have pins left over for other purposes.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0905">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0905">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • One diffused common-cathode RGB LED
     </li>
     <li class="bll">
      • Three 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     <span id="p165">
     </span>
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0017.xhtml#f07009">
      Figure 7-9
     </a>
     .
    </p>
    <div class="figure" id="f07009">
     <p class="fig">
      <img alt="Schematic diagram for Project 33" height="1200" src="images/nsp-boxall502581-f07009.jpg" width="1115" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 7-9:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0017.xhtml#pro33">
        Project 33
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 33
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 7
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you’ve uploaded the code to the microcontroller, your RGB LED should begin to glow with constantly changing colors. (If your LED has a clear body, you can easily diffuse the output for a better effect by placing some white paper over the LED.)
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0017.xhtml#pro33">
      Project 33
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 33 - Experimenting with RGB LEDs and PWM
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ #define wait 10
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Timers 1A and 1B
     </p>
     <p class="cl">
      <span id="p166">
      </span>
      TCCR1A |= (1 &lt;&lt; WGM10);  // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12);  // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; CS11);
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1A1); // PWM to OCR1A - PB1
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1B1); // PWM to OCR1B - PB2
     </p>
     <p class="clf">
      // Timer 2
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; WGM20);  // Fast PWM mode
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; WGM21);  // Fast PWM mode
     </p>
     <p class="cl">
      TCCR2B |= (1 &lt;&lt; CS21);
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; COM2A1); // PWM to OCR2A - PB3
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void PWMblue(uint8_t duty)
     </p>
     <p class="cl">
      // Blue LED is on PB1
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1A = duty;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void PWMred(uint8_t duty)
     </p>
     <p class="cl">
      // Red LED is on PB3
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR2A = duty;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>5</ccust1>-->
      ❺ void PWMgreen(uint8_t duty)
     </p>
     <p class="cl">
      // Green LED is on PB2
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1B = duty;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set PORTB1, PORTB2, and PORTB3 as outputs
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ DDRB |= (1 &lt;&lt; PORTB1)|(1 &lt;&lt; PORTB2)|(1 &lt;&lt; PORTB3);
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="cl">
      uint8_t a;
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Red to green
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ for (a=1; a&lt;255; a++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PWMred(255-a);
     </p>
     <p class="cl">
      PWMgreen(a);
     </p>
     <p class="cl">
      _delay_ms(wait);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      // Green to blue
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ for (a=1; a&lt;255; a++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PWMgreen(255-a);
     </p>
     <p class="cl">
      PWMblue(a);
     </p>
     <p class="cl">
      _delay_ms(wait);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p167">
      </span>
      // Blue to red
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ for (a=1; a&lt;255; a++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PWMblue(255-a);
     </p>
     <p class="cl">
      PWMred(a);
     </p>
     <p class="cl">
      _delay_ms(wait);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     We begin with our usual
     <code class="calibre23">
      initPWM()
     </code>
     function, which sets up the PORTB1, PORTB2, and PORTB3 pins as PWM outputs
     <!--<ccust1>2</ccust1>-->
     ❷. This is followed by three simple functions, one for each LED
     <!--<ccust1>3</ccust1><ccust1>4</ccust1><ccust1>5</ccust1>-->
     ❸❹❺, that pass on the required duty cycle, to make controlling each of the primary colors in the LED easy when required.
    </p>
    <p class="calibre8">
     The main code sets up PORTB1, PORTB2, and PORTB3 as output pins, then initializes the PWM outputs
     <!--<ccust1>6</ccust1>-->
     ❻. Finally, to mix the colors we use the three functions we defined to mix two of the LED colors by starting one color at a high level of brightness with the other color at a low level, then gradually decreasing and increasing the levels of the two colors, respectively
     <!--<ccust1>7</ccust1><ccust1>8</ccust1><ccust1>9</ccust1>-->
     ❼❽❾. You can adjust the speed of the color transition by changing the value of
     <code class="calibre23">
      wait
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶.
    </p>
    <p class="calibre8">
     I hope you found making sound effects with the piezo element and light effects with the RGB LED enjoyable. You’re just getting started: there are many more uses for PWM, including controlling motors for robotics and electric fans, as well as learning how to use MOSFETs to controller larger currents. We’ll explore all of these in the
     <a class="url" href="nsp-boxall502581-0018.xhtml#ch08">
      next chapter
     </a>
     .
    </p>
   </div>
  </div>
 </div>
</div></body></html>