- en: '19'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REFACTORING YOUR CODE
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding chapter, you built a VM with a running SQL server using nothing
    besides an existing hypervisor, an operating system ISO file, and a little bit
    of code. Doing so meant linking together many of the functions you created in
    the previous chapters. Here, you’ll do something different: instead of adding
    new functionality to your PowerLab module, you’ll dig into your code and see if
    you can make your module a little more modular.'
  prefs: []
  type: TYPE_NORMAL
- en: When I say *modular*, I’m talking about separating the functionality of the
    code into reusable functions that can handle many situations. The more modular
    the code, the more generally applicable it will be. And the more generally applicable
    your code, the more useful it will be. With modular code, you can reuse functions
    such as `New-PowerLabVM` or `Install-PowerLabOperatingSystem` to install many
    kinds of servers (which you’ll see in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: A Second Look at New-PowerLabSqlServer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You created two main functions in [Chapter 18](ch18.xhtml#ch18): `New-PowerLabSqlServer`
    and `Install-PowerLabSqlServer`. You did so with the goal of setting up an SQL
    server. But what if you want to make your functions more generally applicable?
    After all, different servers share a lot of components with SQL ones: virtual
    machine, virtual disk, Windows OS, and so forth. You could simply copy the function
    you have and swap out all the specific SQL references for references to the server
    type you want.'
  prefs: []
  type: TYPE_NORMAL
- en: But I’m going to have to advise against this. There’s no need for all that extra
    code. Instead, you’ll simply refactor your existing code. *Refactoring* refers
    to the process of changing a code’s insides without changing its functionality;
    in other words, refactoring is something for you, the programmer. It helps code
    be more readable, and it makes sure that you can keep growing your project without
    running into too many headache-inducing organizational issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by taking a look at that `New-PowerLabSqlServer` function you created,
    shown in [Listing 19-1](ch19.xhtml#ch19list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-1: `New-PowerLabSqlServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: How would you go about refactoring this code? Well for starters, you know that
    every server needs a virtual machine, a virtual disk, and an operating system;
    you handle these needs in the code block between ❸ and ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at this code, though, you’ll see that you can’t just pull it out
    and paste it into a new function. Parameters are defined in the `New-PowerLabSqlServer`
    function ❶ that you use in those lines. Notice that the only parameter that’s
    specific to SQL here is `AnswerFilePath` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve identified the code that isn’t SQL specific, let’s pull it out
    and use it to create the new function `New-PowerLabServer` ([Listing 19-2](ch19.xhtml#ch19list2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-2: A more generic `New-PowerLabServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you have a general server-provisioning function, but no way
    to indicate the kind of server you’re creating. Let’s fix that by using another
    parameter called `ServerType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice the new `ValidateSet` parameter. I’ll give an in-depth explanation of
    what this does later in the chapter; for now, you just need to know that this
    ensures that the user can pass in only a server type contained within this set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have this parameter, let’s use it. Insert a `switch` statement
    at the end of the function to execute different code depending on which server
    type the user enters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you handle the three types of server input (and use the `default`
    case to handle any exceptions ❶). But there’s a problem. To fill out the SQL code,
    you copied and pasted code from the `New-PowerLabSqlServer` function, and now
    you’re using something you don’t have: the `AnswerFilePath` variable. Recall that
    when you moved your generic code to a new function, you left this variable behind,
    meaning that you can’t use it here . . . or can you?'
  prefs: []
  type: TYPE_NORMAL
- en: Using Parameter Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In situations like the preceding one, when you have one parameter that determines
    which other parameter you need, PowerShell has a handy feature called *parameter
    sets*. You can think of parameter sets as letting you use conditional logic to
    control which parameters a user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you’ll use three parameter sets: a set for provisioning SQL
    servers, a set for provisioning web servers, and a default set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define parameter sets by using the `ParameterSetName` attribute followed
    by a name. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you haven’t assigned `ServerType` a parameter set. Parameters that
    are not part of a parameter set can be used with any set. Because of this, you
    can use `ServerType` with either `AnswerFilePath` or the newly created parameter
    you’ll be using for web server provisioning: `CreateDefaultWebsite`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see here that the majority of the parameters stay the same, but you
    add a final one based on what you pass in for `ServerType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to mix and match, and use parameters from two different parameter
    sets at the same time, you’ll fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What would happen if you did the opposite and used neither the `NoDefaultWebsite`
    parameter nor the `AnswerFilePath` parameter?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You get the same error about not being able to resolve the parameter set as
    before. Why? PowerShell doesn’t know which parameter set to use! Earlier, I said
    you’d be using three sets, but you defined only two. You need to set a default
    parameter set. As you saw earlier, parameters that are not explicitly assigned
    to a parameter set can be used in conjunction with any in a set. However, if you
    do define a default parameter set, PowerShell will use those parameters if no
    parameters in any set are being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for your default set, you could pick the defined SQL or web parameter set
    to be your default, or you could simply define a nonspecific parameter set like
    `blah blah`, which would create an inherent set for all parameters that do not
    have an explicit set defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to set a defined parameter set as default, you can set it
    to anything, and PowerShell will ignore both parameter sets *if no parameter in
    a parameter set is used*. This is what you need to do in this case; it’s perfectly
    okay to not use a defined parameter set because you have the `ServerType` parameter
    to indicate whether or not you’re going to deploy a web server or SQL server.
  prefs: []
  type: TYPE_NORMAL
- en: With your new parameter sets, the parameter portion of `New-PowerLabServer`
    looks like [Listing 19-3](ch19.xhtml#ch19list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-3: The new `New-PowerLabServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you have a reference to the function `Install-PowerLabSqlServer`.
    This looks similar to the function (`New-PowerLabSqlServer`) that got us into
    this mess. Instead of creating the virtual machine and installing the operating
    system, `Install-PowerLabSqlServer` takes over from `New-PowerLabServer`, installs
    the SQL server software, and performs basic configuration. You might be inclined
    to perform this same round of refactoring on this function. You could do this,
    but as soon as you look at the code that’s inside `Install-PowerLabSqlServer`,
    you’ll soon realize there are nearly no commonalities between the installation
    phase of SQL server and that of other types of servers. It’s a unique process
    and would be hard to “genericize” for other server deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, now that the code is nice and refactored, you’re left with a function
    capable of . . . provisioning a SQL server. So back where you started, right?
    I hope not! Even though you haven’t changed anything about the functionality of
    the code, you’ve built the foundation you need to easily insert the code for creating
    a web server (which you’ll do in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in this chapter, refactoring PowerShell code isn’t a cut-and-dried
    process. Knowing the ways you can refactor your code, and which of those ways
    is the best for your present situation, is a skill that comes with experience.
    But as long as you keep what programmers call *the DRY principle* (don’t repeat
    yourself) in mind, you’ll be on the right path. More than anything, abiding by
    DRY means avoiding duplicate code and redundant functionality. You saw this in
    this chapter when you chose to create a general function that created new servers,
    as opposed to another `New-PowerLab`InsertServerTypeHere`Server` function.
  prefs: []
  type: TYPE_NORMAL
- en: Your hard work wasn’t for nothing. In the next chapter, you’ll get back to automating,
    adding the code you need to create IIS web servers.
  prefs: []
  type: TYPE_NORMAL
