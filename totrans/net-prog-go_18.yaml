- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Moving to the Cloud
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到云端
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In August of 2006, Amazon Web Services (AWS) brought public cloud infrastructure
    to the mainstream when it introduced its virtual computer, Elastic Compute Cloud
    (EC2). EC2 removed barriers to providing services over the internet; you no longer
    needed to purchase servers and software licenses, sign support contracts, rent
    office space, or hire IT professionals to maintain your infrastructure. Instead,
    you paid AWS as needed for the use of EC2 instances, allowing you to scale your
    business while AWS handled the maintenance, redundancy, and standards compliance
    details for you. In the following years, both Google and Microsoft released public
    cloud offerings to compete with AWS. Now all three cloud providers offer comprehensive
    services that cover everything from analytics to storage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年8月，Amazon Web Services (AWS)推出了Elastic Compute Cloud（EC2），为公共云基础设施的普及做出了贡献。EC2消除了通过互联网提供服务的障碍；你不再需要购买服务器和软件许可证、签署支持合同、租赁办公空间或雇佣IT专业人员来维护基础设施。相反，你按需支付AWS使用EC2实例的费用，允许你在AWS处理维护、冗余和标准合规等细节的同时，扩展你的业务。在接下来的几年里，Google和Microsoft也推出了与AWS竞争的公共云服务。现在，三大云服务提供商都提供全面的服务，涵盖从分析到存储的所有内容。
- en: The goal of this chapter is to give you an apples-to-apples comparison of Amazon
    Web Services, Google Cloud, and Microsoft Azure. You’ll create and deploy an application
    to illustrate the differences in each provider’s tooling, authentication, and
    deployment experience. Your application will follow the *platform-as-a-service
    (PaaS)* model, in which you create the application and deploy it on the cloud
    provider’s platform. Specifically, you’ll create a function and deploy it to AWS
    Lambda, Google Cloud Functions, and Microsoft Azure Functions. We’ll stick to
    the command line as much as possible to keep the comparisons relative and introduce
    you to each provider’s tooling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是为你提供Amazon Web Services、Google Cloud和Microsoft Azure的对比，让你能够一目了然地了解各自的不同。你将创建并部署一个应用程序，展示每个提供商的工具、认证和部署体验的差异。你的应用程序将遵循*平台即服务
    (PaaS)* 模式，在云服务商的平台上创建并部署应用程序。具体来说，你将创建一个函数并将其部署到AWS Lambda、Google Cloud Functions和Microsoft
    Azure Functions。我们将尽量使用命令行，以便保持对比的公平，并让你了解每个提供商的工具。
- en: All three service providers offer a trial period, so you shouldn’t incur any
    costs. If you’ve exhausted your trial, please keep potential costs in mind as
    you work through the following sections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 三大服务提供商都提供试用期，因此你不应产生任何费用。如果你已用完试用期，请在继续执行后续步骤时注意可能的费用。
- en: You’ll create a simple function that retrieves the URL of the latest XKCD comic,
    or optionally the previous comic. This will demonstrate how to retrieve data from
    within the function to fulfill the client’s request and persist function state
    between executions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个简单的功能，获取最新XKCD漫画的URL，或者选择获取前一篇漫画。这将演示如何从函数内检索数据，以满足客户端请求，并在执行之间持久化函数状态。
- en: By the end of this chapter, you should feel comfortable writing an application,
    deploying it, and testing it to leverage the PaaS offerings of AWS, Google Cloud,
    and Microsoft Azure. You should have a better idea of which provider’s workflow
    best fits your use case if you choose to make the jump to the cloud.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够自如地编写应用程序、部署应用程序，并测试它以利用AWS、Google Cloud和Microsoft Azure的PaaS服务。如果你选择迁移到云平台，你应该更清楚地了解哪个提供商的工作流最适合你的使用案例。
- en: Laying Some Groundwork
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打好基础
- en: The XKCD website offers a Real Simple Syndication (RSS) feed at [https://xkcd.com/rss.xml](https://xkcd.com/rss.xml).
    As its file extension indicates, the feed uses XML. You can use Go’s *encoding/xml*
    package to parse the feed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: XKCD网站提供一个Real Simple Syndication (RSS)源，地址为[https://xkcd.com/rss.xml](https://xkcd.com/rss.xml)。正如文件扩展名所示，源使用XML格式。你可以使用Go的*encoding/xml*包来解析这个源。
- en: Before you deploy a function to the cloud that can retrieve the URL of the latest
    XKCD comic, you need to write some code that will allow you to make sense of the
    RSS feed. [Listing 14-1](#listing14-1) creates two types for parsing the feed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在将可以获取最新XKCD漫画URL的功能部署到云端之前，你需要编写一些代码来解析RSS源。[列表14-1](#listing14-1)创建了两种类型来解析该源。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 14-1: Structure that represents the XKCD RSS feed (*feed/rss.go*)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-1：表示XKCD RSS源的结构（*feed/rss.go*）
- en: The `RSS` struct represents the RSS feed, and the `Item` struct represents each
    item (comic) in the feed. Like Go’s *encoding/json* package you used in earlier
    chapters, its *encoding/xml* package can use struct tags to map XML tags to their
    corresponding struct fields. For example, the `Published` field’s tag 1 instructs
    the *encoding/xml* package to assign it the item’s `pubDate` value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSS` 结构体表示RSS订阅源，而`Item` 结构体表示订阅源中的每个项（漫画）。与你在早期章节中使用的Go的*encoding/json*包一样，它的*encoding/xml*包可以使用结构体标签将XML标签映射到相应的结构体字段。例如，`Published`字段的标签指示*encoding/xml*包将其赋值为项的`pubDate`值。'
- en: It’s important to be a good internet neighbor and keep track of the feed’s entity
    tag 2. Web servers often derive entity tags for content that may not change from
    one request to another. Clients can track these entity tags and present them with
    future requests. If the server determines that the requested content has the same
    entity tag, it can forgo returning the entire payload and return a 304 Not Modified
    status code so the client knows to use its cached copy instead. You’ll use this
    value in [Listing 14-2](#listing14-2) to conditionally update the `RSS` struct
    when the feed changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个好的互联网邻居并跟踪订阅源的实体标签非常重要。Web服务器通常为可能不发生变化的内容推导实体标签。客户端可以跟踪这些实体标签，并在以后的请求中提供它们。如果服务器确定请求的内容具有相同的实体标签，它可以避免返回整个负载，并返回304
    Not Modified状态码，这样客户端就知道使用其缓存的副本。你将在[示例14-2](#listing14-2)中使用这个值，在订阅源更改时有条件地更新`RSS`
    结构体。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-2: Methods to parse the XKCD RSS feed and return a slice of items
    (*feed/rss.go*)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-2：解析XKCD RSS订阅源并返回项的切片（*feed/rss.go*）
- en: There are three things to note here. First, the `RSS` struct and its methods
    are not safe for concurrent use. This isn’t a concern for your use case, but it’s
    best that you’re aware of this fact. Second, the `Items` method returns a slice
    of the items in the `RSS` struct, which is empty until your code calls the `ParseURL`
    method to populate the `RSS` struct. Third, the `Items` method makes a copy of
    the `Items` slice 1 and returns the copy to prevent possible corruption of the
    original `Items` slice. This is also a bit of overkill for your use case, but
    it’s best to be aware that you’re returning a reference type that the receiver
    can modify. If the receiver modifies the copy, it won’t affect your original.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三点需要注意。首先，`RSS` 结构体及其方法不适合并发使用。虽然这对于你的用例来说并不成问题，但最好还是了解这一点。第二，`Items` 方法返回`RSS`
    结构体中项的切片，该切片在你的代码调用`ParseURL`方法填充`RSS` 结构体之前是空的。第三，`Items` 方法会复制`Items`切片，并返回该副本，以防止原始`Items`切片被破坏。这对于你的用例来说可能有点过度，但最好知道你返回的是一个可以被接收方修改的引用类型。如果接收方修改了副本，它不会影响原始的`Items`。
- en: Parsing the RSS feed is straightforward and should look familiar. The `ParseURL`
    method retrieves the RSS feed by using a `GET` call. If the feed is new, the method
    reads the XML from the response body and invokes the `xml.Unmarshal` function
    to populate the `RSS` struct with the XML in the server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解析RSS订阅源非常简单，应该看起来很熟悉。`ParseURL` 方法通过使用 `GET` 请求来检索RSS订阅源。如果订阅源是新的，该方法会从响应体中读取XML，并调用`xml.Unmarshal`函数将XML反序列化到`RSS`结构体中。
- en: Notice you conditionally set the request’s `ETag` header 2 so the XKCD server
    can determine whether it needs to send the feed contents or you currently have
    the latest version. If the server responds with a 304 Not Modified status code,
    the `RSS` struct remains unchanged. If you receive a 200 OK 3, you received a
    new version of the feed and unmarshal the response body’s XML into the `RSS` struct.
    If successful, you update the entity tag 4.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你条件性地设置了请求的`ETag`头部，以便XKCD服务器能够判断是否需要发送订阅源内容，还是你已经拥有最新版本。如果服务器响应304 Not
    Modified状态码，`RSS` 结构体保持不变。如果你收到200 OK响应，则表示你收到了订阅源的新版本，并将响应体中的XML反序列化到`RSS` 结构体中。如果成功，你将更新实体标签。
- en: With this logic in place, the `RSS` struct should update itself only if its
    entity tag is empty, as it would be on initialization of the struct, or if a new
    feed is available.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个逻辑下，`RSS` 结构体应当仅在其实体标签为空时更新自己，这在结构体初始化时会发生，或者当有新的订阅源时。
- en: 'The last task is to create a *go.mod* file by using the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个任务是使用以下命令创建*go.mod*文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These commands initialize a new module named *github.com/awoodbeck/gnp/ch14/feed*,
    which will be used by code later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令初始化一个名为*github.com/awoodbeck/gnp/ch14/feed*的新模块，代码将在本章后面使用。
- en: AWS Lambda
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: '*AWS Lambda* is a serverless platform that offers first-class support for Go.
    You can create Go applications, deploy them, and let Lambda handle the implementation
    details. It will scale your code to meet demand. Before you can get started with
    Lambda, please make sure you create a trial account at [https://aws.amazon.com/](https://aws.amazon.com/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*AWS Lambda* 是一个无服务器平台，提供对 Go 语言的优质支持。你可以创建 Go 应用程序，部署它们，并让 Lambda 处理实现细节。它将根据需求扩展你的代码。在开始使用
    Lambda 之前，请确保你在 [https://aws.amazon.com/](https://aws.amazon.com/) 创建了一个试用帐户。'
- en: Installing the AWS Command Line Interface
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 AWS 命令行界面
- en: AWS offers version 2 of its command line interface (CLI) tools for Windows,
    macOS, and Linux. You can find detailed instructions for installing them at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 为 Windows、macOS 和 Linux 提供版本 2 的命令行界面（CLI）工具。你可以在 [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html)
    找到详细的安装说明。
- en: 'Use the following commands to install the AWS CLI tools on Linux:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在 Linux 上安装 AWS CLI 工具：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Download the AWS CLI version 2 archive. Use `curl` to download the ZIP file
    from the command line. Then unzip the archive and use `sudo` to run the *./aws/install*
    executable. Once it’s complete, run `aws --version` to verify that the AWS binary
    is in your path and that you’re running version 2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 AWS CLI 版本 2 的压缩包。使用 `curl` 从命令行下载 ZIP 文件。然后解压该压缩包，并使用 `sudo` 运行 *./aws/install*
    可执行文件。完成后，运行 `aws --version` 以验证 AWS 二进制文件是否在你的路径中，并且你正在运行版本 2。
- en: Configuring the CLI
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 CLI
- en: Now that you have the AWS CLI installed, you need to configure it with credentials
    so it can interact with AWS on your account’s behalf. This section walks you through
    that process. If you get confused, review the AWS CLI configuration quick-start
    guide at [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经安装了 AWS CLI，你需要使用凭证对其进行配置，以便它可以代表你的账户与 AWS 交互。本节将指导你完成该过程。如果你感到困惑，可以参考
    AWS CLI 配置快速入门指南 [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html)。
- en: First, access the AWS Console at [https://console.aws.amazon.com](https://console.aws.amazon.com).
    Log into the AWS Console to access the drop-down menu shown in [Figure 14-1](#figure14-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问 AWS 控制台 [https://console.aws.amazon.com](https://console.aws.amazon.com)。登录
    AWS 控制台后，访问 [图 14-1](#figure14-1) 中显示的下拉菜单。
- en: '![f14001](image_fi/500884c14/f14001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f14001](image_fi/500884c14/f14001.png)'
- en: 'Figure 14-1: Accessing your AWS account security credentials'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：访问你的 AWS 账户安全凭证
- en: Click your account name in the upper-right corner of the AWS Console (**Personal**
    in [Figure 14-1](#figure14-1)). Then, select **My Security Credentials** from
    the drop-down menu. This link should take you to the Your Security Credentials
    page, shown in [Figure 14-2](#figure14-2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 AWS 控制台右上角的账户名称（**个人**，见 [图 14-1](#figure14-1)）。然后，从下拉菜单中选择 **我的安全凭证**。该链接应将你带到“你的安全凭证”页面，如
    [图 14-2](#figure14-2) 所示。
- en: '![f14002](image_fi/500884c14/f14002.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f14002](image_fi/500884c14/f14002.png)'
- en: 'Figure 14-2: Creating a new access key'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：创建新的访问密钥
- en: Select the **Access keys** section heading to expand the section. Then click
    the **Create New Access Key** button to create credentials to use on the command
    line. This will display the credentials ([Figure 14-3](#figure14-3)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **访问密钥** 部分标题以展开该部分。然后点击 **创建新访问密钥** 按钮，以创建可以在命令行中使用的凭证。这将显示凭证（[图 14-3](#figure14-3)）。
- en: '![f14003](image_fi/500884c14/f14003.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f14003](image_fi/500884c14/f14003.png)'
- en: 'Figure 14-3: Retrieving the new access Key ID and secret access key'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：检索新的访问密钥 ID 和秘密访问密钥
- en: 'You’ll need both the access Key ID and secret access key values to authenticate
    your commands on the command line with AWS. Make sure you download the key file
    and keep it in a secure place in case you need to retrieve it in the future. For
    now, you’ll use them to configure your AWS command line interface:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问密钥 ID 和秘密访问密钥来在命令行中使用 AWS 进行身份验证。确保下载密钥文件并将其保存在安全的位置，以备将来需要时使用。现在，你将使用它们来配置你的
    AWS 命令行界面：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the command line, invoke the `aws configure` command. You’ll be prompted
    to enter the access key ID and secret access key from [Figure 14-3](#figure14-3).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，调用 `aws configure` 命令。你将被提示输入 [图 14-3](#figure14-3) 中的访问密钥 ID 和秘密访问密钥。
- en: You can also specify a default region and the default output format. The *region*
    is the geographic endpoint for your services. In this example, I’m telling AWS
    I want my services to use the `us-east-2` endpoint by default, which is in Ohio.
    You can find a general list of regional endpoints at [https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定默认区域和默认输出格式。*区域*是你服务的地理终端。在这个例子中，我告诉 AWS 我希望我的服务默认使用 `us-east-2` 终端，这个终端位于俄亥俄州。你可以在
    [https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)
    找到一个区域终端的通用列表。
- en: Creating a Role
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建角色
- en: Your code requires a specific identity to run in AWS. This identity is called
    a *role*. You can have multiple roles under your AWS account and assign various
    permissions to each role. You can then assign roles to AWS services, which gives
    services permissions to access your resources without you having to assign credentials
    (such as your access key ID and secret access key) to each service. In this chapter,
    you’ll use a role to give AWS Lambda permission to access the Lambda function
    you’ll write.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码需要一个特定的身份在 AWS 中运行。这个身份叫做 *角色*。你可以在你的 AWS 账户下拥有多个角色，并为每个角色分配不同的权限。然后，你可以将角色分配给
    AWS 服务，这样服务就能访问你的资源，而不需要你为每个服务单独分配凭证（比如访问密钥 ID 和密钥访问密钥）。在本章中，你将使用角色来授予 AWS Lambda
    访问你将编写的 Lambda 函数的权限。
- en: For now, you’ll create just one role and give AWS Lambda permission to assume
    that role so it can invoke your code. [Listing 14-3](#listing14-3) details a simple
    trust policy document that assigns the proper access. The trust policy document
    outlines a set of permissions, which you’ll assign to a new role.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时，你将只创建一个角色，并授予 AWS Lambda 角色的权限，以便它能够调用你的代码。[清单 14-3](#listing14-3) 详细说明了一个简单的信任策略文档，该文档分配了适当的访问权限。信任策略文档列出了你将分配给新角色的一组权限。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 14-3: Defining a trust policy for your new role (*aws/trust-policy.json*)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-3：为你的新角色定义信任策略（*aws/trust-policy.json*）
- en: This trust policy tells AWS that you want to allow 2 the Lambda service 3 to
    assume the role 4. The trust policy version 1 is the current version of the trust
    policy language, not an arbitrary date.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信任策略告诉 AWS 你希望允许 Lambda 服务来承担该角色。信任策略版本 1 是当前信任策略语言的版本，而不是一个任意的日期。
- en: 'Next, create the role to which you’ll assign this trust policy:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建你将为其分配该信任策略的角色：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a new role with the AWS Identity and Access Management (IAM) service
    using the role name *lambda-xkcd* and the *aws/trust-policy.json* document you
    created in [Listing 14-3](#listing14-3). If successful, this creates a new role
    using your trust policy 2. IAM assigns the role an Amazon Resource Name (ARN).
    The ARN 1 is a unique identifier for this role that you’ll use when invoking your
    code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 身份与访问管理（IAM）服务创建一个新角色，角色名称为 *lambda-xkcd*，并使用你在 [清单 14-3](#listing14-3)
    中创建的 *aws/trust-policy.json* 文档。如果成功，这将使用你的信任策略 2 创建一个新角色。IAM 为该角色分配一个 Amazon
    资源名称（ARN）。ARN 1 是此角色的唯一标识符，你将在调用代码时使用它。
- en: Defining an AWS Lambda Function
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 AWS Lambda 函数
- en: 'AWS Lambda’s Go library gives you some flexibility when it comes to your Lambda
    function’s signature. Your function must conform to one of these formats:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 的 Go 库在 Lambda 函数签名方面为你提供了一些灵活性。你的函数必须符合以下其中一种格式：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`TypeIn` and `TypeOut` correspond to *encoding/json*-compatible types, in that
    JSON input sent to your Lambda function will be unmarshaled into `TypeIn`. Likewise,
    the `TypeOut` your function returns will be marshaled to JSON before reaching
    its destination. You’ll use the last function signature in this section.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeIn` 和 `TypeOut` 对应 *encoding/json* 兼容类型，发送到 Lambda 函数的 JSON 输入将被解码为 `TypeIn`。同样，函数返回的
    `TypeOut` 将在到达目标之前被编码为 JSON。你将使用本节中的最后一个函数签名。'
- en: The function you’ll write should give you a taste for what you can do with serverless
    environments. It will accept input from the client, retrieve resources over the
    internet, maintain its state between function calls, and respond to the client.
    If you’ve read Chapter 9, you know that you could write an `http.Handler` that
    performs these actions, but AWS Lambda requires a slightly different approach.
    You won’t work with an `http.Request` or an `http.ResponseWriter`. Instead, you’ll
    use types you create or import from other modules. AWS Lambda handles the decoding
    and encoding of the data to and from your function for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写的函数应该让你体验无服务器环境中能做什么。它将接受来自客户端的输入，通过互联网获取资源，保持在函数调用之间的状态，并响应客户端。如果你读过第9章，你知道你可以编写一个
    `http.Handler` 来执行这些操作，但 AWS Lambda 需要一种稍有不同的方法。你不会使用 `http.Request` 或 `http.ResponseWriter`。相反，你将使用自己创建的类型或从其他模块导入的类型。AWS
    Lambda 会为你处理数据的解码和编码，将数据传入和传出你的函数。
- en: Let’s get started writing your first bit of serverless code ([Listing 14-4](#listing14-4)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写你的第一段无服务器代码（[清单 14-4](#listing14-4)）。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 14-4: Creating persistent variables and request and response types
    (*aws/xkcd.go*)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-4：创建持久变量以及请求和响应类型 (*aws/xkcd.go*)
- en: You can specify variables at the package level that will persist between function
    calls while the function persists in memory. In this example, you define a feed
    object 1 and the URL of the RSS feed 2. Creating and populating a new `feed.RSS`
    object involves a bit of overhead. You can avoid that overhead on subsequent function
    calls if you store the object in a variable at the package level so it lives beyond
    each function call. This also allows you to take advantage of the entity tag support
    in `feed.RSS`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在包级别指定变量，这些变量会在函数调用之间保持持久性，同时函数本身在内存中保持存在。在这个示例中，你定义了一个 `feed` 对象 1 和 RSS
    源的 URL 2。创建并填充一个新的 `feed.RSS` 对象需要一定的开销。如果你将该对象存储在包级别的变量中，它将在每次函数调用之后仍然存在，从而避免了后续函数调用中的开销。这还可以让你利用
    `feed.RSS` 中对实体标签的支持。
- en: The `EventRequest` and `EventResponse` types define the format of a client request
    and the function’s response. AWS Lambda unmarshals the JSON from the client’s
    HTTP request body into the `EventRequest` object and marshals the function’s `EventResponse`
    to JSON to the HTTP response body before returning it to the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventRequest` 和 `EventResponse` 类型定义了客户端请求的格式和函数的响应格式。AWS Lambda 会将客户端 HTTP
    请求体中的 JSON 解组到 `EventRequest` 对象中，并将函数的 `EventResponse` 编组为 JSON，放入 HTTP 响应体中，再返回给客户端。'
- en: '[Listing 14-5](#listing14-5) defines the `main` function and begins to define
    the AWS Lambda-compatible function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-5](#listing14-5) 定义了 `main` 函数，并开始定义兼容 AWS Lambda 的函数。'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 14-5: Main function and first part of the Lambda function named LatestXKCD
    (*aws/xkcd.go*)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-5：主函数以及名为 LatestXKCD 的 Lambda 函数的第一部分 (*aws/xkcd.go*)
- en: Hook your function into Lambda by passing it to the `lambda.Start` method 1.
    You’re welcome to instantiate dependencies in an `init` function, or before this
    statement, if your function requires it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将你的函数传递给 `lambda.Start` 方法 1，将它与 Lambda 连接起来。如果你的函数需要，你可以在 `init` 函数中实例化依赖项，或者在这条语句之前实例化它们。
- en: The `LatestXKCD` function accepts a context and an `EventRequest` and returns
    an `EventResponse` and an `error` interface. It defines a response object 2 with
    default `Title` and `URL` values. The function returns the response as is in the
    event of an error or an empty feed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`LatestXKCD` 函数接受一个上下文和一个 `EventRequest`，并返回一个 `EventResponse` 和一个 `error`
    接口。它定义了一个响应对象 2，并设置了默认的 `Title` 和 `URL` 值。在发生错误或源为空时，函数将按原样返回响应。'
- en: Parsing the feed URL 3 from [Listing 14-4](#listing14-4) populates the `rssFeed`
    object with the latest feed details. [Listing 14-6](#listing14-6) uses these details
    to formulate the response.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [清单 14-4](#listing14-4) 解析源 URL 3，会将最新的源细节填充到 `rssFeed` 对象中。[清单 14-6](#listing14-6)
    使用这些细节来构建响应。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 14-6: Populating the response with the feed results (aws/xkcd.go)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-6：用源结果填充响应（aws/xkcd.go）
- en: If the client requests the previous XKCD comic 1 and there are at least two
    feed items, the function populates the response with details of the previous XKCD
    comic. Otherwise, the function populates the response with the most recent XKCD
    comic details, provided there’s at least one feed item. If neither of those cases
    is true, the client receives the response with its default values from [Listing
    14-5](#listing14-5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端请求了之前的 XKCD 漫画 1，并且至少有两个提要项，函数会用之前的 XKCD 漫画的详细信息填充响应。否则，函数会用最新的 XKCD 漫画的详细信息填充响应，只要提要中至少有一个项。如果这两种情况都不成立，客户端将收到默认值的响应，来自
    [Listing 14-5](#listing14-5)。
- en: Compiling, Packaging, and Deploying Your Function
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译、打包和部署你的函数
- en: 'AWS Lambda expects you to compile your code and zip the resulting binary before
    deploying the archive, using the AWS CLI tools. To do this, use the following
    commands in Linux, macOS, or WSL:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 希望你在部署归档之前编译代码并将生成的二进制文件压缩，使用 AWS CLI 工具来完成此操作。为此，请在 Linux、macOS
    或 WSL 中使用以下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile *aws/xkcd.go* and add the resulting *xkcd* binary to a ZIP file. Then,
    use the AWS CLI to create a new function named `xkcd`, a handler named `xkcd`,
    the `go1.x` runtime, the role ARN you created earlier, and the ZIP file containing
    the *xkcd* binary. Notice the *fileb://xkcd.zip* URL in the command line. This
    tells the AWS CLI that it can find a binary file (*fileb*) in the current directory
    named *xkcd.zip*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 *aws/xkcd.go* 并将生成的 *xkcd* 二进制文件添加到一个 ZIP 文件中。然后，使用 AWS CLI 创建一个名为 `xkcd`
    的新函数，指定处理程序为 `xkcd`，运行时为 `go1.x`，并使用之前创建的角色 ARN 和包含 *xkcd* 二进制文件的 ZIP 文件。请注意命令行中的
    *fileb://xkcd.zip* URL，这告诉 AWS CLI 可以在当前目录中找到名为 *xkcd.zip* 的二进制文件 (*fileb*)。
- en: 'If successful, the AWS CLI outputs the details of the new Lambda function:
    the function name 1 in AWS, which you’ll use on the command line to manage your
    function, and the filename of the binary in the zip file 2.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，AWS CLI 会输出新 Lambda 函数的详细信息：AWS 中的函数名称 1，之后你将在命令行中使用该名称管理你的函数，以及 ZIP 文件中二进制文件的文件名
    2。
- en: Compilation of the binary and packing it is a bit different on Windows. I recommend
    you do this in PowerShell since you can compress the cross-compiled binary on
    the command line without the need to install a specific archiver.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，二进制文件的编译和打包略有不同。我建议你在 PowerShell 中执行此操作，因为你可以在命令行中压缩跨平台编译的二进制文件，而无需安装特定的压缩工具。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, use the AWS CLI tools to deploy the ZIP file as in the previous
    listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，使用 AWS CLI 工具像之前的列表中那样部署 ZIP 文件。
- en: 'If you need to update your function code, recompile the binary and archive
    it again. Then use the following command to update the existing Lambda function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更新函数代码，请重新编译二进制文件并再次打包。然后使用以下命令更新现有的 Lambda 函数：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since you’re updating an existing function, the only values you need to provide
    are the names of the function and ZIP file. AWS takes care of the rest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在更新现有的函数，因此只需要提供函数名和 ZIP 文件名。其余的由 AWS 处理。
- en: As an exercise, update the code to allow the client to request a forced refresh
    of the XKCD RSS feed. Then, update the function with those changes and move on
    to the next section to test those changes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，更新代码以允许客户端请求强制刷新 XKCD RSS 提要。然后，更新函数以应用这些更改，并继续到下一部分进行测试。
- en: Testing Your AWS Lambda Function
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的 AWS Lambda 函数
- en: 'The AWS CLI tools make it easy to test your Lambda function. You can use them
    to send a JSON payload and capture the JSON response. Invoke the function by providing
    the function name and the path to a file in the AWS CLI. The AWS CLI will populate
    this with the response body:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI 工具使测试 Lambda 函数变得容易。你可以使用它们发送 JSON 有效负载并捕获 JSON 响应。通过提供函数名和文件路径来调用该函数，AWS
    CLI 会将响应体填充到其中：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the invocation is successful, you can verify that your function provided
    the XKCD comic name and URL by reviewing the *response.json* contents:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，你可以通过查看 *response.json* 的内容来验证函数是否返回了 XKCD 漫画的名称和 URL：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also invoke the function with a custom request body by adding a few
    additional command line arguments. You can pass a `payload` string if you specify
    its format as `raw-in-base64-out`. This tells the AWS CLI to take the string you
    provide and Base64-encode it before assigning it to the request body and passing
    it along to the function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过添加一些额外的命令行参数来使用自定义请求体调用函数。如果你将格式指定为 `raw-in-base64-out`，可以传递一个 `payload`
    字符串。这告诉 AWS CLI 将你提供的字符串进行 Base64 编码，然后将其分配给请求体，并传递给函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Google Cloud Functions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Functions
- en: Like AWS Lambda, Google Cloud Functions allows you to deploy code in a serverless
    environment, offloading the implementation details to Google. Not surprisingly,
    Go enjoys first-class support in Cloud Functions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS Lambda 类似，Google Cloud Functions 允许您在无服务器环境中部署代码，将实现细节交给 Google 处理。不出所料，Go
    在 Cloud Functions 中享有一流支持。
- en: You’ll need a Google Cloud account before proceeding with this section. Visit
    [https://cloud.google.com](https://cloud.google.com) to get started with a trial
    account.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行此部分之前，您需要一个 Google Cloud 帐户。访问[https://cloud.google.com](https://cloud.google.com)开始注册试用帐户。
- en: Installing the Google Cloud Software Development Kit
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Google Cloud 软件开发工具包
- en: The Google Cloud Software Development Kit (SDK) requires Python 2.7.9 or 3.5+.
    You’ll need to make sure a suitable version of Python is installed on your operating
    system before proceeding. You can follow Google’s comprehensive installation guide
    at [https://cloud.google.com/sdk/docs/install/](https://cloud.google.com/sdk/docs/install/),
    where you’ll find specific installation instructions for Windows, macOS, and various
    flavors of Linux.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 软件开发工具包（SDK）要求 Python 2.7.9 或 3.5 以上版本。您需要确保操作系统上安装了适合的 Python
    版本，然后才能继续。您可以按照 Google 提供的全面安装指南[https://cloud.google.com/sdk/docs/install/](https://cloud.google.com/sdk/docs/install/)，其中包含
    Windows、macOS 和各种 Linux 版本的具体安装说明。
- en: 'Here are the generic Linux installation steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通用的 Linux 安装步骤：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Download the current Google Cloud SDK tarball (the version changes frequently!)
    and extract it. Then, run the *./google-cloud-sdk/install.sh* script. The installation
    process asks you questions that pertain to your environment. I snipped them from
    the output for brevity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下载当前的 Google Cloud SDK 压缩包（版本会经常变动！）并解压。然后，运行 *./google-cloud-sdk/install.sh*
    脚本。安装过程中会询问一些与您环境相关的问题。我已从输出中省略这些内容，以简洁为主。
- en: Initializing the Google Cloud SDK
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化 Google Cloud SDK
- en: You need to authorize the Google Cloud SDK before you’re able to use it to deploy
    your code. Google makes this process simple compared to AWS. There’s no need to
    create credentials and then copy and paste them to the command line. Instead,
    Google Cloud uses your web browser for authentication and authorization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要授权 Google Cloud SDK，才能使用它来部署代码。与 AWS 相比，Google 使这个过程变得简单。无需创建凭据并将其复制粘贴到命令行中。相反，Google
    Cloud 使用您的 Web 浏览器进行身份验证和授权。
- en: 'The `gcloud init` command is equivalent to the `aws configure` command, in
    that it will walk you through the configuration of your Google Cloud command line
    environment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud init` 命令相当于 `aws configure` 命令，它将引导您配置 Google Cloud 命令行环境：'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first step in the process will open a page in your web browser to authenticate
    your Google Cloud SDK with your Google Cloud account. Your command line output
    may look a little different from the output here if your Google Cloud account
    has existing projects. For the purposes of this chapter, elect to create a new
    project 1 and give it a project ID—`goxkcd` in this example. Your project ID must
    be unique across Google Cloud. Once you’ve completed this step, you’re ready to
    interact with Google Cloud from the command line, just as you did with AWS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的第一步将会在您的浏览器中打开一个页面，用于将 Google Cloud SDK 与您的 Google Cloud 帐户进行身份验证。如果您的 Google
    Cloud 帐户已有项目，则您的命令行输出可能与此处的输出略有不同。为了本章节的目的，选择创建一个新项目 1 并为其指定一个项目 ID——在本示例中为 `goxkcd`。您的项目
    ID 必须在 Google Cloud 中唯一。一旦完成此步骤，您就可以像在 AWS 中一样，从命令行与 Google Cloud 进行交互。
- en: Enable Billing and Cloud Functions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用结算和 Cloud Functions
- en: You need to make sure billing is enabled for your project before it can use
    Cloud Functions. Visit [https://cloud.google.com/billing/docs/how-to/modify-project/](https://cloud.google.com/billing/docs/how-to/modify-project/)
    to learn how to modify the billing details of an existing project. Once enabled,
    you can then enable your project’s Cloud Functions access. At this point, you
    can start writing code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Cloud Functions 之前，您需要确保为您的项目启用结算功能。访问[https://cloud.google.com/billing/docs/how-to/modify-project/](https://cloud.google.com/billing/docs/how-to/modify-project/)了解如何修改现有项目的结算信息。启用后，您可以继续启用项目的
    Cloud Functions 访问权限。此时，您可以开始编写代码。
- en: Defining a Cloud Function
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个 Cloud Function
- en: Cloud Functions uses Go’s module support instead of requiring you to write a
    stand-alone application as you did for AWS Lambda. This simplifies your code a
    bit since you don’t need to import any libraries specific to Cloud Functions or
    define a main function as the entry point of execution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Functions 使用 Go 的模块支持，而不是像 AWS Lambda 那样要求你编写一个独立的应用程序。这简化了你的代码，因为你不需要导入任何特定于
    Cloud Functions 的库，也不需要定义一个主函数作为执行的入口点。
- en: '[Listing 14-7](#listing14-7) provides the initial code for a Cloud Functions–compatible
    module.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-7](#listing14-7) 提供了一个兼容 Cloud Functions 的模块的初始代码。'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 14-7: Creating persistent variables and request and response types
    (*gcp/xkcd.go*)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-7：创建持久变量和请求、响应类型 (*gcp/xkcd.go*)
- en: The types are identical to the code we wrote for AWS Lambda. Unlike AWS Lambda,
    Cloud Functions won’t unmarshal the request body into an `EventRequest` for you.
    Therefore, you’ll have to handle the unmarshaling and marshaling of the request
    and response payloads on your own.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型与我们为 AWS Lambda 编写的代码是一样的。不同于 AWS Lambda，Cloud Functions 不会为你将请求体解码为 `EventRequest`。因此，你需要自行处理请求和响应负载的解码和编码。
- en: 'Whereas AWS Lambda accepted a range of function signatures, Cloud Functions
    uses the familiar `net/http` handler function signature: `func(http.ResponseWriter,
    *http.Request)`, as shown in [Listing 14-8](#listing14-8).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS Lambda 接受多种函数签名不同，Cloud Functions 使用熟悉的 `net/http` 处理函数签名：`func(http.ResponseWriter,
    *http.Request)`，如 [Listing 14-8](#listing14-8) 所示。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 14-8: Handling the request and response and optionally updating the
    RSS feed (*gcp/xkcd.go*)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-8：处理请求和响应，并可选地更新 RSS feed (*gcp/xkcd.go*)
- en: Like the AWS code, this `LatestXKCD` function refreshes the RSS feed by using
    the `ParseURL` method. But unlike the equivalent AWS code, you need to JSON-unmarshal
    the request body 2 and marshal the response to JSON 1 before sending it to the
    client. Even though `LatestXKCD` doesn’t receive a context in its function parameters,
    you can use the request’s context 3 to cancel the parser if the socket connection
    with the client terminates before the parser returns.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS 代码相似，这个 `LatestXKCD` 函数通过使用 `ParseURL` 方法刷新 RSS feed。但与 AWS 代码不同的是，你需要先将请求体进行
    JSON 解码，然后再将响应转为 JSON，才能发送给客户端。尽管 `LatestXKCD` 的函数参数中没有接收上下文，但你可以使用请求的上下文 3 来取消解析器，如果客户端与服务器的连接在解析器返回之前终止的话。
- en: '[Listing 14-9](#listing14-9) implements the remainder of the `LatestXKCD` function.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-9](#listing14-9) 实现了 `LatestXKCD` 函数的其余部分。'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 14-9: Populating the response with the feed results (*gcp/xkcd.go*)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-9：用 feed 结果填充响应 (*gcp/xkcd.go*)
- en: Like [Listing 14-6](#listing14-6), this code populates the response fields with
    the appropriate feed item. The deferred function in [Listing 14-8](#listing14-8)
    handles writing the response to the `http.ResponseWriter`, so there’s nothing
    further to do here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [Listing 14-6](#listing14-6) 所示，这段代码将适当的 feed 项填充到响应字段中。[Listing 14-8](#listing14-8)
    中的延迟函数负责将响应写入 `http.ResponseWriter`，因此这里不需要做其他事情。
- en: Deploying Your Cloud Function
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署你的 Cloud Function
- en: You need to address one bit of module accounting before you deploy your code;
    you need to create a *go.mod* file so Google can find dependencies, because unlike
    with AWS Lambda, you don’t compile and package the binary yourself. Instead, the
    code is ultimately compiled on Cloud Functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署代码之前，你需要解决一个模块管理的问题；你需要创建一个 *go.mod* 文件，以便 Google 可以找到依赖项，因为与 AWS Lambda
    不同，你不会自己编译和打包二进制文件。相反，代码最终会在 Cloud Functions 上编译。
- en: 'Use the following commands to create the *go.mod* file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建 *go.mod* 文件：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These commands initialize a new module named *github.com/awoodbeck/gnp/ch14/gcp*
    and tidy the module requirements in the *go.mod* file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令初始化了一个名为 *github.com/awoodbeck/gnp/ch14/gcp* 的新模块，并整理了 *go.mod* 文件中的模块需求。
- en: 'Your module is ready for deployment. Use the `gcloud functions deploy` command,
    which accepts your code’s function name, the source location, and the Go runtime
    version:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块已准备好部署。使用 `gcloud functions deploy` 命令，它接受你代码的函数名称、源位置和 Go 运行时版本：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The addition of the `--trigger-http` and `--allow-unauthenticated` flags tells
    Google you want to trigger a call to your function by an incoming HTTP request
    and that no authentication is required for the HTTP endpoint.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `--trigger-http` 和 `--allow-unauthenticated` 标志告诉 Google，你希望通过传入的 HTTP 请求触发对函数的调用，并且该
    HTTP 端点不需要认证。
- en: Once created, the SDK output shows the function name 1, the HTTP endpoint 2
    for your function, the permissions for the endpoint 3, and the Go runtime version
    4.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，SDK 输出将显示函数名称 1、函数的 HTTP 端点 2、端点的权限 3 和 Go 运行时版本 4。
- en: 'Although the Cloud Functions deployment workflow is simpler than the AWS Lambda
    workflow, there’s a limitation: you’re restricted to the Go runtime version that
    Cloud Functions supports, which may not be the latest version. Therefore, you
    need to make sure the code you write doesn’t use newer features added since Go
    1.13\. You don’t have a similar limitation when deploying to AWS Lambda, since
    you locally compile the binary before deployment.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Cloud Functions 的部署工作流程比 AWS Lambda 的工作流程更简单，但它有一个限制：您受到 Cloud Functions
    支持的 Go 运行时版本的限制，可能不是最新版本。因此，您需要确保编写的代码不使用自 Go 1.13 版本以来新增的特性。部署到 AWS Lambda 时没有类似的限制，因为您在部署前会本地编译二进制文件。
- en: Testing Your Google Cloud Function
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试您的 Google Cloud 函数
- en: The Google Cloud SDK doesn’t include a way to invoke your function from the
    command line, as you did using the AWS CLI. But your function’s HTTP endpoint
    is publicly accessible, so you can directly send HTTP requests to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud SDK 不提供像 AWS CLI 那样从命令行调用您的函数的方式。但您的函数的 HTTP 端点是公开可访问的，因此您可以直接向其发送
    HTTP 请求。
- en: 'Use `curl` to send HTTP requests to your function’s HTTP endpoint:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `curl` 向您的函数的 HTTP 端点发送 HTTP 请求：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, you send `POST` requests with the `Content-Type` header indicating that
    the request body contains JSON. The first request sends an empty object, so you
    correctly receive the current XKCD comic title and URL. The second request asks
    for the previous comic, which the function correctly returns in its response.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您发送 `POST` 请求，并在 `Content-Type` 头中指示请求体包含 JSON。第一次请求发送一个空对象，因此您正确地接收当前的
    XKCD 漫画标题和 URL。第二次请求询问前一个漫画，函数正确地在响应中返回它。
- en: Keep in mind that, unlike with AWS, the only security your function’s HTTP endpoint
    has with the use of the `--allow-unauthenticated` flag is obscurity, as anyone
    can send requests to your Google Clouds function. Since you aren’t returning sensitive
    information, the main risk you face is the potential cost you may incur if you
    neglect to delete or secure your function after you’re done with it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与 AWS 不同，使用 `--allow-unauthenticated` 标志时，您的函数的 HTTP 端点唯一的安全性是模糊性，因为任何人都可以向您的
    Google Cloud 函数发送请求。由于您没有返回敏感信息，您面临的主要风险是如果在使用后没有删除或保护您的函数，可能会产生的费用。
- en: 'Once you’re satisfied that the function works as expected, go ahead and delete
    it. I’ll sleep better at night if you do. You can remove the function from the
    command line like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确认函数按预期工作，就可以删除它。如果您这么做，我晚上会睡得更好。您可以通过以下方式在命令行中删除该函数：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ll be prompted to confirm the deletion.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将提示您确认删除操作。
- en: Azure Functions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Unlike AWS Lambda and Google Cloud Functions, Microsoft Azure Functions doesn’t
    offer first-class support for Go. But all is not lost. We can define a custom
    handler that exposes an HTTP server. Azure Functions will proxy requests and responses
    between clients and your custom handler’s HTTP server. You can read more details
    about the Azure Functions custom handlers at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function](https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function).
    In addition, your code runs in a Windows environment as opposed to Linux, which
    is an important distinction when compiling your code for deployment on Azure Functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS Lambda 和 Google Cloud Functions 不同，Microsoft Azure Functions 不提供对 Go 的一流支持。但并非一无所有。我们可以定义一个自定义处理程序，暴露一个
    HTTP 服务器。Azure Functions 会在客户端和您的自定义处理程序的 HTTP 服务器之间代理请求和响应。您可以在[https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function](https://docs.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers#http-only-function)阅读有关
    Azure Functions 自定义处理程序的更多细节。此外，您的代码运行在 Windows 环境中，而不是 Linux，这在为 Azure Functions
    部署时编译代码时是一个重要区别。
- en: You’ll need a Microsoft Azure account before proceeding. Visit [https://azure.microsoft.com](https://azure.microsoft.com)
    to create one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要一个 Microsoft Azure 账户。请访问 [https://azure.microsoft.com](https://azure.microsoft.com)
    创建一个。
- en: Installing the Azure Command Line Interface
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Azure 命令行界面
- en: The Azure CLI has installation packages for Windows, macOS, and several popular
    Linux distributions. You can find details for your operating system at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli/](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI 提供适用于 Windows、macOS 和多个流行 Linux 发行版的安装包。你可以在[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli/](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)找到针对你操作系统的详细信息。
- en: 'The following commands install the Azure CLI on a Debian-compatible Linux system:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在兼容 Debian 的 Linux 系统上安装 Azure CLI：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first command downloads the `InstallAzureCLIDeb` shell script and pipes
    it to `sudo bash`. After authenticating, the script installs an Apt repository,
    updates Apt, and installs the *azure-cli* package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令下载 `InstallAzureCLIDeb` 脚本并将其传递给 `sudo bash`。身份验证后，该脚本会安装 Apt 仓库，更新 Apt，并安装
    *azure-cli* 包。
- en: Once installed, the `az version` command displays the current Azure CLI component
    versions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，`az version` 命令将显示当前 Azure CLI 组件的版本。
- en: Configuring the Azure CLI
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Azure CLI
- en: 'Whereas the AWS CLI required you to provide its credentials during configuration,
    and the Google Cloud SDK opened a web page to authorize itself during configuration,
    the Azure CLI separates configuration and authentication into separate steps.
    First, issue the `az configure` command and follow the instructions for configuring
    the Azure CLI. Then, run the `az login` command to authenticate your Azure CLI
    using your web browser:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AWS CLI 需要你在配置过程中提供凭证，以及 Google Cloud SDK 在配置过程中打开网页进行授权不同，Azure CLI 将配置和身份验证分成了两个独立的步骤。首先，执行
    `az configure` 命令并按照指示配置 Azure CLI。然后，运行 `az login` 命令，通过你的 Web 浏览器对 Azure CLI
    进行身份验证：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The Azure CLI supports several configuration options not covered in the `az
    configure` process. You can use the Azure CLI to set these values instead of directly
    editing the *$HOME/.azure/config* file. For example, you can disable telemetry
    by setting the `core.collect_telemetry` variable to `off`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI 支持多种配置选项，这些选项不在`az configure`过程中涵盖。你可以使用 Azure CLI 来设置这些值，而不是直接编辑
    *$HOME/.azure/config* 文件。例如，你可以通过将 `core.collect_telemetry` 变量设置为 `off` 来禁用遥测：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Installing Azure Functions Core Tools
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Azure Functions 核心工具
- en: Unlike the other cloud services covered in this chapter, the Azure CLI tools
    do not directly support Azure Functions. You need to install another set of tools
    specific to Azure Functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章介绍的其他云服务不同，Azure CLI 工具并不直接支持 Azure Functions。你需要安装一套专门用于 Azure Functions
    的工具。
- en: The “Install the Azure Functions Core Tools” section of [https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/)
    details the process of installing version 3 of the tools on Windows, macOS, and
    Linux.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local/)
    中的“安装 Azure Functions 核心工具”部分详细描述了在 Windows、macOS 和 Linux 上安装版本 3 的工具的过程。'
- en: Creating a Custom Handler
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义处理程序
- en: 'You can use the Azure Functions core tools to initialize a new custom handler.
    Simply run the `func init` command, setting the `--worker-runtime` flag to `custom`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Azure Functions 核心工具初始化一个新的自定义处理程序。只需运行 `func init` 命令，并将 `--worker-runtime`
    标志设置为 `custom`：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The core tools then create a few project files, the most relevant to us being
    the *host.json* file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 核心工具随后会创建一些项目文件，其中最相关的是 *host.json* 文件。
- en: 'You need to complete a few more tasks before you start writing code. First,
    create a subdirectory named after your desired function name in Azure Functions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，你需要完成一些其他任务。首先，在 Azure Functions 中创建一个与期望函数名称相同的子目录：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example names the Azure Function `LatestXKCDFunction` by creating a subdirectory
    with the same name. This name will be part of your function’s endpoint URL.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例通过创建一个同名的子目录来命名 Azure Function 为 `LatestXKCDFunction`。这个名称将成为你函数端点 URL 的一部分。
- en: Second, create a file named *function.json* in the subdirectory with the contents
    in [Listing 14-10](#listing14-10).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，在子目录中创建一个名为*function.json*的文件，内容参见[清单14-10](#listing14-10)。
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 14-10: Binds incoming HTTP trigger and outgoing HTTP (*azure/LatestXKCDFunction/function.json*)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-10：绑定传入的 HTTP 触发器和传出的 HTTP (*azure/LatestXKCDFunction/function.json*)
- en: The Azure Functions Core Tools will use this *function.json* file to configure
    Azure Functions to use your custom handler. This JSON instructs Azure Functions
    to bind an incoming HTTP trigger to your custom handler and expect HTTP output
    from it. Here, you’re telling Azure Functions that incoming 2`POST` requests 3
    shall trigger 1 your custom handler, and your custom handler returns 4 HTTP responses
    5.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions Core Tools 将使用此 *function.json* 文件来配置 Azure Functions 使用你的自定义处理程序。此
    JSON 文件指示 Azure Functions 将传入的 HTTP 触发器绑定到你的自定义处理程序，并期待来自它的 HTTP 输出。在这里，你告诉 Azure
    Functions，传入的 2`POST` 请求 3 将触发 1 你的自定义处理程序，而你的自定义处理程序返回 4 HTTP 响应 5。
- en: Lastly, the generated *host.json* file needs some tweaking ([Listing 14-11](#listing14-11)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成的 *host.json* 文件需要进行一些调整（[列表 14-11](#listing14-11)）。
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 14-11: Tweaking the host.json file (*azure/host.json*)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-11：调整 *host.json* 文件（*azure/host.json*）
- en: Make sure to enable the forwarding of HTTP requests from Azure Functions to
    your custom handler 1. This instructs Azure Functions to act as a proxy between
    clients and your custom handler. Also, set the default executable path to the
    name of your Go binary 2. Since your code will run on Windows, make sure to include
    the *.exe* file extension.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 确保启用从 Azure Functions 到自定义处理程序 1 的 HTTP 请求转发。这指示 Azure Functions 充当客户端和自定义处理程序之间的代理。此外，将默认可执行路径设置为
    Go 二进制文件的名称 2。由于你的代码将在 Windows 上运行，请确保包含 *.exe* 文件扩展名。
- en: Defining a Custom Handler
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义自定义处理程序
- en: Your custom handler needs to instantiate its own HTTP server, but you can leverage
    code you’ve already written for Google Cloud Functions. [Listing 14-12](#listing14-12)
    is the entire custom handler implementation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你的自定义处理程序需要实例化自己的 HTTP 服务器，但你可以利用已经为 Google Cloud Functions 编写的代码。[列表 14-12](#listing14-12)
    是完整的自定义处理程序实现。
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 14-12: Using the Google Cloud Functions code to handle requests (*azure/xkcd.go*)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-12：使用 Google Cloud Functions 代码处理请求（*azure/xkcd.go*）
- en: Azure Functions expects your HTTP server to listen to the port number it assigns
    to the `FUNCTIONS_CUSTOMHANDLER_PORT` environment variable 1. Since the `LatestXKCD`
    function you wrote for Cloud Functions can be cast as an `http.HandlerFunc`, you
    can save a bunch of keystrokes by importing its module and using the function
    as your HTTP server’s handler 2.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 期望你的 HTTP 服务器监听它为 `FUNCTIONS_CUSTOMHANDLER_PORT` 环境变量分配的端口号
    1。由于你为 Cloud Functions 编写的 `LatestXKCD` 函数可以被转换为 `http.HandlerFunc`，你可以通过导入其模块并将该函数用作
    HTTP 服务器的处理程序，从而省去很多敲击键盘的步骤 2。
- en: Locally Testing the Custom Handler
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地测试自定义处理程序
- en: 'The Azure Functions Core Tools allow you to locally test your code before deployment.
    Let’s walk through the process of building and running the Azure Functions code
    on your computer. First, change into the directory with your Azure Functions code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions Core Tools 允许你在部署之前本地测试代码。让我们逐步了解如何在计算机上构建和运行 Azure Functions
    代码。首先，切换到包含 Azure Functions 代码的目录：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, build your code, making sure that the resulting binary name matches the
    one you defined in your host file—*xkcd.exe*, in this example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建你的代码，确保生成的二进制文件名称与在主机文件中定义的名称相匹配——此示例中为 *xkcd.exe*：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since your code will run locally, you do not need to explicitly compile your
    binary for Windows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的代码将在本地运行，你不需要专门为 Windows 编译二进制文件。
- en: 'Finally, run `func start`, which will read the *host.json* file and execute
    the *xkcd.exe* binary:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行 `func start`，这将读取 *host.json* 文件并执行 *xkcd.exe* 二进制文件：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, the Azure Functions code set the `FUNCTIONS_CUSTOMHANDLER_PORT` environment
    variable to 44687 1 before executing the *xkcd.exe* binary. Azure Functions also
    exposes an HTTP endpoint on port 7071 2. Any requests sent to the *LatestXKCDFunction*
    endpoint 3 are forwarded onto the *xkcd.exe* HTTP server, and responses are forwarded
    to the client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Azure Functions 代码在执行 *xkcd.exe* 二进制文件之前，将 `FUNCTIONS_CUSTOMHANDLER_PORT`
    环境变量设置为 44687 1。Azure Functions 还在端口 7071 上公开了一个 HTTP 端点 2。任何发送到 *LatestXKCDFunction*
    端点的请求 3 都会转发到 *xkcd.exe* HTTP 服务器，并且响应会转发给客户端。
- en: 'Now that the *LatestXKCDFunction* endpoint is active, you can send HTTP requests
    to it as you did with your Google Cloud Functions code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*LatestXKCDFunction* 端点已经激活，你可以像使用 Google Cloud Functions 代码时那样向其发送 HTTP
    请求：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As with Google Cloud, sending a `POST` request with empty JSON in the request
    body causes the custom handler to return the current XKCD comic title and URL.
    Requesting the previous comic accurately returns the previous comic’s title and
    URL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Google Cloud 一样，发送一个请求体为空的 `POST` 请求会导致自定义处理程序返回当前的 XKCD 漫画标题和 URL。请求前一张漫画时，会准确返回前一张漫画的标题和
    URL。
- en: Deploying the Custom Handler
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署自定义处理程序
- en: Since you’re using a custom handler, the deployment process is slightly more
    complicated than that for Lambda or Cloud Functions. This section walks you through
    the steps on Linux. You can find the entire process detailed at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/](https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用的是自定义处理程序，部署过程比Lambda或Cloud Functions稍微复杂一些。本节将指导你在Linux上的步骤。你可以在[https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/](https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function-azure-cli/)找到整个过程的详细说明。
- en: 'Start by issuing the `az login` command to make sure your Azure CLI’s authorization
    is current:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`az login`命令来确保你的Azure CLI授权是最新的：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, create a resource group and specify the location you’d like to use. You
    can get a list of locations using `az account list-locations`. This example uses
    `NetworkProgrammingWithGo` for the resource group name and `eastus` for the location:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个资源组并指定你想使用的位置。你可以使用`az account list-locations`获取位置列表。这个示例使用`NetworkProgrammingWithGo`作为资源组名称，`eastus`作为位置：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, create a unique storage account, specifying its name, location, the resource
    group name you just created, and the `Standard_LRS` SKU:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个唯一的存储帐户，指定其名称、位置、你刚创建的资源组名称以及`Standard_LRS` SKU：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, create a function application with a unique name, making sure to specify
    you’re using Functions 3.0 and a custom runtime:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个唯一名称的函数应用，确保指定你使用的是Functions 3.0和自定义运行时：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point, you’re ready to compile your code and deploy it. Since your code
    will run on Windows, it’s necessary to build your binary for Windows. Then, publish
    your custom handler.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经准备好编译代码并部署它。由于你的代码将在Windows上运行，因此需要为Windows构建二进制文件。然后，发布你的自定义处理程序。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once the code is deployed, you can send `POST` requests to your custom handler’s
    URL 1. The actual URL is a bit longer than this one, and it includes URI parameters
    relevant to Azure Functions. I’ve snipped it for brevity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码部署完成，你可以向自定义处理程序的URL 1发送`POST`请求。实际的URL比这个要长，并且包含与Azure Functions相关的URI参数。为了简洁起见，我已经将其剪裁。
- en: Testing the Custom Handler
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自定义处理程序
- en: 'Assuming you’re using your custom handler’s full URL, it should return results
    like those seen here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用自定义处理程序的完整URL，它应该返回如下所示的结果：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Use `curl` to query your Azure Functions custom handler. As expected, empty
    JSON results in the current XKCD comic’s title and URL, whereas a request for
    the previous comic properly returns the previous comic’s details.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`查询你的Azure Functions自定义处理程序。如预期所示，空的JSON会返回当前XKCD漫画的标题和网址，而请求前一部漫画则会正确返回前一部漫画的详细信息。
- en: What You’ve Learned
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: When you use cloud offerings, you can focus on application development and avoid
    the costs of acquiring a server infrastructure, software licensing, and the human
    resources required to maintain it all. This chapter explored Amazon Web Services,
    Google Cloud, and Microsoft Azure, all of which offer comprehensive solutions
    that allow you to scale your business and pay as you go. We used AWS Lambda, Google
    Cloud Functions, and Microsoft Azure Functions, which are all PaaS offerings that
    allow you to deploy an application while letting the platform handle the implementation
    details.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用云服务时，你可以专注于应用程序开发，避免了获取服务器基础设施、软件授权和维护所需的人力资源的成本。本章探讨了Amazon Web Services、Google
    Cloud和Microsoft Azure，这些平台都提供了综合解决方案，使你能够扩展业务并按需付费。我们使用了AWS Lambda、Google Cloud
    Functions和Microsoft Azure Functions，这些都是PaaS服务，允许你部署应用程序，同时让平台处理实现细节。
- en: As you saw, developing and deploying an application on the three cloud environments
    follow the same general process. First, you install the platform’s command line
    tools. Next, you authorize the command line tools to act on behalf of your account.
    You then develop your application for the target platform and deploy it. Finally,
    you make sure your application works as expected.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这三个云环境中开发和部署应用程序遵循相同的一般过程。首先，你安装平台的命令行工具。接下来，你授权命令行工具代表你的帐户执行操作。然后，你为目标平台开发应用程序并进行部署。最后，你确保应用程序按预期运行。
- en: Both AWS Lambda and Cloud Functions have first-class support for Go, making
    the development and deployment workflow easy. Although Azure Functions doesn’t
    explicitly support Go, you can write a custom handler to use with the service.
    But despite the small variations in the development, deployment, and testing workflows,
    all three cloud platforms can generate the same result. Which one you should use
    comes down to your use case and budget.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 和 Cloud Functions 都为 Go 提供了一流的支持，使得开发和部署流程变得简单。尽管 Azure Functions
    没有明确支持 Go，但你可以编写自定义处理程序来与该服务一起使用。尽管在开发、部署和测试工作流程中存在一些小的差异，但这三大云平台都能产生相同的结果。你应该选择哪个，取决于你的使用场景和预算。
