- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AMAZING ACCELERATION**'
  prefs: []
  type: TYPE_NORMAL
- en: The accelerometer is arguably the most useful of the BBC micro:bit’s built-in
    sensors. It lets you measure the direction and strength of a force, such as gravity,
    that is acting on the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the accelerometer for many things, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Detecting gestures like shaking, or even finding
    out that your micro:bit is falling'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Learning which way and how much the micro:bit
    is tilted and using this to control your micro:bit'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Measuring how quickly your micro:bit is accelerating
    when it moves. (For example, you might use it in a pedometer to see how many steps
    you take in a day.)'
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/f0106-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**EXPERIMENT 5: GESTURES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The micro:bit’s software includes gesture recognition, so it can respond to
    certain motions, like tilting or shaking, that are picked up by the accelerometer.
    In this section, you’ll program the micro:bit to display a smile whenever you
    shake it.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you’ll learn how to deal with the raw data that comes
    straight from the accelerometer chip so you can measure acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this experiment, you’ll just need your micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Experiment 5: Gestures**.
    Once the program has opened, click **Download** and then copy the hex file onto
    your micro:bit. If you prefer to use Python, then download the code from the same
    website. For instructions for downloading and using the book’s examples, see “Downloading
    the Code” on [page 34](ch01.xhtml#page_34). The Python file for this experiment
    is *Experiment_05.py*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the program starts, shake your micro:bit, and you should see a smile appear,
    then disappear, on the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using gestures in your program is similar in both Blocks and MicroPython. Both
    languages have the same set of gesture types. The main difference is that in MicroPython
    there is no event mechanism for handling events; instead, you have to keep checking
    for gestures in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for this experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0107-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The acceleration gestures available in the Blocks code work as events, just
    as pressing a button does. Start with an `on` block. Click the triangle in to
    access a drop-down menu of possible gestures, shown in [Figure 5-1](ch05.xhtml#ch5fig1),
    and select `shake`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Selecting different gestures*'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE DIFFERENT GESTURES**'
  prefs: []
  type: TYPE_NORMAL
- en: The shake gesture responds to any significant shaking of your micro:bit. The
    next two gestures, logo up and logo down, respond to tilting the micro:bit front
    to back. The logo this code refers to is the icon printed on the micro:bit board,
    near the USB socket.
  prefs: []
  type: TYPE_NORMAL
- en: The screen up and screen down gestures respond to the micro:bit’s orientation.
    For example, if you placed it screen side down, you’d trigger the screen down
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The tilt left and tilt right events respond when you tilt the micro:bit from
    side to side by more than about 60 degrees. You have to tilt it quite a lot to
    trigger these events.
  prefs: []
  type: TYPE_NORMAL
- en: The final four events relate to the overall force acting on the accelerometer
    rather than the force in any particular direction. For example, if the micro:bit
    is in free fall, then the fall will trigger the free fall event. The gestures
    3g, 6g, and 8g detect different amounts of force acting on the accelerometer,
    measured in *g* (the acceleration due to gravity, or the *g-force*). For example,
    you could detect a finger tap on the micro:bit. Tapping the micro:bit doesn’t
    move it much, so you might think that not much force is involved, but in fact
    tapping can exert quite a high g-force.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s the MicroPython code for this experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if accelerometer.was_gesture(''shake''):'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.HAPPY)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(500)
  prefs: []
  type: TYPE_NORMAL
- en: display.clear()
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recognize most of the code here. We import the usual library and then
    start a `while True` loop so the main code runs continually. This loop checks
    whether the micro:bit has detected shaking and, if it has, shows the happy face!
  prefs: []
  type: TYPE_NORMAL
- en: Because MicroPython doesn’t have the concept of “events,” you have to use the
    `was_gesture` function inside a `while` loop to check for the shake gesture. You
    can also replace the `shake` block with `up`, `down`, `left`, `right`, `face up`,
    `face down`, `freefall`, `3g`, `6g`, or `8g`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try adding more gestures to the program for Experiment 5\. You can even make
    each gesture trigger a different icon on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.xhtml#ch10), you’ll use gesture detection again to steer
    a micro:bit-controlled robot rover!
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Force, Acceleration, and Gravity**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve been talking about force, acceleration, and gravity as if the accelerometer
    measures all of these things, but it really just measures the distance a certain
    mass moves. Then it computes the other measurements. Let’s take a look at what
    the accelerometer chip actually does to get a better idea of what these three
    terms mean.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: The micro:bit’s accelerometer*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](ch05.xhtml#ch5fig2) shows a rough sketch of what’s inside the
    tiny accelerometer chip attached to your micro:bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a tiny mass *m* attached to a spring. (The mass is drawn as a ball in
    [Figure 5-2](ch05.xhtml#ch5fig2), but its shape isn’t important.) Normally, the
    mass is in position A, but if it’s being pulled against the spring by some force
    (for example, gravity), then it will move to some other position, which we’ll
    call position B. The stronger the force, the bigger the difference between A and
    B. By measuring this distance, the accelerometer calculates the force acting on
    the mass.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at [Figure 5-2](ch05.xhtml#ch5fig2), you can see that the force of gravity
    alone will pull the mass down. But the more the spring is stretched, the more
    the spring pulls the mass in the opposite direction to gravity. So gravity applies
    downward force to the mass, stretching the spring, which then applies upward force.
    When the two forces are equal but acting in opposite directions, the difference
    between the distances B and A is a measure of the gravitational force acting on
    the micro:bit. The larger the distance between A and B, the greater the force
    acting on the mass.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the g-force relates to the acceleration that occurs due to gravity.
    Acceleration is an increase in speed. In other words, if you drop your micro:bit
    off a tall building, the acceleration *g* is the number of meters per second the
    micro:bit’s speed increases by every second. If you dropped your micro:bit off
    a tall building in a vacuum, there wouldn’t be any air to slow down the micro:bit,
    and in this case, the speed of the micro:bit would increase by about 9.8 meters
    per second for every second it fell. So, if it were to start at a speed of 0 (as
    you’re holding it in your hand) and then fall for 10 seconds, it would reach a
    speed of 98 meters per second (about 220 miles per hour).
  prefs: []
  type: TYPE_NORMAL
- en: Also, when the micro:bit meets the ground after traveling at 220 miles per hour,
    it will probably be smashed to bits.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you dropped your micro:bit in a vacuum, then its accelerometer would
    read 0 even though it was clearly accelerating at 9.8 meters a second. This is
    because the accelerometer is not really measuring acceleration. As you saw in
    [Figure 5-3](ch05.xhtml#ch5fig3), it’s measuring the force acting on the mass
    inside of the micro:bit. That force would be zero if the mass and the spring were
    accelerating at the same rate, which they would be since they’re both in the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: If you were in space, well away from the gravitational pull of celestial bodies,
    then the acceleration would be equal to the force acting on the object divided
    by the mass of the object. Because the mass is always the same, the accelerometer
    can tell us the acceleration of the micro:bit as long as some force, any force,
    is acting on it.
  prefs: []
  type: TYPE_NORMAL
- en: The accelerometer chip is actually more advanced than [Figure 5-2](ch05.xhtml#ch5fig2)
    suggests because it has three force-measuring devices in it, set to measure force
    in three directions, all at right angles to each other. In other words, the chip
    measures the force acting on it in three dimensions, X, Y, and Z, as shown in
    [Figure 5-3](ch05.xhtml#ch5fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: The micro:bit’s accelerometer measures force in three dimensions.*'
  prefs: []
  type: TYPE_NORMAL
- en: If your micro:bit were sitting flat on a table, the X dimension would run left
    to right, the Y dimension would run front to back, and the Z dimension would run
    above and below the tabletop. So, if the micro:bit is completely horizontal on
    a flat tabletop, the force of gravity will only be acting on the Z (up-down) dimension,
    while the X and Y dimensions will measure 0 acceleration. Now, if you tilt the
    micro:bit forward a little, then some of the force due to gravity will act on
    the Y dimension, so the Y value will no longer be 0\. This also means that slightly
    less gravitational force is acting on the Z dimension, so the value of Z will
    decrease slightly.
  prefs: []
  type: TYPE_NORMAL
- en: From the description so far, you might think that the accelerometer is only
    useful for measuring the force of gravity. In fact, looking at [Figure 5-2](ch05.xhtml#ch5fig2),
    it is easy to imagine how shaking the micro:bit or causing any kind of acceleration
    on it would change the position of the mass.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXPERIMENT 6: REAL-TIME ACCELERATION PLOTTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mu has a great feature that will plot data coming from your micro:bit in real
    time. In this experiment, you’ll use the Plotter feature to see how the acceleration
    data changes when you move your micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE** *At the time of writing, the Plotter feature is available only on
    the Windows and Mac versions of the Mu Editor. The experiment also shows you how
    to get an overall measurement of acceleration, as well as separate readings for
    each of the X, Y, and Z dimensions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this experiment, you just need a micro:bit connected to your computer by
    a USB cable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This project uses Mu’s Plotter feature, which you’ll need Python for, so there’s
    no Blocks code for this. Find the code at *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
    The Python file for this experiment is *Experiment_06.py*. Flash the program onto
    your micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Plotter icon** in the Mu toolbar to open Mu’s Plotter, shown in
    [Figure 5-4](ch05.xhtml#ch5fig4). If you want to see the raw data that Mu is using
    to create graphs, click the **REPL** button.![Image](../images/05fig04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 5-4: Plotting accelerometer data using Mu*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tilt the micro:bit this way and that to see the changes in the Plotter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 5-4](ch05.xhtml#ch5fig4), there are four plots, each
    drawn in a different color. There is one plot for each dimension (blue for X,
    green for Y, and orange for Z). There is also a purple plot for the *net acceleration*,
    which is the combination of the forces in all three dimensions. We’ll explain
    how the net acceleration is calculated in “How It Works: Calculating Net Acceleration”
    on [page 11](ch01.xhtml#page_11).'
  prefs: []
  type: TYPE_NORMAL
- en: If you find that readings don’t appear in the REPL area of the screen, you may
    have an old micro:bit that needs an update for this to work. If this is the case,
    follow the instructions at *[https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/](https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/)*
    to update your device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the Python code that sends the accelerometer data to Mu’s plotter:'
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: x, y, z = accelerometer.get_values()
  prefs: []
  type: TYPE_NORMAL
- en: net = sqrt(x*x + y*y + z*z)
  prefs: []
  type: TYPE_NORMAL
- en: all = (x, y, z, net)
  prefs: []
  type: TYPE_NORMAL
- en: print(all)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(100)
  prefs: []
  type: TYPE_NORMAL
- en: Import the usual micro:bit library. Then import the square root function `sqrt`
    from the Python math library. We’ll use this function to calculate net acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `while` loop, which gets the readings for the X, Y, and Z dimensions
    from the accelerometer in one go using the `get_values` method. This line will
    return a *tuple*, which is a data structure capable of holding multiple values.
    Assign this tuple to three variables: `x`, `y`, and `z`. These will hold the three
    values, respectively. We use these variables to calculate the net acceleration,
    which we assign to the variable `net`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, send the net acceleration value along with the individual values for the
    X, Y, and Z accelerations to Mu for plotting. Mu expects the values you want to
    plot to be in the form of a tuple, so create a new tuple, `all`, that contains
    all four values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, print the tuple, which not only shows the values on Mu’s REPL (for
    more information on this, see “The REPL” on [page 23](ch01.xhtml#page_23)) but
    also provides these values to the Plotter. You can see the values printed in the
    bottom left of [Figure 5-6](ch05.xhtml#ch5fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Calculating Net Acceleration**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To calculate the net acceleration on the X, Y, and Z dimensions, you need to
    use some ancient Greek technology: the *Pythagorean theorem*.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, picture an acceleration force as a line with an
    arrow on the end. The arrow indicates the direction of the force, and the length
    of the line indicates how strong the force is. Lines like these are called *vectors*,
    and they are used often in physics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: Two-dimensional vectors*'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors are easier to understand in two dimensions than in three. [Figure 5-5](ch05.xhtml#ch5fig5)
    shows some two-dimensional vectors on the X and Y dimensions. The blue vector
    along the X axis has a strength of 4, and the green vector along the Y axis has
    a strength of 3.
  prefs: []
  type: TYPE_NORMAL
- en: The purple vector, equivalent to the combined effect of the green and blue vectors,
    is the *net vector* our program calculated earlier. The net vector is useful because
    its length tells you the overall strength of the force. To calculate the strength
    of the net vector, you can use the Pythagorean theorem.
  prefs: []
  type: TYPE_NORMAL
- en: The Pythagorean theorem says that in a right triangle (a triangle that has a
    right angle), the square of the *hypotenuse* (the triangle’s longest side) equals
    the sum of the squares of the other two sides.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at [Figure 5-5](ch05.xhtml#ch5fig5), you can see that we do indeed have
    a right triangle, because the blue and green vectors intersect at a right angle.
    Using the Pythagorean theorem, we can say that the square of the length of the
    purple line is equal to 32 + 42\. That’s 9 + 16, which equals 25\. So, the length
    of the purple line is the square root of 25, which is 5.
  prefs: []
  type: TYPE_NORMAL
- en: The math works in three dimensions as well as two. To find the length of a net
    vector for the dimensions X, Y, and Z, take the square root of the sum of the
    squares of all three X, Y, and Z vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-6](ch05.xhtml#ch5fig6) shows the three forces in the X, Y, and Z
    dimensions at some point in time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: Acceleration forces as vectors in three dimensions*'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the line of code that calculates the length of the single vector that
    would replace the X, Y, and Z vectors.
  prefs: []
  type: TYPE_NORMAL
- en: net = sqrt(x*x + y*y + z*z)
  prefs: []
  type: TYPE_NORMAL
- en: The X, Y, and Z values are found in `a[0]`, `a[1]`, and `a[2]`, respectively,
    in the tuple returned by `accelerometer.get_values().`
  prefs: []
  type: TYPE_NORMAL
- en: 'If the X, Y, and Z vectors were of lengths 4, 3, and 2, as shown in [Figure
    5-6](ch05.xhtml#ch5fig6), then calculating the square of the length of the net
    vector would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 × 4 + 3 × 3 + 2 × 2 = 16 + 9 + 4 = 29
  prefs: []
  type: TYPE_NORMAL
- en: So, the length of the vector would be the square root of 29, or about 5.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: TOOTHBRUSHING MONITOR**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Easy*'
  prefs: []
  type: TYPE_NORMAL
- en: The Mad Scientist is usually a bit distracted by all the interesting experiments
    going on, so they need some help brushing their teeth thoroughly. That’s why the
    Mad Scientist has used a micro:bit to create a toothbrush monitor ([Figure 5-7](ch05.xhtml#ch5fig7))
    that counts the number of strokes of the toothbrush.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A toothbrush monitor*'
  prefs: []
  type: TYPE_NORMAL
- en: The toothbrush monitor displays a score that ranges from 0 to 9 on the display.
    It increases the score by 1 for every 50 strokes of the toothbrush. When it counts
    a score of 10, it displays the happy face icon to show the Mad Scientist that
    toothbrushing is all done—until next time.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING** *Don’t let your micro:bit get wet—it might break!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, you will need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3V battery pack** To power the micro:bit. (The switched type battery box
    is preferred.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual toothbrush** Not the electric type'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × Elastic bands** To attach the micro:bit and battery pack to the toothbrush'
  prefs: []
  type: TYPE_NORMAL
- en: This project is intended for a manual toothbrush. Electric toothbrushes won’t
    work with this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Toothbrushing Monitor**.
    Once the program has opened, click **Download** and then copy the hex file onto
    your micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer to use Python, then download the code from the same website. For
    instructions for downloading and using the book’s examples, see “Downloading the
    Code” on [page 34](ch01.xhtml#page_34). The Python file for this experiment is
    *ch_05_Toothbrush_Monitor.py*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Plug the battery pack into the micro:bit and attach the battery and micro:bit
    to the toothbrush using elastic bands, as shown in [Figure 5-7](ch05.xhtml#ch5fig7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When positioning the bands, make sure they don’t hide the display and that you
    can still reach the battery pack’s on/off switch. Also, check that the bands aren’t
    over the reset switch on the back of the micro:bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Switch on the battery pack. Once it’s on, the micro:bit should show 0\. Brush
    vigorously, and after a little while, the display should show 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The programs for this project measure the acceleration and, if it is above a
    certain level, they add 1 to a count variable to record the number of brush strokes.
  prefs: []
  type: TYPE_NORMAL
- en: When the count of brush strokes becomes big enough to qualify as another point
    in the tooth-brushing score, then the score is also incremented and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, when the score gets to 10, the smiley face icon is shown on the
    micro:bit’s display.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0118-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is probably the most complex program so far in the book. The `on start`
    block defines four variables. Here’s what each of them does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**strokes per point** This specifies the number of brush strokes needed to
    advance your score by a point. If you are a lazy brusher, then you can decrease
    this number so that the points increase more quickly and you get your smiley-face
    reward faster. Note, however, that your next visit to the dentist may not be fun.'
  prefs: []
  type: TYPE_NORMAL
- en: '**score** This is the number that increases as you complete each set of 50
    brush strokes until it reaches 10.'
  prefs: []
  type: TYPE_NORMAL
- en: '**count** This is used to track the number of strokes completed since you earned
    a point. It starts at 0 and resets each time the score goes up.'
  prefs: []
  type: TYPE_NORMAL
- en: '**old mg** This variable holds the acceleration value in milli-gravities the
    last time it checked for a brush stroke. The program will compare this value to
    the new value to detect brush strokes.'
  prefs: []
  type: TYPE_NORMAL
- en: We make a `forever` block, and inside we have a `set XX to` block. From the
    drop-down, we select `mg` so that that this block puts the overall acceleration
    reading into a variable called `mg`. In the `acceleration (mg)` block’s drop-down
    menu, choose `strength`, which does the Pythagorean theorem calculation for you.
    (If you’re using MicroPython, you’ll have to calculate it yourself.)
  prefs: []
  type: TYPE_NORMAL
- en: Then a `set change in mg` block calculates the change in acceleration strength
    by subtracting the current strength from the previous strength (held in `old mg`).
    If the change is greater than 800—indicating the start of a brushing movement—the
    `count` increases by 1\. The value of 800 was chosen by looking at [Figure 5-8](ch05.xhtml#ch5fig8),
    which is a plot of the net acceleration for a short period of vigorous toothbrushing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: A plot of net acceleration during toothbrushing*'
  prefs: []
  type: TYPE_NORMAL
- en: On the plot, each peak represents one brush stroke, with the maximum net acceleration
    occurring when the brush changes direction. The value of 800 is enough to capture
    most strokes, since most strokes produce a change in acceleration of around 1,000\.
    If you brush your teeth quite gently, you might need to decrease this threshold,
    or you could be left brushing your teeth forever, never racking up a large enough
    score to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Next, place the first `if` block to detect acceleration large enough to indicate
    a brush stroke and, inside that, place a second `if` block that checks the value
    of `count`. If the value has exceeded the number you set earlier in `strokes per
    point`, then the program adds 1 to `score` and displays the new `score` value.
    Finally, the program checks whether `score` is greater than 9 and, if it is, displays
    a smiley-face icon.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the MicroPython version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: strokes_per_point = 50
  prefs: []
  type: TYPE_NORMAL
- en: old_mg = 0
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: change_in_mg = 0
  prefs: []
  type: TYPE_NORMAL
- en: score = 0
  prefs: []
  type: TYPE_NORMAL
- en: mg = 0
  prefs: []
  type: TYPE_NORMAL
- en: display.show(str(score))
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: x, y, z = accelerometer.get_values()
  prefs: []
  type: TYPE_NORMAL
- en: mg = sqrt(x*x + y*y + z*z)
  prefs: []
  type: TYPE_NORMAL
- en: change_in_mg = mg - old_mg
  prefs: []
  type: TYPE_NORMAL
- en: old_mg = mg
  prefs: []
  type: TYPE_NORMAL
- en: 'if change_in_mg > 800:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if count > strokes_per_point:'
  prefs: []
  type: TYPE_NORMAL
- en: score += 1
  prefs: []
  type: TYPE_NORMAL
- en: display.show(str(score))
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if score > 9:'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.HAPPY)
  prefs: []
  type: TYPE_NORMAL
- en: The MicroPython code mirrors the Blocks code almost exactly, except that the
    overall strength of the force has to be calculated since MicroPython has no built-in
    function for this for the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You could use this project as a *pedometer*—a device that measures how many
    steps you take when walking or running. To do this, try simplifying the code to
    get rid of the score variable, because we are now only interested in the number
    of steps (equivalent to the strokes when toothbrushing). You’ll want your code
    to keep track of steps and then, when you press button A, display the number of
    steps you’ve taken. To test it, tuck the project into your sock (remove the toothbrush
    first) and walk around while counting your steps in your head. Then see how many
    steps the pedometer says you’ve taken. If the measurement isn’t accurate, you
    may need to change the acceleration threshold from 800 to make the pedometer more
    or less sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXPERIMENT 7: LOGGING ACCELERATION TO A FILE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Plotter built into Mu is great if you don’t mind keeping your micro:bit
    tethered to your computer with a USB cable. However, sometimes the Mad Scientist
    finds it useful to record readings on the micro:bit remotely for later analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this experiment, you’ll use your micro:bit to record accelerometer readings
    in a file saved on the micro:bit. You can wave the micro:bit around and do various
    other tests on it and then look at charts of the measured acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0122-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The program will take about 60 readings per second, and it can record about
    45 seconds’ worth of samples before the micro:bit runs out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this experiment, you’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3V battery pack**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This project uses the micro:bit’s local filesystem, which is not available in
    Blocks code at the time of this writing. That means you’ll have to use Python
    for this experiment. Download the code from *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*,
    along with instructions for downloading and using the book examples. The Python
    file for this experiment is *Experiment_07.py*. Load the program onto your micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you turn on the micro:bit, its display will show an X. This means it isn’t
    recording any readings. When you click button A, the icon will change to a check
    mark, and the micro:bit will start recording. It will stop recording when you
    press button A again, at which point it will save the accelerometer readings in
    a file that you can transfer to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test this out, press **button A**, wave the micro:bit around, and press **button
    A** again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To transfer the file containing the readings to your computer, use Mu’s *Files*
    feature. Connect your micro:bit to your computer with a USB cable and click the
    **Files** icon in Mu’s toolbar ([Figure 5-9](ch05.xhtml#ch5fig9)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottom of the window now has two columns. On the left are the files saved
    on the micro:bit. In [Figure 5-9](ch05.xhtml#ch5fig9), there is only one file,
    *data.txt*. On the right are the files in Mu’s code directory, which is in your
    home directory under *mu code*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/05fig09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 5-9: Mu’s File feature in action*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To copy the file from the micro:bit, just drag it from the left area to the
    right area in the Mu window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with Experiment 6, earlier in the chapter, if the Files feature doesn’t work
    in Mu, you may have an old micro:bit that needs an update. In this case, follow
    the instructions at *[https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/](https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/)*
    to update your device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’ve transferred the data from the micro:bit to your computer, you’ll
    plot the data by importing the file into a spreadsheet, such as Excel or Google
    Sheets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The procedure is a bit different depending on which spreadsheet software you
    use. I’ll show you how to use Google Sheets since it’s free. You just need to
    be logged into a Google account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Visit *[https://docs.google.com/spreadsheets/](https://docs.google.com/spreadsheets/)*
    and click the **Blank** option in the *Start a new spreadsheet* area. Then, from
    the Google Sheets menu, select **File**▸ **Import**. From the pop-up window that
    appears, select the **Upload** tab and navigate to the *data.txt* file that you
    copied onto your computer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The recorded data should appear in the first column of your spreadsheet. Select
    the column and click **Insert**▸**Chart** to create a chart of the data, like
    the one shown in [Figure 5-10](ch05.xhtml#ch5fig10).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/05fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: Charting data recorded on the micro:bit*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is the MicroPython code for this experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: filename = 'data.txt'
  prefs: []
  type: TYPE_NORMAL
- en: recording = False
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.NO)
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_a.was_pressed():'
  prefs: []
  type: TYPE_NORMAL
- en: recording = not recording
  prefs: []
  type: TYPE_NORMAL
- en: 'if recording:'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.YES)
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(filename)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: fs = open(filename, 'w')
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.NO)
  prefs: []
  type: TYPE_NORMAL
- en: fs.close()
  prefs: []
  type: TYPE_NORMAL
- en: 'if recording:'
  prefs: []
  type: TYPE_NORMAL
- en: x, y, z = accelerometer.get_values()
  prefs: []
  type: TYPE_NORMAL
- en: net = sqrt(x*x + y*y + z*z)
  prefs: []
  type: TYPE_NORMAL
- en: fs.write(str(net))
  prefs: []
  type: TYPE_NORMAL
- en: fs.write('\n')
  prefs: []
  type: TYPE_NORMAL
- en: sleep(10)
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit can save only a limited amount of data, so import the `os` package,
    which will let you delete any data already on your micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: Set the data filename as `data.txt`. You can change the name of this file by
    altering the value of the `filename` variable, though I recommend keeping it as
    is until you’ve gotten the program working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a variable called `recording` to keep track of whether the project is
    recording or not. This is toggled between `True` and `False` in the main `while`
    loop every time button A is pressed to start and stop the recording of data. That’s
    what the line `recording = not recording` does: if `recording` is `True`, the
    code sets it to `False`, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `while True` loop to run forever. Inside this loop are two `if` statements.
    The first tells the micro:bit what to do when button A is pressed, and the second
    checks whether we are in recording mode. When button A is first pressed, recording
    starts, the screen displays the `YES` image, and the `os.remove` method deletes
    the existing data file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve put the `remove` command within a `try: except:` Python structure. This
    ensures that if any error occurs (in particular, if the data file can’t be deleted
    because it’s not there), the program ignores the error and doesn’t crash the program.'
  prefs: []
  type: TYPE_NORMAL
- en: The program then opens the file with a mode of `w`, which means you can write
    in it. When button A is pressed again, the screen displays the `NO` image and
    the file closes.
  prefs: []
  type: TYPE_NORMAL
- en: Also contained in the main `while` loop is another `if` block that writes a
    reading from the accelerometer to the file as long as `recording` is `True`. If
    the program runs for too long and fills up all the file space, it will give an
    error. However, the data that it wrote before it ran out of room will still be
    available.
  prefs: []
  type: TYPE_NORMAL
- en: The `sleep` command at the end of the recording slows down the recording process
    so that you don’t run out of memory too quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This experiment will let you measure accelerations in various practical situations.
    You could, for example, record the accelerations on your micro:bit when you throw
    it into the air. If you plan to try this, then it’s wise to take a few precautions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Choose an environment with soft ground. That
    way, if you fail to catch your micro:bit, it might survive. During experiments
    like this, it’s not unusual for a battery to come loose or fall out of its holder.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Don’t throw your micro:bit somewhere where it
    may hit someone in the head.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Attach the micro:bit to the battery pack. Elastic
    bands are good for this.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Put your micro:bit in a case. A Kitronik MI:pro
    case with MI:power battery backpack, shown in [Figure 5-11](ch05.xhtml#ch5fig11),
    is a great choice. If you use this case, you won’t need a battery pack, because
    the case contains a tiny 3V battery.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-11: Kitronik MI:pro case with MI:power battery backpack*'
  prefs: []
  type: TYPE_NORMAL
- en: You could also measure acceleration by securely attaching a string to the micro:bit
    and swinging it gently in circles. Again, be careful as the micro:bit could easily
    become detached from its string, breaking or hurting someone nearby.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem used by the micro:bit is very limited; it has only about 40KB
    available for storage. Therefore, previous files may be erased every time you
    flash a new program onto the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: ACCELERATION DISPLAY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Easy*'
  prefs: []
  type: TYPE_NORMAL
- en: This project, shown in [Figure 5-12](ch05.xhtml#ch5fig12), allows you to see
    the micro:bit’s acceleration on its display. When the micro:bit is at rest, the
    middle row of LEDs on the display will be lit. If you rapidly move the micro:bit
    up, then the line of LEDs will move up the display, like an elevator, in response
    to the increase in the net force. Similarly, if you quickly move the micro:bit
    down, the line will move down, indicating the reduced effect of gravity, as if
    you were accelerating downward in an elevator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: A Micro:bit acceleration display*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this project, you just need a micro:bit. However, it’s useful to have a
    battery pack if you want to make this project more mobile.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the MI:pro case and MI:power combination shown in [Figure
    5-11](ch05.xhtml#ch5fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Acceleration Display**.
    Once the program has opened, **Download** and then copy the hex file onto your
    micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer to use Python, then download the code from the same website. For
    instructions for downloading and using the book’s examples, see “Downloading the
    Code” on [page 34](ch01.xhtml#page_34). The Python file for this experiment is
    *ch_05_Acceleration_Display.py*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try moving your micro:bit up and down, watching how acceleration in various
    directions affects the reading. If you can take your micro:bit for a ride in an
    elevator, watch as the display shows whether you’re going up or down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code first takes a reading of acceleration and then uses a bit of math to
    decide which row of the display to light up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0129-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the code for this project is contained in the `forever` block. It first
    reads the net acceleration and then calculates a value for `y`. Here, `y` represents
    the row of the display that will light up. When the micro:bit is stationary, the
    only force acting on it is gravity, at a net force of 1,000 mg (1 g). Therefore,
    the program subtracts 1,000 from the net acceleration and divides the result by
    100, so that each 1/10 of g will cause a change of 1 row in the display. Finally,
    we add 2 to this result to display row 2 (the middle row of LEDs, if you start
    counting at 0) by default.
  prefs: []
  type: TYPE_NORMAL
- en: Use two `if` blocks to make sure that the value of `y` remains between 0 and
    4 (for the 5 rows). To draw the correct row, first clear the screen so the old
    row isn’t displayed along with the new reading. Then use a `for` loop to loop
    over each of the five LEDs for that row, which are represented by values of `x`,
    to turn them on.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s the MicroPython equivalent of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: x, y, z = accelerometer.get_values()
  prefs: []
  type: TYPE_NORMAL
- en: acc = sqrt(x*x + y*y + z*z)
  prefs: []
  type: TYPE_NORMAL
- en: y = int(2 + (acc - 1000) / 100)
  prefs: []
  type: TYPE_NORMAL
- en: display.clear()
  prefs: []
  type: TYPE_NORMAL
- en: 'if y < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'if y > 4:'
  prefs: []
  type: TYPE_NORMAL
- en: y = 4
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(0, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: display.set_pixel(x, y, 9)
  prefs: []
  type: TYPE_NORMAL
- en: This code is similar to the Blocks code, but you have to calculate the net acceleration
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The micro:bit’s accelerometer opens up a lot of opportunities for projects that
    detect the movement or orientation of a micro:bit. In this chapter, you’ve explored
    some interesting ways you can use the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also learned how to plot data coming from the micro:bit using Mu’s Plotter
    and record readings into a file to chart and analyze later.
  prefs: []
  type: TYPE_NORMAL
