<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>5 TESTING YOUR CODE WITH SIMULATION</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch5">
<span class="CN"><span aria-label=" Page 67. " epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TESTING YOUR CODE WITH SIMULATION</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">There are two ways to find the bugs that will inevitably arise in an FPGA design. The first is to program the FPGA, run it, and see what happens. This is called finding bugs <i>on hardware</i>. The other way is to use a computer to inject test cases into your FPGA code to see how the code responds <i>before</i> you actually program the FPGA. This is called finding bugs <i>in simulation</i>.</p>
<p class="TX">For very simple projects, such as the ones we’ve explored so far in this book, jumping straight to programming the FPGA without any kind of simulation may be a reasonable approach (and it’s the one we’ve taken up to this point). However, as your FPGA designs grow more complicated, finding bugs on hardware becomes incredibly difficult. In nearly all cases, it’s significantly easier to find bugs in simulation. After thoroughly simulating and debugging a design, there’s nothing more satisfying than finally programming your FPGA and having everything work perfectly the first time.</p>
<p class="TX"><span aria-label=" Page 68. " epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/>In this chapter, you’ll learn how simulation works and see why it’s an essential step in the FPGA design process. We’ll explore a free simulator tool and I’ll introduce the testbench to show how you can write test code to stress your design. You’ll try out these concepts by adding a debounce circuit to the LED-toggling project from the previous chapter (<span class="Xref">Project #3</span>) and simulating the design. Finally, we’ll take a look at verification, which is a more formal and rigorous process for testing out FPGA and ASIC designs.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-53"/><samp class="SANS_Futura_Std_Bold_B_11">Why Simulation Matters</samp></h2>
<p class="TNI1">Simulation is important because your FPGA is essentially a black box, as shown in <a href="#fig5-1">Figure 5-1</a>. When you program the FPGA, you’re able to change the inputs and see how the outputs respond, but you’re unable to see the details of what’s going on inside the box itself. You can’t follow the individual variables and data signals as they flow inside your FPGA.</p>
<figure class="IMG"><img alt="" class="img30" id="fig5-1" src="../images/Figure5-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: What’s in the box?</samp></p></figcaption>
</figure>
<p class="TX">If something goes wrong inside that black box (and it will), and the output isn’t what you expect, figuring out the problem is very difficult. The solution is to use a computer to simulate the inner workings of the black box in a way you can follow. Simulation effectively opens up the black box of your FPGA so you can see what’s going on inside.</p>
<p class="TX">Let me give you an example of how useful this can be. In a past job, I had a coworker who was trying to fix a problem with his FPGA design. For some reason the data was getting mixed up inside the FPGA. He spent weeks using oscilloscopes and logic analyzers to send data off the FPGA so he could try to find where the issue was coming from. At one point I asked him if he had simulated the design at all. He had not: he didn’t have any experience with simulation and didn’t feel he could take the time out to learn. I checked his code out of revision control and put together a simulation for it, and within a few hours had found the problem.</p>
<p class="TX">Simulating your design allows you to stress it to see how it reacts. In this case, I was able to re-create the exact failure in simulation and fix the issue very quickly. Ironically, in the time my coworker had spent attempting to debug the problem on hardware, he could easily have learned how to do the simulation himself. It’s an even more attractive option when you consider that once you know how simulation works, you can use that knowledge again and again.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-54"/><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">FPGA Simulation Tools</samp></h2>
<p class="TNI1">There are several popular FPGA simulation tools available. FPGA build tools often have a simulation tool bundled with them, in one large downloadable package; FPGA companies know that their designers want to run simulations, and they want to make it easy to do that. These tools are usually free and convenient, but they can be many gigabytes in size and their complexity can be overwhelming for beginners.</p>
<p class="TX">An alternative solution to the large FPGA tools is to use a standalone simulator. The benefit to this is that if you switch from Intel (Altera) to AMD (Xilinx), for example, you don’t need to learn a whole new tool; your simulator can stay the same. There are two popular standalone simulation tools that I generally recommend: ModelSim and EDA Playground. ModelSim is probably the most popular commercial simulator. It can be downloaded and installed on Windows and Linux. A full license is expensive, costing around $2,000, but a free version with limited features is available.</p>
<p class="TX">EDA Playground, by contrast, is a freely available web-based simulator. I recommend using it when you’re first learning about FPGA design for a few reasons. First, it’s free. Second, since it’s web-based, there’s no download required. Finally, EDA Playground allows you to share your code with others via a web link. For the purposes of this book, we’ll focus on this tool.</p>
<p class="TX">To get started with EDA Playground, first navigate to <a href="https://edaplayground.com"><i>https://<wbr/>edaplayground<wbr/>.com</i></a>. To run simulations and save your progress, you’ll need to create an account and log in. Once you do so, you should see a screen like the one in <a href="#fig5-2">Figure 5-2</a>.</p>
<figure class="IMG"><img alt="" class="img100" id="fig5-2" src="../images/Figure5-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The EDA Playground main screen</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/>Notice that there are two main code windows. The window on the right, titled <i>design.sv</i>, is where the FPGA design code you want to test goes. This code is typically called the <i>unit under test (UUT)</i> or <i>device under test (DUT)</i>. The window on the left, called <i>testbench.sv</i>, is where you write <i>testbenches</i>, code that will exercise your FPGA design during simulation. We’ll discuss how testbenches work in the next section.</p>
<p class="TX">By default, EDA Playground is configured for SystemVerilog/Verilog designs, which is why the two window labels have <i>.sv</i> (SystemVerilog) file extensions. If you wish to reconfigure EDA Playground for VHDL, select <b>VHDL</b> in the drop-down menu under Testbench + Design on the left side of the window.</p>
<aside aria-labelledby="box5" class="box">
<h3 class="BoxTitle" id="box5"><samp class="SANS_Dogma_OT_Bold_B_11">SYSTEMVERILOG</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">SystemVerilog is a superset of Verilog, meaning it has all the features of Verilog</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and more.</samp> <samp class="SANS_Futura_Std_Book_11">Anything you write with Verilog will also work with SystemVerilog. SystemVerilog is often used in simulation, even of VHDL designs. There are a few reasons for this. For one, SystemVerilog offers many high-level language features, such as classes and interfaces, that make creating your testbench code easier and make that code more reusable across projects. In addition, it provides comprehensive support for assertions, which is a significant advantage when creating simulations. In VHDL and vanilla Verilog, assertions are much more limited.</samp></p>
</aside>
<p class="TX">Before you can run code in EDA Playground, you’ll need to select a simulator tool. This is the actual product that will run your code. You can play around with different tools listed in the drop-down menu under Tools &amp; Simulators to see if you prefer one over another. In general, I find that they behave similarly, though some are exclusively for Verilog or VHDL. I’ve had good luck using Mentor Questa or Aldec Riviera.</p>
<p class="TX">Another neat feature of EDA Playground is the Examples section of the toolbar. Here, you can explore sample testbenches that have been made freely available. You can see how they work and modify them for your own experiments, and perhaps gain some insights into clever ways to write your own code.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_B_11">The Testbench</samp></h2>
<p class="TNI1">The purpose of a testbench is to exercise your UUT in a simulation environment so you can analyze it and see if it’s behaving as expected. The testbench code instantiates the UUT. As you can see in <a href="#fig5-3">Figure 5-3</a>, the testbench provides all the required inputs to the UUT and monitors all the outputs.</p>
<span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img30" id="fig5-3" src="../images/Figure5-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: A testbench exercises a UUT so you can analyze it.</samp></p></figcaption>
</figure>
<p class="TX">If your UUT has a clock as an input, for example, the testbench will need to generate that clock and feed it in to the UUT. Similarly, if there’s a data interface into your UUT, the testbench will likely need to generate some sample data to supply to that interface. The testbench monitors all the outputs from the UUT, allowing it to see how the UUT responds to the input data. During the simulation, you’ll also be able to dive into the UUT itself to see how all of its internal signals are behaving in response to the testbench’s inputs. You can monitor every element of your design—every register, clock, wire, memory, and so on—and make sure they’re all behaving as intended.</p>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing a Testbench</samp></h3>
<p class="TNI1">Let’s take a look at a simple example by writing a testbench for the AND gate project from <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> (<span class="Xref">Project #2</span>). First, to review, here’s the original project code that we want to test:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module And_Gate_Project
 (input i_Switch_1,
  input i_Switch_2,
  output o_LED_1);
assign o_LED_1 = i_Switch_1 &amp; i_Switch_2;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity And_Gate_Project is
  port (
    i_Switch_1 : in std_logic;
    i_Switch_2 : in std_logic;
    o_LED_1    : out std_logic);
end entity And_Gate_Project;
architecture RTL of And_Gate_Project is
begin
  o_LED_1 &lt;= i_Switch_1 and i_Switch_2;
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>Enter the module or entity’s code into the <i>design.sv</i> or <i>design.vhd</i> window on the right side of EDA Playground. To test the code completely, we want to exercise it to make sure that the output behaves as intended with all possible input combinations. In this case, the total range of input combinations is pretty small: since there are two inputs, there are just four possible combinations to test in order to fully exercise the UUT. We’ll create a testbench in Verilog and VHDL to instantiate the UUT and test it by passing in each of the four input combinations. Enter the following code into the <i>testbench.sv</i> or <i>testbench.vhd</i> window in EDA Playground:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> module And_Gate_TB();
  reg r_In1, r_In2;
  wire w_Out;
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> And_Gate_Project UUT
  (.i_Switch_1(r_In1),
   .i_Switch_2(r_In2),
   .o_LED_1(w_Out));
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> initial
    begin
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> $dumpfile("dump.vcd"); $dumpvars;
       r_In1 &lt;= 1'b0;
       r_In2 &lt;= 1'b0;
       #10;
       r_In1 &lt;= 1'b0;
       r_In2 &lt;= 1'b1;
       #10;
       r_In1 &lt;= 1'b1;
       r_In2 &lt;= 1'b0;
       #10;
       r_In1 &lt;= 1'b1;
       r_In2 &lt;= 1'b1;
       #10;
       $finish();
    end
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library IEEE;
use IEEE.std_logic_1164.all;
use std.env.finish;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> entity And_Gate_TB is
end entity And_Gate_TB;
architecture behave of And_Gate_TB is
  signal r_In1, r_In2, w_Out : std_logic;
begin
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> UUT : entity work.And_Gate_Project
  port map (
    i_Switch_1 =&gt; r_In1,
    i_Switch_2 =&gt; r_In2,
    o_LED_1    =&gt; w_Out);
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> process is
  begin
    r_In1 &lt;= '0';
    r_In2 &lt;= '0';
    wait for 10 ns;
    r_In1 &lt;= '0';
    r_In2 &lt;= '1';
    wait for 10 ns;
    r_In1 &lt;= '1';
    r_In2 &lt;= '0';
    wait for 10 ns;
    r_In1 &lt;= '1';
    r_In2 &lt;= '1';
    wait for 10 ns;
    wait for 10 ns;
    finish;
  end process;
end behave;</code></pre>
<p class="TX"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>First, notice that this is the first time we’ve seen a Verilog module or VHDL entity that has no inputs or outputs declared <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This is because this testbench doesn’t connect to any external signals; as you saw earlier, in <a href="#fig5-3">Figure 5-3</a>, the testbench itself provides the inputs.</p>
<p class="TX">Inside the module/entity, we instantiate the UUT <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We connect the inputs of the UUT to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, signals that we declare in the testbench. These signals will be the stimuli provided to see how the UUT responds. We’ll be monitoring the output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>, to see how it reacts to changing inputs. I like to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_</samp> prefix on signal names to represent wires, or interconnections within the FPGA. Remember, we want to make sure the AND gate is working as expected.</p>
<p class="TX">We start driving the stimuli (inputs) within an <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> block in Verilog or a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block in VHDL <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This block will start at the beginning of the simulation and will execute from top to bottom in sequence. We send each of the four possible input combinations to the UUT, one after the other. Using delay statements, we add a 10 ns pause between each input combination to allow time for the simulation to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp> signal after each change. In Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp> delay feature, and in VHDL we use <samp class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp>. As you’ll see later in this chapter, these time-based delays—indeed, any reference to the passage of time—are non-synthesizable, meaning they would not work on an actual FPGA; however, they work perfectly well in simulation.</p>
<p class="TX">In the Verilog version, note that EDA Playground requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">$dumpfile</samp> directive <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. This allows the simulator to generate waveforms, which we’ll cover in the next section. This line isn’t required in VHDL.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-57"/><span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running a Testbench and Viewing Waveforms</samp></h3>
<p class="TNI1">Running a testbench generates <i>waveforms</i>, or visual representations of the signals in your test environment, showing you how they change over time. Waveforms are a powerful tool for investigating failures in an FPGA design during simulation; the more you work with FPGAs, the more time you’ll spend staring at waveforms. EDA Playground makes examining waveforms easy with its built-in waveform viewer, EPWave.</p>
<p class="TX">Let’s run our AND gate testbench and view the resulting waveform in EPWave. First, check the <b>Open EPWave After Run</b> checkbox in the Tools &amp; Simulators section of the toolbar on the left side of the EDA Playground window. If you’re using VHDL, you will need to specify which entity is the top of your design. To do that, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">And_Gate_TB</samp> in the Top Entity dialog. Then choose a simulator tool from the drop-down menu and hit <b>Run</b>. <a href="#fig5-4">Figure 5-4</a> shows the resulting waveform.</p>
<figure class="IMG"><img alt="" class="img100" id="fig5-4" src="../images/Figure5-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The AND gate testbench waveform output</samp></p></figcaption>
</figure>
<p class="TX">Here we see all the signals that exist in the design, and we can note the time in nanoseconds when each signal changes from high to low or low to high. The top three signals (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>) are the testbench signals. The bottom three (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>) are in the UUT. Since we wired the testbench and UUT signals together when we instantiated the UUT, the corresponding testbench/UUT signals look the same. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> has the same waveform as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>. Note that if the UUT had other internal signals that weren’t brought out of the module, you would be able to see waveforms for those as well, and they wouldn’t have a corresponding testbench signal.</p>
<p class="TX">Looking at the waveform, we can see that the UUT is working as expected. The AND gate output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>) is high only when both inputs are also high. When only one input is high, or when both inputs are low, the output is low. As you examine the waveform, take a look back at the testbench code and notice how the changes in the waveform correspond to the statements in the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. In the code, for example, both inputs start out low, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp> goes high after a 10 ns pause. Looking at the 10 ns mark in the waveform, you can see that this is where <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp> change from low to high.</p>
<p class="TX">Although this was a simple example, it illustrates the power of the testbench to simulate your FPGA design and let you see everything that is happening. You can monitor all the interactions within the design, and if a signal isn’t behaving as expected, you can investigate why that is, modify <span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>your code, and run the testbench again to generate a new waveform. Often when debugging issues, I’ll rerun simulations dozens of times until my design is behaving as desired.</p>
<p class="TX">In this case, since we were testing a single basic module, we were able to evaluate everything using a single testbench file. For more complicated simulations, however, testbenches can contain many different files that all work together to simulate, monitor, and check your design to make sure it’s behaving as intended.</p>
<p class="TX">You’ll see how testbenches work in more detail in our next project, where we’ll write a testbench and simulate the FPGA design prior to programming the hardware. This will help you gain confidence that your code is working, and it will allow you to identify and fix any bugs early in the process. The project also illustrates how the concept of time works on an FPGA, so even if you don’t have an FPGA to program, I recommend reading through this section.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h-58"/><span class="NoteHead"><samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Debouncing a Switch</samp></span></h2>
<p class="TNI1">In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, we programmed an FPGA to toggle an LED at the push of a button. However, there was a problem: pushing the button didn’t consistently toggle the state of the LED. This is because any physical switch, including a push-button or toggle switch, is subject to <i>bouncing</i>, or rapid signal fluctuations that occur when the switch is toggled or flipped. Bouncing happens when the metal contacts inside the switch come together and move apart quickly before they have time to settle into the stable state. <a href="#fig5-5">Figure 5-5</a> illustrates how this affects the switch’s output signal.</p>
<figure class="IMG"><img alt="" class="img60" id="fig5-5" src="../images/Figure5-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: Bouncing in a mechanical switch</samp></p></figcaption>
</figure>
<p class="TX">If you didn’t know about bouncing, you would probably expect the switch to behave like the top half of <a href="#fig5-5">Figure 5-5</a>. The button is pressed, and the output immediately goes from low to high. However, in the real world bouncing creates glitches in the output signal, which show up as rapid <span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>low-to-high-to-low transitions of the output signal, before it finally stays high. Again, this is due to the mechanical switch contacts quickly coming together and moving apart before settling into a stable output state.</p>
<p class="TX">The code in our LED toggling project was looking for a single falling edge to indicate the press and release of the button, but due to the bouncing, the FPGA was seeing many falling edges per press/release. If it saw an odd number of falling edges during the bouncing of the switch, then the LED toggled successfully. If it saw an even number of falling edges, however, the LED didn’t appear to change state, since each pair of falling edges effectively canceled each other out.</p>
<p class="TX">The number of bounces on a switch is somewhat random, so pushing the switch enough times got the LED to toggle successfully. Still, it would be better if the LED toggled as expected each time the switch is pressed and released. To make this happen, we need to add a <i>debounce filter</i> to the switch. That is, we need to program the FPGA to ignore the bounces. <a href="#fig5-6">Figure 5-6</a> illustrates how this will work.</p>
<figure class="IMG"><img alt="" class="img60" id="fig5-6" src="../images/Figure5-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: The Project #4 block diagram</samp></p></figcaption>
</figure>
<p class="TX">We’ll add a debounce filter to the code from the previous project to ensure that a single press of the button only toggles the LED once. The signal from the switch will pass through the debounce filter before going on to the LED-toggling logic we wrote in the last chapter.</p>
<p class="TX">We create a debounce filter by making sure that the input from the switch is stable for some amount of time before allowing the output driving the LED to change. We therefore need to have some concept of how much time has passed in our FPGA. However, introducing the notion of time into an FPGA design raises some interesting challenges.</p>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring Time on an FPGA</samp></h3>
<p class="TNI1">Time doesn’t exist inherently in an FPGA. The FPGA doesn’t automatically know if it’s Saturday at 11:00 <span class="Caps">AM</span>, or how to wait for 100 ms, for example. To be sure, there are parts of Verilog and VHDL code that refer to time. For example, we already saw how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp> in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp> in VHDL to add 10 ns delays to our AND gate testbench. To give another example, in Verilog you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> to get the current time, while in VHDL the reserved word <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> gets a timestamp of the current time. However, while <span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>features like these will work perfectly well in simulation, they will 100 percent not work on your FPGA. They <i>aren’t synthesizable</i>.</p>
<p class="TX">We’ve already talked about synthesis a few times. It’s the part of the build process where the FPGA tool turns your Verilog or VHDL code into flip-flops, LUTs, and other components. Unfortunately, synthesis tools can’t synthesize anything relating to time. It’s just not possible. As a result, language constructs like <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp> are simply ignored or will create errors during synthesis. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, we’ll look more closely at what features of VHDL and Verilog aren’t able to be synthesized in an FPGA. For now, take it for granted that we can’t use some of these built-in features relating to time.</p>
<p class="TX">If time doesn’t exist in an FPGA, how can you keep track of how much time has passed for the purposes of debouncing a switch or one of the many other time-related tasks you may wish your FPGA to perform? The answer is to <i>count clock cycles</i>. If you know how many clock cycles have occurred, and you know the period of the clock, you’ll know how much time has elapsed. Let’s walk through an example.</p>
<p class="TX">Say you have a clock that oscillates at 25 MHz, and that the clock’s period—the duration of a single cycle—is 40 ns. Given these specifications, how many clock cycles would it take for 400 ns to elapse? Answer: 10. And for 4,000 ns to elapse? Answer: 100. Simply divide the amount of time you want to wait by the period of the clock to get the number of clock cycles you need to count before that amount of time has elapsed. This technique is going to be critical in our debounce project.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp></h3>
<p class="TNI1">Let’s look at how to implement the debounce filter. We’ll start with the top-level module, which instantiates and links together two lower-level modules, one for debouncing the switch and the other for toggling the LED:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Debounce_Project_Top
  (input  i_Clk,
  input  i_Switch_1,
  output o_LED_1);
  wire w_Debounced_Switch;
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> Debounce_Filter <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> #(.DEBOUNCE_LIMIT(250000)) Debounce_Inst
  (.i_Clk(i_Clk),
   .i_Bouncy(i_Switch_1),
   .o_Debounced(w_Debounced_Switch));
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> LED_Toggle_Project LED_Toggle_Inst
  (.i_Clk(i_Clk),
   .i_Switch_1(w_Debounced_Switch),
   .o_LED_1(o_LED_1));
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Debounce_Project_Top is
  port (
    i_Clk       : in  std_logic;
    i_Switch_1  : in  std_logic;
    o_LED_1     : out std_logic
    );
end entity Debounce_Project_Top;
architecture RTL of Debounce_Project_Top is
  signal w_Debounced_Switch : std_logic;
begin
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> Debounce_Inst : entity work.Debounce_Filter
    generic map(
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> DEBOUNCE_LIMIT =&gt; 250000)
    port map (
      i_Clk      =&gt; i_Clk,
      i_Bouncy   =&gt; i_Switch_1,
      o_Debounced =&gt; w_Debounced_Switch);
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> LED_Toggle_Inst : entity work.LED_Toggle_Project
    port map (
      i_Clk      =&gt; i_Clk,
      i_Switch_1 =&gt; w_Debounced_Switch,
      o_LED_1    =&gt; o_LED_1);
end architecture RTL;</code></pre>
<p class="TX">The code matches the block diagram in <a href="#fig5-6">Figure 5-6</a>. At the highest level we have <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>, which instantiates two other modules. The first is the new debounce filter <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which we’ll examine next. The second is the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp> module that we created in the previous chapter <span aria-label="annotation3" class="CodeAnnotation">❸</span>. It’s worth taking a minute to follow the signals here. We can see the input signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> going into the debounce filter. Out of that comes <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Debounced_Switch</samp>, which is the debounced version of this input. This is passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle _Project</samp> module. The output of that module is <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>, which will be connected to the LED pin on your development board. Note that indicating the direction of your signals via their names, as we do here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp> prefixes, becomes very helpful as your designs get larger and incorporate more signals.</p>
<p class="TX">It’s important to highlight the value of creating reusable modules when writing FPGA code. Rather than writing all the project’s code from scratch, here we’re able to reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp> module from the previous chapter and improve its functionality by interfacing it with another module. Another way to make modules reusable is to incorporate Verilog <i>parameters</i> or VHDL <i>generics</i>. These are variables within a module that you can override from higher-level code. We do this when we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp> module. Specifically, we override the module’s parameter/generic called <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">250000</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. As you’ll see later, this value sets the number of clock cycles to <span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>wait while debouncing the switch. Coding it as a parameter/generic makes it easy to modify the value. In general, parameters (in Verilog) and generics (in VHDL) are a very useful way to keep code portable. They let you change the behavior of a module without having to actually modify the module’s file.</p>
<p class="TX">Let’s now examine the code of the debounce filter module:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Debounce_Filter #(parameter DEBOUNCE_LIMIT = 20) (
  input  i_Clk,
  input  i_Bouncy,
  output o_Debounced);
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> reg [$clog2(DEBOUNCE_LIMIT)-1:0] r_Count = 0;
  reg r_State = 1'b0;
  always @(posedge i_Clk)
  begin
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (i_Bouncy !== r_State &amp;&amp; r_Count &lt; DEBOUNCE_LIMIT-1)
     begin
       r_Count &lt;= r_Count + 1;
     end
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> else if (r_Count == DEBOUNCE_LIMIT-1)
     begin
       r_State &lt;= i_Bouncy;
       r_Count &lt;= 0;
     end
     else
     begin
     <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Count &lt;= 0;
     end
   end
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> assign o_Debounced = r_State;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Debounce_Filter is
  generic (DEBOUNCE_LIMIT : integer := 20);
  port (
    i_Clk       : in  std_logic;
    i_Bouncy    : in  std_logic;
    o_Debounced : out std_logic
    );
end entity Debounce_Filter;
architecture RTL of Debounce_Filter is
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> signal r_Count : integer range 0 to DEBOUNCE_LIMIT := 0;
  signal r_State : std_logic := '0';
begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (i_Bouncy /= r_State and r_Count &lt; DEBOUNCE_LIMIT-1) then
         r_Count &lt;= r_Count + 1;
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> elsif r_Count = DEBOUNCE_LIMIT-1 then
         r_State &lt;= i_Bouncy;
         r_Count &lt;= 0;
       else
       <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Count &lt;= 0;
       end if;
     end if;
  end process;
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> o_Debounced &lt;= r_State;
end architecture RTL;</code></pre>
<p class="TX"><span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>The overall purpose of this module is to remove any bounces or glitches in the input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) and create a stable output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced)</samp>. To do this, we check if the input and output are different. If they are, we know the input is changing, but we don’t want to immediately update the output, since the switch might still be bouncing. Instead, we want to make sure that the input is stable for a long enough period of time before updating the output. Because the FPGA has no inherent concept of time, we implement the delay by counting clock cycles.</p>
<p class="TX">Let’s say we want the input to be stable for 10 ms before we update the output. We need to count up to some number of clock cycles that represents 10 ms (or 10 million nanoseconds) of time passed. The Go Board, for example, has a clock period of 40 ns, so in this case we divide 10 million by 40 to get a delay of 250,000 clock cycles. This is the value we used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> parameter/generic in the top-level module <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>. If your development board has a different clock period, you’ll need to change <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> accordingly.</p>
<p class="TX">The code used to create our clock cycle counter <span aria-label="annotation1" class="CodeAnnotation">❶</span> differs between the Verilog and VHDL versions. In Verilog, we use a common trick: the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp> built-in function (short for ceiling log base 2) determines the log<sub>2</sub> of the number of clock cycles we want to count, rounded up. This tells us the number of binary digits needed to implement the counter. Thanks to the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp> function, we can dynamically size the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> register based on the input parameter, so if the input parameter changes (because your clock has a different period, or because you want to extend the wait time), the code will see this and synthesize <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> to be as wide as it needs to be. This is better than hardcoding <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> to some arbitrary limit, which could break when the code is reused.</p>
<p class="TX">With VHDL, we’re able to achieve the same dynamic sizing in a simpler way, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp> keyword. This not only will size the variable correctly, but has an added benefit of creating a warning in your simulation if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> ever goes beyond the integer range limit. The fact that the <span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>simulator can provide these types of warnings when running your testbench is another great reason for using simulations.</p>
<p class="TX">We implement the debounce filter using a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements that are evaluated at each clock cycle. First we handle the case where the input is different from the output (meaning the input is changing) but <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT-1</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This means we haven’t yet waited the desired amount of time for the switch to stop bouncing, so we increment our clock cycle counter by 1. In this <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, we’re effectively waiting for some amount of time to pass to ensure the input is stable, before updating the output value.</p>
<p class="TX">Next we handle the case where the counter has reached its limit, so we know that we’ve waited the full 10 ms (or whatever length of time <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE _LIMIT</samp> corresponds to) <span aria-label="annotation3" class="CodeAnnotation">❸</span>. At this point, we can register the current value of the input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp>, whose value is in turn assigned to the output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>) <span aria-label="annotation5" class="CodeAnnotation">❺</span>. We also reset the counter to 0 to prepare for the next event. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> covers situations where the input and output have the same state. In this case, we reset the counter, since we have nothing to debounce here and we want our debounce filter to always be ready for the next event.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Testbench and Simulation</samp></h3>
<p class="TNI1">Now we’ll create a testbench to exercise our project and make sure it works as expected. Recall that the testbench is what will instantiate our unit under test and simulate its inputs, while monitoring its outputs. In this case, we want the testbench to simulate the unstable input from a bouncing switch so we can confirm that the debounce filter is delaying the output until the switch has settled into a stable state. Here’s the code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Debounce_Filter_TB ();
  reg r_Clk = 1'b0, r_Bouncy = 1'b0;
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> always #2 r_Clk &lt;= !r_Clk;
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> Debounce_Filter #(.DEBOUNCE_LIMIT(4)) UUT
  (.i_Clk(r_Clk),
   .i_Bouncy(r_Bouncy),
   .o_Debounced(w_Debounced));
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> initial begin
    $dumpfile("dump.vcd"); $dumpvars;
    repeat(3) @(posedge r_Clk);
 <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Bouncy &lt;= 1'b1; // toggle state of input pin
    @(posedge r_Clk);
 <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> r_Bouncy &lt;= 1'b0; // simulate a glitch/bounce of switch
    @(posedge r_Clk);
 <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> r_Bouncy &lt;= 1'b1; // bounce goes away
    repeat(6) @(posedge r_Clk);
    $display("Test Complete");
    $finish();
  end
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use std.env.finish;
entity Debounce_Filter_TB is
end entity Debounce_Filter_TB;
architecture test of Debounce_Filter_TB is
  signal r_Clk, r_Bouncy, w_Debounced : std_logic := '0';
begin
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> r_Clk &lt;= not r_Clk after 2 ns;
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> UUT : entity work.Debounce_Filter
     generic map (DEBOUNCE_LIMIT =&gt; 4)
     port map (
        i_Clk       =&gt; r_Clk,
        i_Bouncy    =&gt; r_Bouncy,
        o_Debounced =&gt; w_Debounced);
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> process is
  begin
     wait for 10 ns;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Bouncy &lt;= '1';  -- toggle state of input pin
     wait until rising_edge(r_Clk);
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> r_Bouncy &lt;= '0';  -- simulate a glitch/bounce of switch
     wait until rising_edge(r_Clk);
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> r_Bouncy &lt;= '1';  -- bounce goes away
     wait for 24 ns;
     finish;  -- need VHDL-2008
  end process;
end test;</code></pre>
<p class="TX">Unlike our AND gate testbench, this testbench must provide a clock signal to the UUT, along with the other inputs. We create the clock signal with a simple trick <span aria-label="annotation1" class="CodeAnnotation">❶</span>: we repeatedly invert a signal after a fixed amount of time to generate a 50 percent duty cycle signal that will toggle for the duration of the testbench execution. The signal inverts every 2 ns, for a clock period of 4 ns per cycle. This is much faster than the actual clock period on a typical FPGA development board, but for the purposes of this simulation, that’s okay.</p>
<p class="TX">When we instantiate the UUT <span aria-label="annotation2" class="CodeAnnotation">❷</span>, we override <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. This means our debounce filter will only look for four clock cycles of stability before it deems the output debounced. In a real FPGA, this would be a very short amount of time (less than 1 microsecond), probably not long enough to actually fix the problem. However, keep in mind the purpose of this testbench: we want to make sure that our FPGA logic works as intended. That <span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>logic is functionally the same whether we’re waiting 4 clock cycles or 250,000 clock cycles. Using the much smaller number will make for a quicker simulation and an easier-to-evaluate waveform, while still giving us realistic feedback about whether or not the design works. Shortening counters is a handy trick to remember for large designs: a simulation of such a design could take many minutes to run, but using smaller limits for counters will make the simulation run faster, allowing you to debug your code more quickly. Once your design is fully debugged and verified, you can update the simulation with your actual expected counter lengths to validate your actual design. This means you’ll only have to endure the longer simulation time once, after any issues with the code have already been resolved using the shortened simulation.</p>
<p class="TX">Next, we start to provide stimulus to the UUT <span aria-label="annotation3" class="CodeAnnotation">❸</span>. With synchronous designs, we want to ensure that our input signals to the UUT are synchronous to the clock. We therefore set up the code to change the stimulus on the rising edge of the testbench clock. Otherwise, we might be introducing strange timing effects that would not exist in a real FPGA design. (Remember that all of the flip-flops in your UUT will be using the rising edge of the clock, so your testbench stimulus should also be reacting to the rising edge of the clock.)</p>
<p class="TX">When the test starts, the input is low. After a short time, the input goes high for a single clock cycle <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, then low again <span aria-label="annotation5" class="CodeAnnotation">❺</span>, to simulate a bouncing-induced glitch. We want to make sure that the debounced output of this module doesn’t react to this glitch. Later in the test, we drive the input back high again and leave it there <span aria-label="annotation6" class="CodeAnnotation">❻</span>. This time we want the output to match the input, but only after the debounce filter has counted out four clock cycles.</p>
<p class="TX">After running this testbench code in EDA Playground (or whichever simulator you prefer), you should get a waveform that looks something like that shown in <a href="#fig5-7">Figure 5-7</a>.</p>
<figure class="IMG"><img alt="" class="img100" id="fig5-7" src="../images/Figure5-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: The debounce simulation waveform</samp></p></figcaption>
</figure>
<p class="TX">The waveform shows that the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp> stays low when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp> goes high for only one clock cycle. Then, toward the end of the simulation, we see the output go high to match the input, but only after the input has been high for four clock cycles. The debounce filter works!</p>
<p class="TX">While the testbench we wrote is better than no test at all, it could certainly be improved. For example, we don’t check what happens when the input goes low again, to make sure the output responds correctly. Additionally, we might want to check that a higher <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> value than <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> doesn’t cause any issues. Setting up multiple tests to stress the bulk of your design, and in particular any corner cases, is good test design practice.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming the FPGA</samp></h3>
<p class="TNI1">Having simulated the design, we now have some confidence that if we were to go ahead and program the FPGA, it would likely work as intended. Let’s try it <span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>out! Create a new project inside iCEcube2, and add the following modules to the project: <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>. Make sure that you’ve also included the clock constraints file, as well as the physical constraints file.</p>
<p class="TX">When everything’s ready, build the project. Then double-check for errors, and check your utilization reports. The synthesis report after building the FPGA will look something like this:</p>
<pre><code><var>--snip--</var>
Register bits not including I/Os:   21 (1%)
Total load per clock:
   i_Clk: 1
Mapping Summary:
Total  LUTs: 31 (2%)
<var>--snip--</var></code></pre>
<p class="TX">From this report, we can see that we’re using more LUTs and flip-flops than we did for <span class="Xref">Project #3</span>. This makes sense; the debounce filter accounts for these extra resources. Still, the FPGA has plenty of resources to spare.</p>
<p class="TX">Go ahead and program your FPGA, then try pushing the button to turn the LED on and off. You should notice that the LED is now toggling consistently with each press of the button. We’ve successfully filtered out the bounces from the switch.</p>
<p class="TX">As you’ve seen in this project, simulations are invaluable for building confidence in a design and debugging issues in your Verilog and VHDL. However, even in this relatively simple example, you may have noticed a drawback: examining waveforms to determine if a design is working can be tedious, especially if you have to keep changing the design and rerunning the simulation. It would be much more convenient if the testbench could simply tell you whether the simulation has worked, without you having to study the waveform. As we’ll explore next, it’s possible to write testbenches that offer exactly this capability.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h2 class="H1" id="sec11"><span id="h-63"/><samp class="SANS_Futura_Std_Bold_B_11">Self-Checking Testbenches</samp></h2>
<p class="TNI1">A <i>self-checking testbench</i> is a testbench that you program to verify your UUT is working as intended, without having to manually inspect the output. The self-checking testbench will run a series of steps and let you know if any have failed, at which point you can inspect the failure and fix it. This saves you from having to visually examine the waveforms generated during simulation to determine whether your design has worked as expected. It takes a bit more effort to set up your testbench to be self-checking, but it’s almost always worth the time spent.</p>
<p class="TX">When setting up a self-checking testbench, your goal is to inject many different test cases into your UUT, then monitor the outputs and check, or <i>assert</i>, that they are what you expect. <i>Assertions</i> are statements about what value a signal will have at a particular moment in the simulation, and they’re probably the most critical part of a self-checking testbench. Often, <span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>a self-checking testbench will have hundreds of assertions, with each one imparting a little more confidence that the design is correct.</p>
<p class="TX">Self-checking testbenches are particularly useful if you’re adding a new feature to some old code. It might be something that you haven’t looked at in years, and suddenly you need to try to remember (or learn, if someone else wrote it) how it works. From experience, I can tell you that starting with a testbench that has many checks is a huge benefit. You’ll be able to open the simulation, see all of the assertions in the self-checking testbench, and make sure everything in the old code still works. Then you can add your new code and add new tests for it. Once all the old <i>and</i> new tests are passing, you can have high confidence that your new code is performing as expected—and equally importantly, that <i>you haven’t broken any old code</i>.</p>
<p class="TX">To illustrate how self-checking testbenches work, let’s return to the simple testbench we wrote for our AND gate project earlier in the chapter. The following Verilog and VHDL code takes the original testbench we wrote and adds some assertion checks within it. These assertions will automatically run to verify that the actual output is in the expected state. The new code is shown in bold:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  initial
    begin
       $dumpfile("dump.vcd"); $dumpvars;
       r_In1 &lt;= 1'b0;
       r_In2 &lt;= 1'b0;
       #10;
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <b>assert (w_Out</b> == <b>1'b0);</b>
       r_In1 &lt;= 1'b0;
       r_In2 &lt;= 1'b1;
       #10;
       <b>assert (w_Out</b> == <b>1'b0);</b>
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
process is
  begin
    r_In1 &lt;= '0';
    r_In2 &lt;= '0';
    wait for 10 ns;
 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <b>assert (w_Out</b> = <b>'0') severity failure;</b>
    r_In1 &lt;= '0';
    r_In2 &lt;= '1';
    wait for 10 ns;
    <b>assert (w_Out</b> = <b>'0') severity failure;</b>
<var>--snip--</var></code></pre>
<p class="TX">In this excerpt from the testbench, we’ve added two checks. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> keyword <span aria-label="annotation1" class="CodeAnnotation">❶</span> to first confirm that the output is low when both inputs <span aria-label=" Page 86. " epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>are low, then that it’s low when one input is low and the other is high. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> keyword only exists in SystemVerilog, not regular Verilog. This is an example of how SystemVerilog has improved features for testbenches. VHDL, meanwhile, has <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> built into it, and the severity can be <samp class="SANS_TheSansMonoCd_W5Regular_11">note</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">warning</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>, depending on the level of assertion that you want to check for. Each has a different escalation, so you can filter them out in your report. In this case, we’ve chosen <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>, since we definitely wouldn’t want an AND gate output high when the inputs are low.</p>
<p class="TX">If this assertion evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, then the simulation moves on. However, if something goes wrong and the assertion fails, you’ll see output printed to the screen. In Verilog, you’d see something like this:</p>
<pre><code># ASSERT: Error: ASRT_0301 testbench.sv(20): Immediate assert
condition (w_Out==1'b1) FAILED at time: 10ns, scope: And_Gate_TB</code></pre>
<p class="TX">In VHDL, here is what the failure message would look like:</p>
<pre><code># ** Failure: Assertion violation.
#    Time: 10 ns Iteration: 0  Process: /and_gate_tb/line__22
File: testbench.vhd</code></pre>
<p class="TX">This is very helpful! Not only do we know that the testbench failed, but we know that it failed exactly 10 ns into the simulation, which allows us to immediately locate the failure in the waveform viewer. We also know the exact line of code that caused the failure: line 20 in Verilog or line 22 in VHDL. These pieces of information make it easier to investigate the problem, understand the cause, and fix it. I recommend adding assertions into your tests wherever possible.</p>
<p class="TX">The self-checking testbench is an area where SystemVerilog really shines. Many of the added features beyond what regular Verilog offers are geared toward writing better testbenches. For example, SystemVerilog provides the ability for you to verify sequences of events. This can be handy for analyzing interactions between different signals, to make sure they happen correctly (that is, first one thing happens, then on the next clock cycle, another thing happens). SystemVerilog also provides classes, allowing you to use object-oriented programming techniques to streamline your testbench code. Other SystemVerilog features allow you to randomly inject data into your designs, making your tests much more comprehensive and robust. The details of these features are beyond the scope of this book, but as you start writing more testbenches—particularly self-checking testbenches—I encourage you to learn more about SystemVerilog.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h2 class="H1" id="sec12"><span id="h-64"/><samp class="SANS_Futura_Std_Bold_B_11">Initial Signal Conditions</samp></h2>
<p class="TNI1">By default, if a signal isn’t assigned an initial condition, then it will show up in an unknown state when you start a simulation. This is often represented by a red signal and an X in the waveform viewer. The simulator is telling <span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>you that it doesn’t know how to treat the signal when the testbench is first running. Should it be a 0 or a 1? The simulator doesn’t know.</p>
<p class="TX">There are two methods for assigning a default state to your signals, so that they start in a known state. One method is to use resets. As we discussed back in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, a reset assigns an initial default value to a flip-flop. Driving the reset input at the start of a simulation will set the signals to known states to begin the test. This will work for all signals that are assigned a reset condition.</p>
<p class="TX">The other way we can set signals to an initial state is to use the initialization feature in both Verilog and VHDL. This is particularly useful for simulation purposes. It’s as simple as assigning a signal to a value after it’s created. In Verilog, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">reg r_State</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1'b0;</samp> initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp> signal to 0. In VHDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">signal r_State : std_logic :=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'0';</samp> does the same. You can use any state that the signal can validly be set to as an initialization value.</p>
<p class="TX">Initial signal assignments are only synthesizable for some FPGAs, since not all FPGAs can load an initial state into their flip-flops when they boot up after being programmed. Because this feature isn’t available for all FPGAs, I generally don’t recommend relying on it. A better, more portable solution is to use resets to set signals to some default value. Resets are widely supported across all FPGA manufacturers, so your code will be more portable if you need to change FPGAs.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h2 class="H1" id="sec13"><span id="h-65"/><samp class="SANS_Futura_Std_Bold_B_11">On-FPGA Debugging</samp></h2>
<p class="TNI1">Early in this chapter, I told you that once you’re on hardware, you’re looking at a black box. You can see inputs and outputs, but you can’t see what’s going on internally. This isn’t entirely true. There <i>is</i> a way to do some limited on-FPGA debugging. However, this method has significant drawbacks and should only be used sparingly, if at all.</p>
<p class="TX">On-FPGA debugging is achieved by adding a <i>logic analyzer</i>, a tool that shows the state (high or low) of many digital signals at once, inside your FPGA. This allows you to monitor the FPGA’s internal signals in real time. By looking at these signals, you can debug issues and see where data isn’t behaving as expected.</p>
<p class="TX">Each of the major FPGA companies has a unique product within its suite of tools that creates a logic analyzer inside the FPGA. AMD has a feature called Integrated Logic Analyzer (ILA), Intel has Signal Tap, and Lattice has Reveal. They all work basically the same way: they take part of your FPGA’s resources and turn those resources into a logic analyzer. You run your FPGA code, the logic analyzer “sniffs” the data, and the results are presented on your computer screen so you can debug your design.</p>
<p class="TX">There are several problems with this process, however. The first issue is that it’s extremely time-consuming. If you want to add a logic analyzer to your FPGA, you need to rebuild and reprogram the entire design. You also need to decide ahead of time what signals you’re interested in monitoring with the logic analyzer, as you likely won’t have enough resources on your <span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>FPGA to look at everything. If you want to change what you’re looking at while the FPGA is running, too bad! You’ll have to rebuild the entire FPGA from scratch and start the process all over again. A simulation, on the other hand, can easily see the state of <i>all</i> the signals on your FPGA; you don’t have to pick and choose.</p>
<p class="TX">An additional problem with on-FPGA debugging is that adding a logic analyzer is basically throwaway effort. Once you find and fix your one problem, you don’t need the debug tool anymore. In fact, since it uses your FPGA’s resources (which are a limited commodity), you may not want to keep it in your design. You can save and rerun a simulation, but a logic analyzer is a one-and-done debugging effort.</p>
<p class="TX">The final and perhaps worst problem is that when you add a logic analyzer to your FPGA, you’re changing the FPGA’s design, which can have unintended consequences. Issues that are subject to small timing variations might be fixed by the very act of adding the logic analyzer, or new issues might be created. If you’re trying to use the logic analyzer to debug a race condition inside your FPGA, for example, the design changes that result from adding in the logic analyzer might actually make the race condition go away. Scientists refer to this as the <i>observer effect</i>, where a phenomenon is changed by the act of investigating it.</p>
<p class="TX">This isn’t to say that these on-FPGA debuggers are entirely useless. They’re helpful when you’re trying to investigate a situation that’s difficult to simulate. For example, say some external interface to your FPGA is causing problems, but those problems are only occurring on your hardware while the simulation is working fine. At that point you might want to fire up a logic analyzer and try to see why your simulation is different from real life. Once you figure it out, you should strive to make your simulation as realistic as possible, adding to it the failure mode that you identified with the real-world test.</p>
<p class="TX">These tools have saved me a couple of times in my career, but in general I try to avoid them if possible.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h2 class="H1" id="sec14"><span id="h-66"/><samp class="SANS_Futura_Std_Bold_B_11">Verification</samp></h2>
<p class="TNI1"><i>Verification</i> is the process of ensuring that an FPGA or ASIC design is working as intended. It’s an exhaustive process that goes well beyond writing a few testbenches and running a simulation—so much so that there are people called verification engineers who perform verification full time. The complete details of how verification works are beyond the scope of this book. In fact, there are entire books dedicated to the subject. This section simply introduces the topic so you’re aware of the key role verification can play in real-world FPGA and ASIC design.</p>
<p class="TX">Consider a device like a DVD player. What happens if a DVD is playing, then the user pauses playback, ejects the DVD, and presses the fast-forward button? Does the code handle that sequence of events correctly? Or does the unexpected fast-forward command lock up the processor in a strange state? The verification engineer must test all of these corner <span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>cases to ensure the design won’t make a mistake in handling some strange situation.</p>
<p class="TX">Back in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, I mentioned that making an ASIC is an incredibly expensive and time-consuming process. Once the ASIC is fabricated at the foundry, you have to cut a big check. If there are critical bugs in the design and the ASIC doesn’t work as intended, then you’ve just lost all that money, and you’ll need to rerun the ASIC fabrication process again. It’s the job of a verification engineer to ensure the design is correct up front, since finding and fixing bugs later is incredibly expensive.</p>
<p class="TX">Squashing bugs is great, but that’s only half the benefit. Another major goal of verification is to ensure the design is performing as intended. If you’re handed a specification of how an ASIC is supposed to perform, there might be ambiguities or missing information. Usually, one or more designers will design to the specification, and one or more separate verification engineers will simultaneously verify that the design is meeting the specification. If any discrepancies arise, the two teams can get together and update the specification so that everyone is clear on the intent.</p>
<p class="TX">Most verification engineers take advantage of the extra features built into SystemVerilog to thoroughly test a design. Self-checking testbenches are absolutely a must. It’s helpful to exercise the design randomly as well, so there are blocks of code that can inject random test cases into the design and ensure it’s working as intended.</p>
<p class="TX">Verifying code like this is no small feat. Often it’s more expensive and time-consuming to verify a design is working correctly than to create the design itself! For this reason, unlike with ASICs, not many FPGA designs go through a dedicated verification process. In most cases, it’s just too expensive. Remember that FPGA stands for <i>field programmable</i> gate array, so if a few bugs are allowed to slip through, the device can always be updated in the field, or in the hands of a customer.</p>
<p class="TX">Usually, only FPGA designs that demand very high reliability or simply cannot be updated in the field go through verification. For example, some FPGAs are <i>one-time programmable (OTP)</i>, meaning they can only be programmed once; afterward, the functionality is locked in and cannot be changed. Some applications in outer space utilize these OTP FPGAs, since they’re more resistant to radiation. Additionally, OTP FPGAs are considered less susceptible to reverse engineering, so they’re preferable for high-security applications. OTP FPGA designs often require verification; however, this isn’t the norm for typical FPGA designs.</p>
<p class="TX">For our purposes, testbenches are sufficient to find bugs in the FPGA design, but for ASICs or FPGAs that require it, verification is critically important.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h2 class="H1" id="sec15"><span id="h-67"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter, you’ve learned about simulating your FPGA code and seen how running simulations is time well spent. In contrast to debugging on hardware, simulation lets you visualize all the signals in your design, <span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>observe how they interact, and create stimuli to stress your code and see how it responds. You practiced writing testbenches, or code that instantiates your UUT, injects it with sample input, and monitors the output. You saw how looking at the waveforms generated during simulation is a great way to see if your design is working, but better still is adding tests that make your testbench self-checking. Less debugging on hardware, more beautiful simulations: that’s what makes a happy FPGA designer.</p>
</section>
</section>
</body>
</html>