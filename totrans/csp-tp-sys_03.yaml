- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REFERENCE
    AND VALUE PARAMETERS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll look at how method parameters and arguments relate to
    reference and value types. We’ll revisit the idea that all variables have a value,
    regardless of their type, and see how to pass values of different types *by value*
    or *by reference* as arguments for methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How *reference* and *by reference* differ in meaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why aliasing and mutability are so closely related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How avoiding side effects can make our code clearer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to pass values by reference as an optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing method parameters by value or by reference isn’t the same as those parameters
    being value or reference types. In other words, the parameter’s type (value or
    reference) differs from how the method uses that parameter (by value or by reference).
    *Passing* in this context refers to the mechanism for supplying values to a method’s
    parameters and receiving the result the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into those distinctions in detail, let’s look at how method parameters
    and arguments work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in [Chapter 2](chapter2.xhtml), method parameters are a particular
    kind of variable. A parameter variable is declared with a name and explicit type
    in the method’s definition and goes out of scope when the method ends. If the
    method is defined in a generic type or the method itself is generic, the parameter
    type can be generic. When we call the method, we pass arguments to each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# has four kinds of method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common kind of parameter, value parameters, behave as if they’re local
    variables in the method. A value parameter is initialized with the value of the
    argument passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: These parameters take the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier, signifying that they’re passed by reference. The arguments passed also
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to reinforce
    that the argument and the parameter both refer to the same memory location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: These are parameters that use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, meaning they’re given a new value by the method. Output parameters are
    also passed by reference. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier for reference parameters, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier for both the argument being passed and the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: This special kind of reference parameter uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to indicate that its value doesn’t change within the method. Unlike <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, the argument passed to an input parameter doesn’t require the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    is designed to be transparent to calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Reference, output, and input parameters are special variables in that they indicate
    a level of indirection to an actual variable. They are known collectively as *by-reference
    parameters*.
  prefs: []
  type: TYPE_NORMAL
- en: When we call a method, the arguments we pass populate the parameters we’ve declared
    for that method. When the parameter is a value parameter, our argument for it
    is passed by value. When the parameter is any of the by-reference parameters,
    our argument is passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Types vs.
    By-Reference Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By-reference parameters are sometimes confused with reference type variables,
    in part because the phrase *pass by reference* is often used along with its companion,
    *pass by value*, to describe how reference types differ from value types. Consider
    Microsoft’s guide to framework design ([*http://<wbr>msdn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/library<wbr>/ms229017<wbr>.aspx*](http://msdn.microsoft.com/en-us/library/ms229017.aspx)),
    which includes the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are passed by reference, whereas value types are passed by value.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a not-quite-accurate description of the mechanics of passing by reference.
    To say that reference types are passed by reference is conflating the concepts
    of type and passing. Arguments for by-reference parameters are passed by reference,
    no matter the argument’s type. Put another way, arguments of either reference
    or value type may be passed either by reference or by value, according to the
    presence or absence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the method’s parameters. A by-reference parameter is not itself a
    reference, but the variable it refers to might be. Terminology is fun, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](chapter2.xhtml), we explored how reference types and value types
    have different copy semantics, and passing arguments and copying variable values
    are related ideas. In particular, when we pass an argument by value, we make a
    copy of its value. The Microsoft documentation article quoted earlier goes on
    to say this:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes to an instance of a reference type affect all references pointing to
    the instance. [...] When an instance of a value type is changed, it of course
    does not affect any of its copies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The operative word here is *instance*. We can have multiple references to a
    single instance of a reference type. Copying a reference doesn’t make a copy of
    the *instance*, just a copy of the reference’s value. By contrast, a copy of a
    value type variable is a new instance, independent of the original value. The
    value *is* the instance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Types and Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *value type variable* directly contains the data represented by the member
    fields of the type. This is true whether the variable is a local instance, a field
    stored in another object, or a parameter for a method. Consider the simple value
    type in [Listing 3-1](#list3-1) representing a two-dimensional coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A simple Coordinate
    value type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> type has
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields, each of which
    takes up a single location in memory. A variable of this type, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable in [Listing 3-1](#list3-1),
    will directly contain the entire instance. The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable would look more or less like [Figure 3-1](#fig3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Memory representation
    of a simple value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable doesn’t
    refer to the data in memory but rather stores the contents of each field of a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> directly in place.
    If a type has multiple fields, those fields are stored in consecutive locations.
    If we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> into
    another variable, each field’s value in the new variable is an independent copy
    of the corresponding field’s value in the original <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    value as an argument to a method’s value parameter, the whole value is copied
    into the parameter. In [Listing 3-2](#list3-2), we have a method, <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>,
    with two <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value
    parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end</samp>, and we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable as an argument to both parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A method with
    two value parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>
    method’s parameters are both taken by value, each parameter receives its own copy
    that’s independent of the original value. The result looks something like [Figure
    3-2](#fig3-2) in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Memory representation
    of a copied value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    parameters are initialized with the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    argument passed to them, and each has its own copy within the method itself.
  prefs: []
  type: TYPE_NORMAL
- en: When we assign one value to another or pass a value type instance as an argument
    by value, we copy the value. Two value type variables are always independent instances.
    This is the essence of *copy-by-value* semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Reference type variables behave differently because their value is a reference.
    A reference’s value is used to identify an instance of the type on the heap or
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Value of a Reference</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create an instance of a reference type, memory is allocated on the
    heap, and a reference identifying the location of that memory is stored in the
    variable. Syntactically, it appears that the type of a reference variable is the
    type of the instance to which it refers, as illustrated here with a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’d normally refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    variable as a string. However, that’s not completely accurate. It’s more precise
    to say that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a variable
    whose *type* is <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and
    whose *value* is a *reference* to an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type. The type of a reference variable need not exactly match the type of the
    instance. For example, we can use a base class reference variable, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, to refer to a more specific
    reference type instance, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: A reference’s value is an opaque handle used by the Common Language Runtime
    (CLR) to identify an object. We’re not really interested in what the value of
    a reference is; references are just the mechanism by which we access and manipulate
    instances of a reference type, as illustrated in [Figure 3-3](#fig3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Memory representation
    of a string reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-3](#fig3-3), <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    is a variable whose value is a reference. A reference does not itself have a distinct
    type (certainly not one we can name), but it does have a value. The value of a
    non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a handle
    to an area of memory allocated on the heap that contains the instance of a reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This precision matters because when we’re talking about passing or copying
    variables, we really mean passing or copying *values*. For value types, this distinction
    doesn’t exist: the value of a struct variable *is* the instance. However, reference
    variables are distinct from the instances they refer to—when we copy a reference
    variable’s value, we’re making a copy of the reference, not the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Some languages use pointers to objects in memory, but a reference isn’t quite
    the same as a pointer. References can’t be used for just anything in memory. They’re
    specifically used to access reference type objects on the heap and to track those
    objects when they move around as a result of garbage collection and memory compaction.
    The details of those processes are hidden from us and handled automatically as
    part of the memory management for reference types.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the value of a reference as being a kind of address. In this
    respect, a reference value behaves very much like a value type instance. Like
    a value type variable, a reference type variable directly contains its value (an
    address) and lives within the scope of its parent, which might be the stack frame
    for the local variables of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, consider this: *all* variables, whether they represent reference
    or value types, have values that may be copied. More than that, by default, all
    variable values are copied—and passed—*by value*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Variables
    and Aliasing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Aliasing* refers to accessing a single memory location via multiple variables.
    As you’ve seen, when we copy one reference to another, such as when we pass a
    reference as an argument to a method, we create two aliasing references—the argument
    variable and the parameter variable—to the same object in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when we pass a value type instance as an argument, the argument
    variable and parameter variable are identical but independent copies of each other.
    The difference between reference types and values in this respect is most significant
    when the instances are mutable (that is, their state can be altered).
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing can be intentional and useful, such as when we want changes to an object
    to be observable by all references to it, wherever they might be. For example,
    see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> classes in [Listing 3-3](#list3-3);
    we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    type by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>
    method of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object stores
    a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance used to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Storing a reference
    to a DataStore as a property of Command</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> method
    returns a reference to the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    object, with its reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance. We can *mutate*—change the state of—the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods, and whether
    we use a local <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    variable or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object
    returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>,
    we’ll update the same <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance because both references are aliases for the same object, as demonstrated
    in [Listing 3-4](#list3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Mutating the DataStore
    instance via an alias</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> method
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> property
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> variable and
    test that the state of the local variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp>
    has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value type variables are never aliases for a single instance, so changes to
    an instance are visible only in the variable used to make the change. Value type
    instances are copied by value, so each copy is an independent instance. This process
    is analogous to me sending you a document as an email attachment: we both have
    our own copy of the document, so if I change my copy, your copy is unaffected,
    and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if I instead send a link to a shared document that we can both edit,
    any change either of us makes will be visible to us both via that link. The link
    is similar to a reference; it’s a kind of address for the document, but it’s not
    the document itself. The link represents a level of indirection to the real document.
    In exactly the same way, a reference variable doesn’t contain an object but instead
    a reference, and the object’s instance is accessed indirectly via that reference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mutable By-Reference Parameters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, method parameters are value parameters, meaning that arguments passed
    to them are passed by value, regardless of the argument’s type. In this section,
    we’ll look at the *mutable by-reference parameters*, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, which cause arguments
    to be passed instead by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Value type instances and references can both be passed by reference by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, so it’s important to understand that by-reference parameters are different
    from reference type *value* parameters. When we pass a reference as an argument
    to a reference type value parameter, the same object instance is referenced by
    both the argument and parameter variables, and any change to the instance is visible
    via either variable. A by-reference parameter, in contrast, is an alias for the
    value of the argument variable, whether that value is a reference or value type
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier on a parameter
    means that when we call the method, the address of the argument’s value is passed
    rather than a copy of the value. This extra level of indirection means that regardless
    of the argument’s type, both the caller and the method directly access the same
    value. If the argument’s value is a reference, we can change it to refer to a
    new instance or assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to it, and that change is visible via both the argument and the parameter variables.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the difference between reference variables and by-reference parameters,
    consider [Listing 3-5](#list3-5), where we pass a reference by value to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method that attempts
    to change its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Creating a new
    instance versus changing an instance</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This test fails, even though <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is a reference type. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    operator appears as though it’s mutating the string, it actually creates a new
    string with the updated contents and returns a new reference to it. The new reference
    and instance are visible within the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method but not outside it. The original string is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method isn’t
    changing the shared <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance, but rather the *value* of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> here
    changes the reference to refer to a new, different instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable used as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    still refers to the original, unchanged instance.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates clearly that when we pass a reference as an argument, it is,
    by default, passed by value. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method in [Listing 3-5](#list3-5) to work as expected, we need to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> reference by reference
    so that when the method alters the value of the reference *variable*, the change
    is visible to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing References
    by Reference</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most direct way to make our test in [Listing 3-5](#list3-5) pass is to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> a by-reference parameter.
    [Listing 3-6](#list3-6) shows the same <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method as [Listing 3-5](#list3-5), except in this version we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter by reference by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Using the ref
    modifier to pass name by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    on both the method’s parameter and the argument we pass to it because we’re passing
    a reference to a variable. The test now passes because the changes that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method makes to the
    value of the reference variable are visible via the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable in the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter is,
    in effect, an alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable, as illustrated in [Figure 3-4](#fig3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: A by-reference
    parameter aliases a variable.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of using a by-reference parameter is that the argument and the
    parameter variables don’t just refer to the same instance—they’re effectively
    the same reference. We can still use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance (for example, to access properties or call methods), and the compiler
    hides the extra level of indirection afforded by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Values by
    Reference</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can pass value type variables by reference too. Keep in mind that passing
    arguments by reference doesn’t imply that the parameter is a reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass a value type instance as an argument to a method, the method normally
    gets a copy of the instance because of the copy-by-value semantics of value types.
    As you’ve seen previously, any changes made to the fields of the instance inside
    the method aren’t visible to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: If we require those changes to be visible outside the method, we need to pass
    the value by reference. In [Listing 3-7](#list3-7), we introduce an <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method that takes a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value type parameter by reference and changes its value. Value types like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> should almost always be immutable,
    and you’ll see in “Mutation vs. Creation” on [page 89](#sec22) how to express
    this differently. This example merely demonstrates that the mechanism for passing
    value types by reference is identical to passing references by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Value type by-reference
    parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    to pass the argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    parameter by reference, just as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter in [Listing 3-6](#list3-6). As a result, the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is visible
    to the calling code, as shown in [Listing 3-8](#list3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Using the ref
    modifier to pass speed by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable
    is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> by
    reference, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> is aliased
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method.
    Both the calling code and <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    are effectively using the same variable, so any changes to the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter are visible within
    both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method
    and the code that calls it. The test shows that we’re expecting the value to be
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*To reiterate, by-reference parameters aren’t the same as reference type variables.
    A* reference type variable *refers to an instance of a reference type, whereas
    a* by-reference parameter *refers to a variable, which can be either a reference
    type or a value type.*'
  prefs: []
  type: TYPE_NORMAL
- en: References can refer only to an object on the heap. If we assign a reference
    type variable to an instance of a value type, the value is boxed onto the heap,
    and the variable refers to the boxed copy. A by-reference parameter adds an extra
    level of indirection to a variable’s value. When we pass a value type instance
    by reference, the value is neither boxed nor copied.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Output
    Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Output parameters*, designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, are mutable by-reference parameters and are usually used when we require
    a method to create a new instance of an object for that parameter variable. They’re
    similar to reference parameters in that they, too, alias the variable used as
    the argument. The argument we pass to the method is usually uninitialized, and
    the method will initialize it by assigning a value to populate the output parameter
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: More formally, the difference between a reference parameter and an output parameter
    is that a reference argument must be definitely assigned before it’s passed, whereas
    an output argument may or may not be initialized when it’s passed, but the parameter
    must be assigned a value within the method either way.
  prefs: []
  type: TYPE_NORMAL
- en: Output parameters are typically used when acquiring a new instance of an object
    could fail without the failure being a fatal or even serious problem. Examples
    include parsing a string for a specifically formatted value, connecting to an
    unreliable service, and reading a value from a shared resource such as a queue,
    which could be empty. In cases like these, we often want a way to attempt the
    process and be able to either ignore a failure or retry the operation. If the
    operation succeeds, we receive a valid object as a result.
  prefs: []
  type: TYPE_NORMAL
- en: The common approach to this use case is to define a method that takes at least
    one output parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    indicating success or failure. If the method succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter is initialized with a new object, and the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    indicating that the argument passed has been successfully initialized. If the
    operation is unsuccessful, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating to the caller that the output argument’s value should be ignored. This
    is a common technique in C# known as <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the TryXXX Idiom</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Standard Library has several examples of using <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> to parse a string
    for a specific kind of value, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> parameter
    and an output parameter for a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value. If the parse fails, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
    If the parse succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value will contain the date parsed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    [Listing 3-9](#list3-9) demonstrates how we might use this idiom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: The Try</samp>XXX
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">idiom</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">logTime</samp> variable passed
    as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    may come from an unreliable source, such as user input or a file. Incorrectly
    formatted dates are an error but shouldn’t be considered an exceptional case.
    A successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    means the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> variable
    is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> instance.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp>
    variable is default-initialized instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The documentation for DateTime specifies that the failure case initializes
    the variable to the value of the MinValue property, but that’s equivalent to a
    default DateTime.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods often have a companion version that *will* throw an exception when the
    operation fails. The exception version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method, for example, is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.Parse</samp>,
    which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value upon success and throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatException</samp>
    error upon failure. Handling exceptions can be intrusive, and failing to parse
    a string for a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    is the kind of error we’d probably want to handle as soon as it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had used the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method, we might have wrapped the call in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try…catch</samp>
    block, but this could become cumbersome if we had several strings to parse: to
    catch a failure on any one value, we’d have to wrap *each call* in its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    instead is more direct and less verbose.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making a Definite Assignment</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The underlying mechanism for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is identical
    in the CIL, which has native support for by-reference parameters and arguments.
    They differ in the semantics imposed by the compiler: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter is considered initially assigned within the method, meaning a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument must be definitely
    assigned before being passed; an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, on the other hand, is considered initially unassigned within the method,
    regardless of whether it had been assigned a value before the call. We must therefore
    definitely assign all <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters before the method returns. Not doing so results in a compile-time failure,
    as shown by this method, which attempts to return before the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    parameter has been assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The most straightforward way to avoid the error in this example would be to
    preemptively assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> parameter
    before returning <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. By
    convention, an argument passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    method should be considered to have a valid value in the calling code only if
    the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The target <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> variables
    in the calling code are considered definitely assigned only after a *normal* return
    from a method. It’s possible for control to leave the method *abnormally* by throwing
    an exception before all of its <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters have been assigned. If the method exits with an exception, the variables
    used as <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments that
    weren’t definitely assigned prior to the method call remain not definitely assigned.
    Any arguments that were already definitely assigned before the call remain definitely
    assigned, although they may still have been given a new value within the method
    before the exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: However, we’d usually use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> idiom to *avoid* exceptions,
    as most users will expect such methods to not throw any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Selecting Operations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    idiom with an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter,
    like that shown in [Listing 3-9](#list3-9), is appealing because the method can
    be used inline in a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to test the return value and capture the required output argument’s
    value all in one place. In [Listing 3-10](#list3-10), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method to determine how to obtain a list of results, using the ternary conditional
    operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> blocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    output variable is declared inline in the argument list for the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: Using a simple
    out parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the branch following <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> is taken, and we can use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> output variable
    in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>.
    If the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating the connection to the remote resource failed, our code takes the branch
    following the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> and loads
    the results from a cache instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    to declare the type of the inline <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    argument, in which case the compiler will determine its type according to the
    type of the parameter in the method’s definition. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method allows us to handle the failure to connect without the extra cost and complexity
    of handling an exception, and to attempt a different approach to obtain the list
    of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> method as returning
    multiple values: a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> to
    indicate the success or failure of attempting to obtain a resource, and the resource
    itself when its acquisition succeeds.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Limitations of By-Reference Parameters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While methods with by-reference parameters are well suited for certain situations,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    technique, by-reference parameters are not appropriate for every case, and the
    rules around definite assignment can sometimes require a different approach. Other
    restrictions can also affect where we can use these parameters. We’ll look at
    these restrictions in this section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The result of getting a property or indexer value can’t be used directly as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    argument. In [Listing 3-11](#list3-11), we attempt to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> instance
    as an argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-11: Passing properties
    to ref parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler rejects this code with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The compiler doesn’t allow this code because a property result is a value and
    not a variable. In [Chapter 2](chapter2.xhtml), you saw how variables can be assigned
    to, but values can’t. Accessing a property is exactly the same as reading the
    return value from a method call—something we look at in detail in [Chapter 4](chapter4.xhtml)—and
    methods return values, not variables. We usually use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter when we expect the called method to modify its argument, but because
    a property isn’t a variable, it *can’t* be modified.
  prefs: []
  type: TYPE_NORMAL
- en: It makes no difference whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is a reference type or a value type. Passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument is essentially
    passing the address of the argument, and we can’t pass the address of a nonvariable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading on By-Reference
    Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By-reference parameter modifiers are part of the signature of a method. A reference
    or output parameter is effectively a different type than its value parameter equivalent.
    If we have a method that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter, we can overload it with a method that takes that parameter by value.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloads can have different return types, so we can write a method that
    takes its parameters by value and returns a new object, and overload it with a
    version taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter
    that modifies the object in place, as shown in [Listing 3-12](#list3-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-12: Overloading on
    by-reference modifiers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, the compiler selects the correct overload based on whether we modify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> argument with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword to pass it by reference
    or omit the modifier to call the version with a value parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t, however, overload a method when the only difference is the kind of
    by-reference modifier for its parameters, as we try to do in [Listing 3-13](#list3-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-13: Overloading on
    different modifiers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This might seem an arbitrary restriction. After all, calling code must differentiate
    between passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument
    and passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument.
    However, the compiler rejects this overload because the Common Language Infrastructure
    (CLI) has no way to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> in the method signature.
    Both are just by-reference parameters, so the two overloads have the same signature,
    as far as the CLI is concerned, resulting in ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: The same restriction applies with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, which we cover in “Read-Only References and Returning by Reference”
    on [page 92](#sec24). As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is simply another
    kind of by- reference parameter, as far as the CLI is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a method based purely on whether one or more parameters is taken
    by reference or by value is probably best avoided in any case. Anyone calling
    such a method needs a thorough knowledge of this somewhat arcane corner of overloading
    rules, so such code could easily be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Fields</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making a field a by-reference variable is impossible. Again, this might seem
    arbitrary, but otherwise a by-reference field could become a *dangling* reference—that
    is, it could refer to an object that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As of C# v11.0, by-reference fields are permitted within ref struct types,
    which are specialized value types intended for high-performance applications.
    Numerous restrictions on ref struct types make them less suitable for most general-purpose
    code, so we don’t cover them in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a class like <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    in [Listing 3-14](#list3-14), which attempts to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter in a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-14: A hypothetical
    Reminder class that stores a field by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although this approach might seem attractive in principle—say, if we want the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> class to deliberately
    alias the argument to its constructor, or we want to avoid copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    instance—this code doesn’t compile. The compiler rejects it as simply invalid
    syntax because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    instance could be used after the referenced <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    variable has gone out of scope, meaning the field would become a reference to
    memory that no longer exists or, perhaps worse, memory that has been allocated
    to something else. The <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    field would be a dangling reference, something the rules of C# go to great lengths
    to prevent.
  prefs: []
  type: TYPE_NORMAL
- en: Although reference types have different lifetimes and enjoy automatic memory
    management, allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    fields only for reference types would indeed be arbitrary and a source of potential
    confusion and error. This capability would also serve little purpose because reference
    variables already exhibit aliasing behavior, and by-reference variables are the
    same size as references for the purposes of copying, so the compiler forbids it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Closures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The prohibition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> fields is also the
    reason we can’t use a by-reference parameter inside a closure. A *closure* is
    a method that encapsulates behavior along with its *context*—that is, the state
    of any variables declared outside the method’s own scope but used within its implementation.
    Those external variables are said to have been *closed over* by the method, hence
    the term *closure*. [Listing 3-15](#list3-15) shows a method trying to use a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter inside a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-15: Anonymous closure
    capturing a ref parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method, giving us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The closure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method is the lambda expression used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>
    method. The lambda is an anonymous method that uses the captured <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter, which belongs to the scope of <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>.
    Closure functions are implemented by the compiler as a small, unnamable class
    with fields for each of the closed-over variables. In this example, the variable
    being captured is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter,
    which, as you saw in [Listing 3-14](#list3-14), isn’t a valid field.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the error message indicates, the same problem applies equally to nested
    local functions and anonymous methods, which can also capture the outer method’s
    variables, including its parameters. Anonymous methods, lambda expressions, and
    local functions are all implemented the same way: using a hidden class synthesized
    by the compiler. Any captured variables become fields of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Iterator Blocks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *iterator block* is a compiler-generated class that implements the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> interface
    to iterate over the elements of a sequence, such as an array or a <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>, using deferred execution. Also known as *lazy enumeration*, *deferred
    execution* means that the next element is obtained from the sequence only when
    the user requests it; the sequence is produced on demand and theoretically may
    even be infinite.
  prefs: []
  type: TYPE_NORMAL
- en: An iterator block is created whenever we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement, as shown in [Listing 3-16](#list3-16). However, the compiler rejects
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp> method
    because it has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-16: A ref parameter
    in an iterator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp>
    method is attempting to filter the <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp>
    sequence passed as a parameter for elements that match the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter. However, like closures, methods that use iterator blocks can’t have
    by-reference parameters, so the method in [Listing 3-16](#list3-16) fails to compile,
    with this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each time the method yields a value, control returns to the calling code. When
    the next item is requested, the method must continue at the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> and must do so
    with the same state. The compiler transforms the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement to return an instance of the iterator block class that captures the
    state between requests for each element, similar to the way closures work.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated class needs to capture *all* the method parameters and
    any local variables as fields to preserve the method’s state between each request
    for a value, which is why iterator methods can’t have by-reference parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Asynchronous Methods</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lastly, and for exactly the same reason as closures and iterator blocks, we
    can’t declare by-reference parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    methods like the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryGetResponse</samp>
    method in [Listing 3-17](#list3-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-17: An out parameter
    in an asynchronous method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method fails to compile with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the compiler synthesizes a hidden class to manage the asynchronous
    invocation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Task.Run</samp>
    method. Asynchronous methods return control to their caller when the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    statement is reached, and so, like iterator blocks, they must preserve the state
    of *all* their variables. The compiler-generated class captures all local variables
    and parameters as fields, so by-reference parameters aren’t allowed for any method
    that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> modifier.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extension Methods</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use by-reference parameters in any method that doesn’t use a closure,
    an iterator block, or asynchronous operations using the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    keyword. However, caveats exist for *extension methods*, static methods that extend
    the interface of another type. The first parameter of an extension method is of
    the type being extended and uses the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    modifier. Extension methods have some restrictions on using by-reference parameters
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter. First,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter of an
    extension method can’t be an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, as demonstrated by [Listing 3-18](#list3-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-18: Extension method
    using an out parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code produces the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If this syntax were permitted, code using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatConnection</samp>
    method could *appear* to call a method using an uninitialized variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Most users would probably find this code confusing because using an uninitialized
    variable to invoke a method isn’t allowed in any other circumstances. In any case,
    we have much better alternatives to achieve the same result, and the syntax for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameters is also an
    error. We can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier with any of the other parameters, just as we can with any regular method,
    but we can’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> an
    output parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter is permitted if
    the parameter is a value type, but not if it’s a reference type. This restriction
    might also seem unreasonable at first glance, but it’s intended to explicitly
    prohibit code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullify</samp>
    method with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If this code were permitted, the variable used to call the method could refer
    to a different variable, or—as in this example—be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    after the method returned. Most users would likely be surprised by such behavior,
    so, once again, the compiler forbids it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter when the parameter
    is a value type, which avoids copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    argument’s value. While there’s no benefit to avoiding the copy of a reference,
    copying a large value might be relatively expensive. A value type variable can’t
    be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    but the method can assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    this</samp> parameter, thus changing the argument’s value. Again, doing so would
    likely surprise most users of the method, so even though the syntax is legal,
    we should avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    parameters. If we really want to avoid copying the argument for a <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    parameter, then instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier
    to make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> a read-only
    reference parameter, as discussed in more detail in “Read-Only References and
    Returning by Reference” on [page 92](#sec24).
  prefs: []
  type: TYPE_NORMAL
- en: In spite of their limitations, by-reference parameters are a core part of C#,
    and understanding their semantics is important. None of these restrictions is
    particularly onerous, not least because the use cases for these parameters are
    limited. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    value type parameters in extension methods would be considered unusual by most
    programmers and is a niche-enough feature that it’s probably best avoided in any
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Fields *must* be real variables, and C# provides no way to store a by-reference
    variable as a field of a general-purpose type. Every other example in this section
    can be expressed differently to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Side Effects and Direct Effects</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods with by-reference parameters intentionally alias variables in the calling
    code, and therefore changes made to those parameters within the method are visible
    outside the method’s scope. Altering the state of an aliased object is an example
    of a *side effect*, which is more generally defined as any change of state that’s
    visible to code outside the scope where the change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects aren’t intrinsically bad, but programs that depend on them heavily
    can be more difficult to follow than those that rely only on direct effects. The
    *direct effect* of a method is whatever it returns, normally referred to as the
    method’s output, with the inputs being the method’s formal parameters. By-reference
    parameters, especially <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, blur the distinction between the inputs and outputs of a method, since
    side effects may alter state that is unrelated to the method’s direct effect.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods are commonly used to initialize variables, as shown in [Listing 3-19](#list3-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-19 Using TryRemote
    with an output parameter to initialize the connection variable</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The direct effect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> return
    value indicating the success or failure of initializing its output parameter.
    We use the return value to determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    variable has been initialized; in other words, the direct effect tells us whether
    the side effect was successful. In this case, a connection exists between the
    side and direct effects of <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>,
    but, as with other <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods, the direct
    effect seems secondary to the side effect!
  prefs: []
  type: TYPE_NORMAL
- en: Methods with by-reference parameters, and more generally those that rely substantially
    on operating by side effect, often result in very procedural code comprising a
    set of logical steps or instructions to accomplish a task. Procedural solutions
    are described as *imperative code* because they’re an explicit sequence of instructions
    to be processed to achieve a result. The contrasting approach is *declarative
    code*, which emphasizes outcomes over specific implementation. A more declarative
    approach pulls the focus away from *how* things get done and allows us to concentrate
    instead on the outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of a declarative style is that we attach more importance to the direct
    effect of a method and make a clear separation between a method’s inputs and its
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We could make our <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method in [Listing 3-19](#list3-19) more declarative by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter and returning the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    reference directly; since <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    is a reference type, we can return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method fails.
    However, the side effects associated with by-reference parameters aren’t really
    an issue when those parameters are reference types. Reference types are often
    mutable—by design, and for good reason—and the fact that multiple variables can
    refer to a single instance is often desirable behavior, as you saw in “Reference
    Variables and Aliasing” on [page 74](#sec5). The benefits of declarative code
    are much more important when we’re using value types, which should be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutation vs. Creation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A method that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is giving
    a strong signal that those parameters will change within the method. Since such
    parameters are aliases for the variables passed as arguments to them, we need
    to pay attention to which variables may be changed. Unexpected modifications to
    variables can cause errors that are hard to identify, especially in code that
    uses multiple threads. If we follow the common advice to make our own value types
    immutable, we reduce the likelihood of such problems occurring, which means we
    should also avoid mutable by-reference parameters of value type. Then, there’s
    only one way that a value type variable can change: by assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: If we have an instance of a value and require an instance with different properties,
    we simply create a new one with the state we want, leaving the original unchanged.
    Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method
    in [Listing 3-20](#list3-20) with the similar <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method in [Listing 3-7](#list3-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-20: Creating a new
    value rather than mutating an existing variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create and return a new instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    that’s initialized using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of a parameter variable, instead of altering the properties of a value
    that has been passed by reference. Note that the method name is <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>. The
    name <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is a direct
    verb and might imply that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    parameter was somehow being altered. In contrast, the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    is an adjective describing the result. Using adjectives for nonmutating methods
    is another indication that no state is being altered. Other examples of this naming
    convention include <samp class="SANS_TheSansMonoCd_W5Regular_11">Sorted</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UpperCased</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Rounded</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method, we pass an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value along with a numeric amount by which to increment its value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable in the
    calling code isn’t changed; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method returns a *new* <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with the required value. We assign the new value to a different variable
    here, but we could have overwritten the original <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable with the new instance instead.
  prefs: []
  type: TYPE_NORMAL
- en: Not all objects are values, and sometimes it’s convenient for certain objects
    to be mutable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object you saw earlier has mutable state that can be changed via its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing is useful when we require changes to an object to be visible via all
    *references* to that object, but the benefits of such side effects aren’t so clear
    for value types. Side effects aren’t limited to output parameters. They occur
    anytime we can modify the state of an object that’s visible outside the scope
    in which we make the change, including via a plain reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the state of any object requires special care and attention, especially
    in the presence of multiple threads, so if we limit the need to modify our objects,
    we reduce the potential for problems. If we make all value types immutable, we
    reduce the prevalence of side effects, which can be difficult to identify and
    sometimes make our logic less clear.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to creating a new value based on the properties of an
    existing instance is to use the non-destructive mutation syntax, introduced in
    [Chapter 2](chapter2.xhtml). [Listing 3-21](#list3-21) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword to copy an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    variable and provide a new value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp>
    property of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-21: Copying an instance
    as a template</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors on each
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type enable us to copy an instance and change selected properties for the new
    instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword. Non-destructive mutation was introduced for record types in C# v9.0,
    and since C# v10.0, we can also use it with structs and record structs, and even
    anonymous types.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor also
    allows us to give a property a value by using object initialization (as shown
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> variable
    in [Listing 3-21](#list3-21)) or via a constructor, but once its value is set
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>, the property is
    immutable. If we’d used <samp class="SANS_TheSansMonoCd_W5Regular_11">private
    set</samp> accessors for the properties instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>,
    the object initialization and non-destructive mutation syntax wouldn’t be possible.
    Non-destructive mutation and object initialization both require either a public
    <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> or public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Copying selected properties of immutable values is another aspect of a declarative
    approach to problem-solving, and in some circumstances makes it simpler and more
    direct to create new values by using existing variables as a kind of template.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarative Code
    and Performance</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a declarative style can lead to code that is clearer and more direct but
    often results in more copies of variables being created, adding storage expense.
    This is particularly relevant for value types for which the cost of copying large
    instances may impact a program’s performance. Up to this point, we have considered
    only quite small instances, which would be unlikely to negatively impact performance
    significantly. While reference variables are always all the same size, values
    can be any size. To an extent, size matters when we’re copying values around.
    A value type that simply wraps a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    field will be cheaper to copy than one that has lots of fields, which is why we’re
    often advised to keep value types small.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of *small* varies but is commonly between 16 and 24 bytes. Note
    that on a 64-bit architecture, references are 8 bytes each, so it’s not hard to
    imagine a useful value type that exceeds the recommended size limit. We’ll explore
    some of the performance characteristics of large value types in [Chapter 8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the size of a value type shouldn’t be the primary motivation for
    choosing a class or record over a struct or record struct. If we want instances
    of a type to have value semantics, we should make it a value type, regardless
    of how large it might be. When we pass value type variables as arguments for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, no copy of the instance is made because those arguments are passed
    by reference. Might the preference for returning values over using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters affect
    the efficiency of our code?
  prefs: []
  type: TYPE_NORMAL
- en: For values with several fields, avoiding the copying might well represent a
    net performance gain, but we should also consider the impact of our choices on
    *human* readers. It might seem attractive to use by-reference parameters to avoid
    copying large values, except that using a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter strongly
    implies that the argument passed is likely to change. If we want our code to be
    as self-documenting as possible, using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameters as an *optimization* might be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameters, we can
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, which
    are *immutable* by-reference parameters. Arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters are passed by reference in exactly the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, but an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is
    read-only within the method. In the next section, we’ll explore how to avoid copying
    value type method arguments by using read-only reference parameters, as well as
    how to return values by reference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Read-Only References and Returning by
    Reference</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read-only references and returning by reference are related concepts, and both
    can help us reduce the number of copies of value type instances in our code. First
    we’ll look at read-only reference parameters, which we denote using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword on a method parameter.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, like the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, makes a by-reference parameter, but, unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, it prevents
    the value of the underlying variable from being changed. In other words, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is immutable.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters when
    we’re passing large value type instances as arguments might be beneficial because
    we avoid copying the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we can also pass a reference to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter, but there’s no reason to do so. Passing a reference by reference is
    useful only if we need to change the reference to refer to a new instance. For
    that to work, we need a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter. No performance
    benefit is associated with passing a reference by reference, as there may be with
    value types.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-22](#list3-22) shows a simple expression-bodied method, <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>,
    that calculates a distance from its <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter values,
    both of which are value types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-22: Read-only reference
    parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">time</samp> variables use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier, making them read-only reference parameters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    method. Since the parameter variables are read-only, the compiler will reject
    any attempt to set mutable properties, change public fields, or assign a new value
    to either of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a method that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, we must
    also modify the argument we’re passing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> keyword. By contrast,
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    do *not* require the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As with reference and output parameters, we can overload <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    with a version that has value parameters. The overload *without* modifiers takes
    precedence in overload resolution if we don’t specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the argument. We can explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    for an argument passed to an input parameter to select the version taking its
    parameters by reference. As mentioned earlier in the chapter, overloading methods
    based solely on whether a parameter is passed by reference or by value is likely
    to be a source of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only reference parameters are designed to be transparent in the calling
    code; that is, passing an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter appears the same as passing an argument by value. One consequence is
    that a method may be modified to receive its parameters by read-only reference
    instead of by value, but without requiring changes to the calling code. Arguments
    that were previously passed by value would then be passed by reference. This matters
    only if the *argument* variables may change—perhaps within a different thread.
    Bear in mind that only the parameter variables within the method are read-only;
    the argument variables usually aren’t. Since the argument passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is passed by reference, any change to the argument’s value will be reflected
    in the value of the parameter variable inside the method. [Listing 3-23](#list3-23)
    demonstrates that it’s possible to modify the value of an argument passed to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter even without
    multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-23: Modifying a read-only
    parameter’s value via a callback delegate</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value by read-only
    reference and an <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> delegate.
    A *delegate* is a variable that refers to a method; here, we use the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> type for the delegate
    that represents a method with no parameters and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method, we copy the *value* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter into a temporary variable ❶. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    delegate before testing that the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is now different from the value copied to <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp>
    before we called the delegate ❷. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>,
    we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> value along
    with a lambda for the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    parameter. The lambda closes over the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable, whose value is changed by the lambda ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The test within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method passes because the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter is an alias to the calling code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable’s value changes inside the lambda, the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is also changed. We should therefore be cautious of methods
    that have both <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    and delegate parameters. More generally, we should be suspicious of code that
    changes the values of any variable passed as an argument to a method, especially
    if the method and calling code can run on different threads of execution. The
    potential errors caused by changing an apparently read-only variable could be
    difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Values
    by Reference</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although instances of value type aren’t generally copied by reference, we can
    return a value type instance by reference, and receive the returned reference
    by using a by-reference variable. This can be useful if we’re particularly sensitive
    to the cost of copying large instances, although the technique is sufficiently
    complex that we probably shouldn’t use it routinely. [Listing 3-24](#list3-24)
    shows a struct whose instances will be larger than a reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-24: An Address struct
    with multiple fields</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> struct has
    four <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> backing fields,
    so an instance of the struct is somewhat larger and more expensive to copy than
    a single reference. If huge numbers of instances were being copied around, we
    might want to address the cost of some of those copies. However, returning by
    reference isn’t guaranteed to be cheaper than returning even large values by value,
    and may even represent a performance cost. Even so, if careful performance analysis
    identified instance copying as an issue, returning values by reference might prove
    beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: When we access a property, we inadvertently make a copy of the property’s value.
    We can avoid making this copy by returning the value by reference, known as a
    *reference return value*, or simply a *ref return*. We mark a value as being a
    ref return by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword, as we do when modifying by-reference method parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class in [Listing 3-25](#list3-25) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field value by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-25: The Destination
    property returning the destination field value by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword to the property and to the variable being returned by reference.
  prefs: []
  type: TYPE_NORMAL
- en: When we access a property that returns its value by reference, we can also receive
    that value by reference without copying it at all. A *by-reference variable*,
    or *ref local*, is a local variable that refers to the same variable as the ref
    return. This is best illustrated with a simple example. In [Listing 3-26](#list3-26),
    we receive the ref return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail.Destination</samp>
    by using a local reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-26: Consuming a value
    returned by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable is
    an alias to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> instance,
    not a copy of its value. Again, note that we have to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on both the target variable and the property access; if we forget either,
    the compiler will give us an error. If we omit both, we simply copy the property’s
    value by value into a normal variable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing Modifications
    to Data</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with by-reference parameters, ref return values and ref locals introduce
    an alias to a value. If we modify a value through such an alias, we need to make
    sure we know where those changes will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the ref local reference to mutate the field in <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    too, although in this example we can only assign it a completely new value, since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> is a read-only struct.
    [Listing 3-27](#list3-27) demonstrates that modifying the ref local also changes
    the field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-27: Mutating a field
    by using a ref local variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to modify a *private* field of an instance in this way might not
    be desirable. First, it violates the encapsulation of the field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class, and second, as with any alias, directly altering an object would likely
    cause problems in multithreaded code. A *race condition* occurs whenever an object’s
    state can be altered by multiple threads simultaneously, or when one thread can
    read an object before another thread has finished changing it. The size of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> type means that assigning
    a new value won’t be an atomic operation, meaning that a second thread could read
    a partly initialized instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common approach to addressing race conditions is to protect access to a
    variable from multiple threads by using a lock. Locking access to the data within
    the property itself isn’t sufficient in this situation because the underlying
    data can be modified outside the property definition; we’d need to lock every
    use of the property, which would likely hamper our code’s performance. Fortunately,
    we have a less intrusive solution: we can simply make the property immutable.
    Sharing immutable state has none of the drawbacks associated with changing data
    from multiple threads.'
  prefs: []
  type: TYPE_NORMAL
- en: To protect the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> from modifications,
    we can change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property to return a read-only reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field. If we return such a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable, the calling code needs to also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword for the target variable, as [Listing 3-28](#list3-28) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-28: Preventing mutation
    of a ref return</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler won’t allow any modifications via the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp>
    reference variable. We’ve also made the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field read-only in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class. This means that we *must* use a read-only reference if we return a reference
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field.
    If we attempt to return a read-only field by reference without the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly
    ref</samp> modifier, the compiler gives us this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can assign one <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> variable
    to another by using the same syntax as assigning a ref local to the result of
    a property. Note that a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable can be assigned from a non-read-only reference. An automatic and implicit
    conversion occurs from a plain—or *writable*—ref return or a ref local *to* a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable, but
    not in the other direction. A read-only reference can’t be assigned to a writable
    ref local. Doing so would break the immutability guarantees of a read-only reference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keeping By-Reference
    Variables Within Scope</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods can return values by reference too, and the syntax is the same as for
    properties. However, the lifetime of the variable returned by reference must be
    guaranteed to last at least as long as the reference’s lifetime. More formally,
    the scope of the variable being referenced must *include* the method or property
    that returns a reference to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: One implication of this rule is that we can’t return a reference to a local
    variable, because the variable will go out of scope as soon as the method or property
    implementation returns. This is most clearly apparent for value types. The lifetime
    of a value ends when the scope ends, so its lifetime is *shorter* than that of
    the reference. The method in [Listing 3-29](#list3-29) fails to compile because
    it’s attempting to return a reference to a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-29: Trying to return
    a reference to a local variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we *could* return a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    variable, the code calling this method would get a reference to a value that no
    longer exists. The compiler prevents such a situation by refusing to compile the
    code, giving this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This rule applies regardless of whether the value of the local variable is a
    reference or an instance of a struct. The *variable* still goes out of scope,
    even when the *instance* exists on the heap. By-reference variables and by-reference
    returns are references to variables, not instances, in exactly the same way as
    by-reference parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Instance Fields of Value Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The compiler will prevent us from returning a variable by reference if it can’t
    guarantee that the variable will be valid for at least as long as any reference
    to it. A less obvious consequence of this rule is that a method or property of
    a value type can’t return a reference to one of that type’s instance fields. The
    code in [Listing 3-30](#list3-30), for instance, won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-30: Returning a struct
    field by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler gives us this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This operation is prohibited because the compiler can’t easily determine that
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance will outlive
    any reference to a field within it. [Listing 3-31](#list3-31) shows a pathological
    example to demonstrate why that might be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-31: Invalid code
    returning a reference to a struct’s field</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in
    [Listing 3-30](#list3-30) could legally return one of its fields by reference,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultRgb</samp> method in
    [Listing 3-31](#list3-31) would be returning a reference to a field of an object
    that has gone out of scope. This is a similar problem to returning a reference
    to a local variable, but this time the problem is directly related to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    being a struct. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variable goes out of scope, each of its fields goes out of scope too. The compiler
    forbids returning any instance field of a value type by reference to avoid even
    the possibility of this happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Member methods and properties of a value type are also prevented from returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> by reference. It’s disallowed
    for exactly the same reason as for instance fields: if it were permitted, we would
    be returning a reference to a local value—an instance of the type—that goes out
    of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">References to References</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a reference variable goes out of scope, the instance it represented still
    exists on the heap until it is garbage collected. We can, therefore, safely return
    a reference to an instance field from a property or method of a class or a record.
    In fact, holding such a by-reference variable *prevents* the instance from being
    garbage collected. In [Listing 3-32](#list3-32), we take a reference to an instance
    field of a local reference type object and return it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-32: Returning a reference
    to a field of a local object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler accepts this code, and it’s safe to use this method, although we
    should certainly be cautious because this technique relies on a somewhat esoteric
    feature of the garbage collector. When <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    returns, the <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable
    goes out of scope, leaving no live reference variables directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    instance created inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    method. Normally, that instance would then become eligible for garbage collection,
    making the by-reference return value a dangling reference. However, the returned
    by-reference variable is enough to prevent the garbage collector from destroying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> instance, so holding
    a by-reference variable to one of its fields remains valid.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, a by-reference variable or parameter to a field within a
    class or record instance represents a managed pointer. *Managed pointers* are
    an implementation detail of the CLR, but the takeaway here is that they’re tracked
    by the garbage collector and considered *object roots*—simply put, references
    or managed pointers to objects known to be live when the garbage collector runs.
    Those objects, in turn, may contain references to other objects on the heap, so
    the chain of references forms a graph of objects currently in use at the time
    the garbage collector runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The garbage collector uses object roots to determine whether object instances
    can be collected: any instance it can’t reach from an object root by following
    the object graph is eligible for collection, and any object that *is* reachable
    survives. Storing a ref local variable is enough to keep the owning object from
    being garbage collected.'
  prefs: []
  type: TYPE_NORMAL
- en: We can always safely return a by-reference parameter variable by reference because
    the variable aliased by the parameter must be in scope for the calling code. Strictly,
    the scope of the variable includes the method accepting the parameter by reference,
    as shown in [Listing 3-33](#list3-33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-33: Returning a ref
    parameter by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp> method’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> parameter can be returned
    by reference because the reference can’t outlive the variable underlying it, since
    the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">hasRed</samp> variable
    in the calling code *includes* <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp>.
    [Listing 3-34](#list3-34) shows that the same is true of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, even though they look like they’re returning a reference to a local
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-34: Returning an
    out parameter by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> parameter in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method is
    a reference to a variable in the calling code, whose scope also includes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Returning out parameters by reference is prohibited as of C# v11.0, although
    returning ref parameters by reference is still permitted.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also return <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters by reference, but they must be returned as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp>, because an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is immutable. If we forget to make the returned reference <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>,
    the compiler gives us a predictable error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Given that the variable used to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter must already be part of the calling code and we can’t modify it in any
    way, returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    by reference typically isn’t useful. We can pass the variable to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter to avoid copying it, but the method could just as easily return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> because the calling code must
    already know about the variable, which could not be modified by the method.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mutable Immutable Properties</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Properties that return by reference can’t have a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor and thus are apparently immutable. However, ref returns have a peculiarity:
    if we return by *writable* reference, as shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property in [Listing 3-35](#list3-35), we can use the reference to mutate the
    underlying value, just as we would use a setter for the property.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-35: Setting a new
    value for a writable reference property</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It may look like we’re setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp> variable
    to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but in fact we’re assigning a new value to the *field* in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class directly, by reference. The semantic difference is somewhat subtle. Part
    of the purpose of a property is to *encapsulate* access to a value, but here we
    deliberately sidestep that encapsulation by returning a reference to the field.
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property returned
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>, this code
    wouldn’t compile because we’d be attempting to modify a read-only variable. A
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property would enable us
    to change its value, but permitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for something that is read-only seems perverse.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Performance
    vs. Simplicity</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ref returns, used in conjunction with ref locals, may be beneficial when we’d
    otherwise be copying large value type instances around, particularly if *many*
    copies would be generated. Ref locals and ref returns are a relatively complex
    optimization feature and need to be introduced with care. When the values are
    small, creating references to them carries no benefit and might even result in
    added cost due to the extra indirection required to access the value. We can use
    ref returns and ref locals for reference variables too, but, again, doing so provides
    no advantage; C# allows it just for the symmetry.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be aware of the costs of *all* by-reference variables, whether they’re
    parameters, return values, or locals. Any by-reference variable introduces extra
    indirection in order to obtain the *actual* underlying value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Final Word on Mutable By-Reference Parameters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, using the mutable by-reference parameter types <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    often indicates very procedural code. In general, if we prefer a more declarative
    style, we make our code more self-describing and often more compact. However,
    output parameters have one use in modern C# that supports that same declarative
    approach. The term of art is *object deconstruction*, although the relevance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters here may not
    be immediately obvious.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with the value tuple, introduced in C# v7.0 to simplify the creation
    of lightweight aggregate types such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable in [Listing 3-36](#list3-36).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-36: A value tuple
    for a point</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable is
    a *named tuple*, where we give a name to each component. The tests show how we
    use those names like properties to obtain their respective values. Value tuples
    support deconstruction: we can decompose the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable into individual variables with names unrelated to the names we gave the
    components. [Listing 3-37](#list3-37) uses the deconstruction syntax to assign
    two separate variables from the fields of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    tuple from [Listing 3-36](#list3-36).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-37: Tuple deconstruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">horizontal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">vertical</samp> variables are
    inferred from the components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    value tuple, and we use them individually without needing to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    at all. We can support this same syntax in our own types by writing a public <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method, which uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters to take all
    of its parameters by reference. [Listing 3-38](#list3-38) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct type with such a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-38: User-defined
    type deconstruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use identical syntax to that shown in [Listing 3-37](#list3-37) to deconstruct
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value into individual
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The compiler translates this code to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct, so the calling code has no mention of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    arguments, or even a call to a method. The compiler’s support for object deconstruction
    allows the code using <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    to access its properties as individual variables in a compact and clear way.
  prefs: []
  type: TYPE_NORMAL
- en: The same syntax for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method is also supported for classes. The compiler generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method for both records and record structs, saving us from having to define our
    own implementation of it.
  prefs: []
  type: TYPE_NORMAL
- en: Simple value types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> value tuple
    are common in functional programs because they encapsulate simple abstractions
    with a minimum of syntactical overhead. They also present little or no performance
    overhead, allowing us to write expressive and efficient programs more simply.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How do we convince people that in programming simplicity and clarity [...]
    are not a dispensable luxury, but a crucial matter that decides between success
    and failure?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Edsger W. Dijkstra, *Selected Writings on Computing: A Personal Perspective*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The concept of pass-by-reference, and how it differs from pass-by-value, is
    much less straightforward than a first glance might suggest. The common explanation—that
    value types are passed by value and reference types by reference—is misleading.
    We don’t pass types around; we pass values. What’s more, by default all values
    are passed by value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what the value of a variable actually *is* helps us more precisely
    define what passing by reference really entails. Passing by value is merely the
    default; we have to actively choose to pass a value by reference. Reference and
    value types differ semantically because the value of a reference variable isn’t
    the same as the instance of the type it represents. For value type variables,
    however, the value and the instance are the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we can pass a variable by reference in several ways, each with different
    behavior and restrictions. We’ve looked at using by-reference method parameters
    to change variables in different ways, as well as at alternatives that can make
    our programs more direct and comprehensible by avoiding side effects and making
    values immutable. Immutability is an important aspect of avoiding problems associated
    with unwanted aliasing, even when by-reference variables are being used. If we
    use read-only properties and read-only structs judiciously, we can take advantage
    of some of the performance benefits of passing by reference, without suffering
    from the complications of managing access to shared mutable data.
  prefs: []
  type: TYPE_NORMAL
- en: When an immutable value is shared by several references, aliasing can never
    present a problem. This is the basic principle behind <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters and read-only local references, but it’s also a consideration when
    we want value semantics for a type but also want the benefits of reference semantics
    for performance.
  prefs: []
  type: TYPE_NORMAL
- en: However, passing by reference isn’t without cost. Every access to a by-reference
    parameter involves an extra level of indirection. This cost is likely to be negligible
    but could adversely affect performance if the method is used in “hot paths” through
    the code. As with any performance optimization, we must measure the outcome to
    determine whether the optimization is worthwhile.
  prefs: []
  type: TYPE_NORMAL
