- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REFERENCE
    AND VALUE PARAMETERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll look at how method parameters and arguments relate to
    reference and value types. We’ll revisit the idea that all variables have a value,
    regardless of their type, and see how to pass values of different types *by value*
    or *by reference* as arguments for methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How *reference* and *by reference* differ in meaning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why aliasing and mutability are so closely related
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How avoiding side effects can make our code clearer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to pass values by reference as an optimization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing method parameters by value or by reference isn’t the same as those parameters
    being value or reference types. In other words, the parameter’s type (value or
    reference) differs from how the method uses that parameter (by value or by reference).
    *Passing* in this context refers to the mechanism for supplying values to a method’s
    parameters and receiving the result the method returns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into those distinctions in detail, let’s look at how method parameters
    and arguments work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in [Chapter 2](chapter2.xhtml), method parameters are a particular
    kind of variable. A parameter variable is declared with a name and explicit type
    in the method’s definition and goes out of scope when the method ends. If the
    method is defined in a generic type or the method itself is generic, the parameter
    type can be generic. When we call the method, we pass arguments to each parameter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'C# has four kinds of method parameters:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Value parameters**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The most common kind of parameter, value parameters, behave as if they’re local
    variables in the method. A value parameter is initialized with the value of the
    argument passed to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference parameters**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: These parameters take the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier, signifying that they’re passed by reference. The arguments passed also
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to reinforce
    that the argument and the parameter both refer to the same memory location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Output parameters**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: These are parameters that use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, meaning they’re given a new value by the method. Output parameters are
    also passed by reference. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier for reference parameters, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier for both the argument being passed and the parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Input parameters**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This special kind of reference parameter uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to indicate that its value doesn’t change within the method. Unlike <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, the argument passed to an input parameter doesn’t require the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    is designed to be transparent to calling code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特殊类型的引用参数使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符来表示它的值在方法内部不会改变。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数不同，传递给输入参数的实参不需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 设计时是为了对调用代码透明的。
- en: Reference, output, and input parameters are special variables in that they indicate
    a level of indirection to an actual variable. They are known collectively as *by-reference
    parameters*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 引用、输出和输入参数是特殊的变量，因为它们表示指向实际变量的间接层级。它们统称为*通过引用传递的参数*。
- en: When we call a method, the arguments we pass populate the parameters we’ve declared
    for that method. When the parameter is a value parameter, our argument for it
    is passed by value. When the parameter is any of the by-reference parameters,
    our argument is passed by reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个方法时，传递的参数会填充我们为该方法声明的参数。如果参数是值参数，那么我们的实参是通过值传递的。如果参数是任何一种通过引用传递的参数，则我们的实参是通过引用传递的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Types vs.
    By-Reference Parameters</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用类型与通过引用传递的参数</samp>
- en: 'By-reference parameters are sometimes confused with reference type variables,
    in part because the phrase *pass by reference* is often used along with its companion,
    *pass by value*, to describe how reference types differ from value types. Consider
    Microsoft’s guide to framework design ([*http://<wbr>msdn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/library<wbr>/ms229017<wbr>.aspx*](http://msdn.microsoft.com/en-us/library/ms229017.aspx)),
    which includes the following statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递的参数有时会与引用类型变量混淆，部分原因是因为“*通过引用传递*”这一短语常与其搭档“*通过值传递*”一起使用，用来描述引用类型与值类型的区别。参考微软的框架设计指南（[*http://<wbr>msdn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/library<wbr>/ms229017<wbr>.aspx*](http://msdn.microsoft.com/en-us/library/ms229017.aspx)），其中包括以下内容：
- en: Reference types are passed by reference, whereas value types are passed by value.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引用类型通过引用传递，而值类型通过值传递。
- en: This is a not-quite-accurate description of the mechanics of passing by reference.
    To say that reference types are passed by reference is conflating the concepts
    of type and passing. Arguments for by-reference parameters are passed by reference,
    no matter the argument’s type. Put another way, arguments of either reference
    or value type may be passed either by reference or by value, according to the
    presence or absence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the method’s parameters. A by-reference parameter is not itself a
    reference, but the variable it refers to might be. Terminology is fun, isn’t it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这对通过引用传递的机制描述并不完全准确。说引用类型是通过引用传递的，将类型与传递方式的概念混淆了。无论实参的类型如何，传递给通过引用传递的参数的实参都会通过引用传递。换句话说，无论是引用类型还是值类型的实参，都可以根据方法参数是否包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符来决定是通过引用传递还是通过值传递。一个通过引用传递的参数本身不是引用，但它所指向的变量可能是。术语有趣吧？
- en: 'In [Chapter 2](chapter2.xhtml), we explored how reference types and value types
    have different copy semantics, and passing arguments and copying variable values
    are related ideas. In particular, when we pass an argument by value, we make a
    copy of its value. The Microsoft documentation article quoted earlier goes on
    to say this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中，我们探讨了引用类型和值类型在复制语义上的不同，以及传递参数和复制变量值是如何相关的。特别是，当我们通过值传递参数时，我们是对其值进行了复制。前面引用的微软文档文章继续这样写道：
- en: Changes to an instance of a reference type affect all references pointing to
    the instance. [...] When an instance of a value type is changed, it of course
    does not affect any of its copies.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对引用类型实例的修改会影响所有指向该实例的引用。[...] 当修改一个值类型实例时，当然不会影响其任何副本。
- en: The operative word here is *instance*. We can have multiple references to a
    single instance of a reference type. Copying a reference doesn’t make a copy of
    the *instance*, just a copy of the reference’s value. By contrast, a copy of a
    value type variable is a new instance, independent of the original value. The
    value *is* the instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键词是 *实例*。我们可以对引用类型的单个实例有多个引用。复制一个引用并不会复制 *实例*，而只是复制引用的值。相比之下，值类型变量的复制是一个新的实例，它独立于原始值。值
    *就是* 实例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Types and Parameters</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">值类型与参数</samp>
- en: A *value type variable* directly contains the data represented by the member
    fields of the type. This is true whether the variable is a local instance, a field
    stored in another object, or a parameter for a method. Consider the simple value
    type in [Listing 3-1](#list3-1) representing a two-dimensional coordinate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型变量* 直接包含由该类型成员字段表示的数据。无论变量是本地实例、存储在其他对象中的字段，还是方法的参数，这一点都是成立的。考虑 [列表 3-1](#list3-1)
    中表示二维坐标的简单值类型。'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A simple Coordinate
    value type</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-1：一个简单的坐标值类型</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> type has
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields, each of which
    takes up a single location in memory. A variable of this type, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable in [Listing 3-1](#list3-1),
    will directly contain the entire instance. The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable would look more or less like [Figure 3-1](#fig3-1).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 类型有两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 字段，每个字段占用内存中的一个位置。像 [列表 3-1](#list3-1)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量这样的该类型变量，会直接包含整个实例。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量所使用的内存大致类似于 [图 3-1](#fig3-1)
    中的表示。
- en: '![](../images/Figure3-1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Memory representation
    of a simple value</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：简单值的内存表示</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable doesn’t
    refer to the data in memory but rather stores the contents of each field of a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> directly in place.
    If a type has multiple fields, those fields are stored in consecutive locations.
    If we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> into
    another variable, each field’s value in the new variable is an independent copy
    of the corresponding field’s value in the original <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量并不引用内存中的数据，而是直接存储一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 类型每个字段的内容。如果一个类型有多个字段，这些字段会存储在连续的位置。如果我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 复制到另一个变量中，新变量中每个字段的值将是原始
    <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量对应字段值的独立副本。
- en: If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    value as an argument to a method’s value parameter, the whole value is copied
    into the parameter. In [Listing 3-2](#list3-2), we have a method, <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>,
    with two <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value
    parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end</samp>, and we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable as an argument to both parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 值作为参数传递给方法的值参数，整个值将被复制到参数中。在
    [列表 3-2](#list3-2) 中，我们有一个方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>，它有两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 值参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    变量作为参数传递给这两个参数。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A method with
    two value parameters</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-2：一个带有两个值参数的方法</samp>
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>
    method’s parameters are both taken by value, each parameter receives its own copy
    that’s independent of the original value. The result looks something like [Figure
    3-2](#fig3-2) in memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp> 方法的参数都是按值传递的，每个参数都会接收到它自己的副本，且与原始值是独立的。结果在内存中的表现类似于[图
    3-2](#fig3-2)。
- en: '![](../images/Figure3-2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Memory representation
    of a copied value</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：复制值的内存表示</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    parameters are initialized with the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    argument passed to them, and each has its own copy within the method itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    参数被初始化为传递给它们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 参数的值，并且它们各自拥有该值的副本，在方法内部独立存在。
- en: When we assign one value to another or pass a value type instance as an argument
    by value, we copy the value. Two value type variables are always independent instances.
    This is the essence of *copy-by-value* semantics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个值赋给另一个值，或者按值传递一个值类型实例作为参数时，我们是在复制该值。两个值类型变量总是独立的实例。这就是 *按值复制* 语义的本质。
- en: Reference type variables behave differently because their value is a reference.
    A reference’s value is used to identify an instance of the type on the heap or
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型变量的行为不同，因为它们的值是一个引用。引用的值用于标识堆上某类型的实例，或者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Value of a Reference</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用的值</samp>
- en: 'When we create an instance of a reference type, memory is allocated on the
    heap, and a reference identifying the location of that memory is stored in the
    variable. Syntactically, it appears that the type of a reference variable is the
    type of the instance to which it refers, as illustrated here with a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variable:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个引用类型的实例时，内存会在堆上分配，并且一个标识该内存位置的引用会存储在变量中。从语法上来看，引用变量的类型似乎是它所引用的实例的类型，如这里所示的一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 变量：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’d normally refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    variable as a string. However, that’s not completely accurate. It’s more precise
    to say that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a variable
    whose *type* is <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and
    whose *value* is a *reference* to an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type. The type of a reference variable need not exactly match the type of the
    instance. For example, we can use a base class reference variable, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, to refer to a more specific
    reference type instance, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 变量称为一个字符串。然而，这并不完全准确。更精确的说法是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 是一个 *类型* 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    的变量，而它的 *值* 是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型实例的 *引用*。引用变量的类型不一定需要与实例的类型完全匹配。例如，我们可以使用基类引用变量，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，来引用一个更具体的引用类型实例，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。
- en: A reference’s value is an opaque handle used by the Common Language Runtime
    (CLR) to identify an object. We’re not really interested in what the value of
    a reference is; references are just the mechanism by which we access and manipulate
    instances of a reference type, as illustrated in [Figure 3-3](#fig3-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的值是一个不透明的句柄，供公共语言运行时（CLR）用来标识一个对象。我们其实并不关心引用值是什么；引用只是我们访问和操作引用类型实例的机制，如[图
    3-3](#fig3-3)所示。
- en: '![](../images/Figure3-3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Memory representation
    of a string reference</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：字符串引用的内存表示</samp>
- en: In [Figure 3-3](#fig3-3), <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    is a variable whose value is a reference. A reference does not itself have a distinct
    type (certainly not one we can name), but it does have a value. The value of a
    non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a handle
    to an area of memory allocated on the heap that contains the instance of a reference
    type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-3](#fig3-3)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>是一个值为引用的变量。引用本身并没有独立的类型（当然，我们无法为它命名），但它有一个值。一个非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用的值是指向堆上分配内存区域的句柄，该区域包含一个引用类型的实例。
- en: 'This precision matters because when we’re talking about passing or copying
    variables, we really mean passing or copying *values*. For value types, this distinction
    doesn’t exist: the value of a struct variable *is* the instance. However, reference
    variables are distinct from the instances they refer to—when we copy a reference
    variable’s value, we’re making a copy of the reference, not the instance.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种精确度非常重要，因为当我们谈论传递或复制变量时，实际上是指传递或复制*值*。对于值类型而言，这种区别不存在：结构体变量的值*就是*实例。然而，引用变量与它们所指向的实例是不同的——当我们复制一个引用变量的值时，实际上是在复制引用，而不是实例。
- en: Some languages use pointers to objects in memory, but a reference isn’t quite
    the same as a pointer. References can’t be used for just anything in memory. They’re
    specifically used to access reference type objects on the heap and to track those
    objects when they move around as a result of garbage collection and memory compaction.
    The details of those processes are hidden from us and handled automatically as
    part of the memory management for reference types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言使用指针来访问内存中的对象，但引用与指针略有不同。引用不能像指针一样用于内存中的任何位置。它们专门用于访问堆上的引用类型对象，并在垃圾回收和内存压缩时跟踪这些对象的移动。我们不需要关心这些过程的细节，它们作为引用类型内存管理的一部分被自动处理。
- en: We can think of the value of a reference as being a kind of address. In this
    respect, a reference value behaves very much like a value type instance. Like
    a value type variable, a reference type variable directly contains its value (an
    address) and lives within the scope of its parent, which might be the stack frame
    for the local variables of a method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将引用的值看作是一种地址。在这方面，引用值的行为与值类型实例非常相似。像值类型变量一样，引用类型变量直接包含它的值（一个地址），并且存在于其父作用域内，可能是方法的局部变量栈帧。
- en: 'With that in mind, consider this: *all* variables, whether they represent reference
    or value types, have values that may be copied. More than that, by default, all
    variable values are copied—and passed—*by value*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，考虑一下：*所有*变量，无论是表示引用类型还是值类型，都有可能被复制。更重要的是，默认情况下，所有变量值都是按值*复制*并传递的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Variables
    and Aliasing</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用变量与别名</samp>
- en: '*Aliasing* refers to accessing a single memory location via multiple variables.
    As you’ve seen, when we copy one reference to another, such as when we pass a
    reference as an argument to a method, we create two aliasing references—the argument
    variable and the parameter variable—to the same object in memory.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*别名*指的是通过多个变量访问同一内存位置。正如你所见，当我们将一个引用复制到另一个引用时，例如将引用作为参数传递给方法时，我们就创建了两个指向同一内存对象的别名引用——参数变量和参数对应的变量。'
- en: In contrast, when we pass a value type instance as an argument, the argument
    variable and parameter variable are identical but independent copies of each other.
    The difference between reference types and values in this respect is most significant
    when the instances are mutable (that is, their state can be altered).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当我们将值类型实例作为参数传递时，参数变量和参数对应的变量是完全相同但独立的副本。参考类型和值类型在这方面的区别在实例是可变时最为显著（即它们的状态可以改变）。
- en: Aliasing can be intentional and useful, such as when we want changes to an object
    to be observable by all references to it, wherever they might be. For example,
    see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> classes in [Listing 3-3](#list3-3);
    we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    type by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>
    method of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object stores
    a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance used to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 别名化可以是有意为之且有用的，比如当我们希望对某个对象的更改能被所有引用该对象的地方观察到时。例如，请参阅[示例 3-3](#list3-3)中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    类；我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 方法来创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    类型的实例，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 对象保存了对用于创建
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 实例的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    实例的引用。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Storing a reference
    to a DataStore as a property of Command</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-3：将 DataStore 的引用作为 Command
    的属性保存</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> method
    returns a reference to the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    object, with its reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance. We can *mutate*—change the state of—the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods, and whether
    we use a local <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    variable or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object
    returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>,
    we’ll update the same <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance because both references are aliases for the same object, as demonstrated
    in [Listing 3-4](#list3-4).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 方法返回对新创建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 对象的引用，该对象持有对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 实例的引用。我们可以通过使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp>
    方法来*修改*（更改状态）<samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 对象，无论我们使用本地的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 变量，还是使用从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 返回的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> 属性，我们都会更新相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 实例，因为这两个引用都是指向同一个对象的别名，如[示例
    3-4](#list3-4)所示。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Mutating the DataStore
    instance via an alias</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-4：通过别名修改 DataStore 实例</samp>
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> method
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> property
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> variable and
    test that the state of the local variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp>
    has been changed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> 变量的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> 属性来调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    方法，并测试名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp> 的本地变量的状态是否已被更改。
- en: 'Value type variables are never aliases for a single instance, so changes to
    an instance are visible only in the variable used to make the change. Value type
    instances are copied by value, so each copy is an independent instance. This process
    is analogous to me sending you a document as an email attachment: we both have
    our own copy of the document, so if I change my copy, your copy is unaffected,
    and vice versa.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型变量从不是单一实例的别名，因此对实例的更改只对用于进行更改的变量可见。值类型实例是按值复制的，因此每个副本都是独立的实例。这个过程类似于我将文档作为电子邮件附件发送给你：我们每个人都有文档的副本，因此如果我更改了我的副本，你的副本不会受到影响，反之亦然。
- en: However, if I instead send a link to a shared document that we can both edit,
    any change either of us makes will be visible to us both via that link. The link
    is similar to a reference; it’s a kind of address for the document, but it’s not
    the document itself. The link represents a level of indirection to the real document.
    In exactly the same way, a reference variable doesn’t contain an object but instead
    a reference, and the object’s instance is accessed indirectly via that reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我发送一个我们都可以编辑的共享文档的链接，那么我们双方所做的任何更改都将通过该链接对我们两个人可见。这个链接类似于一个引用；它是文档的地址，但它不是文档本身。这个链接代表了指向真实文档的间接层次。完全同样地，引用变量并不包含对象，而是一个引用，通过该引用间接访问对象的实例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mutable By-Reference Parameters</samp>
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可变的按引用传递参数</samp>
- en: By default, method parameters are value parameters, meaning that arguments passed
    to them are passed by value, regardless of the argument’s type. In this section,
    we’ll look at the *mutable by-reference parameters*, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, which cause arguments
    to be passed instead by reference.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，方法参数是值参数，这意味着传递给它们的参数是按值传递的，无论参数的类型如何。在本节中，我们将讨论*可变的按引用传递参数*，即<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>，它们使得参数按引用传递。
- en: Value type instances and references can both be passed by reference by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, so it’s important to understand that by-reference parameters are different
    from reference type *value* parameters. When we pass a reference as an argument
    to a reference type value parameter, the same object instance is referenced by
    both the argument and parameter variables, and any change to the instance is visible
    via either variable. A by-reference parameter, in contrast, is an alias for the
    value of the argument variable, whether that value is a reference or value type
    instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的实例和引用都可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>修饰符按引用传递，因此理解按引用传递的参数与引用类型的*值*参数不同是很重要的。当我们将引用作为参数传递给引用类型值参数时，参数和引用变量都指向相同的对象实例，对实例所做的任何更改都可以通过任一变量看到。相比之下，按引用传递的参数是参数变量值的别名，无论该值是引用类型还是值类型实例。
- en: The presence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier on a parameter
    means that when we call the method, the address of the argument’s value is passed
    rather than a copy of the value. This extra level of indirection means that regardless
    of the argument’s type, both the caller and the method directly access the same
    value. If the argument’s value is a reference, we can change it to refer to a
    new instance or assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to it, and that change is visible via both the argument and the parameter variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数上使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>修饰符意味着，当我们调用方法时，传递的是参数值的地址，而不是值的副本。这个额外的间接层次意味着无论参数的类型如何，调用者和方法都能直接访问相同的值。如果参数的值是引用类型，我们可以将它更改为指向一个新实例，或者将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>赋给它，这一变化通过参数和参数变量都能看到。
- en: To illustrate the difference between reference variables and by-reference parameters,
    consider [Listing 3-5](#list3-5), where we pass a reference by value to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method that attempts
    to change its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明引用变量和按引用传递的参数之间的区别，考虑[列表 3-5](#list3-5)，其中我们通过值传递一个引用给尝试更改其<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数的<code>AutoAppend</code>方法。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Creating a new
    instance versus changing an instance</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-5：创建新实例与更改实例</samp>
- en: This test fails, even though <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is a reference type. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    operator appears as though it’s mutating the string, it actually creates a new
    string with the updated contents and returns a new reference to it. The new reference
    and instance are visible within the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method but not outside it. The original string is unchanged.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>是引用类型，这个测试仍然会失败。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>操作符看起来像是在修改字符串，实际上它创建了一个包含更新内容的新字符串，并返回一个新的引用指向它。新的引用和实例在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法中可见，但在方法外部不可见。原始字符串没有变化。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method isn’t
    changing the shared <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance, but rather the *value* of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> here
    changes the reference to refer to a new, different instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable used as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    still refers to the original, unchanged instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法并没有改变共享的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>实例，而是改变了其<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数的*值*。在这里调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>会改变引用，使其指向一个新的、不同的实例。用作<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>参数的<samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>变量仍然指向原始的、未改变的实例。
- en: This demonstrates clearly that when we pass a reference as an argument, it is,
    by default, passed by value. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method in [Listing 3-5](#list3-5) to work as expected, we need to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> reference by reference
    so that when the method alters the value of the reference *variable*, the change
    is visible to the calling code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地证明了，当我们按引用传递一个参数时，默认情况下它是按值传递的。为了使[清单 3-5](#list3-5)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法按预期工作，我们需要按引用传递<samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>引用，这样当方法更改引用*变量*的值时，变化能被调用代码看到。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing References
    by Reference</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按引用传递引用</samp>
- en: The most direct way to make our test in [Listing 3-5](#list3-5) pass is to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> a by-reference parameter.
    [Listing 3-6](#list3-6) shows the same <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method as [Listing 3-5](#list3-5), except in this version we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter by reference by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们在[清单 3-5](#list3-5)中的测试通过的最直接方法是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数改为引用类型。[清单 3-6](#list3-6)展示了与[清单
    3-5](#list3-5)相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法，不同之处在于，在这个版本中，我们通过在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数上使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，使其通过引用传递。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Using the ref
    modifier to pass name by reference</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-6：使用ref修饰符按引用传递name</samp>
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    on both the method’s parameter and the argument we pass to it because we’re passing
    a reference to a variable. The test now passes because the changes that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method makes to the
    value of the reference variable are visible via the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable in the calling code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法的参数和传递给它的参数上都使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，因为我们是按引用传递变量。现在测试通过了，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法对引用变量值所做的更改可以通过调用代码中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>变量看到。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter is,
    in effect, an alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable, as illustrated in [Figure 3-4](#fig3-4).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: A by-reference
    parameter aliases a variable.</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of using a by-reference parameter is that the argument and the
    parameter variables don’t just refer to the same instance—they’re effectively
    the same reference. We can still use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance (for example, to access properties or call methods), and the compiler
    hides the extra level of indirection afforded by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on the parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Values by
    Reference</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can pass value type variables by reference too. Keep in mind that passing
    arguments by reference doesn’t imply that the parameter is a reference variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: When we pass a value type instance as an argument to a method, the method normally
    gets a copy of the instance because of the copy-by-value semantics of value types.
    As you’ve seen previously, any changes made to the fields of the instance inside
    the method aren’t visible to the calling code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If we require those changes to be visible outside the method, we need to pass
    the value by reference. In [Listing 3-7](#list3-7), we introduce an <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method that takes a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value type parameter by reference and changes its value. Value types like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> should almost always be immutable,
    and you’ll see in “Mutation vs. Creation” on [page 89](#sec22) how to express
    this differently. This example merely demonstrates that the mechanism for passing
    value types by reference is identical to passing references by reference.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Value type by-reference
    parameters</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    to pass the argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    parameter by reference, just as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter in [Listing 3-6](#list3-6). As a result, the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is visible
    to the calling code, as shown in [Listing 3-8](#list3-8).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Using the ref
    modifier to pass speed by reference</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable
    is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> by
    reference, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> is aliased
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method.
    Both the calling code and <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    are effectively using the same variable, so any changes to the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter are visible within
    both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method
    and the code that calls it. The test shows that we’re expecting the value to be
    changed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*To reiterate, by-reference parameters aren’t the same as reference type variables.
    A* reference type variable *refers to an instance of a reference type, whereas
    a* by-reference parameter *refers to a variable, which can be either a reference
    type or a value type.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: References can refer only to an object on the heap. If we assign a reference
    type variable to an instance of a value type, the value is boxed onto the heap,
    and the variable refers to the boxed copy. A by-reference parameter adds an extra
    level of indirection to a variable’s value. When we pass a value type instance
    by reference, the value is neither boxed nor copied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Output
    Parameters</samp>
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Output parameters*, designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, are mutable by-reference parameters and are usually used when we require
    a method to create a new instance of an object for that parameter variable. They’re
    similar to reference parameters in that they, too, alias the variable used as
    the argument. The argument we pass to the method is usually uninitialized, and
    the method will initialize it by assigning a value to populate the output parameter
    variable.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: More formally, the difference between a reference parameter and an output parameter
    is that a reference argument must be definitely assigned before it’s passed, whereas
    an output argument may or may not be initialized when it’s passed, but the parameter
    must be assigned a value within the method either way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Output parameters are typically used when acquiring a new instance of an object
    could fail without the failure being a fatal or even serious problem. Examples
    include parsing a string for a specifically formatted value, connecting to an
    unreliable service, and reading a value from a shared resource such as a queue,
    which could be empty. In cases like these, we often want a way to attempt the
    process and be able to either ignore a failure or retry the operation. If the
    operation succeeds, we receive a valid object as a result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The common approach to this use case is to define a method that takes at least
    one output parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    indicating success or failure. If the method succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter is initialized with a new object, and the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    indicating that the argument passed has been successfully initialized. If the
    operation is unsuccessful, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating to the caller that the output argument’s value should be ignored. This
    is a common technique in C# known as <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the TryXXX Idiom</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Standard Library has several examples of using <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> to parse a string
    for a specific kind of value, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> parameter
    and an output parameter for a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value. If the parse fails, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
    If the parse succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value will contain the date parsed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    [Listing 3-9](#list3-9) demonstrates how we might use this idiom.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: The Try</samp>XXX
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">idiom</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">logTime</samp> variable passed
    as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    may come from an unreliable source, such as user input or a file. Incorrectly
    formatted dates are an error but shouldn’t be considered an exceptional case.
    A successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    means the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> variable
    is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> instance.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp>
    variable is default-initialized instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The documentation for DateTime specifies that the failure case initializes
    the variable to the value of the MinValue property, but that’s equivalent to a
    default DateTime.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods often have a companion version that *will* throw an exception when the
    operation fails. The exception version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method, for example, is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.Parse</samp>,
    which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value upon success and throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatException</samp>
    error upon failure. Handling exceptions can be intrusive, and failing to parse
    a string for a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    is the kind of error we’d probably want to handle as soon as it occurs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had used the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method, we might have wrapped the call in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try…catch</samp>
    block, but this could become cumbersome if we had several strings to parse: to
    catch a failure on any one value, we’d have to wrap *each call* in its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    instead is more direct and less verbose.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making a Definite Assignment</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The underlying mechanism for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is identical
    in the CIL, which has native support for by-reference parameters and arguments.
    They differ in the semantics imposed by the compiler: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter is considered initially assigned within the method, meaning a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument must be definitely
    assigned before being passed; an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, on the other hand, is considered initially unassigned within the method,
    regardless of whether it had been assigned a value before the call. We must therefore
    definitely assign all <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters before the method returns. Not doing so results in a compile-time failure,
    as shown by this method, which attempts to return before the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    parameter has been assigned:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We receive this error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The most straightforward way to avoid the error in this example would be to
    preemptively assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> parameter
    before returning <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. By
    convention, an argument passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    method should be considered to have a valid value in the calling code only if
    the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The target <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> variables
    in the calling code are considered definitely assigned only after a *normal* return
    from a method. It’s possible for control to leave the method *abnormally* by throwing
    an exception before all of its <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters have been assigned. If the method exits with an exception, the variables
    used as <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments that
    weren’t definitely assigned prior to the method call remain not definitely assigned.
    Any arguments that were already definitely assigned before the call remain definitely
    assigned, although they may still have been given a new value within the method
    before the exception was thrown.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: However, we’d usually use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> idiom to *avoid* exceptions,
    as most users will expect such methods to not throw any exceptions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Selecting Operations</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    idiom with an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter,
    like that shown in [Listing 3-9](#list3-9), is appealing because the method can
    be used inline in a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to test the return value and capture the required output argument’s
    value all in one place. In [Listing 3-10](#list3-10), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method to determine how to obtain a list of results, using the ternary conditional
    operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> blocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    output variable is declared inline in the argument list for the method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: Using a simple
    out parameter</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the branch following <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> is taken, and we can use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> output variable
    in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>.
    If the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating the connection to the remote resource failed, our code takes the branch
    following the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> and loads
    the results from a cache instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    to declare the type of the inline <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    argument, in which case the compiler will determine its type according to the
    type of the parameter in the method’s definition. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method allows us to handle the failure to connect without the extra cost and complexity
    of handling an exception, and to attempt a different approach to obtain the list
    of results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> method as returning
    multiple values: a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> to
    indicate the success or failure of attempting to obtain a resource, and the resource
    itself when its acquisition succeeds.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Limitations of By-Reference Parameters</samp>
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While methods with by-reference parameters are well suited for certain situations,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    technique, by-reference parameters are not appropriate for every case, and the
    rules around definite assignment can sometimes require a different approach. Other
    restrictions can also affect where we can use these parameters. We’ll look at
    these restrictions in this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Values</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The result of getting a property or indexer value can’t be used directly as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    argument. In [Listing 3-11](#list3-11), we attempt to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> instance
    as an argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-11: Passing properties
    to ref parameters</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler rejects this code with the following error:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The compiler doesn’t allow this code because a property result is a value and
    not a variable. In [Chapter 2](chapter2.xhtml), you saw how variables can be assigned
    to, but values can’t. Accessing a property is exactly the same as reading the
    return value from a method call—something we look at in detail in [Chapter 4](chapter4.xhtml)—and
    methods return values, not variables. We usually use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter when we expect the called method to modify its argument, but because
    a property isn’t a variable, it *can’t* be modified.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: It makes no difference whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is a reference type or a value type. Passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument is essentially
    passing the address of the argument, and we can’t pass the address of a nonvariable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading on By-Reference
    Parameters</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By-reference parameter modifiers are part of the signature of a method. A reference
    or output parameter is effectively a different type than its value parameter equivalent.
    If we have a method that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter, we can overload it with a method that takes that parameter by value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Method overloads can have different return types, so we can write a method that
    takes its parameters by value and returns a new object, and overload it with a
    version taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter
    that modifies the object in place, as shown in [Listing 3-12](#list3-12).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-12: Overloading on
    by-reference modifiers</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, the compiler selects the correct overload based on whether we modify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> argument with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword to pass it by reference
    or omit the modifier to call the version with a value parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We can’t, however, overload a method when the only difference is the kind of
    by-reference modifier for its parameters, as we try to do in [Listing 3-13](#list3-13).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-13: Overloading on
    different modifiers</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This might seem an arbitrary restriction. After all, calling code must differentiate
    between passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument
    and passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument.
    However, the compiler rejects this overload because the Common Language Infrastructure
    (CLI) has no way to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> in the method signature.
    Both are just by-reference parameters, so the two overloads have the same signature,
    as far as the CLI is concerned, resulting in ambiguity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The same restriction applies with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, which we cover in “Read-Only References and Returning by Reference”
    on [page 92](#sec24). As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is simply another
    kind of by- reference parameter, as far as the CLI is concerned.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Overloading a method based purely on whether one or more parameters is taken
    by reference or by value is probably best avoided in any case. Anyone calling
    such a method needs a thorough knowledge of this somewhat arcane corner of overloading
    rules, so such code could easily be confusing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Fields</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making a field a by-reference variable is impossible. Again, this might seem
    arbitrary, but otherwise a by-reference field could become a *dangling* reference—that
    is, it could refer to an object that no longer exists.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As of C# v11.0, by-reference fields are permitted within ref struct types,
    which are specialized value types intended for high-performance applications.
    Numerous restrictions on ref struct types make them less suitable for most general-purpose
    code, so we don’t cover them in this book.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Consider a class like <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    in [Listing 3-14](#list3-14), which attempts to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter in a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> field.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-14: A hypothetical
    Reminder class that stores a field by reference</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Although this approach might seem attractive in principle—say, if we want the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> class to deliberately
    alias the argument to its constructor, or we want to avoid copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    instance—this code doesn’t compile. The compiler rejects it as simply invalid
    syntax because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    instance could be used after the referenced <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    variable has gone out of scope, meaning the field would become a reference to
    memory that no longer exists or, perhaps worse, memory that has been allocated
    to something else. The <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    field would be a dangling reference, something the rules of C# go to great lengths
    to prevent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Although reference types have different lifetimes and enjoy automatic memory
    management, allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    fields only for reference types would indeed be arbitrary and a source of potential
    confusion and error. This capability would also serve little purpose because reference
    variables already exhibit aliasing behavior, and by-reference variables are the
    same size as references for the purposes of copying, so the compiler forbids it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Closures</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The prohibition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> fields is also the
    reason we can’t use a by-reference parameter inside a closure. A *closure* is
    a method that encapsulates behavior along with its *context*—that is, the state
    of any variables declared outside the method’s own scope but used within its implementation.
    Those external variables are said to have been *closed over* by the method, hence
    the term *closure*. [Listing 3-15](#list3-15) shows a method trying to use a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter inside a lambda expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-15: Anonymous closure
    capturing a ref parameter</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method, giving us the following error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The closure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method is the lambda expression used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>
    method. The lambda is an anonymous method that uses the captured <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter, which belongs to the scope of <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>.
    Closure functions are implemented by the compiler as a small, unnamable class
    with fields for each of the closed-over variables. In this example, the variable
    being captured is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter,
    which, as you saw in [Listing 3-14](#list3-14), isn’t a valid field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'As the error message indicates, the same problem applies equally to nested
    local functions and anonymous methods, which can also capture the outer method’s
    variables, including its parameters. Anonymous methods, lambda expressions, and
    local functions are all implemented the same way: using a hidden class synthesized
    by the compiler. Any captured variables become fields of that class.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Iterator Blocks</samp>
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *iterator block* is a compiler-generated class that implements the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> interface
    to iterate over the elements of a sequence, such as an array or a <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>, using deferred execution. Also known as *lazy enumeration*, *deferred
    execution* means that the next element is obtained from the sequence only when
    the user requests it; the sequence is produced on demand and theoretically may
    even be infinite.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: An iterator block is created whenever we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement, as shown in [Listing 3-16](#list3-16). However, the compiler rejects
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp> method
    because it has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-16: A ref parameter
    in an iterator</samp>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp>
    method is attempting to filter the <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp>
    sequence passed as a parameter for elements that match the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter. However, like closures, methods that use iterator blocks can’t have
    by-reference parameters, so the method in [Listing 3-16](#list3-16) fails to compile,
    with this error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each time the method yields a value, control returns to the calling code. When
    the next item is requested, the method must continue at the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> and must do so
    with the same state. The compiler transforms the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement to return an instance of the iterator block class that captures the
    state between requests for each element, similar to the way closures work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated class needs to capture *all* the method parameters and
    any local variables as fields to preserve the method’s state between each request
    for a value, which is why iterator methods can’t have by-reference parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Asynchronous Methods</samp>
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lastly, and for exactly the same reason as closures and iterator blocks, we
    can’t declare by-reference parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    methods like the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryGetResponse</samp>
    method in [Listing 3-17](#list3-17).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-17: An out parameter
    in an asynchronous method</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'This method fails to compile with the following error:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this instance, the compiler synthesizes a hidden class to manage the asynchronous
    invocation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Task.Run</samp>
    method. Asynchronous methods return control to their caller when the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    statement is reached, and so, like iterator blocks, they must preserve the state
    of *all* their variables. The compiler-generated class captures all local variables
    and parameters as fields, so by-reference parameters aren’t allowed for any method
    that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> modifier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extension Methods</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use by-reference parameters in any method that doesn’t use a closure,
    an iterator block, or asynchronous operations using the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    keyword. However, caveats exist for *extension methods*, static methods that extend
    the interface of another type. The first parameter of an extension method is of
    the type being extended and uses the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    modifier. Extension methods have some restrictions on using by-reference parameters
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter. First,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter of an
    extension method can’t be an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, as demonstrated by [Listing 3-18](#list3-18).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-18: Extension method
    using an out parameter</samp>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'This code produces the following error message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If this syntax were permitted, code using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatConnection</samp>
    method could *appear* to call a method using an uninitialized variable, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most users would probably find this code confusing because using an uninitialized
    variable to invoke a method isn’t allowed in any other circumstances. In any case,
    we have much better alternatives to achieve the same result, and the syntax for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameters is also an
    error. We can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier with any of the other parameters, just as we can with any regular method,
    but we can’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> an
    output parameter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter is permitted if
    the parameter is a value type, but not if it’s a reference type. This restriction
    might also seem unreasonable at first glance, but it’s intended to explicitly
    prohibit code like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullify</samp>
    method with the following error:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If this code were permitted, the variable used to call the method could refer
    to a different variable, or—as in this example—be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    after the method returned. Most users would likely be surprised by such behavior,
    so, once again, the compiler forbids it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter when the parameter
    is a value type, which avoids copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    argument’s value. While there’s no benefit to avoiding the copy of a reference,
    copying a large value might be relatively expensive. A value type variable can’t
    be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    but the method can assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    this</samp> parameter, thus changing the argument’s value. Again, doing so would
    likely surprise most users of the method, so even though the syntax is legal,
    we should avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    parameters. If we really want to avoid copying the argument for a <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    parameter, then instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier
    to make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> a read-only
    reference parameter, as discussed in more detail in “Read-Only References and
    Returning by Reference” on [page 92](#sec24).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In spite of their limitations, by-reference parameters are a core part of C#,
    and understanding their semantics is important. None of these restrictions is
    particularly onerous, not least because the use cases for these parameters are
    limited. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    value type parameters in extension methods would be considered unusual by most
    programmers and is a niche-enough feature that it’s probably best avoided in any
    case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Fields *must* be real variables, and C# provides no way to store a by-reference
    variable as a field of a general-purpose type. Every other example in this section
    can be expressed differently to achieve the same result.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Side Effects and Direct Effects</samp>
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods with by-reference parameters intentionally alias variables in the calling
    code, and therefore changes made to those parameters within the method are visible
    outside the method’s scope. Altering the state of an aliased object is an example
    of a *side effect*, which is more generally defined as any change of state that’s
    visible to code outside the scope where the change occurs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Side effects aren’t intrinsically bad, but programs that depend on them heavily
    can be more difficult to follow than those that rely only on direct effects. The
    *direct effect* of a method is whatever it returns, normally referred to as the
    method’s output, with the inputs being the method’s formal parameters. By-reference
    parameters, especially <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, blur the distinction between the inputs and outputs of a method, since
    side effects may alter state that is unrelated to the method’s direct effect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Consider how <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods are commonly used to initialize variables, as shown in [Listing 3-19](#list3-19).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-19 Using TryRemote
    with an output parameter to initialize the connection variable</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The direct effect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> return
    value indicating the success or failure of initializing its output parameter.
    We use the return value to determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    variable has been initialized; in other words, the direct effect tells us whether
    the side effect was successful. In this case, a connection exists between the
    side and direct effects of <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>,
    but, as with other <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods, the direct
    effect seems secondary to the side effect!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Methods with by-reference parameters, and more generally those that rely substantially
    on operating by side effect, often result in very procedural code comprising a
    set of logical steps or instructions to accomplish a task. Procedural solutions
    are described as *imperative code* because they’re an explicit sequence of instructions
    to be processed to achieve a result. The contrasting approach is *declarative
    code*, which emphasizes outcomes over specific implementation. A more declarative
    approach pulls the focus away from *how* things get done and allows us to concentrate
    instead on the outcomes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of a declarative style is that we attach more importance to the direct
    effect of a method and make a clear separation between a method’s inputs and its
    output.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We could make our <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method in [Listing 3-19](#list3-19) more declarative by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter and returning the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    reference directly; since <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    is a reference type, we can return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method fails.
    However, the side effects associated with by-reference parameters aren’t really
    an issue when those parameters are reference types. Reference types are often
    mutable—by design, and for good reason—and the fact that multiple variables can
    refer to a single instance is often desirable behavior, as you saw in “Reference
    Variables and Aliasing” on [page 74](#sec5). The benefits of declarative code
    are much more important when we’re using value types, which should be immutable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutation vs. Creation</samp>
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A method that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is giving
    a strong signal that those parameters will change within the method. Since such
    parameters are aliases for the variables passed as arguments to them, we need
    to pay attention to which variables may be changed. Unexpected modifications to
    variables can cause errors that are hard to identify, especially in code that
    uses multiple threads. If we follow the common advice to make our own value types
    immutable, we reduce the likelihood of such problems occurring, which means we
    should also avoid mutable by-reference parameters of value type. Then, there’s
    only one way that a value type variable can change: by assignment.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If we have an instance of a value and require an instance with different properties,
    we simply create a new one with the state we want, leaving the original unchanged.
    Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method
    in [Listing 3-20](#list3-20) with the similar <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method in [Listing 3-7](#list3-7).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-20: Creating a new
    value rather than mutating an existing variable</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We create and return a new instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    that’s initialized using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of a parameter variable, instead of altering the properties of a value
    that has been passed by reference. Note that the method name is <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>. The
    name <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is a direct
    verb and might imply that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    parameter was somehow being altered. In contrast, the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    is an adjective describing the result. Using adjectives for nonmutating methods
    is another indication that no state is being altered. Other examples of this naming
    convention include <samp class="SANS_TheSansMonoCd_W5Regular_11">Sorted</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UpperCased</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Rounded</samp>.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method, we pass an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value along with a numeric amount by which to increment its value, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable in the
    calling code isn’t changed; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method returns a *new* <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with the required value. We assign the new value to a different variable
    here, but we could have overwritten the original <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable with the new instance instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Not all objects are values, and sometimes it’s convenient for certain objects
    to be mutable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object you saw earlier has mutable state that can be changed via its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing is useful when we require changes to an object to be visible via all
    *references* to that object, but the benefits of such side effects aren’t so clear
    for value types. Side effects aren’t limited to output parameters. They occur
    anytime we can modify the state of an object that’s visible outside the scope
    in which we make the change, including via a plain reference variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Changing the state of any object requires special care and attention, especially
    in the presence of multiple threads, so if we limit the need to modify our objects,
    we reduce the potential for problems. If we make all value types immutable, we
    reduce the prevalence of side effects, which can be difficult to identify and
    sometimes make our logic less clear.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to creating a new value based on the properties of an
    existing instance is to use the non-destructive mutation syntax, introduced in
    [Chapter 2](chapter2.xhtml). [Listing 3-21](#list3-21) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword to copy an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    variable and provide a new value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp>
    property of the copy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-21: Copying an instance
    as a template</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors on each
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type enable us to copy an instance and change selected properties for the new
    instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword. Non-destructive mutation was introduced for record types in C# v9.0,
    and since C# v10.0, we can also use it with structs and record structs, and even
    anonymous types.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor also
    allows us to give a property a value by using object initialization (as shown
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> variable
    in [Listing 3-21](#list3-21)) or via a constructor, but once its value is set
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>, the property is
    immutable. If we’d used <samp class="SANS_TheSansMonoCd_W5Regular_11">private
    set</samp> accessors for the properties instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>,
    the object initialization and non-destructive mutation syntax wouldn’t be possible.
    Non-destructive mutation and object initialization both require either a public
    <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> or public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Copying selected properties of immutable values is another aspect of a declarative
    approach to problem-solving, and in some circumstances makes it simpler and more
    direct to create new values by using existing variables as a kind of template.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarative Code
    and Performance</samp>
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a declarative style can lead to code that is clearer and more direct but
    often results in more copies of variables being created, adding storage expense.
    This is particularly relevant for value types for which the cost of copying large
    instances may impact a program’s performance. Up to this point, we have considered
    only quite small instances, which would be unlikely to negatively impact performance
    significantly. While reference variables are always all the same size, values
    can be any size. To an extent, size matters when we’re copying values around.
    A value type that simply wraps a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    field will be cheaper to copy than one that has lots of fields, which is why we’re
    often advised to keep value types small.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The definition of *small* varies but is commonly between 16 and 24 bytes. Note
    that on a 64-bit architecture, references are 8 bytes each, so it’s not hard to
    imagine a useful value type that exceeds the recommended size limit. We’ll explore
    some of the performance characteristics of large value types in [Chapter 8](chapter8.xhtml).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the size of a value type shouldn’t be the primary motivation for
    choosing a class or record over a struct or record struct. If we want instances
    of a type to have value semantics, we should make it a value type, regardless
    of how large it might be. When we pass value type variables as arguments for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, no copy of the instance is made because those arguments are passed
    by reference. Might the preference for returning values over using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters affect
    the efficiency of our code?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: For values with several fields, avoiding the copying might well represent a
    net performance gain, but we should also consider the impact of our choices on
    *human* readers. It might seem attractive to use by-reference parameters to avoid
    copying large values, except that using a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter strongly
    implies that the argument passed is likely to change. If we want our code to be
    as self-documenting as possible, using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameters as an *optimization* might be surprising.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameters, we can
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, which
    are *immutable* by-reference parameters. Arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters are passed by reference in exactly the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, but an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is
    read-only within the method. In the next section, we’ll explore how to avoid copying
    value type method arguments by using read-only reference parameters, as well as
    how to return values by reference.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Read-Only References and Returning by
    Reference</samp>
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read-only references and returning by reference are related concepts, and both
    can help us reduce the number of copies of value type instances in our code. First
    we’ll look at read-only reference parameters, which we denote using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword on a method parameter.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, like the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, makes a by-reference parameter, but, unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, it prevents
    the value of the underlying variable from being changed. In other words, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is immutable.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters when
    we’re passing large value type instances as arguments might be beneficial because
    we avoid copying the instance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we can also pass a reference to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter, but there’s no reason to do so. Passing a reference by reference is
    useful only if we need to change the reference to refer to a new instance. For
    that to work, we need a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter. No performance
    benefit is associated with passing a reference by reference, as there may be with
    value types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-22](#list3-22) shows a simple expression-bodied method, <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>,
    that calculates a distance from its <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter values,
    both of which are value types.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-22: Read-only reference
    parameters</samp>'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">time</samp> variables use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier, making them read-only reference parameters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    method. Since the parameter variables are read-only, the compiler will reject
    any attempt to set mutable properties, change public fields, or assign a new value
    to either of them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a method that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, we must
    also modify the argument we’re passing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> keyword. By contrast,
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    do *not* require the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier,
    as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with reference and output parameters, we can overload <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    with a version that has value parameters. The overload *without* modifiers takes
    precedence in overload resolution if we don’t specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the argument. We can explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    for an argument passed to an input parameter to select the version taking its
    parameters by reference. As mentioned earlier in the chapter, overloading methods
    based solely on whether a parameter is passed by reference or by value is likely
    to be a source of confusion.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Read-only reference parameters are designed to be transparent in the calling
    code; that is, passing an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter appears the same as passing an argument by value. One consequence is
    that a method may be modified to receive its parameters by read-only reference
    instead of by value, but without requiring changes to the calling code. Arguments
    that were previously passed by value would then be passed by reference. This matters
    only if the *argument* variables may change—perhaps within a different thread.
    Bear in mind that only the parameter variables within the method are read-only;
    the argument variables usually aren’t. Since the argument passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is passed by reference, any change to the argument’s value will be reflected
    in the value of the parameter variable inside the method. [Listing 3-23](#list3-23)
    demonstrates that it’s possible to modify the value of an argument passed to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter even without
    multiple threads.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-23: Modifying a read-only
    parameter’s value via a callback delegate</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value by read-only
    reference and an <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> delegate.
    A *delegate* is a variable that refers to a method; here, we use the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> type for the delegate
    that represents a method with no parameters and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method, we copy the *value* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter into a temporary variable ❶. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    delegate before testing that the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is now different from the value copied to <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp>
    before we called the delegate ❷. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>,
    we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> value along
    with a lambda for the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    parameter. The lambda closes over the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable, whose value is changed by the lambda ❸.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The test within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method passes because the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter is an alias to the calling code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable’s value changes inside the lambda, the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is also changed. We should therefore be cautious of methods
    that have both <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    and delegate parameters. More generally, we should be suspicious of code that
    changes the values of any variable passed as an argument to a method, especially
    if the method and calling code can run on different threads of execution. The
    potential errors caused by changing an apparently read-only variable could be
    difficult to track down.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Values
    by Reference</samp>
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although instances of value type aren’t generally copied by reference, we can
    return a value type instance by reference, and receive the returned reference
    by using a by-reference variable. This can be useful if we’re particularly sensitive
    to the cost of copying large instances, although the technique is sufficiently
    complex that we probably shouldn’t use it routinely. [Listing 3-24](#list3-24)
    shows a struct whose instances will be larger than a reference variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-24: An Address struct
    with multiple fields</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> struct has
    four <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> backing fields,
    so an instance of the struct is somewhat larger and more expensive to copy than
    a single reference. If huge numbers of instances were being copied around, we
    might want to address the cost of some of those copies. However, returning by
    reference isn’t guaranteed to be cheaper than returning even large values by value,
    and may even represent a performance cost. Even so, if careful performance analysis
    identified instance copying as an issue, returning values by reference might prove
    beneficial.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: When we access a property, we inadvertently make a copy of the property’s value.
    We can avoid making this copy by returning the value by reference, known as a
    *reference return value*, or simply a *ref return*. We mark a value as being a
    ref return by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword, as we do when modifying by-reference method parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class in [Listing 3-25](#list3-25) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field value by reference.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-25: The Destination
    property returning the destination field value by reference</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword to the property and to the variable being returned by reference.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: When we access a property that returns its value by reference, we can also receive
    that value by reference without copying it at all. A *by-reference variable*,
    or *ref local*, is a local variable that refers to the same variable as the ref
    return. This is best illustrated with a simple example. In [Listing 3-26](#list3-26),
    we receive the ref return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail.Destination</samp>
    by using a local reference variable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-26: Consuming a value
    returned by reference</samp>'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable is
    an alias to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> instance,
    not a copy of its value. Again, note that we have to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on both the target variable and the property access; if we forget either,
    the compiler will give us an error. If we omit both, we simply copy the property’s
    value by value into a normal variable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing Modifications
    to Data</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with by-reference parameters, ref return values and ref locals introduce
    an alias to a value. If we modify a value through such an alias, we need to make
    sure we know where those changes will be visible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We can use the ref local reference to mutate the field in <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    too, although in this example we can only assign it a completely new value, since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> is a read-only struct.
    [Listing 3-27](#list3-27) demonstrates that modifying the ref local also changes
    the field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> variable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-27: Mutating a field
    by using a ref local variable</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Being able to modify a *private* field of an instance in this way might not
    be desirable. First, it violates the encapsulation of the field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class, and second, as with any alias, directly altering an object would likely
    cause problems in multithreaded code. A *race condition* occurs whenever an object’s
    state can be altered by multiple threads simultaneously, or when one thread can
    read an object before another thread has finished changing it. The size of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> type means that assigning
    a new value won’t be an atomic operation, meaning that a second thread could read
    a partly initialized instance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'One common approach to addressing race conditions is to protect access to a
    variable from multiple threads by using a lock. Locking access to the data within
    the property itself isn’t sufficient in this situation because the underlying
    data can be modified outside the property definition; we’d need to lock every
    use of the property, which would likely hamper our code’s performance. Fortunately,
    we have a less intrusive solution: we can simply make the property immutable.
    Sharing immutable state has none of the drawbacks associated with changing data
    from multiple threads.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: To protect the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> from modifications,
    we can change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property to return a read-only reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field. If we return such a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable, the calling code needs to also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword for the target variable, as [Listing 3-28](#list3-28) shows.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-28: Preventing mutation
    of a ref return</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler won’t allow any modifications via the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp>
    reference variable. We’ve also made the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field read-only in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class. This means that we *must* use a read-only reference if we return a reference
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field.
    If we attempt to return a read-only field by reference without the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly
    ref</samp> modifier, the compiler gives us this error:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can assign one <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> variable
    to another by using the same syntax as assigning a ref local to the result of
    a property. Note that a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable can be assigned from a non-read-only reference. An automatic and implicit
    conversion occurs from a plain—or *writable*—ref return or a ref local *to* a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable, but
    not in the other direction. A read-only reference can’t be assigned to a writable
    ref local. Doing so would break the immutability guarantees of a read-only reference.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keeping By-Reference
    Variables Within Scope</samp>
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods can return values by reference too, and the syntax is the same as for
    properties. However, the lifetime of the variable returned by reference must be
    guaranteed to last at least as long as the reference’s lifetime. More formally,
    the scope of the variable being referenced must *include* the method or property
    that returns a reference to that variable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: One implication of this rule is that we can’t return a reference to a local
    variable, because the variable will go out of scope as soon as the method or property
    implementation returns. This is most clearly apparent for value types. The lifetime
    of a value ends when the scope ends, so its lifetime is *shorter* than that of
    the reference. The method in [Listing 3-29](#list3-29) fails to compile because
    it’s attempting to return a reference to a local variable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-29: Trying to return
    a reference to a local variable</samp>'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'If we *could* return a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    variable, the code calling this method would get a reference to a value that no
    longer exists. The compiler prevents such a situation by refusing to compile the
    code, giving this error:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This rule applies regardless of whether the value of the local variable is a
    reference or an instance of a struct. The *variable* still goes out of scope,
    even when the *instance* exists on the heap. By-reference variables and by-reference
    returns are references to variables, not instances, in exactly the same way as
    by-reference parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Instance Fields of Value Types</samp>
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The compiler will prevent us from returning a variable by reference if it can’t
    guarantee that the variable will be valid for at least as long as any reference
    to it. A less obvious consequence of this rule is that a method or property of
    a value type can’t return a reference to one of that type’s instance fields. The
    code in [Listing 3-30](#list3-30), for instance, won’t compile.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-30: Returning a struct
    field by reference</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler gives us this error message:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This operation is prohibited because the compiler can’t easily determine that
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance will outlive
    any reference to a field within it. [Listing 3-31](#list3-31) shows a pathological
    example to demonstrate why that might be a problem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-31: Invalid code
    returning a reference to a struct’s field</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in
    [Listing 3-30](#list3-30) could legally return one of its fields by reference,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultRgb</samp> method in
    [Listing 3-31](#list3-31) would be returning a reference to a field of an object
    that has gone out of scope. This is a similar problem to returning a reference
    to a local variable, but this time the problem is directly related to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    being a struct. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variable goes out of scope, each of its fields goes out of scope too. The compiler
    forbids returning any instance field of a value type by reference to avoid even
    the possibility of this happening.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Member methods and properties of a value type are also prevented from returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> by reference. It’s disallowed
    for exactly the same reason as for instance fields: if it were permitted, we would
    be returning a reference to a local value—an instance of the type—that goes out
    of scope.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">References to References</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a reference variable goes out of scope, the instance it represented still
    exists on the heap until it is garbage collected. We can, therefore, safely return
    a reference to an instance field from a property or method of a class or a record.
    In fact, holding such a by-reference variable *prevents* the instance from being
    garbage collected. In [Listing 3-32](#list3-32), we take a reference to an instance
    field of a local reference type object and return it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-32: Returning a reference
    to a field of a local object</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The compiler accepts this code, and it’s safe to use this method, although we
    should certainly be cautious because this technique relies on a somewhat esoteric
    feature of the garbage collector. When <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    returns, the <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable
    goes out of scope, leaving no live reference variables directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    instance created inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    method. Normally, that instance would then become eligible for garbage collection,
    making the by-reference return value a dangling reference. However, the returned
    by-reference variable is enough to prevent the garbage collector from destroying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> instance, so holding
    a by-reference variable to one of its fields remains valid.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, a by-reference variable or parameter to a field within a
    class or record instance represents a managed pointer. *Managed pointers* are
    an implementation detail of the CLR, but the takeaway here is that they’re tracked
    by the garbage collector and considered *object roots*—simply put, references
    or managed pointers to objects known to be live when the garbage collector runs.
    Those objects, in turn, may contain references to other objects on the heap, so
    the chain of references forms a graph of objects currently in use at the time
    the garbage collector runs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The garbage collector uses object roots to determine whether object instances
    can be collected: any instance it can’t reach from an object root by following
    the object graph is eligible for collection, and any object that *is* reachable
    survives. Storing a ref local variable is enough to keep the owning object from
    being garbage collected.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We can always safely return a by-reference parameter variable by reference because
    the variable aliased by the parameter must be in scope for the calling code. Strictly,
    the scope of the variable includes the method accepting the parameter by reference,
    as shown in [Listing 3-33](#list3-33).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-33: Returning a ref
    parameter by reference</samp>'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp> method’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> parameter can be returned
    by reference because the reference can’t outlive the variable underlying it, since
    the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">hasRed</samp> variable
    in the calling code *includes* <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp>.
    [Listing 3-34](#list3-34) shows that the same is true of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, even though they look like they’re returning a reference to a local
    variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-34: Returning an
    out parameter by reference</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> parameter in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method is
    a reference to a variable in the calling code, whose scope also includes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method itself.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Returning out parameters by reference is prohibited as of C# v11.0, although
    returning ref parameters by reference is still permitted.*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also return <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters by reference, but they must be returned as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp>, because an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is immutable. If we forget to make the returned reference <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>,
    the compiler gives us a predictable error:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Given that the variable used to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter must already be part of the calling code and we can’t modify it in any
    way, returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    by reference typically isn’t useful. We can pass the variable to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter to avoid copying it, but the method could just as easily return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> because the calling code must
    already know about the variable, which could not be modified by the method.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mutable Immutable Properties</samp>
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Properties that return by reference can’t have a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor and thus are apparently immutable. However, ref returns have a peculiarity:
    if we return by *writable* reference, as shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property in [Listing 3-35](#list3-35), we can use the reference to mutate the
    underlying value, just as we would use a setter for the property.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-35: Setting a new
    value for a writable reference property</samp>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: It may look like we’re setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp> variable
    to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but in fact we’re assigning a new value to the *field* in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class directly, by reference. The semantic difference is somewhat subtle. Part
    of the purpose of a property is to *encapsulate* access to a value, but here we
    deliberately sidestep that encapsulation by returning a reference to the field.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property returned
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>, this code
    wouldn’t compile because we’d be attempting to modify a read-only variable. A
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property would enable us
    to change its value, but permitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for something that is read-only seems perverse.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Performance
    vs. Simplicity</samp>
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ref returns, used in conjunction with ref locals, may be beneficial when we’d
    otherwise be copying large value type instances around, particularly if *many*
    copies would be generated. Ref locals and ref returns are a relatively complex
    optimization feature and need to be introduced with care. When the values are
    small, creating references to them carries no benefit and might even result in
    added cost due to the extra indirection required to access the value. We can use
    ref returns and ref locals for reference variables too, but, again, doing so provides
    no advantage; C# allows it just for the symmetry.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We need to be aware of the costs of *all* by-reference variables, whether they’re
    parameters, return values, or locals. Any by-reference variable introduces extra
    indirection in order to obtain the *actual* underlying value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Final Word on Mutable By-Reference Parameters</samp>
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, using the mutable by-reference parameter types <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    often indicates very procedural code. In general, if we prefer a more declarative
    style, we make our code more self-describing and often more compact. However,
    output parameters have one use in modern C# that supports that same declarative
    approach. The term of art is *object deconstruction*, although the relevance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters here may not
    be immediately obvious.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: We begin with the value tuple, introduced in C# v7.0 to simplify the creation
    of lightweight aggregate types such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable in [Listing 3-36](#list3-36).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-36: A value tuple
    for a point</samp>'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'This <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable is
    a *named tuple*, where we give a name to each component. The tests show how we
    use those names like properties to obtain their respective values. Value tuples
    support deconstruction: we can decompose the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable into individual variables with names unrelated to the names we gave the
    components. [Listing 3-37](#list3-37) uses the deconstruction syntax to assign
    two separate variables from the fields of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    tuple from [Listing 3-36](#list3-36).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-37: Tuple deconstruction</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">horizontal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">vertical</samp> variables are
    inferred from the components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    value tuple, and we use them individually without needing to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    at all. We can support this same syntax in our own types by writing a public <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method, which uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters to take all
    of its parameters by reference. [Listing 3-38](#list3-38) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct type with such a method.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-38: User-defined
    type deconstruction</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use identical syntax to that shown in [Listing 3-37](#list3-37) to deconstruct
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value into individual
    variables:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The compiler translates this code to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct, so the calling code has no mention of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    arguments, or even a call to a method. The compiler’s support for object deconstruction
    allows the code using <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    to access its properties as individual variables in a compact and clear way.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The same syntax for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method is also supported for classes. The compiler generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method for both records and record structs, saving us from having to define our
    own implementation of it.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Simple value types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> value tuple
    are common in functional programs because they encapsulate simple abstractions
    with a minimum of syntactical overhead. They also present little or no performance
    overhead, allowing us to write expressive and efficient programs more simply.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How do we convince people that in programming simplicity and clarity [...]
    are not a dispensable luxury, but a crucial matter that decides between success
    and failure?*'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Edsger W. Dijkstra, *Selected Writings on Computing: A Personal Perspective*'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The concept of pass-by-reference, and how it differs from pass-by-value, is
    much less straightforward than a first glance might suggest. The common explanation—that
    value types are passed by value and reference types by reference—is misleading.
    We don’t pass types around; we pass values. What’s more, by default all values
    are passed by value.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what the value of a variable actually *is* helps us more precisely
    define what passing by reference really entails. Passing by value is merely the
    default; we have to actively choose to pass a value by reference. Reference and
    value types differ semantically because the value of a reference variable isn’t
    the same as the instance of the type it represents. For value type variables,
    however, the value and the instance are the same thing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we can pass a variable by reference in several ways, each with different
    behavior and restrictions. We’ve looked at using by-reference method parameters
    to change variables in different ways, as well as at alternatives that can make
    our programs more direct and comprehensible by avoiding side effects and making
    values immutable. Immutability is an important aspect of avoiding problems associated
    with unwanted aliasing, even when by-reference variables are being used. If we
    use read-only properties and read-only structs judiciously, we can take advantage
    of some of the performance benefits of passing by reference, without suffering
    from the complications of managing access to shared mutable data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: When an immutable value is shared by several references, aliasing can never
    present a problem. This is the basic principle behind <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters and read-only local references, but it’s also a consideration when
    we want value semantics for a type but also want the benefits of reference semantics
    for performance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: However, passing by reference isn’t without cost. Every access to a by-reference
    parameter involves an extra level of indirection. This cost is likely to be negligible
    but could adversely affect performance if the method is used in “hot paths” through
    the code. As with any performance optimization, we must measure the outcome to
    determine whether the optimization is worthwhile.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
