<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="873" id="Page_873"/>16</span><br/>
<span class="ChapterTitle">Stand-Alone Assembly Language Programs</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Until now, this book has relied upon a C/C++ main program to call the example code written in assembly language. Although this is probably the biggest use of assembly language in the real world, it is also possible to write stand-alone code (no C/C++ main program) in assembly language.</p>
<p>In the context of this chapter, <em>stand-alone assembly language programs</em> means that you’re writing an executable program in assembly that does not directly link into a C/C++ program for execution. Without a C/C++ main program calling your assembly code, you’re not dragging along the C/C++ library code and runtime system, so your programs can be smaller and you won’t have external naming conflicts with C/C++ public names. However, you’ll have to do much of the work yourself that C/C++ libraries do by writing comparable assembly code or calling the Win32 API.</p>
<p>The <em>Win32 API</em> is a bare-metal interface to the Windows operating system that provides thousands of functions you can call from a stand-alone assembly language program—far too many to consider in this chapter. This chapter provides a basic introduction to Win32 applications (especially <span epub:type="pagebreak" title="874" id="Page_874"/>console-based applications). This information will get you started writing stand-alone assembly language programs under Windows.</p>
<p>To use the Win32 API from your assembly programs, you’ll need to download the MASM32 library package from <a href="https://www.masm32.com/" class="LinkURL">https://www.masm32.com/</a>.<sup class="FootnoteReference"><a id="c16-footnoteref-1" href="#c16-footnote-1">1</a></sup> Most of the examples in this chapter assume the MASM32 64-bit include files are available on your system in the <em>C:\masm32</em> subdirectory.</p>
<h2 id="h1-501089c16-0001">	16.1	Hello World, by Itself</h2>
<p class="BodyFirst">Before showing you some of the wonders of Windows stand-alone assembly language programming, perhaps the best place to start is at the beginning: with a stand-alone “Hello, world!” program (<a href="#listing16-1" id="listinganchor16-1">Listing 16-1</a>).</p>
<pre><code>; Listing 16-1.asm

; A stand-alone assembly language version of 
; the ubiquitous "Hello, world!" program.

; Link in the Windows Win32 API:

            includelib kernel32.lib

; Here are the two Windows functions we will need
; to send "Hello, world!" to the standard console device:

            extrn __imp_GetStdHandle:proc
            extrn __imp_WriteFile:proc

            .code
hwStr       byte    "Hello World!"
hwLen       =       $-hwStr

; This is the honest-to-goodness assembly language
; main program:

main        proc
            
; On entry, stack is aligned at 8 mod 16. Setting aside
; 8 bytes for "bytesWritten" ensures that calls in main have
; their stack aligned to 16 bytes (8 mod 16 inside function),
; as required by the Windows API (which __imp_GetStdHandle and
; __imp_WriteFile use. They are written in C/C++).
            
            lea     rbx, hwStr
            sub     rsp, 8
            mov     rdi, rsp      ; Hold # of bytes written here

; Note: must set aside 32 bytes (20h) for shadow registers for
; parameters (just do this once for all functions). 
; Also, WriteFile has a 5th argument (which is NULL), 
<span epub:type="pagebreak" title="875" id="Page_875"/>; so we must set aside 8 bytes to hold that pointer (and
; initialize it to zero). Finally, stack must always be 
; 16-byte-aligned, so reserve another 8 bytes of storage
; to ensure this.

            sub     rsp, 030h  ; Shadow storage for args
                    
; Handle = GetStdHandle(-11);
; Single argument passed in ECX.
; Handle returned in RAX.

            mov     rcx, -11                     ; STD_OUTPUT
            call    qword ptr __imp_GetStdHandle ; Returns handle
                                                 ; in RAX
                    
; WriteFile(handle, "Hello World!", 12, &amp;bytesWritten, NULL);
; Zero out (set to NULL) "lpOverlapped" argument:
            
            xor     rcx, rcx
            mov     [rsp + 4 * 8], rcx
            
            mov     r9, rdi    ; Address of "bytesWritten" in R9
            mov     r8d, hwLen ; Length of string to write in R8D
            lea     rdx, hwStr ; Ptr to string data in RDX
            mov     rcx, rax   ; File handle passed in RCX
            call    qword ptr __imp_WriteFile
            
; Clean up stack and return:

            add     rsp, 38h
            ret
main        endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing16-1">Listing 16-1</a>: Stand-alone “Hello, world!” program</p>
<p>The <code>__imp_</code><code>GetStdHandle</code> and <code>__imp_</code><code>WriteFile</code> procedures are functions inside Windows (they are part of the so-called Win32 API, even though this is 64-bit code that is executing). The <code>__imp_GetStdHandle</code> procedure, when passed the (admittedly magic) number –11 as an argument, returns a handle to the standard output device. With this handle, calls to <code>__imp_WriteFile</code> will send the output to the standard output device (the console). To build and run this program, use the following command:</p>
<pre><code>ml64 listing16-1.asm /link /subsystem:console /entry:main</code></pre>
<p>The MASM <code>/link</code> command line option tells it that the following commands (to the end of the line) are to be passed on to the linker. The <code>/subsystem:console</code> (linker) command line option tells the linker that this program is a console application (that is, it will run in a command line window). The <code>/entry:main</code> linker option passes along the name of the main program to the linker. The linker stores this address in a special location <span epub:type="pagebreak" title="876" id="Page_876"/>in the executable file so Windows can determine the starting address of the main program after it loads the executable file into memory.</p>
<h2 id="h1-501089c16-0002">	16.2	Header Files and the Windows Interface</h2>
<p class="BodyFirst">Near the beginning of the “Hello, world!” example in <a href="#listing16-1">Listing 16-1</a>, you’ll notice the following lines:</p>
<pre><code>includelib kernel32.lib

; Here are the two Windows functions we will need
; to send "Hello, world!" to the standard console device:

extrn __imp_GetStdHandle:proc
extrn __imp_WriteFile:proc</code></pre>
<p>The <em>kernel32.lib</em> library file contains the object module definitions for many of the Win32 API functions, including the <code>__imp_GetStdHandle</code> and <code>__imp_WriteFile</code> procedures. Inserting <code>extrn</code> directives for all the Win32 API functions into your assembly language programs is an incredible amount of work. The proper way to deal with these function definitions is to include them in a header (include) file and then include that file in every application you write that uses the Win32 API functions. </p>
<p>The bad news is that creating an appropriate set of header files is a gargantuan task. The good news is that somebody else has already done all that work for you: the MASM32 headers. <a href="#listing16-2" id="listinganchor16-2">Listing 16-2</a> is a rework of <a href="#listing16-1">Listing 16-1</a> that uses the MASM32 64-bit include files to obtain the Win32 external declarations. Note that we incorporate MASM32 via an include file, <em>listing16-2.inc</em>, rather than use it directly. This will be explained in a moment.</p>
<pre><code>; Listing 16-2

            include    listing16-2.inc
            includelib kernel32.lib               ; File I/O library

; Include just the files we need from masm64rt.inc:

;           include \masm32\include64\masm64rt.inc
;           OPTION DOTNAME                        ; Required for macro files
;           option casemap:none                   ; Case sensitive
;           include \masm32\include64\win64.inc
;           include \masm32\macros64\macros64.inc
;           include \masm32\include64\kernel32.inc

            .data
bytesWrtn   qword   ?
hwStr       byte    "Listing 16-2", 0ah, "Hello, World!", 0
hwLen       =       sizeof hwStr

            .code
         
**********************************************************

<span epub:type="pagebreak" title="877" id="Page_877"/>; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    r15
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56            ; Shadow storage
            and     rsp, -16
            
            mov     rcx, -11           ; STD_OUTPUT
            call    __imp_GetStdHandle ; Returns handle
             
            xor     rcx, rcx
            mov     bytesWrtn, rcx
            
            lea     r9, bytesWrtn      ; Address of "bytesWritten" in R9
            mov     r8d, hwLen         ; Length of string to write in R8D 
            lea     rdx, hwStr         ; Ptr to string data in RDX
            mov     rcx, rax           ; File handle passed in RCX
            call    __imp_WriteFile
                         
allDone:    leave
            pop     r15
            pop     rdi
            pop     rsi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p>Here’s the <em>listing16-2.inc</em> include file:</p>
<pre><code>; listing16-2.inc

; Header file entries extracted from MASM32 header
; files (placed here rather than including the 
; full MASM32 headers to avoid namespace pollution
; and speed up assemblies).

PPROC           TYPEDEF PTR PROC        ; For include file prototypes

externdef __imp_GetStdHandle:PPROC
externdef __imp_WriteFile:PPROC</code></pre>
<p class="CodeListingCaption"><a id="listing16-2">Listing 16-2</a>: Using the MASM32 64-bit include files</p>
<p>Here’s the build command and sample output:</p>
<pre><code>C:\&gt;<b>ml64 /nologo listing16-2.asm kernel32.lib /link /nologo /subsystem:console /entry:asmMain</b>
 Assembling: listing16-2.asm

<span epub:type="pagebreak" title="878" id="Page_878"/>C:\&gt;<b>listing16-2</b>
Listing 16-2
Hello, World!</code></pre>
<p>The MASM32 include file</p>
<pre><code>include \masm32\include64\masm64rt.inc</code></pre>
<p class="BodyContinued">includes all the other hundreds of include files that are part of the MASM32 64-bit system. Sticking this include directive into your programs provides your application with access to a huge number of Win32 API functions, data declarations, and other goodies (such as MASM32 macros).</p>
<p>However, your computer will pause for a bit when you assemble your source file. That’s because that single include directive winds up including many tens of thousands of lines of code into your program during assembly. If you know which header file(s) contain the actual declarations you want to use, you can speed up your compilations by including just the files you need (as was done in <em>listing16-2.asm</em> using the MASM32 64-bit include files). </p>
<p>Including <em>masm64rt.inc</em> into your programs has one other problem: <em>namespace pollution</em>. The MASM32 include file introduces thousands and thousands of symbols into your program, and there is a chance a symbol you want to use has already been defined in the MASM32 include files (for a different purpose than the one you have in mind). If you have a <em>file grep</em> utility, a program that searches through files in a directory and recursively in subdirectories for a particular string, you can easily locate all occurrences of a particular symbol you want to use in your file and copy that symbol’s definition into your own source file (or, better yet, into a header file you create specifically for this purpose). This is the approach this chapter uses for many of the example programs.</p>
<h2 id="h1-501089c16-0003">	16.3	The Win32 API and the Windows ABI</h2>
<p class="BodyFirst">The Win32 API functions all adhere to the Windows ABI calling convention. This means that calls to these functions can modify all the volatile registers (RAX, RCX, RDX, R8, R9, R10, R11, and XMM0 to XMM5) but must preserve the nonvolatile registers (the others not listed here). Also, API calls pass parameters in RDX, RCX, R8, R9 (and XMM0 to XMM3), and then on the stack; the stack must be 16-byte-aligned prior to the API call. See the discussion of the Windows ABI throughout this book for more details.</p>
<h2 id="h1-501089c16-0004">	16.4	Building a Stand-Alone Console Application</h2>
<p class="BodyFirst">Take a look at the (simplified) build command from the preceding section:<sup class="FootnoteReference"><a id="c16-footnoteref-2" href="#c16-footnote-2">2</a></sup></p>
<pre><code>ml64 listing16-2.asm /link /subsystem:console /entry:asmMain</code></pre>
<p><span epub:type="pagebreak" title="879" id="Page_879"/>The <code>/subsystem:console</code> option tells the linker that in addition to possible GUI windows the application might create, the system must also create a special window for the application to display console information. If you run the program from a Windows command line, it uses the already-open console window of the <em>cmd.exe</em> program. </p>
<h2 id="h1-501089c16-0005">	16.5	Building a Stand-Alone GUI Application</h2>
<p class="BodyFirst">To create a pure Windows GUI application that does not also open up a console window, you can specify <code>/subsystem:windows</code> rather than <code>/subsystem:console</code>. The simple dialog box application in <a href="#listing16-3" id="listinganchor16-3">Listing 16-3</a> is an example of an especially simple Windows application. It displays a simple dialog box and then quits when the user clicks the OK button in the dialog box.</p>
<pre><code>; Listing 16-3

; Dialog box demonstration.

            include    listing16-3.inc
            includelib user32.lib

          ; include \masm32\include64\masm64rt.inc

            .data

msg         byte    "Dialog Box Demonstration",0
DBTitle     byte    "Dialog Box Title", 0
            
            .code
         
**********************************************************

; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage
            and     rsp, -16
            
            xor     rcx, rcx        ; HWin = NULL
            lea     rdx, msg        ; Message to display
            lea     r8, DBTitle     ; Dialog box title
            mov     r9d, MB_OK      ; Has an "OK" button
            call    MessageBox
                         
allDone:    leave
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing16-3">Listing 16-3</a>: A simple dialog box application</p>
<p><span epub:type="pagebreak" title="880" id="Page_880"/>Here’s the <em>listing16-3.inc</em> include file:</p>
<pre><code>; listing16-3.inc

; Header file entries extracted from MASM32 header
; files (placed here rather than including the 
; full MASM32 headers to avoid namespace pollution
; and speed up assemblies).

PPROC           TYPEDEF PTR PROC        ; For include file prototypes

MB_OK                                equ 0h

externdef __imp_MessageBoxA:PPROC
MessageBox equ &lt;__imp_MessageBoxA&gt;</code></pre>
<p>Here is the build command for the program in <a href="#listing16-3">Listing 16-3</a>:</p>
<pre><code>C:\&gt;<b>ml64 listing16-3.asm /link /subsystem:windows /entry:asmMain</b></code></pre>
<p><a href="#figure16-1" id="figureanchor16-1">Figure 16-1</a> shows the runtime output from <a href="#listing16-3">Listing 16-3</a>.</p>
<figure>

    		file:///Users/DisPater/Desktop/Hyde501089/Production/IndesignFiles/image_fi/501089c16/f16001.tiff
<figcaption><p><a id="figure16-1">Figure 16-1</a>: Sample dialog box output</p></figcaption>
</figure>
<h2 id="h1-501089c16-0006">	16.6	A Brief Look at the MessageBox Windows API Function</h2>
<p class="BodyFirst">Although creating GUI applications in assembly language is well beyond the scope of this book, the <code>MessageBox</code> function is sufficiently useful (even in console applications) to be worth a special mention.</p>
<p>The <code>MessageBox</code> function has four parameters:</p>
<ol class="none">
<li><span class="RunInHead">RCX</span>  Window handle. This is usually NULL (0), implying that the message box is a stand-alone dialog box that is not associated with any particular window.</li>
<li><span class="RunInHead">RDX</span>  Message pointer. RDX contains a pointer to a zero-terminated string that will be displayed in the body of the message box.</li>
<li><span epub:type="pagebreak" title="881" id="Page_881"/><span class="RunInHead">R8</span>  Window title. R8 contains a pointer to a zero-terminated string that is displayed in the title bar of the message box window.</li>
<li><span class="RunInHead">R9D</span>  Message box type. This is an integer value that specifies the type of buttons and other icons appearing in the message box. Typical values are the following: <code>MB_OK</code>, <code>MB_OKCANCEL</code>, <code>MB_ABORTRETRYIGNORE</code>, <code>MB_YESNOCANCEL</code>, <code>MB_YESNO</code>, and <code>MB_RETRYCANCEL</code>. </li>
</ol>
<p>The <code>MessageBox</code> function returns an integer value in RAX corresponding to the button that was pressed (if <code>MB_OK</code> was specified, that’s the value that the message box returns when the user clicks the OK button).</p>
<h2 id="h1-501089c16-0007">	16.7	Windows File I/O</h2>
<p class="BodyFirst">One thing missing from most of the example code in this book has been a discussion of file I/O. Although you can easily make C Standard Library calls to open, read, write, and close files, it seemed appropriate to use file I/O as an example in this chapter to cover this missing detail.</p>
<p>The Win32 API provides many useful functions for <em>file I/O</em>: reading and writing file data. This section describes a small number of these functions:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>CreateFileA</code></span></span>  A function (despite its name) that you use to open existing files or create new files</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>WriteFile</code></span></span>  A function that writes data to a file</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>ReadFile</code></span></span>  A function that reads data from a file</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>CloseHandle</code></span></span>  A function that closes a file and flushes any cached data to the storage device</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>GetStdHandle</code></span> </span>  A function, which you’ve already seen, that returns the handle of one of the standard input or output devices (standard input, standard output, or standard error)</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>GetLastError</code></span></span>  A function you can use to retrieve a Windows error code if an error occurs in the execution of any of these functions</li>
</ol>
<p><a href="#listing16-4" id="listinganchor16-4">Listing 16-4</a> demonstrates the use of these functions as well as the creation of some useful procedures that call these functions. Note that this code is rather long, so I’ve taken the liberty of breaking it into smaller chunks, with individual explanations in front of each section.</p>
<p>The Win32 file I/O functions are all part of the <em>kernel32.lib</em> library module. Therefore, <a href="#listing16-4">Listing 16-4</a> uses the <code>includelib kernel32.lib</code> statement to automatically link in this library during the build phase. To speed up assembly and reduce namespace pollution, this program does not automatically include all of the MASM32 equate files (via an <code>include \masm32\include64\masm64rt.inc</code> statement). Instead, I’ve collected all the necessary equates and other definitions from the MASM32 header files and placed them in the <em>listing16-4.inc</em> header file (which appears a little later in this <span epub:type="pagebreak" title="882" id="Page_882"/>chapter). Finally, the program also includes the <em>aoalib.inc</em> header file, just to use a few of the constants defined in that file (such as <code>cr</code> and <code>nl</code>): </p>
<pre><code>; Listing 16-4 

; File I/O demonstration.

            include    listing16-4.inc
            include    aoalib.inc   ; To get some constants
            includelib kernel32.lib ; File I/O library

            .const
prompt      byte    "Enter (text) filename:", 0
badOpenMsg  byte    "Could not open file", cr, nl, 0

            .data

inHandle    dword   ?
inputLn     byte    256 dup (0)

fileBuffer  byte    4096 dup (0)</code></pre>
<p>The following code constructs <em>wrapper code</em> around each of the file I/O functions to preserve the volatile register values. These functions use the following macro definitions to save and restore the register values:</p>
<pre><code>            .code

rcxSave     textequ &lt;[rbp - 8]&gt;
rdxSave     textequ &lt;[rbp - 16]&gt;
r8Save      textequ &lt;[rbp - 24]&gt;
r9Save      textequ &lt;[rbp - 32]&gt;
r10Save     textequ &lt;[rbp - 40]&gt;
r11Save     textequ &lt;[rbp - 48]&gt;
xmm0Save    textequ &lt;[rbp - 64]&gt;
xmm1Save    textequ &lt;[rbp - 80]&gt;
xmm2Save    textequ &lt;[rbp - 96]&gt;
xmm3Save    textequ &lt;[rbp - 112]&gt;
xmm4Save    textequ &lt;[rbp - 128]&gt;
xmm5Save    textequ &lt;[rbp - 144]&gt;
var1        textequ &lt;[rbp - 160]&gt;

mkActRec    macro
            push    rbp
            mov     rbp, rsp
            sub     rsp, 256        ; Includes shadow storage
            and     rsp, -16        ; Align to 16 bytes
            mov     rcxSave, rcx
            mov     rdxSave, rdx
            mov     r8Save, r8
            mov     r9Save, r9
            mov     r10Save, r10
            mov     r11Save, r11
            movdqu  xmm0Save, xmm0
            movdqu  xmm1Save, xmm1
<span epub:type="pagebreak" title="883" id="Page_883"/>            movdqu  xmm2Save, xmm2
            movdqu  xmm3Save, xmm3
            movdqu  xmm4Save, xmm4
            movdqu  xmm5Save, xmm5
            endm
     
rstrActRec  macro
            mov     rcx, rcxSave
            mov     rdx, rdxSave
            mov     r8, r8Save 
            mov     r9, r9Save 
            mov     r10, r10Save
            mov     r11, r11Save
            movdqu  xmm0, xmm0Save
            movdqu  xmm1, xmm1Save
            movdqu  xmm2, xmm2Save
            movdqu  xmm3, xmm3Save
            movdqu  xmm4, xmm4Save
            movdqu  xmm5, xmm5Save
            leave
            endm</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	These macros assume that the code does not need to preserve the AVX registers (YMM, or even ZMM, registers). If you’re running on a CPU that supports the AVX extensions (and you need to preserve YMM0 to YMM5 or even ZMM0 to ZMM5), you will need to modify these macros to handle the preservation of those registers. These macros also do not preserve the value in the RAX register, because almost all Win32 API functions return a function result in RAX (an error code, if nothing else). </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The first function appearing in <a href="#listing16-4">Listing 16-4</a> is <code>getStdOutHandle</code>. This is a wrapper function around <code>__imp_GetStdHandle</code> that preserves the volatile registers and explicitly requests the standard output device handle. This function returns the standard output device handle in the RAX register. Immediately following <code>getStdOutHandle</code> are comparable functions that retrieve the standard error handle and the standard input handle:</p>
<pre><code>; getStdOutHandle - Returns stdout handle in RAX:

getStdOutHandle proc
                mkActRec
                mov     rcx, STD_OUTPUT_HANDLE
                call    __imp_GetStdHandle  ; Returns handle
                rstrActRec
                ret
getStdOutHandle endp
                
; getStdErrHandle - Returns stderr handle in RAX:

getStdErrHandle proc
                mkActRec
                mov     rcx, STD_ERROR_HANDLE
                call    __imp_GetStdHandle  ; Returns handle
                rstrActRec
                ret
<span epub:type="pagebreak" title="884" id="Page_884"/>getStdErrHandle endp

; getStdInHandle - Returns stdin handle in RAX:

getStdInHandle proc
               mkActRec
               mov     rcx, STD_INPUT_HANDLE
               call    __imp_GetStdHandle   ; Returns handle
               rstrActRec
               ret
getStdInHandle endp</code></pre>
<p>Now consider the wrapper code for the <code>write</code> function:</p>
<pre><code>; write - Write data to a file handle.
 
; RAX - File handle.
; RSI - Pointer to buffer to write.
; RCX - Length of buffer to write.

; Returns:

; RAX - Number of bytes actually written
;       or -1 if there was an error.
            
write       proc
            mkActRec
            
            mov     rdx, rsi        ; Buffer address
            mov     r8, rcx         ; Buffer length
            lea     r9, var1        ; bytesWritten
            mov     rcx, rax        ; Handle
            xor     r10, r10        ; lpOverlapped is passed
            mov     [rsp+4*8], r10  ; on the stack
            call    __imp_WriteFile
            test    rax, rax        ; See if error
            mov     rax, var1       ; bytesWritten
            jnz     rtnBytsWrtn     ; If RAX was not zero
            mov     rax, -1         ; Return error status

rtnBytsWrtn:
            rstrActRec
            ret
write       endp</code></pre>
<p>The <code>write</code> function writes data from a memory buffer to the output file specified by a file handle (which could also be the standard output or standard error handle, if you want to write data to the console). The <code>write</code> function expects the following parameter data:</p>
<ol class="none">
<li><span class="RunInHead">RAX</span>  File handle specifying the write destination. This is typically a handle obtained by the <code>open</code> or <code>openNew</code> functions (a little later in the program) or the <code>getStdOutHandle</code> and <code>getStdErrHandle</code> functions.</li>
<li><span epub:type="pagebreak" title="885" id="Page_885"/><span class="RunInHead">RSI</span>  Address of the buffer containing the data to write to the file.</li>
<li><span class="RunInHead">RCX</span>  Number of bytes of data to write to the file (from the buffer).</li>
</ol>
<p>This function does not follow the Windows ABI calling convention. Although there isn’t an official <em>assembly language calling convention</em>, many assembly language programmers tend to use the same registers that the x86-64 string instructions use. For example, the source data (buffer) is passed in RSI (the source index register), and the count (buffer size) parameter appears in the RCX register. The <code>write</code> procedure moves the data to appropriate locations for the call to <code>__imp_WriteFile</code> (as well as sets up additional parameters).</p>
<p>The <code>__imp_WriteFile</code> function is the actual Win32 API write function (technically, <code>__imp_WriteFile</code> is a pointer to the function; the call instruction is an indirect call through this pointer). The <code>__imp_WriteFile</code> has the following arguments:</p>
<ol class="none">
<li><span class="RunInHead">RCX</span>  File handle.</li>
<li><span class="RunInHead">RDX</span>  Buffer address.</li>
<li><span class="RunInHead">R8</span>  Buffer size (really, 32 bits in R8D).</li>
<li><span class="RunInHead">R9</span>  Address of a dword variable to receive the number of bytes written to the file; this will equal the buffer size if the write operation is successful.</li>
<li><span class="RunInHead">[rsp + 32]</span>  <code>lpOverlapped</code> value; just set this to NULL (0). As per the Windows ABI, callers pass all parameters beyond the fourth parameter on the stack, leaving room (shadow parameters) for the first four.</li>
</ol>
<p>On return from <code>__imp_WriteFile</code>, RAX contains a nonzero value (true) if the write was successful, and zero (false) if there was an error. If there was an error, you can call the Win32 <code>GetLastError</code> function to retrieve the error code.</p>
<p>Note that the <code>write</code> function returns the number of bytes written to the file in the RAX register. If there was an error, <code>write</code> returns <code>-1</code> in the RAX register.</p>
<p>Next up are the <code>puts</code> and <code>newLn</code> functions:</p>
<pre><code>; puts - Outputs a zero-terminated string to standard output device.

; RSI - Address of string to print to standard output.

            .data
stdOutHnd   qword   0
hasSOHndl   byte    0

            .code
puts        proc
            push    rax
            push    rcx
            cmp     hasSOHndl, 0
            jne     hasHandle

<span epub:type="pagebreak" title="886" id="Page_886"/>            call    getStdOutHandle
            mov     stdOutHnd, rax
            mov     hasSOHndl, 1

; Compute the length of the string:
            
hasHandle:  mov     rcx, -1
lenLp:      inc     rcx
            cmp     byte ptr [rsi][rcx * 1], 0
            jne     lenLp
            
            mov     rax, stdOutHnd
            call    write

            pop     rcx
            pop     rax
            ret
puts        endp

; newLn - Outputs a newline sequence to the standard output device:

newlnSeq    byte    cr, nl

newLn       proc
            push    rax
            push    rcx
            push    rsi
            cmp     hasSOHndl, 0
            jne     hasHandle
            
            call    getStdOutHandle
            mov     stdOutHnd, rax
            mov     hasSOHndl, 1

hasHandle:  lea     rsi, newlnSeq
            mov     rcx, 2
            mov     rax, stdOutHnd
            call    write
                                   
            pop     rsi
            pop     rcx
            pop     rax
            ret
newLn       endp</code></pre>
<p>The <code>puts</code> and <code>newLn</code> procedures write strings to the standard output device. The <code>puts</code> function writes a zero-terminated string whose address you pass in the RSI register. The <code>newLn</code> function writes a newline sequence (carriage return and line feed) to the standard output device. </p>
<p>These two functions have a tiny optimization: they call <code>getStdOutHandle</code> only once to obtain the standard output device handle. On the first call to either of these functions, they call <code>getStdOutHandle</code> and cache the result (in the <code>stdOutHnd</code> variable) and set flag (<code>hasSOHndl</code>) that indicates that the cached value <span epub:type="pagebreak" title="887" id="Page_887"/>is valid. Thereafter, these functions use the cached value rather than continually calling <code>getStdOutHandle</code> to retrieve the standard output device handle. </p>
<p>The <code>write</code> function requires a buffer length; it does not work on zero-terminated strings. Therefore, the <code>puts</code> function must explicitly determine the length of the zero-terminated string before calling <code>write</code>. The <code>newLn</code> function doesn’t have to do this because it knows the length of the carriage return and line feed sequence (two characters).</p>
<p>The next function in <a href="#listing16-4">Listing 16-4</a> is the wrapper for the <code>read</code> function:</p>
<pre><code>; read - Read data from a file handle.

; EAX - File handle.
; RDI - Pointer to buffer receive data.
; ECX - Length of data to read.

; Returns:

; RAX - Number of bytes actually read
;       or -1 if there was an error.
            
read        proc
            mkActRec
            
            mov     rdx, rdi        ; Buffer address
            mov     r8, rcx         ; Buffer length
            lea     r9, var1        ; bytesRead
            mov     rcx, rax        ; Handle
            xor     r10, r10        ; lpOverlapped is passed
            mov     [rsp+4*8], r10  ; on the stack
            call    __imp_ReadFile
            test    rax, rax        ; See if error
            mov     rax, var1       ; bytesRead
            jnz     rtnBytsRead     ; If RAX was not zero
            mov     rax, -1         ; Return error status

rtnBytsRead:
            rstrActRec
            ret
read        endp</code></pre>
<p>The <code>read</code> function is the input analog to the <code>write</code> function. The parameters are similar (note, however, that <code>read</code> uses RDI as the <em>destination address</em> for the buffer parameter):</p>
<ol class="none">
<li><span class="RunInHead">RAX</span>  File handle.</li>
<li><span class="RunInHead">RDI</span>  Destination buffer to store data read from file.</li>
<li><span class="RunInHead">RCX</span>  Number of bytes to read from the file.</li>
</ol>
<p>The <code>read</code> function, a wrapper around the Win32 API <code>__imp_ReadFile</code> function, has the following arguments:</p>
<ol class="none">
<li><span class="RunInHead">RCX</span>  File handle.</li>
<li><span class="RunInHead">RDX</span>  File buffer address.</li>
<li><span epub:type="pagebreak" title="888" id="Page_888"/><span class="RunInHead">R8</span>  Number of bytes to read.</li>
<li><span class="RunInHead">R9</span>  Address of dword variable to receive the number of bytes actually read.</li>
<li><span class="RunInHead">[rsp + 32]</span>  Overlapped operation; should be NULL (0). As per the Windows ABI, callers pass all parameters beyond the fourth parameter on the stack, leaving room (shadow parameters) for the first four.</li>
</ol>
<p>The <code>read</code> function returns <code>-1</code> in RAX if there was an error during the read operation. Otherwise, it returns the actual number of bytes read from the file. This value can be less than the requested read amount if the read operation reaches the end of the file (EOF). A <code>0</code> return value generally indicates EOF has been reached.</p>
<p>The <code>open</code> function opens an existing file for reading, writing, or both. It is a wrapper function for the Windows <code>CreateFileA</code> API call:</p>
<pre><code>; open - Open existing file for reading or writing.

; RSI - Pointer to filename string (zero-terminated).
; RAX - File access flags.
;       (GENERIC_READ, GENERIC_WRITE, or
;       "GENERIC_READ + GENERIC_WRITE")

; Returns:

; RAX - Handle of open file (or INVALID_HANDLE_VALUE if there
;       was an error opening the file).

open        proc
            mkActRec
            
            mov     rcx, rsi               ; Filename
            mov     rdx, rax               ; Read and write access
            xor     r8, r8                 ; Exclusive access
            xor     r9, r9                 ; No special security
            mov     r10, OPEN_EXISTING     ; Open an existing file
            mov     [rsp + 4 * 8], r10     
            mov     r10, FILE_ATTRIBUTE_NORMAL
            mov     [rsp + 5 * 8], r10
            mov     [rsp + 6 * 8], r9      ; NULL template file
            call    __imp_CreateFileA
            rstrActRec
            ret
open        endp</code></pre>
<p>The <code>open</code> procedure has two parameters:</p>
<ol class="none">
<li><span class="RunInHead">RSI</span>  A pointer to a zero-terminated string containing the filename of the file to open.</li>
<li><span class="RunInHead">RAX</span>  A set of file access flags. These are typically the constants <code>GENERIC_READ</code> (to open a file for reading), <code>GENERIC_WRITE</code> (to open a file for writing), or <code>GENERIC_READ + GENERIC_WRITE</code> (to open a file for reading and writing).</li>
</ol>
<p><span epub:type="pagebreak" title="889" id="Page_889"/>The <code>open</code> function calls the Windows <code>CreateFileA</code> function after setting up the appropriate parameters for the latter. The <code>A</code> suffix on <code>CreateFileA</code> stands for <em>ASCII</em>. This particular function expects the caller to pass an ASCII filename. Another function, <code>CreateFileW</code>, expects Unicode filenames, encoded as UTF-16. Internally, Windows uses Unicode filenames; when you call <code>CreateFileA</code>, it converts the ASCII filename to Unicode and then calls <code>CreateFileW</code>. The <code>open</code> function sticks with ASCII characters. </p>
<p>The <code>CreateFileA</code> function has the following parameters:</p>
<ol class="none">
<li><span class="RunInHead">RCX</span>  Pointer to zero-terminated (ASCII) string holding the name of the file to open.</li>
<li><span class="RunInHead">RDX</span>  Read and write access flags (<code>GENERIC_READ</code> and <code>GENERIC_WRITE</code>).</li>
<li><span class="RunInHead">R8</span>  Sharing mode flag (<code>0</code> means exclusive access). Controls whether another process can access the file while the current process has it open. Possible flag values are <code>FILE_SHARE_READ</code>, <code>FILE_SHARE_WRITE</code>, and <code>FILE_SHARE_DELETE</code> (or a combination of these).</li>
<li><span class="RunInHead">R9</span>  Pointer to a security descriptor. The <code>open</code> function doesn’t specify any special security; it simply passes NULL (0) as this argument.</li>
<li><span class="RunInHead">[rsp + 32]</span>  This parameter holds the creation disposition flag. The <code>open</code> function opens an existing file, so it passes <code>OPEN_EXISTING</code> here. Other possible values are <code>CREATE_ALWAYS</code>, <code>CREATE_NEW</code>, <code>OPEN_ALWAYS</code>, <code>OPEN_EXISTING</code>, or <code>TRUNCATE_EXISTING</code>. The <code>OPEN_EXISTING</code> value requires that the file exists, or it will return an open error. Being the fifth parameter, this is passed on the stack (in the fifth 64-bit slot).</li>
<li><span class="RunInHead">[rsp + 40]</span>  This parameter contains the file attributes. This function simply uses the <code>FILE_ATTRIBUTE_NORMAL</code> attribute (for example, not read-only).</li>
<li><span class="RunInHead">[rsp + 48]</span>  This parameter is a pointer to a file template handle. The <code>open</code> function doesn’t use a file template, so it passes NULL (0) in this argument.</li>
</ol>
<p>The <code>open</code> function returns a file handle in the RAX register. If there was an error, this function returns <code>INVALID_HANDLE_VALUE</code> in RAX.</p>
<p>The <code>openNew</code> function is also a wrapper around the <code>CreateFileA</code> function:</p>
<pre><code>; openNew - Creates a new file and opens it for writing.

; RSI - Pointer to filename string (zero-terminated).

; Returns:

; RAX - Handle of open file (or INVALID_HANDLE_VALUE if there
;       was an error opening the file).

openNew     proc
            mkActRec
            
            mov     rcx, rsi                         ; Filename
            mov     rdx, GENERIC_WRITE+GENERIC_WRITE ; Access
<span epub:type="pagebreak" title="890" id="Page_890"/>            xor     r8, r8                           ; Exclusive access
            xor     r9, r9                           ; No security
            mov     r10, CREATE_ALWAYS               ; Open a new file
            mov     [rsp + 4 * 8], r10 
            mov     r10, FILE_ATTRIBUTE_NORMAL
            mov     [rsp + 5 * 8], r10
            mov     [rsp + 6 * 8], r9                ; NULL template
            call    __imp_CreateFileA
            rstrActRec
            ret
openNew     endp</code></pre>
<p><code>openNew</code> creates a new (empty) file on the disk. If the file previously existed, <code>openNew</code> will delete it before opening the new file. This function is almost identical to the preceding <code>open</code> function, with the following two differences:</p>
<ul>
<li>The caller does not pass the file access flags in the RAX register. The file access is always assumed to be <code>GENERIC_WRITE</code>.</li>
<li>This function passes the <code>CREATE_ALWAYS</code> creation disposition flag to <code>CreateFileA</code> rather than <code>OPEN_EXISTING</code>.</li>
</ul>
<p>The <code>closeHandle</code> function is a simple wrapper around the Windows <code>CloseHandle</code> function. You pass the file handle of the file to close in the RAX register. This function returns <code>0</code> in RAX if there was an error, or a nonzero file if the file close operation was successful. The only purpose of this wrapper is to preserve all the volatile registers across the call to the Windows <code>CloseHandle</code> function:</p>
<pre><code>; closeHandle - Closes a file specified by a file handle.

; RAX - Handle of file to close.

closeHandle proc
            mkActRec
            
            call    __imp_CloseHandle

            rstrActRec
            ret
closeHandle endp</code></pre>
<p>Although this program doesn’t explicitly use <code>getLastError</code>, it does provide a wrapper around the <code>getLastError</code> function (just to show how it would be written). Whenever one of the Windows functions in this program returns an error indication, you have to call <code>getLastError</code> to retrieve the actual error code. This function has no input parameters. It returns the last Windows error code generated in RAX.</p>
<p>It is very important to call <code>getLastError</code> immediately after a function returns an error indication. If you call any other Windows functions between the error and retrieval of the error code, those intervening calls will reset the last error code value.</p>
<p><span epub:type="pagebreak" title="891" id="Page_891"/>As was the case for the <code>closeHandle</code> function, the <code>getLastError</code> procedure is a very simple wrapper around the Windows <code>GetLastError</code> function that preserves volatile register values across the call:</p>
<pre><code>; getLastError - Returns the error code of the last Windows error.

; Returns:

; RAX - Error code.

getLastError proc
             mkActRec
             call   __imp_GetLastError
             rstrActRec
             ret
getLastError endp</code></pre>
<p>The <code>stdin_read</code> is a simple wrapper function around the <code>read</code> function that reads its data from the standard input device (rather than from a file on another device):</p>
<pre><code>; stdin_read - Reads data from the standard input.

; RDI - Buffer to receive data.
; RCX - Buffer count (note that data input will
;       stop on a newline character if that
;       comes along before RCX characters have
;       been read).

; Returns:

; RAX - -1 if error, bytes read if successful.

stdin_read  proc
            .data
hasStdInHnd byte    0
stdInHnd    qword   0
            .code
            mkActRec
            cmp     hasStdInHnd, 0
            jne     hasHandle
            
            call    getStdInHandle
            mov     stdInHnd, rax
            mov     hasStdInHnd, 1
            
hasHandle:  mov     rax, stdInHnd   ; Handle
            call    read
                                            
            rstrActRec
            ret
stdin_read  endp</code></pre>
<p><span epub:type="pagebreak" title="892" id="Page_892"/><code>stdin_read</code> is similar to the <code>puts</code> (and <code>newLn</code>) procedure insofar as it caches the standard input handle on its first call and uses that cached value on subsequent calls. Note that <code>stdin_read</code> does not (directly) preserve the volatile registers. This function does not directly call any Windows functions, so it doesn’t have to preserve the volatile registers (<code>stdin_read</code> calls the <code>read</code> function, which preserves the volatile registers). The <code>stdin_read</code> function has the following parameters:</p>
<ol class="none">
<li><span class="RunInHead">RDI</span>  Pointer to destination buffer that will receive the characters read from the standard input device.</li>
<li><span class="RunInHead">RCX</span>  Buffer size (maximum number of bytes to read).</li>
</ol>
<p>This function returns the actual number of bytes read in the RAX register. This value may be less than the value passed in RCX. If the user presses <span class="KeyCaps">enter</span>, this function immediately returns. This function does not zero-terminate the string read from the standard input device. Use the value in the RAX register to determine the string’s length. If this function returns because the user pressed <span class="KeyCaps">enter</span> on the standard input device, that carriage return will appear in the buffer.</p>
<p>The <code>stdin_getc</code> function reads a single character from the standard input device and returns that character in the AL register:</p>
<pre><code>; stdin_getc - Reads a single character from the standard input.
;              Returns character in AL register.

stdin_getc  proc
            push    rdi
            push    rcx
            sub     rsp, 8

            mov     rdi, rsp
            mov     rcx, 1
            call    stdin_read
            test    eax, eax        ; Error on read?
            jz      getcErr
            movzx   rax, byte ptr [rsp]

getcErr:    add     rsp, 8
            pop     rcx
            pop     rdi 
            ret
stdin_getc  endp</code></pre>
<p>The <code>readLn</code> function reads a string of characters from the standard input device and places them in a caller-specified buffer. The arguments are as follows:</p>
<ol class="none">
<li><span class="RunInHead">RDI</span>  Address of the buffer.</li>
<li><span class="RunInHead">RCX</span>  Maximum buffer size. (<code>readLn</code> allows the user to enter a maximum of RCX – 1 characters.)</li>
</ol>
<p><span epub:type="pagebreak" title="893" id="Page_893"/>This function will put a zero-terminating byte at the end of the string input by the user. Furthermore, it will strip out the carriage return (or newline or line feed) character at the end of the line. It returns the character count in RAX (not counting the <span class="KeyCaps">enter</span> key):</p>
<pre><code>; readLn - Reads a line of text from the user.
;          Automatically processes backspace characters
;          (deleting previous characters, as appropriate).
;          Line returned from function is zero-terminated
;          and does not include the ENTER key code (carriage
;          return) or line feed.

; RDI - Buffer to place line of text read from user.
; RCX - Maximum buffer length.

; Returns:

; RAX - Number of characters read from the user
;       (does not include ENTER key).

readLn      proc
            push    rbx
            
            xor     rbx, rbx           ; Character count
            test    rcx, rcx           ; Allowable buffer is 0?
            je      exitRdLn
            dec     rcx                ; Leave room for 0 byte
readLp:
            call    stdin_getc         ; Read 1 char from stdin
            test    eax, eax           ; Treat error like ENTER
            jz      lineDone
            cmp     al, cr             ; Check for ENTER key
            je      lineDone
            cmp     al, nl             ; Check for newline code
            je      lineDone
            cmp     al, bs             ; Handle backspace character
            jne     addChar
            
; If a backspace character came along, remove the previous
; character from the input buffer (assuming there is a
; previous character).

            test    rbx, rbx           ; Ignore BS character if no
            jz      readLp             ; chars in the buffer
            dec     rbx
            jmp     readLp

; If a normal character (that we return to the caller),
; then add the character to the buffer if there is
; room for it (ignore the character if the buffer is full).
            
addChar:    cmp     ebx, ecx           ; See if we're at the
            jae     readLp             ; end of the buffer
            mov     [rdi][rbx * 1], al ; Save char to buffer
<span epub:type="pagebreak" title="894" id="Page_894"/>            inc     rbx
            jmp     readLp

; When the user presses ENTER (or the line feed) key
; during input, come down here and zero-terminate the string.

lineDone:   mov     byte ptr [rdi][rbx * 1], 0 
            
exitRdLn:   mov     rax, rbx        ; Return char cnt in RAX
            pop     rbx
            ret
readLn      endp</code></pre>
<p>Here’s the main program for <a href="#listing16-4">Listing 16-4</a>, which reads a filename from the user, opens that file, reads the file data, and displays the data on the standard output device:</p>
<pre><code>**********************************************************

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 64         ; Shadow storage
            and     rsp, -16

; Get a filename from the user:

            lea     rsi, prompt
            call    puts

            lea     rdi, inputLn
            mov     rcx, lengthof inputLn
            call    readLn
            
; Open the file, read its contents, and display
; the contents to the standard output device:

            lea     rsi, inputLn
            mov     rax, GENERIC_READ
            call    open

            cmp     eax, INVALID_HANDLE_VALUE
            je      badOpen
            
            mov     inHandle, eax
            
<span epub:type="pagebreak" title="895" id="Page_895"/>; Read the file 4096 bytes at a time:

readLoop:   mov     eax, inHandle
            lea     rdi, fileBuffer
            mov     ecx, lengthof fileBuffer
            call    read
            test    eax, eax        ; EOF?
            jz      allDone
            mov     rcx, rax        ; Bytes to write
            
            call    getStdOutHandle
            lea     rsi, fileBuffer
            call    write
            jmp     readLoop
            
badOpen:    lea     rsi, badOpenMsg
            call    puts
            
allDone:    mov     eax, inHandle
            call    closeHandle
            
            leave
            pop     rdi
            pop     rsi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing16-4">Listing 16-4</a>: File I/O demonstration program</p>
<p>Here’s the build command and sample output for <a href="#listing16-4">Listing 16-4</a>:</p>
<pre><code>C:\&gt;<b>nmake /nologo /f listing16-4.mak</b>
        ml64 /nologo listing16-4.asm  /link /subsystem:console /entry:asmMain
 Assembling: listing16-4.asm
Microsoft (R) Incremental Linker Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/OUT:listing16-4.exe
listing16-4.obj
/subsystem:console
/entry:asmMain

C:\&gt;<b>listing16-4</b>
Enter (text) filename:listing16-4.mak
listing16-4.exe: listing16-4.obj listing16-4.asm
        ml64 /nologo listing16-4.asm \
                /link /subsystem:console /entry:asmMain</code></pre>
<p><span epub:type="pagebreak" title="896" id="Page_896"/>Here’s the <em>listing16-4.inc</em> include file:</p>
<pre><code>; listing16-4.inc

; Header file entries extracted from MASM32 header
; files (placed here rather than including the 
; entire set of MASM32 headers to avoid namespace 
; pollution and speed up assemblies).

STD_INPUT_HANDLE                     equ -10
STD_OUTPUT_HANDLE                    equ -11
STD_ERROR_HANDLE                     equ -12
CREATE_NEW                           equ 1
CREATE_ALWAYS                        equ 2
OPEN_EXISTING                        equ 3
OPEN_ALWAYS                          equ 4
FILE_ATTRIBUTE_READONLY              equ 1h
FILE_ATTRIBUTE_HIDDEN                equ 2h
FILE_ATTRIBUTE_SYSTEM                equ 4h
FILE_ATTRIBUTE_DIRECTORY             equ 10h
FILE_ATTRIBUTE_ARCHIVE               equ 20h
FILE_ATTRIBUTE_NORMAL                equ 80h
FILE_ATTRIBUTE_TEMPORARY             equ 100h
FILE_ATTRIBUTE_COMPRESSED            equ 800h
FILE_SHARE_READ                      equ 1h
FILE_SHARE_WRITE                     equ 2h
GENERIC_READ                         equ 80000000h
GENERIC_WRITE                        equ 40000000h
GENERIC_EXECUTE                      equ 20000000h
GENERIC_ALL                          equ 10000000h
INVALID_HANDLE_VALUE                 equ -1

PPROC           TYPEDEF PTR PROC        ; For include file prototypes

externdef __imp_GetStdHandle:PPROC
externdef __imp_WriteFile:PPROC
externdef __imp_ReadFile:PPROC
externdef __imp_CreateFileA:PPROC
externdef __imp_CloseHandle:PPROC
externdef __imp_GetLastError:PPROC</code></pre>
<p>Here’s the <em>listing16-4.mak</em> makefile:</p>
<pre><code>listing16-4.exe: listing16-4.obj listing16-4.asm
    ml64 /nologo listing16-4.asm \
        /link /subsystem:console /entry:asmMain</code></pre>
<h2 id="h1-501089c16-0008"><span epub:type="pagebreak" title="897" id="Page_897"/>	16.8	Windows Applications</h2>
<p class="BodyFirst">This chapter has provided just a glimpse of what is possible when writing pure assembly language applications that run under Windows. The <em>kernel32.lib</em> library provides hundreds of functions you can call, covering such diverse topic areas as manipulating filesystems (for example, deleting files, looking up filenames in a directory, and changing directories), creating threads and synchronizing them, processing environment strings, allocating and deallocating memory, manipulating the Windows registry, sleeping for a certain time period, waiting for events to occur, and much, much more. </p>
<p>The <em>kernel32.lib</em> library is but one of the libraries in the Win32 API. The <em>gdi32.lib</em> library contains most of the functions needed to create GUI applications running under Windows. Creating such applications is well beyond the scope of this book, but if you want to create stand-alone Windows GUI applications, you need to become intimately familiar with this library. The following <span class="xref" itemid="xref_target_“For More Information”">“For More Information”</span> section provides links to internet resources if you’re interested in creating stand-alone Windows GUI applications in assembly language.</p>
<h2 id="h1-501089c16-0009">	16.9	For More Information</h2>
<p class="BodyFirst">If you want to write stand-alone 64-bit assembly language programs that run under Windows, your first stop should be <a href="https://www.masm32.com/" class="LinkURL">https://www.masm32.com/</a>. Although this website is primarily dedicated to creating 32-bit assembly language programs that run under Windows, it has a large amount of information for 64-bit programmers as well. More importantly, this site contains the header files you will need to access the Win32 API from your 64-bit assembly language programs.</p>
<p>If you’re serious about writing Win32 API–based Windows applications in assembly language, Charles Petzold’s <em>Programming Windows</em>, Fifth Edition (Microsoft, 1998) is an absolutely essential purchase. This book is old (do not get the newer edition for C# and XAML), and you likely will have to purchase a used copy. It was written for C programmers (not assembly), but if you know the Windows ABI (which you should by now), translating all the C calls into assembly language isn’t that difficult. Though much of this information about the Win32 API is available online (such as at the MASM32 site), having all the information available in a single (very large!) book is essential.</p>
<p>Another good source on the web for Win32 API calls is software analyst Geoff Chappell’s Win32 Programming page (<a href="https://www.geoffchappell.com/studies/windows/win32/" class="LinkURL">https://www.geoffchappell.com/studies/windows/win32/</a>).</p>
<p>The Iczelion tutorials were the original standard for writing Windows programs in x86 assembly language. Although they were originally written for 32-bit x86 assembly language, there have been several translations of this code to 64-bit assembly language, for example: <a href="http://masm32.com/board/index.php?topic=4190.0/" class="LinkURL">http://masm32.com/board/index.php?topic=4190.0/</a>.</p>
<p><span epub:type="pagebreak" title="898" id="Page_898"/>The HLA Standard Library and examples (which can be found at <a href="https://www.randallhyde.com/" class="LinkURL">https://www.randallhyde.com/</a>) contain a ton of Windows code and API function calls. Though this code is all 32-bit, translating it to 64-bit MASM code is easy. </p>
<h2 id="h1-501089c16-0010">	16.10	Test Yourself</h2>
<ol class="decimal">
<li value="1">What is the linker command line option needed to tell MASM that you’re building a console application?</li>
<li value="2">What website should you visit to get Win32 programming information? </li>
<li value="3">What is the major drawback to including <em>\masm32\include64\masm64rt.inc</em> in all your assembly language source files?</li>
<li value="4">What linker command line option lets you specify the name of your assembly language main program?</li>
<li value="5">What is the name of the Win32 API function that lets you bring up a dialog box?</li>
<li value="6">What is wrapper code?</li>
<li value="7">What is the Win32 API function you would use to open an existing file?</li>
<li value="8">What Win32 API function do you use to retrieve the last Windows error code?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c16-footnote-1" href="#c16-footnoteref-1">1.</a></sup> Despite its name, the MASM32 library includes header files for both 32-bit and 64-bit assembly language programmers. Obviously, we’re interested in the 64-bit libraries.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c16-footnote-2" href="#c16-footnoteref-2">2.</a></sup> I’ve removed the <span class="LiteralFootnote"><code>/nologo</code></span> options to save space on the line. They don’t affect the operation of the compilation other than to reduce some Microsoft output.</p></aside>
</section>
</section>
</body></html>