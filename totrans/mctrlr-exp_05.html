<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_53"/><strong>5 Ledger Nano S, 0xF00DBABE</strong></h2>&#13;
<p class="noindent">The Ledger Nano S is an electronic wallet for cryptocurrencies, powered by an STM32F042 microcontroller and an ST31H320 secure element. Holding one of the buttons at startup triggers a bootloader implemented in the STM32F0’s flash memory, speaking the APDU protocol over USB. Most of the STM32 firmware is open source, while the ST31 runs applets inside of a closed source supervisor.</p>&#13;
<p class="indent">In this chapter we’ll discuss a vulnerability, first published in Roth (2018), in which the dual mapping of flash memory allows a sanity check to be bypassed in writing firmware, so that the bootloader will mistakenly believe the code signature has already been validated.</p>&#13;
<p class="indent">We will also briefly cover a technique from Rashid (2018), in which the device’s cryptographic firmware attestation can be tricked. By replacing compiler intrinsic functions with branches back to their bootloader equivalents, we can hollow out some space for a patch. This allows the STM32 to lie to the ST31 about its code, sneaking small patches past the validation.</p>&#13;
<p class="indent">The Ledger Nano S divides its code between an STM32F042 and an ST31H320. Instead of using sticker seals to protect against tampering, the device features a case that is easy to open and software attestation. The ST31 smartcard verifies the firmware of the STM32 by reading it with strict timing requirements.</p>&#13;
<p class="indent">From an attacker’s perspective, a successful attack requires both flashing new code into the STM32 chip and faking the attestation so that the host GUI software believes the firmware to be genuine. We’ll cover tricks for both, but first let’s take a brief tour of the platform so that we know what we’re working with.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_54"/><img id="ch5fig1" src="../images/f0054-01.jpg" alt="Image" width="777" height="750"/></div>&#13;
<p class="figcap">Figure 5.1: Disassembled Ledger Nano S</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_55"/><img id="ch5fig2" src="../images/f0055-01.jpg" alt="Image" width="578" height="489"/></div>&#13;
<p class="figcap">Figure 5.2: STM32F042 Memory Map</p>&#13;
<p class="indent">While the ST31 firmware is held secret, the STM32 firmware is open source, with documentation and a development kit. To prevent malicious patching, the host software validates the ST31’s attestation of the STM32 firmware, and to prevent malicious applications, a pin number is required to approve applications and signing keys that might be flashed into the unit.</p>&#13;
<p class="indent">Third party applications are written in C, and they run in a protected mode of the ST31. Most examples are cryptocurrency wallet applications, but a few games exist, such as a port of <em>Snake</em> by Parker Hoyes.<sup><a id="ch5fn_1" href="footnotes.xhtml#ch5fn1">1</a></sup> Applet firmware is verified by the ST31 at installation time, and the GUI must be invoked to run applets signed by an untrusted authority. The STM32 firmware is now verified, but it was not in early versions of the device.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Communication with the Nano S is performed by USB-wrapped APDU commands, and client examples are freely provided in Python as part of the <code>ledgerblue</code> package. An example from that package is shown in <a href="ch05.xhtml#ch5fig3">Figure 5.3</a>.</p>&#13;
<p class="indent">Having a full development kit, accurate source code for most of the firmware, and legal support for third-party applications allows many degrees of freedom to the attacker. In Saleem Rashid’s example, knowing the expected bytes of the official application allows it to be compressed, patched, and replayed to fake out the secure element’s attestation. As we’ll see in Thomas Roth’s example, bugs can be found in the bootloader after dumping it from an application in development mode.</p>&#13;
<h3 class="h3" id="ch00lev1sec16"><strong>Rashid’s Attestation Exploit</strong></h3>&#13;
<p class="noindent">In early versions of the Ledger Nano S, the STM32 firmware and its bootloader were both open source. The host software would ask the ST31 to authenticate the STM32 firmware by quickly transferring the STM32 code over an internal UART bus.</p>&#13;
<p class="indent">Rashid first created a malicious firmware patch by changing the onboarding screen so that <code>memset</code> will be called instead of the <code>cs_rng</code> function when the wallet is creating a recovery key. So the customer will always get the same key, and that key can be externally known.</p>&#13;
<p class="indent">This was far from a sneaky backdoor, so he next faked out the attestation by hiding his code inside of the application copies of functions that also exist in the bootloader. For example, <code>memset</code> existed both at application address <code>0x08006310</code> and at boot-loader address <code>0x08002a9c</code>. He could free up 124 bytes by redirecting function calls from one to the other.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_57"/><img id="ch5fig3" src="../images/f0057-01.jpg" alt="Image" width="822" height="740"/></div>&#13;
<p class="figcap">Figure 5.3: Example Client Script in Python</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>He can then fill these bytes with a patched wrapper for the function that sends chunks of memory to the ST31 for validation, taking care to send fake bytes to hide his hooking and patching.</p>&#13;
<h3 class="h3" id="ch00lev1sec17"><strong>Roth’s Bootloader Exploit</strong></h3>&#13;
<p class="indent">After Rashid’s publication, Ledger closed their STM32 boot-loader’s source code and patched it to validate the application region immediately, before booting. They left the STM32 JTAG open, however, so Roth opened the case, wired a unit up, and dumped a copy of flash memory. He then reverse engineered it with the aim of finding a bug that would allow him to flash and execute unauthenticated code.</p>&#13;
<p class="indent">Ledger’s bootloader for the Nano S operates over the APDU protocol. Commands are described in <a href="ch05.xhtml#ch5fig4">Figure 5.4</a>, where you first use Select Segment to choose a base address, then use Load to accept data into the working segment, and finally Flush each block back into flash memory. When the full update is installed, you can either call Boot or power cycle the device to execute the image.</p>&#13;
<p class="indent">All of that is fairly standard for a bootloader. The tricky part is that this bootloader verifies an application image’s signature, rather than implementing a lockout. So you can call all of these commands on a locked production device, but you shouldn’t be able to execute the Boot command or launch your image if the image hasn’t been signed with the manufacturer’s production key.</p>&#13;
<p class="indent">By reading a dump of the bootloader, Roth learned that it places <code>0xf00dbabe</code> in little endian (<code>be ba 0d f0</code>) at <code>0x0800-3000</code> after the signature has been validated. It doesn’t bother to repeat a validation if this tag is found. So writing that value to that location would be enough to inject foreign, unauthenticated code through the bootloader.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_59"/><img id="ch5fig4" src="../images/f0059-01.jpg" alt="Image" width="701" height="265"/></div>&#13;
<p class="figcap">Figure 5.4: APDU Bootloader Commands</p>&#13;
<div class="image"><img id="ch5fig5" src="../images/f0059-02.jpg" alt="Image" width="822" height="577"/></div>&#13;
<p class="figcap">Figure 5.5: APDU Load Handler Pseudocode from Roth (2018)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_60"/><img id="ch5fig6" src="../images/f0060-01.jpg" alt="Image" width="821" height="299"/></div>&#13;
<p class="figcap">Figure 5.6: APDU Bootloader Exploit PoC</p>&#13;
<p class="indent">From his pseudocode of the decompiled handler in <a href="ch05.xhtml#ch5fig5">Figure 5.5</a>, it might look as if you could begin a segment just before the magic word and overwrite it, but flash writes on an STM32 have strict page alignment rules that thwart such an attack. Similarly, they check for writes to the forbidden page and clear four bytes of the buffer just to frustrate us.</p>&#13;
<p class="indent">What makes this exploitable is that in many STM32 microcontrollers, including this one, flash memory is mapped not just to its default location of <code>0x08000000</code>. There is also a second location mirrored or ghosted at <code>0x00000000</code>, which happens to be flash because it defaults to the boot memory. Roth observed that while there’s an explicit check to prevent a write to <code>0x0800C000</code>, there is nothing preventing a write to <code>0x0000C000</code>. Because of the mirroring, these two addresses are the same place!</p>&#13;
<h3 class="h3" id="ch00lev1sec18"><span epub:type="pagebreak" id="page_61"/><strong>Roth’s Payload</strong></h3>&#13;
<p class="noindent">A proof-of-concept exploit is shown in <a href="ch05.xhtml#ch5fig6">Figure 5.6</a>. This proves the bug, but let’s disassemble his payload and see exactly what it does.</p>&#13;
<p class="indent">The write occurs to <code>0x3000</code>, but we know that’s a mirror for <code>0x08003000</code>, so let’s work around that target location for consistency. In Radare2, we would open it like this.</p>&#13;
<div class="imagel"><img src="../images/f0061-01.jpg" alt="Image" width="809" height="43"/></div>&#13;
<p class="indent">The file begins with two 32-bit words. <code>0xf00dbabe</code> is the boot-loader password, and <code>0x080030c1</code> is the reset vector at which code is executed.</p>&#13;
<div class="imagel"><img src="../images/f0061-02.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent">Remembering to drop the least significant bit, we can disassemble that target word to find the infinite loop.<sup><a id="ch5fn_2" href="footnotes.xhtml#ch5fn2">2</a></sup></p>&#13;
<div class="imagel"><img src="../images/f0061-03.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent">But what’s all the rest of the code? Why not just have ten bytes (<code>0xf00dbabe</code>, <code>0x08003009</code>, and <code>b 0x08003009</code>) to loop forever on the first instruction? Well, Roth seems to have included a nearly functional exploit as an Easter egg, neutered into an infinite loop at the last minute by changing the entry point.</p>&#13;
</div>
</div>
</body></html>