- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STATIC
    AND DYNAMIC CODE ANALYSIS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While initial triage, automated sandboxing, and behavioral analysis are essential
    steps in understanding an unknown malware sample, sometimes you need to dig deeper,
    down to the code level. Maybe you’re experiencing problems getting the sample
    to run in a sandbox or VM environment, or perhaps you’re trying to identify any
    hidden capabilities. Whatever your reasons, this chapter will walk you through
    static and dynamic code analysis techniques you can use to reverse engineer a
    malware sample and discover its true intentions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a brief introduction to assembly code, a fundamental concept
    for reverse engineering PE files. Then we’ll dig into static code analysis and
    disassemblers like IDA. Finally, we’ll explore the details of dynamic code analysis
    and debugging with x64dbg.
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*As with [Chapter 2](chapter2.xhtml), the goal of this chapter is to introduce
    key concepts that will be referenced later in this book. It’s not meant to be
    a comprehensive guide to these techniques, but you can find some great beginner’s
    resources listed in [Appendix C](appendix-C.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introduction to Assembly Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Assembly* is a low-level programming language that provides a human- readable
    representation of machine code instructions. When reverse engineering malware,
    malicious programs can be converted from binary machine code to assembly code;
    a process referred to as *disassembly.*'
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces x86 (32-bit) and x86_64 (64-bit, referenced as *x64*
    from here on) assembly code and some CPU concepts that you’ll apply throughout
    the rest of the book. We’ll start with CPU architecture basics and then move on
    to assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU Registers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a program is running, CPUs use *registers*, which are memory locations on
    the physical processor chip, to store data and keep track of the processing state.
    Because memory storage is much slower, the CPU takes advantage of registers as
    much as possible for data storage and manipulation. Depending on processor architecture,
    each register can store a certain amount of data. A *word* is equal to 16 bits
    of data. An x86 processor register usually can store one *dword* (32 bits) of
    data, while an x64 processor register can store one *qword* (64 bits) of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five primary types of CPU registers: (1) general registers, (2) index
    and pointer registers, (3) flag registers, (4) segment registers, and (5) indicator
    registers. The first three are the most important for our purposes here, but I’ll
    touch on the other two later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">General Registers</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*General registers* are used to store and process data for general purposes
    such as arithmetic operations and function arguments. Each general register can
    be split into smaller segments containing 16 or 8 bits of data. For example, the
    x64 RAX register, which can store 64 bits of data, “contains” four additional
    smaller general registers: EAX (the last 32 bits of data in RAX), AX (the upper
    16 bits of EAX), AH (the upper 8 bits of EAX), and AL (the lower 8 bits of EAX).
    [Figure 3-1](chapter3.xhtml#fig3-1) shows the RAX register and its smaller segments
    with their respective storage size limits in bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: General-purpose
    register layout</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](chapter3.xhtml#tab3-1) describes each general register for x86
    and x64 processors. Note that these descriptions reflect how each register has
    been used historically; this doesn’t mean that the register *must* be used in
    this way.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">x86
    and x64 General Registers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EAX</samp> | <samp class="SANS_Futura_Std_Book_11">RAX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The accumulator register, used for tasks
    such as arithmetic, interrupts, and storing return values</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">AX, AH, AL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EAX, upper
    8 bits of EAX, and lower 8 bits of EAX, respectively</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EBX</samp> | <samp class="SANS_Futura_Std_Book_11">RBX</samp>
    | <samp class="SANS_Futura_Std_Book_11">Used for referencing variables and arguments</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">BX, BH, BL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EBX, upper
    8 bits of EBX, and lower 8 bits of EBX, respectively</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">ECX</samp> | <samp class="SANS_Futura_Std_Book_11">RCX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The counter register, used for counting
    and loop control</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">CX, CH, CL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of ECX, upper
    8 bits of ECX, and lower 8 bits of ECX, respectively</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EDX</samp> | <samp class="SANS_Futura_Std_Book_11">RDX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The data register, used primarily for
    arithmetic operations and sometimes as a backup for EAX</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">DX, DH, DL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EDX, upper
    8 bits of EDX, and lower 8 bits of EDX, respectively</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Index and Pointer Registers</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Index registers* and *pointer registers* can store both pointers and addresses.
    They can be used for tasks such as transferring memory data, maintaining control
    flow, and keeping track of the stack. [Table 3-2](chapter3.xhtml#tab3-2) provides
    an overview of these registers.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">x86
    and x64 Index and Pointer Registers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">ESI</samp> | <samp class="SANS_Futura_Std_Book_11">RSI</samp>
    | <samp class="SANS_Futura_Std_Book_11">The source index; typically serves as
    the source address in memory operations</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EDI</samp> | <samp class="SANS_Futura_Std_Book_11">RDI</samp>
    | <samp class="SANS_Futura_Std_Book_11">The destination index; typically serves
    as the destination address in memory operations</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EBP</samp> | <samp class="SANS_Futura_Std_Book_11">RBP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The base pointer; points to the base of
    the stack</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">ESP</samp> | <samp class="SANS_Futura_Std_Book_11">RSP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The stack pointer; points to the last
    item pushed to the stack</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">EIP</samp> | <samp class="SANS_Futura_Std_Book_11">RIP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The extended instruction pointer; points
    to the address of the code that will be executed next</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Flags Register</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *flags register* keeps track of the current state of the processor. Generally,
    it’s used for storing the results of computations and controlling the processor’s
    operation. *Flags* is a general term for the EFLAGS register, which is used in
    32-bit architectures and shown in [Figure 3-2](chapter3.xhtml#fig3-2), and the
    RFLAGS register, which is used in 64-bit architectures. These two registers function
    similarly to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The EFLAGS register</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two most important flag values for our purposes are the *zero flag (ZF)*
    and the *trap flag (TF)*. The ZF is a single bit in length and is set with a conditional
    instruction. For example, a conditional instruction may compare two values; if
    the values are the same, the ZF will be set to 1\. The TF is used for debugging
    purposes and allows the debugger to single-step through instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">x64 and x86 Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve covered the basics of CPU registers and the stack, let’s start
    digging into the various assembly instructions available for a program to use.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Stack Operations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Chapter 1](chapter1.xhtml) briefly mentioned the stack, a region of memory
    assigned to a thread and used to store temporary data such as variables, pointers,
    and other objects that will no longer be needed after the thread completes execution
    and is terminated. The stack operates in a *last-in, first-out (LIFO)* way. This
    means that when a program stores data, let’s say a variable, on the stack, that
    variable goes to the top of the stack. To retrieve the variable, the program must
    first retrieve all the other data above it.'
  prefs: []
  type: TYPE_NORMAL
- en: To place data on the stack, the program executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction, which pushes the data to the top of the stack (see [Figure 3-3](chapter3.xhtml#fig3-3)).
    To retrieve that data, the application executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    instruction, which pops the data off the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: A program pushing
    data to the top of the stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here the program is pushing Value 1 onto the stack first, followed by Value
    2 and then Value 3\. Value 3 is now at the top of the stack. To retrieve Value
    1, the program will have to pop Values 3 and 2 off the stack first, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](chapter3.xhtml#tab3-3) provides an overview of these instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Stack
    Operation Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx push [ebx] push "50"</samp>
    | <samp class="SANS_Futura_Std_Book_11">Push (store) the data in</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(which
    can be a register, memory address, or constant) to the top of the stack.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">pop ebx pop [ebx]</samp> | <samp
    class="SANS_Futura_Std_Book_11">Pop (retrieve) data from the top of the stack
    and stores it in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp
    class="SANS_Futura_Std_Book_11">, which can be a register or memory address.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Most instructions can operate on CPU registers directly as well as on memory
    addresses. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">push
    ebx</samp> instruction will push whatever data is currently stored directly in
    the EBX register onto the stack. Brackets around a register name, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">push [ebx]</samp>, indicate that the instruction
    is dereferencing a pointer to memory, so whatever is stored inside the memory
    address in EBX will be pushed to the stack. For example, if EBX currently contains
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00406028</samp> (a memory
    address), whatever is currently stored at that memory address will be pushed onto
    the stack. In a disassembler (discussed shortly), you’ll usually see this instruction
    written as <samp class="SANS_TheSansMonoCd_W5Regular_11">push byte ptr [ebx]</samp>
    or similar, giving you a clue that this is a pointer to a sequence of bytes in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Arithmetic Operations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Data manipulation and arithmetic instructions are used for computations like
    sums and differences. Some arithmetic instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    take two arguments: the first is a target operand and the second is the value
    to add to it. Others, like <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>,
    which decrements a target operand, take only one argument. [Table 3-4](chapter3.xhtml#tab3-4)
    summarizes some common arithmetic operation instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Arithmetic
    Operation Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">add ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">Add the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant
    such as the value</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp><samp
    class="SANS_Futura_Std_Book_11">) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">sub ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">Subtract the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant)
    from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">inc ecx</samp> | <samp class="SANS_Futura_Std_Book_11">Increment</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register or memory address) by 1.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">dec ecx</samp> | <samp class="SANS_Futura_Std_Book_11">Decrement</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register or memory address) by 1.</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Data Movement</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A program can move data to and from memory and registers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    takes two arguments, but only one can be a memory address. For example, in x86
    and x64 assembly code, a program can’t move data directly from a memory address
    to another memory address. You can see some common examples of these instructions
    in [Table 3-5](chapter3.xhtml#tab3-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Examples
    of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_Futura_Std_Book_11">Instruction</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, ebx mov [ebx],
    100</samp> | <samp class="SANS_Futura_Std_Book_11">Move the data in</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register, memory address, or constant) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Quite often, a program will need to compare two values to direct control flow.
    Comparison instructions may be <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if var</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    but the two primary comparison instructions are <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>. The result of either
    instruction is stored in the zero flag register, which will later be used to direct
    control flow. [Table 3-6](chapter3.xhtml#tab3-6) provides an overview of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Comparison
    Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, ebx cmp eax,
    5</samp> | <samp class="SANS_Futura_Std_Book_11">Compare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address) with</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register, memory address, or constant).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, ebx test
    eax, 5</samp> | <samp class="SANS_Futura_Std_Book_11">Same as above.</samp> |'
  prefs: []
  type: TYPE_TB
- en: You may see instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">test
    eax, eax</samp> that are comparing the value in EAX to itself. This is simply
    a way of checking to see whether the content of the register (EAX, in this case)
    is 0\. When both arguments are the same in a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instruction, it’s essentially comparing the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    If EAX is 0, the zero flag will be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    look incredibly similar, there are fundamental differences in how they work: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> can be seen as a <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instruction, and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> is
    similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> instruction.
    The full details are beyond the scope of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Jump Instructions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A program can use various forms of jump instructions to skip to another area
    of code or to modify control flow based on the comparison instructions just described.
    There are three common types of jump statements worth noting for our purposes,
    summarized in [Table 3-7](chapter3.xhtml#tab3-7).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Jump
    Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp func_00405207 jmp ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump” instruction: jump to another
    address,</samp> <samp class="SANS_Futura_Std_Book_11">function, or segment of
    code;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">can</samp> <samp class="SANS_Futura_Std_Book_11">be
    a register (containing a memory address), a pointer, or an address in code.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jz func_00405207 jz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump-if-zero” instruction: jump to</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">if
    the last arithmetic operation resulted in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz func_00405207 jnz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump-if-not-zero” instruction: jump</samp>
    <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">if the last arithmetic operation did not
    result in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: In the case of the conditional jump statements (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>), these instructions
    inspect the zero flag register for input. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> set these flags,
    they’re usually a precursor to conditional jumps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Call and Return Instructions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programs issue call instructions to invoke a Windows API function or to skip
    to a target function in the code. In the latter form, <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    works a lot like an unconditional jump instruction. Before jumping to a new address,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions push the
    current address (stored in EIP or RIP) to the stack. Later, the program can issue
    a return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction
    to go back to the previous location in code. [Table 3-8](chapter3.xhtml#tab3-8)
    describes these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Call
    and Return Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">call ebx call WriteFile</samp>
    | <samp class="SANS_Futura_Std_Book_11">Call (or jump to) the address in</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp class="SANS_Futura_Std_Book_11">,
    which can be a register (containing a memory address), pointer, or function.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    | <samp class="SANS_Futura_Std_Book_11">Return to the previous code location before
    the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_Futura_Std_Book_11">instruction
    executed.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">No-Operation Instructions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'No-operation, or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>,
    instructions do exactly what you’d think: nothing. An address with a <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instruction is essentially skipped over by the processor. If you’re wondering
    what their purpose is, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instructions are used for various legitimate reasons, including alignment of code
    and memory, timing purposes (such as testing a program’s execution speed), and
    placeholder code (in manual assembly programming, for example).'
  prefs: []
  type: TYPE_NORMAL
- en: However, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>s can also
    be used for more nefarious purposes, such as in shellcode (discussed in [Chapter
    12](chapter12.xhtml)) and exploit code (such as buffer overflows). The presence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions in an
    assembly code segment can be a good signal to an analyst that there’s something
    worth investigating further.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the basics of assembly code, let’s turn our attention
    to investigating malicious code via static code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Static Code Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Static code analysis* is the technique of inspecting code in its static state
    (that is, not during execution) and is usually accomplished with a tool called
    a *disassembler*. Disassemblers allow us to navigate through the malware’s code,
    identify functions or code blocks of interest, and dive deeper into those areas.
    Knowing how to use disassemblers effectively is often what separates novice malware
    analysts from intermediate and advanced ones. Let’s say you have an unknown executable
    file that exhibits only a few behaviors in your automated sandboxes and VMs, or
    perhaps it doesn’t even run properly. Maybe it’s using some VM detection and sandbox
    evasion techniques. Novice malware analysts might throw in the towel at this stage.
    Experienced analysts, however, would likely load the sample into a disassembler
    to identify where to focus their investigation efforts next.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Disassembler</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two of the best-known disassemblers in use today are IDA and Ghidra. Both are
    interactive disassemblers, meaning you can interact with and manually manipulate
    the disassembled code. This allows you to modify code, add comments, rename functions,
    fix incorrectly disassembled code, and in general have greater control over the
    reverse engineering process.
  prefs: []
  type: TYPE_NORMAL
- en: IDA ([*https://<wbr>hex<wbr>-rays<wbr>.com*](https://hex-rays.com)) has always
    been one of the most popular interactive disassemblers, for good reason. It can
    disassemble many different file types, has support for many different processor
    architectures and operating systems, and features many plug-ins and scripts created
    by Hex Rays and the community. IDA comes in various flavors but offers a free
    version that is sufficient for many reverse engineering scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra, on the other hand, is a completely free and open source interactive
    disassembler that implements many of the features of IDA and some additional ones
    such as collaborative disassembly, allowing multiple people to work on a single
    file. Ghidra is newer and, at the time of this writing, doesn’t have as many plug-ins
    or extensibility scripts available as IDA. These will come with time, however.
    You can find a curated list of helpful IDA and Ghidra plug-ins and scripts at
    [*https://<wbr>github<wbr>.com<wbr>/fr0gger<wbr>/awesome<wbr>-ida<wbr>-x64<wbr>-olly<wbr>-plugin*](https://github.com/fr0gger/awesome-ida-x64-olly-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: There are many fans in both the IDA camp and the Ghidra camp, but ultimately
    which one you choose doesn’t matter much. Once you grasp assembly concepts, either
    option will get the job done. For this chapter (and throughout most of this book),
    I’ll be using IDA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with IDA</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s walk through the basic process of static code analysis with IDA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this section, we’ll be investigating a malware file in IDA that you can
    download from VirusTotal or MalShare using the following file hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: 30c9a1460615254a4ef791ffeeba53f4a31361c2646b25d3909025178c5a3976'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To open this suspicious file in IDA, navigate to **File****Open**, accept the
    default options, and select **OK** (see [Figure 3-4](chapter3.xhtml#fig3-4)).
    IDA will then automatically analyze the file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Loading a new file
    into IDA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The IDA interface contains several tabs, some of which represent elements of
    the file that you may wish to inspect (see [Figure 3-5](chapter3.xhtml#fig3-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The IDA interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: On the Imports tab, you can see several interesting functions, including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinHttp</samp> library functions (see
    [Figure 3-6](chapter3.xhtml#fig3-6)), which signal that this malware may try to
    communicate with a server on the internet at some point.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The list of functions
    on the IDA Imports tab</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function
    can be used by malware to connect to a malicious server on the internet. To inspect
    this function call in the program, you can simply double-click it in the Imports
    view and then press CTRL-X to view the cross-references (see [Figure 3-7](chapter3.xhtml#fig3-7)).
    *Cross-references* are addresses in the program’s code that contain the selected
    item.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: Cross-references
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp></samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** on a cross-reference to jump to the location in the code where
    the program is calling <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>,
    as shown in [Figure 3-8](chapter3.xhtml#fig3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: The code location
    for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp>
    function call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’re trying to determine what URL is being opened by the malware, but unfortunately,
    we can’t see much in this code, as the input parameters aren’t clear. We can see
    several <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions
    that are storing parameters on the stack, and one of these parameters is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpszUrl</samp>, which is the target URL.
    If we were to run this program, this parameter would be on the stack at address
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp+lpszUrl]</samp>. However, since
    we’re only looking at the code statically, there are no parameters on the stack
    to inspect, which makes our job more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could trace the code backward to try to determine what the program is eventually
    pushing to the stack as a parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    function. Sometimes this is valuable, but oftentimes tricky malware obfuscates
    this data. An alternative method is to load the malware into a debugger and dynamically
    inspect the stack. We’ll take a look at how to do this in a moment. First, let’s
    discuss one more helpful static code analysis tool.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing
    with CAPA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'CAPA ([*https://<wbr>github<wbr>.com<wbr>/mandiant<wbr>/capa*](https://github.com/mandiant/capa))
    is an open source tool written by researchers at Mandiant. Although not a full-fledged
    disassembler like IDA Pro, it can help malware analysts quickly understand a malware
    sample’s potential behaviors and identify areas of code worth investigating further.
    CAPA works by scanning a PE file for patterns such as strings and specific assembly
    instructions. This scan extracts a wealth of information and helps to guide the
    reverse engineering process. To run CAPA against a target executable file, invoke
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-vv</samp> instruction tells
    CAPA to deliver extra-verbose information. (Note that -<samp class="SANS_TheSansMonoCd_W5Regular_11">vvv</samp>
    returns even more information, and <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    returns less.) [Figure 3-9](chapter3.xhtml#fig3-9) illustrates some sample output
    from CAPA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: CAPA output</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This output reveals some interesting information. First, this sample seems to
    be using evasion techniques such as file obfuscation, process injection, and virtualization
    and sandbox discovery. These tactics may be new to you, but don’t worry, we’ll
    cover them in great detail throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: CAPA running in verbose mode will even provide the address where the suspect
    functionality resides in the executable. [Figure 3-10](chapter3.xhtml#fig3-10)
    shows potential anti-VM instructions identified by CAPA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: Potential anti-VM
    instructions identified by CAPA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The specific anti-VM instruction in [Figure 3-10](chapter3.xhtml#fig3-10) is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>, an assembly instruction
    often used by malware to detect a VM environment. CAPA located the addresses in
    this executable where <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is called (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002157</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x14000217E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002203</samp>).
    Now you can load this malware sample into a disassembler such as IDA Pro and jump
    to these address locations in an executable to quickly find the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-11](chapter3.xhtml#fig3-11) shows another example in which CAPA has
    identified the addresses where suspected malware resides.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: CAPA output showing
    potential process injection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, CAPA has identified a potential process injection technique:
    APC injection, which is a method malware uses to evade host defenses and stealthily
    execute malicious code.'
  prefs: []
  type: TYPE_NORMAL
- en: Used alongside a disassembler and other static code analysis tools, CAPA can
    increase the efficiency of the code analysis process and be a great asset in your
    malware analysis toolbox. We’ll talk more about CAPA in other chapters, but now
    we’ll turn to dynamic code analysis and how it can supplement static code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'While CAPA is incredibly useful, it has a few limitations. First, it has no
    unpacking or deobfuscation capabilities (at least not at the time of this writing),
    so in the case of packed and heavily obfuscated malware, CAPA may produce incorrect
    information or none at all. Second, CAPA occasionally produces false-positive
    indicators. Always manually verify any functionalities you find with CAPA.  ###
    <samp class="SANS_Futura_Std_Bold_B_11">Dynamic Code Analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dynamic code analysis* consists of analyzing code while it’s actively running,
    which usually means executing code in a debugger. *Debuggers* are similar to disassemblers
    in that they also disassemble code and present it to you, but they have the added
    benefit of being able to dynamically execute the code.'
  prefs: []
  type: TYPE_NORMAL
- en: The real power of debuggers is that they allow you to set breakpoints on running
    code. *Breakpoints* are special instructions or flags that trigger an exception
    (or *break*) in the program that passes control to the debugger itself, allowing
    you to take control of the running malware sample.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Debugger</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The x64dbg tool ([*https://<wbr>x64dbg<wbr>.com*](https://x64dbg.com)) is a
    powerful, free, and open source debugger for Windows environments. It’s highly
    customizable and scriptable, and it’s supported by the community with many useful
    plug-ins. Throughout this book, I’ll focus specifically on x64dbg, but many debuggers
    act, look, and feel very similar to it. Some alternatives to x64dbg are the much
    older OllyDbg, IDA Pro’s built-in debugger, or WinDbg.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There are technically two versions of x64dbg: x32dbg (for debugging 32-bit
    programs) and x64dbg (for 64-bit programs). They function exactly the same but
    focus on different architectures. I’ll refer to the program as x64dbg, as the
    debugger’s creator does, but just remember that in order to debug a 32-bit (x86)
    program, you must use the x32dbg version.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Starting a Debugging
    Session in x64dbg</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To load an executable file into x64dbg, choose the right version of x64dbg (the
    32-bit or 64-bit version) and select **File****Open**. (If you use the wrong
    version, you’ll get a helpful message at the bottom of the debugger window, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">"Use x32dbg to debug this file!"</samp>.)
    Alternatively, you can attach the debugger to a currently running malware process
    by selecting **File****Attach**. This approach has the downside that you might
    miss critical behaviors that occurred before you were able to attach to the process
    and begin debugging it.
  prefs: []
  type: TYPE_NORMAL
- en: Once a program is loaded into a debugger, it’s running as a child process under
    the debugger. In most situations, the debugger calls the function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>,
    which permits it to attach to the active process and begin the debug session.
    We’ll return to this API call in [Chapter 10](chapter10.xhtml). For now, let’s
    take a look at the most important sections of the x64dbg user interface, shown
    in [Figure 3-12](chapter3.xhtml#fig3-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The x64dbg debugger</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Tab</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The CPU pane at the top left of the x64dbg window lists the instructions the
    malware will execute, or has already executed, in sequential order. In this window,
    you can step through the code line by line or skip ahead to the more interesting
    parts. EIP (or RIP for x64 programs) marks the instruction that will be executed
    next, as shown in [Figure 3-13](chapter3.xhtml#fig3-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-13: The x64dbg CPU
    tab</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Registers Pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At the top right of the x64dbg window, you’ll see the CPU Registers pane (see
    [Figure 3-14](chapter3.xhtml#fig3-14)). This pane displays each register and flag
    and its currently stored value. This is helpful for keeping track of data and
    addresses stored in registers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-14: The x64dbg CPU
    Registers pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You might also have noticed the EFLAGS section of this pane, which displays
    the flag registers and their values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Arguments Pane</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Arguments pane (see [Figure 3-15](chapter3.xhtml#fig3-15)) is positioned
    in the middle right of the x64dbg window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-15: The x64dbg Arguments
    pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This pane displays the list of arguments on the stack that are passed to the
    current function call in the program. This information is invaluable for monitoring
    and altering arguments to functions.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Stack Pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: On the bottom right of the x64dbg window is the Stack pane. This pane displays
    the currently running thread’s stack memory (see [Figure 3-16](chapter3.xhtml#fig3-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-16: The x64dbg Stack
    pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It is helpful to reference this stack pane when the malware calls a function
    (whether an internal function or a Windows API function). The parameters that
    the malware passes to the function being called will oftentimes be pushed to the
    stack prior to the function call, especially in 32-bit malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Dump Pane</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the bottom left is the Dump pane, shown in [Figure 3-17](chapter3.xhtml#fig3-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-17: The x64dbg Dump
    pane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This view allows you to inspect and monitor memory addresses (or *dumps*) dynamically.
    You can also set *watches* to have x64dbg notify you when a specific event occurs,
    such as when a specific register is modified.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Memory Map Tab</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, the Memory Map tab can be accessed from the series of tabs toward the
    top of the x64dbg window. It’s very useful during dynamic code analysis, as it
    displays the program’s virtual memory layout and allows you to dig deeper into
    each memory region (see [Figure 3-18](chapter3.xhtml#fig3-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-18: The x64dbg Memory
    Map tab</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important uses of the Memory Map pane is hunting for executable
    code in memory during the malware unpacking. I’ll cover this in more detail, and
    memory in general, in [Chapter 17](chapter17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with x64dbg</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll look at a typical debugging scenario for a malware sample to give
    you a high-level overview of what dynamic code analysis inside a debugger looks
    like. We’ll be analyzing the same file we used in “Analyzing with IDA” on [page
    53](chapter3.xhtml#pg_53).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disabling ASLR</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As [Chapter 1](chapter1.xhtml) explained, address space layout randomization
    loads your malware’s executable and libraries into randomized memory locations.
    Although it’s an effective way to thwart attackers, it will also hamper your dynamic
    code analysis efforts, so you should disable it. To disable ASLR for this file,
    you have a few options, but you could use CFF Explorer ([*https://<wbr>ntcore<wbr>.com*](https://ntcore.com))
    here because it makes this process quick and easy. Simply load the malware sample
    into CFF Explorer, select the **Optional Header** category on the left menu, and
    click the **DllCharacteristics** box (see [Figure 3-19](chapter3.xhtml#fig3-19)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-19: Setting a file’s
    DLL characteristics in CFF Explorer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You may recognize the Optional Header from [Chapter 1](chapter1.xhtml). One
    of the fields inside the Optional Header, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllCharacteristics</samp>
    field, contains a number of attributes for the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the pop-up menu, uncheck the box next to **DLL Can Move**, as shown
    in [Figure 3-20](chapter3.xhtml#fig3-20).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-20: Disabling ASLR
    in CFF Explorer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click **OK** and remember to save the modified file by selecting **File****Save**.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Running the Code</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now load the file into x64dbg (more specifically, x32dbg, since this is a 32-bit
    file) by selecting **File****Open**. Once that’s done, you should see several
    options on the Debug menu for running and debugging the program (see [Figure 3-21](chapter3.xhtml#fig3-21)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-21: The Debug menu
    in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the options in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Run**'
  prefs: []
  type: TYPE_NORMAL
- en: Runs the program until something stops the code, such as an exception, error,
    or breakpoint, or a process termination or exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run Until Selection**'
  prefs: []
  type: TYPE_NORMAL
- en: Runs the program until it hits an address in the code that you have manually
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Into**'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to step into a function about to be executed in order to manually
    debug and inspect it. This option is commonly known just as a *step* and will
    be discussed frequently throughout this book. Its keyboard shortcut is F7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Over**'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to step over a function, skipping its execution entirely. This is
    a good way to save time and skip over code that you’re not interested in analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute Till Return**'
  prefs: []
  type: TYPE_NORMAL
- en: Executes the program until it hits the next return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>)
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run to User Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Executes the program and breaks on the user code. This is one of the most useful
    debugging options, as we’ll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: There are more debugging options in the Advanced menu. For example, the option
    Run (Swallow Exceptions) forces the debugger to essentially ignore exceptions.
    Since a large number of exceptions can be problematic while debugging (and malware
    can even purposefully generate exceptions to annoy you!), this can be a good option
    to save you some frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file has been loaded into the debugger, it must complete initialization
    tasks such as loading required libraries and other Windows operating system tasks.
    We’re not interested in this for our purposes and would instead like to skip ahead
    to the malware file’s entry point (the part of the code we want to analyze). To
    do this, select **Debug****Run to User Code** (see [Figure 3-22](chapter3.xhtml#fig3-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-22: The Run to User
    Code entry point</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the malware has been loaded into the debugger, we could simply start
    executing and stepping through code. This isn’t usually the most efficient method,
    however. It’s better to have an idea in mind of what code we’d like to inspect
    in the malware. In the previous section, we found something of interest in IDA:
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function.
    Let’s find and inspect this area of code.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Software Breakpoints</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You set software breakpoints by inserting special CPU instructions, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 3</samp> (in hexadecimal, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>), which is the most common
    breakpoint instruction, or <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 2D</samp>
    (in hexadecimal, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCD 0x2D</samp>).
    Keep in mind that creating software breakpoints directly modifies the running
    program’s code. Most benign programs don’t care about this and ignore it. However,
    some malware doesn’t want to be debugged and will attempt to detect and circumvent
    your breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To jump to the area of code that executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    function, you can simply set a breakpoint on this function call. The most efficient
    way to do this is by entering this instruction in the Command bar at the bottom
    of the x64dbg window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure 3-23](chapter3.xhtml#fig3-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-23: Setting a breakpoint
    on a function call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, execute the sample by using the **Debug****Run** command (or pressing
    F9 on the keyboard). This will execute the malware and break on our target function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>, as shown
    in [Figure 3-24](chapter3.xhtml#fig3-24).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-24: Breakpoint hit!</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the parameters in the Arguments pane, you should see a full URL
    on the stack (see [Figure 3-25](chapter3.xhtml#fig3-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-25: A URL on the stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The internet service *iplogger.org* can be used to log and track IP addresses.
    The malware is likely using this service to track the hosts that are infected
    by this malware sample or to obtain the victim’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Software breakpoints aren’t limited to function calls; you can set them on any
    address you choose. In the CPU pane of x64dbg, simply right-click on an address
    where you’d like to set a breakpoint and select **Breakpoint****Toggle** (or
    press F2). Once the instructions at this address are about to be executed by the
    CPU, the debugger will pause.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Hardware and Memory
    Breakpoints</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As an alternative to software breakpoints, you can set *hardware breakpoints*,
    which are implemented by the CPU itself, or *memory breakpoints*, which are implemented
    using memory protections. Hardware breakpoints are set and stored in CPU registers,
    specifically DR0, DR1, DR2, and DR3\. When you set a hardware breakpoint, the
    address where the breakpoint was set is stored in one of these DR registers. Hardware
    breakpoints have the advantage that they do not directly modify code, so they
    are less invasive and thus a bit more difficult for malware to detect. Their primary
    disadvantage is that only four of them can be placed at a time due to the limited
    number of DR registers.
  prefs: []
  type: TYPE_NORMAL
- en: Memory breakpoints modify the protection attributes of a memory page, effectively
    causing an exception when that memory page is accessed. This is usually accomplished
    by modifying the memory page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    attribute. Memory breakpoints are particularly useful for monitoring addresses
    in memory. For example, if you identify an interesting string in memory at runtime
    (such as a URL or filename), setting a memory breakpoint on that string’s address
    can help you determine where and how the malware is using that string. One downside
    to memory breakpoints is that, since they directly modify memory page protections,
    they can interfere with a program’s operations. Specifically, memory breakpoints
    may cause a program to crash when it attempts to allocate new memory pages or
    modify existing pages. Once a memory breakpoint is triggered, the memory protections
    for the page are reset to the way they were before the breakpoint was set. So,
    if a malware sample modifies the protections of the page before or after the breakpoint
    is triggered, you may undo the malware’s changes or the malware may inadvertently
    (or purposely!) undo your breakpoint. Always be cautious when using memory breakpoints.
    Since hardware and memory breakpoints are often grouped together, from now on
    I’ll use the term *hardware breakpoint* to refer to both.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to set a hardware breakpoint in a program being debugged:'
  prefs: []
  type: TYPE_NORMAL
- en: To set a hardware breakpoint on an address in the CPU pane, right-click the
    address and then click **Breakpoint****Set Hardware on Execution**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Dump pane view, select a single byte for which to set a breakpoint, right-click
    it, and mouse over **Breakpoint** to select from several options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Memory Map tab view, highlight a memory region where you’d like to set
    a breakpoint. Right-click it and select **Memory Breakpoint**, then select the
    breakpoint option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 3-9](chapter3.xhtml#tab3-9) outlines various types of hardware and memory
    breakpoints and ways to implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    of Hardware Breakpoints in x64dbg</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Breakpoint type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Access</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on access. When this address is accessed in any way (read,
    written to, or executed), the breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Write</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on write. When this address is about to be written to, the
    breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Execute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on execute. When the instructions at this address are about
    to be executed, the breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Access</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on access. When this memory page is accessed in any way (read,
    written to, or executed), the breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Read</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on read. When this memory page is about to be read from, the
    breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Write</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on write. When this memory page is about to be written to,
    the breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Execute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on execute. When instructions in this memory page are about
    to be executed, the breakpoint will be triggered.</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'It’s important to note that hardware breakpoints can be set on a byte, a word,
    or a dword. Setting a hardware breakpoint on a specific byte, for example, will
    trigger an exception when that specific byte is accessed. For words and dwords,
    the exception will trigger if the entire word (2 bytes) or dword (4 bytes) is
    accessed. Hardware breakpoints can also be set in two modes: singleshoot and restore.
    The *singleshoot breakpoint*, once triggered, is removed and will not trigger
    again. The *restore breakpoint* will restore itself once triggered, creating a
    persistent breakpoint that will trigger again if the specific address is accessed
    again.'
  prefs: []
  type: TYPE_NORMAL
- en: For malware analysis specifically, hardware breakpoints are most often used
    to counter common debugger and breakpoint detection techniques, as well as during
    manual unpacking of a sample. We’ll discuss hardware breakpoints specifically
    in this context in [Chapters 10](chapter10.xhtml) and [17](chapter17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Patching and Modifying
    Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Patching* means modifying or removing instructions from a program. To do this
    in x64dbg, right-click the address of the code you need to modify and select **Binary**,
    as shown in [Figure 3-26](chapter3.xhtml#fig3-26).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-26: Editing and patching
    code in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Edit option allows you to modify the code at this address. The Fill with
    NOPs option is a good way to quickly clear code; it fills this memory address
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions, essentially
    telling the program to skip over this section of code. To patch out the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    in the current malware sample, for example, you’d highlight the line that contains
    the function call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    InternetOpenUrlW</samp>) and then fill it with NOPs.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, there’s likely no point in patching out the call instruction
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> (unless
    you want to prohibit the malware from connecting to the internet). In general,
    however, patching code in a running malware sample can be a very powerful way
    to bypass anti-analysis and evasion techniques and control a malware’s flow of
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tracing API Calls
    with API Monitor</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: API Monitor ([*http://<wbr>www<wbr>.rohitab<wbr>.com<wbr>/downloads*](http://www.rohitab.com/downloads))
    is a great debugging tool to add to your toolbox, as it allows you to trace and
    monitor malware API function calls. It also enables you to set breakpoints on
    specific functions, so it acts as a rudimentary debugger as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can select the APIs and functions that you’d like to trace in the API Filter
    window (at the top left of the API Monitor window), as shown in [Figure 3-27](chapter3.xhtml#fig3-27).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-27: The API Filter
    menu in API Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here I’ve selected all of the internet- and network-related functions under
    the *Wininet.dll* library.
  prefs: []
  type: TYPE_NORMAL
- en: To monitor a new process, click the **Monitor New Process** button in the middle
    of the API Monitor window and then select the malware executable you want to analyze.
    The default options are good enough, so click **OK** (see [Figure 3-28](chapter3.xhtml#fig3-28)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-28: Monitoring a new
    process in API Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After the malware executes and runs for a few minutes, some API calls will begin
    to populate the Summary window, as you can see in [Figure 3-29](chapter3.xhtml#fig3-29).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-29: A list of API
    calls in API Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You may recognize some of these calls from our previous analysis in x64dbg.
    The power of API Monitor is that it lets you quickly see the function calls you’re
    interested in as well as their arguments and return values. This is immensely
    valuable for getting a quick read on a malware sample’s capabilities or for monitoring
    and tracing suspect behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you took a crash course in assembly code and explored the static
    and dynamic code analysis processes, including the role of disassemblers and debuggers,
    at a high level. In a typical scenario, you’d use static code analysis to identify
    and analyze code worth investigating further, and then you’d follow up with dynamic
    code analysis in a debugger. When you’re reverse engineering malware, it can be
    helpful to switch between static and dynamic code analysis often to fully understand
    the code you’re investigating.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the foundational topics of malware analysis. In the next
    few chapters, we’ll start to dig into how evasive malware is able to detect virtual
    machines, sandboxes, and the tools analysts use to investigate malware internals.
  prefs: []
  type: TYPE_NORMAL
