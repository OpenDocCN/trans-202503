- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STATIC
    AND DYNAMIC CODE ANALYSIS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">静态与动态代码分析</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: While initial triage, automated sandboxing, and behavioral analysis are essential
    steps in understanding an unknown malware sample, sometimes you need to dig deeper,
    down to the code level. Maybe you’re experiencing problems getting the sample
    to run in a sandbox or VM environment, or perhaps you’re trying to identify any
    hidden capabilities. Whatever your reasons, this chapter will walk you through
    static and dynamic code analysis techniques you can use to reverse engineer a
    malware sample and discover its true intentions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步筛查、自动沙箱分析和行为分析是理解未知恶意软件样本的必要步骤时，有时你需要深入挖掘，甚至到代码层面。也许你遇到的问题是无法让样本在沙箱或虚拟机环境中运行，或者你可能在试图识别隐藏的功能。不管是什么原因，本章将指导你如何使用静态和动态代码分析技术来逆向工程恶意软件样本，并发现其真实意图。
- en: We’ll start with a brief introduction to assembly code, a fundamental concept
    for reverse engineering PE files. Then we’ll dig into static code analysis and
    disassemblers like IDA. Finally, we’ll explore the details of dynamic code analysis
    and debugging with x64dbg.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从汇编代码的简要介绍开始，这是逆向工程 PE 文件的一个基本概念。接下来，我们将深入探讨静态代码分析和反汇编工具，如 IDA。最后，我们将探索使用
    x64dbg 进行动态代码分析和调试的细节。
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '> <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>'
- en: '*As with [Chapter 2](chapter2.xhtml), the goal of this chapter is to introduce
    key concepts that will be referenced later in this book. It’s not meant to be
    a comprehensive guide to these techniques, but you can find some great beginner’s
    resources listed in [Appendix C](appendix-C.xhtml).*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*与[第 2 章](chapter2.xhtml)一样，本章的目标是介绍一些本书后续部分会引用的关键概念。它并不是这些技术的全面指南，但你可以在[附录
    C](appendix-C.xhtml)中找到一些很好的初学者资源。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introduction to Assembly Code</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编代码简介</samp>
- en: '*Assembly* is a low-level programming language that provides a human- readable
    representation of machine code instructions. When reverse engineering malware,
    malicious programs can be converted from binary machine code to assembly code;
    a process referred to as *disassembly.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编*是一种低级编程语言，提供了机器码指令的人类可读表示。在进行恶意软件逆向工程时，恶意程序可以从二进制机器码转换为汇编代码；这一过程称为*反汇编*。'
- en: This section introduces x86 (32-bit) and x86_64 (64-bit, referenced as *x64*
    from here on) assembly code and some CPU concepts that you’ll apply throughout
    the rest of the book. We’ll start with CPU architecture basics and then move on
    to assembly instructions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 x86（32 位）和 x86_64（64 位，从此处起简称为 *x64*）汇编代码以及一些将在本书其余部分中应用的 CPU 概念。我们将从
    CPU 架构基础开始，然后转到汇编指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU Registers</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU 寄存器</samp>
- en: As a program is running, CPUs use *registers*, which are memory locations on
    the physical processor chip, to store data and keep track of the processing state.
    Because memory storage is much slower, the CPU takes advantage of registers as
    much as possible for data storage and manipulation. Depending on processor architecture,
    each register can store a certain amount of data. A *word* is equal to 16 bits
    of data. An x86 processor register usually can store one *dword* (32 bits) of
    data, while an x64 processor register can store one *qword* (64 bits) of data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行时，CPU 使用*寄存器*，即物理处理器芯片上的内存位置，来存储数据并跟踪处理状态。由于内存存储速度较慢，CPU 尽可能多地利用寄存器进行数据存储和操作。根据处理器架构的不同，每个寄存器可以存储一定量的数据。一个*字*等于
    16 位数据。x86 处理器寄存器通常可以存储一个*双字*（32 位）数据，而 x64 处理器寄存器可以存储一个*四字*（64 位）数据。
- en: 'There are five primary types of CPU registers: (1) general registers, (2) index
    and pointer registers, (3) flag registers, (4) segment registers, and (5) indicator
    registers. The first three are the most important for our purposes here, but I’ll
    touch on the other two later in the book.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 寄存器有五种主要类型：（1）通用寄存器，（2）索引和指针寄存器，（3）标志寄存器，（4）段寄存器，以及（5）指示器寄存器。前三种对于我们这里的目的最为重要，但我将在本书后续部分介绍其他两种。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">General Registers</samp>
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">通用寄存器</samp>
- en: '*General registers* are used to store and process data for general purposes
    such as arithmetic operations and function arguments. Each general register can
    be split into smaller segments containing 16 or 8 bits of data. For example, the
    x64 RAX register, which can store 64 bits of data, “contains” four additional
    smaller general registers: EAX (the last 32 bits of data in RAX), AX (the upper
    16 bits of EAX), AH (the upper 8 bits of EAX), and AL (the lower 8 bits of EAX).
    [Figure 3-1](chapter3.xhtml#fig3-1) shows the RAX register and its smaller segments
    with their respective storage size limits in bits.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用寄存器* 用于存储和处理用于算术运算、函数参数等一般用途的数据。每个通用寄存器可以分割成包含 16 位或 8 位数据的更小的段。例如，x64 中的
    RAX 寄存器可以存储 64 位数据，RAX “包含”四个额外的更小的通用寄存器：EAX（RAX 中的最后 32 位数据）、AX（EAX 的高 16 位）、AH（EAX
    的高 8 位）和 AL（EAX 的低 8 位）。[图 3-1](chapter3.xhtml#fig3-1) 显示了 RAX 寄存器及其更小的段，并展示了它们的存储大小限制（以位为单位）。'
- en: '![](../images/fig3-1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: General-purpose
    register layout</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：通用寄存器布局</samp>
- en: '[Table 3-1](chapter3.xhtml#tab3-1) describes each general register for x86
    and x64 processors. Note that these descriptions reflect how each register has
    been used historically; this doesn’t mean that the register *must* be used in
    this way.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](chapter3.xhtml#tab3-1) 描述了 x86 和 x64 处理器的每个通用寄存器。请注意，这些描述反映了每个寄存器历史上的使用方式；这并不意味着寄存器*必须*按这种方式使用。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">x86
    and x64 General Registers</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-1：</samp> <samp class="SANS_Futura_Std_Book_11">x86
    和 x64 通用寄存器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EAX</samp> | <samp class="SANS_Futura_Std_Book_11">RAX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The accumulator register, used for tasks
    such as arithmetic, interrupts, and storing return values</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EAX</samp> | <samp class="SANS_Futura_Std_Book_11">RAX</samp>
    | <samp class="SANS_Futura_Std_Book_11">累加寄存器，用于算术运算、中断和存储返回值等任务</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">AX, AH, AL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EAX, upper
    8 bits of EAX, and lower 8 bits of EAX, respectively</samp> |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">AX, AH, AL</samp> | <samp class="SANS_Futura_Std_Book_11">与
    x86 相同</samp> | <samp class="SANS_Futura_Std_Book_11">分别为 EAX 的高 16 位、EAX 的高 8
    位和 EAX 的低 8 位</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EBX</samp> | <samp class="SANS_Futura_Std_Book_11">RBX</samp>
    | <samp class="SANS_Futura_Std_Book_11">Used for referencing variables and arguments</samp>
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EBX</samp> | <samp class="SANS_Futura_Std_Book_11">RBX</samp>
    | <samp class="SANS_Futura_Std_Book_11">用于引用变量和参数</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">BX, BH, BL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EBX, upper
    8 bits of EBX, and lower 8 bits of EBX, respectively</samp> |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">BX, BH, BL</samp> | <samp class="SANS_Futura_Std_Book_11">与
    x86 相同</samp> | <samp class="SANS_Futura_Std_Book_11">分别为 EBX 的高 16 位、EBX 的高 8
    位和 EBX 的低 8 位</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">ECX</samp> | <samp class="SANS_Futura_Std_Book_11">RCX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The counter register, used for counting
    and loop control</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">ECX</samp> | <samp class="SANS_Futura_Std_Book_11">RCX</samp>
    | <samp class="SANS_Futura_Std_Book_11">计数寄存器，用于计数和循环控制</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">CX, CH, CL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of ECX, upper
    8 bits of ECX, and lower 8 bits of ECX, respectively</samp> |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">CX, CH, CL</samp> | <samp class="SANS_Futura_Std_Book_11">与
    x86 相同</samp> | <samp class="SANS_Futura_Std_Book_11">分别为 ECX 的高 16 位、ECX 的高 8
    位和 ECX 的低 8 位</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EDX</samp> | <samp class="SANS_Futura_Std_Book_11">RDX</samp>
    | <samp class="SANS_Futura_Std_Book_11">The data register, used primarily for
    arithmetic operations and sometimes as a backup for EAX</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EDX</samp> | <samp class="SANS_Futura_Std_Book_11">RDX</samp>
    | <samp class="SANS_Futura_Std_Book_11">数据寄存器，主要用于算术运算，有时也作为 EAX 的备份</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">DX, DH, DL</samp> | <samp class="SANS_Futura_Std_Book_11">Same
    as x86</samp> | <samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EDX, upper
    8 bits of EDX, and lower 8 bits of EDX, respectively</samp> |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">DX, DH, DL</samp> | <samp class="SANS_Futura_Std_Book_11">与
    x86 相同</samp> | <samp class="SANS_Futura_Std_Book_11">EDX 的高 16 位、EDX 的高 8 位和
    EDX 的低 8 位</samp> |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Index and Pointer Registers</samp>
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">索引和指针寄存器</samp>
- en: '*Index registers* and *pointer registers* can store both pointers and addresses.
    They can be used for tasks such as transferring memory data, maintaining control
    flow, and keeping track of the stack. [Table 3-2](chapter3.xhtml#tab3-2) provides
    an overview of these registers.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引寄存器*和*指针寄存器*可以存储指针和地址。它们可用于任务，如传输内存数据、维持控制流和跟踪栈。[表 3-2](chapter3.xhtml#tab3-2)概述了这些寄存器。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">x86
    and x64 Index and Pointer Registers</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-2：</samp> <samp class="SANS_Futura_Std_Book_11">x86
    和 x64 索引与指针寄存器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    register</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">x86 寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">x64
    寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">ESI</samp> | <samp class="SANS_Futura_Std_Book_11">RSI</samp>
    | <samp class="SANS_Futura_Std_Book_11">The source index; typically serves as
    the source address in memory operations</samp> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">ESI</samp> | <samp class="SANS_Futura_Std_Book_11">RSI</samp>
    | <samp class="SANS_Futura_Std_Book_11">源索引；通常作为内存操作中的源地址</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EDI</samp> | <samp class="SANS_Futura_Std_Book_11">RDI</samp>
    | <samp class="SANS_Futura_Std_Book_11">The destination index; typically serves
    as the destination address in memory operations</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EDI</samp> | <samp class="SANS_Futura_Std_Book_11">RDI</samp>
    | <samp class="SANS_Futura_Std_Book_11">目标索引；通常作为内存操作中的目标地址</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EBP</samp> | <samp class="SANS_Futura_Std_Book_11">RBP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The base pointer; points to the base of
    the stack</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EBP</samp> | <samp class="SANS_Futura_Std_Book_11">RBP</samp>
    | <samp class="SANS_Futura_Std_Book_11">基址指针；指向栈的基址</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">ESP</samp> | <samp class="SANS_Futura_Std_Book_11">RSP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The stack pointer; points to the last
    item pushed to the stack</samp> |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">ESP</samp> | <samp class="SANS_Futura_Std_Book_11">RSP</samp>
    | <samp class="SANS_Futura_Std_Book_11">栈指针；指向最后一个被推入栈的项目</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">EIP</samp> | <samp class="SANS_Futura_Std_Book_11">RIP</samp>
    | <samp class="SANS_Futura_Std_Book_11">The extended instruction pointer; points
    to the address of the code that will be executed next</samp> |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">EIP</samp> | <samp class="SANS_Futura_Std_Book_11">RIP</samp>
    | <samp class="SANS_Futura_Std_Book_11">扩展指令指针；指向下一条将被执行的代码地址</samp> |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Flags Register</samp>
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">标志寄存器</samp>
- en: The *flags register* keeps track of the current state of the processor. Generally,
    it’s used for storing the results of computations and controlling the processor’s
    operation. *Flags* is a general term for the EFLAGS register, which is used in
    32-bit architectures and shown in [Figure 3-2](chapter3.xhtml#fig3-2), and the
    RFLAGS register, which is used in 64-bit architectures. These two registers function
    similarly to each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*标志寄存器*用于跟踪处理器的当前状态。通常，它用于存储计算结果并控制处理器的操作。*标志*是 EFLAGS 寄存器的通用术语，EFLAGS 用于 32
    位架构，并在[图 3-2](chapter3.xhtml#fig3-2)中展示；而 RFLAGS 寄存器用于 64 位架构。这两个寄存器的功能相似。'
- en: '![](../images/fig3-2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The EFLAGS register</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：EFLAGS 寄存器</samp>
- en: The two most important flag values for our purposes are the *zero flag (ZF)*
    and the *trap flag (TF)*. The ZF is a single bit in length and is set with a conditional
    instruction. For example, a conditional instruction may compare two values; if
    the values are the same, the ZF will be set to 1\. The TF is used for debugging
    purposes and allows the debugger to single-step through instructions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，最重要的两个标志位是*零标志位 (ZF)*和*陷阱标志位 (TF)*。ZF是一个单一的比特位，通过条件指令设置。例如，某个条件指令可能比较两个值；如果值相同，ZF将被设置为1。TF用于调试，允许调试器单步执行指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">x64 and x86 Instructions</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">x64 和 x86 指令</samp>
- en: Now that we’ve covered the basics of CPU registers and the stack, let’s start
    digging into the various assembly instructions available for a program to use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 CPU 寄存器和栈的基本内容，接下来让我们开始深入了解程序可以使用的各种汇编指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Stack Operations</samp>
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">栈操作</samp>
- en: '[Chapter 1](chapter1.xhtml) briefly mentioned the stack, a region of memory
    assigned to a thread and used to store temporary data such as variables, pointers,
    and other objects that will no longer be needed after the thread completes execution
    and is terminated. The stack operates in a *last-in, first-out (LIFO)* way. This
    means that when a program stores data, let’s say a variable, on the stack, that
    variable goes to the top of the stack. To retrieve the variable, the program must
    first retrieve all the other data above it.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](chapter1.xhtml)简要提到了栈，这是分配给线程的内存区域，用于存储临时数据，如变量、指针以及线程执行完成并终止后不再需要的其他对象。栈以*后进先出
    (LIFO)*的方式操作。这意味着，当程序将数据（例如变量）存储到栈中时，该变量会被放置到栈顶。要检索该变量，程序必须首先取出栈顶以上的所有其他数据。'
- en: To place data on the stack, the program executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction, which pushes the data to the top of the stack (see [Figure 3-3](chapter3.xhtml#fig3-3)).
    To retrieve that data, the application executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    instruction, which pops the data off the top of the stack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据放置到栈中，程序执行一个<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令，这会将数据推送到栈顶（见[图
    3-3](chapter3.xhtml#fig3-3)）。要检索该数据，应用程序执行一个<samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>指令，这会将栈顶的数据弹出。
- en: '![](../images/fig3-3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: A program pushing
    data to the top of the stack</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：一个程序将数据推送到栈顶</samp>
- en: Here the program is pushing Value 1 onto the stack first, followed by Value
    2 and then Value 3\. Value 3 is now at the top of the stack. To retrieve Value
    1, the program will have to pop Values 3 and 2 off the stack first, in that order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里程序首先将值 1 推送到栈中，然后是值 2，最后是值 3。此时，值 3 位于栈顶。要检索值 1，程序首先需要按照顺序弹出值 3 和值 2。
- en: '[Table 3-3](chapter3.xhtml#tab3-3) provides an overview of these instructions.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](chapter3.xhtml#tab3-3)提供了这些指令的概览。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Stack
    Operation Instructions</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-3：</samp> <samp class="SANS_Futura_Std_Book_11">栈操作指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx push [ebx] push "50"</samp>
    | <samp class="SANS_Futura_Std_Book_11">Push (store) the data in</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(which
    can be a register, memory address, or constant) to the top of the stack.</samp>
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx push [ebx] push "50"</samp>
    | <samp class="SANS_Futura_Std_Book_11">将数据存储到</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(可以是寄存器、内存地址或常量)的栈顶。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">pop ebx pop [ebx]</samp> | <samp
    class="SANS_Futura_Std_Book_11">Pop (retrieve) data from the top of the stack
    and stores it in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp
    class="SANS_Futura_Std_Book_11">, which can be a register or memory address.</samp>
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">pop ebx pop [ebx]</samp> | <samp
    class="SANS_Futura_Std_Book_11">从栈顶弹出（获取）数据，并将其存储在</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp
    class="SANS_Futura_Std_Book_11">中，<samp class="SANS_Futura_Std_Book_11">可以是寄存器或内存地址。</samp>
    |'
- en: Most instructions can operate on CPU registers directly as well as on memory
    addresses. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">push
    ebx</samp> instruction will push whatever data is currently stored directly in
    the EBX register onto the stack. Brackets around a register name, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">push [ebx]</samp>, indicate that the instruction
    is dereferencing a pointer to memory, so whatever is stored inside the memory
    address in EBX will be pushed to the stack. For example, if EBX currently contains
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00406028</samp> (a memory
    address), whatever is currently stored at that memory address will be pushed onto
    the stack. In a disassembler (discussed shortly), you’ll usually see this instruction
    written as <samp class="SANS_TheSansMonoCd_W5Regular_11">push byte ptr [ebx]</samp>
    or similar, giving you a clue that this is a pointer to a sequence of bytes in
    memory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数指令可以直接在 CPU 寄存器和内存地址上操作。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">push
    ebx</samp> 指令会将当前存储在 EBX 寄存器中的数据直接推入栈中。寄存器名称周围的括号，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">push
    [ebx]</samp>，表示指令正在解除引用内存指针，因此，存储在 EBX 中的内存地址所指向的数据将被推入栈中。例如，如果 EBX 当前包含值 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x00406028</samp>（一个内存地址），那么存储在该内存地址的数据将被推入栈中。在反汇编程序中（稍后讨论），你通常会看到这条指令写作
    <samp class="SANS_TheSansMonoCd_W5Regular_11">push byte ptr [ebx]</samp> 或类似形式，提示你这指向内存中一系列字节的指针。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Arithmetic Operations</samp>
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">算术运算</samp>
- en: 'Data manipulation and arithmetic instructions are used for computations like
    sums and differences. Some arithmetic instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    take two arguments: the first is a target operand and the second is the value
    to add to it. Others, like <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>,
    which decrements a target operand, take only one argument. [Table 3-4](chapter3.xhtml#tab3-4)
    summarizes some common arithmetic operation instructions.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据操作和算术指令用于计算，如加法和减法。某些算术指令，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>，需要两个操作数：第一个是目标操作数，第二个是要加到其上的值。其他的指令，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>，用于递减目标操作数，只需要一个操作数。[表
    3-4](chapter3.xhtml#tab3-4)总结了一些常见的算术运算指令。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Arithmetic
    Operation Instructions</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-4：</samp> <samp class="SANS_Futura_Std_Book_11">算术运算指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">add ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">Add the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant
    such as the value</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp><samp
    class="SANS_Futura_Std_Book_11">) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">add ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">将</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(一个寄存器、内存地址或常量，如值</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp><samp
    class="SANS_Futura_Std_Book_11">) 加到</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(一个寄存器或内存地址)中。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">sub ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">Subtract the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant)
    from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">sub ebx, 50</samp>
    | <samp class="SANS_Futura_Std_Book_11">将</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(一个寄存器、内存地址或常量)的值从</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(一个寄存器或内存地址)中减去。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">inc ecx</samp> | <samp class="SANS_Futura_Std_Book_11">Increment</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register or memory address) by 1.</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">inc ecx</samp> | <samp class="SANS_Futura_Std_Book_11">将</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(一个寄存器或内存地址)增加1。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">dec ecx</samp> | <samp class="SANS_Futura_Std_Book_11">Decrement</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register or memory address) by 1.</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">dec ecx</samp> | <samp class="SANS_Futura_Std_Book_11">将</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(一个寄存器或内存地址)减少1。</samp>
    |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Data Movement</samp>
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">数据移动</samp>
- en: A program can move data to and from memory and registers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    takes two arguments, but only one can be a memory address. For example, in x86
    and x64 assembly code, a program can’t move data directly from a memory address
    to another memory address. You can see some common examples of these instructions
    in [Table 3-5](chapter3.xhtml#tab3-5).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令在内存和寄存器之间移动数据。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令需要两个参数，但只能有一个是内存地址。例如，在 x86
    和 x64 汇编代码中，程序不能直接将数据从一个内存地址移动到另一个内存地址。你可以在 [表 3-5](chapter3.xhtml#tab3-5) 中看到这些指令的一些常见示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Examples
    of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_Futura_Std_Book_11">Instruction</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">mov</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">指令的示例</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, ebx mov [ebx],
    100</samp> | <samp class="SANS_Futura_Std_Book_11">Move the data in</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register, memory address, or constant) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, ebx mov [ebx],
    100</samp> | <samp class="SANS_Futura_Std_Book_11">将</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(寄存器、内存地址或常量) 的数据移动到</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(寄存器或内存地址)。</samp> |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons</samp>
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">值比较</samp>
- en: Quite often, a program will need to compare two values to direct control flow.
    Comparison instructions may be <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if var</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    but the two primary comparison instructions are <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>. The result of either
    instruction is stored in the zero flag register, which will later be used to direct
    control flow. [Table 3-6](chapter3.xhtml#tab3-6) provides an overview of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instructions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，程序需要比较两个值以引导控制流。比较指令可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">if var</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，但两条主要的比较指令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>。任一指令的结果都会存储在零标志寄存器中，稍后将用来引导控制流。[表
    3-6](chapter3.xhtml#tab3-6) 提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> 指令的概述。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Comparison
    Instructions</samp>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-6：</samp> <samp class="SANS_Futura_Std_Book_11">比较指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, ebx cmp eax,
    5</samp> | <samp class="SANS_Futura_Std_Book_11">Compare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(a register or memory address) with</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a
    register, memory address, or constant).</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, ebx cmp eax,
    5</samp> | <samp class="SANS_Futura_Std_Book_11">比较</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">(寄存器或内存地址) 与</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp>
    <samp class="SANS_Futura_Std_Book_11">(寄存器、内存地址或常量)。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, ebx test
    eax, 5</samp> | <samp class="SANS_Futura_Std_Book_11">Same as above.</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1,
    arg2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, ebx test
    eax, 5</samp> | <samp class="SANS_Futura_Std_Book_11">与上面相同。</samp> |'
- en: You may see instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">test
    eax, eax</samp> that are comparing the value in EAX to itself. This is simply
    a way of checking to see whether the content of the register (EAX, in this case)
    is 0\. When both arguments are the same in a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instruction, it’s essentially comparing the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    If EAX is 0, the zero flag will be set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到像 <samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, eax</samp> 这样的指令，它比较的是
    EAX 中的值和它自身。这实际上是在检查寄存器（此处为 EAX）的内容是否为 0。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    指令中的两个参数相同时，实际上是将该参数与 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 进行比较。如果
    EAX 为 0，则零标志将被设置。
- en: 'Though <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    look incredibly similar, there are fundamental differences in how they work: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> can be seen as a <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instruction, and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> is
    similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> instruction.
    The full details are beyond the scope of this chapter.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    看起来非常相似，但它们的工作原理存在根本性的差异：<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    可以看作是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> 指令，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 指令。具体细节超出了本章的范围。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Jump Instructions</samp>
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">跳转指令</samp>
- en: A program can use various forms of jump instructions to skip to another area
    of code or to modify control flow based on the comparison instructions just described.
    There are three common types of jump statements worth noting for our purposes,
    summarized in [Table 3-7](chapter3.xhtml#tab3-7).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以使用各种跳转指令跳过到代码的其他区域，或者根据之前提到的比较指令来修改控制流。我们需要注意的三种常见跳转语句已在[表3-7](chapter3.xhtml#tab3-7)中总结。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Jump
    Instructions</samp>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表3-7：</samp> <samp class="SANS_Futura_Std_Book_11">跳转指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp func_00405207 jmp ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump” instruction: jump to another
    address,</samp> <samp class="SANS_Futura_Std_Book_11">function, or segment of
    code;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">can</samp> <samp class="SANS_Futura_Std_Book_11">be
    a register (containing a memory address), a pointer, or an address in code.</samp>
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp func_00405207 jmp ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">“跳转”指令：跳转到另一个地址、函数或代码段；</samp> <samp class="SANS_Futura_Std_Book_11">可以是寄存器（包含内存地址）、指针或代码中的地址。</samp>'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jz func_00405207 jz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump-if-zero” instruction: jump to</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">if
    the last arithmetic operation resulted in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jz func_00405207 jz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">“零值跳转”指令：如果上一个算术操作的结果为</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_Futura_Std_Book_11">，则跳转到</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">。</samp>'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz func_00405207 jnz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">The “jump-if-not-zero” instruction: jump</samp>
    <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    <samp class="SANS_Futura_Std_Book_11">if the last arithmetic operation did not
    result in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz func_00405207 jnz ebx</samp>
    | <samp class="SANS_Futura_Std_Book_11">“非零跳转”指令：如果上一个算术操作结果不是</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp
    class="SANS_Futura_Std_Book_11">，则跳转到</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: In the case of the conditional jump statements (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>), these instructions
    inspect the zero flag register for input. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> set these flags,
    they’re usually a precursor to conditional jumps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件跳转指令（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>），这些指令会检查零标志寄存器的输入。由于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    会设置这些标志，它们通常是条件跳转的前奏。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Call and Return Instructions</samp>
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">调用与返回指令</samp>
- en: Programs issue call instructions to invoke a Windows API function or to skip
    to a target function in the code. In the latter form, <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    works a lot like an unconditional jump instruction. Before jumping to a new address,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions push the
    current address (stored in EIP or RIP) to the stack. Later, the program can issue
    a return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction
    to go back to the previous location in code. [Table 3-8](chapter3.xhtml#tab3-8)
    describes these instructions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 程序发出调用指令以调用 Windows API 函数或跳转到代码中的目标函数。在后者的形式中，<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    类似于无条件跳转指令。在跳转到新地址之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    指令会将当前地址（存储在 EIP 或 RIP 中）推送到栈中。之后，程序可以发出返回（<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>）指令返回到代码中的前一个位置。[表
    3-8](chapter3.xhtml#tab3-8)描述了这些指令。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Call
    and Return Instructions</samp>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-8：</samp> <samp class="SANS_Futura_Std_Book_11">调用与返回指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">call ebx call WriteFile</samp>
    | <samp class="SANS_Futura_Std_Book_11">Call (or jump to) the address in</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp class="SANS_Futura_Std_Book_11">,
    which can be a register (containing a memory address), pointer, or function.</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">call ebx call WriteFile</samp>
    | <samp class="SANS_Futura_Std_Book_11">调用（或跳转到）</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp
    class="SANS_Futura_Std_Book_11">中存储的地址，可以是寄存器（包含内存地址）、指针或函数。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    | <samp class="SANS_Futura_Std_Book_11">Return to the previous code location before
    the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_Futura_Std_Book_11">instruction
    executed.</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    | <samp class="SANS_Futura_Std_Book_11">返回到执行过</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    <samp class="SANS_Futura_Std_Book_11">指令之前的代码位置。</samp> |'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">No-Operation Instructions</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">空操作指令</samp>'
- en: 'No-operation, or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>,
    instructions do exactly what you’d think: nothing. An address with a <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instruction is essentially skipped over by the processor. If you’re wondering
    what their purpose is, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instructions are used for various legitimate reasons, including alignment of code
    and memory, timing purposes (such as testing a program’s execution speed), and
    placeholder code (in manual assembly programming, for example).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 空操作指令，或称<samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令，正如你所想，它们什么也不做。含有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令的地址本质上会被处理器跳过。如果你在想它们的目的是什么，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令有许多合法用途，包括代码和内存的对齐、时间控制（例如测试程序的执行速度），以及占位代码（例如在手动汇编编程中）。
- en: However, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>s can also
    be used for more nefarious purposes, such as in shellcode (discussed in [Chapter
    12](chapter12.xhtml)) and exploit code (such as buffer overflows). The presence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions in an
    assembly code segment can be a good signal to an analyst that there’s something
    worth investigating further.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>也可以用于更恶意的目的，例如在shellcode（在[第12章](chapter12.xhtml)中讨论）和漏洞利用代码（例如缓冲区溢出）中使用。汇编代码段中存在的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令可以为分析员提供一个很好的信号，提示可能有值得进一步调查的内容。
- en: Now that we’ve looked at the basics of assembly code, let’s turn our attention
    to investigating malicious code via static code analysis.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了汇编代码的基础，接下来让我们关注通过静态代码分析来调查恶意代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Static Code Analysis</samp>
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">静态代码分析</samp>
- en: '*Static code analysis* is the technique of inspecting code in its static state
    (that is, not during execution) and is usually accomplished with a tool called
    a *disassembler*. Disassemblers allow us to navigate through the malware’s code,
    identify functions or code blocks of interest, and dive deeper into those areas.
    Knowing how to use disassemblers effectively is often what separates novice malware
    analysts from intermediate and advanced ones. Let’s say you have an unknown executable
    file that exhibits only a few behaviors in your automated sandboxes and VMs, or
    perhaps it doesn’t even run properly. Maybe it’s using some VM detection and sandbox
    evasion techniques. Novice malware analysts might throw in the towel at this stage.
    Experienced analysts, however, would likely load the sample into a disassembler
    to identify where to focus their investigation efforts next.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态代码分析*是检查代码静态状态（即不在执行时）的技术，通常使用一种叫做*反汇编工具*的工具来实现。反汇编工具允许我们浏览恶意软件的代码，识别感兴趣的函数或代码块，并深入研究这些区域。了解如何有效地使用反汇编工具通常是区分初学者与中级及高级恶意软件分析员的关键。假设你有一个未知的可执行文件，在你的自动化沙箱和虚拟机中只表现出一些行为，或者它甚至根本无法正常运行。也许它使用了某些虚拟机检测和沙箱规避技术。初学者在这个阶段可能会放弃，而经验丰富的分析员则很可能会将样本加载到反汇编工具中，以确定接下来该将调查重点放在哪里。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Disassembler</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">选择反汇编工具</samp>
- en: Two of the best-known disassemblers in use today are IDA and Ghidra. Both are
    interactive disassemblers, meaning you can interact with and manually manipulate
    the disassembled code. This allows you to modify code, add comments, rename functions,
    fix incorrectly disassembled code, and in general have greater control over the
    reverse engineering process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最著名的两款反汇编工具是IDA和Ghidra。它们都是交互式反汇编工具，意味着你可以与反汇编代码进行互动并手动操作。这允许你修改代码、添加注释、重命名函数、修复错误的反汇编代码，总的来说，能更好地控制逆向工程过程。
- en: IDA ([*https://<wbr>hex<wbr>-rays<wbr>.com*](https://hex-rays.com)) has always
    been one of the most popular interactive disassemblers, for good reason. It can
    disassemble many different file types, has support for many different processor
    architectures and operating systems, and features many plug-ins and scripts created
    by Hex Rays and the community. IDA comes in various flavors but offers a free
    version that is sufficient for many reverse engineering scenarios.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IDA ([*https://<wbr>hex<wbr>-rays<wbr>.com*](https://hex-rays.com)) 一直是最受欢迎的交互式反汇编工具之一，原因很充分。它可以反汇编多种文件类型，支持多种处理器架构和操作系统，并且拥有许多
    Hex Rays 和社区创建的插件和脚本。IDA 有多种版本，但提供了一个免费版，足以满足许多逆向工程的需求。
- en: Ghidra, on the other hand, is a completely free and open source interactive
    disassembler that implements many of the features of IDA and some additional ones
    such as collaborative disassembly, allowing multiple people to work on a single
    file. Ghidra is newer and, at the time of this writing, doesn’t have as many plug-ins
    or extensibility scripts available as IDA. These will come with time, however.
    You can find a curated list of helpful IDA and Ghidra plug-ins and scripts at
    [*https://<wbr>github<wbr>.com<wbr>/fr0gger<wbr>/awesome<wbr>-ida<wbr>-x64<wbr>-olly<wbr>-plugin*](https://github.com/fr0gger/awesome-ida-x64-olly-plugin).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Ghidra 是一个完全免费的开源交互式反汇编工具，具有许多 IDA 的功能，还增加了一些新特性，例如协作反汇编，允许多人共同处理一个文件。Ghidra
    较新，并且在写作时，它还没有像 IDA 那样拥有众多插件或扩展脚本。不过，随着时间推移，这些功能会逐步增加。你可以在[*https://<wbr>github<wbr>.com<wbr>/fr0gger<wbr>/awesome<wbr>-ida<wbr>-x64<wbr>-olly<wbr>-plugin*](https://github.com/fr0gger/awesome-ida-x64-olly-plugin)找到一个精心策划的
    IDA 和 Ghidra 插件及脚本列表。
- en: There are many fans in both the IDA camp and the Ghidra camp, but ultimately
    which one you choose doesn’t matter much. Once you grasp assembly concepts, either
    option will get the job done. For this chapter (and throughout most of this book),
    I’ll be using IDA.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 阵营和 Ghidra 阵营中都有许多粉丝，但最终你选择哪一个并不太重要。一旦掌握了汇编概念，任一选项都能完成任务。对于本章（以及本书的大部分内容），我将使用
    IDA。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with IDA</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用 IDA 分析</samp>
- en: Let’s walk through the basic process of static code analysis with IDA.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 IDA 进行静态代码分析的基本过程。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In this section, we’ll be investigating a malware file in IDA that you can
    download from VirusTotal or MalShare using the following file hash:*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本节中，我们将使用 IDA 分析一个恶意软件文件，你可以通过以下文件哈希从 VirusTotal 或 MalShare 下载该文件：*'
- en: 'SHA256: 30c9a1460615254a4ef791ffeeba53f4a31361c2646b25d3909025178c5a3976'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: 30c9a1460615254a4ef791ffeeba53f4a31361c2646b25d3909025178c5a3976'
- en: To open this suspicious file in IDA, navigate to **File****Open**, accept the
    default options, and select **OK** (see [Figure 3-4](chapter3.xhtml#fig3-4)).
    IDA will then automatically analyze the file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 IDA 中打开这个可疑文件，请导航至 **文件****打开**，接受默认选项，然后点击 **确定**（见[图 3-4](chapter3.xhtml#fig3-4)）。IDA
    将自动分析该文件。
- en: '![](../images/fig3-4.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Loading a new file
    into IDA</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-4: 将新文件加载到 IDA 中</samp>'
- en: The IDA interface contains several tabs, some of which represent elements of
    the file that you may wish to inspect (see [Figure 3-5](chapter3.xhtml#fig3-5)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 界面包含多个选项卡，其中一些代表你可能希望检查的文件元素（见[图 3-5](chapter3.xhtml#fig3-5)）。
- en: '![](../images/fig3-5.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The IDA interface</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-5: IDA 界面</samp>'
- en: On the Imports tab, you can see several interesting functions, including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinHttp</samp> library functions (see
    [Figure 3-6](chapter3.xhtml#fig3-6)), which signal that this malware may try to
    communicate with a server on the internet at some point.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在“导入”选项卡中，你可以看到几个有趣的函数，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">WinHttp</samp>
    库函数（见[图 3-6](chapter3.xhtml#fig3-6)），这些函数表明该恶意软件可能会在某些时候尝试与互联网上的服务器通信。
- en: '![](../images/fig3-6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The list of functions
    on the IDA Imports tab</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-6: IDA 导入选项卡上的函数列表</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function
    can be used by malware to connect to a malicious server on the internet. To inspect
    this function call in the program, you can simply double-click it in the Imports
    view and then press CTRL-X to view the cross-references (see [Figure 3-7](chapter3.xhtml#fig3-7)).
    *Cross-references* are addresses in the program’s code that contain the selected
    item.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>函数可被恶意软件用来连接到互联网上的恶意服务器。要检查程序中此函数的调用，你只需在导入视图中双击它，然后按CTRL-X查看交叉引用（参见[图3-7](chapter3.xhtml#fig3-7)）。*交叉引用*是程序代码中包含所选项的地址。
- en: '![](../images/fig3-7.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: Cross-references
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp></samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-7：指向<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp>的交叉引用</samp>
- en: Click **OK** on a cross-reference to jump to the location in the code where
    the program is calling <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>,
    as shown in [Figure 3-8](chapter3.xhtml#fig3-8).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**以跳转到代码中的位置，查看程序调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>，如[图3-8](chapter3.xhtml#fig3-8)所示。
- en: '![](../images/fig3-8.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: The code location
    for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp>
    function call</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-8：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp>函数调用的代码位置</samp>
- en: We’re trying to determine what URL is being opened by the malware, but unfortunately,
    we can’t see much in this code, as the input parameters aren’t clear. We can see
    several <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions
    that are storing parameters on the stack, and one of these parameters is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpszUrl</samp>, which is the target URL.
    If we were to run this program, this parameter would be on the stack at address
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp+lpszUrl]</samp>. However, since
    we’re only looking at the code statically, there are no parameters on the stack
    to inspect, which makes our job more difficult.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在尝试确定恶意软件打开的是哪个URL，但不幸的是，由于输入参数不明确，我们无法从这段代码中看到太多内容。我们可以看到几条<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令，这些指令将参数存储在栈上，其中一个参数是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpszUrl</samp>，它是目标URL。如果我们运行这个程序，这个参数将位于栈上的地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[ebp+lpszUrl]</samp>。然而，由于我们只是静态地查看代码，栈上没有参数可以检查，这使得我们的工作变得更加困难。
- en: 'We could trace the code backward to try to determine what the program is eventually
    pushing to the stack as a parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    function. Sometimes this is valuable, but oftentimes tricky malware obfuscates
    this data. An alternative method is to load the malware into a debugger and dynamically
    inspect the stack. We’ll take a look at how to do this in a moment. First, let’s
    discuss one more helpful static code analysis tool.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing
    with CAPA</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以逆向跟踪代码，试图确定程序最终将什么参数压入栈中，作为传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>函数的参数。有时候这样做很有价值，但通常情况下，恶意软件会混淆这些数据。另一种方法是将恶意软件加载到调试器中，动态检查栈。稍后我们会看看如何操作。首先，让我们讨论一个有用的静态代码分析工具。  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用CAPA进行分析</samp>'
- en: 'CAPA ([*https://<wbr>github<wbr>.com<wbr>/mandiant<wbr>/capa*](https://github.com/mandiant/capa))
    is an open source tool written by researchers at Mandiant. Although not a full-fledged
    disassembler like IDA Pro, it can help malware analysts quickly understand a malware
    sample’s potential behaviors and identify areas of code worth investigating further.
    CAPA works by scanning a PE file for patterns such as strings and specific assembly
    instructions. This scan extracts a wealth of information and helps to guide the
    reverse engineering process. To run CAPA against a target executable file, invoke
    the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: CAPA（[*https://<wbr>github<wbr>.com<wbr>/mandiant<wbr>/capa*](https://github.com/mandiant/capa)）是由Mandiant的研究人员编写的开源工具。尽管它不是像IDA
    Pro那样的完整反汇编工具，但它可以帮助恶意软件分析师快速理解恶意软件样本的潜在行为，并识别值得进一步调查的代码区域。CAPA通过扫描PE文件中的模式，如字符串和特定的汇编指令，来工作。此扫描提取了大量信息，并有助于引导逆向工程过程。要在目标可执行文件上运行CAPA，执行以下命令：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-vv</samp> instruction tells
    CAPA to deliver extra-verbose information. (Note that -<samp class="SANS_TheSansMonoCd_W5Regular_11">vvv</samp>
    returns even more information, and <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    returns less.) [Figure 3-9](chapter3.xhtml#fig3-9) illustrates some sample output
    from CAPA.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-vv</samp>指令告诉CAPA提供额外的详细信息。（请注意，-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">vvv</samp>会返回更多信息，而<samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>则返回较少。）[图3-9](chapter3.xhtml#fig3-9)展示了CAPA的一些示例输出。
- en: '![](../images/fig3-9.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: CAPA output</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-9：CAPA输出</samp>
- en: This output reveals some interesting information. First, this sample seems to
    be using evasion techniques such as file obfuscation, process injection, and virtualization
    and sandbox discovery. These tactics may be new to you, but don’t worry, we’ll
    cover them in great detail throughout this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输出揭示了一些有趣的信息。首先，这个样本似乎正在使用规避技术，如文件混淆、进程注入以及虚拟化和沙箱检测。这些战术可能对你来说是新的，但别担心，我们将在本书的后续章节中详细讲解它们。
- en: CAPA running in verbose mode will even provide the address where the suspect
    functionality resides in the executable. [Figure 3-10](chapter3.xhtml#fig3-10)
    shows potential anti-VM instructions identified by CAPA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在详细模式下的CAPA甚至会提供可执行文件中嫌疑功能所在的地址。[图3-10](chapter3.xhtml#fig3-10)显示了CAPA识别的潜在反虚拟机指令。
- en: '![](../images/fig3-10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: Potential anti-VM
    instructions identified by CAPA</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-10：CAPA识别的潜在反虚拟机指令</samp>
- en: The specific anti-VM instruction in [Figure 3-10](chapter3.xhtml#fig3-10) is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>, an assembly instruction
    often used by malware to detect a VM environment. CAPA located the addresses in
    this executable where <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is called (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002157</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x14000217E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002203</samp>).
    Now you can load this malware sample into a disassembler such as IDA Pro and jump
    to these address locations in an executable to quickly find the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instructions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-10](chapter3.xhtml#fig3-10)中的特定反虚拟机指令是<samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>，这是一条恶意软件常用的汇编指令，用于检测虚拟机环境。CAPA定位了此可执行文件中调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>的地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002157</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x14000217E</samp>，和<samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002203</samp>）。现在，你可以将这个恶意样本加载到反汇编工具中，比如IDA
    Pro，并跳转到这些地址位置，快速找到<samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>指令。'
- en: '[Figure 3-11](chapter3.xhtml#fig3-11) shows another example in which CAPA has
    identified the addresses where suspected malware resides.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-11](chapter3.xhtml#fig3-11)显示了另一个例子，CAPA识别了怀疑恶意软件所在的地址。'
- en: '![](../images/fig3-11.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: CAPA output showing
    potential process injection</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-11：CAPA输出显示潜在的进程注入</samp>
- en: 'In this case, CAPA has identified a potential process injection technique:
    APC injection, which is a method malware uses to evade host defenses and stealthily
    execute malicious code.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，CAPA识别了一种潜在的进程注入技术：APC注入，这是一种恶意软件用来规避宿主防御并隐蔽执行恶意代码的方法。
- en: Used alongside a disassembler and other static code analysis tools, CAPA can
    increase the efficiency of the code analysis process and be a great asset in your
    malware analysis toolbox. We’ll talk more about CAPA in other chapters, but now
    we’ll turn to dynamic code analysis and how it can supplement static code analysis.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与反汇编器和其他静态代码分析工具配合使用时，CAPA可以提高代码分析过程的效率，是你恶意软件分析工具箱中的得力助手。我们将在后续章节中详细介绍CAPA，但现在我们将转向动态代码分析，并讨论它如何补充静态代码分析。
- en: 'While CAPA is incredibly useful, it has a few limitations. First, it has no
    unpacking or deobfuscation capabilities (at least not at the time of this writing),
    so in the case of packed and heavily obfuscated malware, CAPA may produce incorrect
    information or none at all. Second, CAPA occasionally produces false-positive
    indicators. Always manually verify any functionalities you find with CAPA.  ###
    <samp class="SANS_Futura_Std_Bold_B_11">Dynamic Code Analysis</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然CAPA非常有用，但它也有一些局限性。首先，它没有解包或去混淆的功能（至少在本文写作时是如此），因此在处理打包和高度混淆的恶意软件时，CAPA可能会产生不正确的信息，甚至什么信息都没有。其次，CAPA偶尔会产生误报。始终手动验证通过CAPA找到的任何功能。  ###
    <samp class="SANS_Futura_Std_Bold_B_11">动态代码分析</samp>'
- en: '*Dynamic code analysis* consists of analyzing code while it’s actively running,
    which usually means executing code in a debugger. *Debuggers* are similar to disassemblers
    in that they also disassemble code and present it to you, but they have the added
    benefit of being able to dynamically execute the code.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态代码分析*包括在代码处于活动运行状态时进行分析，这通常意味着在调试器中执行代码。*调试器*与反汇编器类似，它们也会反汇编代码并将其呈现给您，但它们的附加优势是能够动态执行代码。'
- en: The real power of debuggers is that they allow you to set breakpoints on running
    code. *Breakpoints* are special instructions or flags that trigger an exception
    (or *break*) in the program that passes control to the debugger itself, allowing
    you to take control of the running malware sample.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器的真正强大之处在于它们允许您在运行中的代码上设置断点。*断点*是特殊的指令或标志，当程序执行到这些断点时，会触发异常（或*中断*），将控制权交给调试器本身，使您可以控制正在运行的恶意软件样本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Debugger</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">选择调试器</samp>
- en: The x64dbg tool ([*https://<wbr>x64dbg<wbr>.com*](https://x64dbg.com)) is a
    powerful, free, and open source debugger for Windows environments. It’s highly
    customizable and scriptable, and it’s supported by the community with many useful
    plug-ins. Throughout this book, I’ll focus specifically on x64dbg, but many debuggers
    act, look, and feel very similar to it. Some alternatives to x64dbg are the much
    older OllyDbg, IDA Pro’s built-in debugger, or WinDbg.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: x64dbg工具（[*https://<wbr>x64dbg<wbr>.com*](https://x64dbg.com)）是一个功能强大、免费的开源调试器，适用于Windows环境。它具有高度的可定制性和脚本化功能，并且得到了社区的支持，有许多有用的插件。在本书中，我将特别关注x64dbg，但许多调试器的操作、外观和使用体验都与它非常相似。x64dbg的一些替代品包括更古老的OllyDbg、IDA
    Pro自带的调试器或WinDbg。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*There are technically two versions of x64dbg: x32dbg (for debugging 32-bit
    programs) and x64dbg (for 64-bit programs). They function exactly the same but
    focus on different architectures. I’ll refer to the program as x64dbg, as the
    debugger’s creator does, but just remember that in order to debug a 32-bit (x86)
    program, you must use the x32dbg version.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*x64dbg技术上有两个版本：x32dbg（用于调试32位程序）和x64dbg（用于64位程序）。它们的功能完全相同，但专注于不同的架构。我将把这个程序称为x64dbg，就像调试器的创建者一样，但请记住，为了调试32位（x86）程序，您必须使用x32dbg版本。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Starting a Debugging
    Session in x64dbg</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">在x64dbg中启动调试会话</samp>
- en: To load an executable file into x64dbg, choose the right version of x64dbg (the
    32-bit or 64-bit version) and select **File****Open**. (If you use the wrong
    version, you’ll get a helpful message at the bottom of the debugger window, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">"Use x32dbg to debug this file!"</samp>.)
    Alternatively, you can attach the debugger to a currently running malware process
    by selecting **File****Attach**. This approach has the downside that you might
    miss critical behaviors that occurred before you were able to attach to the process
    and begin debugging it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要将可执行文件加载到x64dbg中，请选择正确版本的x64dbg（32位或64位版本），然后选择**文件****打开**。（如果使用错误版本，调试器窗口底部会显示一条有帮助的消息，比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"请使用x32dbg调试此文件！"</samp>。）或者，您可以通过选择**文件****附加**，将调试器附加到当前正在运行的恶意软件进程。此方法的缺点是您可能会错过在附加进程并开始调试之前发生的关键行为。
- en: Once a program is loaded into a debugger, it’s running as a child process under
    the debugger. In most situations, the debugger calls the function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>,
    which permits it to attach to the active process and begin the debug session.
    We’ll return to this API call in [Chapter 10](chapter10.xhtml). For now, let’s
    take a look at the most important sections of the x64dbg user interface, shown
    in [Figure 3-12](chapter3.xhtml#fig3-12).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序加载到调试器中，它作为调试器下的子进程运行。在大多数情况下，调试器调用函数<samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>，允许它附加到活动进程并开始调试会话。我们将在[第
    10 章](chapter10.xhtml)中再次讨论这个 API 调用。目前，让我们来看看 x64dbg 用户界面中最重要的部分，如[图 3-12](chapter3.xhtml#fig3-12)所示。
- en: '![](../images/fig3-12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The x64dbg debugger</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-12：x64dbg 调试器</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Tab</samp>
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">CPU 标签</samp>
- en: The CPU pane at the top left of the x64dbg window lists the instructions the
    malware will execute, or has already executed, in sequential order. In this window,
    you can step through the code line by line or skip ahead to the more interesting
    parts. EIP (or RIP for x64 programs) marks the instruction that will be executed
    next, as shown in [Figure 3-13](chapter3.xhtml#fig3-13).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: x64dbg 窗口左上角的 CPU 面板列出了恶意软件将执行或已经执行的指令，按顺序排列。在这个窗口中，你可以逐行单步调试代码，或者跳过到更有趣的部分。EIP（对于
    x64 程序是 RIP）标记了下一个将被执行的指令，如[图 3-13](chapter3.xhtml#fig3-13)所示。
- en: '![](../images/fig3-13.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-13: The x64dbg CPU
    tab</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-13：x64dbg CPU 标签</samp>
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Registers Pane</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">CPU 寄存器面板</samp>'
- en: At the top right of the x64dbg window, you’ll see the CPU Registers pane (see
    [Figure 3-14](chapter3.xhtml#fig3-14)). This pane displays each register and flag
    and its currently stored value. This is helpful for keeping track of data and
    addresses stored in registers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x64dbg 窗口的右上方，你会看到 CPU 寄存器面板（参见[图 3-14](chapter3.xhtml#fig3-14)）。这个面板显示了每个寄存器和标志以及它们当前存储的值。这对于跟踪寄存器中存储的数据和地址非常有帮助。
- en: '![](../images/fig3-14.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-14.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-14: The x64dbg CPU
    Registers pane</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-14：x64dbg CPU 寄存器面板</samp>
- en: You might also have noticed the EFLAGS section of this pane, which displays
    the flag registers and their values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能注意到这个面板中的 EFLAGS 部分，显示了标志寄存器及其值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Arguments Pane</samp>
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">参数面板</samp>
- en: The Arguments pane (see [Figure 3-15](chapter3.xhtml#fig3-15)) is positioned
    in the middle right of the x64dbg window.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 参数面板（参见[图 3-15](chapter3.xhtml#fig3-15)）位于 x64dbg 窗口的右中部。
- en: '![](../images/fig3-15.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-15.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-15: The x64dbg Arguments
    pane</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-15：x64dbg 参数面板</samp>
- en: This pane displays the list of arguments on the stack that are passed to the
    current function call in the program. This information is invaluable for monitoring
    and altering arguments to functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板显示了程序中当前函数调用的堆栈上的参数列表。这些信息对于监控和修改传递给函数的参数非常宝贵。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Stack Pane</samp>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">堆栈面板</samp>'
- en: On the bottom right of the x64dbg window is the Stack pane. This pane displays
    the currently running thread’s stack memory (see [Figure 3-16](chapter3.xhtml#fig3-16)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x64dbg 窗口的右下角是堆栈面板。这个面板显示了当前正在运行的线程的堆栈内存（参见[图 3-16](chapter3.xhtml#fig3-16)）。
- en: '![](../images/fig3-16.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-16.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-16: The x64dbg Stack
    pane</samp>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-16：x64dbg 堆栈面板</samp>
- en: It is helpful to reference this stack pane when the malware calls a function
    (whether an internal function or a Windows API function). The parameters that
    the malware passes to the function being called will oftentimes be pushed to the
    stack prior to the function call, especially in 32-bit malware.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件调用一个函数（无论是内部函数还是 Windows API 函数）时，参考此堆栈面板是非常有帮助的。恶意软件传递给被调用函数的参数通常会在函数调用之前被推入堆栈，特别是在
    32 位恶意软件中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Dump Pane</samp>
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dump 窗格</samp>
- en: At the bottom left is the Dump pane, shown in [Figure 3-17](chapter3.xhtml#fig3-17).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 左下角是 Dump 窗格，如[图 3-17](chapter3.xhtml#fig3-17)所示。
- en: '![](../images/fig3-17.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-17.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-17: The x64dbg Dump
    pane</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-17: x64dbg Dump 窗格</samp>'
- en: This view allows you to inspect and monitor memory addresses (or *dumps*) dynamically.
    You can also set *watches* to have x64dbg notify you when a specific event occurs,
    such as when a specific register is modified.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图允许你动态检查和监控内存地址（或 *转储*）。你还可以设置 *监视*，当特定事件发生时，x64dbg 会通知你，例如当特定寄存器被修改时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Memory Map Tab</samp>
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Map 标签页</samp>
- en: Finally, the Memory Map tab can be accessed from the series of tabs toward the
    top of the x64dbg window. It’s very useful during dynamic code analysis, as it
    displays the program’s virtual memory layout and allows you to dig deeper into
    each memory region (see [Figure 3-18](chapter3.xhtml#fig3-18)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Memory Map 标签页可以通过 x64dbg 窗口顶部的一系列标签访问。在动态代码分析过程中，它非常有用，因为它显示了程序的虚拟内存布局，并允许你深入挖掘每个内存区域（参见[图
    3-18](chapter3.xhtml#fig3-18)）。
- en: '![](../images/fig3-18.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-18.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-18: The x64dbg Memory
    Map tab</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-18: x64dbg Memory Map 标签页</samp>'
- en: One of the most important uses of the Memory Map pane is hunting for executable
    code in memory during the malware unpacking. I’ll cover this in more detail, and
    memory in general, in [Chapter 17](chapter17.xhtml).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Memory Map 窗格的一个重要用途是在恶意软件解包过程中寻找可执行代码。我将在[第17章](chapter17.xhtml)中更详细地讲解这一点，以及内存的一般知识。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with x64dbg</samp>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用 x64dbg 分析</samp>
- en: Next, we’ll look at a typical debugging scenario for a malware sample to give
    you a high-level overview of what dynamic code analysis inside a debugger looks
    like. We’ll be analyzing the same file we used in “Analyzing with IDA” on [page
    53](chapter3.xhtml#pg_53).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个典型的恶意软件调试场景，给你一个高层次的概览，展示在调试器中进行动态代码分析的样子。我们将分析与在[第53页](chapter3.xhtml#pg_53)中“使用
    IDA 分析”时相同的文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disabling ASLR</samp>
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">禁用 ASLR</samp>
- en: As [Chapter 1](chapter1.xhtml) explained, address space layout randomization
    loads your malware’s executable and libraries into randomized memory locations.
    Although it’s an effective way to thwart attackers, it will also hamper your dynamic
    code analysis efforts, so you should disable it. To disable ASLR for this file,
    you have a few options, but you could use CFF Explorer ([*https://<wbr>ntcore<wbr>.com*](https://ntcore.com))
    here because it makes this process quick and easy. Simply load the malware sample
    into CFF Explorer, select the **Optional Header** category on the left menu, and
    click the **DllCharacteristics** box (see [Figure 3-19](chapter3.xhtml#fig3-19)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第1章](chapter1.xhtml)所解释的，地址空间布局随机化（ASLR）将恶意软件的可执行文件和库加载到随机的内存位置。虽然这是一种有效的防止攻击者的方法，但它也会妨碍你的动态代码分析工作，因此你应该禁用它。要禁用该文件的
    ASLR，你有几个选择，但你可以使用 CFF Explorer（[*https://<wbr>ntcore<wbr>.com*](https://ntcore.com)）来完成，因为它让这个过程快速而简单。只需将恶意软件样本加载到
    CFF Explorer 中，在左侧菜单中选择 **Optional Header** 类别，然后点击 **DllCharacteristics** 框（参见[图
    3-19](chapter3.xhtml#fig3-19)）。
- en: '![](../images/fig3-19.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-19.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-19: Setting a file’s
    DLL characteristics in CFF Explorer</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-19: 在 CFF Explorer 中设置文件的
    DLL 特性</samp>'
- en: You may recognize the Optional Header from [Chapter 1](chapter1.xhtml). One
    of the fields inside the Optional Header, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllCharacteristics</samp>
    field, contains a number of attributes for the executable file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从[第1章](chapter1.xhtml)中认识到可选头部分。可选头中的一个字段，<samp class="SANS_TheSansMonoCd_W5Regular_11">DllCharacteristics</samp>
    字段，包含了可执行文件的一些属性。
- en: Next, in the pop-up menu, uncheck the box next to **DLL Can Move**, as shown
    in [Figure 3-20](chapter3.xhtml#fig3-20).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在弹出菜单中，取消勾选**DLL Can Move**旁边的框，如[图 3-20](chapter3.xhtml#fig3-20)所示。
- en: '![](../images/fig3-20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-20.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-20: Disabling ASLR
    in CFF Explorer</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-20: 在 CFF Explorer 中禁用
    ASLR</samp>'
- en: Finally, click **OK** and remember to save the modified file by selecting **File****Save**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击**确定**，并记得通过选择**文件****保存**来保存修改过的文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Running the Code</samp>
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">运行代码</samp>
- en: Now load the file into x64dbg (more specifically, x32dbg, since this is a 32-bit
    file) by selecting **File****Open**. Once that’s done, you should see several
    options on the Debug menu for running and debugging the program (see [Figure 3-21](chapter3.xhtml#fig3-21)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过选择**文件****打开**将文件加载到x64dbg中（更具体地说是x32dbg，因为这是一个32位文件）。完成后，你应该在调试菜单中看到几个用于运行和调试程序的选项（参见[图
    3-21](chapter3.xhtml#fig3-21)）。
- en: '![](../images/fig3-21.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-21.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-21: The Debug menu
    in x64dbg</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-21：x64dbg中的调试菜单</samp>
- en: 'Let’s go through the options in order:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序浏览这些选项：
- en: '**Run**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行**'
- en: Runs the program until something stops the code, such as an exception, error,
    or breakpoint, or a process termination or exit.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序直到某个事件停止代码的执行，例如异常、错误、断点，或者进程终止或退出。
- en: '**Run Until Selection**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行直到选择**'
- en: Runs the program until it hits an address in the code that you have manually
    selected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，直到遇到你手动选择的代码地址。
- en: '**Step Into**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐步进入**'
- en: Allows you to step into a function about to be executed in order to manually
    debug and inspect it. This option is commonly known just as a *step* and will
    be discussed frequently throughout this book. Its keyboard shortcut is F7.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你进入即将执行的函数，以便手动调试和检查它。这个选项通常被称为*逐步执行*，并将在本书中频繁讨论。其快捷键是F7。
- en: '**Step Over**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳过**'
- en: Allows you to step over a function, skipping its execution entirely. This is
    a good way to save time and skip over code that you’re not interested in analyzing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你跳过一个函数，完全跳过其执行。这是节省时间并跳过你不感兴趣的代码的好方法。
- en: '**Execute Till Return**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行直到返回**'
- en: Executes the program until it hits the next return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>)
    instruction.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，直到遇到下一个返回（<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>）指令。
- en: '**Run to User Code**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行到用户代码**'
- en: Executes the program and breaks on the user code. This is one of the most useful
    debugging options, as we’ll discuss shortly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序并在用户代码处断点。这是最有用的调试选项之一，我们稍后会详细讨论。
- en: There are more debugging options in the Advanced menu. For example, the option
    Run (Swallow Exceptions) forces the debugger to essentially ignore exceptions.
    Since a large number of exceptions can be problematic while debugging (and malware
    can even purposefully generate exceptions to annoy you!), this can be a good option
    to save you some frustration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在“高级”菜单中有更多调试选项。例如，选项“Run (Swallow Exceptions)”强制调试器基本上忽略异常。由于在调试过程中大量异常可能会导致问题（而恶意软件甚至可能故意生成异常来烦扰你！），这个选项可以帮助你节省一些挫败感。
- en: Once the file has been loaded into the debugger, it must complete initialization
    tasks such as loading required libraries and other Windows operating system tasks.
    We’re not interested in this for our purposes and would instead like to skip ahead
    to the malware file’s entry point (the part of the code we want to analyze). To
    do this, select **Debug****Run to User Code** (see [Figure 3-22](chapter3.xhtml#fig3-22)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文件加载到调试器中后，必须完成初始化任务，如加载所需的库和其他Windows操作系统任务。对于我们的目的，这些步骤不需要关注，而是希望跳过到恶意软件文件的入口点（我们要分析的代码部分）。为此，选择**调试****运行到用户代码**（参见[图
    3-22](chapter3.xhtml#fig3-22)）。
- en: '![](../images/fig3-22.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-22.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-22: The Run to User
    Code entry point</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-22：运行到用户代码入口</samp>
- en: 'Now that the malware has been loaded into the debugger, we could simply start
    executing and stepping through code. This isn’t usually the most efficient method,
    however. It’s better to have an idea in mind of what code we’d like to inspect
    in the malware. In the previous section, we found something of interest in IDA:
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function.
    Let’s find and inspect this area of code.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在恶意软件已经加载到调试器中，我们可以直接开始执行并逐步调试代码。然而，这通常不是最有效的方法。最好提前明确我们希望在恶意软件中检查的代码部分。在前一节中，我们在IDA中发现了一个有趣的地方：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>函数。让我们找到并检查这段代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Software Breakpoints</samp>
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用软件断点</samp>
- en: You set software breakpoints by inserting special CPU instructions, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 3</samp> (in hexadecimal, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>), which is the most common
    breakpoint instruction, or <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 2D</samp>
    (in hexadecimal, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCD 0x2D</samp>).
    Keep in mind that creating software breakpoints directly modifies the running
    program’s code. Most benign programs don’t care about this and ignore it. However,
    some malware doesn’t want to be debugged and will attempt to detect and circumvent
    your breakpoints.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过插入特殊的CPU指令来设置软件断点，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">INT 3</samp>（以十六进制表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>），这是最常见的断点指令，或者<samp class="SANS_TheSansMonoCd_W5Regular_11">INT
    2D</samp>（以十六进制表示为<samp class="SANS_TheSansMonoCd_W5Regular_11">0xCD 0x2D</samp>）。请记住，创建软件断点会直接修改正在运行程序的代码。大多数良性程序对此不在意并忽略它。然而，一些恶意软件不希望被调试，它们会尝试检测并规避你的断点。
- en: 'To jump to the area of code that executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    function, you can simply set a breakpoint on this function call. The most efficient
    way to do this is by entering this instruction in the Command bar at the bottom
    of the x64dbg window:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳转到执行<samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>函数的代码区域，你可以简单地在该函数调用处设置一个断点。最有效的方法是，在x64dbg窗口底部的命令栏中输入以下指令：
- en: '[PRE1]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See [Figure 3-23](chapter3.xhtml#fig3-23).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 见[图 3-23](chapter3.xhtml#fig3-23)。
- en: '![](../images/fig3-23.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-23.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-23: Setting a breakpoint
    on a function call</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-23：在函数调用上设置断点</samp>
- en: Next, execute the sample by using the **Debug****Run** command (or pressing
    F9 on the keyboard). This will execute the malware and break on our target function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>, as shown
    in [Figure 3-24](chapter3.xhtml#fig3-24).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用**调试****运行**命令（或按键盘上的F9）执行该样本。这将执行恶意软件并在我们的目标函数<samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>处中断，如[图
    3-24](chapter3.xhtml#fig3-24)所示。
- en: '![](../images/fig3-24.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-24.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-24: Breakpoint hit!</samp>'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-24：命中断点！</samp>
- en: If you inspect the parameters in the Arguments pane, you should see a full URL
    on the stack (see [Figure 3-25](chapter3.xhtml#fig3-25)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查参数面板中的参数，你应该能够在堆栈上看到一个完整的URL（见[图 3-25](chapter3.xhtml#fig3-25)）。
- en: '![](../images/fig3-25.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-25.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-25: A URL on the stack</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-25：堆栈中的URL</samp>
- en: The internet service *iplogger.org* can be used to log and track IP addresses.
    The malware is likely using this service to track the hosts that are infected
    by this malware sample or to obtain the victim’s IP address.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务*iplogger.org*可以用来记录和跟踪IP地址。恶意软件可能正在使用这个服务来跟踪被该恶意软件样本感染的主机，或获取受害者的IP地址。
- en: Software breakpoints aren’t limited to function calls; you can set them on any
    address you choose. In the CPU pane of x64dbg, simply right-click on an address
    where you’d like to set a breakpoint and select **Breakpoint****Toggle** (or
    press F2). Once the instructions at this address are about to be executed by the
    CPU, the debugger will pause.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 软件断点不仅限于函数调用；你可以在任何你选择的地址上设置它们。在x64dbg的CPU面板中，只需右键点击你想设置断点的地址，并选择**断点****切换**（或按F2）。一旦CPU准备执行该地址的指令，调试器将暂停。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Hardware and Memory
    Breakpoints</samp>
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">设置硬件和内存断点</samp>
- en: As an alternative to software breakpoints, you can set *hardware breakpoints*,
    which are implemented by the CPU itself, or *memory breakpoints*, which are implemented
    using memory protections. Hardware breakpoints are set and stored in CPU registers,
    specifically DR0, DR1, DR2, and DR3\. When you set a hardware breakpoint, the
    address where the breakpoint was set is stored in one of these DR registers. Hardware
    breakpoints have the advantage that they do not directly modify code, so they
    are less invasive and thus a bit more difficult for malware to detect. Their primary
    disadvantage is that only four of them can be placed at a time due to the limited
    number of DR registers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件断点的替代方案，您可以设置*硬件断点*（由CPU本身实现）或*内存断点*（通过内存保护实现）。硬件断点设置并存储在CPU寄存器中，具体是DR0、DR1、DR2和DR3寄存器。当您设置硬件断点时，断点所在的地址会被存储在这些DR寄存器中的一个。硬件断点的优点是它们不会直接修改代码，因此侵入性较小，恶意软件较难检测到。它们的主要缺点是，由于DR寄存器数量有限，因此一次只能设置四个硬件断点。
- en: Memory breakpoints modify the protection attributes of a memory page, effectively
    causing an exception when that memory page is accessed. This is usually accomplished
    by modifying the memory page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    attribute. Memory breakpoints are particularly useful for monitoring addresses
    in memory. For example, if you identify an interesting string in memory at runtime
    (such as a URL or filename), setting a memory breakpoint on that string’s address
    can help you determine where and how the malware is using that string. One downside
    to memory breakpoints is that, since they directly modify memory page protections,
    they can interfere with a program’s operations. Specifically, memory breakpoints
    may cause a program to crash when it attempts to allocate new memory pages or
    modify existing pages. Once a memory breakpoint is triggered, the memory protections
    for the page are reset to the way they were before the breakpoint was set. So,
    if a malware sample modifies the protections of the page before or after the breakpoint
    is triggered, you may undo the malware’s changes or the malware may inadvertently
    (or purposely!) undo your breakpoint. Always be cautious when using memory breakpoints.
    Since hardware and memory breakpoints are often grouped together, from now on
    I’ll use the term *hardware breakpoint* to refer to both.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 内存断点通过修改内存页面的保护属性，实际上会在访问该内存页面时引发异常。这通常是通过修改内存页面的<samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>属性来实现的。内存断点对于监视内存中的地址特别有用。例如，如果您在运行时发现了一个有趣的字符串（例如URL或文件名），在该字符串的地址上设置内存断点可以帮助您确定恶意软件如何使用该字符串以及使用的位置和方式。内存断点的一个缺点是，由于它们直接修改内存页面的保护属性，可能会干扰程序的操作。具体而言，当程序尝试分配新的内存页面或修改现有页面时，内存断点可能导致程序崩溃。一旦内存断点被触发，该页面的内存保护将被重置为触发断点之前的状态。因此，如果恶意软件在断点触发之前或之后修改了页面的保护，您可能会撤销恶意软件的更改，或者恶意软件可能无意（或故意！）撤销您的断点。在使用内存断点时务必小心。由于硬件和内存断点通常是一起使用的，从现在起，我将使用*硬件断点*这个术语来同时指代两者。
- en: 'There are multiple ways to set a hardware breakpoint in a program being debugged:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正在调试的程序中的硬件断点有多种方法：
- en: To set a hardware breakpoint on an address in the CPU pane, right-click the
    address and then click **Breakpoint****Set Hardware on Execution**.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在CPU窗格中的某个地址设置硬件断点，右键单击该地址，然后点击**断点****执行时设置硬件断点**。
- en: In the Dump pane view, select a single byte for which to set a breakpoint, right-click
    it, and mouse over **Breakpoint** to select from several options.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“转储”窗格视图中，选择一个字节来设置断点，右键单击它，然后将鼠标悬停在**断点**上，选择多个选项中的一个。
- en: In the Memory Map tab view, highlight a memory region where you’d like to set
    a breakpoint. Right-click it and select **Memory Breakpoint**, then select the
    breakpoint option.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“内存映射”标签视图中，突出显示您想要设置断点的内存区域。右键单击该区域并选择**内存断点**，然后选择断点选项。
- en: '[Table 3-9](chapter3.xhtml#tab3-9) outlines various types of hardware and memory
    breakpoints and ways to implement them.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-9](chapter3.xhtml#tab3-9)概述了各种类型的硬件和内存断点及其实现方式。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    of Hardware Breakpoints in x64dbg</samp>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表3-9：</samp> <samp class="SANS_Futura_Std_Book_11">x64dbg中的硬件断点类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Breakpoint type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">断点类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Access</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on access. When this address is accessed in any way (read,
    written to, or executed), the breakpoint will be triggered.</samp> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">硬件，访问</samp> | <samp class="SANS_Futura_Std_Book_11">设置硬件断点以监视访问。当此地址以任何方式（读取、写入或执行）被访问时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Write</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on write. When this address is about to be written to, the
    breakpoint will be triggered.</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">硬件，写入</samp> | <samp class="SANS_Futura_Std_Book_11">设置硬件断点以监视写入。当此地址即将被写入时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Hardware, Execute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a hardware breakpoint on execute. When the instructions at this address are about
    to be executed, the breakpoint will be triggered.</samp> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">硬件，执行</samp> | <samp class="SANS_Futura_Std_Book_11">设置硬件断点以监视执行。当此地址上的指令即将被执行时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Access</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on access. When this memory page is accessed in any way (read,
    written to, or executed), the breakpoint will be triggered.</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">内存，访问</samp> | <samp class="SANS_Futura_Std_Book_11">设置内存断点以监视访问。当此内存页面以任何方式（读取、写入或执行）被访问时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Read</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on read. When this memory page is about to be read from, the
    breakpoint will be triggered.</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">内存，读取</samp> | <samp class="SANS_Futura_Std_Book_11">设置内存断点以监视读取。当此内存页面即将被读取时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Write</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on write. When this memory page is about to be written to,
    the breakpoint will be triggered.</samp> |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">内存，写入</samp> | <samp class="SANS_Futura_Std_Book_11">在写入时设置内存断点。当此内存页面即将被写入时，断点将被触发。</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Memory, Execute</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    a memory breakpoint on execute. When instructions in this memory page are about
    to be executed, the breakpoint will be triggered.</samp> |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">内存，执行</samp> | <samp class="SANS_Futura_Std_Book_11">设置内存断点以监视执行。当此内存页面中的指令即将被执行时，断点将被触发。</samp>
    |'
- en: 'It’s important to note that hardware breakpoints can be set on a byte, a word,
    or a dword. Setting a hardware breakpoint on a specific byte, for example, will
    trigger an exception when that specific byte is accessed. For words and dwords,
    the exception will trigger if the entire word (2 bytes) or dword (4 bytes) is
    accessed. Hardware breakpoints can also be set in two modes: singleshoot and restore.
    The *singleshoot breakpoint*, once triggered, is removed and will not trigger
    again. The *restore breakpoint* will restore itself once triggered, creating a
    persistent breakpoint that will trigger again if the specific address is accessed
    again.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，硬件断点可以设置在字节、字或双字上。例如，设置在特定字节上的硬件断点，当访问该字节时会触发异常。对于字和双字，当整个字（2字节）或双字（4字节）被访问时，异常将触发。硬件断点还可以设置为两种模式：单次触发和恢复。*单次触发断点*在触发后会被移除，不会再次触发。*恢复断点*会在触发后恢复自己，创建一个持久的断点，如果再次访问特定地址时会再次触发。
- en: For malware analysis specifically, hardware breakpoints are most often used
    to counter common debugger and breakpoint detection techniques, as well as during
    manual unpacking of a sample. We’ll discuss hardware breakpoints specifically
    in this context in [Chapters 10](chapter10.xhtml) and [17](chapter17.xhtml).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在恶意软件分析中，硬件断点通常用于对抗常见的调试器和断点检测技术，以及在手动解包样本时。我们将在[第10章](chapter10.xhtml)和[第17章](chapter17.xhtml)中特别讨论硬件断点在这一上下文中的应用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Patching and Modifying
    Code</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">修补和修改代码</samp>
- en: '*Patching* means modifying or removing instructions from a program. To do this
    in x64dbg, right-click the address of the code you need to modify and select **Binary**,
    as shown in [Figure 3-26](chapter3.xhtml#fig3-26).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*修补*意味着修改或移除程序中的指令。要在x64dbg中执行此操作，右键点击你需要修改的代码地址并选择**二进制**，如[图3-26](chapter3.xhtml#fig3-26)所示。'
- en: '![](../images/fig3-26.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-26.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-26: Editing and patching
    code in x64dbg</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-26：在x64dbg中编辑和修补代码</samp>
- en: The Edit option allows you to modify the code at this address. The Fill with
    NOPs option is a good way to quickly clear code; it fills this memory address
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions, essentially
    telling the program to skip over this section of code. To patch out the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>
    in the current malware sample, for example, you’d highlight the line that contains
    the function call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    InternetOpenUrlW</samp>) and then fill it with NOPs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑选项允许你修改该地址的代码。用NOP填充选项是一个快速清除代码的好方法；它将该内存地址填充为<samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令，实质上告诉程序跳过这部分代码。举个例子，要在当前恶意软件样本中修补对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>的调用，你需要高亮显示包含函数调用指令的行（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">call InternetOpenUrlW</samp>），然后用NOP填充它。
- en: In this scenario, there’s likely no point in patching out the call instruction
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> (unless
    you want to prohibit the malware from connecting to the internet). In general,
    however, patching code in a running malware sample can be a very powerful way
    to bypass anti-analysis and evasion techniques and control a malware’s flow of
    execution.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常没有必要修补对<samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>的调用指令（除非你想禁止恶意软件连接到互联网）。然而，通常来说，在运行中的恶意软件样本中修补代码是一种非常强大的绕过反分析和规避技术的方式，并且可以控制恶意软件的执行流程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tracing API Calls
    with API Monitor</samp>
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">通过API Monitor跟踪API调用</samp>
- en: API Monitor ([*http://<wbr>www<wbr>.rohitab<wbr>.com<wbr>/downloads*](http://www.rohitab.com/downloads))
    is a great debugging tool to add to your toolbox, as it allows you to trace and
    monitor malware API function calls. It also enables you to set breakpoints on
    specific functions, so it acts as a rudimentary debugger as well.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: API Monitor（[*http://<wbr>www<wbr>.rohitab<wbr>.com<wbr>/downloads*](http://www.rohitab.com/downloads)）是一个很好的调试工具，可以添加到你的工具箱中，因为它允许你跟踪和监控恶意软件的API函数调用。它还允许你在特定的函数上设置断点，因此它也充当一个基本的调试器。
- en: You can select the APIs and functions that you’d like to trace in the API Filter
    window (at the top left of the API Monitor window), as shown in [Figure 3-27](chapter3.xhtml#fig3-27).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在API Monitor窗口左上角的API过滤器窗口中选择你想要跟踪的API和函数，如[图3-27](chapter3.xhtml#fig3-27)所示。
- en: '![](../images/fig3-27.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-27.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-27: The API Filter
    menu in API Monitor</samp>'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-27：API Monitor中的API过滤器菜单</samp>
- en: Here I’ve selected all of the internet- and network-related functions under
    the *Wininet.dll* library.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择了*Wininet.dll*库下的所有与互联网和网络相关的函数。
- en: To monitor a new process, click the **Monitor New Process** button in the middle
    of the API Monitor window and then select the malware executable you want to analyze.
    The default options are good enough, so click **OK** (see [Figure 3-28](chapter3.xhtml#fig3-28)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要监控一个新的进程，请点击API Monitor窗口中间的**监控新进程**按钮，然后选择你想分析的恶意软件可执行文件。默认选项已经足够好，因此点击**确定**（参见[图3-28](chapter3.xhtml#fig3-28)）。
- en: '![](../images/fig3-28.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-28.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-28: Monitoring a new
    process in API Monitor</samp>'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-28：在API Monitor中监控新进程</samp>
- en: After the malware executes and runs for a few minutes, some API calls will begin
    to populate the Summary window, as you can see in [Figure 3-29](chapter3.xhtml#fig3-29).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件执行并运行几分钟后，一些API调用将开始出现在摘要窗口中，正如你在[图3-29](chapter3.xhtml#fig3-29)中看到的那样。
- en: '![](../images/fig3-29.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-29.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-29: A list of API
    calls in API Monitor</samp>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-29：API Monitor中的API调用列表</samp>
- en: You may recognize some of these calls from our previous analysis in x64dbg.
    The power of API Monitor is that it lets you quickly see the function calls you’re
    interested in as well as their arguments and return values. This is immensely
    valuable for getting a quick read on a malware sample’s capabilities or for monitoring
    and tracing suspect behaviors.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从我们之前在x64dbg中的分析中认出一些这些调用。API Monitor的强大之处在于，它可以让你快速查看你感兴趣的函数调用，以及它们的参数和返回值。这对于快速了解恶意软件样本的功能，或者监视和追踪可疑行为极为有价值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you took a crash course in assembly code and explored the static
    and dynamic code analysis processes, including the role of disassemblers and debuggers,
    at a high level. In a typical scenario, you’d use static code analysis to identify
    and analyze code worth investigating further, and then you’d follow up with dynamic
    code analysis in a debugger. When you’re reverse engineering malware, it can be
    helpful to switch between static and dynamic code analysis often to fully understand
    the code you’re investigating.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了汇编代码的基础知识，并高层次地探索了静态和动态代码分析过程，包括反汇编器和调试器的作用。在典型场景中，你会使用静态代码分析来识别并分析值得进一步调查的代码，然后使用调试器进行动态代码分析。在逆向工程恶意软件时，频繁切换静态和动态代码分析有助于全面理解你正在调查的代码。
- en: This chapter concludes the foundational topics of malware analysis. In the next
    few chapters, we’ll start to dig into how evasive malware is able to detect virtual
    machines, sandboxes, and the tools analysts use to investigate malware internals.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了恶意软件分析的基础主题。在接下来的几章中，我们将开始深入研究如何规避的恶意软件能够检测虚拟机、沙盒以及分析师用来调查恶意软件内部的工具。
