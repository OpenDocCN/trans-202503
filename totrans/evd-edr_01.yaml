- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EDR-CHITECTURE</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Virtually every adversary, whether they’re a malicious actor or part of a commercial
    red team, will sometimes run into defensive products that compromise their operations.
    Of these defensive products, endpoint detection and response (EDR) presents the
    largest risk to the post-exploitation phase of an attack. Generally speaking,
    *EDRs* are applications installed on a target’s workstations or servers that are
    designed to collect data about the security of the environment, called *telemetry*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discuss the components of EDRs, their methods of detecting
    malicious activity on a system, and their typical designs. We also provide an
    overview of the difficulties that EDRs can cause attackers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Components of an EDR</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Later chapters will explore the nuts and bolts of many EDR sensor components,
    how they work, and how attackers might evade them. First, though, we’ll consider
    the EDR as a whole and define some terms that you’ll see frequently throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Agent</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EDR *agent* is an application that controls and consumes data from sensor
    components, performs some basic analysis to determine whether a given activity
    or series of events aligns with attacker behavior, and forwards the telemetry
    to the main server, which further analyzes events from all agents deployed in
    an environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the agent deems some activity to be worthy of its attention, it may take
    any of the following actions: *log* that malicious activity in the form of an
    alert sent to a central logging system, such as the EDR’s dashboard or a security
    incident and event management (SIEM) solution; *block* the malicious operation’s
    execution by returning values indicating failure to the program that is performing
    the action; or *deceive* the attacker by returning to the caller invalid values,
    such as incorrect memory addresses or modified access masks, causing the offensive
    tooling to believe that the operation completed successfully even though subsequent
    operations will fail.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Telemetry</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every sensor in an EDR serves a common purpose: the collection of telemetry.
    Roughly defined, *telemetry* is the raw data generated by a sensor component or
    the host itself, and defenders can analyze it to determine whether malicious activity
    has occurred. Every action on the system, from opening a file to creating a new
    process, generates some form of telemetry. This information becomes a datapoint
    in the security product’s internal alerting logic.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](#fig1-1) compares telemetry to the data collected by a radar system.
    Radars use electromagnetic waves to detect the presence, heading, and velocity
    of objects within some range.'
  prefs: []
  type: TYPE_NORMAL
- en: When a radio wave bounces off an object and returns to the radar system, it
    creates a datapoint indicating that there is something there. Using these datapoints,
    the radar system’s processor can determine things such as the object’s speed,
    location, and altitude and then handle each case differently. For instance, the
    system might need to respond to an object flying at a slow speed at lower altitudes
    differently from one flying at a fast speed at higher altitudes.
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to how an EDR handles the telemetry collected by its sensors.
    On its own, information about how a process was created or a file was accessed
    rarely provides enough context to make an informed decision regarding actions
    to be taken. They’re just blips on the radar display. Moreover, a process detected
    by an EDR can terminate at any point in time. Therefore, it is important for the
    telemetry feeding into the EDR to be as complete as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Visualizing security
    events as radar blips</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The EDR then passes the data to its detection logic. This detection logic takes
    all available telemetry and uses some internal method, such as environmental heuristics
    or static signature libraries, to attempt to ascertain whether the activity was
    benign or malicious and whether the activity meets its threshold for logging or
    prevention.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sensors</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If telemetry represents the blips on the radar, then *sensors* are the transmitter,
    duplexer, and receiver: the components responsible for detecting objects and turning
    them into blips. Whereas radar systems constantly ping objects to track their
    movements, EDR sensors work a bit more passively by intercepting data flowing
    through an internal process, extracting information, and forwarding it to the
    central agent.'
  prefs: []
  type: TYPE_NORMAL
- en: Because these sensors often need to sit inline of some system process, they
    must also work incredibly fast. Imagine that a sensor monitoring registry queries
    took 5 ms to perform its work before the registry operation was allowed to continue.
    That doesn’t sound like much of a problem until you consider that thousands of
    registry queries can occur per second on some systems. A 5 ms processing penalty
    applied to 1,000 events would introduce a five-second delay to system operations.
    Most users would find this unacceptable, driving customers away from using the
    EDR altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Although Windows has numerous telemetry sources available, EDRs typically focus
    on only a select few. This is because certain sources may lack data quality or
    quantity, may not be relevant to host security, or may not be easily accessible.
    Some sensors are built into the operating system, such as the native event log.
    EDRs may also introduce their own sensor components to the system, such as drivers,
    function-hooking DLLs, and minifilters, which we’ll discuss in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Those of us on the offensive side of things mostly care about preventing, limiting,
    or normalizing (as in blending in with) the flow of telemetry collected by the
    sensor. The goal of this tactic is to reduce the number of datapoints that the
    product could use to create high-fidelity alerts or prevent our operation from
    executing. Essentially, we’re trying to generate a false negative. By understanding
    each of an EDR’s sensor components and the telemetry it can collect, we can make
    informed decisions about the tradecraft to use in certain situations and develop
    robust evasion strategies backed by data rather than anecdotal evidence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detections</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply put, *detections* are the logic that correlates discrete pieces of telemetry
    with some behavior performed on the system. A detection can check for a singular
    condition (for example, the presence of a file whose hash matches that of known
    malware) or a complex sequence of events coming from many different sources (for
    example, that a child process of *chrome.exe* was spawned and then communicated
    over TCP port 88 with the domain controller).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a detection engineer writes these rules based on the available sensors.
    Some detection engineers work for the EDR vendor and so must carefully consider
    scale, as the detection will likely affect a substantial number of organizations.
    On the other hand, detection engineers working within an organization can build
    rules that extend the EDR’s capabilities beyond those that the vendor provides
    to tailor their detection to the needs of their environment.
  prefs: []
  type: TYPE_NORMAL
- en: An EDR’s detection logic usually exists in the agent and its subordinate sensors
    or in the backend collection system (the system to which all agents in the enterprise
    report). Sometimes it is found in some combination of the two. There are pros
    and cons to each approach. A detection implemented in the agent or its sensors
    may allow the EDR to take immediate preventive action but won’t provide it with
    the ability to analyze a complex situation. By contrast, a detection implemented
    at the backend collection system can support a huge set of detection rules but
    introduces delays to any preventive action taken.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Challenges of EDR Evasion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many adversaries rely on bypasses described anecdotally or in public proofs
    of concept to avoid detection on a target’s systems. This approach can be problematic
    for a number of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, those public bypasses only work if an EDR’s capabilities stay the same
    over time and across different organizations. This isn’t a huge issue for internal
    red teams, which likely encounter the same product deployed across their entire
    environment. For consultants and malicious threat actors, however, the evolution
    of EDR products poses a significant headache, as each environment’s software has
    its own configuration, heuristics, and alert logic. For example, an EDR might
    not scrutinize the execution of PsExec, a Windows remote-administration tool,
    in one organization if its use there is commonplace. But another organization
    might rarely use the tool, so its execution might indicate malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: Second, these public evasion tools, blog posts, and papers often use the term
    *bypass* loosely. In many cases, their authors haven’t determined whether the
    EDR merely allowed some action to occur or didn’t detect it at all. Sometimes,
    rather than automatically blocking an action, an EDR triggers alerts that require
    human interaction, introducing a delay to the response. (Imagine that the alert
    fired at 3 AM on a Saturday, allowing the attacker to continue moving through
    the environment.) Most attackers hope to completely evade detection, as a mature
    security operations center (SOC) can efficiently hunt down the source of any malicious
    activity once an EDR detects it. This can be catastrophic to an attacker’s mission.
  prefs: []
  type: TYPE_NORMAL
- en: Third, researchers who disclose new techniques typically don’t name the products
    they tested, for a number of reasons. For instance, they might have signed a nondisclosure
    agreement with a client or worry that the affected vendor will threaten legal
    action. Consequentially, those researchers may think that some technique can bypass
    all EDRs instead of only a certain product and configuration. For example, a technique
    might evade user-mode function hooking in one product because the product happens
    not to monitor the targeted function, but another product might implement a hook
    that would detect the malicious API call.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, researchers might not clarify which component of the EDR their technique
    evades. Modern EDRs are complex pieces of software with many sensor components,
    each of which can be bypassed in its own way. For example, an EDR might track
    suspicious parent–child process relationships by obtaining data from a kernel-mode
    driver, Event Tracing for Windows (ETW), function hooks, and a number of other
    sources. If an evasion technique targets an EDR agent that relies on ETW to collect
    its data, it may not work against a product that leverages its driver for the
    same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: To effectively evade EDR, then, adversaries need a detailed understanding of
    how these tools work. The rest of this chapter dives into their components and
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Malicious Activity</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build successful detections, an engineer must understand more than the latest
    attacker tactics; they must also know how a business operates and what an attacker’s
    objectives might be. Then they must take the distinct and potentially unrelated
    datapoints gleaned from an EDR’s sensors and identify clusters of activity that
    could indicate something malicious happening on the system. This is much easier
    said than done.
  prefs: []
  type: TYPE_NORMAL
- en: For example, does the creation of a new service indicate that an adversary has
    installed malware persistently on the system? Potentially, but it’s more likely
    that the user installed new software for legitimate reasons. What if the service
    was installed at 3 AM? Suspicious, but maybe the user is burning the midnight
    oil on a big project. How about if *rundll32.exe*, the native Windows application
    for executing DLLs, is the process responsible for installing the service? Your
    gut reaction may be to say, “Aha! We’ve got you now!” Still, the functionality
    could be part of a legitimate but poorly implemented installer. Deriving intent
    from actions can be extremely difficult.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Context</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to make informed decisions is to consider the context of the actions
    in question. Compare them with user and environmental norms, known adversary tradecraft
    and artifacts, and other actions that the affected user performed in some timeframe.
    [Table 1-1](#tab1-1) provides an example of how this may work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    a Series of Events on the System</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Event</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Context</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Determination</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">spawns under the context</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CONTOSO\jdoe.</samp>
    | <samp class="SANS_Futura_Std_Book_11">The user</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp>
    <samp class="SANS_Futura_Std_Book_11">frequently travels inter</samp><samp class="SANS_Futura_Std_Book_11">nationally
    and works off-hours to meet with business partners in other regions.</samp> |
    <samp class="SANS_Futura_Std_Book_11">Benign</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2:55</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">loads an unsigned DLL,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">usp10.dll</samp><samp
    class="SANS_Futura_Std_Book_11">, from the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">%APPDATA%</samp>
    <samp class="SANS_Futura_Std_Book_11">directory.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application isn’t known to load unsigned code in its default configuration,
    but users at the organization are permitted to install third-party plug-ins that
    may change the application’s behavior at startup.</samp> | <samp class="SANS_Futura_Std_Book_11">Mildly
    suspicious</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2:56</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">makes a connection to the internet over
    TCP port 443.</samp> | <samp class="SANS_Futura_Std_Book_11">This chat application’s
    server is hosted by a cloud provider, so it regularly polls the server for information.</samp>
    | <samp class="SANS_Futura_Std_Book_11">Benign</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2:59</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">queries the registry value</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">HKLM:\System\CurrentControlSet\Control\LSA\LsaCfgFlags</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application regularly pulls system- and application-configuration information
    from the registry but isn’t known to access registry keys associated with Credential
    Guard.</samp> | <samp class="SANS_Futura_Std_Book_11">Highly suspicious</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> <samp class="SANS_Futura_Std_Book_SC_11">AM</samp><samp
    class="SANS_Futura_Std_Book_11">: The application</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chatapp.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">opens a handle to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lsass.exe</samp>
    <samp class="SANS_Futura_Std_Book_11">with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS
    _VM_READ</samp> <samp class="SANS_Futura_Std_Book_11">access.</samp> | <samp class="SANS_Futura_Std_Book_11">This
    chat application doesn’t access the address spaces of other processes, but the
    user</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">JDOE</samp> <samp
    class="SANS_Futura_Std_Book_11">does have the required permissions.</samp> | <samp
    class="SANS_Futura_Std_Book_11">Malicious</samp> |'
  prefs: []
  type: TYPE_TB
- en: This contrived example shows the ambiguity involved in determining intent based
    on the actions taken on a system. Remember that the overwhelming majority of activities
    on a system are benign, assuming that something horrible hasn’t happened. Engineers
    must determine how sensitive an EDR’s detections should be (in other words, how
    much they should skew toward saying something is malicious) based on how many
    false negatives the customer can tolerate.
  prefs: []
  type: TYPE_NORMAL
- en: One way that a product can meet its customers’ needs is by using a combination
    of so-called brittle and robust detections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Applying Brittle
    vs. Robust Detections</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Brittle* detections are those designed to detect a specific artifact, such
    as a simple string or hash-based signature commonly associated with known malware.
    *Robust* detections aim to detect behaviors and could be backed by machine-learning
    models trained for the environment. Both detection types have a place in modern
    scanning engines, as they help balance false positives and false negatives.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a detection built around the hash of a malicious file will very
    effectively detect a specific version of that one file, but any slight variation
    to the file will change its hash, causing the detection rule to fail. This is
    why we call such rules “brittle.” They are extremely specific, often targeting
    a single artifact. This means that the likelihood of a false positive is almost
    nonexistent while the likelihood of a false negative is very high.
  prefs: []
  type: TYPE_NORMAL
- en: Despite their flaws, these detections offer distinct benefits to security teams.
    They are easy to develop and maintain, so engineers can change them rapidly as
    the organization’s needs evolve. They can also effectively detect some common
    attacks. For example, a single rule for detecting an unmodified version of the
    exploitation tool Mimikatz brings tremendous value, as its false-positive rate
    is nearly zero and the likelihood of the tool being used maliciously is high.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, the detection engineer must carefully consider what data to use when
    creating their brittle detections. If an attacker can trivially modify the indicator,
    the detection becomes much easier to evade. For example, say that a detection
    checks for the filename *mimikatz.exe*; an adversary could simply change the filename
    to *mimidogz.exe* and bypass the detection logic. For this reason, the best brittle
    detections target attributes that are either immutable or at least difficult to
    modify.
  prefs: []
  type: TYPE_NORMAL
- en: On the other end of the spectrum, a robust ruleset backed by a machine-learning
    model might flag the modified file as suspicious because it is unique to the environment
    or contains some attribute that the classification algorithm weighted highly.
    Most robust detections are simply rules that more broadly try to target a technique.
    These types of detections exchange their specificity for the ability to detect
    an attack more generally, reducing the likelihood of false negatives by increasing
    the likelihood of false positives.
  prefs: []
  type: TYPE_NORMAL
- en: While the industry tends to favor robust detections, they have their own drawbacks.
    Compared to brittle signatures, these rules can be much harder to develop due
    to their complexity. Additionally, the detection engineer must consider an organization’s
    false-positive tolerance. If their detection has a very low false-negative rate
    but a high false-positive rate, the EDR will behave like the boy who cried wolf.
    If they go too far in their attempts to reduce false positives, they may also
    increase the rate of false negatives, allowing an attack to go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, most EDRs employ a hybrid approach, using brittle signatures
    to catch obvious threats and robust detections to detect attacker techniques more
    generally.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Elastic
    Detection Rules</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the only EDR vendors to publicly release its detection rules is Elastic,
    which publishes its SIEM rules in a GitHub repository. Let’s take a peek behind
    the curtain, as these rules contain great examples of both brittle and robust
    detections.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider Elastic’s rule for detecting Kerberoasting attempts that
    use Bifrost, a macOS tool for interacting with Kerberos, shown in [Listing 1-1](#list1-1).
    *Kerberoasting* is the technique of retrieving Kerberos tickets and cracking them
    to uncover service account credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: Elastic’s rule for detecting Kerberoasting based on command line
    arguments'
  prefs: []
  type: TYPE_NORMAL
- en: This rule checks for the presence of certain command line arguments that Bifrost
    supports. An attacker could trivially bypass this detection by renaming the arguments
    in the source code (for example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">-action</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-dothis</samp>) and then recompiling
    the tool. Additionally, a false positive could occur if an unrelated tool supports
    the arguments listed in the rule.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, the rule might seem like a bad detection. But remember that
    not all adversaries operate at the same level. Many threat groups continue to
    use off-the-shelf tooling. This detection serves to catch those who are using
    the basic version of Bifrost and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the rule’s narrow focus, Elastic should supplement it with a more
    robust detection that covers these gaps. Thankfully, the vendor published a complementary
    rule, shown in [Listing 1-2](#list1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: Elastic’s rule for detecting atypical processes communicating
    over TCP port 88'
  prefs: []
  type: TYPE_NORMAL
- en: This rule targets atypical processes that make outbound connections to TCP port
    88, the standard Kerberos port. While this rule contains some gaps to address
    false positives, it’s generally more robust than the brittle detection for Bifrost.
    Even if the adversary were to rename parameters and recompile the tool, the network
    behavior inherent to Kerberoasting would cause this rule to fire.
  prefs: []
  type: TYPE_NORMAL
- en: To evade detection, the adversary could take advantage of the exemption list
    included at the bottom of the rule, perhaps changing Bifrost’s name to match one
    of those files, such as *opera.exe*. If the adversary also modified the tool’s
    command line arguments, they would evade both the brittle and robust detections
    covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Most EDR agents strive for a balance between brittle and robust detections but
    do so in an opaque way, so an organization might find it very difficult to ensure
    coverage, especially in agents that don’t support the introduction of custom rules.
    For this reason, a team’s detection engineers should test and validate detections
    using tooling such as Red Canary’s Atomic Test Harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Agent Design</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As attackers, we should pay close attention to the EDR agent deployed on the
    endpoints we’re targeting because this is the component responsible for detecting
    the activities we’ll use to complete our operation. In this section, we’ll review
    the parts of an agent and the various design choices they might make.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Basic</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Agents are composed of distinct parts, each of which has its own objective
    and type of telemetry it is able to collect. Most commonly, agents include the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The static scanner**   An application, or component of the agent itself,
    that performs static analysis of images, such as Portable Executable (PE) files
    or arbitrary ranges of virtual memory, to determine whether the content is malicious.
    Static scanners commonly form the backbone of antivirus services.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The hooking DLL**   A DLL that is responsible for intercepting calls to specific
    application programming interface (API) functions. [Chapter 2](chapter2.xhtml)
    covers function hooking in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The kernel driver**   A kernel-mode driver responsible for injecting the
    hooking DLL into target processes and collecting kernel-specific telemetry. [Chapters
    3](chapter3.xhtml) through [7](chapter7.xhtml) cover its various detection techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The agent service**   An application responsible for aggregating telemetry
    created by the preceding two components. It sometimes correlates data or generates
    alerts. Then it relays the collected data to a centralized EDR server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](#fig1-2) shows the most basic agent architecture that commercial
    products use today.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The basic agent
    architecture</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see here, this basic design doesn’t have many sources of telemetry.
    Its three sensors (a scanner, a driver, and a function-hooking DLL) provide the
    agent with data about process-creation events, the invocation of functions deemed
    sensitive (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread</samp>),
    the signatures of files, and potentially the virtual memory belonging to a process.
    This may be sufficient coverage for some use cases, but most commercial EDR products
    today go far beyond these capabilities. For instance, this basic EDR would be
    incapable of detecting files being created, deleted, or encrypted on the host.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Intermediate</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While a basic agent can collect a large amount of valuable data with which to
    create detections, this data may not form a complete picture of the activities
    performed on the host. Usually, the endpoint security products deployed in enterprise
    environments today have substantially expanded their capabilities to collect additional
    telemetry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the agents that attackers encounter fall into the intermediate level
    of sophistication. These agents not only introduce new sensors but also use telemetry
    sources native to the operating system. Additions commonly made at this level
    may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network filter drivers**   Drivers that perform network traffic analysis
    to identify indicators of malicious activity, such as beaconing. These will be
    covered in [Chapter 7](chapter7.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem filter drivers**   A special type of driver that can monitor for
    operations on the host filesystem. They are discussed extensively in [Chapter
    6](chapter6.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**ETW consumers**   Components of the agent that can subscribe to events created
    by the host operating system or third-party applications. ETW is covered in [Chapter
    8](chapter8.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early Launch Antimalware (ELAM) components**   Features that provide a Microsoft-supported
    mechanism for loading an antimalware driver before other boot-start services to
    control the initialization of the other boot drivers. These components also grant
    the ability to receive Secure ETW events, a special type of event generated from
    a group of protected event providers. These functions of ELAM drivers are covered
    in [Chapter 11](chapter11.xhtml) and [Chapter 12](chapter12.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: While modern EDRs may not implement all of these components, you’ll commonly
    see the ELAM driver deployed alongside the primary kernel driver. [Figure 1-3](#fig1-3)
    illustrates what a more modern agent architecture may look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: The intermediate
    agent architecture</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This design builds upon the basic architecture and adds many new sensors from
    which telemetry can be collected. For instance, this EDR can now monitor filesystem
    events such as file creation, consume from ETW providers that offer data the agent
    wouldn’t otherwise be able to collect, and observe network communications on the
    host through its filter driver, potentially allowing the agent to detect command-and-control
    beaconing activity. It also adds a layer of redundancy so that if one sensor fails,
    another might be able to pick up the slack.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Advanced</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some products implement more advanced features to monitor specific areas of
    the system in which they’re interested. Here are two examples of such features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypervisors**   Provide a method for the interception of system calls, the
    virtualization of certain system components, and the sandboxing of code execution.
    These also provide the agent with a way to monitor transitions in execution between
    the guest and host. They’re commonly leveraged as a component of anti-ransomware
    and anti-exploit functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adversary deception**   Provides false data to the adversary instead of preventing
    the malicious code’s execution. This may cause the adversary to focus on debugging
    their tooling without realizing that the data in use has been tampered with.'
  prefs: []
  type: TYPE_NORMAL
- en: Because these are typically product-specific implementations and are not commonplace
    at the time of this writing, we won’t discuss these advanced features in significant
    detail. Additionally, many of the components in this category align more closely
    with prevention strategies rather than detection, pushing them slightly outside
    the scope of this book. As time goes on, however, some advanced features may become
    more common, and new ones will likely be invented.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Types of Bypasses</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In his 2021 blog post “Evadere Classifications,” Jonathan Johnson groups evasions
    based on the location in the detection pipeline where they occur. Using the Funnel
    of Fidelity, a concept put forth by Jared Atkinson to describe phases of the detection
    and response pipeline, Johnson defines areas where an evasion can occur. The following
    are the ones we’ll discuss in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration bypass**   Occurs when there is a telemetry source on the endpoint
    that could identify the malicious activity, but the sensor failed to collect data
    from it, leading to a gap in coverage. For example, even if the sensor is able
    to collect events from a specific ETW provider related to Kerberos authentication
    activity, it might not be configured to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perceptual bypass**   Occurs when the sensor or agent lacks the capability
    to collect the relevant telemetry. For example, the agent might not monitor filesystem
    interactions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical bypass**   Occurs when the adversary abuses a gap in a detection’s
    logic. For example, a detection might contain a known gap that no other detection
    covers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classification bypass**   Occurs when the sensor or agent is unable to identify
    enough datapoints to classify the attacker’s behavior as malicious, despite observing
    it. For example, the attacker’s traffic might blend into normal network traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration bypasses are one of the most common techniques. Sometimes they
    are even used unknowingly, as most mature EDR agents have the ability to collect
    certain telemetry but fail to do so for one reason or another, such as to reduce
    event volume. Perceptual bypasses are generally the most valuable because if the
    data doesn’t exist and no compensating components cover the gap, the EDR has no
    chance of detecting the attacker’s activities.
  prefs: []
  type: TYPE_NORMAL
- en: Logical bypasses are the trickiest to pull off because they generally require
    knowledge of the detection’s underlying logic. Lastly, classification bypasses
    require a bit of forethought and system profiling, but red teams use them frequently
    (for example, by beaconing over a slow HTTPS channel to a reputable site for their
    command-and-control activities). When executed well, classification bypasses can
    approach the efficacy of a perceptual bypass for less work than that required
    for a logical bypass.
  prefs: []
  type: TYPE_NORMAL
- en: On the defense side, these classifications let us discuss blind spots in our
    detection strategies with greater specificity. For instance, if we require that
    events be forwarded from the endpoint agent to the central collection server for
    analysis, our detection is inherently vulnerable to a configuration evasion, as
    an attacker could potentially change the agent’s configuration in such a way that
    the agent–server communication channel is interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Perceptual bypasses are important to understand but are often the hardest to
    find. If our EDR simply lacks the ability to collect the required data, we have
    no choice but to find another way to build our detection. Logical bypasses happen
    due to decisions made when building the detection rules. Because SOCs aren’t staffed
    with an infinite number of analysts who can review alerts, engineers always seek
    to reduce false positives. But for every exemption they make in a rule, they inherit
    the potential for a logical bypass. Consider Elastic’s robust Kerberoasting rule
    described earlier and how an adversary could simply change the name of their tool
    to evade it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, classification evasions can be the trickiest to protect against. To
    do so, engineers must continue to tune the EDR’s detection threshold until it’s
    just right. Take command-and-control beaconing as an example. Say we build our
    detection strategy by assuming that an attacker will connect to a site with an
    uncategorized reputation at a rate greater than one request per minute. In what
    way could our adversary fly under the radar? Well, they might beacon through an
    established domain or slow their callback interval to once every two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In response, we could change our rule to look for domains to which the system
    hasn’t previously connected, or we could increase the beaconing interval. But
    remember that we’d risk receiving more false positives. Engineers will continue
    to perform this dance as they strive to optimize their detection strategies to
    balance the tolerances of their organizations with the capabilities of their adversaries.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Linking Evasion Techniques: An Example
    Attack</samp>'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is typically more than one way to collect a piece of telemetry. For example,
    the EDR could monitor process-creation events using both a driver and an ETW consumer.
    This means that evasion isn’t a simple matter of finding a silver bullet. Rather,
    it’s the process of abusing gaps in a sensor to fly under the threshold at which
    the EDR generates an alert or takes preventive action.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Table 1-2](#tab1-2), which describes a contrived classification system
    designed to catch command-and-control agent operations. In this example, any actions
    occurring within some window of time whose cumulative score is greater than or
    equal to 500 will cause a high-severity alert. A score higher than 750 will cause
    the offending process and its children to be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">An
    Example Classification System</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Activity</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Risk
    score</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Execution of an unsigned binary</samp>
    | <samp class="SANS_Futura_Std_Book_11">250</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Atypical child process spawned</samp>
    | <samp class="SANS_Futura_Std_Book_11">400</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Outbound HTTP traffic originating from
    a non-browser process</samp> | <samp class="SANS_Futura_Std_Book_11">100</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Allocation of a read-write-execute
    buffer</samp> | <samp class="SANS_Futura_Std_Book_11">200</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Committed memory allocation not backed
    by an image</samp> | <samp class="SANS_Futura_Std_Book_11">350</samp> |'
  prefs: []
  type: TYPE_TB
- en: An attacker could bypass each of these activities individually, but when they’re
    combined, evasion becomes much more difficult. How could we chain evasion techniques
    to avoid triggering the detection logic?
  prefs: []
  type: TYPE_NORMAL
- en: Starting with configuration evasions, let’s imagine that the agent lacks a network-inspection
    sensor, so it can’t correlate outgoing network traffic with a client process.
    However, a compensating control may be present, such as an ETW consumer for the
    Microsoft-Windows-WebIO provider. In that case, we might opt to use a browser
    as a host process or employ another protocol, such as DNS, for command and control.
    We might also use a logical evasion to subvert the “atypical child process” detection
    by matching typical parent–child relationships on the system. For a perceptual
    evasion, let’s say that the agent lacks the ability to scan memory allocations
    to see if they’re backed by an image. As attackers, we won’t need to worry at
    all about being detected based on this indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put this all together to describe how an attack might proceed. First,
    we could exploit an email client to achieve code execution under the context of
    that process. Because this mail-client binary is a legitimate product that existed
    on the system prior to compromise, we can reasonably assume that it is signed
    or has a signing exclusion. We’ll send and receive command-and-control traffic
    over HTTP, which triggers the detection for a non-browser process communicating
    over HTTP, bringing the current risk score up to 100.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to spawn a sacrificial process at some point to perform our post-exploitation
    actions. Our tooling is written in PowerShell, but rather than spawning *powershell.exe*,
    which would be atypical and trigger an alert by bringing our risk score to 500,
    we instead spawn a new instance of the email client as a child process and use
    Unmanaged PowerShell to execute our tooling inside it. Our agent allocates a read-write-execute
    buffer in the child process, however, raising our risk score to 300.
  prefs: []
  type: TYPE_NORMAL
- en: 'We receive the output from our tool and determine that we need to run another
    tool to perform some action to further our access. At this point, any additional
    detections will raise our risk score to 500 or greater, potentially burning our
    operation, so we have some decisions to make. Here are a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the post-exploitation tooling and accept the detection. After the alert,
    we could move very quickly in an attempt to outpace the response, hope for an
    ineffective response process that fails to eradicate us, or be okay with burning
    the operation and starting over again if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for some period of time before executing our tooling. Because the agent
    correlates only those events that occur within some window of time, we can simply
    wait until the state recycles, resetting our risk score to zero, and continue
    the operation from there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find another method of execution. This could range from simply dropping our
    script on the target and executing it there, to proxying in the post-exploitation
    tool’s traffic to reduce most of the host-based indicators it would create.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whatever we choose, our goal is clear: stay below the alerting threshold for
    as long as possible. By calculating the risks of each action that we need to perform,
    understanding the indicators our activities create, and using a combination of
    evasion tactics, we can evade an EDR’s complex detection systems. Note that no
    single evasion worked universally in this example. Rather, a combination of evasions
    targeted the most relevant detections for the task at hand.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In summary, an EDR agent is composed of any number of sensors that are responsible
    for collecting telemetry related to activity on the system. The EDR applies its
    own rules or detection logic across this data to pick out what things might indicate
    a malicious actor’s presence. Each of these sensors is susceptible to evasion
    in some way, and it is our job to identify those blind spots and either abuse
    them or compensate for them.
  prefs: []
  type: TYPE_NORMAL
