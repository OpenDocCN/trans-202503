["```\n{-# OPTIONS -Wall #-}\n\nmodule Maxwell where\n\nimport SimpleVec\n    ( R, Vec(..), (^/), (^+^), (^-^), (*^)\n    , vec, negateV, magnitude, xComp, yComp, zComp, iHat, jHat, kHat )\nimport CoordinateSystems\n    ( ScalarField, VectorField\n    , cart, shiftPosition, rVF, magRad )\nimport ElectricField ( cSI, mu0 )\nimport qualified Data.Map.Strict as M\nimport qualified Diagrams.Prelude as D\nimport Diagrams.Prelude\n    ( Diagram, Colour\n    , PolyType(..), PolyOrientation(..), PolygonOpts(..), V2(..)\n    , (#), rotate, deg, rad, polygon, sinA, dims, p2\n    , fc, none, lw, blend )\nimport Diagrams.Backend.Cairo ( B, renderCairo )\n```", "```\ndirectionalDerivative :: Vec -> ScalarField -> ScalarField\ndirectionalDerivative d f r\n    = (f (shiftPosition (d ^/ 2) r) - f (shiftPosition (negateV d ^/ 2) r))\n      / magnitude d\n```", "```\ncurl :: R -> VectorField -> VectorField\ncurl a vf r\n    = let vx = xComp . vf\n          vy = yComp . vf\n          vz = zComp . vf\n          derivX = directionalDerivative (a *^ iHat)\n          derivY = directionalDerivative (a *^ jHat)\n          derivZ = directionalDerivative (a *^ kHat)\n      in      (derivY vz r - derivZ vy r) *^ iHat\n          ^+^ (derivZ vx r - derivX vz r) *^ jHat\n          ^+^ (derivX vy r - derivY vx r) *^ kHat\n```", "```\ntype FieldState = (R            -- time t\n                  ,VectorField  -- electric field E\n                  ,VectorField  -- magnetic field B\n                  )\n```", "```\nmaxwellUpdate :: R                  -- dx\n              -> R                  -- dt\n              -> (R -> VectorField) -- J\n              -> FieldState -> FieldState\nmaxwellUpdate dx dt j (t,eF,bF)\n    = let t'    = t + dt\n          eF' r = eF r ^+^ cSI**2 *^ dt *^ (curl dx bF r ^-^ mu0 *^ j t r)\n          bF' r = bF r ^-^           dt *^  curl dx eF r\n      in (t',eF',bF')\n```", "```\nmaxwellEvolve :: R                  -- dx\n              -> R                  -- dt\n              -> (R -> VectorField) -- J\n              -> FieldState -> [FieldState]\nmaxwellEvolve dx dt j st0 = iterate (maxwellUpdate dx dt j) st0\n```", "```\nexLocs, eyLocs, ezLocs, bxLocs, byLocs, bzLocs :: [(Int,Int,Int)]\nexLocs = [(nx,ny,nz) | nx <- odds , ny <- evens, nz <- evens]\neyLocs = [(nx,ny,nz) | nx <- evens, ny <- odds , nz <- evens]\nezLocs = [(nx,ny,nz) | nx <- evens, ny <- evens, nz <- odds ]\nbxLocs = [(nx,ny,nz) | nx <- evens, ny <- odds , nz <- odds ]\nbyLocs = [(nx,ny,nz) | nx <- odds , ny <- evens, nz <- odds ]\nbzLocs = [(nx,ny,nz) | nx <- odds , ny <- odds , nz <- evens]\n```", "```\nspaceStepsCE :: Int\nspaceStepsCE = 40\n```", "```\nhiEven :: Int\nhiEven =  2 * spaceStepsCE\n```", "```\nevens :: [Int]\nevens = [-hiEven, -hiEven + 2 .. hiEven]\n```", "```\nodds :: [Int]\nodds = [-hiEven + 1, -hiEven + 3 .. hiEven - 1]\n```", "```\ndata StateFDTD = StateFDTD {timeFDTD :: R\n                           ,stepX    :: R\n                           ,stepY    :: R\n                           ,stepZ    :: R\n                           ,eField   :: M.Map (Int,Int,Int) R\n                           ,bField   :: M.Map (Int,Int,Int) R\n                           } deriving Show\n```", "```\ninitialStateFDTD :: R -> StateFDTD\ninitialStateFDTD spatialStep\n    = StateFDTD {timeFDTD  = 0\n                ,stepX = spatialStep\n                ,stepY = spatialStep\n                ,stepZ = spatialStep\n                ,eField = M.fromList [(loc,0) | loc <- exLocs++eyLocs++ezLocs]\n                ,bField = M.fromList [(loc,0) | loc <- bxLocs++byLocs++bzLocs]\n                }\n```", "```\nPrelude> :l Maxwell\n[ 1 of 13] Compiling Newton2          ( Newton2.hs, interpreted )\n[ 2 of 13] Compiling SimpleVec        ( SimpleVec.hs, interpreted )\n[ 3 of 13] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[ 4 of 13] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[ 5 of 13] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[ 6 of 13] Compiling MOExamples       ( MOExamples.hs, interpreted )\n[ 7 of 13] Compiling Electricity      ( Electricity.hs, interpreted )\n[ 8 of 13] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )\n[ 9 of 13] Compiling Geometry         ( Geometry.hs, interpreted )\n[10 of 13] Compiling Integrals        ( Integrals.lhs, interpreted )\n[11 of 13] Compiling Charge           ( Charge.hs, interpreted )\n[12 of 13] Compiling ElectricField    ( ElectricField.hs, interpreted )\n[13 of 13] Compiling Maxwell          ( Maxwell.hs, interpreted )\n\nOk, 13 modules loaded.\n*Maxwell> :t M.lookup\nM.lookup :: Ord k => k -> M.Map k a -> Maybe a\n```", "```\n*Maxwell>  :m Data.Map.Strict\nPrelude Data.Map.Strict>  :t Data.Map.Strict.lookup\nData.Map.Strict.lookup :: Ord k => k -> Map k a -> Maybe a\n```", "```\nlookupAZ :: Ord k => k -> M.Map k R -> R\nlookupAZ key m = case M.lookup key m of\n                     Nothing -> 0\n                     Just x  -> x\n```", "```\npartialX,partialY,partialZ :: R -> M.Map (Int,Int,Int) R -> (Int,Int,Int) -> R\npartialX dx m (i,j,k) = (lookupAZ (i+1,j,k) m - lookupAZ (i-1,j,k) m) / dx\npartialY dy m (i,j,k) = (lookupAZ (i,j+1,k) m - lookupAZ (i,j-1,k) m) / dy\npartialZ dz m (i,j,k) = (lookupAZ (i,j,k+1) m - lookupAZ (i,j,k-1) m) / dz\n```", "```\ncurlEx,curlEy,curlEz,curlBx,curlBy,curlBz :: StateFDTD -> (Int,Int,Int) -> R\ncurlBx (StateFDTD _ _ dy dz _ b) loc = partialY dy b loc - partialZ dz b loc\ncurlBy (StateFDTD _ dx _ dz _ b) loc = partialZ dz b loc - partialX dx b loc\ncurlBz (StateFDTD _ dx dy _ _ b) loc = partialX dx b loc - partialY dy b loc\ncurlEx (StateFDTD _ _ dy dz e _) loc = partialY dy e loc - partialZ dz e loc\ncurlEy (StateFDTD _ dx _ dz e _) loc = partialZ dz e loc - partialX dx e loc\ncurlEz (StateFDTD _ dx dy _ e _) loc = partialX dx e loc - partialY dy e loc\n```", "```\nstateUpdate :: R                   -- dt\n            -> (R -> VectorField)  -- current density J\n            -> StateFDTD -> StateFDTD\nstateUpdate dt j st0@(StateFDTD t _dx _dy _dz _e _b)\n    = let st1 = updateE dt (j t) st0\n          st2 = updateB dt st1\n      in st2\n```", "```\nupdateE :: R            -- time step dt\n        -> VectorField  -- current density J\n        -> StateFDTD -> StateFDTD\nupdateE dt jVF st\n    = st { timeFDTD = timeFDTD st + dt / 2\n         , eField   = M.mapWithKey (updateEOneLoc dt jVF st) (eField st) }\n```", "```\nPrelude Data.Map.Strict>  :m Data.Map.Strict\nPrelude Data.Map.Strict>  :t mapWithKey\nmapWithKey :: (k -> a -> b) -> Map k a -> Map k b\n```", "```\nupdateB :: R -> StateFDTD -> StateFDTD\nupdateB dt st\n    = st { timeFDTD = timeFDTD st + dt / 2\n         , bField   = M.mapWithKey (updateBOneLoc dt st) (bField st) }\n```", "```\nupdateEOneLoc :: R -> VectorField -> StateFDTD -> (Int,Int,Int) -> R -> R\nupdateEOneLoc dt jVF st (nx,ny,nz) ec\n    = let r = cart (fromIntegral nx * stepX st / 2)\n                   (fromIntegral ny * stepY st / 2)\n                   (fromIntegral nz * stepZ st / 2)\n          Vec jx jy jz = jVF r\n      in case (odd nx, odd ny, odd nz) of\n           (True , False, False)\n               -> ec + cSI**2 * (curlBx st (nx,ny,nz) - mu0 * jx) * dt  -- Ex\n           (False, True , False)\n               -> ec + cSI**2 * (curlBy st (nx,ny,nz) - mu0 * jy) * dt  -- Ey\n           (False, False, True )\n               -> ec + cSI**2 * (curlBz st (nx,ny,nz) - mu0 * jz) * dt  -- Ez\n           _ -> error \"updateEOneLoc passed bad indices\"\n```", "```\nupdateBOneLoc :: R -> StateFDTD -> (Int,Int,Int) -> R -> R\nupdateBOneLoc dt st (nx,ny,nz) bc\n    = case (odd nx, odd ny, odd nz) of\n        (False, True , True ) -> bc - curlEx st (nx,ny,nz) * dt  -- Bx\n        (True , False, True ) -> bc - curlEy st (nx,ny,nz) * dt  -- By\n        (True , True , False) -> bc - curlEz st (nx,ny,nz) * dt  -- Bz\n        _ -> error \"updateBOneLoc passed bad indices\"\n```", "```\njGaussian :: R -> VectorField\njGaussian t r\n    = let wavelength = 1.08             -- meters\n          frequency = cSI / wavelength  -- Hz\n          j0 = 77.5                     -- A/m^2\n          l = 0.108                     -- meters\n          rMag = magnitude (rVF r)      -- meters\n      in j0 *^ exp (-rMag**2 / l**2) *^ cos (2*pi*frequency*t) *^ kHat\n```", "```\nmakeEpng :: (Colour R, Colour R) -> (Int,StateFDTD) -> IO ()\nmakeEpng (scol,zcol) (n,StateFDTD _ _ _ _ em _)\n    = let threeDigitString = reverse $ take 3 $ reverse (\"00\" ++ show n)\n          pngFilePath = \"MaxVF\" ++ threeDigitString ++ \".png\"\n          strongE = 176  -- V/m\n          vs = [((fromIntegral nx, fromIntegral nz),(xComp ev, zComp ev))\n               | nx <- evens, nz <- evens, abs nx <= 50, abs nz <= 50\n               , let ev = getAverage (nx,0,nz) em ^/ strongE]\n      in gradientVectorPNG pngFilePath (scol,zcol) vs\n```", "```\ngetAverage :: (Int,Int,Int)  -- (even,even,even) or (odd,odd,odd)\n           -> M.Map (Int,Int,Int) R\n           -> Vec\ngetAverage (i,j,k) m\n    = let vXl = lookupAZ (i-1,j  ,k  ) m\n          vYl = lookupAZ (i  ,j-1,k  ) m\n          vZl = lookupAZ (i  ,j  ,k-1) m\n          vXr = lookupAZ (i+1,j  ,k  ) m\n          vYr = lookupAZ (i  ,j+1,k  ) m\n          vZr = lookupAZ (i  ,j  ,k+1) m\n      in vec ((vXl+vXr)/2) ((vYl+vYr)/2) ((vZl+vZr)/2)\n```", "```\ngradientVectorPNG :: FilePath\n                  -> (Colour R, Colour R)\n                  -> [((R,R),(R,R))]\n                  -> IO ()\ngradientVectorPNG fileName (scol,zcol) vs\n    = let maxX = maximum $ map fst $ map fst $ vs\n          normalize (x,y) = (x/maxX,y/maxX)\n          array = [(normalize (x,y), magRad v) | ((x,y),v) <- vs]\n          arrowMagRadColors :: R  -- magnitude\n                            -> R  -- angle in radians, ccw from x axis\n                            -> Diagram B\n          arrowMagRadColors mag th\n              = let r     = sinA (15 D.@@ deg) / sinA (60 D.@@ deg)\n                    myType = PolyPolar [120 D.@@ deg,  0 D.@@ deg, 45 D.@@ deg\n                                       , 30 D.@@ deg, 45 D.@@ deg,  0 D.@@ deg\n                                       ,120 D.@@ deg]\n                             [1,1,r,1,1,r,1,1]\n                    myOpts = PolygonOpts myType NoOrient (p2 (0,0))\n                in D.scale 0.5 $ polygon myOpts # lw none #\n                   fc (blend mag scol zcol) # rotate (th D.@@ rad)\n          step = 2 / (sqrt $ fromIntegral $ length vs)\n          scaledArrow m th = D.scale step $ arrowMagRadColors m th\n          pic = D.position [(p2 pt, scaledArrow m th) | (pt,(m,th)) <- array]\n      in renderCairo fileName (dims (V2 1024 1024)) pic\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Maxwell ( makeEpng, stateUpdate, jGaussian, initialStateFDTD )\nimport Diagrams.Prelude ( black, yellow )\n\nmain :: IO ()\nmain = let dt = 0.02e-9   -- 0.02 ns time step\n           numTimeSteps = 719\n       in sequence_ $ map (makeEpng (yellow,black)) $ zip [0..numTimeSteps] $\n          iterate (stateUpdate dt jGaussian) (initialStateFDTD 0.108)\n```", "```\niterate (stateUpdate dt jGaussian) (initialStateFDTD 0.108)\n```", "```\n$ ffmpeg -framerate 25 -i MaxVF%03d.png MaxVF.mp4\n```"]