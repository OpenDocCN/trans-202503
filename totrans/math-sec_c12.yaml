- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Minimum Viable Product Approach to Security Software Development
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Going beyond your current proof-of-concept code means planning how other users
    will interact with your program. Mapping out the user’s path through the application
    from start to finish will allow you to decide the best ways to deliver the application,
    which in turn will enable your users to quickly and intuitively begin using your
    software. The considerations in this chapter apply to most types of applications
    equally well, as they deal with the process of delivering and using the application,
    rather than with the problem directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter we identified a few use cases that led us to define
    several features that the application would have to support. In this chapter,
    we’re going to implement the still-open features: developing a graphical user
    interface (GUI) and saving projects. We’ll begin by mapping the user’s interactions
    with the program, using them to build the GUI. Then we’ll discuss state managers
    and how to use process parallelism to split up the workload, optimizing our solutions
    for complex floor plans. Finally, we’ll build the GUI and implement the save feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the User’s Interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most good software projects begin the development phase with a set of user interaction
    plans that describe the actual steps a user will follow in the application to
    achieve each use case. These plans can be rough sketches or extremely detailed
    wireframe mock-ups of the final application, but they all need to answer the question,
    “How will the user use the system to achieve the goal?” My preferred method for
    plotting use cases is using application state machines for the structure and Unified
    Modeling Language (UML) for the process. I recommend using an application like
    Dia or LucidChart to produce a visual layout. [Figure 12-1](#figure12-1) shows
    the workflow diagram I developed in LucidChart for the use case where a user wants
    to save their project across multiple sessions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c12/f12001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: A multiple-session workflow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'I chose this particular use case because it encompasses the entire application
    flow: we create multiple floors, draw the polygon representation, save and reload
    project data, as well as create the final solution visualization. At the top left
    of [Figure 12-1](#figure12-1), you see the oval shape, which is used to represent
    the use case entry point. In this scenario, a user who wants to work across multiple
    sessions begins by initializing their project. Right now that simply means they
    open the program for the first time, but we’ll add more to the initialization
    in later sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rounded squares represent high-level states of the application. These states
    are similar to the ones we examined in [Chapter 6](c06.xhtml) when we discussed
    finite state machines: they represent the options available at each state to transition
    to another state. When a user initializes their project, they’re moved into the
    *Start* state, where they’re expected to create one or more `Floor` objects that
    contain a background PNG file. Once the `Floor` class representing the floor plan
    is created, it’s passed to the next state the user enters, the *Started* state.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Started state, the user has the option to draw the shape data for the
    floor plan. To do so, they click their mouse to create a series of points representing
    the hull of the floor plan along with points within the hull to define holes (represented
    by the `Obstacle` class in the application primitives). Once a user adds a point
    to start drawing a shape, they must either finish drawing or back out using an
    `undo` function. After the user draws the shapes they want, the Shapely data is
    sent to the state manager, the heart of the whole application. We’ll cover the
    state manager in more detail momentarily, but for now just understand that the
    state manager’s job is to track what the user’s doing in the application and expose
    the proper actions and impose the proper constraints (such as finishing a shape
    before saving).
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has drawn as much as they want for the session, they move into
    the *Drawn* state, where they’ll save the information for the next session. To
    tell the state manager to record the various files and objects, the user enters
    the key combination ctrl-S. From this state, the user can either return to drawing—allowing
    incremental progress saves within a single session—or end the program and return
    later. When the user does return for subsequent sessions, they enter the application
    at the *Saved* state, which allows them to ask the session manager to load a previously
    saved project using the key combination ctrl-O. After loading completes, the user
    can add new floors (the Start state) or continue to draw on previously created
    floors (the Started state). Once all the necessary shapes are recorded, the user
    can solve the floor with the key combination ctrl-P. The result will be an image
    file that includes the lowest-count deployment overlaid on the background image
    for the floor plan.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this implementation is still somewhat basic in its feature set; this
    is intentional to allow you to expand the program to meet your vision for the
    project. Part of the art in application development lies in how you choose to
    organize the feature work, so I won’t go into any more detail about which pieces
    I think should go where. As long as you lay out the features to match the use
    cases in a way that makes sense to you, they’ll serve as a map to guide the rest
    of your project development.
  prefs: []
  type: TYPE_NORMAL
- en: Planning Application States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve created the rest of your application state flowcharts, you can begin
    to pick apart the code needed to support each application state. This process
    is about identifying the pieces of the application that impact the most features
    and developing the code necessary to support those functions that cover it. Following
    this application-mapping process helps you reduce unnecessary code by identifying
    the shared pieces of an application so you can develop them with reusable classes
    or functions. Because it allows you to track which interactions touch which sections
    of the code, this process also helps you gauge the relative importance of each
    piece to the application’s performance. For example, by examining the diagram
    in [Figure 12-1](#figure12-1), we can tell that we’ll need a state manager class
    to track what’s happening in the application, a floor class to represent the floor
    plan, and some way to support keyboard input (like the hotkey commands ctrl-S
    and ctrl-O). We know the state manager will need to be able to take in shape data
    and output files that store the important details. It will also need to be able
    to read in those same files and rebuild the last saved state from them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application map also helps you organize the libraries and modules
    you’ll need to support these requirements. We already know we’ll need the Triangle
    and NetworkX libraries from the previous chapter. Because we’ll need graphic displays,
    keyboard shortcuts, and mouse interactions, the PyGame library is a good choice
    for developing the user interface—it supports all three needs at once. Since we’re
    using a background PNG file, we’ll need something that knows how to work with
    this file type. We could use a specific PNG library (creatively named png) that
    works well with PyGame’s functions, or we could use imutils or another similar
    library. Allow your application diagram to guide your selection of libraries and
    read the documentation for different options. Look for libraries like PyGame that
    can solve multiple requirements. Where two options appear equally suited to a
    task, I often choose the one that allows me to reduce the overall requirement
    size. That means choosing the one that’s already included in the requirements
    library or selecting the smaller of the two packages in terms of file size.
  prefs: []
  type: TYPE_NORMAL
- en: In practical development, the number of use cases you include and the order
    in which you approach them will largely be dictated by external forces (such as
    business needs and budgets), so it’s impossible for anyone to give you a generic
    development process to follow. Still, at a high level, developing use case diagrams
    and application flow diagrams will almost always help you stay on target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s discuss an often-overlooked topic when it comes to proof-of-concept
    development: documenting our projects for the good of humanity.'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An absolute must for any important project is good documentation. We’ve already
    got a start on our documentation with the application state diagram. When it’s
    time to deliver this software, we can include this diagram along with other project
    documentation to show users our application’s basic functionality. In addition
    to the project artifacts, we should also be documenting our source code. The code
    for this project uses a method known as *docstrings* to document the code both
    for ourselves and for future developers. Docstrings are comments added directly
    to your script files in a human-readable syntax. This topic is covered in great
    detail online ([https://peps.python.org/pep-0257](https://peps.python.org/pep-0257)),
    so I won’t go into it much here, but I do think it is helpful to show an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The docstring for the function is the string literal enclosed in triple quotes
    (`'''`) directly after the function definition. The comments cover the input and
    output of functions (in the example under the `Parameters` and `Returns` headers,
    respectively), document the intended use of class objects, and record any important
    notes or facts for anyone who might want to make future changes—for example, including
    a link to the source material for a particular algorithm the function uses. We
    can access the documentation for any function with a docstring using the built-in
    `.__doc__` attribute. The docstring syntax also allows automated programs to detect
    the comments and format them into prettier API documentation for general distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Having good documentation allows you to quickly bring in new developers. If
    you were developing this application for a business, you could easily train the
    other developers on your team and enable them to develop extensions and improvements.
    Likewise, if you’re building for the open source community, good documentation
    encourages good contributions. Even if you’re building only for yourself, strong
    documentation practices can help refresh your memory when you pick up a project
    after a long time away from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve discussed all the planning essentials to keep our code efficient
    and promote adoption by other developers, we can begin the fun part of the project:
    developing the core of the application, the state manager.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing the State Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extremely common in modern software, *state managers* manage all the different
    possible interactions in a program. For example, your web browser has to keep
    track of where you click and what you type, as well as everything else happening
    in the browser. The state of the browser will determine what those clicks and
    keypresses do: pressing ctrl-S on the Google home page attempts to save the page
    as an HTML file, while the same shortcut on the Google Docs web page saves the
    project to your cloud storage. This can happen only because there’s a class responsible
    for orchestrating all the pieces: the state manager. State managers are *event
    driven*: when certain actions—like a pressed key or right-click—happen, they get
    notified and decide how to respond.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at some events. [Listing 12-1](#listing12-1) shows an example
    of how PyGame uses the `pygame.event` class to send events to your program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Handling PyGame events'
  prefs: []
  type: TYPE_NORMAL
- en: The `pygame.event` class contains a queue of all the events that happen between
    successive `get` requests. The result of the `get` call is a list of event objects
    to process that we’ll loop through ❶. The order of the events will (usually) be
    the order in which the user performed them. For example, a user entering the ctrl-S
    keyboard shortcut to save a project would set off a series of events in the queue
    representing the user pressing ctrl, pressing the S key, then releasing the S
    key, and finally releasing the ctrl key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each event object has a type field to help you understand what occurred. There
    are five major event types we’re concerned with. `pygame.QUIT` ❷ is a special
    event that should trigger your application’s shutdown code and finally conclude
    the program by exiting the application cleanly (without leaving unused files on
    disk or resources opened). The other types also have fairly intuitive names: the
    `pygame.KEYDOWN` and `pygame.KEYUP` events occur when the user presses or releases
    a keyboard key, respectively. Similarly, the `pygame.MOUSEBUTTONDOWN` event indicates
    a user clicked one of the mouse buttons ❸. The state manager uses these events
    to decide when and how to transition between application states.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of events in the PyGame event queue. The `pygame.MOUSEMOTION`
    event, for example, is triggered multiple times as the user moves the mouse pointer
    around the screen. You can filter undesirable events by checking that the event
    type is not equal (`!=`) to an undesired event’s type ❹. During development, printing
    events out to the console can help you identify events that you might want to
    develop code for, such as additional keyboard shortcuts. This is an excellent
    time to use type filtering to reduce the number of output messages, as shown in
    [Listing 12-1](#listing12-1).
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications like web browsers and operating systems can have hundreds
    of states or more. Furthermore, each of these states can have *substates*, different
    options that exist within a single state, such as a red or black background screen
    in the drawing state. The more complex the application becomes, the more important
    it is to refer back to your workflow diagrams from time to time. Development is
    an iterative process, and it’s important to make sure you’re capturing all the
    major states as the project progresses. Rather than detailing all the code in
    the state manager, I’ll cover examples of the key elements that drive the interactions.
    For example, rather than showing you the logic for handling every keystroke, I’ll
    show you how to handle the two types of keyboard input (`KEYUP` and `KEYDOWN`)
    generically. You can then dive into the specifics for each function using the
    documentation provided in the file *AGP_solver_API.pdf* in the project’s resources
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 12-2](#listing12-2) shows the framework for the `handle_keydown`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Handling `KEYDOWN` events in the state manager'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes in the `pygame.event` object as its only parameter. It needs
    the object so it can determine what key was pressed and respond accordingly. There
    are a few ways to check the value of an event. First, by checking to see if the
    `event.key` attribute is in a list of values ❶, you can apply the same code block
    to multiple input values. These values are numeric identifiers for every key on
    the keyboard, also called the key’s *scan code*. In this case, the two values
    `303` and `304` correspond to the left and right shift keys, respectively. If
    either is pressed, it will trigger the code that sets the `shifted` variable to
    `True` ❷. If you care about only one key from a pair, you can compare the `event.key`
    parameter to a single scan code ❸. In this case, `306` corresponds to the left
    ctrl key. Pressing the right ctrl key won’t trigger the code block that sets the
    `controlled` variable to `True`. Note that the `shifted` and `controlled` variables
    are both global variables, which means their value will persist in the application
    even after the function returns. This is what enables us to know if the user has
    entered a two-key combination like ctrl-S, which takes two calls to `handle_keydown`
    to achieve. PyGame also has another built-in function called `pygame.key.get_mods`
    for determining whether modifier keys like ctrl or shift were pressed in a key
    combination; you should explore it to improve the code from [Listing 12-2](#listing12-2).
  prefs: []
  type: TYPE_NORMAL
- en: Determining if a specific key was pressed is sometimes easier to read in the
    code if you compare the `event.unicode` attribute against the string literal of
    the key instead of using the key’s scan code. In the example, we compare the attribute
    to the string `"z"` ❹; if the value matches, we call the `undo` function ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The `handle_keyup` function in [Listing 12-3](#listing12-3) is shorter because
    there are usually fewer keys whose release timing we care about.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Handling `KEYUP` events in the state manager'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this function is the inverse of that in [Listing 12-2](#listing12-2).
    We check the `event.key` parameter to see if either shift key was released by
    the user and, if so, set the `shifted` key to `False`. Otherwise, we check if
    the left ctrl key was released, in which case we set the controlled variable to
    `False`. The Z key fires off a one-time event, which means you don’t need to worry
    about whether the user released it or not.
  prefs: []
  type: TYPE_NORMAL
- en: The state manager has a similar function named `handle_click` that handles mouse-click
    events, as shown in [Listing 12-4](#listing12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: Handling `MOUSEBUTTONDOWN` events in the state manager'
  prefs: []
  type: TYPE_NORMAL
- en: The concept here is the same as in the previous listings, but the logic has
    to be longer to handle determining what button was clicked, where the pointer
    was when the click happened, and what other objects were in the same area as the
    pointer when the button was clicked. The `check_clicked_existing_vertex` function
    ❶ compares the position of the mouse (stored in the `event.pos` parameter of mouse
    events) against a list of all vertices in the project. It’s hard for a user to
    click exactly where a vertex is, so we give them a bit of room for error, called
    ε (epsilon). The current value for epsilon is 3 pixels. If the pointer was within
    epsilon (3 pixels) of a vertex, the vertex’s data is returned. The `EPSILON` constant
    is defined on line 35 of the *state_manager.py* file in the chapter’s supplemental
    materials, and the code for the `check_clicked_existing_vertex` is in the same
    file starting at line 634.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `check_clicked_within_room` function ❷ checks to see if the pointer
    was inside any of the polygon shapes. The event and the information regarding
    the clicked objects (if any are present) are then passed to the appropriate function
    based on what button was clicked. Some mice have different button configurations,
    and the scan codes will depend on the manufacturer and driver your computer uses
    to some degree. You can use `print(event)` while clicking different buttons to
    have PyGame identify their scan codes for you. For production applications, you
    should use PyGame’s built-in key literals like `pygame.key.K_a` instead of scan
    codes for portability.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 12-4](#listing12-4), if `event.button` is `1` ❸, it corresponds
    to the user clicking the left mouse button, so we call the function `left_click`
    ❹. If `event.button` is `3`, it corresponds to the user clicking the right mouse
    button, in which case we call the `right_click` function ❺. Both of these functions
    take in the `event` object, the `clicked` vertex, and `room` (if any exist). Each
    function uses these details to determine how to update the internal state using
    a lot of specific logical checks. For example, implementing a special delete response
    for a shift-left-click on a vertex requires the `left_click` function to first
    check if the `shifted` global variable is set to `True`. If so, the state manager
    removes the vertex that was passed to it for the list of vertices, thus updating
    the internal state. If the `shifted` variable is `False`, the state manager will
    follow a different branch of logic depending on whether a room, vertex, or neither
    was clicked. As you can imagine, the logic for these functions can quickly become
    quite long and complex.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events and managing state as we’ve done in the last three listings
    is the central concept behind the state manager code. As you expand your implementation,
    you’ll continue to add logic to the `handle_keydown`, `handle_keyup`, and `handle_click`
    functions to implement all the different possible user interactions, such as drawing
    the rooms and adding obstructions to them (covered in the “[Adding a Graphical
    User Interface](#h1-502567c12-0004)” section shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Accelerating Security with Parallel Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Process parallelism* is a large topic with many nuances, but simply put, it
    means spreading the work that needs to be accomplished across multiple workers.
    How you accomplish this is called the *division of labor* and is a matter of some
    contention. For example, suppose you’re a teacher and you have to grade 100 student
    papers, each with 20 questions. Luckily, you have four teaching assistants to
    help you, for a total of five workers grading papers, so you could each grade
    20 papers. The benefit would be that you have five papers being graded at the
    same time instead of just one.'
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be for each of you to select four questions to grade. You
    take the first paper, grade your four questions, then pass it along to the next
    person for them to grade their four questions, and so on. In this scenario, every
    worker touches every paper at least once, but for a reduced amount of time. The
    benefit of a division of labor like this is it allows each worker to focus on
    the work they’re best suited for. Imagine a scenario where one of the assistants
    is a specialist in mechanical engineering and another specializes in chemistry.
    By allowing each specialist to work on their area of expertise, you maximize the
    speed of the process by leveraging their individual capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Threading Parallelism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More formally speaking, Python has two main approaches for parallelism: threading
    parallelism and processor parallelism. *Threading parallelism* occurs when a main
    application opens up a child application that shares its resources, like memory
    space ([https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)).
    This would be similar to having a single answer key for the test that all the
    people grading papers can look at (imagine it’s taped to a wall in the room).
    Each grader represents a thread and the answer key is a shared resource they all
    have access to. With most flavors of Python, threading isn’t technically parallelism
    because only one thread can be executing a command at a time (controlled by the
    Python interpreter). This is equivalent to letting only one person grade an answer
    at any given time. For practical purposes, though, switching threads happens so
    fast that it’s nearly simultaneous, so most developers (myself included) still
    count it.'
  prefs: []
  type: TYPE_NORMAL
- en: Threads can be created in a few different ways, but one of the most popular
    is to create multiple threads of a single class, as shown in [Listing 12-5](#listing12-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: Threaded parallelism for displaying concurrent images'
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a class named `DisplayAGP` that allows the application to display
    multiple images at the same time, while still allowing the main application to
    do other work in the background. All classes that are intended to be used in a
    threaded fashion need to extend the `threading.Thread` class ❶ and contain a `run`
    method ❸, which contains the logic to be executed within the context of the thread—in
    this case, opening a particular image file and displaying it with `im.show` ❹.
    You can add further class methods, like the `set_file` method ❷, as a means of
    configuring each thread prior to running it.
  prefs: []
  type: TYPE_NORMAL
- en: To display all the image files in a list creatively named `image_files` concurrently,
    you can use the code in [Listing 12-6](#listing12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: Displaying images concurrently with the `DisplayAGP` class'
  prefs: []
  type: TYPE_NORMAL
- en: We start by looping over the list of file locations. For each one, we create
    a new instance of the `DisplayAGP` class. Then we call the `set_file` method with
    the location of the image so each thread knows what it should display. Setting
    the `t.daemon` property to `True` tells the program not to wait for the result
    of the thread once it is started with the `start` method. Calling ``t.start actually
    triggers the code in the `DisplayAGP.run` method. Once all the threads have been
    started, your main thread is free to move on to handle other work.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
