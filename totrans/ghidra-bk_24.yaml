- en: '## **20'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **20'
- en: COMPILER VARIATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器差异**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: At this point, if we have done our job properly, you now possess the essential
    skills to use Ghidra effectively and, more importantly, to bend it to your will.
    The next step is to learn to adapt to the challenges that binaries (as opposed
    to Ghidra) will throw at you. Depending on your motives for staring at assembly
    language, either you may be very familiar with what you are looking at or you
    may never know what you are going to be faced with. If you spend all of your time
    examining code that was compiled using `gcc` on a Linux platform, you’ll become
    quite familiar with the style of code that it generates, but you may be baffled
    by a debug version of a program compiled using the Microsoft C/C++ compiler. If
    you are a malware analyst, you may see code created using `gcc`, clang, Microsoft's
    C++ compiler, Delphi, and others, all in the same afternoon.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果我们做得对，你应该已经掌握了有效使用Ghidra的基本技能，更重要的是，学会如何让它为你所用。下一步是学习如何应对二进制文件（而不是Ghidra）给你带来的挑战。根据你研究汇编语言的动机，你可能对自己正在查看的内容非常熟悉，或者你根本无法预知会面临什么。如果你花费所有时间分析在Linux平台上使用`gcc`编译的代码，你将非常熟悉它生成的代码风格，但你可能会对使用微软C/C++编译器编译的调试版本程序感到困惑。如果你是恶意软件分析师，你可能会在同一个下午看到使用`gcc`、clang、微软C++编译器、Delphi等编写的代码。
- en: 'Like you, Ghidra is more familiar with the output of some compilers than other
    compilers, and familiarity with code generated by one compiler in no way guarantees
    that you will recognize high-level constructs compiled using an entirely different
    compiler (or even different versions of the same compiler family). Rather than
    relying entirely on Ghidra’s analysis capabilities to recognize commonly used
    code and data constructs, you should always be prepared to utilize your own skills:
    your familiarity with a given assembly language, your knowledge of compilers,
    and your research skills to properly interpret a disassembly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 和你一样，Ghidra对某些编译器的输出比其他编译器更熟悉，而对某个编译器生成的代码的熟悉，并不能保证你能够识别使用完全不同编译器（甚至是同一编译器家族的不同版本）编译的高级构造。与其完全依赖Ghidra的分析能力来识别常用的代码和数据结构，你应该始终准备好运用自己的技能：你对特定汇编语言的熟悉程度、你对编译器的知识，以及你的研究能力，以正确解读反汇编代码。
- en: In this chapter, we cover some of the ways that compiler differences manifest
    themselves in disassembly listings. We primarily use compiled C code for our examples,
    as the variability of C compilers and target platforms provides foundational concepts
    that can be extended to other compiled languages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍编译器差异如何在反汇编清单中体现出来。我们主要使用编译后的C代码作为示例，因为C编译器和目标平台的多样性提供了基础概念，这些概念可以扩展到其他编译语言。
- en: '**High-Level Constructs**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级构造**'
- en: In some cases, the differences between compilers may just be cosmetic, but in
    other cases, they are much more significant. In this section, we look at high-level
    language constructs and demonstrate how different compilers and compiler options
    may significantly impact the resulting disassembly listing. We begin with `switch`
    statements and the two mechanisms most commonly employed to resolve `switch` case
    selection. Following that, we look at the way that compiler options affect code
    generation for common expressions before moving on to discuss how different compilers
    implement C++-specific constructs and handle program startup.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编译器之间的差异可能只是表面上的，但在其他情况下，它们的差异可能更为显著。在本节中，我们将探讨高级语言构造，并演示不同的编译器和编译器选项如何显著影响生成的反汇编清单。我们从`switch`语句开始，讨论解决`switch`
    case选择时最常用的两种机制。接着，我们将研究编译器选项如何影响常见表达式的代码生成，然后再讨论不同编译器如何实现C++特定构造并处理程序启动。
- en: '***switch Statements***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***switch语句***'
- en: The C `switch` statement is a frequent target for compiler optimizations. The
    goal of these optimizations is to match the `switch` variable to a valid case
    label in the most efficient manner possible, but the distribution of the `switch`
    statement’s case labels constrains the type of search that can be used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的`switch`语句是编译器优化的常见目标。这些优化的目标是以最有效的方式将`switch`变量匹配到有效的case标签，但`switch`语句的case标签分布限制了可以使用的查找类型。
- en: Since the efficiency of a search is measured by the number of comparisons required
    to find the correct case, we can trace the logic a compiler might use to determine
    the best way to represent a `switch` table. A constant time algorithm, such as
    a table lookup, is the most efficient.^([1](footnotes.xhtml#ch20fn1)) At the other
    end of the continuum is linear search, which, in the worst case, requires comparing
    the `switch` variable against every case label before finding a match or resolving
    to the default and thus is the least efficient.^([2](footnotes.xhtml#ch20fn2))
    The efficiency of a binary search is much better, on average, than linear search
    but introduces additional constraints, as it requires a sorted list.^([3](footnotes.xhtml#ch20fn3))
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于搜索的效率是通过所需的比较次数来衡量的，我们可以追踪编译器可能用来确定最优方式表示`switch`表的逻辑。常数时间算法，如表查找，是最有效的。^([1](footnotes.xhtml#ch20fn1))
    在最不理想的情况下是线性搜索，它在最坏情况下需要将`switch`变量与每个case标签进行比较，直到找到匹配项或回退到默认值，因此它是最不高效的。^([2](footnotes.xhtml#ch20fn2))
    二分查找的效率通常优于线性搜索，但也引入了额外的限制，因为它需要一个已排序的列表。^([3](footnotes.xhtml#ch20fn3))
- en: In order to select the most efficient implementation for a particular `switch`
    statement, it helps to understand how the case label distribution affects the
    compiler’s decision-making process. When case labels are closely clustered, as
    in the source code in [Listing 20-1](ch20.xhtml#exa20_1), compilers generally
    resolve the `switch` variable by performing a table lookup to match the `switch`
    variable to the address of its associated case—specifically by using a jump table.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择最有效的实现方式，对于特定的`switch`语句，了解case标签的分布如何影响编译器的决策过程是很有帮助的。当case标签紧密聚集时，如[列表20-1](ch20.xhtml#exa20_1)中的源代码所示，编译器通常通过执行表查找来解决`switch`变量，将`switch`变量与其相关联的case地址匹配——具体而言，是通过使用跳转表。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 20-1: A* `switch` *statement with consecutive case labels*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表20-1：一个*`switch`*语句，具有连续的case标签*'
- en: 'A *jump table* is an array of pointers, with each pointer in the array referencing
    a possible jump target. At runtime, a dynamic index into the table chooses one
    of the many potential jumps each time the jump table is referenced. Jump tables
    work well when `switch` case labels are closely spaced (dense), with most of the
    cases falling into a consecutive number sequence. Compilers take this into account
    when deciding whether to utilize a jump table. For any `switch` statement, we
    can compute the minimum number of entries an associated jump table will contain
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转表*是一个指针数组，数组中的每个指针都指向一个可能的跳转目标。在运行时，表中的动态索引每次被引用时都会选择多个潜在跳转中的一个。跳转表在`switch`
    case标签紧密排列（即密集）时表现良好，大多数case标签都形成一个连续的数字序列。编译器在决定是否使用跳转表时会考虑这一点。对于任何`switch`语句，我们可以通过以下方式计算跳转表中最少的条目数：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The *density*, or utilization rate, of the jump tables can then be computed
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转表的*密度*或利用率可以通过以下方式计算：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A completely contiguous list with every value represented would have a density
    value of 100 percent (1.0). Finally, the total amount of space required to store
    the jump table is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个值都被表示为一个完全连续的列表，那么该列表的密度值为100%（1.0）。最后，存储跳转表所需的总空间如下：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A `switch` statement with 100 percent density will be implemented using a jump
    table. A set of cases with a density of 30 percent might not be implemented using
    a jump table, since jump table entries would still need to be allocated for the
    absent cases, which would be 70 percent of the jump table. If `num_entries` is
    30, the jump table would contain entries for 21 unreferenced case labels. On a
    64-bit system, this is 168 of the 240 bytes allocated to the table, which is not
    a lot of overhead, but if `num_entries` jumps to 300, then the overhead becomes
    1680 bytes, which may not be worth the trade-off for 90 possible cases. A compiler
    that is optimizing for speed may favor jump table implementations, while a compiler
    that is optimizing for size may choose an alternative implementation with lower
    memory overhead: binary search.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有100%密度的`switch`语句将通过跳转表来实现。一个密度为30%的case集合可能无法通过跳转表实现，因为跳转表条目仍然需要为缺失的case分配空间，而这些缺失的case占了跳转表的70%。如果`num_entries`为30，则跳转表将包含21个未引用的case标签的条目。在64位系统上，这将占用跳转表分配的240字节中的168字节，虽然开销不大，但如果`num_entries`跳到300，则开销变为1680字节，这对于90个可能的case来说可能不值得这种权衡。优化速度的编译器可能更倾向于使用跳转表实现，而优化尺寸的编译器则可能选择一个内存开销更小的替代实现：二分查找。
- en: '*Binary search* is efficient when the case labels are widely spread (low density),
    as seen in [Listing 20-2](ch20.xhtml#exa20_2) (density 0.0008).^([4](footnotes.xhtml#ch20fn4))
    Because binary search works only on sorted lists, the compiler must ensure that
    the case labels are ordered before it begins the search with the median value.
    This may result in the reordering of case blocks when viewed in a disassembly,
    as compared to the order they appear in the corresponding source.^([5](footnotes.xhtml#ch20fn5))'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 case 标签分布较广（低密度）时，*二分查找*非常高效，如在[清单 20-2](ch20.xhtml#exa20_2)中所示（密度为 0.0008）。^([4](footnotes.xhtml#ch20fn4))
    由于二分查找仅适用于排序过的列表，编译器必须确保在开始使用中位值进行查找之前，先对 case 标签进行排序。这可能导致在反汇编中查看到的 case 块的顺序与它们在源代码中的顺序不同。^([5](footnotes.xhtml#ch20fn5))
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 20-2: Sample* `switch` *statement with nonconsecutive case labels*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 20-2：示例* `switch` *语句，包含非连续的 case 标签*'
- en: '[Listing 20-3](ch20.xhtml#exa20_3) shows an outline for a non-iterative binary
    search through a fixed number of constant values. This is the rough framework
    that the compiler uses to implement the `switch` from [Listing 20-2](ch20.xhtml#exa20_2).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 20-3](ch20.xhtml#exa20_3) 显示了一个通过固定数量常量值进行非迭代二分查找的概要框架。这是编译器用来实现来自[清单 20-2](ch20.xhtml#exa20_2)的`switch`语句的粗略框架。'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 20-3: Non-iterative binary search through a fixed number of constant
    values*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 20-3：通过固定数量常量值进行非迭代二分查找*'
- en: Compilers are also capable of performing more fine-grained optimizations across
    a range of case labels. For example, when confronted with the case labels
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还能够在一系列 case 标签之间执行更精细的优化。例如，当面对 case 标签时，
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: a less aggressive compiler might see a density of 0.0015 here and generate a
    binary search through all 15 cases. A more aggressive compiler might emit a jump
    table to resolve cases 1 to 8, and a binary search for the remaining cases, achieving
    optimal performance for over half of the cases.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么激进的编译器可能会看到 0.0015 的密度，并对所有 15 个 case 进行二分查找。而一个更激进的编译器可能会生成一个跳转表来解决 case
    1 到 8，并对剩余的 case 进行二分查找，从而实现对超过一半 case 的最佳性能。
- en: Before we look at the disassembled versions of [Listings 20-1](ch20.xhtml#exa20_1)
    and [20-2](ch20.xhtml#exa20_2), let’s look at the Ghidra Function Graph windows
    corresponding to the listings, shown side by side in [Figure 20-1](ch20.xhtml#fig20_1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看[清单 20-1](ch20.xhtml#exa20_1)和[清单 20-2](ch20.xhtml#exa20_2)的反汇编版本之前，先来看看与这些清单对应的
    Ghidra 函数图窗口，两个窗口并排显示在[图 20-1](ch20.xhtml#fig20_1)中。
- en: '![image](Images/fig20-1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-1.jpg)'
- en: '*Figure 20-1: Ghidra Function Graph* `switch` *statement examples*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-1：Ghidra 函数图* `switch` *语句示例*'
- en: On the left, the graph for [Listing 20-1](ch20.xhtml#exa20_1) shows a nice vertical
    stack of cases. Each stacked code block resides at the same nesting depth, as
    is true for cases in a `switch` statement. The stack suggests that we can use
    an index to quickly select one block from the many (think array access). This
    is precisely how jump table resolution works, and the left-hand graph provides
    us with a visual hint that this is the case, even before we have looked at a single
    line of the disassembly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，[清单 20-1](ch20.xhtml#exa20_1)的图表显示了一个整齐的垂直堆叠的 case。每个堆叠的代码块位于相同的嵌套深度，这正是`switch`语句中的
    case 的特点。该堆叠表明我们可以使用索引快速从多个块中选择一个（类似数组访问）。这正是跳转表解析的工作原理，左侧的图表为我们提供了一个视觉提示，表明这一点，即使我们还没有查看反汇编的任何一行代码。
- en: The right-hand graph is Ghidra’s result based solely on its understanding of
    the disassembly of [Listing 20-2](ch20.xhtml#exa20_2). The lack of a jump table
    makes it much more challenging to identify this as a `switch` statement. What
    you are seeing is a visual representation of the `switch` statement using Ghidra’s
    Nested Code Layout. This is the default layout for function graphs in Ghidra and
    is intended to represent the flow structures in a program. The horizontal branching
    in this graph suggests conditional execution (`if`/`else`) branching to mutually
    exclusive alternatives. The vertical symmetry suggests that the alternative execution
    paths have been very carefully balanced to place equal numbers of blocks in each
    vertical half of the graph. Finally, the distance that the graph traverses horizontally
    is an indicator of the depth reached by the search, which in turn is dictated
    by the total number of case labels present in the `switch`. For a binary search,
    this depth will always be on the order of `log[2]``(num_cases)`. The similarity
    between the indentation of the graphical representation and the algorithm outlined
    in [Listing 20-3](ch20.xhtml#exa20_3) is easily observable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图形是Ghidra仅根据其对[示例 20-2](ch20.xhtml#exa20_2)反汇编结果的理解所得到的结果。由于缺少跳转表，这使得识别`switch`语句变得更加困难。你看到的是使用Ghidra的嵌套代码布局的`switch`语句的可视化表示。这是Ghidra中函数图形的默认布局，旨在表示程序中的流程结构。图中的水平分支表示条件执行（`if`/`else`）分支到互斥的替代路径。垂直对称性表明，替代执行路径被非常仔细地平衡，确保图形的每个垂直半部分中包含相等数量的块。最后，图形水平遍历的距离是搜索深度的指示器，这又由`switch`中存在的总案例标签数量决定。对于二分查找，这个深度通常是`log[2]``(num_cases)`的数量级。图形表示的缩进与[示例
    20-3](ch20.xhtml#exa20_3)中概述的算法之间的相似性很容易观察到。
- en: Turning our attention to the Decompiler window, [Figure 20-2](ch20.xhtml#fig20_2)
    shows the partial decompilation of the functions displayed in [Figure 20-1](ch20.xhtml#fig20_1).
    On the left is the decompiled version of [Listing 20-1](ch20.xhtml#exa20_1). As
    with the graph, the presence of a jump table in the binary helps Ghidra identify
    the code as a `switch` statement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向反编译窗口，[图 20-2](ch20.xhtml#fig20_2)显示了[图 20-1](ch20.xhtml#fig20_1)中展示的函数的部分反编译结果。左侧是[示例
    20-1](ch20.xhtml#exa20_1)的反编译版本。与图形一样，二进制文件中存在跳转表有助于Ghidra将代码识别为`switch`语句。
- en: On the right is the decompiled version of [Listing 20-2](ch20.xhtml#exa20_2).
    The decompiler has presented the `switch` statement as a nested `if`/`else` structure
    consistent with a binary search, and similar in structure to [Listing 20-3](ch20.xhtml#exa20_3).
    You can see that first comparison is against 719, the median value in the list,
    and that subsequent comparisons continue to divide the search space in half. Referring
    to [Figure 20-1](ch20.xhtml#fig20_1) (as well as [Listing 20-3](ch20.xhtml#exa20_3)),
    we can again observe that the graphical representations of each function closely
    correspond to the indentation patterns observed in the Decompiler window.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧是[示例 20-2](ch20.xhtml#exa20_2)的反编译版本。反编译器将`switch`语句呈现为与二分查找一致的嵌套`if`/`else`结构，且结构与[示例
    20-3](ch20.xhtml#exa20_3)类似。你可以看到，第一次比较是与719进行的，这是列表中的中位数，随后的比较则继续将搜索空间对半分。参考[图
    20-1](ch20.xhtml#fig20_1)（以及[示例 20-3](ch20.xhtml#exa20_3)），我们可以再次观察到，每个函数的图形表示与反编译窗口中观察到的缩进模式紧密对应。
- en: Now that you have an idea of what is happening from a high level, let’s look
    inside the binaries and investigate what is happening at a low level. Since our
    objective in this chapter is to observe differences between compilers, we present
    this example as a series of comparisons between two compilers, `gcc` and Microsoft
    C/C++.^([6](footnotes.xhtml#ch20fn6))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对高层的情况有了了解，我们来看一下二进制文件，调查低层发生了什么。由于本章的目标是观察编译器之间的差异，我们将这个例子呈现为`gcc`与微软C/C++编译器之间的比较系列。^([6](footnotes.xhtml#ch20fn6))
- en: '![image](Images/fig20-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-2.jpg)'
- en: '*Figure 20-2: Ghidra decompiled* `switch` *statement examples*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-2：Ghidra反编译的* `switch` *语句示例*'
- en: '***Example: Comparing gcc with Microsoft C/C++ Compiler***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例：比较gcc与微软C/C++编译器***'
- en: 'In this example, we compare two 32-bit x86 binaries generated for [Listing
    20-1](ch20.xhtml#exa20_1) by two distinct compilers. We will attempt to identify
    components of a `switch` statement in each binary, locate the associated jump
    table in each binary, and point out significant differences between the two binaries.
    Let’s start by looking at the `switch`-related components for [Listing 20-1](ch20.xhtml#exa20_1)
    in the binary built with `gcc`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们比较了为[清单20-1](ch20.xhtml#exa20_1)生成的两个32位x86二进制文件，这两个文件分别由两个不同的编译器生成。我们将尝试识别每个二进制文件中的`switch`语句组件，定位每个二进制文件中的相关跳转表，并指出这两个二进制文件之间的重要差异。让我们从查看使用`gcc`构建的二进制文件中的[清单20-1](ch20.xhtml#exa20_1)的`switch`相关组件开始。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ghidra recognizes the switch bounds test ➊, the jump table ➍, and individual
    case blocks by value, such as the one at `switchD_00010771::caseD_1` ➌. The compiler
    generated a jump table with 13 entries, although [Listing 20-1](ch20.xhtml#exa20_1)
    contained only 12 cases. The additional case, case 0 (the first entry ➎ in the
    jump table), shares a target address with every value outside the range 1 to 12\.
    In other words, case 0 is part of the default case. While it may seem that negative
    numbers are being excluded from the default, the `CMP,` `JA` sequence works as
    a comparison on unsigned values; thus, `-1` (`0xFFFFFFFF`) would be seen as `4294967295`,
    which is much larger than 12 and therefore excluded from the valid range for indexing
    the jump table. The `JA` instruction directs all such cases to the default location:
    `switchD_00010771::caseD_0` ➋.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra识别`switch`边界测试 ➊，跳转表 ➍，以及通过值区分的单个`case`块，例如`switchD_00010771::caseD_1`
    ➌。在编译时，生成了一个包含13个条目的跳转表，尽管[清单20-1](ch20.xhtml#exa20_1)中只有12个`case`。额外的`case`，即`case
    0`（跳转表中的第一个条目 ➎），与值范围1到12以外的所有值共享目标地址。换句话说，`case 0`是默认`case`的一部分。尽管看起来负数被排除在默认情况之外，但`CMP`、`JA`指令序列实际上对无符号值进行比较；因此，`-1`（`0xFFFFFFFF`）会被视为`4294967295`，这个值远大于12，因此被排除在有效范围之外，无法用来索引跳转表。`JA`指令将所有这些情况引导至默认位置：`switchD_00010771::caseD_0`
    ➋。
- en: 'Now that we understand the basic components of the code generated by the `gcc`
    compiler, let’s shift our focus to the same components in code generated by the
    Microsoft C/C++ compiler in debug mode:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了由`gcc`编译器生成的代码的基本组件，接下来我们将注意力转向微软C/C++编译器在调试模式下生成的代码中的相同组件：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `switch` variable (`local_d4` in this case) is decremented ➊ to shift
    the range of valid values from 0 to 11 ➋, eliminating the need for a dummy table
    entry for the value 0\. As a result, the first entry (or 0 index entry) in the
    jump table ➌ actually refers to the code for switch case 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`switch`变量（在此案例中为`local_d4`）被递减 ➊，以将有效值的范围从0变为11 ➋，从而不再需要为值0创建一个虚拟的表项。因此，跳转表中的第一个条目（即索引为0的条目）实际上指向的是`switch`语句的第1个分支。
- en: Another, perhaps more subtle difference between the two listings is the location
    of the jump table within the file. The `gcc` compiler places switch jump tables
    in the read-only data (`.rodata`) section of the binary, providing a logical separation
    between the code associated with the `switch` statement and the data required
    to implement the jump table. The Microsoft C/C++ compiler, on the other hand,
    inserts jump tables into the `.text` section, immediately following the function
    containing the associated `switch` statement. Positioning the jump table in this
    manner has little effect on the behavior of the program. In this example, Ghidra
    is able to recognize the `switch` statements for both compilers and uses the term
    `switch` within the associated labels.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能更微妙的区别是跳转表在文件中的位置。`gcc`编译器将`switch`跳转表放置在二进制文件的只读数据（`.rodata`）部分，从而在与`switch`语句相关的代码和实现跳转表所需的数据之间提供了逻辑上的分离。另一方面，微软C/C++编译器将跳转表插入到`.text`部分，紧接着包含相关`switch`语句的函数之后。这种跳转表的定位对程序的行为几乎没有影响。在这个例子中，Ghidra能够识别两种编译器生成的`switch`语句，并在相关标签中使用`switch`一词。
- en: One of the key points here is that there is no single correct way to compile
    source to assembly. As a result, you cannot assume that something is not a `switch`
    statement simply because Ghidra fails to label it as such. Understanding the `switch`
    statement characteristics that factor into the compiler implementation can help
    you make a more accurate inference about the original source code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个关键点是，没有单一的正确方式将源代码编译成汇编代码。因此，你不能仅仅因为Ghidra没有将某个部分标记为`switch`语句，就假设它不是`switch`语句。理解`switch`语句的特点，这些特点会影响编译器的实现，能够帮助你更准确地推断出原始源代码。
- en: '**Compiler Build Options**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编译器构建选项**'
- en: A compiler converts high-level code that solves a particular problem into low-level
    code that solves the same problem. Multiple compilers may solve the same problem
    in rather different ways. Further, a single compiler may solve a problem very
    differently based on the associated compiler options. In this section, we look
    at the assembly language code that results from using different compilers and
    different command line options. (Some differences will have a clear explanation;
    others will not.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将解决特定问题的高级代码转换为解决相同问题的低级代码。多个编译器可能采用截然不同的方式来解决同一问题。此外，同一个编译器可能会根据相关的编译器选项以非常不同的方式来解决一个问题。在本节中，我们将查看使用不同编译器和不同命令行选项时生成的汇编语言代码。（一些差异有明确的解释；另一些则没有。）
- en: Microsoft’s Visual Studio can build either debug or release versions of program
    binaries.^([7](footnotes.xhtml#ch20fn7)) To see how the two versions are different,
    compare the build options specified for each. Release versions are generally optimized,
    while debug versions are not, and debug versions are linked with additional symbol
    information and debugging versions of the runtime library, while release versions
    are not.^([8](footnotes.xhtml#ch20fn8)) Debugging-related symbols allow debuggers
    to map assembly language statements back to their source code counterparts and
    to determine the names of local variables (such information is otherwise lost
    during the compilation process). The debugging versions of Microsoft’s runtime
    libraries have also been compiled with debugging symbols included, optimizations
    disabled, and additional safety checks enabled to verify that some function parameters
    are valid.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 的 Visual Studio 可以构建程序二进制文件的调试版本或发布版本。^([7](footnotes.xhtml#ch20fn7))
    要了解这两种版本的区别，可以对比它们各自的构建选项。发布版本通常会经过优化，而调试版本则不会，调试版本会链接附加的符号信息和调试版本的运行时库，而发布版本则不会。^([8](footnotes.xhtml#ch20fn8))
    与调试相关的符号使调试器能够将汇编语言语句映射回源代码，并确定局部变量的名称（否则此类信息在编译过程中会丢失）。Microsoft 运行时库的调试版本还包括了调试符号、禁用了优化，并启用了额外的安全检查，以验证某些函数参数的有效性。
- en: When disassembled using Ghidra, debug builds of Visual Studio projects look
    significantly different from release builds. This is a result of compiler and
    linker options specified only in debug builds, such as basic runtime checks (`/RTCx`),
    which introduce extra code into the resulting binary.^([9](footnotes.xhtml#ch20fn9))
    Let’s jump right in and look at some of these differences in disassemblies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ghidra 反汇编时，Visual Studio 项目的调试版本与发布版本看起来有显著不同。这是由于仅在调试版本中指定的编译器和链接器选项所导致的，例如基本的运行时检查（`/RTCx`），这些选项会在生成的二进制文件中引入额外的代码。^([9](footnotes.xhtml#ch20fn9))
    让我们直接进入，看看这些反汇编中的一些差异。
- en: '***Example 1: Modulo Operator***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 1：取模运算符***'
- en: 'We begin our examples with a simple mathematical operation, modulo. The following
    listing contains the source code for a program whose only goal is to accept an
    integer value from the user and demonstrate integer division and the modulo operator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个简单的数学运算——取模作为示例。以下列出了一个程序的源代码，该程序的唯一目标是接受用户输入的整数值，并演示整数除法和取模运算符：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s investigate how the disassembly varies across compilers for the modulo
    operator in this example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一下不同编译器在处理此示例中的取模运算符时，反汇编是如何变化的。
- en: '##### **Modulo with Microsoft C/C++ Win x64 Debug**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **使用 Microsoft C/C++ Win x64 调试版本的取模**'
- en: 'The following listing shows the code that Visual Studio generates when configured
    to build a debug version of the binary:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了当配置为构建调试版本的二进制文件时，Visual Studio 生成的代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A straightforward x86 `IDIV` instruction ➊ leaves the quotient in `EAX` and
    the remainder of the division in `EDX`. The result is then moved to lower 32 bits
    of `R8` (`R8D`) ➋, which is the third argument in the call to `printf`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接的x86 `IDIV` 指令 ➊ 将商保存在 `EAX` 寄存器中，余数保存在 `EDX` 寄存器中。结果随后被移动到 `R8` 的低32位（`R8D`）
    ➋，这是调用 `printf` 函数时的第三个参数。
- en: '**Modulo with Microsoft C/C++ Win x64 Release**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Microsoft C/C++ Win x64 发布版本的取模**'
- en: 'Release builds optimize software for speed and size in order to enhance performance
    and minimize storage requirements. When optimizing for speed, compiler writers
    may resort to non-obvious implementations of common operations. The following
    listing shows us how Visual Studio generates the same modulo operation in a release
    binary:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 发布版本通过优化软件的速度和大小来提高性能并最小化存储需求。在优化速度时，编译器作者可能会采用一些不明显的常见操作实现方式。以下列表展示了Visual
    Studio如何在发布二进制文件中生成相同的取模操作：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, multiplication ➊ is used rather than division, and after a long
    sequence of arithmetic operations, what must be the result of the modulo operation
    ends up in `R8D` ➋ (again the third argument in the call to `printf` ➌). Intuitive,
    right? An explanation of this code follows our next example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用的是乘法➊而不是除法，经过一长串算术操作，最终模运算的结果被存储在`R8D`中➋（同样是`printf`调用中的第三个参数➌）。直观吧？接下来我们将通过下一个示例来解释这段代码。
- en: '**Modulo with gcc for Linux x64**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Linux x64 的 gcc 模运算**'
- en: 'We’ve seen how differently one compiler can behave simply by changing the compile-time
    options used to generate a binary. We might expect that a completely unrelated
    compiler would generate entirely different code yet again. The following disassembly
    shows us the `gcc` version of the same modulus operation, and it turns out to
    look somewhat familiar:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过仅仅改变编译时选项，编译器的行为可以有很大的不同。我们可能会期望一个完全不同的编译器会生成完全不同的代码。以下的反汇编展示了相同模运算的`gcc`版本，结果看起来有些熟悉：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code is very similar to the assembly produced by the Visual Studio release
    version. We again see multiplication ➊ rather than division followed by a sequence
    of arithmetic operations that eventually leaves the result in `EDX` ➋ (where it
    is eventually used as the third argument to `printf`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 Visual Studio 发布版生成的汇编非常相似。我们再次看到的是乘法➊而不是除法，后面跟着一系列算术操作，最终结果存储在`EDX`中➋（最终作为`printf`的第三个参数）。
- en: The code is using a multiplicative inverse to perform division by multiplying
    because hardware multiplication is faster than hardware division. You may also
    see multiplication implemented using a series of additions and arithmetic shifts,
    as each of these operations is significantly faster in hardware than multiplication.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用乘法逆运算来执行除法，因为硬件乘法比硬件除法更快。你也可能看到乘法是通过一系列加法和算术移位来实现的，因为这些操作在硬件中比乘法显著更快。
- en: Your ability to recognize this code as modulo 10 depends on your experience,
    patience, and creativity. If you’ve seen similar code sequences in the past, you
    are probably more apt to recognize what’s taking place here. Lacking that experience,
    you might instead work through the code manually with sample values, hoping to
    recognize a pattern in the results. You might even take the time to extract the
    assembly language, wrap it in a C test harness, and do some high-speed data generation
    to assist you. Ghidra’s decompiler can be another useful resource for reducing
    complex or unusual code sequences to their more recognizable C equivalents.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将这段代码识别为模 10 运算，取决于你的经验、耐心和创造力。如果你以前见过类似的代码序列，你可能会更容易识别出这里发生的事情。如果缺乏这样的经验，你可能会手动通过样本值来推算代码，希望能从结果中识别出某种模式。你甚至可能花时间提取汇编语言，将其封装在
    C 测试框架中，进行高速数据生成来辅助你。Ghidra 的反编译器也是一个很有用的资源，可以将复杂或不寻常的代码序列简化为更易识别的 C 语言等效代码。
- en: 'As a last resort, or first resort (don’t be ashamed), you might turn to the
    internet for answers. But what should you be searching for? Usually, unique, specific
    searches yield the most relevant results, and the most unique feature in the sequence
    of code is the integer constant `0x66666667`. When we searched for this constant,
    the top three results were all helpful, but one in particular was worth bookmarking:
    *[http://flaviojslab.blogspot.com/2008/02/integer-division.html](http://flaviojslab.blogspot.com/2008/02/integer-division.html)*.
    Unique constants are also used rather frequently in cryptographic algorithms,
    and a quick internet search may be all it takes to identify exactly what crypto
    routine you are staring at.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的手段，或者是第一选择（别害羞），你可能会转向互联网寻找答案。但你应该搜索什么呢？通常，独特且具体的搜索能够带来最相关的结果，而在这段代码序列中，最独特的特征就是整数常量`0x66666667`。当我们搜索这个常量时，排名前三的结果都很有帮助，但其中一个特别值得收藏：[http://flaviojslab.blogspot.com/2008/02/integer-division.html](http://flaviojslab.blogspot.com/2008/02/integer-division.html)*。独特常量在加密算法中也经常使用，快速的互联网搜索可能正是识别你正在查看的加密程序的关键。
- en: '#### ***Example 2: The Ternary Operator***'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***示例 2：三元运算符***'
- en: 'The ternary operator evaluates an expression and then yields one of two possible
    results, depending on the boolean value of that expression. Conceptually, the
    ternary operator can be thought of as an `if`/`else` statement (and can even be
    replaced with an `if`/`else` statement). The following intentionally unoptimized
    source code demonstrates the use of this operator:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符会计算一个表达式，然后根据该表达式的布尔值，返回两种可能结果之一。从概念上讲，三元运算符可以被看作是一个 `if`/`else` 语句（甚至可以用
    `if`/`else` 语句替代）。下面的未经优化的源代码演示了如何使用此运算符：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**NOTE**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The volatile keyword asks the compiler not to optimize code involving the
    associated variables. Without its use here, some compilers will optimize away
    the entire body of this function since none of the statements contribute to the
    function’s result. This is one of the challenges you might face when coding examples
    for yourself or for others.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*`volatile` 关键字要求编译器不要优化涉及相关变量的代码。如果这里没有使用它，一些编译器可能会优化掉整个函数体，因为其中的语句不会影响函数的结果。这是你在为自己或他人编写示例代码时可能遇到的挑战之一。*'
- en: 'As for the behavior of the unoptimized code, the assignment into variable `z`
    ➊ could be replaced with the following `if`/`else` statement without changing
    the semantics of the program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 至于未经优化的代码，赋值给变量 `z` ➊ 可以用以下 `if`/`else` 语句替代，而不改变程序的语义：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s see how the ternary operator code is handled by different compilers and
    different compiler options.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看三元运算符代码是如何被不同编译器和不同编译选项处理的。
- en: '**Ternary Operator with gcc on Linux x64**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**带有 gcc 的三元运算符（Linux x64）**'
- en: '`gcc`, with no options, generated the following assembly for the initialization
    of `z`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc` 在没有选项的情况下，为 `z` 的初始化生成了以下汇编代码：'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code uses the `if`/`else` implementation. Local variable `y` is compared
    to `30` ➊ to decide whether to set `EAX` to `0` or `0xffffffff` in opposing branches
    of the `if`/`else` before assigning the result into `z` ➋.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 `if`/`else` 实现。局部变量 `y` 与 `30` ➊ 进行比较，以决定是将 `EAX` 设置为 `0` 还是 `0xffffffff`，然后在
    `if`/`else` 的不同分支中将结果赋值给 `z` ➋。
- en: '**Ternary Operator with Microsoft C/C++ Win x64 Release**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**带有 Microsoft C/C++ Win x64 发布版的三元运算符**'
- en: 'Visual Studio yields a very different implementation of the statement containing
    the ternary operator. Here, the compiler recognizes that a single instruction
    can be used to conditionally generate either `0` or `-1` (and no other possible
    value) and uses this instruction in lieu of the `if`/`else` construct we saw earlier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 对包含三元运算符的语句进行了非常不同的实现。在这里，编译器识别到可以使用单条指令有条件地生成 `0` 或 `-1`（且没有其他可能的值），并用这条指令替代我们之前看到的
    `if`/`else` 结构：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `SBB` instruction ➌ (*subtract with borrow*) subtracts the second operand
    from the first operand and then subtracts the carry flag, `CF` (which can be only
    0 or 1). The equivalent arithmetic expression to `SBB EAX,EAX` is `EAX – EAX –
    CF`, which reduces to `0 – CF`. This, in turn, can result only in `0` (when `CF
    == 0`) or `-1` (when `CF == 1`). For this trick to work, the compiler must set
    the carry properly prior to executing the `SBB` instruction. This is accomplished
    by comparing `EAX` to the constant `0x1e` (`30`) ➊ using a subtraction that leaves
    `EAX` equal to `0` only when `EAX` was initially `0x1e`. The `NEG` instruction
    ➋ then sets the carry flag for the `SBB` instruction that follows.^([10](footnotes.xhtml#ch20fn10))
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`SBB` 指令 ➌ (*subtract with borrow*，带借位相减) 从第一个操作数中减去第二个操作数，然后减去进位标志 `CF`（它只能是
    0 或 1）。`SBB EAX,EAX` 的等效算术表达式是 `EAX – EAX – CF`，简化为 `0 – CF`。这反过来只能得到 `0`（当 `CF
    == 0` 时）或 `-1`（当 `CF == 1` 时）。为了使这个技巧有效，编译器必须在执行 `SBB` 指令之前正确设置进位标志。这是通过将 `EAX`
    与常量 `0x1e`（即 `30`） ➊ 进行比较实现的，比较操作会使得只有当 `EAX` 初始值为 `0x1e` 时，`EAX` 的值才为 0。接下来的
    `NEG` 指令 ➋ 会为后续的 `SBB` 指令设置进位标志。^([10](footnotes.xhtml#ch20fn10))'
- en: '**Ternary Operator with gcc on Linux x64 (Optimized)**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**带有优化的 gcc 三元运算符（Linux x64）**'
- en: 'When we ask `gcc` to try a little harder by optimizing its code (`-O2`), the
    result is not unlike the Visual Studio code in the previous example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求 `gcc` 通过优化其代码（`-O2`）来稍微加把劲时，结果与前面示例中的 Visual Studio 代码类似：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, `gcc` uses `SETNZ` ➊ to conditionally set the `AL` register to
    either 0 or 1 based on the state of the zero flag resulting from the preceding
    comparison. The result is then negated ➋ to become either `0` or `-1` before assignment
    into variable `z` ➌.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`gcc` 使用 `SETNZ` ➊ 根据前面的比较结果（零标志的状态）有条件地将 `AL` 寄存器设置为 0 或 1。然后，该结果被取反
    ➋，变为 `0` 或 `-1`，并赋值给变量 `z` ➌。
- en: '#### ***Example 3: Function Inlining***'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***示例 3：函数内联***'
- en: When a programmer marks a function `inline`, they are suggesting to the compiler
    that any calls to the function should be replaced with a copy of the entire function
    body. The intent is to speed up the function call by eliminating parameter and
    stack frame setup and teardown. The trade-off is that many copies of an inlined
    function make the binary larger. Inlined functions can be very difficult to recognize
    in binaries because the distinctive `call` instruction is eliminated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员标记一个函数为`inline`时，他们是在向编译器建议，任何对该函数的调用应该被整个函数体的副本所替代。其目的是通过消除参数和堆栈帧的设置与拆卸来加速函数调用。其权衡之处在于，多个副本会使二进制文件变大。内联函数在二进制文件中非常难以识别，因为独特的`call`指令被去除了。
- en: 'Even when the `inline` keyword has not been used, compilers may elect to inline
    a function on their own initiative. In our third example, we are making a call
    to the following function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有使用`inline`关键字，编译器也可能主动决定将一个函数内联。在我们的第三个示例中，我们调用了以下函数：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Function Call with gcc on Linux x86**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Linux x86上使用gcc的函数调用**'
- en: 'After building a Linux x86 binary using `gcc` with no optimizations, we disassemble
    it to see the following listing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`gcc`构建没有优化的Linux x86二进制文件后，我们对其进行反汇编，得到了如下的清单：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can clearly see the call ➊ to the `maybe_inline` function in this disassembly,
    even though it is just a single line of code returning a constant value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到在这个反汇编代码中对`maybe_inline`函数的调用 ➊，尽管它仅是一个返回常量值的单行代码。
- en: '**Optimized Function Call with gcc on Linux x86**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Linux x86上使用gcc优化的函数调用**'
- en: 'Next, we look at an optimized (`-O2`) version of the same source code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下相同源代码的优化（`-O2`）版本：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Contrasting this code with the unoptimized code, we see that the call to `maybe_inline`
    has been eliminated, and the constant value ➊ returned by `maybe_inline` is pushed
    directly onto the stack to be used as an argument for the call to `printf`. This
    optimized version of the function call is identical to what you would see if the
    function had been designated inline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码与未优化的代码进行对比时，我们看到对`maybe_inline`的调用已经被移除，并且`maybe_inline`返回的常量值 ➊ 被直接压入栈中，作为调用`printf`时的参数使用。这个优化后的函数调用与如果该函数被指定为内联时所看到的完全一致。
- en: Having examined some of the ways that optimizations can influence the code generated
    by compilers, let’s turn our attention to the different ways that compiler designers
    choose to implement language-specific features when language designers leave implementation
    details to the compiler writers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视了优化如何影响编译器生成的代码之后，我们接下来将关注编译器设计者在语言设计者将实现细节留给编译器编写者时，选择实现语言特定功能的不同方式。
- en: '**Compiler-Specific C++ Implementation**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**特定编译器的C++实现**'
- en: Programming languages are designed by programmers for programmers. Once the
    dust of the design process has settled, it’s up to compiler writers to build the
    tools that faithfully translate programs written in the new high-level language
    into semantically equivalent machine language programs. When a language permits
    a programmer to do A, B, and C, it’s up to the compiler writers to find a way
    to make these things possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言是程序员为程序员设计的。一旦设计过程尘埃落定，编译器编写者就需要构建工具，将用新高级语言编写的程序忠实地转换为语义上等效的机器语言程序。当一种语言允许程序员执行A、B和C时，编译器编写者的任务是找到一种方法使这些操作成为可能。
- en: 'C++ gives us three excellent examples of behaviors required by the language,
    but whose implementation details were left to the compiler writer to sort out:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C++给了我们三个很好的例子，展示了语言所要求的行为，但其实现细节留给了编译器编写者来解决：
- en: Within a nonstatic member function of a class, programmers may refer to a variable
    named `this`, which is never explicitly declared anywhere. (See [Chapters 6](ch06.xhtml#ch06)
    and [8](ch08.xhtml#ch08) for compilers’ treatment of `this`.)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的非静态成员函数中，程序员可以引用一个名为`this`的变量，而这个变量从未在任何地方显式声明过。（关于编译器如何处理`this`，请参见[第6章](ch06.xhtml#ch06)和[第8章](ch08.xhtml#ch08)）
- en: Function overloading is allowed. Programmers are free to reuse function names
    as often as they like, subject to restrictions on their parameter lists.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载是允许的。程序员可以根据需要自由地重用函数名，但必须遵循其参数列表的限制。
- en: Type introspection is supported through the use of the `dynamic_cast` and `typeid`
    operators.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`dynamic_cast`和`typeid`运算符，支持类型反射。
- en: '***Function Overloading***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数重载***'
- en: Function overloading in C++ allows programmers to name functions identically,
    with the caveat that any two functions that share a name must have different parameter
    sequences. Name mangling, introduced in [Chapter 8](ch08.xhtml#ch08), is the under-the-hood
    mechanism that allows overloading to work by ensuring that no two symbols share
    the same name by the time the linker is asked to do its job.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的函数重载允许程序员为函数命名相同的名称，但有一个前提条件，任何两个共享名称的函数必须具有不同的参数序列。[第8章](ch08.xhtml#ch08)中介绍的名称混淆是一个幕后机制，它通过确保在链接器进行工作时，没有两个符号共享相同的名称，从而使得重载得以实现。
- en: 'Often, one of the earliest signs that you are working with a C++ binary is
    the presence of mangled names. The two most popular name mangling schemes are
    Microsoft’s and the Intel Itanium ABI.^([11](footnotes.xhtml#ch20fn11)) The Intel
    standard has been widely adopted by other Unix compilers such as `g++` and clang.
    The following shows a C++ function name and the mangled version of that name under
    both the Microsoft and Intel schemes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你发现正在处理C++二进制文件时，最早的迹象之一就是出现了混淆的名称。最流行的两种名称混淆方案是微软方案和Intel Itanium ABI方案。^([11](footnotes.xhtml#ch20fn11))
    Intel标准已被其他Unix编译器，如`g++`和clang，广泛采用。以下展示了一个C++函数名以及该名称在微软和Intel方案下的混淆版本：
- en: '**Function** `void SubClass::vfunc1()`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数** `void SubClass::vfunc1()`'
- en: '**Microsoft scheme** `?vfunc1@SubClass@@UAEXXZ`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**微软方案** `?vfunc1@SubClass@@UAEXXZ`'
- en: '**Intel scheme** `_ZN8SubClass6vfunc1Ev`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Intel方案** `_ZN8SubClass6vfunc1Ev`'
- en: Most languages that permit overloading, including Objective-C, Swift, and Rust,
    incorporate some form of name mangling at the implementation level. A passing
    familiarity with name-mangling styles can provide you with clues about a program’s
    original source language as well as the compiler used to build the program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 允许重载的大多数语言，包括Objective-C、Swift和Rust，在实现层面都包含某种形式的名称混淆。对名称混淆样式的简单了解可以为你提供有关程序原始源语言以及用于构建程序的编译器的线索。
- en: '***RTTI Implementations***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RTTI实现***'
- en: In [Chapter 8](ch08.xhtml#ch08), we discussed C++ Runtime Type Identification
    (RTTI) and the lack of a standard for implementing RTTI by a compiler. In fact,
    runtime type identification is not mentioned anywhere in the C++ standard, so
    it should be no surprise that implementations differ. To support the `dynamic_cast`
    operator, RTTI data structures record not only a class’s name, but its entire
    inheritance hierarchy, including any multiple inheritance relationships. Locating
    RTTI data structures can be extremely useful in recovering the object model of
    a program. Automatic recognition of RTTI-related constructs within a binary is
    another area in which Ghidra’s capabilities vary across compilers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#ch08)中，我们讨论了C++运行时类型识别（RTTI）以及编译器实施RTTI的标准缺失。实际上，C++标准中没有提到运行时类型识别，因此，实施方式的差异并不令人惊讶。为了支持`dynamic_cast`操作符，RTTI数据结构不仅记录类的名称，还记录其完整的继承层次结构，包括任何多重继承关系。定位RTTI数据结构在恢复程序的对象模型时非常有用。在二进制文件中自动识别RTTI相关构造是Ghidra在不同编译器间能力差异的另一个领域。
- en: Microsoft C++ programs contain no embedded symbol information, but Microsoft’s
    RTTI data structures are well understood, and Ghidra will locate them when present.
    Any RTTI-related information Ghidra does locate will be summarized in the Symbol
    Tree’s *Classes* folder, which will contain an entry for each class that Ghidra
    locates using its RTTI analyzer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的C++程序不包含嵌入的符号信息，但微软的RTTI数据结构已经被充分理解，Ghidra会在存在时定位它们。Ghidra定位到的任何RTTI相关信息都会在符号树的*Classes*文件夹中汇总，该文件夹将包含每个类的条目，这些类是通过Ghidra的RTTI分析器定位的。
- en: Programs built with `g++` include symbol table information unless they have
    been stripped. For unstripped `g++` binaries, Ghidra relies exclusively on the
    mangled names it finds in the binary, and it uses those names to identify RTTI-related
    data structures and the classes they are associated with. As with Microsoft binaries,
    any RTTI-related information will be included in the Symbol Tree’s *Classes* folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`g++`构建的程序包含符号表信息，除非它们已经被剥离。对于未剥离的`g++`二进制文件，Ghidra完全依赖于它在二进制文件中找到的被混淆的名称，并使用这些名称来识别与RTTI相关的数据结构及其关联的类。与微软的二进制文件一样，任何与RTTI相关的信息都会被包含在符号树的*Classes*文件夹中。
- en: One strategy for understanding how a specific compiler embeds type information
    for C++ classes is to write a simple program that uses classes containing virtual
    functions. After compiling the program, you can load the resulting executable
    into Ghidra and search for instances of strings that contain the names of classes
    used in the program. Regardless of the compiler used to build a binary, one thing
    that RTTI data structures have in common is that they all reference, in some manner,
    a string containing the mangled name of the class that they represent. Using extracted
    strings and data cross-references, it should be possible to locate candidate RTTI-related
    data structures within the binary. The last step is to link a candidate RTTI structure
    back to the associated class’s vftable, which is best accomplished by following
    data cross-references backward from the candidate RTTI structure until a table
    of function pointers (the vftable) is reached. Let’s walk through an example that
    uses this method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 理解编译器如何为 C++ 类嵌入类型信息的一种策略是编写一个简单的程序，使用包含虚函数的类。编译程序后，可以将生成的可执行文件加载到 Ghidra 中，并搜索包含程序中使用的类名的字符串实例。无论使用什么编译器构建二进制文件，RTTI
    数据结构的共同点是它们都以某种方式引用一个包含它们所表示的类的 mangled 名称的字符串。通过提取的字符串和数据交叉引用，应该可以在二进制文件中定位候选的
    RTTI 相关数据结构。最后一步是将候选 RTTI 结构链接回相关类的 vftable，最佳方法是通过从候选 RTTI 结构向后跟踪数据交叉引用，直到找到函数指针表（vftable）。让我们通过一个示例来演示这种方法。
- en: '**Example: Locating RTTI Information in a Linux x86-64 g++ Binary**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例：定位 Linux x86-64 g++ 二进制文件中的 RTTI 信息**'
- en: 'To demonstrate these concepts, we created a small program with a `BaseClass`,
    a `SubClass`, a `SubSubClass`, and a collection of virtual functions unique to
    each. The following listing shows part of the main program we used to reference
    our classes and functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些概念，我们创建了一个包含 `BaseClass`、`SubClass`、`SubSubClass` 以及每个类独有的虚函数的小程序。以下清单展示了我们用于引用类和函数的部分主程序：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We compiled the program using `g++` to build a 64-bit Linux binary with symbols.
    After we analyze the program, the Symbol Tree provides the information shown in
    [Figure 20-3](ch20.xhtml#fig20_3).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `g++` 编译程序，构建了一个包含符号的 64 位 Linux 二进制文件。分析程序后，符号树提供了如 [图 20-3](ch20.xhtml#fig20_3)
    所示的信息。
- en: '![image](Images/fig20-3.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-3.jpg)'
- en: '*Figure 20-3: Symbol Tree classes for an unstripped binary*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-3：未剥离二进制文件的符号树类*'
- en: The *Classes* folder contains entries for all three of our classes. The expanded
    *SubClass* entry reveals additional information that Ghidra has uncovered about
    it. The stripped version of the same binary contains a lot less information, as
    shown in [Figure 20-4](ch20.xhtml#fig20_4).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*Classes* 文件夹包含了我们所有三个类的条目。展开的 *SubClass* 条目揭示了 Ghidra 发现的更多信息。剥离后的版本同一二进制文件包含的信息少得多，如
    [图 20-4](ch20.xhtml#fig20_4) 所示。'
- en: '![image](Images/fig20-4.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-4.jpg)'
- en: '*Figure 20-4: Symbol Tree classes for a stripped binary*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-4：剥离二进制文件的符号树类*'
- en: In this case, we might, incorrectly, assume that the binary contains no C++
    classes of interest, although it is likely a C++ binary based on the reference
    to a core C++ class (`basic_ostream`). Since stripping removes only symbol information,
    we may still be able to find RTTI information by searching for class names in
    the program’s strings and walking our way back to any RTTI data structure. A string
    search yields the results shown in [Figure 20-5](ch20.xhtml#fig20_5).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会错误地认为二进制文件中没有值得关注的 C++ 类，尽管基于对一个核心 C++ 类（`basic_ostream`）的引用，它很可能是一个
    C++ 二进制文件。由于剥离操作仅去除符号信息，我们仍然可以通过在程序的字符串中搜索类名，逆向跟踪到任何 RTTI 数据结构来查找 RTTI 信息。字符串搜索的结果如
    [图 20-5](ch20.xhtml#fig20_5) 所示。
- en: '![image](Images/fig20-5.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-5.jpg)'
- en: '*Figure 20-5: String Search results revealing class names*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-5：字符串搜索结果显示类名*'
- en: 'If we click the `"8SubClass"` string, we are taken to this portion of the Listing
    window:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 `"8SubClass"` 字符串，就会跳转到列出窗口中的这一部分：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `g++` binaries, RTTI-related structures contain references to the corresponding
    class name string. If we follow the cross-reference on the first line to its source,
    we arrive at the following section of the disassembly listing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `g++` 二进制文件中，RTTI 相关的结构包含对相应类名字符串的引用。如果我们沿着第一行的交叉引用追溯到其来源，就可以看到以下反汇编清单部分：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The source of the cross-reference ➍ is the second field within `SubClass`’s
    `typeinfo` structure, which starts at address `00301d18` ➌. Unfortunately, unless
    you are willing to dive into the source code for `g++`, structure layouts like
    this are just something you need to learn by experience. Our last remaining task
    is to locate `SubClass`’s vftable. In this example, if we follow the lone cross-reference
    to the `typeinfo` structure that originates from a data region ➋ (the other cross-reference
    ➊ originates from a function and can’t possibly be the vftable), we hit a dead
    end. A little math tells us that the cross-reference originates from the location
    immediately preceding the `typeinfo` struct (`00301d18` – `8` == `00301d10`).
    Under normal circumstances, a cross-reference would exist from the vftable to
    the `typeinfo` structure; however, lacking symbols, Ghidra fails to create that
    reference. Since we know that another pointer to our `typeinfo` structure must
    exist somewhere, we can ask Ghidra for help. With the cursor positioned at the
    start of the structure ➌, we can use the menu option Search ▸ For Direct References,
    which asks Ghidra to find the current address in memory for us. The results are
    shown in [Figure 20-6](ch20.xhtml#fig20_6).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用的源代码 ➍ 是`SubClass`的`typeinfo`结构中的第二个字段，它从地址`00301d18` ➌开始。不幸的是，除非你愿意深入研究`g++`的源代码，否则像这样的结构布局只是需要通过经验来学习。我们最后的任务是定位`SubClass`的vftable。在这个例子中，如果我们追踪到来源于数据区域
    ➋ 的孤立交叉引用到`typeinfo`结构（另一个交叉引用 ➊ 来自一个函数，显然不可能是vftable），我们会碰到死胡同。简单的数学运算告诉我们，交叉引用源自于`typeinfo`结构前面的地址（`00301d18`
    – `8` == `00301d10`）。在正常情况下，vftable到`typeinfo`结构应该存在交叉引用；然而，由于缺少符号，Ghidra未能创建该引用。由于我们知道，另一个指向我们`typeinfo`结构的指针必须存在某个地方，我们可以请求Ghidra的帮助。在结构的开始位置
    ➌，将光标定位后，我们可以使用菜单选项“搜索 ▸ 寻找直接引用”，让Ghidra为我们找到当前内存地址。搜索结果如[图20-6](ch20.xhtml#fig20_6)所示。
- en: '![image](Images/fig20-6.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig20-6.jpg)'
- en: '*Figure 20-6: Results of direct reference search*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-6：直接引用搜索结果*'
- en: 'Ghidra has found two additional references to this `typeinfo` structure. Investigating
    each of them finally leads us to a vftable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra找到了两个额外的引用指向这个`typeinfo`结构。对每个引用进行调查，最终我们找到了一个vftable：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ghidra has not formatted the source ➊ of the `typeinfo` cross-reference as a
    pointer (which explains the lack of a cross-reference), but it does provide an
    EOL comment that hints at it being a pointer ➋. The vftable itself begins 8 bytes
    later ➌ and contains five pointers to virtual functions belonging to `SubClass`.
    The table contains no mangled names because the binary has been stripped.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra没有将`typeinfo`交叉引用的源代码➊格式化为指针（这解释了为何没有交叉引用），但它确实提供了一个行尾注释，暗示它是一个指针➋。虚拟函数表（vftable）本身在8个字节后开始➌，并包含指向`SubClass`所属的五个虚拟函数的指针。该表中没有经过名称修饰的名字，因为二进制文件已经被剥离。
- en: In the next section, we apply this “follow the bread crumbs” analysis technique
    to help identify the `main` function in C binaries generated by several compilers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将应用这种“追踪面包屑”分析技术，帮助识别由几个编译器生成的C语言二进制文件中的`main`函数。
- en: '**Locating the main Function**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定位main函数**'
- en: From a programmer’s perspective, program execution typically begins with the
    `main` function, so it’s not a bad strategy to start analyzing a binary from the
    `main` function. However, compilers and linkers (and the use of libraries) add
    code that executes before `main` is reached. Thus, it’s often inaccurate to assume
    that the entry point of a binary corresponds to the `main` function written by
    the program’s author. In fact, the notion that all programs have a `main` function
    is a C/C++ compiler convention rather than a hard-and-fast rule for writing programs.
    If you have ever written a Windows GUI application, you may be familiar with the
    `WinMain` variation on `main`. Once you step away from C/C++, you may find that
    other languages use other names for their primary entry-point function. We refer
    to this function generically as the `main` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，程序执行通常从`main`函数开始，因此从`main`函数着手分析一个二进制文件并不是一个坏策略。然而，编译器和链接器（以及库的使用）会添加在到达`main`之前执行的代码。因此，假设二进制文件的入口点就是程序作者编写的`main`函数往往是不准确的。事实上，所有程序都有`main`函数的这一概念其实是C/C++编译器的一种约定，而不是编写程序的硬性规定。如果你曾经编写过Windows
    GUI应用程序，你可能对`main`函数的变体`WinMain`有所了解。一旦你离开C/C++，你会发现其他语言为其主入口函数使用了不同的名称。我们通常将这个函数泛称为`main`函数。
- en: If there is a symbol named `main` in your binary, you can simply ask Ghidra
    to take you there, but if you happen to be analyzing a stripped binary, you will
    be dropped at the file header and have to find `main` on your own. With a little
    understanding of how executables operate, and a little experience, this shouldn’t
    prove too daunting a task.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的二进制文件中有一个名为 `main` 的符号，你可以直接让 Ghidra 带你去该位置，但如果你正分析一个被剥离的二进制文件，你将会被直接带到文件头部，然后必须自己找到
    `main`。只要稍微理解一下可执行文件的工作原理，并积累一些经验，这个任务不应该太难。
- en: All executables must designate an address within the binary as the first instruction
    to execute after the binary file has been mapped into memory. Ghidra refers to
    this address as `entry` or `_start`, depending on the file type and the availability
    of symbols. Most executable file formats specify this address within the file’s
    header region, and Ghidra loaders know exactly how to find it. In an ELF file,
    the entry point address is specified in a field named `e_entry`, while PE files
    contain a field named `AddressOfEntryPoint`. A compiled C program, regardless
    of the platform the executable is running on, has code at the entry point, inserted
    by the compiler, to make the transition from a brand-new process to a running
    C program. Part of this transition involves ensuring that arguments and environment
    variables provided to the kernel at process creation are gathered and provided
    to `main` utilizing the C calling convention.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可执行文件都必须指定一个地址，该地址是二进制文件映射到内存后执行的第一条指令。Ghidra 将这个地址称为 `entry` 或 `_start`，具体取决于文件类型和符号的可用性。大多数可执行文件格式在文件的头部区域指定此地址，Ghidra
    加载器能准确找到它。在 ELF 文件中，入口点地址在名为 `e_entry` 的字段中指定，而 PE 文件则包含名为 `AddressOfEntryPoint`
    的字段。无论可执行文件运行在哪个平台，编译后的 C 程序在入口点处都有代码，由编译器插入，用于将进程从刚创建的状态转换为正在运行的 C 程序。这一过渡的一部分是确保内核在创建进程时提供的参数和环境变量被收集并传递给
    `main`，并使用 C 调用约定。
- en: '**NOTE**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Your operating system kernel neither knows nor cares in what language any
    executable was written. Your kernel knows exactly one way to pass parameters to
    a new process, and that way may not be compatible with your program’s entry function.
    It is the compiler’s job to bridge this gap.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的操作系统内核既不知道也不关心任何可执行文件是用什么语言编写的。你的内核仅知道一种将参数传递给新进程的方式，而这种方式可能与程序的入口函数不兼容。这正是编译器的任务，它负责弥合这一差距。*'
- en: Now that we know that execution begins at a published entry point and eventually
    reaches the `main` function, we can take a look at some compiler-specific code
    for effecting this transition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道执行从一个公开的入口点开始，并最终到达 `main` 函数，我们可以查看一些编译器特定的代码，了解如何实现这一过渡。
- en: '***Example 1: _start to main with gcc on Linux x86-64***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 1：在 Linux x86-64 上使用 gcc 从 _start 到 main***'
- en: 'By examining the start code in an unstripped executable, we can learn exactly
    how `main` is reached for a given compiler on a given operating system. Linux
    `gcc` offers one of the simpler approaches for this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查未剥离的可执行文件中的启动代码，我们可以确切了解在给定操作系统上，如何通过特定的编译器到达 `main`。Linux `gcc` 提供了一个相对简单的方法：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The address of `main` is loaded into `RDI` ➊ immediately before a call ➋ is
    made to a library function named `__libc_start_main`, which means that the address
    of `main` is passed as the first argument to `__libc_start_main`. Armed with this
    knowledge, we can easily locate `main` in a stripped binary. The following listing
    shows the lead-up to the call to `__libc_start_main` in a stripped binary:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 的地址在调用到名为 `__libc_start_main` 的库函数之前，会被加载到 `RDI` ➊ 中，这意味着 `main` 的地址作为第一个参数传递给了
    `__libc_start_main`。掌握了这个信息后，我们就可以轻松地在剥离的二进制文件中定位到 `main`。以下是剥离二进制文件中调用 `__libc_start_main`
    的前导代码：'
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Though the code contains references to three generically named functions, we
    conclude that `FUN_0040080a` must be `main` because it is being passed as the
    first argument to `__libc_start_main` ➊.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码中引用了三个命名通用的函数，但我们可以得出结论，`FUN_0040080a` 必定是 `main`，因为它作为第一个参数传递给了 `__libc_start_main`
    ➊。
- en: '***Example 2: _start to main with clang on FreeBSD x86-64***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 2：在 FreeBSD x86-64 上使用 clang 从 _start 到 main***'
- en: On current versions of FreeBSD, clang is the default C compiler, and the `_start`
    function is somewhat more substantial and harder to follow than the simple Linux
    `_start` stub. To keep things simple, we’ll use Ghidra’s decompiler to look at
    the tail end of `_start`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 FreeBSD 中，clang 是默认的 C 编译器，并且 `_start` 函数比简单的 Linux `_start` 存根要更为复杂，且更难以跟踪。为了简化操作，我们将使用
    Ghidra 的反编译器来查看 `_start` 的尾部。
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this case, `main` is the penultimate function called in `_start`, and the
    return value from `main` is immediately passed to `exit` to terminate the program.
    Using Ghidra’s decompiler on a stripped version of the same binary yields the
    following listing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`main`是`_start`中倒数第二个被调用的函数，`main`的返回值立即传递给`exit`以终止程序。使用Ghidra的反编译器对相同二进制文件的剥离版本进行反编译，得到以下列表：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once again, we can pick `main` ➊ out of the crowd, even when the binary has
    been stripped. If you are wondering why this listing shows two function names
    that have not been stripped, the reason is that this particular binary is dynamically
    linked. The functions `atexit` and `exit` are not symbols in the binary; they
    are external dependencies. These external dependencies remain, even after stripping,
    and continue to be visible in the decompiled code. The corresponding code for
    a statically linked, stripped version of this binary is shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们可以从人群中挑选出`main` ➊，即使二进制文件已经被剥离。如果你想知道为什么这个列表显示了两个没有被剥离的函数名，原因是这个特定的二进制文件是动态链接的。`atexit`和`exit`这两个函数并不是二进制中的符号；它们是外部依赖。这些外部依赖即使在剥离后仍然存在，并且在反编译后的代码中仍然可见。下面展示的是这个二进制文件的静态链接、剥离版本的相应代码：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***Example 3: _start to main with Microsoft’s C/C++ compiler***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 3：Microsoft C/C++编译器的_start到main***'
- en: The Microsoft C/C++ compiler’s startup stub is a bit more complicated because
    the primary interface to the Windows kernel is via *kernel32.dll* (rather than
    *libc* on most Unix systems), which provides no C library functions. As a result,
    the compiler often statically links many C library functions directly into executables.
    The startup stub uses these and other functions to interface with the kernel to
    set up your C program’s runtime environment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的C/C++编译器的启动存根要复杂一些，因为Windows内核的主要接口是通过*kernel32.dll*（而不是大多数Unix系统上的*libc*）提供的，它不提供C库函数。因此，编译器通常会将许多C库函数静态链接到可执行文件中。启动存根使用这些函数以及其他函数与内核交互，以设置C程序的运行时环境。
- en: 'However, in the end, the startup stub still needs to call `main` and exit after
    it returns. Tracking down `main` among all of the startup code is usually a matter
    of identifying a three-argument function (`main`) whose return value is passed
    to a one-argument function (`exit`). The following excerpt from this type of binary
    contains calls to the two functions we are looking for:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，启动存根仍然需要在`main`返回后调用`main`并退出。追踪`main`通常是通过识别一个带有三个参数的函数（`main`），其返回值被传递给一个带有一个参数的函数（`exit`）。以下是这种类型的二进制文件的片段，包含了我们正在寻找的两个函数的调用：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `FUN_140001060` ➋ is the three-argument function that turns out to be
    `main`, and `FUN_140002b30` ➌ is the one-argument `exit`. Note that Ghidra has
    been able to recover the name ➊ of one of the statically linked functions called
    by the startup stub because the function matches an FidDb entry. We can use clues
    provided by any identified symbols to save some time in our search for `main`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FUN_140001060` ➋ 是带有三个参数的函数，结果是`main`，而`FUN_140002b30` ➌ 是带有一个参数的`exit`。注意，Ghidra能够恢复启动存根调用的静态链接函数之一的名称
    ➊，因为该函数与FidDb条目匹配。我们可以利用任何已识别符号提供的线索，在寻找`main`时节省一些时间。
- en: '**Summary**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The sheer volume of compiler-specific behaviors is too numerous to cover in
    a single chapter (or even a single book, for that matter). Among other behaviors,
    compilers differ in the algorithms they select to implement various high-level
    constructs and the manner in which they optimize generated code. Because a compiler’s
    behavior is heavily influenced by the arguments supplied to the compiler during
    the build process, it is possible for one compiler to generate radically different
    binaries when fed the same source with different build options selected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器特定行为的数量太多，无法在一章（甚至一本书）中涵盖。除了其他行为外，编译器在实现各种高级结构时选择的算法和优化生成代码的方式各不相同。由于编译器的行为受到构建过程中提供的参数的强烈影响，因此当使用相同的源代码并选择不同的构建选项时，一个编译器可能会生成完全不同的二进制文件。
- en: Unfortunately, coping with all of these variations only comes with experience,
    and it is often very difficult to search for help on specific assembly language
    constructs, as it is very difficult to craft search expressions that will yield
    results applicable to your particular case. When this happens, your best resource
    is generally a forum dedicated to reverse engineering in which you can post code
    and benefit from the knowledge of others who have had similar experiences.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，应对所有这些变体只能通过经验积累，而在特定的汇编语言结构上寻求帮助通常非常困难，因为很难构造出能针对你特定情况产生有效结果的搜索表达式。当这种情况发生时，你最好的资源通常是一个专门讨论逆向工程的论坛，在那里你可以发布代码，并从那些有类似经历的人的知识中受益。
