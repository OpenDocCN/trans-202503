- en: Foreword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, building software and systems is a lot like assembling an IKEA kitchen—on
    your front lawn. People are taking parsers, utilities, and other components originally
    intended for use with trusted data by a person on their own command line, and
    exposing them to the internet. With each new query language and interpreter/parser
    combination (GraphQL being one of the more recent), the old becomes new again.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability classes like denial of service (DoS), injection, information disclosure,
    and authentication/authorization bypasses have persisted in pretty much every
    data format and language parsed with regular expressions over the course of my
    career. Some of this is because inherent weaknesses exist in the underlying technology
    that aren’t well understood by developers of new languages. But it’s more than
    a technology problem that makes these classes of vulnerabilities hard to solve.
    It’s an ecosystem problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, because of the inherent design of the components being exposed
    to the internet, layering security controls on top of them is challenging to do
    without losing functionality or efficiency. Take regular expressions themselves:
    the ability to self-reference and back-reference is what makes them so powerful,
    but that same ability also creates an inherent DoS risk. To parse a statement,
    a regular expression can back-reference or self-reference as many times as necessary.
    Yet for an attacker, *necessary* might mean *until you pay me to stop*.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers can reasonably assume that command line users working on their own
    systems will submit well-formulated requests, designed to end in computationally
    reasonable times. After all, who would DoS themselves, except by accident? But
    that foundational assumption doesn’t hold true on the internet. Even for those
    incredibly rare people who consider and understand how online threats invalidate
    the fundamental design assumptions of the component they’re reusing, compensating
    for a design decision is tricky. More commonly, people don’t even know there’s
    a problem to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Then you have the fact that usability is a thing. Most of our internet-facing
    technology is supposed to be forgiving in the case of errors so that our lowest-common-denominator
    internet users can handle it. It should be autocorrecting so that errors are handled
    gracefully. And, at the same time, that technology needs to be secure against
    the most technically savvy, bored, or determined attackers. No effective self-correcting
    and communicative system can also keep a person from inferring that data is correct
    or has been corrected. A shrewd user with no prior knowledge of the system can
    often infer the data it contains by making a short series of educated guesses
    and abusing the communicative aspects of the technology. This ability to infer
    and then confirm is the source of many subtle information disclosure risks.
  prefs: []
  type: TYPE_NORMAL
- en: In a broader sense, many of the specifications for these data formats and languages
    are insecure as a consequence of the design process. Standards for things like
    PDFs and images often include a mishmash of requirements dictated by the biggest
    vendors at the time that the standard was made. The core specification contains
    what the vendors could agree on, while optional items accommodate each vendor’s
    peculiar features and design decisions. The patchwork created by committees with
    vested interests doesn’t exactly inspire the group to think about security. And
    as data becomes the new currency, committees are almost deliberately adding privacy
    and security risks to standards so that companies can continue to perform data
    collection (and profit accordingly).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, education about these issues is sorely lacking, which brings us back
    to this book. If you’re learning how to attack interpreted query languages and
    data formats for the first time, this book should give you the foundational approaches
    to do more than just hack GraphQL. The same techniques, thought processes, and
    issue classes described in the book will likely serve your career for the next
    decade and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re reading this book to better understand GraphQL (or skimming it in
    the mad rush to prepare for your next assignment), you’ll find it to be a great
    briefing created by two people who have had to do their own fair share of hacking
    and who know the information you’ll need. This includes a useful checklist of
    issues to look out for, insight into a bunch of little gotchas, and GraphQL-specific
    quirks and subtleties that would otherwise take you a lot of time and research
    to uncover.
  prefs: []
  type: TYPE_NORMAL
- en: Nick Aleks and Dolev Farhi have both used this information to break and build
    complex systems, so they can describe the builder’s perspective as well as the
    breaker’s, an angle often missing in hacking books. Their insights into the GraphQL
    ecosystem should help quickly elevate your work beyond *finding the vulnerability*
    and allow you to move to an adversarial simulation or threat-hunting approach.
  prefs: []
  type: TYPE_NORMAL
- en: And if you’re ever working on a new framework, this book will be a great resource
    for helping you change your little part of the ecosystem. By studying common technical
    problems and understanding GraphQL’s ecosystem challenges, hopefully you’ll pick
    up tips on what to avoid and concepts that will translate into more secure design
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Opheliar Chan
  prefs: []
  type: TYPE_NORMAL
- en: OWASP Toronto chapter lead
  prefs: []
  type: TYPE_NORMAL
