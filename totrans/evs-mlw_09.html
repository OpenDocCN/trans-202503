<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">RUNTIME ENVIRONMENT AND VIRTUAL PROCESSOR ANOMALIES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">In the previous three chapters, you’ve seen how malware can query and enumerate OS artifacts and configurations to understand its environment and detect that it’s being analyzed. This chapter will focus on how malware can actively identify analysis sandboxes and VM environments by inspecting the anomalies that malware analysis tools introduce, monitoring virtual processor performance and timing, and abusing virtual processor instructions.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-89"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Analysis and Runtime Anomalies</samp></h3>&#13;
<p class="TNI1">When malware is executed in a sandbox or malware analysis environment, the sandbox or analysis tools can give away their presence in several ways. Sandboxes sometimes rename the malware file to a generic filename, for example. Sandboxes and analysis tools might also inject code into or modify <span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>code in the malware sample to better intercept and analyze the malware’s actions. Some malware variants can detect these anomalies in their runtime environment. Let’s look into these techniques in more detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Run Paths, Filenames, and Arguments</samp></h4>&#13;
<p class="TNI1">When malware is sent to an automated sandbox to be detonated and analyzed, it’s often named something generic such as <i>sample.exe</i> or <i>malware.exe</i> or assigned a hash value like <i>b3126a1de5401048f5a6ea5a9192126fc7482ff0.</i> It might also be run from a generic directory such as <i>C:\Users\&lt;user&gt;\Downloads</i> or <i>C:\Users\&lt;user&gt;\Desktop</i>, rather than the directory the malware author intended, such as a temporary directory. Some malware can identify these anomalies. For example, a malware sample might call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp> function to return its own name or the <samp class="SANS_TheSansMonoCd_W5Regular_11">PathFindFileName</samp> function to return the full path from where it executed. The following sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp> to test whether its filename is blocklisted:</p>&#13;
<pre class="pre-40"><code>push  offset size   ; nSize&#13;
push  offset fileNameBuffer  ; lpFilename&#13;
push  esi; hModule (null)&#13;
<span class="CodeAnnotationHang">1</span> call  GetModuleFileNameA&#13;
<var>--snip--</var>&#13;
loc_21D10:&#13;
push offset blocklist1 ; "malware.exe"&#13;
push fileNameBuffer&#13;
<span class="CodeAnnotationHang">2</span> call wcsstr&#13;
test eax, eax&#13;
jz   short loc_21E12:&#13;
<var>--snip--</var>&#13;
<span class="CodeAnnotationHang">3</span> loc_21E12:&#13;
push offset blocklist2 ; "sample.exe"&#13;
push fileNameBuffer&#13;
call wcsstr&#13;
test eax, eax&#13;
jz   short loc_21F10:</code></pre>&#13;
<p class="TX">This malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileNameA</samp> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> with three parameters: a buffer that will store the returned filename for the malware (<samp class="SANS_TheSansMonoCd_W5Regular_11">fileNameBuffer</samp>), the size of this buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>), and a target module (<samp class="SANS_TheSansMonoCd_W5Regular_11">esi</samp>). The target module, when set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, is the currently running process.</p>&#13;
<p class="TX">Next, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> with two parameters: a blocklisted filename (<samp class="SANS_TheSansMonoCd_W5Regular_11">blocklist1</samp>) and a pointer to the buffer that stores the malware filename returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>. The malware sample then compares its own filename to a blocklist value. If the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, meaning that the returned filename doesn’t match the blocklisted filename, the malware jumps to the next comparison. It continues to iterate through a list of blocklisted filenames <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it finds a match, it assumes it is being analyzed.</p>&#13;
<p class="TX">Instead of using a generic filename, malware sandboxes and analysts sometimes rename the malware file to its hash value—typically in MD5, SHA-1, or SHA256 format. When you download malware from malware <span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>repositories such as VirusTotal, its filename will be in the form of a hash, like <i>b3126a1de5401048f5a6ea5a9192126fc7482ff0</i>. The malware analyst or sandbox may simply append the file type extension to this file before running it: <i>b3126a1de5401048f5a6ea5a9192126fc7482ff0.exe</i>. Hashes have a set number of characters, such as 32 characters for MD5 hashes and 40 characters for SHA-1 hashes. Malware can count the number of characters in its filename, and if there are exactly 32 or 40 (plus the file extension characters), the malware could assume it’s running in an analysis environment.</p>&#13;
<p class="TX">Additionally, malware can inspect its run path and filename and compare those to the original run path and filename intended by the malware author. For example, a malicious Microsoft Word document might attempt to download an executable file from the internet and save it in the <i>C:\Users\&lt;user&gt;\AppData\Roaming</i> directory, with a filename of <i>abc.exe</i>. If a malware analyst were to obtain this executable file without the original Word document and run it from the <i>C:\Users\&lt;user&gt;\Downloads</i> directory with a filename of <i>evil.exe</i>, the malware sample might notice that it was running from an anomalous location with an unknown filename and take evasive actions.</p>&#13;
<p class="TX">Finally, malware may inspect its command line arguments. Certain sandboxes add their own arguments into the malware process, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">-force</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-analysis</samp>, or -<samp class="SANS_TheSansMonoCd_W5Regular_11">debug</samp>. By checking for the presence of these arguments, malware can detect if it’s running inside a sandbox environment and alter its behavior accordingly. A variation of this technique is malware executing only with specific command line arguments. If the malware is executed without them, which might be the case if it’s detonated in an automated sandbox environment, it could cease to fully execute or exhibit different functionalities. For example, the malware sample <i>evil.exe</i> may require the command line argument <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>:</p>&#13;
<pre class="pre-41"><code>C:\&gt; evil.exe do_stuff</code></pre>&#13;
<p class="TX">Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp> argument, the malware may not run correctly in the analysis environment. This technique usually involves a preliminary malware executable or script that executes the primary malware executable with the correct arguments. In this case, you might have to do some manual analysis and reverse engineering to identify the command line arguments the malware is expecting.</p>&#13;
<p class="TX">To bypass many filename and run path evasion checks that malware might use, you can simply rename the file to a random word or phrase and run the file from a directory that malware is often executed from, such as a temp directory (for example, <i>C:\Users\&lt;username&gt;\AppData\Roaming\</i>). It’s important to understand the full attack chain here too: the malware may be looking for a specific filepath or argument, and a quick way to get this path is to investigate all artifacts of the attack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Loaded Modules</samp></h4>&#13;
<p class="TNI1">Certain sandboxes and malware analysis tools load modules into the memory address space of a running malware process to modify the malware’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>behavior or to intercept its code. In this case, a <i>module</i> is typically a DLL file that is loaded (or <i>injected</i>) into a target process for various reasons. To determine which modules are loaded in its memory space, the malware can use Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> to enumerate its loaded modules and identify any anomalies. <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> are used to iterate through all the loaded modules inside the calling process, much like <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> are used to enumerate processes. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>, on the other hand, simply takes a module name as a parameter and returns a handle to the module if it is loaded. Malware can use it to check for a hardcoded list of module names, as shown here:</p>&#13;
<pre class="pre-42"><code>loc_1:&#13;
push offset toolSandboxie; "sbiedll.dll"&#13;
call GetModuleHandleA&#13;
test eax, eax&#13;
jz  loc_2:&#13;
<var>--snip--</var>&#13;
loc_2:&#13;
push offset toolVirtualpc; "vmcheck.dll"&#13;
call GetModuleHandleA&#13;
test eax, eax</code></pre>&#13;
<p class="TX">This malware sample first pushes the address of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"sbiedll.dll"</samp> to the stack, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandleA</samp>. If the returned value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, meaning that this module isn’t loaded into the malware’s memory space, the code jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>, where it uses the same instructions to check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"vmcheck.dll"</samp> module. The two modules this sample is looking for are Sandboxie (<i>sbiedll.dll</i>), a popular sandbox application, and <i>vmcheck.dll</i>, a module that’s often loaded in a Virtual PC guest.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This technique can be used for other reasons, like looking for anti-malware, endpoint detection and response (EDR), and other defense tools; we’ll discuss this in <a href="part4.xhtml">Part IV</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anomalous Strings in Memory</samp></h4>&#13;
<p class="TNI1">When hooking or monitoring malware, analysis sandboxes and tools sometimes leave artifacts in the malware’s process memory space. Malware can enumerate these strings in memory, searching for specific analysis tools and other suspicious behaviors, as demonstrated by this pseudocode:</p>&#13;
<pre class="pre-43"><code>hashedString = "9253221daaf309200fdcec682a987a51c5a5a598";&#13;
ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);&#13;
hashedBuffer = sha1sum(lpbuffer);&#13;
if (memcmp(hashedString, hashedBuffer, sizeof(hashedString)) == 0)&#13;
{&#13;
  TerminateProcess();&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>First, this malware sample defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedString</samp>. This string is simply the SHA-1 hash sum of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">HookLibraryx86.dll</samp>, which I’ll discuss in more detail in a moment. Next, the sample will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> function with several parameters, the most important of which are a handle to a process (<samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>), the base address from which to begin reading memory inside the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddresss</samp>), the buffer that will receive the read memory data (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>), and the number of bytes to be read from memory (<samp class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>). In this case, the process being read from is the malware’s own process. Once the data is read from memory and stored in the buffer, the sample calculates a hash of this data using the SHA-1 algorithm. Finally, the sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp> to compare the hashed buffer data with the original hashed string.</p>&#13;
<p class="TX">Malware can either search its entire memory address space for anomalies or target a specific memory region. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp> value can be any base address within the malware’s process address space.</p>&#13;
<p class="TX">This malware sample’s usage of hashing makes analysis more difficult because we can’t really know what it’s searching for in memory without reversing the hash. <i>HookLibraryx86.dll</i> is a module that is commonly loaded into memory when the tool ScyllaHide is being used to analyze malware. I’ll cover ScyllaHide in more detail in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, but for now, keep in mind that malware can scan its own memory for an anomalous string and obfuscate what it’s searching for to make analysis more difficult.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hooked Functions and Acceleration Checks</samp></h4>&#13;
<p class="TNI1">Automated malware sandboxes and some analysis tools may hook and modify specific functions when running malware to bypass certain evasion attempts. One commonly hooked function is <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>, which malware uses to remain dormant and prevent automated sandboxes from successfully analyzing it (because sandboxes often run for only a few minutes). Sandboxes might modify the parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function to change the sleep time from 5 minutes to 30 seconds, for example. Malware can check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function is being tampered with by “sandwiching” it between two timing-based functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> (this technique is called an <i>acceleration check</i>):</p>&#13;
<pre class="pre-44"><code>call GetTickCount&#13;
mov edi, eax&#13;
push 7530h ; 30,000 ms&#13;
call Sleep&#13;
call GetTickCount&#13;
sub eax, edi&#13;
mov ecx, 7148h ; 29,000&#13;
cmp ecx, eax</code></pre>&#13;
<p class="TX">This malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>, followed by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> for 30,000 milliseconds (30 seconds). Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> a second time, then subtracts the first <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> result from the second and stores the difference in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub eax, edi</samp>). Finally, the malware compares the value in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/><samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to a value of 29,000 milliseconds, which is the minimum length of time that the malware expects should have elapsed. If an automated sandbox or tool has tampered with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> values wouldn’t be proportionate to this expected length of time, tipping the malware off that something is amiss.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-94"/><samp class="SANS_Futura_Std_Bold_B_11">Using Performance and Timing Indicators</samp></h3>&#13;
<p class="TNI1">There can be significant timing and performance deviations between real, non-virtualized processors and their virtualized counterparts. Non-virtualized processors typically execute instructions more quickly and more efficiently than a virtual processor using the same hardware specifications. Most of the time, this isn’t noticeable to the humans interfacing with these systems. Malware, however, can exploit these slight differences to reveal the underlying VM.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The rdtsc Instruction</samp></h4>&#13;
<p class="TNI1">The <i>Read Time-Stamp Counter</i>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>, is a special assembly instruction with a number of use cases, including performance monitoring and metrics gathering. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction is executed on a CPU, the current number of CPU ticks is stored and can be referenced and compared to a later <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction. The difference between the two values is the number of ticks since the first <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction.</p>&#13;
<p class="TX">VMs have a problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction. When <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> is executed by a program running on a virtual processor, the virtual processor must pass this instruction on to the “real” processor: the hardware CPU that runs the host OS. Passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction to the real CPU and back again causes some latency, which in turn increases the number of ticks. When malware sees that this returned tick count is higher than it would be on a non-virtualized system, it might deduce that it’s running inside a VM environment.</p>&#13;
<p class="TX">To better understand the way malware can use this technique, let’s look at an excerpt of some assembly code from a disassembled piece of malware:</p>&#13;
<pre class="pre-45"><code>rdtsc&#13;
mov [ebp+rdtsc_1], eax&#13;
xor eax, eax&#13;
rdtsc&#13;
sub eax, [ebp+rdtsc_1]</code></pre>&#13;
<p class="TX">The malware sample uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction to get the current tick count and stores this value in a buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc_1</samp>). Then, it executes another <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction and subtracts the result from the original (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub eax, [ebp+ rdtsc_1]</samp>). It can use the resulting value to determine whether the execution time is within the threshold of a non-virtualized processor.</p>&#13;
<p class="TX">Sometimes malware gets craftier than two simple <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> commands, and some malware families execute multiple iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> to get a more <span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>accurate value. In the next section, we’ll cover a few more use cases for <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Function Execution Timing</samp></h4>&#13;
<p class="TNI1">Given the timing differences between non-virtualized and virtualized processors, some malware runs a function or instruction and compares its execution time to a baseline representing a real, non-virtualized processor. If the instructions execute more slowly than the baseline, the malware could determine that it’s running in a VM.</p>&#13;
<p class="TX">One technique is for the malware to sandwich a Windows API function call or instruction between two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> functions and compare the results. A long delay between the two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> functions could signify to the malware that it’s being executed and analyzed.</p>&#13;
<p class="TX">There are many variations of this technique, including using instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> instead of Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>. The takeaway here is that any time you spot malware using timing-based functions or instructions, followed by a comparison operation, you should investigate it in more detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Performance Counters</samp></h4>&#13;
<p class="TNI1">The CPU maintains <i>performance counters</i> to represent the number of instructions that have executed since a certain point in time. They can be used legitimately to gather performance metrics, but malware can use them to detect VM environments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceCounter</samp> function queries the processor’s performance counter and returns the current value. <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceFrequency</samp> returns the performance counter’s <i>frequency</i>, a fixed value representing the processor’s overall performance. When these instructions are executed in a VM, the values returned by these functions may be slightly lower than on a non-virtualized system, demonstrating the performance impact of virtualized processors.</p>&#13;
<p class="TX">If you spot malware using these functions, look for a subsequent comparison operation. This may be malware attempting to identify your analysis environment.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h-98"/><samp class="SANS_Futura_Std_Bold_B_11">Abusing the Virtual Processor</samp></h3>&#13;
<p class="TNI1">The virtual processors inside a VM may interpret and execute certain assembly instructions in a way that reveals the VM’s presence to malware. In this section, we’ll delve into how malware “abuses” these virtual processors by misusing instructions or exploiting their design flaws.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Red Pill and No Pill Techniques</samp></h4>&#13;
<p class="TNI1">The Red Pill and No Pill techniques are two well-known methods used by malware to detect virtual environments. Both techniques check processor data structures for VM-specific values. These techniques are often <span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>ineffective in modern analysis environments, so they’re seldom used in modern malware, but it’s still good to be aware of them.</p>&#13;
<p class="TX">For the Red Pill technique, malware executes the <i>Store Interrupt Descriptor Table</i>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt</samp>, assembly instruction, which writes the value of the Interrupt Descriptor Table register to memory, then checks it. The <i>Interrupt Descriptor Table (IDT)</i> is a data structure the processor uses to determine the correct response to exceptions and interrupts. (<i>Exceptions</i> signal to a processor that something is wrong with an instruction, and <i>interrupts</i> allow the processor to respond to a higher-priority event when required.) If the malware is running in a VM, the fifth byte of the IDT register will contain a specific value indicating that.</p>&#13;
<p class="TX">The Red Pill technique is simple to implement:</p>&#13;
<pre class="pre-46"><code>lea  eax, [ebp+buffer]&#13;
sidt [eax]&#13;
mov  al, [eax+5]&#13;
cmp  al, 0FFh</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt [eax]</samp> instruction stores the contents of the IDT register, which is 6 bytes long, to a buffer. The code reads this value and executes a comparison operation to the fifth byte of the buffer, <samp class="SANS_TheSansMonoCd_W5Regular_11">[eax+5]</samp>. The fifth byte of the IDT register will be equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">FF</samp> (in hexadecimal) if it’s running in a VM.</p>&#13;
<p class="TX">The No Pill technique uses the <i>Store Local Descriptor Table</i>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sldt</samp>, instruction to store the <i>Local Descriptor Table</i> (<i>LDT</i>) register to memory. Since normal Windows applications don’t use the LDT, this LDT register should have a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. However, on some hypervisors, this LDT register value will contain a nonzero value, which can be a hint to the malware that it’s running in a VM. Similarly to the Red Pill technique, the No Pill technique doesn’t work correctly anymore in modern sandboxes and hypervisors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IO Ports</samp></h4>&#13;
<p class="TNI1">An <i>input/output port (IO port)</i> is a communication method between the physical hardware of the machine and the software that’s running on it. Certain hypervisors use IO ports for host-to-guest OS communication. VMware, for example, uses the VMX IO port. Research from Cisco Talos revealed that malware can identify the VMX port to detect whether it is running in a VMware environment. The following assembly code shows what this might look like in practice:</p>&#13;
<pre class="pre-47"><code>mov   eax, 'VMXh'&#13;
mov   ebx, 2EF36D4Ch&#13;
mov   ecx, 0Ah&#13;
mov   dx, 'VX'&#13;
in    eax, dx&#13;
cmp   ebx, 2EF36D4Ch</code></pre>&#13;
<p class="TX">This malware sample loads the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VMXh</samp> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, then loads the magic value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2EF36D4Ch</samp> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. This magic value can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>be any hexadecimal value, and it doesn’t matter here. Next, the code loads the <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp> register segment with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VX</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">5658</samp> in hexadecimal, which is the VMX port number. Finally, the malware executes <samp class="SANS_TheSansMonoCd_W5Regular_11">in eax, dx</samp>, which uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> assembly instruction to attempt to access the IO port. If this host is running the VMware Workstation hypervisor, this instruction will return the magic number, which will likely trigger the malware sample to terminate itself or take other evasive actions. On a non-virtualized host, the returned value would be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
<p class="TX">As with the Red Pill and No Pill techniques, this specific technique is quite old and has already been patched in modern versions of VMware. However, it’s important to understand this technique and others like it in case you’re analyzing malware that uses it or some variation of it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The cpuid Instruction</samp></h4>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> assembly instruction returns information about the host’s processors, such as the processor’s features and manufacturer. Outside of a VM, executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> with EAX set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will return something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Genuineintel</samp> for Intel processors or <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthenticAMD</samp> for AMD processors. When <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> is executed inside a VM, it often returns the name of the hypervisor. In the case of VMware, this string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareVMware</samp>. For VirtualBox, the returned string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVBoxVBox</samp>.</p>&#13;
<p class="TX">Setting EAX to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> prior to executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> returns much more information, stored as a 31-bit block in the ECX and EDX registers. The 31st bit in the ECX register will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the system’s CPU is physical or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the system is using a virtual CPU, indicating a VM environment. Here’s an excerpt of assembly code from a malware sample using this technique:</p>&#13;
<pre class="pre-48"><code>inc eax&#13;
cpuid&#13;
bt ecx, 0x1f&#13;
jc terminate_process</code></pre>&#13;
<p class="TX">Here the malware sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">inc eax</samp>), which will be used as a parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> instruction following it. After <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> is executed, the malware executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">bt</samp> (<i>bit test</i>) instruction to move the 31st bit of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> into the <i>carry flag</i> register, which is a special CPU register that can store values of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and is typically used during addition and subtraction operations. Finally, the sample checks the carry flag register (<samp class="SANS_TheSansMonoCd_W5Regular_11">jc</samp>), and if it’s set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the malware will conclude that it’s running in a VM and terminate itself.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Wikipedia is a great reference for the processor information and feature bits returned from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">cpuid</samp>. See</i> <a href="https://en.wikipedia.org/wiki/CPUID"><span class="note_LinkURL_Italic">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/CPUID<wbr/>.</span></a></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unsupported Instruction Sets</samp></h4>&#13;
<p class="TNI1">Malware may use <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> to find out whether a specific instruction set is supported by the processor. For example, the 23rd bit within the EDX register specifies whether the processor supports the <i>SSE instruction set</i>, a set of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>uncommon assembly instructions that’s typically used for graphics processing and scientific computing. Some modern hypervisors support instruction sets like SSE, but not all do! This can be a dead giveaway for malware that it’s running in a VM or sandbox.</p>&#13;
<p class="TX">Some malware, instead of methodically looking through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>, will simply try to execute these instructions, like so:</p>&#13;
<pre class="pre-49"><code>movdqa xmm0, xmmword ptr [eax]&#13;
movdqa xmm1, xmmword ptr [eax]&#13;
movdqa xmmword ptr [eax], xmm0&#13;
movdqa xmmword ptr [eax], xmm1</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp> (Move Aligned Double Quadword) instruction is used for moving data to and from <i>XMM registers</i>, which are those used in the SSE instruction set. In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp> instruction moves the data referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp> register and again to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm1</samp> register. Then, it moves this data back from the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm</samp> registers to <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. If this code produces an error (or the malware crashes!), the malware sample may assume it’s being run in a virtualized environment.</p>&#13;
<p class="TX">The SSE instruction set is just an example here, and most modern hypervisors support it. The important thing to remember is that any exotic or uncommon assembly instructions can be abused by malware for VM and sandbox detection if the hypervisor doesn’t support them.</p>&#13;
<p class="TX">Another example of an exotic instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp>, which produces an error if executed outside of the Windows Virtual PC hypervisor. If executed inside Virtual PC, however, the instruction will succeed and set the EBX register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The following code executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp> instruction, followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction to check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:</p>&#13;
<pre class="pre-50"><code>vpcext 7, 0bh&#13;
test ebx, ebx</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Trap Flag and Other Techniques</samp></h4>&#13;
<p class="TNI1">The trap flag is the eighth bit in the EFLAGS register in the Intel x86 instruction set. If it is enabled prior to another instruction call, an exception will be triggered. In a VM environment, the hypervisor emulates the trap flag behavior. Depending on the hypervisor in use, this emulation may not be correct or complete, which will cause the trap flag to be ignored and notify the malware that it’s running in a VM. This technique was first discovered in the wild in 2021 by researchers at Palo Alto’s Unit 42.</p>&#13;
<p class="TX">It seems that new VM detection methods like this trap flag technique are discovered every few years. Most of them have one thing in common: they abuse the way the CPU and its architecture were designed to function, causing the hypervisor to behave in unexpected or previously unknown ways and ultimately exposing the underlying VM. Malware analysts must keep up to date on these techniques to identify when malware is using them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>&#13;
<h3 class="H1" id="sec16"><span id="h-104"/><samp class="SANS_Futura_Std_Bold_B_11">The Risks of Using Detection Techniques</samp></h3>&#13;
<p class="TNI1">As you’ve seen in this chapter and throughout the previous chapters, for malware authors there can be many benefits of implementing VM and analysis tool detection functionalities. So why might a malware author <i>not</i> include them? One reason is that these techniques can actually increase the chance of the malware being detected by anti-malware or an analyst. The more suspicious the Windows API functions or instructions the malware executes, the greater the chance that these behavioral anomalies will be noticed.</p>&#13;
<p class="TX">Another risk is less obvious and, in my opinion, a bit comical. If malware detects that it’s running in a VM and subsequently chooses not to infect the host, this can be self-defeating in certain circumstances. Many organizations are switching to cloud and on-demand infrastructure, where many systems are in fact VMs. Malware that can detect VMs to evade malware analysts and sandboxes often is simultaneously evading the exact corporate systems it’s designed to infect.</p>&#13;
<p class="TX">One real-world example is the well-known cybercrime malware Emotet, which featured several anti-analysis techniques, one of which was VM and sandbox detection. If it deemed the host a VM or sandbox, Emotet would either terminate itself, thus preventing infection, or behave differently from how it otherwise would on a real, physical system. This led to a lower Emotet infection rate than there would have been otherwise and likely saved some organizations running on virtualized infrastructure from major harm.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h-105"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, you learned about several techniques that malware can use to establish context and detect malware analysis tooling, VMs, and sandboxes. Next, we’ll build on what we’ve discussed in this and the previous three chapters. Specifically, we’ll examine what malware does to evade and disrupt analysis efforts when it discovers it’s running in a virtualized environment or lab.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>