["```\nPrelude> :t 4\n4 :: Num p => p\n```", "```\nx = 4\n```", "```\nPrelude> :l typetest.hs\n[1 of 1] Compiling Main            ( typetest.hs, interpreted )\nOk, one module loaded.\n*Main> :t x\nx :: Integer\n```", "```\n*Main> :t (==)\n(==) :: Eq a => a -> a -> Bool\n```", "```\n*Main> sqrt\n\n<interactive>:5:1: error:\n    • No instance for (Show (Double -> Double))\n        arising from a use of print\n        (maybe you haven't applied a function to enough arguments?)\n    • In a stmt of an interactive GHCi command: print it\n```", "```\n*Main> :t (+)\n(+) :: Num a => a -> a -> a\n```", "```\n*Main> :i Num\nclass Num a where\n  (+) :: a -> a -> a\n  (-) :: a -> a -> a\n  (*) :: a -> a -> a\n  negate :: a -> a\n  abs :: a -> a\n  signum :: a -> a\n  fromInteger :: Integer -> a\n  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}\n   -- Defined in 'GHC.Num'\ninstance Num Word -- Defined in 'GHC.Num'\ninstance Num Integer -- Defined in 'GHC.Num'\ninstance Num Int -- Defined in 'GHC.Num'\ninstance Num Float -- Defined in 'GHC.Float'\ninstance Num Double -- Defined in 'GHC.Float'\n```", "```\n*Main> :t rem\nrem :: Integral a => a -> a -> a\n```", "```\n\"kitchen\" > 4\n```", "```\n*Main> :t (<)\n(<) :: Ord a => a -> a -> Bool\n```", "```\nx > y\n```", "```\nx > fromIntegral y\n```", "```\n*Main> :t fromIntegral\nfromIntegral :: (Integral a, Num b) => a -> b\n```", "```\n*Main> :t (/)\n(/) :: Fractional a => a -> a -> a\n```", "```\n*Main> :t cos\ncos :: Floating a => a -> a\n```", "```\ntype R = Double\n\nintegral :: R -> (R -> R) -> R -> R -> R\nintegral dt f a b\n    = sum [f t * dt | t <- [a+dt/2, a+3*dt/2 .. b - dt/2]]\n```", "```\n*Main> :l TypeClasses\n[1 of 1] Compiling Main            ( TypeClasses.lhs, interpreted )\nOk, one module loaded.\n*Main> integral 0.01 (^2) 0 1\n0.33332499999999987\n```", "```\nimport Graphics.Gnuplot.Simple\n\nplot1 = plotFunc [] [0,0.01..10] cos\n```", "```\ntypeTrouble.hs:3:9: error:\n    • Ambiguous type variable 'a0' arising from a use of 'plotFunc'\n      prevents the constraint '(Graphics.Gnuplot.Value.Atom.C\n                                  a0)' from being solved.\n      Probable fix: use a type annotation to specify what 'a0' should be.\n      These potential instances exist:\n        instance [safe] Graphics.Gnuplot.Value.Atom.C Integer\n          -- Defined in 'Graphics.Gnuplot.Value.Atom'\n        instance [safe] Graphics.Gnuplot.Value.Atom.C Double\n          -- Defined in 'Graphics.Gnuplot.Value.Atom'\n        instance [safe] Graphics.Gnuplot.Value.Atom.C Float\n          -- Defined in 'Graphics.Gnuplot.Value.Atom'\n        ...plus one other\n        ...plus 11 instances involving out-of-scope types\n        (use -fprint-potential-instances to see them all)\n    • In the expression: plotFunc [] [0, 0.01 .. 10] cos\n      In an equation for 'plot1': plot1 = plotFunc [] [0, 0.01 .. 10] cos\n   |\n3  | plot1 = plotFunc [] [0,0.01..10] cos\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```", "```\n*Main> :t plotFunc\n\n<interactive>:1:1: error: Variable not in scope: plotFunc\n```", "```\n*Main> :m Graphics.Gnuplot.Simple\n```", "```\nPrelude Graphics.Gnuplot.Simple> :t plotFunc\nplotFunc\n  :: (Graphics.Gnuplot.Value.Atom.C a,\n      Graphics.Gnuplot.Value.Tuple.C a) =>\n     [Attribute] -> [a] -> (a -> a) -> IO ()\n```", "```\n[Attribute] -> [a] -> (a -> a) -> IO ()\n```", "```\nPrelude Graphics.Gnuplot.Simple> :t [0,0.01..10]\n[0,0.01..10] :: (Fractional a, Enum a) => [a]\nPrelude Graphics.Gnuplot.Simple> :t cos\ncos :: Floating a => a -> a\n```", "```\nimport Graphics.Gnuplot.Simple\n\nxRange :: [Double]\nxRange = [0,0.01..10]\n\nplot2 = plotFunc [] xRange cos\n```", "```\nimport Graphics.Gnuplot.Simple\n\nplot3 = plotFunc [] ([0,0.01..10] :: [Double]) cos\n```", "```\nimport Graphics.Gnuplot.Simple\n\nplot4 = plotFunc [] [0,0.01..10 :: Double] cos\n```"]