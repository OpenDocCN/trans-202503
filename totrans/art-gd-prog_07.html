<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="113" id="Page_113"/>7</span><br/>
<span class="ChapterTitle">3D Graphics and Animation</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c07-0001" class="HeadProject"><span><span epub:type="pagebreak" title="114" id="Page_114"/>Sketch 51: Basic 3D Objects</span></h2>
<p class="BodyFirst">We have been drawing only two-dimensional (2D) objects so far: lines, circles, triangles, rectangles, and images. Processing can draw three-dimensional (3D) objects too, although all that we can represent on a computer screen is a <span class="KeyTerm">view</span> of these, a 2D projection onto a plane. This projection aspect is what makes 3D more difficult. The x dimension is horizontal, and the y is vertical, and displaying those coordinates on a 2D screen is obvious. The third dimension, called z, would be perpendicular to the screen’s surface. In order to visualize it, the three coordinates must be reduced to two, which is what the projection does.</p>
<p>Processing provides a 3D box (cube) and a sphere. In this sketch, we’ll draw these standard objects to show how 3D works.</p>
<p>To render 3D objects, Processing needs to use software that performs 3D drawing operations, called a <span class="KeyTerm">3D renderer</span>. The default renderer, called <code>P2D</code>, only handles two dimensions. To specify three dimensions, we provide the <code>P3D</code> renderer <span class="CodeAnnotation" aria-label="annotation1">1</span> as an argument to the <code>size</code> function within <code>setup</code>:</p>
<pre><code>size (300, 400, P3D);</code></pre>
<p>Now all 3D operations are available. Cubes and spheres are provided through functions, just as rectangles and ellipses are in 2D. The function <code>sphere(R)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> draws a sphere having radius <code>R</code> at the origin. </p>
<p>A sphere is drawn as a collection of triangles that have x-, y-, and z-coordinates at each vertex, oriented along the surface of the sphere and connected edge to edge. Think of it as the 3D version of drawing a circle using many short straight lines; it’s not exactly smooth, but if the triangles are small enough, the illusion works. The triangles will be visible unless outlines are turned off with a call to <code>noStroke()</code>.</p>
<p>The <code>box(s)</code> function draws a cube where each side is <code>s</code> pixels long <span class="CodeAnnotation" aria-label="annotation4">4</span>. To specify the size in each direction, we can use the second form of <code>box</code>: <code>box(w, h, d)</code>.</p>
<p>To draw either shape somewhere other than the origin, we must first call the <code>translate()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function to move the origin to the location where the sphere is to be drawn. In 3D, coordinates have three values: x, y, and z, and <code>translate()</code> has three corresponding parameters.</p>
<p>Finally, when drawing in three dimensions, we need illumination to create depth. To enable lighting, we call <code>lights()</code> in the <code>draw()</code> function. Without the call to <code>lights()</code>, the sphere on the left of the Example A output would just look like a circle.</p>
<h3 id="h2-501645c07-0001">Example A</h3>
<p class="BodyFirst">We draw two spheres: one with the triangles composing the sphere visible (right) and one with them hidden (using <code>noStroke()</code>, left). The spheres move away from the point of view and then back, showing the third dimension more clearly than if they were still.</p>
<h3 id="h2-501645c07-0002">Example B</h3>
<p class="BodyFirst">We draw two cubes, again with the right one showing the cube outlines and with the left one not. The cubes also move away from the camera and then back again (along the z-axis).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<p class="BoxCodeLabel">Example A</p>
<pre><code>int z = 50, dz = 1;
void setup ()
{
  size(400, 300,   <span class="CodeAnnotationHang" aria-label="annotation1">1</span>P3D);
}

void draw ()
{
  background (200);
  noStroke();
  lights();
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> translate(100, 150, z);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> sphere(50);
  translate(200, 0, 0);
  stroke (0);
  sphere (50);
  z = z + dz;
  if (z &gt; 50) dz = -dz;
  if (z &lt; -350) dz = -dz;
}</code></pre>
<span epub:type="pagebreak" title="115" id="Page_115"/><figure class="graphic"><img src="Images/g051001.png" alt="g051001" width="543" height="407"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>int z = 50, dz = 1;

void setup ()
{
   size(400, 300, P3D);
}

void draw ()
{
  background (200);
  noStroke();
  lights();
  translate(100, 150, z);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> box(50);
  translate(200, 0, 0);
  stroke (0);
  box(50);
  z = z + dz;
  if (z &gt; 50) dz = -dz;
  if (z &lt; -350) dz = -dz;
}</code></pre>
<figure class="graphic"><img src="Images/g051002.png" alt="g051002" width="543" height="406"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0002" class="HeadProject"><span><span epub:type="pagebreak" title="116" id="Page_116"/>Sketch 52: 3D Geometry—Viewpoints, Projections</span></h2>
<p class="BodyFirst">3D objects are really simulations in which the edges and faces have locations in a virtual space having three coordinates. Because computer screens are 2D, visualizing these objects means projecting them onto a plane so they can be drawn on a screen.</p>
<p>This plane lies between the object and the location from which the object is being seen, or the <span class="KeyTerm">viewpoint</span>. The viewpoint is a location in 3D space, marked by an eye in <a href="#figure52-1" id="figureanchor52-1">Figure 52-1</a>. (2D scenes don’t really have a viewpoint; the entire image is a plane in the first place.)</p>
<figure>
<img src="Images/f052001.png" alt="f052001" class="" width="647" height="170"/>
<figcaption><p><a id="figure52-1">Figure 52-1</a>: Viewing a 3D object</p></figcaption>
</figure>
<p>There is a second crucial point for defining how a 3D view appears, and that is the location where the viewer (camera) is <em>looking</em>. This is the center of the scene, denoted by <code>(cx, cy, cz)</code>. The plane on which the 3D scene is projected is perpendicular to the line between <code>(ex, ey, ez)</code> and <code>(cx, cy, cz)</code>, and precisely what can be seen depends on the <span class="KeyTerm">field of view</span>, or the angle of the visible field, which determines what can be seen without moving the camera. </p>
<p>In Processing, we use a call to <code>camera()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to set up the basic 3D configuration:</p>
<pre><code>camera(ex, ey, ez, cx, cy, cz, 0, 1, 0);</code></pre>
<p>The first three parameters are the viewpoint, and the next three are the center of the scene. The last three represent a vector that defines the direction <em>up</em> so that the scene is oriented correctly. In this example, <em>up</em> is the positive y-direction. It is a choice made by the programmer.</p>
<p>This sketch uses the <code>camera()</code> function to change the view of a pair of 3D objects according to user key presses. We move the location of the viewpoint by incrementing or decrementing the values of <code>ex</code> and <code>ez</code> inside the <code>keyPressed()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> when the proper keys are pressed: <span class="KeyCaps">a</span> decreases x (moves left), <span class="KeyCaps">d</span> increases x (moves right), <span class="KeyCaps">w</span> decreases z, and <span class="KeyCaps">s</span> increases z (the distance to the objects). This is the equivalent of moving the player in a video game. The sphere is drawn at <code>(cx, cy, cz)</code> so that it is guaranteed to be visible at the outset. To move the center of the scene away from the sphere, we can change the value of <code>cy</code> with the up and down arrow keys. You can see the effect of changing the viewpoint and the center of the scene by experimenting with them using the keyboard.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="117" id="Page_117"/>int x=100, y=100, z=100;      // Sphere position
int ex=100, ey=100, ez=400;   // Viewpoint
int cx=100, cy=100, cz=100;   // Point we are looking at

void setup ()
{
  size (500, 400, P3D);
}

void draw ()
{
  background (200, 200, 200);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> camera(ex, ey, ez, cx, cy, cz, 0, 1, 0);
  noStroke();
  lights();
  translate (x, y, z);
  sphere (12);
  translate (20, 0, 0);
  box (12);
  translate (-x-20, -y, -z);
}

  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> void keyPressed ()
{
  if (key == 'w') ez = ez - 10;
  if (key == 's') ez = ez + 10;
  if (key == 'a') ex = ex - 10;
  if (key == 'd') ex = ex + 10;
  if (keyCode == UP) cy = cy + 10;
  if (keyCode == DOWN) cy = cy - 10;
}</code></pre>
<figure class="graphic"><img src="Images/g052001.png" alt="g052001" width="485" height="388"/></figure>
<figure class="graphic"><img src="Images/g052002.png" alt="g052002" width="485" height="388"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0003" class="HeadProject"><span><span epub:type="pagebreak" title="118" id="Page_118"/>Sketch 53: 3D Illumination</span></h2>
<p class="BodyFirst">Illumination can profoundly change the appearance of a scene. The location of lights will cause specific portions of objects or scenes to be visible while others are not. Colored lights can change the apparent color of objects. Directional lighting can illuminate some portions of an object and not others. Processing provides all of these options. </p>
<p>In this sketch, we’ll draw a sphere and permit the user to select the type of lighting used by typing a number. The lighting may be ambient (1), directional (2), point (3), spot (4), or all three: directional, point, and spot (5). The default lighting is code 0. When the user changes the kind of lighting, the color changes as well: ambient is cyan, directional is violet, point is yellow, and spot is green.</p>
<p>The previous sketches have used a call to <code>lights()</code> to provide default illumination. Alternatively, we can use a call to the <code>ambientLight()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> to specify a color and, optionally, a location for ambient lighting, which is illumination that permeates the scene.</p>
<pre><code>ambientLight (r, g, b, x, y, z);</code></pre>
<p>The first three parameters specify the RGB values for the color of the light. The next three are optional, and specify a location in three dimensions. Light spreads in all directions from this point. </p>
<p>The <code>directionalLight()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> specifies light from a specific direction, so it appears brighter when striking a surface perpendicular to that direction and less bright as the angle changes.</p>
<pre><code>directionalLight (r, g, b, dx, dy, dz);</code></pre>
<p>Again, the first three parameters represent the color of the light. The next three specify the direction. So, for example, if <code>dy=1</code> while <code>dx=0</code> and <code>dz=0</code>, the object will be illuminated from above.</p>
<p>The <code>pointLight()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span> creates a single location from which illumination comes, like a lamp. This call places a light with the specified RGB values at the given (<code>x</code>, <code>y</code>, <code>z</code>) location:</p>
<pre><code>pointLight (r, g, b, x, y, z);</code></pre>
<p>Finally, a <code>spotlight()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> is a concentrated directional light, and it is the most complex of the lighting sources. This call specifies a light of color RGB at location (<code>x</code>, <code>y</code>, <code>z</code>) pointed in direction (<code>dx</code>, <code>dy</code>, <code>dz</code>):</p>
<pre><code>spotlight (r,g,b, x,y,z, dx,dy,dz, angle, concentration);</code></pre>
<p>The value of <code>angle</code> is the dispersion angle of the light; the smaller the angle, the smaller the circle of light. This angle is in radians. The <code>concentration</code> specifies how the light varies across a cross section, brighter in the center and less bright at the edges. Values can vary from 1 to 10,000.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int x=100, y=100, z=100;         // Sphere position
int ex=100, ey=100, ez=147;      // Viewpoint
int cx=100, cy=100, cz=100;      // Point we are looking at
int code = 0;
void setup()
{
  size (500, 400, P3D);
}

void draw ()
{
  background (200, 200, 200);
  camera(ex, ey, ez, cx, cy, cz, 0, 1, 0);
  if (code == 0) 
    lights();
  else if (code == 1) 
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> ambientLight (0, 200, 200, 0, 1000, 0);
  else if (code == 2) 
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> directionalLight (200, 0, 200, 0, 1000, 0);
  else if (code == 3)
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> pointLight (200, 200, 0, 0, -1000, 0);
  else if (code == 4) 
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> spotLight (0, 200, 0, -300, 100, 100, 100, 0, 0, PI/16, 1000);

  else if (code == 5)  // All three!
  {
    directionalLight (200, 0, 200, 0, 1000, 0);
    pointLight (200, 200, 0, 0, -1000, 0);
    spotLight (0, 200, 0, -300, 100, 100, 100, 0, 0, PI/16, 1000);
  }
  translate (x, y, z);
  sphere (12); 
}

void keyPressed ()
{
  if (key == '0') code = 0;
  if (key == '1') code = 1;
  if (key == '2') code = 2;
  if (key == '3') code = 3;
  if (key == '4') code = 4;
  if (key == '5') code = 5;
}</code></pre>
<span epub:type="pagebreak" title="119" id="Page_119"/><figure class="graphic"><img src="Images/g053001.png" alt="g053001" width="254" height="1072"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0004" class="HeadProject"><span><span epub:type="pagebreak" title="120" id="Page_120"/>Sketch 54: Bouncing a Ball in 3D</span></h2>
<p class="BodyFirst">Sketch 28 was a simulation of a bouncing ball. A circle (ball) moved about a window, bouncing when it struck the boundary. An obvious extension of this into three dimensions has a sphere bouncing about the inside of a cube. When the sphere (ball) strikes one of the sides of the cube, it bounces. This is conceptually the same problem as in two dimensions, but it requires quite a bit more code because there are more conditions to check and more things to draw. </p>
<p>The scene consists of the cube and a sphere. The cube occupies most of the field of view, bounded by the coordinate axes. We’ll draw the coordinate axes in special colors to show the three primary directions: x will be green, y will be blue, and z will be red. Instead of calling <code>box()</code>, we’ll draw the cube as the 12 lines that compose the edges so that we can see the ball inside. </p>
<p>We’ll start drawing the cube from the origin in the upper-left corner, followed by the remaining nine edges, using the <code>mycube()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>. To see if the ball has collided with a side, we’ll test the ball’s coordinates against the x, y, and z values of the bounding planes, which are aligned with the coordinate axes.</p>
<p>We can still use the <code>sphere()</code> function to draw the bouncing ball at position (<code>x</code>, <code>y</code>, <code>z</code>) using a translation of the origin to that point before drawing. After each frame, we move the ball an amount (<code>dx</code>, <code>dy</code>, <code>dz</code>). If the ball coordinates are such that the ball extends past any of the cube faces, then the ball bounces—it reverses the direction of motion to move away from the face. This is implemented by the <code>moveSphere()</code> function. For example, in the x-direction, this is the specific test for a bounce <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>if (x&lt;=6 || x&gt;=194) dx = -dx;</code></pre>
<p>This test is specific for a sphere size of 12, because it checks against the radius of 6 pixels. A sphere of radius <em>r</em> is in contact with the cube if its center is within <em>r</em> pixels of a face, and <em>r</em> is half of the specified sphere size. Because the cube starts at (0, 0, 0) and is 200 units in each direction, the ball collides around x-coordinates 6 and 194. </p>
<p>The center of the cube is at (100, 100, 100) <span class="CodeAnnotation" aria-label="annotation3">3</span>. This point is the center of the scene. We stare into the cube from the viewpoint at the (<code>x</code>, <code>y</code>) center, which is (100, 100), but along the z-axis 400 units. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A 3D version of the game Pong could be created from this basic program. Paddles could be small rectangles aligned to the opposite y-z axes. The left paddle could be moved with the <span class="KeyCaps">w</span>, <span class="KeyCaps">a</span>, <span class="KeyCaps">s</span>, and <span class="KeyCaps">d</span> keys, and the right paddle with the arrow keys. Bouncing off of the y-z planes would occur only if the sphere’s y- and z-coordinates placed it within the rectangle defined by the paddle.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int x=100, y=100, z=100;                            // Sphere position
int dx=2, dy=3, dz=4;                               // Velocity of the sphere
int eyex= 100, eyey=100, eyez=400;                  // Viewpoint
int cx=100, cy=100, cz=100;                         // Point we are looking at

void setup() {  size (400, 400, P3D); }

  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> void mycube ()
{
  stroke (255, 0, 0);  line (0, 0, 0, 0, 0, 200);   // Z axis is red
  stroke(0, 0, 255);  line (0, 200, 0, 0, 0, 0);    // Y axis is blue
  stroke(0, 255, 0); line (0, 0, 0, 200, 0, 0);     // X axis is green
  stroke (255);                                     // All other edges are white
  line (0, 0, 200, 0, 200, 200);
  line (0, 200, 200, 0, 200, 0);
  line (0, 200, 0, 200, 200, 0);
  line (0, 200, 200, 200, 200, 200);
  line (0, 0, 200, 200, 0, 200);
  line (200, 0, 0, 200, 0, 200);
  line (200, 0, 200, 200, 200, 200);
  line (200, 200, 200, 200, 200, 0);
  line (200, 200, 0, 200, 0, 0);
  noStroke();
}

void moveSphere ()
{     //  Move the sphere position one frame
  x = x + dx;  y = y + dy;  z = z + dz;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (x&lt;=6 || x&gt;=194) dx = -dx;
  if (y&lt;=6 || y&gt;=194) dy = -dy;
  if (z&lt;=6 || z&gt;=194) dz = -dz;
}

void draw ()
{ 
  background (45, 45, 120);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);
  mycube();
  lights();
  noStroke();
  translate (x, y, z);
  sphere (12);
  moveSphere();
}</code></pre>
<span epub:type="pagebreak" title="121" id="Page_121"/><figure class="graphic"><img src="Images/g054001.png" alt="g054001" width="310" height="310"/></figure>
<figure class="graphic"><img src="Images/g054002.png" alt="g054002" width="310" height="310"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0005" class="HeadProject"><span><span epub:type="pagebreak" title="122" id="Page_122"/>Sketch 55: Constructing 3D Objects Using Planes</span></h2>
<p class="BodyFirst">Processing provides only spheres and boxes as basic 3D objects, but that does not mean that we can’t make more complex things. We can construct arbitrary objects from polygons. This means we need to design the objects first, either on paper or using a 3D modeling program like Blender or Maya. The design yields a set of coordinates of the <span class="KeyTerm">vertices</span> (corner points) of the polygons in three dimensions. Then we can use Processing to draw these polygons and thus display the object.</p>
<p>Since prisms are the easiest objects to build, this sketch will draw a prism and color the various faces differently so we can tell which are which. The point of view will move in a pattern so that the 3D nature of the object is clear.</p>
<p>A <span class="KeyTerm">rectangular prism</span> consists of rectangles joined along their edges. A cube is a rectangular prism, for example. The first step is to determine the values of the coordinates for each of the corners of the rectangles that will compose the prism. A piece of graph paper is useful for this: sketch the prism and define the x, y, z coordinate system (x is horizontal). Then start with the origin, the (0, 0, 0) point, and place the coordinates on the drawing where they belong, as in <a href="#figure55-1" id="figureanchor55-1">Figure 55-1</a>. Now you can simply read off the coordinates of each rectangle in any order you like. For example, the front face of the prism in the figure is defined by the following coordinates: (0, 0, 0), (sx, 0, 0), (sx, sy, 0), and (0, sy, 0).</p>
<figure>
<img src="Images/f055001.png" alt="f055001" class="" width="344" height="429"/>
<figcaption><p><a id="figure55-1">Figure 55-1</a>: 3D coordinates of a prism</p></figcaption>
</figure>
<p>To draw polygons that are connected as an object, we bookend that drawing code between calls to the <code>beginShape()</code> and <code>endShape()</code> functions. In this case, because the polygons used are rectangles, <code>beginShape()</code> is passed the argument <code>QUAD</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>; another option would be <code>TRIANGLES</code>. This argument specifies to Processing the number of vertices needed for each polygon (in this case four). Between the begin and end calls, we place calls to a function named <code>vertex()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each such call specifies a point in 3D space that represents, in this instance, a corner of a rectangle. For example, the front face of the prism is defined by these calls:</p>
<pre><code>vertex (0., 0., 0.);
vertex (sx, 0., 0.);
vertex (sx, sy, 0.);
vertex (0., sy, 0.); </code></pre>
<p><span epub:type="pagebreak" title="123" id="Page_123"/>The sketch draws four rectangles connected along vertical edges, creating a rectangular prism with no top or bottom. Each is filled with a different color merely by placing a call to <code>fill()</code> immediately before the four vertices for that rectangle are specified. </p>
<p>The viewpoint changes by the amount <code>dz</code> during each frame between a minimum of z = −200 and a maximum of z = 300 <span class="CodeAnnotation" aria-label="annotation4">4</span> so that various views of the prism are displayed.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	After an object is complete, it can be terminated by a call to <code>endShape(</code><code>CLOSE)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>; the parameter indicates the polygon should be closed. This will connect the first coordinate and the last so that there is no gap in the polygon. Floating-point approximations can cause gaps because small errors in individual calculations can accumulate and result in small errors. Adding 0.01 to a value 100 times may not be exactly the same as adding 1.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float sx=30., sy=40., sz=12.;
int eyex= 144, eyey=0, eyez=245;
int cx=30, cy=40, cz=32;
int dz = -1;

void setup ()
{
  size(300, 300, P3D);
  stroke(0);
}

void draw ()
{
  background(255);
  camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);

  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> beginShape (QUAD); 
    fill (170, 120, 50);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> vertex (0., 0., 0.);
  vertex (sx, 0., 0.);
  vertex (sx, sy, 0.);
  vertex (0., sy, 0.); 
    fill (120, 170, 50);
  vertex (sx, 0., 0.);
  vertex (sx, 0., sz);
  vertex (sx, sy, sz);
  vertex (sx, sy, 0.);   
    fill (170, 50, 120);
  vertex (sx, 0., sz);
  vertex (0., 0., sz);
  vertex (0., sy, sz);
  vertex (sx, sy, sz);
    fill (50, 120, 170);
  vertex (0., 0., 0.);
  vertex (0., sy, 0.);
  vertex (0., sy, sz);
  vertex (0., 0., sz);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> endShape (CLOSE);

  eyez = eyez + dz;
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (eyez &lt; -200) dz = -dz;
  if (eyez &gt; 300) dz = -dz;
} </code></pre>
<figure class="graphic"><img src="Images/g055001.png" alt="g055001" width="416" height="416"/></figure>
<figure class="graphic"><img src="Images/g055002.png" alt="g055002" width="416" height="415"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0006" class="HeadProject"><span><span epub:type="pagebreak" title="124" id="Page_124"/>Sketch 56: Texture Mapping</span></h2>
<p class="BodyFirst">In Sketch 55 we gave each side of a prism a distinct color to make it easy to identify each face. This was done as an exercise, but in most real applications, a prism would either be a single color or would have a <span class="KeyTerm">texture</span> placed on it. A texture is a pattern, often simply an image, that we apply like a decal to a polygon. In this way, we can make a simple prism look like many things: a building, a book, a chair—nearly anything with corners. This sketch applies a texture (carpet) to a polygon (a rectangle) and moves the viewpoint so that the 3D effect can be seen.</p>
<p>Applying an image to a polygon as a texture is a process called <span class="KeyTerm">texture mapping</span>. The details of the algorithm are complex, but the idea is simple enough, and the way it is implemented in Processing fits nicely into the scheme already explained for drawing objects. In English, the process is as follows:</p>
<ol class="decimal">
<li value="1">Read in an image that will serve as the texture <span class="CodeAnnotation" aria-label="annotation1">1</span>. This will be a <code>PImage</code>.</li>
<li value="2">Define the coordinates of a 3D polygon, possibly part of a bigger object.</li>
<li value="3">Map each of the four corners of the texture image to a vertex of the polygon; that is, if the polygon is a rectangle, decide which corners of the texture image will be placed over which corners of the rectangle.</li>
<li value="4">Convert the coordinate mapping into calls to the <code>vertex()</code> function <span class="CodeAnnotation" aria-label="annotation4">4</span>.</li>
<li value="5">Bracket the vertex calls between <code>beginShape()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>endShape()</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>.</li>
<li value="6">Immediately after <code>beginShape()</code>, tell Processing which texture image to use by calling the built-in <code>texture()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span>.</li>
</ol>
<p>In this example, we use an image of carpet texture. As an orientation marker, a red rectangle is placed in the upper-left corner and a green one in the upper right. The texture image is 524 by 928 pixels. This is the coordinate mapping from texture to vertices, as shown in <a href="#figure56-1" id="figureanchor56-1">Figure 56-1</a>:</p>
<ul>
<li>Texture (0, 0) maps to polygon (0, 0, 0).</li>
<li>Texture (524, 0) maps to polygon (sx, 0, 0).</li>
<li>Texture (524, 928) maps to polygon (sx, sy, 0).</li>
<li>Texture (0, 928) maps to polygon (0, sy, 0).</li>
</ul>
<figure>
<img src="Images/f056001.png" alt="f056001" class="" width="591" height="368"/>
<figcaption><p><a id="figure56-1">Figure 56-1</a>: Mapping texture coordinates to a polygon</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="125" id="Page_125"/>The <code>vertex()</code> function allows us to specify the mapping with two optional parameters for texture coordinates. This would be the mapping of the previous vertices:</p>
<pre><code>vertex (0., 0., 0.,   0.,  0.);    vertex (sx, 0., 0.,   524, 0.);
vertex (sx, sy, 0.,   524, 928);   vertex (0., sy, 0.,   0.,  928);</code></pre>
<p>Because Processing knows the size of the texture image (<code>timage</code>), the numeric constant 524 in the preceding mappings can be replaced by <code>timage.width</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Similarly, we can use <code>timage.height</code> instead of 928.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>float sx=30., sy=40., sz=12.;
int eyex=30, eyey=50, eyez=60;
int cx=20, cy=30, cz=12;
int dx = -1;
PImage timage;

void setup ()
{
  size(200, 200, P3D);
  stroke(0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> timage = loadImage ("carpets.jpg");
}

void draw ()
{
  background(255);
  camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);

  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> beginShape (QUAD); 
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> texture (timage);
  vertex (0., 0., 0.,   0.,           0.);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> vertex (sx, 0., 0.,   timage.width, 0.);
  vertex (sx, sy, 0.,   timage.width, timage.height);
  vertex (0., sy, 0.,   0.,           timage.height);
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> endShape (CLOSE);

  eyex = eyex + dx;
  if (eyex &lt; -30) dx = -dx;
  if (eyex &gt; 100) dx = -dx;
}</code></pre>
<figure class="graphic"><img src="Images/g056001.png" alt="g056001" width="400" height="400"/></figure>
<figure class="graphic"><img src="Images/g056002.png" alt="g056002" width="400" height="400"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0007" class="HeadProject"><span><span epub:type="pagebreak" title="126" id="Page_126"/>Sketch 57: Billboards—Simulating a Tree</span></h2>
<p class="BodyFirst">Let’s draw a tree in three dimensions. A prism is a simple thing, but a tree? Trees have many parts: leaves, branches, bark, and myriad details. Graphics specialists have devised very complex methods to create complex things like trees, mountains, and living things, but in most cases, it is not necessary to go to that trouble. For artwork, animations, and games, there are ways to simplify things (to “cheat”) so that they look pretty good while still being easy to implement. Building a tree as a <span class="KeyTerm">billboard</span> is one of those things.</p>
<p>In its simplest form, a billboard is a rectangle with a texture drawn on it. It resembles the kind of billboard you can see while driving down tourist highways, and in computer graphics, it would normally occur only at a large distance from the viewer. To make a tree, we’ll use two billboards at right angles to each other, joined at the vertical center of each. Each one is a rectangle with a tree image textured onto it. The idea is that from any angle one sees the entire tree, and moving the viewpoint appears to change the view of the tree. From close up it is obvious what is happening, but when seen from a medium distance or while the viewer is moving, the illusion is a good one.</p>
<p><a href="#figure57-1" id="figureanchor57-1">Figure 57-1</a> shows how we arrange the two perpendicular rectangles in three dimensions. The texture placed on them needs to have a transparent background, or the white rectangles will be visible. This means using either a GIF or PNG format image file, which are the ones that support transparency.</p>
<figure>
<img src="Images/f057001.png" alt="f057001" class="" width="208" height="372"/>
<figcaption><p><a id="figure57-1">Figure 57-1</a>: Two perpendicular rectangles</p></figcaption>
</figure>
<p>The sketch first reads in the tree image that we’ll use as a texture and opens the window, as usual. The <code>draw()</code> function sets up the camera <span class="CodeAnnotation" aria-label="annotation1">1</span> and draws two rectangles at the origin, both using the tree as a texture that we map onto the rectangles <span class="CodeAnnotation" aria-label="annotation2">2</span>, similar to what was done in Sketch 56. We rotate the second texture-mapped rectangle by 90 degrees <span class="CodeAnnotation" aria-label="annotation3">3</span> and translate it by 13 units in the x and z directions to align it with the center of the first rectangle. (The rectangle is 26 units wide, and 13 units is half of that.)</p>
<p>We also change the viewpoint slightly in each frame so that the 3D effect is obvious when the sketch is executing.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The use of billboards can be more interesting and dynamic than this. Imagine that we need a burning torch. We could make a set of animation frames of a burning torch using Paint and then map them onto the billboard in sequence. The result is a convincing representation of a burning torch, especially if the background is otherwise dark.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage tree; // https://pngimg.com/download/204/

float sx=30., sy=40.;
int eyex=30, eyey=20, eyez=60;
int cx=20, cy=15, cz=12;
int dx = -1;

void setup ()
{
  size (500, 400, P3D);
  tree = loadImage ("tree.gif");
  noStroke();
}

void draw ()
{
  background (200, 255, 0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);
  beginShape (QUAD);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> texture (tree);
  vertex (0., 0., 0.,   0.,         0.);
  vertex (sx, 0., 0.,   tree.width, 0.);
  vertex (sx, sy, 0.,   tree.width, tree.height);
  vertex (0., sy, 0.,   0.,         tree.height); 
  endShape (CLOSE);

  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> rotateY (PI/2.0);
  translate (-13, 0, 13);

  beginShape (QUAD);
  texture (tree);
  vertex (0., 0., 0.,   0.,         0.);
  vertex (sx, 0., 0.,   tree.width, 0.);
  vertex (sx, sy, 0.,   tree.width, tree.height);
  vertex (0., sy, 0.,   0.,         tree.height);
  endShape (CLOSE);

  eyex = eyex + dx;
  if(eyex&lt;-40 || eyex&gt;60) dx = -dx;
}</code></pre>
<span epub:type="pagebreak" title="127" id="Page_127"/><figure class="graphic"><img src="Images/g057001.png" alt="g057001" width="383" height="305"/></figure>
<figure class="graphic"><img src="Images/g057002.png" alt="g057002" width="383" height="306"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0008" class="HeadProject"><span><span epub:type="pagebreak" title="128" id="Page_128"/>Sketch 58: Moving the Viewpoint in 3D</span></h2>
<p class="BodyFirst">In a first-person computer game, the representation of the player in the game is an <span class="KeyTerm">avatar</span>, controlled by the player. Pressing <span class="KeyCaps">w</span> moves the avatar forward, <span class="KeyCaps">s</span> moves it backward, <span class="KeyCaps">a</span> moves it left, and <span class="KeyCaps">d</span> moves it right. This scheme is easy for a player to understand but harder to implement than the scheme we have been using.</p>
<p>In the sketches presented so far, the movement has been automatic or based on simplistic assumptions—<span class="KeyCaps">a</span> and <span class="KeyCaps">d</span> move along the x-axis and <span class="KeyCaps">w</span> and <span class="KeyCaps">s</span> move along the z-axis—but people don’t move in that way. The <span class="KeyCaps">a</span> and <span class="KeyCaps">d</span> keys should rotate the player about their own axis, and the <span class="KeyCaps">w</span> and <span class="KeyCaps">s</span> keys should move the player forward and backward along the direction defined by that angle. As a demonstration of avatar movement control, this sketch draws nine cubes and allows the user to move among them using this technique.</p>
<p>The avatar has a direction in which it is facing, defined by the variable <code>angle</code> (in degrees). The <span class="KeyCaps">a</span> and <span class="KeyCaps">d</span> keys allow the user to change this angle by one degree per key press <span class="CodeAnnotation" aria-label="annotation3">3</span>. Changing the angle will not modify the camera position, but it does modify the center of the scene by rotating it about the avatar. Because the vertical axis is y, we can calculate this in the x-z plane as a simple trigonometric relationship <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>cx = cos(radians(angle))*20000.0;
cz = sin(radians(angle))*20000.0;</code></pre>
<p>The value 20,000 represents a large distance, effectively infinite, that provides a distant focus point. </p>
<p>Pressing <span class="KeyCaps">w</span> moves the avatar one unit along the direction it is facing, which is the variable <code>angle</code>. Each unit moved changes the <code>x</code> position by <code>dx</code> and the <code>z</code> position by <code>dz</code>, as defined in <a href="#figure58-1" id="figureanchor58-1">Figure 58-1</a>.</p>
<figure>
<img src="Images/f058001.png" alt="f058001" class="" width="433" height="316"/>
<figcaption><p><a id="figure58-1">Figure 58-1</a>: Converting (x, z) motion to (angle, distance)</p></figcaption>
</figure>
<p>The position of the avatar is (<code>eyex</code>, <code>eyez</code>), and it is likely that for any given forward <span class="CodeAnnotation" aria-label="annotation1">1</span> or backward <span class="CodeAnnotation" aria-label="annotation2">2</span> movement, both of these values will change. One key press will move the avatar 5 units, or <code>dx*5</code>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <code>radians</code><code>(</code><code>)</code> function can be used to convert an angle in degrees into radians.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int eyex=30, eyey=0, eyez=60;
int cx=20000, cy=15, cz=20000;
float angle = 0.0;
float dx = 1.0, dz = 1.0, sx, sy, sz; 


void setup ()
{    
  size (500, 400, P3D);  
  fill (200,0,0); 
  keyPressed();  // Initialize the viewpoint
}

void draw ()
{
  background (200, 255, 0);
  camera(eyex, eyey, eyez, cx, cy, cz, 0, 1, 0);
  for (int i=0; i&lt;9; i++)  // Draw nine boxes (30,0,30) apart
  {
    translate (30, 0, 30);
    box (20);
  }
}

void keyPressed ()
{
  if (key == 'w')          // Move 'forward'
  {
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> eyex += 5*dx;    eyez += 5*dz;  
  }
  else if (key == 's')     // Move 'backward'
  {
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> eyex -= 5*dx;      eyez -= 5*dz;   
  }
  else if (key == 'a')     // Turn left a unit (CCW)
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> angle = angle - 1.0;
  else if (key == 'd')     // Turn right a unit (CW)
    angle = angle + 1.0;
  if (angle &lt; 0) angle = angle + 360.0;
  else if (angle &gt; 360.0) angle = angle - 360.0;
  dx = cos(radians(angle)); dz = sin(radians(angle));
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> cx = (int)(dx*20000.0);  // cx = x coordinate of center point
  cz = (int)(dz*20000.0);  // cz = z coordinate of center point
}</code></pre>
<span epub:type="pagebreak" title="129" id="Page_129"/><figure class="graphic"><img src="Images/g058001.png" alt="g058001" width="410" height="328"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0009" class="HeadProject"><span><span epub:type="pagebreak" title="130" id="Page_130"/>Sketch 59: Spotlights</span></h2>
<p class="BodyFirst">If the ambient illumination is off and the background is dark, any objects drawn within the 3D space of the Processing graphics world will not be visible. This sketch simulates illumination in a new way—as a small spotlight source in a dark space. The spotlight shines on the center-of-scene coordinates, and the rest of the scene is unlit. The sketch places three cubes of different colors around the scene <span class="CodeAnnotation" aria-label="annotation2">2</span>, and the user can explore the space by rotating and watching for the cubes to light up.</p>
<p>This sketch uses the same code for <code>keyPressed()</code> as does the previous sketch, so the avatar can rotate and move forward and backward <span class="CodeAnnotation" aria-label="annotation3">3</span>. A Processing spotlight is placed at the camera coordinates <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>spotLight(255,255,20, eyex,eyey,eyez, cx,cy,cz, PI/4, 300);</code></pre>
<p>The first three parameters (<code>255</code>, <code>255</code>, <code>20</code>) of the spotlight represent the RGB values for the color of the light, the next three (<code>eyex</code>, <code>eyey</code>, <code>eyez</code>) are the 3D coordinates of the light, and the next three (<code>cx</code>, <code>cy</code>, <code>cz</code>) are the coordinates toward which the light is pointed. This means that wherever the camera/avatar moves, a spotlight is shining on the center of the scene. The angle for the light, <code>PI/4</code> (45 degrees) is the 10th parameter, and we can increase or decrease it to see what happens to the scene. The value <code>300</code> indicates how strongly the light concentrates near the center of the spot, with larger numbers being more focused.</p>
<p>We can define lights for other types of local illumination. Car headlights, for example, are simply two spotlights separated by a small distance. There is a commented-out statement that adds a second light to the one in the sketch:</p>
<pre><code>spotLight(255,255,20, eyex+3*dz,eyey,eyez+3*dx, cx,cy,cz, PI/4, 300);</code></pre>
<p>Spotlights are only visible by their light reflected off of objects. They cannot be seen as glowing objects. The same is true of point lights and other sources. In that sense, lights are not objects. Surrounding a light with an object illuminates the objects around it but does not make the light source visible.</p>
<p>We can make lights flash on and off or change color by alternately calling the <code>spotLight()</code> function or not, depending on a flag that is either true or false, here named <code>flash</code>. Simply change a counter after each frame, and change the flag after a fixed number of frames (20 here). The following code illuminates one of two spheres alternately with red or blue, like police car lights.</p>
<pre><code>if (count % 20 == 0) flash = !flash;  // If flash is true, make it false
if (flash)   spotLight(255,0,0,  0,  335,  0, 0,  -1, 0, PI/4, 300);
else   spotLight(0,0,255,  50,  335,  0, 0,  -1, 0, PI/4, 300);
sphere(20);
translate (50, 0, 0); sphere(20); translate (50, 0, 0);</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float eyex = 35, eyey = 10, eyez = -300.0;
float cx = 200.0, cy = 5.0, cz = 100.0;
float dx = 0.0, dz = 1.0;
float angle = 90.0;

void setup () 
{ 
  size(400, 300, P3D); 
  keyPressed ();
}

void draw ()
{
  background (60);
  camera (eyex, eyey, eyez, cx, cy, cz, 0.0, -1.0, 0.0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> spotLight(255,255,20, eyex, eyey, eyez,cx, cy, cz,PI/4, 300);
//  spotLight(255,255,20, eyex+3*dz, eyey, eyez+3*dx, cx, cy, cz, PI/4, 300);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> fill (255,255,255); box (20);
  fill (255,0,0); translate (200, 0, 300); box(20);
  fill (0,255,255); translate (-50, 0, -400); box(20);
}

  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> void keyPressed ()
{
  if (key == 'w')           // Move 'forward'
  {
    eyex += 5*dx;    eyez += 5*dz;  
  }
  else if (key == 's')     // Move 'backward'
  {
    eyex -= 5*dx;    eyez -= 5*dz;   
  }
  else if (key == 'a')     // Turn left a unit (CCW)
    angle = angle + 1.0;
  else if (key == 'd')     // Turn right a unit (CW)
    angle = angle - 1.0;
  if (angle &lt; 0) angle = angle + 360.0;
  else if (angle &gt; 360.0) angle = angle - 360.0;
  dx = cos(radians(angle)); dz = sin(radians(angle));
  cx = (int)(dx*20000.0);  // cx = x coordinate of center point = cos(angle)*20000
  cz = (int)(dz*20000.0);  // cz = z coordinate of center point = sin(angle)*20000
}</code></pre>
<span epub:type="pagebreak" title="131" id="Page_131"/><figure class="graphic"><img src="Images/g059001.png" alt="g059001" width="377" height="283"/></figure>
<figure class="graphic"><img src="Images/g059002.png" alt="g059002" width="377" height="283"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c07-0010" class="HeadProject"><span><span epub:type="pagebreak" title="132" id="Page_132"/>Sketch 60: A Driving Simulation</span></h2>
<p class="BodyFirst">Driving simulations and games have a specific, standard interface and visual presentation. Unlike previous sketches, where users can move about the space but are not themselves visible, driving simulations display the avatar as a car, and the camera (viewpoint) is usually behind and above the car so that the view of the car is always looking forward. Cars drive on roads, so a background is important; without one the user can’t tell when they are on a road or have any real idea of how fast they are moving. This sketch will allow a user to drive a vehicle (a rectangular prism, actually) around a track, using the same scheme to move the avatar as before.</p>
<p>The first thing to do is create a track. It will simply be an image, so we can use Paint or some other drawing program. It should be large enough so that it provides some entertainment value (variety) and does not distort too badly when displayed. The example shown in <a href="#figure60-1" id="figureanchor60-1">Figure 60-1</a> is 1,000×1,000 pixels. </p>
<figure>
<img src="Images/f060001.png" alt="f060001" class="" width="365" height="365"/>
<figcaption><p><a id="figure60-1">Figure 60-1</a>: A simple track for driving on</p></figcaption>
</figure>
<p>The sketch reads this image and uses it as a texture for a 1,000×1,000 square drawn on the x-z plane <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>beginShape(QUADS);
  texture (track);
  vertex (0, 0, 0, 0, 0);   vertex (1000, 0, 0, 1000, 0);
  vertex (1000, 0, 1000, 1000, 1000);
  vertex (0, 0, 1000, 0, 1000);
endShape();</code></pre>
<p>The viewpoint needs to be above and behind the car. If the variables <code>dx</code> and <code>dz</code> represent the unit change in the x and z directions for the given <code>angle</code> (the current facing angle of the car), and <code>carX</code> and <code>carZ</code> are the horizontal and vertical positions of the car, then this should be the viewpoint <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>eyex = carX - dx*50;  eyez = carZ - dz*50;</code></pre>
<p class="BodyContinued">And it should have some fixed height <code>eyey=20</code>. The value <code>50</code> is a scale factor that depends on the image size. </p>
<p>We draw the car at coordinates <code>(carX, 0, carZ)</code>. After each step, these coordinates change as a function of the car’s speed (variable <code>velocity</code>); the <code>velocity</code> value increases or decreases as the user presses the <span class="KeyCaps">w</span> and <span class="KeyCaps">s</span> keys <span class="CodeAnnotation" aria-label="annotation4">4</span> (as opposed to previous sketches in which we moved forward and backward using those keys). The <span class="KeyCaps">w</span> key is the accelerator <span epub:type="pagebreak" title="133" id="Page_133"/>pedal, and the <span class="KeyCaps">s</span> is the brake. The car maintains its speed once the user presses one of those keys, and the user can focus on steering using <span class="KeyCaps">a</span> and <span class="KeyCaps">d</span>.</p>
<p>We calculate the motion of the car as follows:</p>
<pre><code>carX = carX + velocity*dx 
carZ = carZ + velocity*dz </code></pre>
<p class="BodyContinued">Then we use the <code>translate()</code> function to make the car face the direction of motion <span class="CodeAnnotation" aria-label="annotation2">2</span>. The car should always face away from the camera, so to make the car face in the correct direction, we rotate it by <code>–angle</code>.</p>
<p>The effect is that the car (a red prism) can speed up (<span class="KeyCaps">w</span>) and slow down (<span class="KeyCaps">s</span>) and turn left (<span class="KeyCaps">a</span>) or right (<span class="KeyCaps">d</span>) so as to stay on the grey circular path, and the camera follows the car at a discreet distance. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage track;
float eyey = 20,eyex = 213,eyez = 400.0;
float cx=200.0, cy=5.0, cz= 200.0,dx = 0.0, dz = 1.0;
float angle = 265.0, velocity=0.,carX=200, carY=0, carZ=310;

void setup ()
{
  size (600, 400, P3D);
  track = loadImage ("road.png");
  keyPressed(); 
  fill (180, 30, 30);
}

void draw ()
{
  background(0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> beginShape(QUADS);
    texture (track);
    vertex (0, 0, 0, 0, 0);
    vertex (1000, 0, 0, 1000, 0);
    vertex (1000, 0, 1000, 1000, 1000);
    vertex (0, 0, 1000, 0, 1000);
  endShape();
  translate (carX, 4, carZ); 
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> rotateY(-radians(angle));
  box(20, 5, 10);
  carX = carX + velocity*dx; 
  carZ = carZ + velocity*dz;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> eyex = carX - dx*50;  eyez = carZ - dz*50;
  camera (eyex, eyey, eyez, cx, cy, cz, 0.0, -1.0, 0.0);
}

void keyPressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (key == 'w') velocity += .1;  // Move 'forward'  
  if (key == 's') velocity -= .1;  // Move 'backward' 
  if (key == 'a') angle = angle +2.0; // Turn left a unit (CCW)
  if (key == 'd') angle = angle -2.0; // Turn right a unit (CW)
  if (angle &lt; 0) angle = angle + 360.0;
  else if (angle &gt; 360.0) angle = angle - 360.0;
  dx = cos(radians(angle)); dz = sin(radians(angle));
  cx =(int)(dx*20000.0);  // cx = x coordinate of center point = cos(angle)*20000
  cz =(int)(dz*20000.0);  // cz = z coordinate of center point = sin(angle)*20000
}</code></pre>
<figure class="graphic"><img src="Images/g060001.png" alt="g060001" width="381" height="254"/></figure>
<figure class="graphic"><img src="Images/g060002.png" alt="g060002" width="381" height="254"/></figure>

<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>