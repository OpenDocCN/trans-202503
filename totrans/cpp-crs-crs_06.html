<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_88"/><span epub:type="pagebreak" id="page_89"/><strong><span class="big">4</span><br/>THE OBJECT LIFE CYCLE</strong></h2>&#13;
<p class="quote"><em>Things you used to own, now they own you.<br/>—Chuck Palahniuk,</em> Fight Club</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The object life cycle is the series of stages a C++ object goes through during its lifetime. This chapter begins with a discussion of an object’s storage duration, the time during which storage is allocated for an object. You’ll learn about how the object life cycle dovetails with exceptions to handle error conditions and cleanup in a robust, safe, and elegant way. The chapter closes with a discussion of move and copy semantics that provides you with granular control over an object’s life cycle.</p>&#13;
<h3 class="h3" id="ch04lev1sec1"><strong>An Object’s Storage Duration</strong></h3>&#13;
<p class="noindent">An <em>object</em> is a region of storage that has a type and a value. When you declare a variable, you create an object. A variable is simply an object that has a name.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><span epub:type="pagebreak" id="page_90"/><strong><em>Allocation, Deallocation, and Lifetime</em></strong></h4>&#13;
<p class="noindent">Every object requires storage. You reserve storage for objects in a process called <em>allocation</em>. When you’re done with an object, you release the object’s storage in a process called <em>deallocation</em>.</p>&#13;
<p class="indent">An object’s <em>storage duration</em> begins when the object is allocated and ends when the object is deallocated. The <em>lifetime</em> of an object is a runtime property that is bound by the object’s storage duration. An object’s lifetime begins once its constructor completes, and it ends just before a destructor is invoked. In summary, each object passes through the following stages:</p>&#13;
<ol>&#13;
<li class="noindent">The object’s storage duration begins, and storage is allocated.</li>&#13;
<li class="noindent">The object’s constructor is called.</li>&#13;
<li class="noindent">The object’s lifetime begins.</li>&#13;
<li class="noindent">You can use the object in your program.</li>&#13;
<li class="noindent">The object’s lifetime ends.</li>&#13;
<li class="noindent">The object’s destructor is called.</li>&#13;
<li class="noindent">The object’s storage duration ends, and storage is deallocated.</li>&#13;
</ol>&#13;
<h4 class="h4" id="ch04lev2sec2"><strong><em>Memory Management</em></strong></h4>&#13;
<p class="noindent">If you’ve been programming in an application language, chances are you’ve used an <em>automatic memory manager</em>, or a <em>garbage collector</em>. At runtime, programs create objects. Periodically, the garbage collector determines which objects are no longer required by the program and safely deallocates them. This approach frees the programmer from worrying about managing an object’s life cycle, but it incurs several costs, including runtime performance, and requires some powerful programming techniques like deterministic resource management.</p>&#13;
<p class="indent">C++ takes a more efficient approach. The trade-off is that C++ programmers must have intimate knowledge of storage durations. It’s <em>our</em> job, not the garbage collector’s, to craft object lifetimes.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><strong><em>Automatic Storage Duration</em></strong></h4>&#13;
<p class="noindent">An <em>automatic object</em> is allocated at the beginning of an enclosing code block, and it’s deallocated at the end. The enclosing block is the automatic object’s <em>scope</em>. Automatic objects are said to have <em>automatic storage duration</em>. Note that function parameters are automatic, even though notationally they appear outside the function body.</p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch04ex01">Listing 4-1</a>, the function <code>power_up_rat_thing</code> is the scope for the automatic variables <code>nuclear_isotopes</code> and <code>waste_heat</code>.</p>&#13;
<pre>void power_up_rat_thing(int nuclear_isotopes) {&#13;
  int waste_heat = 0;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex01"/><em>Listing 4-1: A function with two automatic variables, <code>nuclear_isotopes</code> and <code>waste_heat</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>Both <code>nuclear_isotopes</code> and <code>waste_heat</code> are allocated each time <code>power_up_rat_thing</code> is invoked. Just before <code>power_up_rat_thing</code> returns, these variables are deallocated.</p>&#13;
<p class="indent">Because you cannot access these variables outside of <code>power_up_rat_thing</code>, automatic variables are also called <em>local variables</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec4"><strong><em>Static Storage Duration</em></strong></h4>&#13;
<p class="noindent">A <em>static object</em> is declared using the <code>static</code> or <code>extern</code> keyword. You declare static variables at the same level you declare functions—at global scope (or <em>namespace scope</em>). Static objects with global scope have <em>static storage duration</em> and are allocated when the program starts and deallocated when the program stops.</p>&#13;
<p class="indent">The program in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> powers up a Rat Thing with nuclear isotopes by calling the <code>power_up_rat_thing</code> function. When it does, the Rat Thing’s power increases, and the variable <code>rat_things_power</code> keeps track of the power level between power-ups.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
static int rat_things_power = 200; <span class="ent">➊</span>&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  rat_things_power = rat_things_power + nuclear_isotopes; <span class="ent">➋</span>&#13;
  const auto waste_heat = rat_things_power * 20; <span class="ent">➌</span>&#13;
  if (waste_heat &gt; 10000) { <span class="ent">➍</span>&#13;
    printf("Warning! Hot doggie!\n"); <span class="ent">➎</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  printf("Rat-thing power: %d\n", rat_things_power); <span class="ent">➏</span>&#13;
  power_up_rat_thing(100); <span class="ent">➐</span>&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
  power_up_rat_thing(500);&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Rat-thing power: 200</span>&#13;
<span class="color1">Rat-thing power: 300</span>&#13;
<span class="color1">Warning! Hot doggie! <span class="ent">➑</span></span>&#13;
<span class="color1">Rat-thing power: 800</span></pre>&#13;
<p class="listing"><a id="ch04ex02"/><em>Listing 4-2: A program with a static variable and several automatic variables</em></p>&#13;
<p class="indent">The variable <code>rat_things_power</code> <span class="ent">➊</span> is a static variable because it’s declared at global scope with the <code>static</code> keyword. Another feature of being declared at global scope is that <code>rat_things_power</code> can be accessed from any function in the translation unit. (Recall from <a href="ch01.xhtml#ch01">Chapter 1</a> that a translation unit is what a preprocessor produces after acting on a single source file.) At <span class="ent">➋</span>, you see <code>power_up_rat_thing</code> increasing <code>rat_things_power</code> by the number of <code>nuclear_isotopes</code>. Because <code>rat_things_power</code> is a static variable—and hence its <span epub:type="pagebreak" id="page_92"/>lifetime is the program’s lifetime—each time you call <code>power_up_rat_thing</code>, the value of <code>rat_things_power</code> carries over into the next call.</p>&#13;
<p class="indent">Next, you calculate how much waste heat is produced given the new value of <code>rat_things_power</code>, and you store the result in the automatic variable <code>waste_heat</code> <span class="ent">➌</span>. Its storage duration begins when <code>power_up_rat_thing</code> is called and ends when <code>power_up_rat_thing</code> returns, so its values aren’t saved between function calls. Finally, you check whether waste_heat is over a threshold value of <code>1000</code> <span class="ent">➍</span>. If it is, you print a warning message <span class="ent">➎</span></p>&#13;
<p class="indent">Within <code>main</code>, you alternate between printing the value of <code>rat_things_power</code> <span class="ent">➏</span> and calling <code>power_up_rat_thing</code> <span class="ent">➐</span>.</p>&#13;
<p class="indent">Once you’ve increased the Rat Thing’s power from <code>300</code> to <code>800</code>, you get the warning message in the output <span class="ent">➑</span>. The effects of modifying <code>rat_things_power</code> last for the lifetime of the program due to its static storage duration.</p>&#13;
<p class="indent">When you use the <code>static</code> keyword, you specify <em>internal linkage</em>. Internal linkage means that a variable is inaccessible to other translation units. You can alternately specify <em>external linkage</em>, which makes a variable accessible to other translation units. For external linkage, you use the <code>extern</code> keyword instead of <code>static</code>.</p>&#13;
<p class="indent">You could modify <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> in the following way to achieve external linkage:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
extern int rat_things_power = 200; // External linkage&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">With <code>extern</code> rather than <code>static</code>, you can access <code>rat_things_power</code> from other translation units.</p>&#13;
<h5 class="h5" id="ch04lev3sec1"><strong>Local Static Variables</strong></h5>&#13;
<p class="noindent">A <em>local static variable</em> is a special kind of static variable that is a local—rather than global—variable. Local static variables are declared at function scope, just like automatic variables. But their lifetimes begin upon the first invocation of the enclosing function and end when the program exits.</p>&#13;
<p class="indent">For example, you could refactor <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> to make <code>rat_things_power</code> a local static variable, as demonstrated in <a href="ch04.xhtml#ch04ex03">Listing 4-3</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  static int rat_things_power = 200;&#13;
  rat_things_power = rat_things_power + nuclear_isotopes;&#13;
  const auto waste_heat = rat_things_power * 20;&#13;
  if (waste_heat &gt; 10000) {&#13;
    printf("Warning! Hot doggie!\n");&#13;
  }&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
}&#13;
<span epub:type="pagebreak" id="page_93"/>int main() {&#13;
  power_up_rat_thing(100);&#13;
  power_up_rat_thing(500);&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex03"/><em>Listing 4-3: A refactor of <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> using a local static variable.</em></p>&#13;
<p class="indent">Unlike in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a>, you cannot refer to <code>rat_things_power</code> from outside of the <code>power_up_rat_thing</code> function due to its local scope. This is an example of a programming pattern called <em>encapsulation</em>, which is the bundling of data with a function that operates on that data. It helps to protect against unintended modification.</p>&#13;
<h5 class="h5" id="ch04lev3sec2"><strong>Static Members</strong></h5>&#13;
<p class="noindent"><em>Static members</em> are members of a class that aren’t associated with a particular instance of the class. Normal class members have lifetimes nested within the class’s lifetime, but static members have static storage duration.</p>&#13;
<p class="indent">These members are essentially similar to static variables and functions declared at global scope; however, you must refer to them by the containing class’s name, using the scope resolution operator <code>::</code>. In fact, you must initialize static members at global scope. You cannot initialize a static member within a containing class definition.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is an exception to the static member initialization rule: you can declare and define integral types within a class definition as long as they’re also <code>const</code>.</em></p>&#13;
</div>&#13;
<p class="indent">Like other static variables, static members have only a single instance. All instances of a class with static members share the same member, so if you modify a static member, <em>all</em> class instances will observe the modification. To illustrate, you could convert <code>power_up_rat_thing</code> and <code>rat_things_power</code> in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> to static members of a <code>RatThing</code> class, as shown in <a href="ch04.xhtml#ch04ex04">Listing 4-4</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct RatThing {&#13;
  static int rat_things_power; <span class="ent">➊</span>&#13;
  static<span class="ent">➋</span> void power_up_rat_thing(int nuclear_isotopes) {&#13;
    rat_things_power<span class="ent">➌</span> = rat_things_power + nuclear_isotopes;&#13;
    const auto waste_heat = rat_things_power * 20;&#13;
    if (waste_heat &gt; 10000) {&#13;
      printf("Warning! Hot doggie!\n");&#13;
    }&#13;
    printf("Rat-thing power: %d\n", rat_things_power);&#13;
  }&#13;
};&#13;
&#13;
int RatThing::rat_things_power = 200; <span class="ent">➍</span>&#13;
&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_94"/>  RatThing::power_up_rat_thing(100); <span class="ent">➎</span>&#13;
  RatThing::power_up_rat_thing(500);&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex04"/><em>Listing 4-4: A refactor of <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> using static members</em></p>&#13;
<p class="indent">The <code>RatThing</code> class contains <code>rat_things_power</code> as a static member variable <span class="ent">➊</span> and <code>power_up_rat_thing</code> as a static method <span class="ent">➋</span>. Because <code>rat_things_power</code> is a member of <code>RatThing</code>, you don’t need the scope resolution operator <span class="ent">➌</span>; you access it like any other member.</p>&#13;
<p class="indent">You see the scope resolution operator in action where <code>rat_things_power</code> is initialized <span class="ent">➍</span> and where you invoke the static method <code>power_up_rat_thing</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec5"><strong><em>Thread-Local Storage Duration</em></strong></h4>&#13;
<p class="noindent">One of the fundamental concepts in concurrent programs is the <em>thread</em>. Each program has one or more threads that can perform independent operations. The sequence of instructions that a thread executes is called its <em>thread of execution</em>.</p>&#13;
<p class="indent">Programmers must take extra precautions when using more than one thread of execution. Code that multiple threads can execute safely is called <em>thread-safe code</em>. Mutable global variables are the source of many thread safety issues. Sometimes, you can avoid these issues by giving each thread its own copy of a variable. You can do this by specifying that an object has <em>thread storage duration</em>.</p>&#13;
<p class="indent">You can modify any variable with static storage duration to have thread-local storage duration by adding the <code>thread_local</code> keyword to the <code>static</code> or <code>extern</code> keyword. If only <code>thread_local</code> is specified, <code>static</code> is assumed. The variable’s linkage is unchanged.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex03">Listing 4-3</a> is not thread safe. Depending on the order of reads and writes, <code>rat_things_power</code> could become corrupted. You could make <a href="ch04.xhtml#ch04ex03">Listing 4-3</a> thread safe by specifying <code>rat_things_power</code> as <code>thread_local</code>, as demonstrated here:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  static thread_local int rat_things_power = 200; <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Now each thread would represent its own Rat Thing; if one thread modifies its <code>rat_things_power</code>, the modification will not affect the other threads. Each copy of <code>rat_things_power</code> is initialized to 200 <span class="ent">➊</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Concurrent programming is discussed in more detail in <a href="ch19.xhtml#ch19">Chapter 19</a>. Thread storage duration is presented here for completeness.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec6"><strong><em><span epub:type="pagebreak" id="page_95"/>Dynamic Storage Duration</em></strong></h4>&#13;
<p class="noindent">Objects with <em>dynamic storage duration</em> are allocated and deallocated on request. You have manual control over when a <em>dynamic object</em>’s life begins and when it ends. Dynamic objects are also called <em>allocated objects</em> for this reason.</p>&#13;
<p class="indent">The primary way to allocate a dynamic object is with a <em>new expression</em>. A new expression begins with the <code>new</code> keyword followed by the desired type of the dynamic object. New expressions create objects of a given type and then return a pointer to the newly minted object.</p>&#13;
<p class="indent">Consider the following example where you create an <code>int</code> with dynamic storage duration and save it into a pointer called <code>my_int_ptr</code>:</p>&#13;
<pre>int*<span class="ent">➊</span> my_int_ptr = new<span class="ent">➋</span> int<span class="ent">➌</span>;</pre>&#13;
<p class="indent">You declare a pointer to <code>int</code> and initialize it with the result of the new expression on the right side of the equal sign <span class="ent">➊</span>. The new expression is composed of the <code>new</code> keyword <span class="ent">➋</span> followed by the desired type <code>int</code> <span class="ent">➌</span>. When the new expression executes, the C++ runtime allocates memory to store an <code>int</code> and then returns its pointer.</p>&#13;
<p class="indent">You can also initialize a dynamic object within a new expression, as shown here:</p>&#13;
<pre>int* my_int_ptr = new int{ 42 }; // Initializes dynamic object to 42</pre>&#13;
<p class="indent">After allocating storage for the <code>int</code>, the dynamic object will be initialized as usual. After initialization completes, the dynamic object’s lifetime begins.</p>&#13;
<p class="indent">You deallocate dynamic objects using the <em>delete expression</em>, which is composed of the <code>delete</code> keyword followed by a pointer to the dynamic object. Delete expressions always return <code>void</code>.</p>&#13;
<p class="indent">To deallocate the object pointed to by <code>my_int_ptr</code>, you would use the following delete expression:</p>&#13;
<pre>delete my_int_ptr;</pre>&#13;
<p class="indent">The value contained in memory where the deleted object resided is undefined, meaning the compiler can produce code that leaves anything there. In practice, major compilers will try to be as efficient as possible, so typically the object’s memory will remain untouched until the program reuses it for some other purposes. You would have to implement a custom destructor to, for example, zero out some sensitive contents.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because the compiler doesn’t typically clean up memory after an object is deleted, a subtle and potentially serious type of bug called a <em>use after free</em> can occur. If you delete an object and accidentally reuse it, your program might appear to function correctly because the deallocated memory might still contain reasonable values. In some situations, the problems don’t manifest until the program has been in production for a long time—or until a security researcher finds a way to exploit the bug and discloses it!</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec3"><strong><span epub:type="pagebreak" id="page_96"/>Dynamic Arrays</strong></h5>&#13;
<p class="noindent"><em>Dynamic arrays</em> are arrays with dynamic storage duration. You create dynamic arrays with <em>array new expressions</em>. Array new expressions have the following form:</p>&#13;
<pre>new MyType[n_elements] { init-list }</pre>&#13;
<p class="indent"><code>MyType</code> is the desired type of the array elements, <code>n_elements</code> is the length of the desired array, and the optional <code>init-list</code> is an initialization list to initialize the array. Array new expressions return a pointer to the first element of the newly allocated array.</p>&#13;
<p class="indent">In the following example, you allocate an <code>int</code> array of length 100 and save the result into a pointer called <code>my_int_array_ptr</code>:</p>&#13;
<pre>int* my_int_array_ptr = new int[100<span class="ent">➊</span>];</pre>&#13;
<p class="indent">The number of elements <span class="ent">➊</span> doesn’t need to be constant: the size of the array can be determined at runtime, meaning the value between brackets <span class="ent">➊</span> could be a variable rather than a literal.</p>&#13;
<p class="indent">To deallocate a dynamic array, use the <em>array delete expression</em>. Unlike the array new expression, the array delete expression doesn’t require a length:</p>&#13;
<pre>delete[] my_int_array_ptr</pre>&#13;
<p class="indent">Like the delete expression, the array delete expression returns <code>void</code>.</p>&#13;
<h5 class="h5" id="ch04lev3sec4"><strong>Memory Leaks</strong></h5>&#13;
<p class="noindent">With privilege comes responsibility, so you must make sure that dynamic objects you allocate are also deallocated. Failure to do so causes <em>memory leaks</em> in which memory that is no longer needed by your program isn’t released. When you leak memory, you use up a resource in your environment that you’ll never reclaim. This can cause performance problems or worse.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In practice, your program’s operating environment might clean up leaked resources for you. For example, if you’ve written user-mode code, modern operating systems will clean up the resources when the program exits. However, if you’ve written kernel code, those operating systems won’t clean up the resources. You’ll only reclaim them when the computer reboots.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>Tracing the Object Life Cycle</strong></h3>&#13;
<p class="noindent">The object life cycle is as daunting to newcomers as it is powerful. Let’s clarify with an example that explores each of the storage durations.</p>&#13;
<p class="indent">Consider the <code>Tracer</code> class in <a href="ch04.xhtml#ch04ex05">Listing 4-5</a>, which prints a message whenever a <code>Tracer</code> object is constructed or destructed. You can use this class to <span epub:type="pagebreak" id="page_97"/>investigate object life cycles, because each <code>Tracer</code> clearly indicates when its life is beginning and ending.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name<span class="ent">➊</span>) : name{ name }<span class="ent">➋</span> {&#13;
    printf("%s constructed.\n", name); <span class="ent">➌</span>&#13;
  }&#13;
  ~Tracer() {&#13;
    printf("%s destructed.\n", name); <span class="ent">➍</span>&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex05"/><em>Listing 4-5: A <code>Tracer</code> class that announces construction and destruction</em></p>&#13;
<p class="indent">The constructor takes a single parameter <span class="ent">➊</span> and saves it into the member <code>name</code> <span class="ent">➋</span>. It then prints a message containing <code>name</code> <span class="ent">➌</span>. The destructor <span class="ent">➍</span> also prints a message with <code>name</code>.</p>&#13;
<p class="indent">Consider the program in <a href="ch04.xhtml#ch04ex06">Listing 4-6</a>. Four different <code>Tracer</code> objects have different storage durations. By looking at the order of the program’s <code>Tracer</code> output, you can verify what you’ve learned about storage durations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
static Tracer t1{ "Static variable" }; <span class="ent">➊</span>&#13;
thread_local Tracer t2{ "Thread-local variable" }; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
const auto t2_ptr = &amp;t2;&#13;
  printf("A\n"); <span class="ent">➌</span>&#13;
  Tracer t3{ "Automatic variable" }; <span class="ent">➍</span>&#13;
  printf("B\n");&#13;
  const auto* t4 = new Tracer{ "Dynamic variable" }; <span class="ent">➎</span>&#13;
  printf("C\n");&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex06"/><em>Listing 4-6: A program using the <code>Tracer</code> class in <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> to illustrate storage duration</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex06">Listing 4-6</a> contains a <code>Tracer</code> with static duration <span class="ent">➊</span>, thread local duration <span class="ent">➋</span>, automatic duration <span class="ent">➍</span>, and dynamic duration <span class="ent">➎</span>. Between each line in <code>main</code>, you print the character <code>A</code>, <code>B</code>, or <code>C</code> for reference <span class="ent">➌</span>.</p>&#13;
<p class="indent">Running the program yields <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>.</p>&#13;
<pre>Static variable constructed.&#13;
Thread-local variable constructed.&#13;
A <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_98"/>Automatic variable constructed.&#13;
B&#13;
Dynamic variable constructed.&#13;
C&#13;
Automatic variable destructed.&#13;
Thread-local variable destructed.&#13;
Static variable destructed.</pre>&#13;
<p class="listing"><a id="ch04ex07"/><em>Listing 4-7: Sample output from running <a href="ch04.xhtml#ch04ex06">Listing 4-6</a></em></p>&#13;
<p class="indent">Before the first line of <code>main</code> <span class="ent">➌</span>, the static and thread local variables <code>t1</code> and <code>t2</code> have been initialized <span class="ent">➊</span> <span class="ent">➋</span>. You can see this in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>: both variables have printed their initialization messages before <code>A</code>. As an automatic variable, the scope of <code>t3</code> is bounded by the enclosing function <code>main</code>. Accordingly, <code>t3</code> is constructed where it is initialized just after <code>A</code>.</p>&#13;
<p class="indent">After <code>B</code>, you see the message corresponding to the initialization of <code>t4</code> <span class="ent">➎</span>. Notice that there’s no corresponding message generated by the dynamic destructor of <code>Tracer</code>. The reason is that you’ve (intentionally) leaked the object pointed to by <code>t4</code>. Because there’s no command to <code>delete t4</code>, the destructor is never called.</p>&#13;
<p class="indent">Just before <code>main</code> returns, <code>C</code> prints. Because <code>t3</code> is an automatic variable whose scope is <code>main</code>, it’s destroyed at this point because <code>main</code> is returning.</p>&#13;
<p class="indent">Finally, the static and thread-local variables <code>t1</code> and <code>t2</code> are destroyed just before program exit, yielding the final two messages in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>Exceptions</strong></h3>&#13;
<p class="noindent"><em>Exceptions</em> are types that communicate an error condition. When an error condition occurs, you <em>throw</em> an exception. After you throw an exception, it’s <em>in flight</em>. When an exception is in flight, the program stops normal execution and searches for an <em>exception handler</em> that can manage the in-flight exception. Objects that fall out of scope during this process are destroyed.</p>&#13;
<p class="indent">In situations where there’s no good way to handle an error locally, such as in a constructor, you generally use exceptions. Exceptions play a crucial role in managing object life cycles in such circumstances.</p>&#13;
<p class="indent">The other option for communicating error conditions is to return an error code as part of a function’s prototype. These two approaches are complementary. In situations where an error occurs that can be dealt with locally or that is expected to occur during the normal course of a program’s execution, you generally return an error code.</p>&#13;
<h4 class="h4" id="ch04lev2sec7"><strong><em>The throw Keyword</em></strong></h4>&#13;
<p class="noindent">To throw an exception, use the <code>throw</code> keyword followed by a throwable object.</p>&#13;
<p class="indent">Most objects are throwable. But it’s good practice to use one of the exceptions available in stdlib, such as <code>std::runtime_error</code> in the <code>&lt;stdexcept&gt;</code> header. The <code>runtime_error</code> constructor accepts a null-terminated <code>const char*</code> describing the nature of the error condition. You can retrieve this message via the <code>what</code> method, which takes no parameters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>The <code>Groucho</code> class in <a href="ch04.xhtml#ch04ex08">Listing 4-8</a> throws an exception whenever you invoke the <code>forget</code> method with an argument equal to <code>0xFACE</code>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
struct Groucho {&#13;
  void forget(int x) {&#13;
    if (x == 0xFACE) {&#13;
      throw<span class="ent">➊</span> std::runtime_error<span class="ent">➋</span>{ "I'd be glad to make an exception." };&#13;
    }&#13;
    printf("Forgot 0x%x\n", x);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex08"/><em>Listing 4-8: The <code>Groucho</code> class</em></p>&#13;
<p class="indent">To throw an exception, <a href="ch04.xhtml#ch04ex08">Listing 4-8</a> uses the <code>throw</code> keyword <span class="ent">➊</span> followed by a <code>std::runtime_error</code> object <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec8"><strong><em>Using try-catch Blocks</em></strong></h4>&#13;
<p class="noindent">You use <code>try</code>-<code>catch</code> blocks to establish exception handlers for a block of code. Within the <code>try</code> block, you place code that might throw an exception. Within the <code>catch</code> block, you specify a handler for each exception type you can handle.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex09">Listing 4-9</a> illustrates the use of a <code>try</code>-<code>catch</code> block to handle exceptions thrown by a <code>Groucho</code> object.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
struct Groucho {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  Groucho groucho;&#13;
  try { <span class="ent">➊</span>&#13;
    groucho.forget(0xC0DE); <span class="ent">➋</span>&#13;
    groucho.forget(0x<a id="_idTextAnchor179"/>FACE); <span class="ent">➌</span>&#13;
    groucho.forget(0xC0FFEE); <span class="ent">➍</span>&#13;
  } catch (const std::runtime_error&amp; e<span class="ent">➎</span>) {&#13;
    printf("exception caught with message: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex09"/><em>Listing 4-9: The use of <code>try</code>-<code>catch</code> to handle the exceptions of the <code>Groucho</code> class</em></p>&#13;
<p class="indent">In <code>main</code>, you construct a <code>Groucho</code> object and then establish a <code>try</code>-<code>catch</code> block <span class="ent">➊</span>. Within the <code>try</code> portion, you invoke the <code>groucho</code> class’s <code>forget</code> method with several different parameters: <code>0xC0DE</code> <span class="ent">➋</span>, <code>0xFACE</code> <span class="ent">➌</span>, and <code>0xC0FFEE</code> <span class="ent">➍</span>. Within the <code>catch</code> portion, you handle any <code>std::runtime_error</code> exceptions <span class="ent">➎</span> by printing the message to the console <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>When you run the program in <a href="ch04.xhtml#ch04ex09">Listing 4-9</a>, you get the following output:</p>&#13;
<pre>Forgot 0xc0de&#13;
exception caught with message: I'd be glad to make an exception.</pre>&#13;
<p class="indent">When you invoked <code>forget</code> with the argument <code>0xC0DE</code> <span class="ent">➋</span>, <code>groucho</code> printed <code>Forgot 0xc0de</code> and returned. When you invoked <code>forget</code> with the argument <code>0xFACE</code> <span class="ent">➌</span>, <code>groucho</code> threw an exception. This exception stopped normal program execution, so <code>forget</code> is never invoked again <span class="ent">➍</span>. Instead, the in-flight exception is caught <span class="ent">➎</span>, and its message is printed <span class="ent">➏</span>.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>A CRASH COURSE IN INHERITANCE</strong></p>&#13;
<p class="noindent">Before introducing the stdlib exceptions, you need to understand simple C++ class inheritance at a very high level. Classes can have subclasses that inherit the functionality of their superclasses. The syntax in <a href="ch04.xhtml#ch04ex10">Listing 4-10</a> defines this relationship.</p>&#13;
<pre>struct Superclass {&#13;
  int x;&#13;
};&#13;
&#13;
struct Subclass : Superclass { <span class="ent">➊</span>&#13;
  int y;&#13;
  int foo() {&#13;
    return x + y; <span class="ent">➋</span>&#13;
}&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex10"/><em>Listing 4-10: Defining superclasses and subclasses</em></p>&#13;
<p class="indent">There’s nothing special about <code>Superclass</code>. But the declaration of <code>Subclass</code> <span class="ent">➊</span> is special. It defines the inheritance relationship using the : <code>Superclass</code> syntax. <code>Subclass</code> inherits members from <code>Superclass</code> that are not marked private. You can see this in action where <code>Subclass</code> uses the field x <span class="ent">➋</span>. This is a field belonging to <code>Superclass</code>, but because <code>Subclass</code> inherits from Superclass, x is accessible.</p>&#13;
<p class="indent">Exceptions use these inheritance relationships to determine whether a handler catches an exception. Handlers will catch a given type and any of its childrens’ types.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec9"><strong><em>stdlib Exception Classes</em></strong></h4>&#13;
<p class="noindent">You can arrange classes into parent-child relationships using <em>inheritance</em>. Inheritance has a big impact on how the code handles exceptions. There is a nice, simple hierarchy of existing exception types available for use in the stdlib. You should try to use these types for simple programs. Why reinvent the wheel?</p>&#13;
<h5 class="h5" id="ch04lev3sec5"><strong><span epub:type="pagebreak" id="page_101"/>Standard Exception Classes</strong></h5>&#13;
<p class="noindent">The stdlib provides you with the <em>standard exception classes</em> in the <code>&lt;stdexcept&gt;</code> header. These should be your first port of call when you’re programming exceptions. The superclass for all the standard exception classes is the class <code>std::exception</code>. All the subclasses in <code>std::exception</code> can be partitioned into three groups: logic errors, runtime errors, and language support errors. While language support errors are not generally relevant to you as a programmer, you’ll definitely encounter logic errors and runtime errors. <a href="ch04.xhtml#ch04fig01">Figure 4-1</a> summarizes their relationship.</p>&#13;
<div class="image"><img src="../images/fig4_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig01"><em>Figure 4-1: How stdlib exceptions are nested under std::exception</em></p>&#13;
<h5 class="h5" id="ch04lev3sec6"><strong>Logic Errors</strong></h5>&#13;
<p class="noindent"><em>Logic errors</em> derive from the <code>logic_error</code> class. Generally, you could avoid these exceptions through more careful programming. A primary example is when a logical precondition of a class isn’t satisfied, such as when a class invariant cannot be established. (Remember from <a href="ch02.xhtml#ch02">Chapter 2</a> that a class invariant is a feature of a class that is always true.)</p>&#13;
<p class="indent">Since a class invariant is something that the programmer defines, neither the compiler nor the runtime environment can enforce it without help. You can use a class constructor to check for various conditions, and if you cannot establish a class invariant, you can throw an exception. If the failure is the result of, say, passing an incorrect parameter to the constructor, a <code>logic_error</code> is an appropriate exception to throw.</p>&#13;
<p class="indent">The <code>logic_error</code> has several subclasses that you should be aware of:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>domain_error</code> reports errors related to valid input range, especially for math functions. The square root, for example, only supports non-negative numbers (in the real case). If a negative argument is passed, a square root function could throw a <code>domain_error</code>.</li>&#13;
<li class="noindent">The <code>invalid_argument</code> exception reports generally unexpected arguments.</li>&#13;
<li class="noindent">The <code>length_error</code> exception reports that some action would violate a maximum size constraint.</li>&#13;
<li class="noindent">The <code>out_of_range</code> exception reports that some value isn’t in an expected range. The canonical example is bounds-checked indexing into a data structure.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch04lev3sec7"><strong><span epub:type="pagebreak" id="page_102"/>Runtime Errors</strong></h5>&#13;
<p class="noindent"><em>Runtime errors</em> derive from the <code>runtime_error</code> class. These exceptions help you report error conditions that are outside the program’s scope. Like <code>logic_error</code>, <code>runtime_error</code> has some subclasses that you might find useful:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>system_error</code> reports that the operating system encountered some error. You can get a lot of mileage out of this kind of exception. Inside of the <code>&lt;system_error&gt;</code> header, there’s a large number of <em>error codes</em> and <em>error conditions</em>. When a <code>system_error</code> is constructed, information about the error is packed in so you can determine the nature of the error. The <code>.code()</code> method returns an <code>enum class</code> of type <code>std::errc</code> that has a large number of values, such as <code>bad_file_descriptor</code>, <code>timed_out</code>, and <code>permission_denied</code>.</li>&#13;
<li class="noindent">The <code>overflow_error</code> and <code>underflow_error</code> report arithmetic overflow and underflow, respectively.</li>&#13;
</ul>&#13;
<p class="indent">Other errors inherit directly from <code>exception</code>. A common one is the <code>bad_alloc</code> exception, which reports that <code>new</code> failed to allocate the required memory for dynamic storage.</p>&#13;
<h5 class="h5" id="ch04lev3sec8"><strong>Language Support Errors</strong></h5>&#13;
<p class="indent">You won’t use language support errors directly. They exist to indicate that some core language feature failed at runtime.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><strong><em>Handling Exceptions</em></strong></h4>&#13;
<p class="noindent">The rules for exception handling are based on class inheritance. When an exception is thrown, a <code>catch</code> block handles the exception if the thrown exception’s type matches the <code>catch</code> handler’s exception type or if the thrown exception’s type <em>inherits from</em> the <code>catch</code> handler’s exception type.</p>&#13;
<p class="indent">For example, the following handler catches any exception that inherits from <code>std::exception</code>, including a <code>std::logic_error</code>:</p>&#13;
<pre>try {&#13;
  throw std::logic_error{ "It's not about who wrong "&#13;
                        "it's not about who right" };&#13;
} catch (std::exception&amp; ex) {&#13;
  // Handles std::logic_error as it inherits from std::exception&#13;
}</pre>&#13;
<p class="noindent">The following special handler catches <em>any</em> exception regardless of its type:</p>&#13;
<pre>try {&#13;
  throw 'z'; // Don't do this.&#13;
} catch (...) {&#13;
  // Handles any exception, even a 'z'&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Special handlers are typically used as a safety mechanism to log the program’s catastrophic failure to catch an exception of a specific type.</p>&#13;
<p class="indent">You can handle different types of exceptions originating from the same <code>try</code> block by chaining together <code>catch</code> statements, as demonstrated here:</p>&#13;
<pre>try {&#13;
  // Code that might throw an exception&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::logic_error&amp; ex) {&#13;
  // Log exception and terminate the program; there is a programming error!&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::runtime_error&amp; ex) {&#13;
  // Do our best to recover gracefully&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::exception&amp; ex) {&#13;
  // This will handle any exception that derives from std:exception&#13;
  // that is not a logic_error or a runtime_error.&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (...) {&#13;
  // Panic; an unforeseen exception type was thrown&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">It’s common to see such code in a program’s entry point.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>RETHROWING AN EXCEPTION</strong></p>&#13;
<p class="noindent">In a <code>catch</code> block, you can use the throw keyword to resume searching for an appropriate exception handler. This is called rethrowing an exception. There are some unusual but important cases where you might want to further inspect an exception before deciding to handle it, as shown in <a href="ch04.xhtml#ch04ex11">Listing 4-11</a>.</p>&#13;
<pre>try {&#13;
  // Some code that might throw a system_error&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch(const std::system_error&amp; ex) {&#13;
  if(ex.code()!= std::errc::permission_denied){&#13;
    // Not a permission denied error&#13;
    throw; <span class="ent">➊</span>&#13;
  }&#13;
  // Recover from a permission denied&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex11"/><em>Listing 4-11: Rethrowing an error</em></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_104"/>In this example, some code that might throw a <code>system_error</code> is wrapped in a <code>try-catch</code> block. All <code>system_errors</code> are handled, but unless it’s an <code>EACCES (permission denied)</code> error, you rethrow the exception <span class="ent">➊</span>  There are some performance penalties to this approach, and the resulting code is often needlessly convoluted.</p>&#13;
<p class="noindent">Rather than rethrowing, you can define a new exception type and create a separate <code>catch</code> handler for the <code>EACCES</code> error, as demonstrated in <a href="ch04.xhtml#ch04ex12">Listing 4-12</a>.</p>&#13;
<pre>try {&#13;
  // Throw a PermissionDenied instead&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch(const PermissionDenied&amp; ex) {&#13;
  // Recover from an EACCES error (Permission Denied) ..&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex12"/><em>Listing 4-12: Catching a specific exception rather than rethrowing</em></p>&#13;
<p class="noindent">If a <code>std::system_error</code> is thrown, the <code>PermissionDenied</code> handler <span class="ent">➊</span> won’t catch it. (Of course, you could still keep the <code>std::system_error</code> handler to catch such exceptions if you wish.)</p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec11"><strong><em>User-Defined Exceptions</em></strong></h4>&#13;
<p class="noindent">You can define your own exceptions whenever you’d like; usually, these <em>user-defined exceptions</em> inherit from <code>std::exception</code>. All the classes from stdlib use exceptions that derive from <code>std::exception</code>. This makes it easy to catch all exceptions, whether from your code or from the stdlib, with a single <code>catch</code> block.</p>&#13;
<h4 class="h4" id="ch04lev2sec12"><strong><em>The noexcept Keyword</em></strong></h4>&#13;
<p class="noindent">The keyword <code>noexcept</code> is another exception-related term you should know. You can, and should, mark any function that cannot possibly throw an exception <code>noexcept</code>, as in the following:</p>&#13;
<pre>bool is_odd(int x) noexcept {&#13;
  return 1 == (x % 2);&#13;
}</pre>&#13;
<p class="indent">Functions marked <code>noexcept</code> make a rigid contract. When you’re using a function marked <code>noexcept</code>, you can rest assured that the function cannot throw an exception. In exchange, you must be extremely careful when you mark your own function <code>noexcept</code>, since the compiler won’t check for you. If your code throws an exception inside a function marked <code>noexcept</code>, <span epub:type="pagebreak" id="page_105"/>it’s bad juju. The C++ runtime will call the function <code>std::terminate</code>, a function that by default will exit the program via <code>abort</code>. Your program cannot recover:</p>&#13;
<pre>void hari_kari() noexcept {&#13;
  throw std::runtime_error{ "Goodbye, cruel world." };&#13;
}</pre>&#13;
<p class="indent">Marking a function <code>noexcept</code> enables some code optimizations that rely on the function’s not being able to throw an exception. Essentially, the compiler is liberated to use move semantics, which may be faster (more about this in “Move Semantics” on <a href="ch04.xhtml#page_122">page 122</a>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Check out Item 14 of Effective Modern C++ by Scott Meyers for a thorough discussion of <code>noexcept</code>. The gist is that some move constructors and move assignment operators might throw an exception, for example, if they need to allocate memory and the system is out. Unless a move constructor or move assignment operator specifies otherwise, the compiler must assume that a move could cause an exception. This disables certain optimizations.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec13"><strong><em>Call Stacks and Exceptions</em></strong></h4>&#13;
<p class="noindent">The <em>call stack</em> is a runtime structure that stores information about active functions. When a piece of code (the <em>caller</em>) invokes a function (the <em>callee</em>), the machine keeps track of who called whom by pushing information onto the call stack. This allows programs to have many function calls nested within each other. The callee could then, in turn, become the caller by invoking another function.</p>&#13;
<h5 class="h5" id="ch04lev3sec9"><strong>Stacks</strong></h5>&#13;
<p class="noindent">A stack is a flexible data container that can hold a dynamic number of elements. There are two essential operations that all stacks support: <em>pushing</em> elements onto the top of the stack and <em>popping</em> those elements off. It is a last-in, first-out data structure, as illustrated in <a href="ch04.xhtml#ch04fig02">Figure 4-2</a>.</p>&#13;
<div class="image"><img src="../images/fig4_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig02"><em>Figure 4-2: Elements being pushed onto and popped off of a stack</em></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_106"/>As its name suggests, the call stack is functionally similar to its namesake data container. Each time a function is invoked, information about the function invocation is arranged into a <em>stack frame</em> and pushed onto the call stack. Because a new stack frame is pushed onto the stack for every function call, a callee is free to call other functions, forming arbitrarily deep call chains. Whenever a function returns, its stack frame is popped off the top of the call stack, and execution control resumes as indicated by the previous stack frame.</p>&#13;
<h5 class="h5" id="ch04lev3sec10"><strong>Call Stacks and Exception Handling</strong></h5>&#13;
<p class="noindent">The runtime seeks the closest exception handler to a thrown exception. If there is a matching exception handler in the current stack frame, it will handle the exception. If no matching handler is found, the runtime will unwind the call stack until it finds a suitable handler. Any objects whose lifetimes end are destroyed in the usual way.</p>&#13;
<h5 class="h5" id="ch04lev3sec11"><strong>Throwing in Destructors</strong></h5>&#13;
<p class="noindent">If you throw an exception in a destructor, you are juggling with chainsaws. Such an exception absolutely must be caught within the destructor.</p>&#13;
<p class="indent">Suppose an exception is thrown, and during stack unwinding, another exception is thrown by a destructor during normal cleanup. Now you have <em>two</em> exceptions in flight. How should the C++ runtime handle such a situation?</p>&#13;
<p class="indent">You can have an opinion on the matter, but the runtime will call <code>terminate</code>. Consider <a href="ch04.xhtml#ch04ex13">Listing 4-13</a>, which illustrates what can happen when you throw an exception from a destructor:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct CyberdyneSeries800 {&#13;
  CyberdyneSeries800() {&#13;
    printf("I'm a friend of Sarah Connor."); <span class="ent">➊</span>&#13;
  }&#13;
  ~CyberdyneSeries800() {&#13;
    throw std::runtime_error{ "I'll be back." }; <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  try {&#13;
    CyberdyneSeries800 t800; <span class="ent">➌</span>&#13;
    throw std::runtime_error{ "Come with me if you want to live." }; <span class="ent">➍</span>&#13;
  } catch(const std::exception&amp; e) { <span class="ent">➎</span>&#13;
    printf("Caught exception: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm a friend of Sarah Connor. <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch04ex13"/><em>Listing 4-13: A program illustrating the perils of throwing an exception within a destructor</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_107"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch04.xhtml#ch04ex13">Listing 4-13</a> calls <code>std::terminate</code>, so depending on your environment, you might get a nasty pop-up indicating this.</em></p>&#13;
</div>&#13;
<p class="indent">First, you declare the <code>CyberdyneSeries800</code> class, which has a simple constructor that prints a message <span class="ent">➊</span> and a thoroughly belligerent destructor that throws an uncaught exception <span class="ent">➋</span>. Within <code>main</code>, you set up a <code>try</code> block where you initialize a <code>CyberdyneSeries800</code> called <code>t800</code> <span class="ent">➌</span> and throw a <code>runtime_error</code> <span class="ent">➍</span>. Under better circumstances, the <code>catch</code> block <span class="ent">➎</span> would handle this exception, print its message <span class="ent">➏</span>, and exit gracefully. Because <code>t800</code> is an automatic variable within the <code>try</code> block, it destructs during the normal process of finding a handler for the exception you’ve thrown <span class="ent">➍</span>. And because <code>t800</code> throws an exception in its destructor <span class="ent">➋</span>, your program invokes <code>std::terminate</code> and ends abruptly.</p>&#13;
<p class="indent">As a general rule, treat destructors as if they were <code>noexcept</code>.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><strong>A SimpleString Class</strong></h3>&#13;
<p class="noindent">Using an extended example, let’s explore how constructors, destructors, members, and exceptions gel together. The <code>SimpleString</code> class in <a href="ch04.xhtml#ch04ex14">Listing 4-14</a> allows you to add C-style strings together and print the result.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleString {&#13;
  SimpleString(size_t max_size) <span class="ent">➊</span>&#13;
    : max_size{ max_size }, <span class="ent">➋</span>&#13;
      length{} { <span class="ent">➌</span>&#13;
    if (max_size == 0) {&#13;
      throw std::runtime_error{ "Max size must be at least 1." }; <span class="ent">➍</span>&#13;
    }&#13;
    buffer = new char[max_size]; <span class="ent">➎</span>&#13;
    buffer[0] = 0; <span class="ent">➏</span>&#13;
  }&#13;
&#13;
  ~SimpleString() {&#13;
    delete[] buffer; <span class="ent">➐</span>&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  size_t max_size;&#13;
  char* buffer;&#13;
  size_t length;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex14"/><em>Listing 4-14: The constructor and destructor of a <code>SimpleString</code> class</em></p>&#13;
<p class="indent">The constructor <span class="ent">➊</span> takes a single <code>max_size</code> argument. This is the maximum length of your string, which includes a null terminator. The member initializer <span class="ent">➋</span> saves this length into the <code>max_size</code> member variable. This value is also used in the array new expression to allocate a buffer to store your string <span class="ent">➎</span>. The resulting pointer is stored into <code>buffer</code>. You initialize length <span epub:type="pagebreak" id="page_108"/>to zero <span class="ent">➌</span> and ensure that there is at least enough size for a null byte <span class="ent">➍</span>. Because the string is initially empty, you assign the first byte of the buffer to zero <span class="ent">➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because <code>max_size</code> is a <code>size_t</code>, it is unsigned and cannot be negative, so you don’t need to check for this bogus condition.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>SimpleString</code> class owns a resource—the memory pointed to by <code>buffer</code>—which must be released when it’s no longer needed. The destructor contains a single line <span class="ent">➐</span> that deallocates <code>buffer</code>. Because you’ve paired the allocation and deallocation of <code>buffer</code> with the constructor and destructor of <code>SimpleString</code>, you’ll never leak the storage.</p>&#13;
<p class="indent">This pattern is called <em>resource acquisition is initialization (RAII)</em> or <em>constructor acquires, destructor releases (CADRe)</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code>SimpleString</code> class still has an implicitly defined copy constructor. Although it might never leak the storage, it will potentially double free if copied. You’ll learn about copy constructors in “Copy Semantics” on <a href="ch04.xhtml#page_115">page 115</a>. Just be aware that <a href="ch04.xhtml#ch04ex14">Listing 4-14</a> is a teaching tool, not production-worthy code.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec14"><strong><em>Appending and Printing</em></strong></h4>&#13;
<p class="noindent">The <code>SimpleString</code> class isn’t of much use yet. <a href="ch04.xhtml#ch04ex15">Listing 4-15</a> adds the ability to print the string and append a line to the end of the string.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  void print(const char* tag) const { <span class="ent">➊</span>&#13;
    printf("%s: %s", tag, buffer);&#13;
  }&#13;
&#13;
  bool append_line(const char* x) { <span class="ent">➋</span>&#13;
    const auto x_len = strlen<span class="ent">➌</span>(x);&#13;
    if (x_len + length + 2 &gt; max_size) return false; <span class="ent">➍</span>&#13;
    std::strncpy<span class="ent">➎</span>(buffer + length, x, max_size - length);&#13;
    length += x_len;&#13;
    buffer[length++] = '\n';&#13;
    buffer[length] = 0;&#13;
    return true;&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex15"/><em>Listing 4-15: The <code>print</code> and <code>append_line</code> methods of <code>SimpleString</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>The first method <code>print</code> <span class="ent">➊</span> prints your string. For convenience, you can provide a <code>tag</code> string so you can match an invocation of <code>print</code> with the result. This method is <code>const</code> because it doesn’t need to modify the state of a <code>SimpleString</code>.</p>&#13;
<p class="indent">The <code>append_line</code> method <span class="ent">➋</span> takes a null-terminated string <code>x</code> and adds its contents—plus a newline character—to <code>buffer</code>. It returns <code>true</code> if <code>x</code> was successfully appended and <code>false</code> if there wasn’t enough space. First, <code>append_line</code> must determine the length of <code>x</code>. For this, you employ the <code>strlen</code> function <span class="ent">➌</span> from the <code>&lt;cstring&gt;</code> header, which accepts a null-terminated string and returns its length:</p>&#13;
<pre>size_t strlen(const char* str);</pre>&#13;
<p class="indent">You use <code>strlen</code> to compute the length of <code>x</code> and initialize <code>x_len</code> with the result. This result is used to compute whether appending <code>x</code> (a newline character) and a null byte to the current string would result in a string with length greater than <code>max_size</code> <span class="ent">➍</span>. If it would, <code>append_line</code> returns <code>false</code>.</p>&#13;
<p class="indent">If there is enough room to append <code>x</code>, you need to copy its bytes into the correct location in <code>buffer</code>. The <code>std::strncpy</code> function <span class="ent">➎</span> from the <code>&lt;cstring&gt;</code> header is one possible tool for this job. It accepts three arguments: the <code>destination</code> address, the <code>source</code> address, and the <code>num</code> of characters to copy:</p>&#13;
<pre>char* std::strncpy(char* destination, const char* source, std::size_t num);</pre>&#13;
<p class="indent">The <code>strncpy</code> function will copy up to <code>num</code> bytes from <code>source</code> into <code>destination</code>. Once complete, it will return <code>destination</code> (which you discard).</p>&#13;
<p class="indent">After adding the number of bytes <code>x_len</code> copied into <code>buffer</code> to <code>length</code>, you finish by adding a newline character <code>\n</code> and a null byte to the end of <code>buffer</code>. You return <code>true</code> to indicate that you’ve successfully appended the input <code>x</code> as a line to the end of <code>buffer</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Use <code>strncpy</code> very carefully. It’s too easy to forget the null-terminator in the <code>source</code> string or not allocate enough space in the <code>destination</code> string. Both errors will cause undefined behavior. We’ll cover a safer alternative in <a href="part02.xhtml#part02">Part II</a> of the book.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec15"><strong><em>Using SimpleString</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04ex16">Listing 4-16</a> illustrates an example use of <code>SimpleString</code> where you append several strings and print intermediate results to the console.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;exception&gt;&#13;
&#13;
struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
<span epub:type="pagebreak" id="page_110"/>int main() {&#13;
  SimpleString string{ 115 }; <span class="ent">➊</span>&#13;
  string.append_line("Starbuck, whaddya hear?");&#13;
  string.append_line("Nothin' but the rain."); <span class="ent">➋</span>&#13;
  string.print("A") <span class="ent">➌</span>&#13;
  string.append_line("Grab your gun and bring the cat in.");&#13;
  string.append_line("Aye-aye sir, coming home."); <span class="ent">➍</span>&#13;
  string.print("B") <span class="ent">➎</span>&#13;
  if (!string.append_line("Galactica!")) { <span class="ent">➏</span>&#13;
    printf("String was not big enough to append another message."); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex16"/><em>Listing 4-16: The methods of <code>SimpleString</code></em></p>&#13;
<p class="indent">First, you create a <code>SimpleString</code> with <code>max_length=115</code> <span class="ent">➊</span>. You use the <code>append_line</code> method twice <span class="ent">➋</span> to add some data to <code>string</code> and then print the contents along with the tag <code>A</code> <span class="ent">➌</span>. You then append more text <span class="ent">➍</span> and print the contents again, this time with the tag <code>B</code> <span class="ent">➎</span>. When <code>append_line</code> determines that <code>SimpleString</code> has run out of space <span class="ent">➏</span>, it returns <code>false</code> <span class="ent">➐</span>. (It’s your responsibility as a user of <code>SimpleString</code> to check for this condition.)</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex17">Listing 4-17</a> contains output from running this program.</p>&#13;
<pre>A: Starbuck, whaddya hear? <span class="ent">➊</span>&#13;
Nothin' but the rain.&#13;
B: Starbuck, whaddya hear? <span class="ent">➋</span>&#13;
Nothin' but the rain.&#13;
Grab your gun and bring the cat in.&#13;
Aye-aye sir, coming home.&#13;
String was not big enough to append another message. <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch04ex17"/><em>Listing 4-17: Output from running the program in <a href="ch04.xhtml#ch04ex16">Listing 4-16</a></em></p>&#13;
<p class="indent">As expected, the string contains <code>Starbuck, whaddya hear?\nNothin' but the rain.\n</code> at <code>A</code> <span class="ent">➊</span>. (Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that <code>\n</code> is the newline special character.) After appending <code>Grab your gun and bring the cat in.</code> and <code>Aye-aye sir, coming home.</code>, you get the expected output at <code>B</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">When <a href="ch04.xhtml#ch04ex17">Listing 4-17</a> tries to append <code>Galactica!</code> to <code>string</code>, <code>append_line</code> returns <code>false</code> because there is not enough space in <code>buffer</code>. This causes the message <code>String was not big enough to append another message</code> to print <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec16"><strong><em>Composing a SimpleString</em></strong></h4>&#13;
<p class="noindent">Consider what happens when you define a class with a <code>SimpleString</code> member, as demonstrated in <a href="ch04.xhtml#ch04ex18">Listing 4-18</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleStringOwner {&#13;
  SimpleStringOwner(const char* x)&#13;
    : string{ 10 } { <span class="ent">➊</span>&#13;
    if (!string.append_line(x)) {&#13;
      throw std::runtime_error{ "Not enough memory!" };&#13;
<span epub:type="pagebreak" id="page_111"/>    }&#13;
    string.print("Constructed");&#13;
  }&#13;
  ~SimpleStringOwner() {&#13;
    string.print("About to destroy"); <span class="ent">➋</span>&#13;
  }&#13;
private:&#13;
  SimpleString string;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex18"/><em>Listing 4-18: The implementation of <code>SimpleStringOwner</code></em></p>&#13;
<p class="indent">As suggested by the member initializer <span class="ent">➊</span>, <code>string</code> is fully constructed, and its class invariants are established once the constructor of <code>SimpleStringOwner</code> executes. This illustrates the order of an object’s members during construction: <em>members are constructed before the enclosing object’s constructor</em>. This makes sense: how can you establish a class’s invariants if you don’t know about its members’ invariants?</p>&#13;
<p class="indent">Destructors work the opposite way. Inside <code>~SimpleStringOwner()</code> <span class="ent">➋</span>, you need the class invariants of <code>string</code> to hold so you can print its contents. <em>All members are destructed after the object’s destructor is invoked.</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex19">Listing 4-19</a> exercises a <code>SimpleStringOwner</code>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleStringOwner x{ "x" };&#13;
  printf("x is alive\n");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructed: x <span class="ent">➊</span></span>&#13;
<span class="color1">x is alive</span>&#13;
<span class="color1">About to destroy: x <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch04ex19"/><em>Listing 4-19: A program containing a <code>SimpleStringOwner</code></em></p>&#13;
<p class="indent">As expected, the member <code>string</code> of <code>x</code> is created appropriately because <em>an object’s member constructors are called before the object’s constructor</em>, resulting in the message <code>Constructed: x</code> <span class="ent">➊</span>. As an automatic variable, <code>x</code> is destroyed just before <code>main</code> returns, and you get <code>About to destroy: x</code> <span class="ent">➋</span>. The member <code>string</code> is still valid at this point because member destructors are called after the enclosing object’s destructor.</p>&#13;
<h4 class="h4" id="ch04lev2sec17"><strong><em>Call Stack Unwinding</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04ex20">Listing 4-20</a> demonstrates how exception handling and stack unwinding work together. You establish a <code>try</code>-<code>catch</code> block in <code>main</code> and then make a series of function calls. One of these calls causes an exception.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void fn_c() {&#13;
  SimpleStringOwner c{ "cccccccccc" }; <span class="ent">➊</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_112"/>void fn_b() {&#13;
  SimpleStringOwner b{ "b" };&#13;
  fn_c(); <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  try { <span class="ent">➌</span>&#13;
    SimpleStringOwner a{ "a" };&#13;
    fn_b(); <span class="ent">➍</span>&#13;
    SimpleStringOwner d{ "d" }; <span class="ent">➎</span>&#13;
  } catch(const std::exception&amp; e) { <span class="ent">➏</span>&#13;
    printf("Exception: %s\n", e.what());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex20"/><em>Listing 4-20: A program illustrating the use of <code>SimpleStringOwner</code> and call stack unwinding</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex21">Listing 4-21</a> shows the results of running the program in <a href="ch04.xhtml#ch04ex20">Listing 4-20</a>.</p>&#13;
<pre>Constructed: a&#13;
Constructed: b&#13;
About to destroy: b&#13;
About to destroy: a&#13;
Exception: Not enough memory!</pre>&#13;
<p class="listing"><a id="ch04ex21"/><em>Listing 4-21: Output from running the program in <a href="ch04.xhtml#ch04ex20">Listing 4-20</a></em></p>&#13;
<p class="indent">You’ve set up a <code>try</code>-<code>catch</code> block <span class="ent">➌</span>. The first <code>SimpleStringOwner</code>, <code>a</code>, gets constructed without incident, and you see <code>Constructed: a</code> printed to the console. Next, <code>fn_b</code> is called <span class="ent">➍</span>. Notice that you’re still in the <code>try</code>-<code>catch</code> block, so any <code>exception</code> that gets thrown <em>will</em> be handled. Inside <code>fn_b</code>, another <code>SimpleString Owner</code>, <code>b</code>, gets constructed successfully, and <code>Constructed: b</code> is printed to the console. Next, there’s a call into yet another function, <code>fn_c</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Let’s pause for a moment to take an account of what the call stack looks like, what objects are alive, and what the exception-handling situation looks like. You have two <code>SimpleStringOwner</code> objects alive and valid: <code>a</code> and <code>b</code>. The call stack looks like <code>main() → fn_b() → fn_c()</code>, and you have an exception handler set up inside <code>main</code> to handle any exceptions. <a href="ch04.xhtml#ch04fig03">Figure 4-3</a> summarizes this situation.</p>&#13;
<p class="indent">At <span class="ent">➊</span>, you run into a little problem. Recall that <code>SimpleStringOwner</code> has a member <code>SimpleString</code> that is always initialized with a <code>max_size</code> of 10. When you try to construct <code>c</code>, the constructor of <code>SimpleStringOwner</code> throws an <code>exception</code> because you’ve tried to append <code>"cccccccccc"</code>, which has length 10 and is too big to fit alongside a newline and a null terminator.</p>&#13;
<p class="indent">Now you have an exception in flight. The stack will unwind until an appropriate handler is found, and all objects that fall out of scope as a result of this unwinding will be destructed. The handler is all the way up the stack <span class="ent">➏</span>, so <code>fn_c</code> and <code>fn_b</code> unwind. Because <code>SimpleStringOwner b</code> is an automatic variable in <code>fn_b</code>, it gets destructed and you see <code>About to destroy: b</code> printed to the console. After <code>fn_b</code>, the automatic variables inside <code>try{}</code> are destroyed. This includes <code>SimpleStringOwner a</code>, so you see <code>About to destroy: a</code> printed to the console.</p>&#13;
<div class="image"><img src="../images/fig4_3.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig03"><em>Figure 4-3: The call stack when <code>fn_c</code> calls the constructor of <code>SimpleStringOwner c</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Once an exception occurs in a <code>try{}</code> block, no further statements execute. As a result, <code>d</code> never initializes <span class="ent">➎</span>, and you never see the constructor of <code>d</code> print to console. After the call stack is unwound, execution proceeds immediately to the <code>catch</code> block. In the end, you print the message <code>Exception: Not enough memory!</code> to the console <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec18"><strong><em>Exceptions and Performance</em></strong></h4>&#13;
<p class="noindent">In your programs, you must handle errors; errors are unavoidable. When you use exceptions correctly and no errors occur, your code is faster than manually error-checked code. If an error does occur, exception handling can sometimes be slower, but you make huge gains in robustness and maintainability over the alternative. Kurt Guntheroth, the author of <em>Optimized C++</em>, puts it well: “use of exception handling leads to programs that are faster when they execute normally, and better behaved when they fail.” When a C++ program executes normally (without exceptions being thrown), there is no runtime overhead associated with checking exceptions. It’s only when an exception is thrown that you pay overhead.</p>&#13;
<p class="indent">Hopefully, you’re convinced of the central role exceptions play in idiomatic C++ programs. Sometimes, unfortunately, you won’t be able to use exceptions. One example is embedded development where real-time guarantees are required. Tools simply don’t (yet) exist in this setting. With luck, this will change soon, but for now, you’re stuck without exceptions in most embedded contexts. Another example is with some legacy code. Exceptions are elegant because of how they fit in with RAII objects. When destructors are responsible for cleaning up resources, stack unwinding is a direct and effective way to guarantee against resource leakages. In legacy code, you might find manual resource management and error handling instead of RAII objects. This makes using exceptions very dangerous, because stack unwinding is safe only with RAII objects. Without them, you could easily leak resources.</p>&#13;
<h4 class="h4" id="ch04lev2sec19"><span epub:type="pagebreak" id="page_114"/><strong><em>Alternatives to Exceptions</em></strong></h4>&#13;
<p class="noindent">In situations where exceptions are not available, all is not lost. Although you’ll need to keep track of errors manually, there are some helpful C++ features that you can employ to take the sting out a bit. First, you can manually enforce class invariants by exposing some method that communicates whether the class invariants could be established, as shown here:</p>&#13;
<pre>struct HumptyDumpty {&#13;
   HumptyDumpty();&#13;
   bool is_together_again();&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">In idiomatic C++, you would just throw an exception in the constructor, but here you must remember to check and treat the situation as an error condition in your calling code:</p>&#13;
<pre>bool send_kings_horses_and_men() {&#13;
  HumptyDumpty hd{};&#13;
  if (hd.is_together_again()) return false;&#13;
  // Class invariants of hd are now guaranteed.&#13;
  // Humpty Dumpty had a great fall.&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  return true;&#13;
}</pre>&#13;
<p class="indent">The second, complementary coping strategy is to return multiple values using <em>structured binding declaration</em>, a language feature that allows you to return multiple values from a function call. You can use this feature to return success flags alongside the usual return value, as demonstrated in <a href="ch04.xhtml#ch04ex22">Listing 4-22</a>.</p>&#13;
<pre>struct Result { <span class="ent">➊</span>&#13;
  HumptyDumpty hd;&#13;
  bool success;&#13;
};&#13;
&#13;
Result make_humpty() { <span class="ent">➋</span>&#13;
  HumptyDumpty hd{};&#13;
  bool is_valid;&#13;
  // Check that hd is valid and set is_valid appropriately&#13;
  return { hd, is_valid };&#13;
}&#13;
&#13;
bool send_kings_horses_and_men() {&#13;
  auto [hd, success] = make_humpty(); <span class="ent">➌</span>&#13;
  if(!success) return false;&#13;
  // Class invariants established&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  return true;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex22"/><em>Listing 4-22: A code segment illustrating structured binding declaration</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>First, you declare a POD that contains a <code>HumptyDumpty</code> and a <code>success</code> flag <span class="ent">➊</span>. Next, you define the function <code>make_humpty</code> <span class="ent">➋</span>, which builds and validates a <code>HumptyDumpty</code>. Such methods are called <em>factory methods</em>, because their purpose is to initialize objects. The <code>make_humpty</code> function packs this and the success flag into a <code>Result</code> when it returns. The syntax at the call site <span class="ent">➌</span> illustrates how you can unpack the <code>Result</code> into multiple, <code>auto</code>-type-deduced variables.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll explore structured bindings in more detail in “Structured Bindings” on <a href="ch08.xhtml#page_222">page 222</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Copy Semantics</strong></h3>&#13;
<p class="noindent"><em>Copy semantics</em> is “the meaning of copy.” In practice, programmers use the term to mean the rules for making copies of objects: after <code>x</code> is <em>copied into</em> <code>y</code>, they’re <em>equivalent</em> and <em>independent</em>. That is, <code>x == y</code> is true after a copy (equivalence), and a modification to <code>x</code> doesn’t cause a modification of <code>y</code> (independence).</p>&#13;
<p class="indent">Copying is extremely common, especially when passing objects to functions by value, as demonstrated in <a href="ch04.xhtml#ch04ex23">Listing 4-23</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int add_one_to(int x) {&#13;
  x++; <span class="ent">➊</span>&#13;
  return x;&#13;
}&#13;
&#13;
int main() {&#13;
  auto original = 1;&#13;
  auto result = add_one_to(original); <span class="ent">➋</span>&#13;
  printf("Original: %d; Result: %d", original, result);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Original: 1; Result: 2</span></pre>&#13;
<p class="listing"><a id="ch04ex23"/><em>Listing 4-23: A program illustrating that passing by value generates a copy</em></p>&#13;
<p class="indent">Here, <code>add_one_to</code> takes its argument <code>x</code> by value. It then modifies the value of <code>x</code> <span class="ent">➊</span>. This modification is isolated from the caller <span class="ent">➋</span>; <code>original</code> is unaffected because <code>add_one_to</code> gets a copy.</p>&#13;
<p class="indent">For user-defined POD types, the story is similar. Passing by value causes each member value to be copied into the parameter (a <em>member-wise copy</em>), as demonstrated in <a href="ch04.xhtml#ch04ex24">Listing 4-24</a>.</p>&#13;
<pre>struct Point {&#13;
  int x, y;&#13;
};&#13;
&#13;
Point make_transpose(Point p) {&#13;
  int tmp = p.x;&#13;
  p.x = p.y;&#13;
<span epub:type="pagebreak" id="page_116"/>  p.y = tmp;&#13;
  return p;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex24"/><em>Listing 4-24: The function <code>make_transpose</code> generates a copy of the POD type <code>Point</code>.</em></p>&#13;
<p class="indent">When <code>make_transpose</code> is invoked, it receives a copy <code>Point</code> in <code>p</code>, and the original is unaffected.</p>&#13;
<p class="indent">For fundamental and POD types, the story is straightforward. Copying these types is memberwise, which means each member gets copied into its corresponding destination. This is effectively a bitwise copy from one memory address to another.</p>&#13;
<p class="indent">Fully featured classes require some more thought. The default copy semantics for fully featured classes is also the memberwise copy, and this can be extremely dangerous. Consider again the <code>SimpleString</code> class. You would invite disaster if you allowed a user to make a memberwise copy of a live <code>SimpleString</code> class. Two <code>SimpleString</code> classes would point to the same <code>buffer</code>. With both of the copies appending to the same <code>buffer</code>, they’ll clobber each other. <a href="ch04.xhtml#ch04fig04">Figure 4-4</a> summarizes the situation.</p>&#13;
<div class="image"><img src="../images/fig4_4.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig04"><em>Figure 4-4: A depiction of default copy semantics on the <code>SimpleString</code> class</em></p>&#13;
<p class="indent">This result is bad, but even worse things happen when the <code>SimpleString</code> classes start destructing. When one of the <code>SimpleString</code> classes is destructed, <code>buffer</code> will be freed. When the remaining <code>SimpleString</code> class tries to write its <code>buffer</code>—bang!—you have undefined behavior. At some point, this remaining <code>SimpleString</code> class will be destructed and free <code>buffer</code> again, resulting in what is commonly called a <em>double free</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Like its nefarious cousin the use after free, the double free can result in subtle and hard-to-diagnose bugs that manifest only very infrequently. A double free occurs when you deallocate an object twice. Recall that once you’ve deallocated an object, its storage lifetime ends. This memory is now in an undefined state, and if you destruct an object that’s already been destructed, you’ve got undefined behavior. In certain situations, this can cause serious security vulnerabilities.</em></p>&#13;
</div>&#13;
<p class="indent">You can avoid this dumpster fire by taking control of copy semantics. You can specify copy constructors and copy assignment operators, as described in the following sections.</p>&#13;
<h4 class="h4" id="ch04lev2sec20"><span epub:type="pagebreak" id="page_117"/><strong><em>Copy Constructors</em></strong></h4>&#13;
<p class="noindent">There are two ways to copy an object. One is to use <em>copy construction</em>, which creates a copy and assigns it to a brand-new object. The copy constructor looks like other constructors:</p>&#13;
<pre>struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  SimpleString(const SimpleString&amp; other);&#13;
};</pre>&#13;
<p class="indent">Notice that <code>other</code> is <code>const</code>. You’re copying from some original <code>SimpleString</code>, and you have no reason to modify it. You use the copy constructor just like other constructors, using the uniform initialization syntax of braced initializers:</p>&#13;
<pre>SimpleString a;&#13;
SimpleString a_copy{ a };</pre>&#13;
<p class="indent">The second line invokes the copy constructor of <code>SimpleString</code> with <code>a</code> to yield <code>a_copy</code>.</p>&#13;
<p class="indent">Let’s implement the copy constructor of <code>SimpleString</code>. You want what is known as a <em>deep copy</em> where you copy the data pointed to by the original <code>buffer</code> into a new <code>buffer</code>, as depicted in <a href="ch04.xhtml#ch04fig05">Figure 4-5</a>.</p>&#13;
<div class="image"><img src="../images/fig4_5.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig05"><em>Figure 4-5: A depiction of a deep copy on the <code>SimpleString</code> class</em></p>&#13;
<p class="indent">Rather than copying the pointer <code>buffer</code>, you’ll make a new allocation on the free store and then copy all the data pointed to by the original <code>buffer</code>. This gives you two independent <code>SimpleString</code> classes. <a href="ch04.xhtml#ch04ex25">Listing 4-25</a> implements the copy constructor of <code>SimpleString</code>:</p>&#13;
<pre>SimpleString(const SimpleString&amp; other)&#13;
  : max_size{ other.max_size }, <span class="ent">➊</span>&#13;
    buffer{ new char[other.max_size] }, <span class="ent">➋</span>&#13;
    length{ other.length } { <span class="ent">➌</span>&#13;
    std::strncpy(buffer, other.buffer, max_size); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex25"/><em>Listing 4-25: <code>SimpleString</code> class’s copy constructor</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>You use member initializers for <code>max_size</code> <span class="ent">➊</span>, <code>buffer</code> <span class="ent">➋</span>, and <code>length</code> <span class="ent">➌</span> and pass in the corresponding fields on <code>other</code>. You can use array new <span class="ent">➋</span> to initialize <code>buffer</code> because you know <code>other.max_size</code> is greater than 0. The copy constructor’s body contains a single statement <span class="ent">➍</span> that copies the contents pointed to by <code>other.buffer</code> into the array pointed to by <code>buffer</code>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex26">Listing 4-26</a> uses this copy constructor by initializing a <code>SimpleString</code> with an existing <code>SimpleString</code>:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  SimpleString a_copy{ a }; <span class="ent">➊</span>&#13;
  a.append_line("inconvenience."); <span class="ent">➋</span>&#13;
  a_copy.append_line("incontinence."); <span class="ent">➌</span>&#13;
  a.print("a");&#13;
  a_copy.print("a_copy");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the</span>&#13;
<span class="color1">inconvenience.</span>&#13;
<span class="color1">a_copy: We apologize for the</span>&#13;
<span class="color1">incontinence.</span></pre>&#13;
<p class="listing"><a id="ch04ex26"/><em>Listing 4-26: A program using <code>SimpleString</code> class’s copy constructor</em></p>&#13;
<p class="indent">In the program, <code>SimpleString a_copy</code> <span class="ent">➊</span> is copy constructed from <code>a</code>. It’s equivalent to—and independent from—the original. You can append different messages to the end of <code>a</code> <span class="ent">➋</span> and <code>a_copy</code> <span class="ent">➌</span>, and the changes are isolated.</p>&#13;
<p class="indent">The copy constructor is invoked when passing <code>SimpleString</code> into a function by value, as demonstrated in <a href="ch04.xhtml#ch04ex27">Listing 4-27</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void foo(SimpleString x) {&#13;
  x.append_line("Change lost.");&#13;
}&#13;
&#13;
int main() {&#13;
  SimpleString a { 20 };&#13;
  foo(a); // Invokes copy constructor&#13;
  a.print("Still empty");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Still empty:</span></pre>&#13;
<p class="listing"><a id="ch04ex27"/><em>Listing 4-27: A program illustrating that copy constructors get invoked when passing an object by value</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You shouldn’t pass by value to avoid modification. Use a <code>const</code> reference.</em></p>&#13;
</div>&#13;
<p class="indent">The performance impact of copying can be substantial, especially in a situation where free store allocations and buffer copies are involved. For example, suppose you have a class that manages the life cycle of a gigabyte <span epub:type="pagebreak" id="page_119"/>of data. Each time you copy the object, you’ll need to allocate and copy a gigabyte of data. This can take a lot of time, so you should be absolutely sure you need the copy. If you can get away with passing a <code>const</code> reference, strongly prefer it.</p>&#13;
<h4 class="h4" id="ch04lev2sec21"><strong><em>Copy Assignment</em></strong></h4>&#13;
<p class="noindent">The other way to make a copy in C++ is with the <em>copy assignment operator</em>. You can create a copy of an object and assign it to another existing object, as demonstrated in <a href="ch04.xhtml#ch04ex28">Listing 4-28</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void dont_do_this() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message");&#13;
  b = a; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex28"/><em>Listing 4-28: Using the default copy assignment operator to create a copy of an object and assign it to another existing object</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The code in <a href="ch04.xhtml#ch04ex28">Listing 4-28</a> causes undefined behavior because it doesn’t have a user-defined copy assignment operator.</em></p>&#13;
</div>&#13;
<p class="indent">The line at <span class="ent">➊</span> <em>copy assigns</em> <code>a</code> to <code>b</code>. The major difference between copy assignment and copy construction is that in copy assignment, <code>b</code> might already have a value. You must clean up <code>b</code>’s resources before copying <code>a</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The default copy assignment operator for simple types just copies the members from the source object to the destination object. In the case of <code><em>SimpleString</em></code>, this is very dangerous for two reasons. First, the original <code><em>SimpleString</em></code> class’s buffer gets rewritten without freeing the dynamically allocated <code><em>char</em></code> array. Second, now two <code><em>SimpleString</em></code> classes own the same buffer, which can cause dangling pointers and double frees. You must implement a copy assignment operator that performs a clean hand-off.</em></p>&#13;
</div>&#13;
<p class="indent">The copy assignment operator uses the <code>operator=</code> syntax, as demonstrated in <a href="ch04.xhtml#ch04ex29">Listing 4-29</a>.</p>&#13;
<pre>struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this; <span class="ent">➊</span>&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    return *this; <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex29"/><em>Listing 4-29: A user-defined copy assignment operator for <code>SimpleString</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>The copy assignment operator returns a reference to the result, which is always <code>*this</code> <span class="ent">➋</span>. It’s also generally good practice to check whether <code>other</code> refers to <code>this</code> <span class="ent">➊</span>.</p>&#13;
<p class="indent">You can implement copy assignment for <code>SimpleString</code> by following these guidelines: free the current <code>buffer</code> of <code>this</code> and then copy <code>other</code> as you did in copy construction, as shown in <a href="ch04.xhtml#ch04ex30">Listing 4-30</a>.</p>&#13;
<pre>  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this;&#13;
    const auto new_buffer = new char[other.max_size]; <span class="ent">➊</span>&#13;
    delete[] buffer; <span class="ent">➋</span>&#13;
    buffer = new_buffer; <span class="ent">➌</span>&#13;
    length = other.length; <span class="ent">➍</span>&#13;
    max_size = other.max_size; <span class="ent">➎</span>&#13;
    std::strncpy(buffer, other.buffer, max_size); <span class="ent">➏</span>&#13;
    return *this;&#13;
  }</pre>&#13;
<p class="listing"><a id="ch04ex30"/><em>Listing 4-30: A copy assignment operator for <code>SimpleString</code></em></p>&#13;
<p class="indent">The copy assignment operator starts by allocating a <code>new_buffer</code> with the appropriate size <span class="ent">➊</span>. Next, you clean up <code>buffer</code> <span class="ent">➋</span>. The rest is essentially identical to the copy constructor in <a href="ch04.xhtml#ch04ex25">Listing 4-25</a>. You copy <code>buffer</code> <span class="ent">➌</span>, <code>length</code> <span class="ent">➍</span>, and <code>max_size</code> <span class="ent">➎</span> and then copy the contents from <code>other.buffer</code> into your own <code>buffer</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex31">Listing 4-31</a> illustrates how <code>SimpleString</code> copy assignment works (as implemented in <a href="ch04.xhtml#ch04ex30">Listing 4-30</a>).</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the"); <span class="ent">➊</span>&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message"); <span class="ent">➋</span>&#13;
  a.print("a"); <span class="ent">➌</span>&#13;
  b.print("b"); <span class="ent">➍</span>&#13;
  b = a; <span class="ent">➎</span>&#13;
  a.print("a"); <span class="ent">➏</span>&#13;
  b.print("b"); <span class="ent">➐</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the <span class="ent">➌</span></span>&#13;
<span class="color1">b: Last message <span class="ent">➍</span></span>&#13;
<span class="color1">a: We apologize for the <span class="ent">➏</span></span>&#13;
<span class="color1">b: We apologize for the <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch04ex31"/><em>Listing 4-31: A program illustrating copy assignment with the <code>SimpleString</code> class</em></p>&#13;
<p class="indent">You begin by declaring two <code>SimpleString</code> classes with different messages: the string <code>a</code> contains <code>We apologize for the</code> <span class="ent">➊</span>, and <code>b</code> contains <code>Last</code> <span epub:type="pagebreak" id="page_121"/><code>message</code> <span class="ent">➋</span>. You print these strings to verify that they contain the text you’ve specified <span class="ent">➌➍</span>. Next, you copy assign <code>b</code> equal to <code>a</code> <span class="ent">➎</span>. Now, <code>a</code> and <code>b</code> contain copies of the same message, <code>We apologize for the</code> <span class="ent">➏➐</span>. But—and this is important—that message resides in two separate memory locations.</p>&#13;
<h4 class="h4" id="ch04lev2sec22"><strong><em>Default Copy</em></strong></h4>&#13;
<p class="noindent">Often, the compiler will generate default implementations for copy construction and copy assignment. The default implementation is to invoke copy construction or copy assignment on each of a class’s members.</p>&#13;
<p class="indent">Any time a class manages a resource, you must be extremely careful with default copy semantics; they’re likely to be wrong (as you saw with <code>SimpleString</code>). Best practice dictates that you explicitly declare that default copy assignment and copy construction are acceptable for such classes using the <code>default</code> keyword. The <code>Replicant</code> class, for example, has default copy semantics, as demonstrated here:</p>&#13;
<pre>struct Replicant {&#13;
  Replicant(const Replicant&amp;) = default;&#13;
  Replicant&amp; operator=(const Replicant&amp;) = default;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">Some classes simply cannot or should not be copied—for example, if your class manages a file or if it represents a mutual exclusion lock for concurrent programming. You can suppress the compiler from generating a copy constructor and a copy assignment operator using the <code>delete</code> keyword. The <code>Highlander</code> class, for example, cannot be copied:</p>&#13;
<pre>struct Highlander {&#13;
  Highlander(const Highlander&amp;) = delete;&#13;
  Highlander&amp; operator=(const Highlander&amp;) = delete;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">Any attempt to copy a <code>Highlander</code> will result in a compiler error:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  Highlander a;&#13;
  Highlander b{ a }; // Bang! There can be only one.&#13;
}</pre>&#13;
<p class="indent">I highly recommend that you explicitly define the copy assignment operator and copy constructor for <em>any</em> class that owns a resource (like a printer, a network connection, or a file). If custom behavior is not needed, use either <code>default</code> or <code>delete</code>. This will save you from a lot of nasty and difficult-to-debug errors.</p>&#13;
<h4 class="h4" id="ch04lev2sec23"><strong><em><span epub:type="pagebreak" id="page_122"/>Copy Guidelines</em></strong></h4>&#13;
<p class="noindent">When you implement copy behavior, think about the following criteria:</p>&#13;
<p class="bq"><strong>Correctness</strong> You must ensure that class invariants are maintained. The <code>SimpleString</code> class demonstrated that the default copy constructor can violate invariants.</p>&#13;
<p class="bq"><strong>Independence</strong> After copy assignment or copy construction, the original object and the copy shouldn’t change each other’s state during modification. Had you simply copied <code>buffer</code> from one <code>SimpleString</code> to another, writing to one <code>buffer</code> could overwrite the data from the other.</p>&#13;
<p class="bq"><strong>Equivalence</strong> The original and the copy should be the <em>same</em>. The semantics of sameness depend on context. But generally, an operation applied to the original should yield the same result when applied to the copy.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Move Semantics</strong></h3>&#13;
<p class="noindent">Copying can be quite time-consuming at runtime when a large amount of data is involved. Often, you just want to <em>transfer ownership</em> of resources from one object to another. You could make a copy and destroy the original, but this is often inefficient. Instead, you can <em>move</em>.</p>&#13;
<p class="indent"><em>Move semantics</em> is move’s corollary to copy semantics, and it requires that after an object <code>y</code> is <em>moved into</em> an object <code>x</code>, <code>x</code> is equivalent to the former value of <code>y</code>. After the move, <code>y</code> is in a special state called the <em>moved-from</em> state. You can perform only two operations on moved-from objects: (re)assign them or destruct them. Note that moving an object <code>y</code> into an object <code>x</code> isn’t just a renaming: these are separate objects with separate storage and potentially separate lifetimes.</p>&#13;
<p class="indent">Similar to how you specify copying behavior, you specify how objects move with <em>move constructors</em> and <em>move assignment operators</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec24"><strong><em>Copying Can Be Wasteful</em></strong></h4>&#13;
<p class="noindent">Suppose you want to move a <code>SimpleString</code> into a <code>SimpleStringOwner</code> in the following way:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void own_a_string() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  a.append_line("inconvenience.");&#13;
  SimpleStringOwner b{ a };&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">You could add a constructor for <code>SimpleStringOwner</code> and then copy-construct its <code>SimpleString</code> member, as demonstrated in <a href="ch04.xhtml#ch04ex32">Listing 4-32.</a></p>&#13;
<pre><span epub:type="pagebreak" id="page_123"/>struct SimpleStringOwner {&#13;
  SimpleStringOwner(const SimpleString&amp; my_string) : string{ my_string }<span class="ent">➊</span> { }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  SimpleString string; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex32"/><em>Listing 4-32: A naive approach to member initialization containing a wasteful copy</em></p>&#13;
<p class="indent">There is hidden waste in this approach. You have a copy construction <span class="ent">➊</span>, but the caller never uses the pointed-to object again after constructing <code>string</code> <span class="ent">➋</span>. <a href="ch04.xhtml#ch04fig06">Figure 4-6</a> illustrates the issue.</p>&#13;
<div class="image"><img src="../images/fig4_6.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig06"><em>Figure 4-6: Using the copy constructor for <code>string</code> is wasteful.</em></p>&#13;
<p class="indent">You should move the guts of <code>SimpleString a</code> into the <code>string</code> field of <code>SimpleStringOwner</code>. <a href="ch04.xhtml#ch04fig07">Figure 4-7</a> shows what you want to achieve: <code>SimpleString Owner b</code> steals <code>buffer</code> and sets <code>SimpleString a</code> into a destructible state.</p>&#13;
<div class="image"><img src="../images/fig4_7.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig07"><em>Figure 4-7: Swapping the buffer of <code>a</code> into <code>b</code></em></p>&#13;
<p class="indent">After moving <code>a</code>, the <code>SimpleString</code> of <code>b</code> is equivalent to the former state of <code>a</code>, and <code>a</code> is destructible.</p>&#13;
<p class="indent">Moving can be dangerous. If you accidentally use moved-from <code>a</code>, you’d invite disaster. The class invariants of <code>SimpleString</code> aren’t satisfied when <code>a</code> is moved from.</p>&#13;
<p class="indent">Fortunately, the compiler has built-in safeguards: <em>lvalues</em> and <em>rvalues</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec25"><strong><em><span epub:type="pagebreak" id="page_124"/>Value Categories</em></strong></h4>&#13;
<p class="noindent">Every expression has two important characteristics: its <em>type</em> and its <em>value category</em>. A value category describes what kinds of operations are valid for the expression. Thanks to the evolutionary nature of C++, value categories are complicated: an expression can be a “generalized lvalue” (<em>glvalue</em>), a “pure rvalue” (<em>prvalue</em>), an “expiring value” (<em>xvalue</em>), an <em>lvalue</em> (a glvalue that isn’t an xvalue), or an <em>rvalue</em> (a prvalue or an xvalue). Fortunately for the newcomer, you don’t need to know much about most of these value categories.</p>&#13;
<p class="indent">We’ll consider a very simplified view of value categories. For now, you’ll just need a general understanding of lvalues and rvalues. An <em>lvalue</em> is any value that has a name, and an <em>rvalue</em> is anything that isn’t an lvalue.</p>&#13;
<p class="indent">Consider the following initializations:</p>&#13;
<pre>SimpleString a{ 50 };&#13;
SimpleStringOwner b{ a };                   // a is an lvalue&#13;
SimpleStringOwner c{ SimpleString{ 50 } };  // SimpleString{ 50 } is an rvalue</pre>&#13;
<p class="indent">The etymology of these terms is <em>right value</em> and <em>left value</em>, referring to where each appears with respect to the equal sign in construction. In the statement <code>int x = 50;</code>, <code>x</code> is left of the equal sign (lvalue) and <code>50</code> is right of the equal sign (rvalue). These terms aren’t totally accurate because you can have an lvalue on the right side of an equal sign (as in copy assignment, for example).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The ISO C++ Standard details Value Categories in [basic] and [expr].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec26"><strong><em>lvalue and rvalue References</em></strong></h4>&#13;
<p class="noindent">You can communicate to the compiler that a function accepts lvalues or rvalues using <em>lvalue references</em> and <em>rvalue references</em>. Up to this point in this book, every reference parameter has been an lvalue reference, and these are denoted with a single <code>&amp;</code>. You can also take a parameter by rvalue reference using <code>&amp;&amp;</code>.</p>&#13;
<p class="indent">Fortunately, the compiler does an excellent job of determining whether an object is an lvalue or an rvalue. In fact, you can define multiple functions with the same name but with different parameters, and the compiler will automatically call the correct version depending on what arguments you provide when you invoke the function.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex33">Listing 4-33</a> contains two functions with the name <code>ref_type</code> function to discern whether the invoker passed an lvalue or an rvalue reference.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
void ref_type(int &amp;x) { <span class="ent">➊</span>&#13;
  printf("lvalue reference %d\n", x);&#13;
}&#13;
<span epub:type="pagebreak" id="page_125"/>void ref_type(int &amp;&amp;x) { <span class="ent">➋</span>&#13;
  printf("rvalue reference %d\n", x);&#13;
}&#13;
&#13;
int main() {&#13;
  auto x = 1;&#13;
  ref_type(x); <span class="ent">➌</span>&#13;
  ref_type(2); <span class="ent">➍</span>&#13;
  ref_type(x + 2); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">lvalue reference 1 <span class="ent">➌</span></span>&#13;
<span class="color1">rvalue reference 2 <span class="ent">➍</span></span>&#13;
<span class="color1">rvalue reference 3 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch04ex33"/><em>Listing 4-33: A program containing an overloaded function with lvalue and rvalue references</em></p>&#13;
<p class="indent">The <code>int &amp;x</code> version <span class="ent">➊</span> takes an lvalue reference, and the <code>int &amp;&amp;x</code> version <span class="ent">➋</span> takes an rvalue reference. You invoke <code>ref_type</code> three times. First, you invoke the lvalue reference version, because <code>x</code> is an lvalue (it has a name) <span class="ent">➌</span>. Second, you invoke the rvalue reference version because <code>2</code> is an integer literal without a name <span class="ent">➍</span>. Third, the result of adding 2 to <code>x</code> is not bound to a name, so it’s an rvalue <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Defining multiple functions with the same name but different parameters is called <em>function overloading</em>, a topic you’ll explore in detail in <a href="ch09.xhtml#ch09">Chapter 9</a>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec27"><strong><em>The std::move Function</em></strong></h4>&#13;
<p class="noindent">You can cast an lvalue reference to an rvalue reference using the <code>std::move</code> function from the <code>&lt;utility&gt;</code> header. <a href="ch04.xhtml#ch04ex34">Listing 4-34</a> updates <a href="ch04.xhtml#ch04ex33">Listing 4-33</a> to illustrate the use of the <code>std::move</code> function.</p>&#13;
<pre>#include &lt;utility&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  auto x = 1;&#13;
  ref_type(std::move(x)); <span class="ent">➊</span>&#13;
  ref_type(2);&#13;
  ref_type(x + 2);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">rvalue reference 1 <span class="ent">➊</span></span>&#13;
<span class="color1">rvalue reference 2</span>&#13;
<span class="color1">rvalue reference 3</span></pre>&#13;
<p class="listing"><a id="ch04ex34"/><em>Listing 4-34: An update to <a href="ch04.xhtml#ch04ex33">Listing 4-33</a> using <code>std::move</code> to cast <code>x</code> to an rvalue</em></p>&#13;
<p class="indent">As expected, <code>std::move</code> changes the lvalue <code>x</code> into an rvalue <span class="ent">➊</span>. You never call the lvalue <code>ref_type</code> overload.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_126"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The C++ committee probably should have named <code>std::move</code> as <code>std::rvalue</code>, but it’s the name we’re stuck with. The <code>std:move</code> function doesn’t actually move anything—it casts.</em></p>&#13;
</div>&#13;
<p class="indent">Be very careful when you’re using <code>std::move</code>, because you remove the safeguards keeping you from interacting with a moved-from object. You can perform two actions on a moved-from object: destroy it or reassign it.</p>&#13;
<p class="indent">How lvalue and rvalue semantics enable move semantics should now be clear. If an lvalue is at hand, moving is suppressed. If an rvalue is at hand, moving is enabled.</p>&#13;
<h4 class="h4" id="ch04lev2sec28"><strong><em>Move Construction</em></strong></h4>&#13;
<p class="noindent">Move constructors look like copy constructors except they take rvalue references instead of lvalue references.</p>&#13;
<p class="indent">Consider the <code>SimpleString</code> move constructor in <a href="ch04.xhtml#ch04ex35">Listing 4-35</a>.</p>&#13;
<pre>SimpleString(SimpleString&amp;&amp; other) noexcept&#13;
  : max_size{ other.max_size }, <span class="ent">➊</span>&#13;
  buffer(other.buffer),&#13;
  length(other.length) {&#13;
  other.length = 0; <span class="ent">➋</span>&#13;
  other.buffer = nullptr;&#13;
  other.max_size = 0;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex35"/><em>Listing 4-35: A move constructor for <code>SimpleString</code></em></p>&#13;
<p class="indent">Because <code>other</code> is an rvalue reference, you’re allowed to cannibalize it. In the case of <code>SimpleString</code>, this is easy: just copy all fields of <code>other</code> into <code>this</code> <span class="ent">➊</span> and then zero out the fields of <code>other</code> <span class="ent">➋</span>. The latter step is important: it puts <code>other</code> in a moved-from state. (Consider what would happen upon the destruction of <code>other</code> had you not cleared its members.)</p>&#13;
<p class="indent">Executing this move constructor is a <em>lot</em> less expensive than executing the copy constructor.</p>&#13;
<p class="indent">The move constructor is designed to <em>not</em> throw an exception, so you mark it <code>noexcept</code>. Your preference should be to use <code>noexcept</code> move constructors; often, the compiler cannot use exception-throwing move constructors and will use copy constructors instead. Compilers prefer slow, correct code instead of fast, incorrect code.</p>&#13;
<h4 class="h4" id="ch04lev2sec29"><strong><em>Move Assignment</em></strong></h4>&#13;
<p class="noindent">You can also create a move analogue to copy assignment via <code>operator=</code>. The move assignment operator takes an rvalue reference rather than a <code>const</code> lvalue reference, and you usually mark it <code>noexcept</code>. <a href="ch04.xhtml#ch04ex36">Listing 4-36</a> implements such a move assignment operator for <code>SimpleString</code>.</p>&#13;
<pre>SimpleString&amp; operator=(SimpleString&amp;&amp; other) noexcept { <span class="ent">➊</span>&#13;
  if (this == &amp;other) return *this; <span class="ent">➋</span>&#13;
  delete[] buffer; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_127"/>  buffer = other.buffer; <span class="ent">➍</span>&#13;
  length = other.length;&#13;
  max_size = other.max_size;&#13;
  other.buffer = nullptr; <span class="ent">➎</span>&#13;
  other.length = 0;&#13;
  other.max_size = 0;&#13;
  return *this;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex36"/><em>Listing 4-36: A move assignment operator for <code>SimpleString</code></em></p>&#13;
<p class="indent">You declare the move assignment operator using the rvalue reference syntax and the <code>noexcept</code> qualifier, as with the move constructor <span class="ent">➊</span>. The self-reference check <span class="ent">➋</span> handles the move assignment of a <code>SimpleString</code> to itself. You clean up <code>buffer</code> <span class="ent">➌</span> before assigning the fields of <code>this</code> to the fields of <code>other</code> <span class="ent">➍</span> and zero out the fields of <code>other</code> <span class="ent">➎</span>. Aside from the self-reference check <span class="ent">➋</span> and the cleanup <span class="ent">➌</span>, the move assignment operator and the move constructor are functionally identical.</p>&#13;
<p class="indent">Now that <code>SimpleString</code> is movable, you can complete the <code>SimpleString</code> constructor of <code>SimpleStringOwner</code>:</p>&#13;
<pre>SimpleStringOwner(SimpleString&amp;&amp; x) : string{ std::move(x)<span class="ent">➊</span> } { }</pre>&#13;
<p class="indent">The <code>x</code> is an lvalue, so you must <code>std::move x</code> into the move constructor of <code>string</code> <span class="ent">➊</span>. You might find <code>std::move</code> odd, because <code>x</code> is an rvalue reference. Recall that lvalue/rvalue and lvalue reference/rvalue reference are distinct descriptors.</p>&#13;
<p class="indent">Consider if <code>std::move</code> weren’t required here: what if you moved from <code>x</code> and then used it inside the constructor? This could lead to bugs that are hard to diagnose. Remember that you cannot use moved-from objects except to reassign or destruct them. Doing anything else is undefined behavior.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex37">Listing 4-37</a> illustrates the <code>SimpleString</code> move assignment.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the"); <span class="ent">➊</span>&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message"); <span class="ent">➋</span>&#13;
  a.print("a"); <span class="ent">➌</span>&#13;
  b.print("b"); <span class="ent">➍</span>&#13;
  b = std::move(a); <span class="ent">➎</span>&#13;
  // a is "moved-from"&#13;
  b.print("b"); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the <span class="ent">➌</span></span>&#13;
<span class="color1">b: Last message <span class="ent">➍</span></span>&#13;
<span class="color1">b: We apologize for the <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch04ex37"/><em>Listing 4-37: A program illustrating move assignment with the <code>SimpleString</code> class</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/>As in <a href="ch04.xhtml#ch04ex31">Listing 4-31</a>, you begin by declaring two <code>SimpleString</code> classes with different messages: the string <code>a</code> contains <code>We apologize for the</code> <span class="ent">➊</span>, and <code>b</code> contains <code>Last message</code> <span class="ent">➋</span>. You print these strings to verify that they contain the strings you’ve specified <span class="ent">➌➍</span>. Next, you move assign <code>b</code> equal to <code>a</code> <span class="ent">➎</span>. Note that you had to cast <code>a</code> to an <code>rvalue</code> using <code>std::move</code>. After the move assignment, <code>a</code> is in a moved-from state, and you can’t use it unless you reassign it to a new value. Now, <code>b</code> owns the message that <code>a</code> used to own, <code>We apologize for the</code> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec30"><strong><em>The Final Product</em></strong></h4>&#13;
<p class="noindent">You now have a fully implemented <code>SimpleString</code> that supports move and copy semantics. <a href="ch04.xhtml#ch04ex38">Listing 4-38</a> brings these all together for your reference.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;utility&gt;&#13;
&#13;
struct SimpleString {&#13;
  SimpleString(size_t max_size)&#13;
    : max_size{ max_size },&#13;
    length{} {&#13;
    if (max_size == 0) {&#13;
      throw std::runtime_error{ "Max size must be at least 1." };&#13;
    }&#13;
    buffer = new char[max_size];&#13;
    buffer[0] = 0;&#13;
  }&#13;
  ~SimpleString() {&#13;
    delete[] buffer;&#13;
  }&#13;
  SimpleString(const SimpleString&amp; other)&#13;
    : max_size{ other.max_size },&#13;
    buffer{ new char[other.max_size] },&#13;
    length{ other.length } {&#13;
    std::strncpy(buffer, other.buffer, max_size);&#13;
  }&#13;
  SimpleString(SimpleString&amp;&amp; other) noexcept&#13;
    : max_size(other.max_size),&#13;
    buffer(other.buffer),&#13;
    length(other.length) {&#13;
    other.length = 0;&#13;
    other.buffer = nullptr;&#13;
    other.max_size = 0;&#13;
  }&#13;
  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this;&#13;
    const auto new_buffer = new char[other.max_size];&#13;
    delete[] buffer;&#13;
    buffer = new_buffer;&#13;
    length = other.length;&#13;
    max_size = other.max_size;&#13;
    std::strncpy(buffer, other.buffer, max_size);&#13;
<span epub:type="pagebreak" id="page_129"/>    return *this;&#13;
  }&#13;
  SimpleString&amp; operator=(SimpleString&amp;&amp; other) noexcept {&#13;
    if (this == &amp;other) return *this;&#13;
    delete[] buffer;&#13;
    buffer = other.buffer;&#13;
    length = other.length;&#13;
    max_size = other.max_size;&#13;
    other.buffer = nullptr;&#13;
    other.length = 0;&#13;
    other.max_size = 0;&#13;
    return *this;&#13;
  }&#13;
  void print(const char* tag) const {&#13;
    printf("%s: %s", tag, buffer);&#13;
  }&#13;
  bool append_line(const char* x) {&#13;
    const auto x_len = strlen(x);&#13;
    if (x_len + length + 2 &gt; max_size) return false;&#13;
    std::strncpy(buffer + length, x, max_size - length);&#13;
    length += x_len;&#13;
    buffer[length++] = '\n';&#13;
    buffer[length] = 0;&#13;
    return true;&#13;
  }&#13;
private:&#13;
  size_t max_size;&#13;
  char* buffer;&#13;
  size_t length;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex38"/><em>Listing 4-38: A fully specified <code>SimpleString</code> class supporting copy and move semantics</em></p>&#13;
<h4 class="h4" id="ch04lev2sec31"><strong><em>Compiler-Generated Methods</em></strong></h4>&#13;
<p class="noindent">Five methods govern move and copy behavior:</p>&#13;
<ul>&#13;
<li class="noindent">The destructor</li>&#13;
<li class="noindent">The copy constructor</li>&#13;
<li class="noindent">The move constructor</li>&#13;
<li class="noindent">The copy assignment operator</li>&#13;
<li class="noindent">The move assignment operator</li>&#13;
</ul>&#13;
<p class="indent">The compiler can generate default implementations for each under certain circumstances. Unfortunately, the rules for which methods get generated are complicated and potentially uneven across compilers.</p>&#13;
<p class="indent">You can eliminate this complexity by setting these methods to <code>default</code>/<code>delete</code> or by implementing them as appropriate. This general rule is the <em>rule of five</em>, because there are five methods to specify. Being explicit costs a little time, but it saves a lot of future headaches.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>The alternative is memorizing <a href="ch04.xhtml#ch04fig08">Figure 4-8</a>, which summarizes the interactions between each of the five functions you implement and each that the compiler generates on your behalf.</p>&#13;
<div class="image"><img src="../images/fig4_8.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig08"><em>Figure 4-8: A chart illustrating which methods the compiler generates when given various inputs</em></p>&#13;
<p class="indent">If you provide nothing, the compiler will generate all five destruct/copy/move functions. This is the <em>rule of zero</em>.</p>&#13;
<p class="indent">If you explicitly define any of destructor/copy constructor/copy assignment operator, you get all three. This is dangerous, as demonstrated earlier with <code>SimpleString</code>: it’s too easy to get into an unintended situation in which the compiler will essentially convert all your moves into copies.</p>&#13;
<p class="indent">Finally, if you provide only move semantics for your class, the compiler will not automatically generate anything except a destructor.</p>&#13;
<h3 class="h3" id="ch04lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">You’ve completed the exploration of the object life cycle. Your journey began in storage durations, where you saw an object lifetime from construction to destruction. Subsequent study of exception handling illustrated deft, lifetime-aware error handling and enriched your understanding of RAII. Finally, you saw how copy and move semantics grant you granular control over object lifetimes.</p>&#13;
<div class="box5" id="bm03">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_131"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>4-1.</strong> Create a <code>struct TimerClass</code>. In its constructor, record the current time in a field called <code>timestamp</code> (compare with the POSIX function <code>gettimeofday</code>).</p>&#13;
<p class="noindent"><strong>4-2.</strong> In the destructor of  TimerClass, record the current time and subtract the time at construction. This time is roughly the <em>age</em> of the timer. Print this value.</p>&#13;
<p class="noindent"><strong>4-3.</strong> Implement a copy constructor and a copy assignment operator for  TimerClass. The copies should share  timestamp values.</p>&#13;
<p class="noindent"><strong>4-4.</strong> Implement a move constructor and a move assignment operator for  TimerClass. A moved-from  TimerClass shouldn’t print any output to the console when it gets destructed.</p>&#13;
<p class="noindent"><strong>4-5.</strong> Elaborate the  TimerClass constructor to accept an additional  <code>const char* name</code> parameter. When  <code>TimerClass</code> is destructed and prints to stdout, include the name of the timer in the output.</p>&#13;
<p class="noindent"><strong>4-6.</strong> Experiment with your  TimerClass. Create a timer and move it into a function that performs some computationally intensive operation (for example, lots of math in a loop). Verify that your timer behaves as you expect.</p>&#13;
<p class="noindent"><strong>4-7.</strong> Identify each method in the  SimpleString class (<a href="ch04.xhtml#ch04ex38">Listing 4-38</a>). Try reimplementing it from scratch without referring to the book.</p>&#13;
</div>&#13;
<div class="box6" id="bm04">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Optimized C++: Proven Techniques for Heightened Performance</em> by Kurt Guntheroth (O’Reilly Media, 2016)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</em> by Scott Meyers (O’Reilly Media, 2015)</li></ul>&#13;
</div>&#13;
</body></html>