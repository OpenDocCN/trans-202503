<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_88"/><span epub:type="pagebreak" id="page_89"/><strong><span class="big">4</span><br/>THE OBJECT LIFE CYCLE</strong></h2>&#13;
<p class="quote"><em>Things you used to own, now they own you.<br/>—Chuck Palahniuk,</em> Fight Club</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The object life cycle is the series of stages a C++ object goes through during its lifetime. This chapter begins with a discussion of an object’s storage duration, the time during which storage is allocated for an object. You’ll learn about how the object life cycle dovetails with exceptions to handle error conditions and cleanup in a robust, safe, and elegant way. The chapter closes with a discussion of move and copy semantics that provides you with granular control over an object’s life cycle.</p>&#13;
<h3 class="h3" id="ch04lev1sec1"><strong>An Object’s Storage Duration</strong></h3>&#13;
<p class="noindent">An <em>object</em> is a region of storage that has a type and a value. When you declare a variable, you create an object. A variable is simply an object that has a name.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><span epub:type="pagebreak" id="page_90"/><strong><em>Allocation, Deallocation, and Lifetime</em></strong></h4>&#13;
<p class="noindent">Every object requires storage. You reserve storage for objects in a process called <em>allocation</em>. When you’re done with an object, you release the object’s storage in a process called <em>deallocation</em>.</p>&#13;
<p class="indent">An object’s <em>storage duration</em> begins when the object is allocated and ends when the object is deallocated. The <em>lifetime</em> of an object is a runtime property that is bound by the object’s storage duration. An object’s lifetime begins once its constructor completes, and it ends just before a destructor is invoked. In summary, each object passes through the following stages:</p>&#13;
<ol>&#13;
<li class="noindent">The object’s storage duration begins, and storage is allocated.</li>&#13;
<li class="noindent">The object’s constructor is called.</li>&#13;
<li class="noindent">The object’s lifetime begins.</li>&#13;
<li class="noindent">You can use the object in your program.</li>&#13;
<li class="noindent">The object’s lifetime ends.</li>&#13;
<li class="noindent">The object’s destructor is called.</li>&#13;
<li class="noindent">The object’s storage duration ends, and storage is deallocated.</li>&#13;
</ol>&#13;
<h4 class="h4" id="ch04lev2sec2"><strong><em>Memory Management</em></strong></h4>&#13;
<p class="noindent">If you’ve been programming in an application language, chances are you’ve used an <em>automatic memory manager</em>, or a <em>garbage collector</em>. At runtime, programs create objects. Periodically, the garbage collector determines which objects are no longer required by the program and safely deallocates them. This approach frees the programmer from worrying about managing an object’s life cycle, but it incurs several costs, including runtime performance, and requires some powerful programming techniques like deterministic resource management.</p>&#13;
<p class="indent">C++ takes a more efficient approach. The trade-off is that C++ programmers must have intimate knowledge of storage durations. It’s <em>our</em> job, not the garbage collector’s, to craft object lifetimes.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><strong><em>Automatic Storage Duration</em></strong></h4>&#13;
<p class="noindent">An <em>automatic object</em> is allocated at the beginning of an enclosing code block, and it’s deallocated at the end. The enclosing block is the automatic object’s <em>scope</em>. Automatic objects are said to have <em>automatic storage duration</em>. Note that function parameters are automatic, even though notationally they appear outside the function body.</p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch04ex01">Listing 4-1</a>, the function <span class="literal">power_up_rat_thing</span> is the scope for the automatic variables <span class="literal">nuclear_isotopes</span> and <span class="literal">waste_heat</span>.</p>&#13;
<pre>void power_up_rat_thing(int nuclear_isotopes) {&#13;
  int waste_heat = 0;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex01"/><em>Listing 4-1: A function with two automatic variables, <span class="literal">nuclear_isotopes</span> and <span class="literal">waste_heat</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>Both <span class="literal">nuclear_isotopes</span> and <span class="literal">waste_heat</span> are allocated each time <span class="literal">power_up_rat_thing</span> is invoked. Just before <span class="literal">power_up_rat_thing</span> returns, these variables are deallocated.</p>&#13;
<p class="indent">Because you cannot access these variables outside of <span class="literal">power_up_rat_thing</span>, automatic variables are also called <em>local variables</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec4"><strong><em>Static Storage Duration</em></strong></h4>&#13;
<p class="noindent">A <em>static object</em> is declared using the <span class="literal">static</span> or <span class="literal">extern</span> keyword. You declare static variables at the same level you declare functions—at global scope (or <em>namespace scope</em>). Static objects with global scope have <em>static storage duration</em> and are allocated when the program starts and deallocated when the program stops.</p>&#13;
<p class="indent">The program in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> powers up a Rat Thing with nuclear isotopes by calling the <span class="literal">power_up_rat_thing</span> function. When it does, the Rat Thing’s power increases, and the variable <span class="literal">rat_things_power</span> keeps track of the power level between power-ups.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
static int rat_things_power = 200; <span class="ent">➊</span>&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  rat_things_power = rat_things_power + nuclear_isotopes; <span class="ent">➋</span>&#13;
  const auto waste_heat = rat_things_power * 20; <span class="ent">➌</span>&#13;
  if (waste_heat &gt; 10000) { <span class="ent">➍</span>&#13;
    printf("Warning! Hot doggie!\n"); <span class="ent">➎</span>&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  printf("Rat-thing power: %d\n", rat_things_power); <span class="ent">➏</span>&#13;
  power_up_rat_thing(100); <span class="ent">➐</span>&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
  power_up_rat_thing(500);&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Rat-thing power: 200</span>&#13;
<span class="color1">Rat-thing power: 300</span>&#13;
<span class="color1">Warning! Hot doggie! <span class="ent">➑</span></span>&#13;
<span class="color1">Rat-thing power: 800</span></pre>&#13;
<p class="listing"><a id="ch04ex02"/><em>Listing 4-2: A program with a static variable and several automatic variables</em></p>&#13;
<p class="indent">The variable <span class="literal">rat_things_power</span> <span class="ent">➊</span> is a static variable because it’s declared at global scope with the <span class="literal">static</span> keyword. Another feature of being declared at global scope is that <span class="literal">rat_things_power</span> can be accessed from any function in the translation unit. (Recall from <a href="ch01.xhtml#ch01">Chapter 1</a> that a translation unit is what a preprocessor produces after acting on a single source file.) At <span class="ent">➋</span>, you see <span class="literal">power_up_rat_thing</span> increasing <span class="literal">rat_things_power</span> by the number of <span class="literal">nuclear_isotopes</span>. Because <span class="literal">rat_things_power</span> is a static variable—and hence its <span epub:type="pagebreak" id="page_92"/>lifetime is the program’s lifetime—each time you call <span class="literal">power_up_rat_thing</span>, the value of <span class="literal">rat_things_power</span> carries over into the next call.</p>&#13;
<p class="indent">Next, you calculate how much waste heat is produced given the new value of <span class="literal">rat_things_power</span>, and you store the result in the automatic variable <span class="literal">waste_heat</span> <span class="ent">➌</span>. Its storage duration begins when <span class="literal">power_up_rat_thing</span> is called and ends when <span class="literal">power_up_rat_thing</span> returns, so its values aren’t saved between function calls. Finally, you check whether waste_heat is over a threshold value of <span class="literal">1000</span> <span class="ent">➍</span>. If it is, you print a warning message <span class="ent">➎</span></p>&#13;
<p class="indent">Within <span class="literal">main</span>, you alternate between printing the value of <span class="literal">rat_things_power</span> <span class="ent">➏</span> and calling <span class="literal">power_up_rat_thing</span> <span class="ent">➐</span>.</p>&#13;
<p class="indent">Once you’ve increased the Rat Thing’s power from <span class="literal">300</span> to <span class="literal">800</span>, you get the warning message in the output <span class="ent">➑</span>. The effects of modifying <span class="literal">rat_things_power</span> last for the lifetime of the program due to its static storage duration.</p>&#13;
<p class="indent">When you use the <span class="literal">static</span> keyword, you specify <em>internal linkage</em>. Internal linkage means that a variable is inaccessible to other translation units. You can alternately specify <em>external linkage</em>, which makes a variable accessible to other translation units. For external linkage, you use the <span class="literal">extern</span> keyword instead of <span class="literal">static</span>.</p>&#13;
<p class="indent">You could modify <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> in the following way to achieve external linkage:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
extern int rat_things_power = 200; // External linkage&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">With <span class="literal">extern</span> rather than <span class="literal">static</span>, you can access <span class="literal">rat_things_power</span> from other translation units.</p>&#13;
<h5 class="h5" id="ch04lev3sec1"><strong>Local Static Variables</strong></h5>&#13;
<p class="noindent">A <em>local static variable</em> is a special kind of static variable that is a local—rather than global—variable. Local static variables are declared at function scope, just like automatic variables. But their lifetimes begin upon the first invocation of the enclosing function and end when the program exits.</p>&#13;
<p class="indent">For example, you could refactor <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> to make <span class="literal">rat_things_power</span> a local static variable, as demonstrated in <a href="ch04.xhtml#ch04ex03">Listing 4-3</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  static int rat_things_power = 200;&#13;
  rat_things_power = rat_things_power + nuclear_isotopes;&#13;
  const auto waste_heat = rat_things_power * 20;&#13;
  if (waste_heat &gt; 10000) {&#13;
    printf("Warning! Hot doggie!\n");&#13;
  }&#13;
  printf("Rat-thing power: %d\n", rat_things_power);&#13;
}&#13;
<span epub:type="pagebreak" id="page_93"/>int main() {&#13;
  power_up_rat_thing(100);&#13;
  power_up_rat_thing(500);&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex03"/><em>Listing 4-3: A refactor of <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> using a local static variable.</em></p>&#13;
<p class="indent">Unlike in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a>, you cannot refer to <span class="literal">rat_things_power</span> from outside of the <span class="literal">power_up_rat_thing</span> function due to its local scope. This is an example of a programming pattern called <em>encapsulation</em>, which is the bundling of data with a function that operates on that data. It helps to protect against unintended modification.</p>&#13;
<h5 class="h5" id="ch04lev3sec2"><strong>Static Members</strong></h5>&#13;
<p class="noindent"><em>Static members</em> are members of a class that aren’t associated with a particular instance of the class. Normal class members have lifetimes nested within the class’s lifetime, but static members have static storage duration.</p>&#13;
<p class="indent">These members are essentially similar to static variables and functions declared at global scope; however, you must refer to them by the containing class’s name, using the scope resolution operator <span class="literal">::</span>. In fact, you must initialize static members at global scope. You cannot initialize a static member within a containing class definition.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is an exception to the static member initialization rule: you can declare and define integral types within a class definition as long as they’re also <span class="literal">const</span>.</em></p>&#13;
</div>&#13;
<p class="indent">Like other static variables, static members have only a single instance. All instances of a class with static members share the same member, so if you modify a static member, <em>all</em> class instances will observe the modification. To illustrate, you could convert <span class="literal">power_up_rat_thing</span> and <span class="literal">rat_things_power</span> in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> to static members of a <span class="literal">RatThing</span> class, as shown in <a href="ch04.xhtml#ch04ex04">Listing 4-4</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct RatThing {&#13;
  static int rat_things_power; <span class="ent">➊</span>&#13;
  static<span class="ent">➋</span> void power_up_rat_thing(int nuclear_isotopes) {&#13;
    rat_things_power<span class="ent">➌</span> = rat_things_power + nuclear_isotopes;&#13;
    const auto waste_heat = rat_things_power * 20;&#13;
    if (waste_heat &gt; 10000) {&#13;
      printf("Warning! Hot doggie!\n");&#13;
    }&#13;
    printf("Rat-thing power: %d\n", rat_things_power);&#13;
  }&#13;
};&#13;
&#13;
int RatThing::rat_things_power = 200; <span class="ent">➍</span>&#13;
&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_94"/>  RatThing::power_up_rat_thing(100); <span class="ent">➎</span>&#13;
  RatThing::power_up_rat_thing(500);&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex04"/><em>Listing 4-4: A refactor of <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> using static members</em></p>&#13;
<p class="indent">The <span class="literal">RatThing</span> class contains <span class="literal">rat_things_power</span> as a static member variable <span class="ent">➊</span> and <span class="literal">power_up_rat_thing</span> as a static method <span class="ent">➋</span>. Because <span class="literal">rat_things_power</span> is a member of <span class="literal">RatThing</span>, you don’t need the scope resolution operator <span class="ent">➌</span>; you access it like any other member.</p>&#13;
<p class="indent">You see the scope resolution operator in action where <span class="literal">rat_things_power</span> is initialized <span class="ent">➍</span> and where you invoke the static method <span class="literal">power_up_rat_thing</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec5"><strong><em>Thread-Local Storage Duration</em></strong></h4>&#13;
<p class="noindent">One of the fundamental concepts in concurrent programs is the <em>thread</em>. Each program has one or more threads that can perform independent operations. The sequence of instructions that a thread executes is called its <em>thread of execution</em>.</p>&#13;
<p class="indent">Programmers must take extra precautions when using more than one thread of execution. Code that multiple threads can execute safely is called <em>thread-safe code</em>. Mutable global variables are the source of many thread safety issues. Sometimes, you can avoid these issues by giving each thread its own copy of a variable. You can do this by specifying that an object has <em>thread storage duration</em>.</p>&#13;
<p class="indent">You can modify any variable with static storage duration to have thread-local storage duration by adding the <span class="literal">thread_local</span> keyword to the <span class="literal">static</span> or <span class="literal">extern</span> keyword. If only <span class="literal">thread_local</span> is specified, <span class="literal">static</span> is assumed. The variable’s linkage is unchanged.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex03">Listing 4-3</a> is not thread safe. Depending on the order of reads and writes, <span class="literal">rat_things_power</span> could become corrupted. You could make <a href="ch04.xhtml#ch04ex03">Listing 4-3</a> thread safe by specifying <span class="literal">rat_things_power</span> as <span class="literal">thread_local</span>, as demonstrated here:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
void power_up_rat_thing(int nuclear_isotopes) {&#13;
  static thread_local int rat_things_power = 200; <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Now each thread would represent its own Rat Thing; if one thread modifies its <span class="literal">rat_things_power</span>, the modification will not affect the other threads. Each copy of <span class="literal">rat_things_power</span> is initialized to 200 <span class="ent">➊</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Concurrent programming is discussed in more detail in <a href="ch19.xhtml#ch19">Chapter 19</a>. Thread storage duration is presented here for completeness.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec6"><strong><em><span epub:type="pagebreak" id="page_95"/>Dynamic Storage Duration</em></strong></h4>&#13;
<p class="noindent">Objects with <em>dynamic storage duration</em> are allocated and deallocated on request. You have manual control over when a <em>dynamic object</em>’s life begins and when it ends. Dynamic objects are also called <em>allocated objects</em> for this reason.</p>&#13;
<p class="indent">The primary way to allocate a dynamic object is with a <em>new expression</em>. A new expression begins with the <span class="literal">new</span> keyword followed by the desired type of the dynamic object. New expressions create objects of a given type and then return a pointer to the newly minted object.</p>&#13;
<p class="indent">Consider the following example where you create an <span class="literal">int</span> with dynamic storage duration and save it into a pointer called <span class="literal">my_int_ptr</span>:</p>&#13;
<pre>int*<span class="ent">➊</span> my_int_ptr = new<span class="ent">➋</span> int<span class="ent">➌</span>;</pre>&#13;
<p class="indent">You declare a pointer to <span class="literal">int</span> and initialize it with the result of the new expression on the right side of the equal sign <span class="ent">➊</span>. The new expression is composed of the <span class="literal">new</span> keyword <span class="ent">➋</span> followed by the desired type <span class="literal">int</span> <span class="ent">➌</span>. When the new expression executes, the C++ runtime allocates memory to store an <span class="literal">int</span> and then returns its pointer.</p>&#13;
<p class="indent">You can also initialize a dynamic object within a new expression, as shown here:</p>&#13;
<pre>int* my_int_ptr = new int{ 42 }; // Initializes dynamic object to 42</pre>&#13;
<p class="indent">After allocating storage for the <span class="literal">int</span>, the dynamic object will be initialized as usual. After initialization completes, the dynamic object’s lifetime begins.</p>&#13;
<p class="indent">You deallocate dynamic objects using the <em>delete expression</em>, which is composed of the <span class="literal">delete</span> keyword followed by a pointer to the dynamic object. Delete expressions always return <span class="literal">void</span>.</p>&#13;
<p class="indent">To deallocate the object pointed to by <span class="literal">my_int_ptr</span>, you would use the following delete expression:</p>&#13;
<pre>delete my_int_ptr;</pre>&#13;
<p class="indent">The value contained in memory where the deleted object resided is undefined, meaning the compiler can produce code that leaves anything there. In practice, major compilers will try to be as efficient as possible, so typically the object’s memory will remain untouched until the program reuses it for some other purposes. You would have to implement a custom destructor to, for example, zero out some sensitive contents.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because the compiler doesn’t typically clean up memory after an object is deleted, a subtle and potentially serious type of bug called a <em>use after free</em> can occur. If you delete an object and accidentally reuse it, your program might appear to function correctly because the deallocated memory might still contain reasonable values. In some situations, the problems don’t manifest until the program has been in production for a long time—or until a security researcher finds a way to exploit the bug and discloses it!</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec3"><strong><span epub:type="pagebreak" id="page_96"/>Dynamic Arrays</strong></h5>&#13;
<p class="noindent"><em>Dynamic arrays</em> are arrays with dynamic storage duration. You create dynamic arrays with <em>array new expressions</em>. Array new expressions have the following form:</p>&#13;
<pre>new MyType[n_elements] { init-list }</pre>&#13;
<p class="indent"><span class="literal">MyType</span> is the desired type of the array elements, <span class="literal">n_elements</span> is the length of the desired array, and the optional <span class="literal">init-list</span> is an initialization list to initialize the array. Array new expressions return a pointer to the first element of the newly allocated array.</p>&#13;
<p class="indent">In the following example, you allocate an <span class="literal">int</span> array of length 100 and save the result into a pointer called <span class="literal">my_int_array_ptr</span>:</p>&#13;
<pre>int* my_int_array_ptr = new int[100<span class="ent">➊</span>];</pre>&#13;
<p class="indent">The number of elements <span class="ent">➊</span> doesn’t need to be constant: the size of the array can be determined at runtime, meaning the value between brackets <span class="ent">➊</span> could be a variable rather than a literal.</p>&#13;
<p class="indent">To deallocate a dynamic array, use the <em>array delete expression</em>. Unlike the array new expression, the array delete expression doesn’t require a length:</p>&#13;
<pre>delete[] my_int_array_ptr</pre>&#13;
<p class="indent">Like the delete expression, the array delete expression returns <span class="literal">void</span>.</p>&#13;
<h5 class="h5" id="ch04lev3sec4"><strong>Memory Leaks</strong></h5>&#13;
<p class="noindent">With privilege comes responsibility, so you must make sure that dynamic objects you allocate are also deallocated. Failure to do so causes <em>memory leaks</em> in which memory that is no longer needed by your program isn’t released. When you leak memory, you use up a resource in your environment that you’ll never reclaim. This can cause performance problems or worse.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In practice, your program’s operating environment might clean up leaked resources for you. For example, if you’ve written user-mode code, modern operating systems will clean up the resources when the program exits. However, if you’ve written kernel code, those operating systems won’t clean up the resources. You’ll only reclaim them when the computer reboots.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>Tracing the Object Life Cycle</strong></h3>&#13;
<p class="noindent">The object life cycle is as daunting to newcomers as it is powerful. Let’s clarify with an example that explores each of the storage durations.</p>&#13;
<p class="indent">Consider the <span class="literal">Tracer</span> class in <a href="ch04.xhtml#ch04ex05">Listing 4-5</a>, which prints a message whenever a <span class="literal">Tracer</span> object is constructed or destructed. You can use this class to <span epub:type="pagebreak" id="page_97"/>investigate object life cycles, because each <span class="literal">Tracer</span> clearly indicates when its life is beginning and ending.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name<span class="ent">➊</span>) : name{ name }<span class="ent">➋</span> {&#13;
    printf("%s constructed.\n", name); <span class="ent">➌</span>&#13;
  }&#13;
  ~Tracer() {&#13;
    printf("%s destructed.\n", name); <span class="ent">➍</span>&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex05"/><em>Listing 4-5: A <span class="literal">Tracer</span> class that announces construction and destruction</em></p>&#13;
<p class="indent">The constructor takes a single parameter <span class="ent">➊</span> and saves it into the member <span class="literal">name</span> <span class="ent">➋</span>. It then prints a message containing <span class="literal">name</span> <span class="ent">➌</span>. The destructor <span class="ent">➍</span> also prints a message with <span class="literal">name</span>.</p>&#13;
<p class="indent">Consider the program in <a href="ch04.xhtml#ch04ex06">Listing 4-6</a>. Four different <span class="literal">Tracer</span> objects have different storage durations. By looking at the order of the program’s <span class="literal">Tracer</span> output, you can verify what you’ve learned about storage durations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Tracer {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
static Tracer t1{ "Static variable" }; <span class="ent">➊</span>&#13;
thread_local Tracer t2{ "Thread-local variable" }; <span class="ent">➋</span>&#13;
&#13;
int main() {&#13;
const auto t2_ptr = &amp;t2;&#13;
  printf("A\n"); <span class="ent">➌</span>&#13;
  Tracer t3{ "Automatic variable" }; <span class="ent">➍</span>&#13;
  printf("B\n");&#13;
  const auto* t4 = new Tracer{ "Dynamic variable" }; <span class="ent">➎</span>&#13;
  printf("C\n");&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex06"/><em>Listing 4-6: A program using the <span class="literal">Tracer</span> class in <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> to illustrate storage duration</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex06">Listing 4-6</a> contains a <span class="literal">Tracer</span> with static duration <span class="ent">➊</span>, thread local duration <span class="ent">➋</span>, automatic duration <span class="ent">➍</span>, and dynamic duration <span class="ent">➎</span>. Between each line in <span class="literal">main</span>, you print the character <span class="literal">A</span>, <span class="literal">B</span>, or <span class="literal">C</span> for reference <span class="ent">➌</span>.</p>&#13;
<p class="indent">Running the program yields <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>.</p>&#13;
<pre>Static variable constructed.&#13;
Thread-local variable constructed.&#13;
A <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_98"/>Automatic variable constructed.&#13;
B&#13;
Dynamic variable constructed.&#13;
C&#13;
Automatic variable destructed.&#13;
Thread-local variable destructed.&#13;
Static variable destructed.</pre>&#13;
<p class="listing"><a id="ch04ex07"/><em>Listing 4-7: Sample output from running <a href="ch04.xhtml#ch04ex06">Listing 4-6</a></em></p>&#13;
<p class="indent">Before the first line of <span class="literal">main</span> <span class="ent">➌</span>, the static and thread local variables <span class="literal">t1</span> and <span class="literal">t2</span> have been initialized <span class="ent">➊</span> <span class="ent">➋</span>. You can see this in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>: both variables have printed their initialization messages before <span class="literal">A</span>. As an automatic variable, the scope of <span class="literal">t3</span> is bounded by the enclosing function <span class="literal">main</span>. Accordingly, <span class="literal">t3</span> is constructed where it is initialized just after <span class="literal">A</span>.</p>&#13;
<p class="indent">After <span class="literal">B</span>, you see the message corresponding to the initialization of <span class="literal">t4</span> <span class="ent">➎</span>. Notice that there’s no corresponding message generated by the dynamic destructor of <span class="literal">Tracer</span>. The reason is that you’ve (intentionally) leaked the object pointed to by <span class="literal">t4</span>. Because there’s no command to <span class="literal">delete t4</span>, the destructor is never called.</p>&#13;
<p class="indent">Just before <span class="literal">main</span> returns, <span class="literal">C</span> prints. Because <span class="literal">t3</span> is an automatic variable whose scope is <span class="literal">main</span>, it’s destroyed at this point because <span class="literal">main</span> is returning.</p>&#13;
<p class="indent">Finally, the static and thread-local variables <span class="literal">t1</span> and <span class="literal">t2</span> are destroyed just before program exit, yielding the final two messages in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>Exceptions</strong></h3>&#13;
<p class="noindent"><em>Exceptions</em> are types that communicate an error condition. When an error condition occurs, you <em>throw</em> an exception. After you throw an exception, it’s <em>in flight</em>. When an exception is in flight, the program stops normal execution and searches for an <em>exception handler</em> that can manage the in-flight exception. Objects that fall out of scope during this process are destroyed.</p>&#13;
<p class="indent">In situations where there’s no good way to handle an error locally, such as in a constructor, you generally use exceptions. Exceptions play a crucial role in managing object life cycles in such circumstances.</p>&#13;
<p class="indent">The other option for communicating error conditions is to return an error code as part of a function’s prototype. These two approaches are complementary. In situations where an error occurs that can be dealt with locally or that is expected to occur during the normal course of a program’s execution, you generally return an error code.</p>&#13;
<h4 class="h4" id="ch04lev2sec7"><strong><em>The throw Keyword</em></strong></h4>&#13;
<p class="noindent">To throw an exception, use the <span class="literal">throw</span> keyword followed by a throwable object.</p>&#13;
<p class="indent">Most objects are throwable. But it’s good practice to use one of the exceptions available in stdlib, such as <span class="literal">std::runtime_error</span> in the <span class="literal">&lt;stdexcept&gt;</span> header. The <span class="literal">runtime_error</span> constructor accepts a null-terminated <span class="literal">const char*</span> describing the nature of the error condition. You can retrieve this message via the <span class="literal">what</span> method, which takes no parameters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>The <span class="literal">Groucho</span> class in <a href="ch04.xhtml#ch04ex08">Listing 4-8</a> throws an exception whenever you invoke the <span class="literal">forget</span> method with an argument equal to <span class="literal">0xFACE</span>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
struct Groucho {&#13;
  void forget(int x) {&#13;
    if (x == 0xFACE) {&#13;
      throw<span class="ent">➊</span> std::runtime_error<span class="ent">➋</span>{ "I'd be glad to make an exception." };&#13;
    }&#13;
    printf("Forgot 0x%x\n", x);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex08"/><em>Listing 4-8: The <span class="literal">Groucho</span> class</em></p>&#13;
<p class="indent">To throw an exception, <a href="ch04.xhtml#ch04ex08">Listing 4-8</a> uses the <span class="literal">throw</span> keyword <span class="ent">➊</span> followed by a <span class="literal">std::runtime_error</span> object <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec8"><strong><em>Using try-catch Blocks</em></strong></h4>&#13;
<p class="noindent">You use <span class="literal">try</span>-<span class="literal">catch</span> blocks to establish exception handlers for a block of code. Within the <span class="literal">try</span> block, you place code that might throw an exception. Within the <span class="literal">catch</span> block, you specify a handler for each exception type you can handle.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex09">Listing 4-9</a> illustrates the use of a <span class="literal">try</span>-<span class="literal">catch</span> block to handle exceptions thrown by a <span class="literal">Groucho</span> object.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
struct Groucho {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  Groucho groucho;&#13;
  try { <span class="ent">➊</span>&#13;
    groucho.forget(0xC0DE); <span class="ent">➋</span>&#13;
    groucho.forget(0x<a id="_idTextAnchor179"/>FACE); <span class="ent">➌</span>&#13;
    groucho.forget(0xC0FFEE); <span class="ent">➍</span>&#13;
  } catch (const std::runtime_error&amp; e<span class="ent">➎</span>) {&#13;
    printf("exception caught with message: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex09"/><em>Listing 4-9: The use of <span class="literal">try</span>-<span class="literal">catch</span> to handle the exceptions of the <span class="literal">Groucho</span> class</em></p>&#13;
<p class="indent">In <span class="literal">main</span>, you construct a <span class="literal">Groucho</span> object and then establish a <span class="literal">try</span>-<span class="literal">catch</span> block <span class="ent">➊</span>. Within the <span class="literal">try</span> portion, you invoke the <span class="literal">groucho</span> class’s <span class="literal">forget</span> method with several different parameters: <span class="literal">0xC0DE</span> <span class="ent">➋</span>, <span class="literal">0xFACE</span> <span class="ent">➌</span>, and <span class="literal">0xC0FFEE</span> <span class="ent">➍</span>. Within the <span class="literal">catch</span> portion, you handle any <span class="literal">std::runtime_error</span> exceptions <span class="ent">➎</span> by printing the message to the console <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>When you run the program in <a href="ch04.xhtml#ch04ex09">Listing 4-9</a>, you get the following output:</p>&#13;
<pre>Forgot 0xc0de&#13;
exception caught with message: I'd be glad to make an exception.</pre>&#13;
<p class="indent">When you invoked <span class="literal">forget</span> with the argument <span class="literal">0xC0DE</span> <span class="ent">➋</span>, <span class="literal">groucho</span> printed <span class="literal">Forgot 0xc0de</span> and returned. When you invoked <span class="literal">forget</span> with the argument <span class="literal">0xFACE</span> <span class="ent">➌</span>, <span class="literal">groucho</span> threw an exception. This exception stopped normal program execution, so <span class="literal">forget</span> is never invoked again <span class="ent">➍</span>. Instead, the in-flight exception is caught <span class="ent">➎</span>, and its message is printed <span class="ent">➏</span>.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>A CRASH COURSE IN INHERITANCE</strong></p>&#13;
<p class="noindent">Before introducing the stdlib exceptions, you need to understand simple C++ class inheritance at a very high level. Classes can have subclasses that inherit the functionality of their superclasses. The syntax in <a href="ch04.xhtml#ch04ex10">Listing 4-10</a> defines this relationship.</p>&#13;
<pre>struct Superclass {&#13;
  int x;&#13;
};&#13;
&#13;
struct Subclass : Superclass { <span class="ent">➊</span>&#13;
  int y;&#13;
  int foo() {&#13;
    return x + y; <span class="ent">➋</span>&#13;
}&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex10"/><em>Listing 4-10: Defining superclasses and subclasses</em></p>&#13;
<p class="indent">There’s nothing special about <span class="literal">Superclass</span>. But the declaration of <span class="literal">Subclass</span> <span class="ent">➊</span> is special. It defines the inheritance relationship using the : <span class="literal">Superclass</span> syntax. <span class="literal">Subclass</span> inherits members from <span class="literal">Superclass</span> that are not marked private. You can see this in action where <span class="literal">Subclass</span> uses the field x <span class="ent">➋</span>. This is a field belonging to <span class="literal">Superclass</span>, but because <span class="literal">Subclass</span> inherits from Superclass, x is accessible.</p>&#13;
<p class="indent">Exceptions use these inheritance relationships to determine whether a handler catches an exception. Handlers will catch a given type and any of its childrens’ types.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec9"><strong><em>stdlib Exception Classes</em></strong></h4>&#13;
<p class="noindent">You can arrange classes into parent-child relationships using <em>inheritance</em>. Inheritance has a big impact on how the code handles exceptions. There is a nice, simple hierarchy of existing exception types available for use in the stdlib. You should try to use these types for simple programs. Why reinvent the wheel?</p>&#13;
<h5 class="h5" id="ch04lev3sec5"><strong><span epub:type="pagebreak" id="page_101"/>Standard Exception Classes</strong></h5>&#13;
<p class="noindent">The stdlib provides you with the <em>standard exception classes</em> in the <span class="literal">&lt;stdexcept&gt;</span> header. These should be your first port of call when you’re programming exceptions. The superclass for all the standard exception classes is the class <span class="literal">std::exception</span>. All the subclasses in <span class="literal">std::exception</span> can be partitioned into three groups: logic errors, runtime errors, and language support errors. While language support errors are not generally relevant to you as a programmer, you’ll definitely encounter logic errors and runtime errors. <a href="ch04.xhtml#ch04fig01">Figure 4-1</a> summarizes their relationship.</p>&#13;
<div class="image"><img src="../images/fig4_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig01"><em>Figure 4-1: How stdlib exceptions are nested under std::exception</em></p>&#13;
<h5 class="h5" id="ch04lev3sec6"><strong>Logic Errors</strong></h5>&#13;
<p class="noindent"><em>Logic errors</em> derive from the <span class="literal">logic_error</span> class. Generally, you could avoid these exceptions through more careful programming. A primary example is when a logical precondition of a class isn’t satisfied, such as when a class invariant cannot be established. (Remember from <a href="ch02.xhtml#ch02">Chapter 2</a> that a class invariant is a feature of a class that is always true.)</p>&#13;
<p class="indent">Since a class invariant is something that the programmer defines, neither the compiler nor the runtime environment can enforce it without help. You can use a class constructor to check for various conditions, and if you cannot establish a class invariant, you can throw an exception. If the failure is the result of, say, passing an incorrect parameter to the constructor, a <span class="literal">logic_error</span> is an appropriate exception to throw.</p>&#13;
<p class="indent">The <span class="literal">logic_error</span> has several subclasses that you should be aware of:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">domain_error</span> reports errors related to valid input range, especially for math functions. The square root, for example, only supports non-negative numbers (in the real case). If a negative argument is passed, a square root function could throw a <span class="literal">domain_error</span>.</li>&#13;
<li class="noindent">The <span class="literal">invalid_argument</span> exception reports generally unexpected arguments.</li>&#13;
<li class="noindent">The <span class="literal">length_error</span> exception reports that some action would violate a maximum size constraint.</li>&#13;
<li class="noindent">The <span class="literal">out_of_range</span> exception reports that some value isn’t in an expected range. The canonical example is bounds-checked indexing into a data structure.</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch04lev3sec7"><strong><span epub:type="pagebreak" id="page_102"/>Runtime Errors</strong></h5>&#13;
<p class="noindent"><em>Runtime errors</em> derive from the <span class="literal">runtime_error</span> class. These exceptions help you report error conditions that are outside the program’s scope. Like <span class="literal">logic_error</span>, <span class="literal">runtime_error</span> has some subclasses that you might find useful:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">system_error</span> reports that the operating system encountered some error. You can get a lot of mileage out of this kind of exception. Inside of the <span class="literal">&lt;system_error&gt;</span> header, there’s a large number of <em>error codes</em> and <em>error conditions</em>. When a <span class="literal">system_error</span> is constructed, information about the error is packed in so you can determine the nature of the error. The <span class="literal">.code()</span> method returns an <span class="literal">enum class</span> of type <span class="literal">std::errc</span> that has a large number of values, such as <span class="literal">bad_file_descriptor</span>, <span class="literal">timed_out</span>, and <span class="literal">permission_denied</span>.</li>&#13;
<li class="noindent">The <span class="literal">overflow_error</span> and <span class="literal">underflow_error</span> report arithmetic overflow and underflow, respectively.</li>&#13;
</ul>&#13;
<p class="indent">Other errors inherit directly from <span class="literal">exception</span>. A common one is the <span class="literal">bad_alloc</span> exception, which reports that <span class="literal">new</span> failed to allocate the required memory for dynamic storage.</p>&#13;
<h5 class="h5" id="ch04lev3sec8"><strong>Language Support Errors</strong></h5>&#13;
<p class="indent">You won’t use language support errors directly. They exist to indicate that some core language feature failed at runtime.</p>&#13;
<h4 class="h4" id="ch04lev2sec10"><strong><em>Handling Exceptions</em></strong></h4>&#13;
<p class="noindent">The rules for exception handling are based on class inheritance. When an exception is thrown, a <span class="literal">catch</span> block handles the exception if the thrown exception’s type matches the <span class="literal">catch</span> handler’s exception type or if the thrown exception’s type <em>inherits from</em> the <span class="literal">catch</span> handler’s exception type.</p>&#13;
<p class="indent">For example, the following handler catches any exception that inherits from <span class="literal">std::exception</span>, including a <span class="literal">std::logic_error</span>:</p>&#13;
<pre>try {&#13;
  throw std::logic_error{ "It's not about who wrong "&#13;
                        "it's not about who right" };&#13;
} catch (std::exception&amp; ex) {&#13;
  // Handles std::logic_error as it inherits from std::exception&#13;
}</pre>&#13;
<p class="noindent">The following special handler catches <em>any</em> exception regardless of its type:</p>&#13;
<pre>try {&#13;
  throw 'z'; // Don't do this.&#13;
} catch (...) {&#13;
  // Handles any exception, even a 'z'&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Special handlers are typically used as a safety mechanism to log the program’s catastrophic failure to catch an exception of a specific type.</p>&#13;
<p class="indent">You can handle different types of exceptions originating from the same <span class="literal">try</span> block by chaining together <span class="literal">catch</span> statements, as demonstrated here:</p>&#13;
<pre>try {&#13;
  // Code that might throw an exception&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::logic_error&amp; ex) {&#13;
  // Log exception and terminate the program; there is a programming error!&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::runtime_error&amp; ex) {&#13;
  // Do our best to recover gracefully&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (const std::exception&amp; ex) {&#13;
  // This will handle any exception that derives from std:exception&#13;
  // that is not a logic_error or a runtime_error.&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch (...) {&#13;
  // Panic; an unforeseen exception type was thrown&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">It’s common to see such code in a program’s entry point.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>RETHROWING AN EXCEPTION</strong></p>&#13;
<p class="noindent">In a <span class="literal">catch</span> block, you can use the throw keyword to resume searching for an appropriate exception handler. This is called rethrowing an exception. There are some unusual but important cases where you might want to further inspect an exception before deciding to handle it, as shown in <a href="ch04.xhtml#ch04ex11">Listing 4-11</a>.</p>&#13;
<pre>try {&#13;
  // Some code that might throw a system_error&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch(const std::system_error&amp; ex) {&#13;
  if(ex.code()!= std::errc::permission_denied){&#13;
    // Not a permission denied error&#13;
    throw; <span class="ent">➊</span>&#13;
  }&#13;
  // Recover from a permission denied&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex11"/><em>Listing 4-11: Rethrowing an error</em></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_104"/>In this example, some code that might throw a <span class="literal">system_error</span> is wrapped in a <span class="literal">try-catch</span> block. All <span class="literal">system_errors</span> are handled, but unless it’s an <span class="literal">EACCES (permission denied)</span> error, you rethrow the exception <span class="ent">➊</span>  There are some performance penalties to this approach, and the resulting code is often needlessly convoluted.</p>&#13;
<p class="noindent">Rather than rethrowing, you can define a new exception type and create a separate <span class="literal">catch</span> handler for the <span class="literal">EACCES</span> error, as demonstrated in <a href="ch04.xhtml#ch04ex12">Listing 4-12</a>.</p>&#13;
<pre>try {&#13;
  // Throw a PermissionDenied instead&#13;
  --<span class="codeitalic1">snip</span>--&#13;
} catch(const PermissionDenied&amp; ex) {&#13;
  // Recover from an EACCES error (Permission Denied) ..&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex12"/><em>Listing 4-12: Catching a specific exception rather than rethrowing</em></p>&#13;
<p class="noindent">If a <span class="literal">std::system_error</span> is thrown, the <span class="literal">PermissionDenied</span> handler <span class="ent">➊</span> won’t catch it. (Of course, you could still keep the <span class="literal">std::system_error</span> handler to catch such exceptions if you wish.)</p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec11"><strong><em>User-Defined Exceptions</em></strong></h4>&#13;
<p class="noindent">You can define your own exceptions whenever you’d like; usually, these <em>user-defined exceptions</em> inherit from <span class="literal">std::exception</span>. All the classes from stdlib use exceptions that derive from <span class="literal">std::exception</span>. This makes it easy to catch all exceptions, whether from your code or from the stdlib, with a single <span class="literal">catch</span> block.</p>&#13;
<h4 class="h4" id="ch04lev2sec12"><strong><em>The noexcept Keyword</em></strong></h4>&#13;
<p class="noindent">The keyword <span class="literal">noexcept</span> is another exception-related term you should know. You can, and should, mark any function that cannot possibly throw an exception <span class="literal">noexcept</span>, as in the following:</p>&#13;
<pre>bool is_odd(int x) noexcept {&#13;
  return 1 == (x % 2);&#13;
}</pre>&#13;
<p class="indent">Functions marked <span class="literal">noexcept</span> make a rigid contract. When you’re using a function marked <span class="literal">noexcept</span>, you can rest assured that the function cannot throw an exception. In exchange, you must be extremely careful when you mark your own function <span class="literal">noexcept</span>, since the compiler won’t check for you. If your code throws an exception inside a function marked <span class="literal">noexcept</span>, <span epub:type="pagebreak" id="page_105"/>it’s bad juju. The C++ runtime will call the function <span class="literal">std::terminate</span>, a function that by default will exit the program via <span class="literal">abort</span>. Your program cannot recover:</p>&#13;
<pre>void hari_kari() noexcept {&#13;
  throw std::runtime_error{ "Goodbye, cruel world." };&#13;
}</pre>&#13;
<p class="indent">Marking a function <span class="literal">noexcept</span> enables some code optimizations that rely on the function’s not being able to throw an exception. Essentially, the compiler is liberated to use move semantics, which may be faster (more about this in “Move Semantics” on <a href="ch04.xhtml#page_122">page 122</a>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Check out Item 14 of Effective Modern C++ by Scott Meyers for a thorough discussion of <span class="literal">noexcept</span>. The gist is that some move constructors and move assignment operators might throw an exception, for example, if they need to allocate memory and the system is out. Unless a move constructor or move assignment operator specifies otherwise, the compiler must assume that a move could cause an exception. This disables certain optimizations.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec13"><strong><em>Call Stacks and Exceptions</em></strong></h4>&#13;
<p class="noindent">The <em>call stack</em> is a runtime structure that stores information about active functions. When a piece of code (the <em>caller</em>) invokes a function (the <em>callee</em>), the machine keeps track of who called whom by pushing information onto the call stack. This allows programs to have many function calls nested within each other. The callee could then, in turn, become the caller by invoking another function.</p>&#13;
<h5 class="h5" id="ch04lev3sec9"><strong>Stacks</strong></h5>&#13;
<p class="noindent">A stack is a flexible data container that can hold a dynamic number of elements. There are two essential operations that all stacks support: <em>pushing</em> elements onto the top of the stack and <em>popping</em> those elements off. It is a last-in, first-out data structure, as illustrated in <a href="ch04.xhtml#ch04fig02">Figure 4-2</a>.</p>&#13;
<div class="image"><img src="../images/fig4_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig02"><em>Figure 4-2: Elements being pushed onto and popped off of a stack</em></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_106"/>As its name suggests, the call stack is functionally similar to its namesake data container. Each time a function is invoked, information about the function invocation is arranged into a <em>stack frame</em> and pushed onto the call stack. Because a new stack frame is pushed onto the stack for every function call, a callee is free to call other functions, forming arbitrarily deep call chains. Whenever a function returns, its stack frame is popped off the top of the call stack, and execution control resumes as indicated by the previous stack frame.</p>&#13;
<h5 class="h5" id="ch04lev3sec10"><strong>Call Stacks and Exception Handling</strong></h5>&#13;
<p class="noindent">The runtime seeks the closest exception handler to a thrown exception. If there is a matching exception handler in the current stack frame, it will handle the exception. If no matching handler is found, the runtime will unwind the call stack until it finds a suitable handler. Any objects whose lifetimes end are destroyed in the usual way.</p>&#13;
<h5 class="h5" id="ch04lev3sec11"><strong>Throwing in Destructors</strong></h5>&#13;
<p class="noindent">If you throw an exception in a destructor, you are juggling with chainsaws. Such an exception absolutely must be caught within the destructor.</p>&#13;
<p class="indent">Suppose an exception is thrown, and during stack unwinding, another exception is thrown by a destructor during normal cleanup. Now you have <em>two</em> exceptions in flight. How should the C++ runtime handle such a situation?</p>&#13;
<p class="indent">You can have an opinion on the matter, but the runtime will call <span class="literal">terminate</span>. Consider <a href="ch04.xhtml#ch04ex13">Listing 4-13</a>, which illustrates what can happen when you throw an exception from a destructor:</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct CyberdyneSeries800 {&#13;
  CyberdyneSeries800() {&#13;
    printf("I'm a friend of Sarah Connor."); <span class="ent">➊</span>&#13;
  }&#13;
  ~CyberdyneSeries800() {&#13;
    throw std::runtime_error{ "I'll be back." }; <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  try {&#13;
    CyberdyneSeries800 t800; <span class="ent">➌</span>&#13;
    throw std::runtime_error{ "Come with me if you want to live." }; <span class="ent">➍</span>&#13;
  } catch(const std::exception&amp; e) { <span class="ent">➎</span>&#13;
    printf("Caught exception: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">I'm a friend of Sarah Connor. <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch04ex13"/><em>Listing 4-13: A program illustrating the perils of throwing an exception within a destructor</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_107"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch04.xhtml#ch04ex13">Listing 4-13</a> calls <span class="literal">std::terminate</span>, so depending on your environment, you might get a nasty pop-up indicating this.</em></p>&#13;
</div>&#13;
<p class="indent">First, you declare the <span class="literal">CyberdyneSeries800</span> class, which has a simple constructor that prints a message <span class="ent">➊</span> and a thoroughly belligerent destructor that throws an uncaught exception <span class="ent">➋</span>. Within <span class="literal">main</span>, you set up a <span class="literal">try</span> block where you initialize a <span class="literal">CyberdyneSeries800</span> called <span class="literal">t800</span> <span class="ent">➌</span> and throw a <span class="literal">runtime_error</span> <span class="ent">➍</span>. Under better circumstances, the <span class="literal">catch</span> block <span class="ent">➎</span> would handle this exception, print its message <span class="ent">➏</span>, and exit gracefully. Because <span class="literal">t800</span> is an automatic variable within the <span class="literal">try</span> block, it destructs during the normal process of finding a handler for the exception you’ve thrown <span class="ent">➍</span>. And because <span class="literal">t800</span> throws an exception in its destructor <span class="ent">➋</span>, your program invokes <span class="literal">std::terminate</span> and ends abruptly.</p>&#13;
<p class="indent">As a general rule, treat destructors as if they were <span class="literal">noexcept</span>.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><strong>A SimpleString Class</strong></h3>&#13;
<p class="noindent">Using an extended example, let’s explore how constructors, destructors, members, and exceptions gel together. The <span class="literal">SimpleString</span> class in <a href="ch04.xhtml#ch04ex14">Listing 4-14</a> allows you to add C-style strings together and print the result.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleString {&#13;
  SimpleString(size_t max_size) <span class="ent">➊</span>&#13;
    : max_size{ max_size }, <span class="ent">➋</span>&#13;
      length{} { <span class="ent">➌</span>&#13;
    if (max_size == 0) {&#13;
      throw std::runtime_error{ "Max size must be at least 1." }; <span class="ent">➍</span>&#13;
    }&#13;
    buffer = new char[max_size]; <span class="ent">➎</span>&#13;
    buffer[0] = 0; <span class="ent">➏</span>&#13;
  }&#13;
&#13;
  ~SimpleString() {&#13;
    delete[] buffer; <span class="ent">➐</span>&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  size_t max_size;&#13;
  char* buffer;&#13;
  size_t length;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex14"/><em>Listing 4-14: The constructor and destructor of a <span class="literal">SimpleString</span> class</em></p>&#13;
<p class="indent">The constructor <span class="ent">➊</span> takes a single <span class="literal">max_size</span> argument. This is the maximum length of your string, which includes a null terminator. The member initializer <span class="ent">➋</span> saves this length into the <span class="literal">max_size</span> member variable. This value is also used in the array new expression to allocate a buffer to store your string <span class="ent">➎</span>. The resulting pointer is stored into <span class="literal">buffer</span>. You initialize length <span epub:type="pagebreak" id="page_108"/>to zero <span class="ent">➌</span> and ensure that there is at least enough size for a null byte <span class="ent">➍</span>. Because the string is initially empty, you assign the first byte of the buffer to zero <span class="ent">➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because <span class="literal">max_size</span> is a <span class="literal">size_t</span>, it is unsigned and cannot be negative, so you don’t need to check for this bogus condition.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">SimpleString</span> class owns a resource—the memory pointed to by <span class="literal">buffer</span>—which must be released when it’s no longer needed. The destructor contains a single line <span class="ent">➐</span> that deallocates <span class="literal">buffer</span>. Because you’ve paired the allocation and deallocation of <span class="literal">buffer</span> with the constructor and destructor of <span class="literal">SimpleString</span>, you’ll never leak the storage.</p>&#13;
<p class="indent">This pattern is called <em>resource acquisition is initialization (RAII)</em> or <em>constructor acquires, destructor releases (CADRe)</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">SimpleString</span> class still has an implicitly defined copy constructor. Although it might never leak the storage, it will potentially double free if copied. You’ll learn about copy constructors in “Copy Semantics” on <a href="ch04.xhtml#page_115">page 115</a>. Just be aware that <a href="ch04.xhtml#ch04ex14">Listing 4-14</a> is a teaching tool, not production-worthy code.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec14"><strong><em>Appending and Printing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">SimpleString</span> class isn’t of much use yet. <a href="ch04.xhtml#ch04ex15">Listing 4-15</a> adds the ability to print the string and append a line to the end of the string.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  void print(const char* tag) const { <span class="ent">➊</span>&#13;
    printf("%s: %s", tag, buffer);&#13;
  }&#13;
&#13;
  bool append_line(const char* x) { <span class="ent">➋</span>&#13;
    const auto x_len = strlen<span class="ent">➌</span>(x);&#13;
    if (x_len + length + 2 &gt; max_size) return false; <span class="ent">➍</span>&#13;
    std::strncpy<span class="ent">➎</span>(buffer + length, x, max_size - length);&#13;
    length += x_len;&#13;
    buffer[length++] = '\n';&#13;
    buffer[length] = 0;&#13;
    return true;&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex15"/><em>Listing 4-15: The <span class="literal">print</span> and <span class="literal">append_line</span> methods of <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>The first method <span class="literal">print</span> <span class="ent">➊</span> prints your string. For convenience, you can provide a <span class="literal">tag</span> string so you can match an invocation of <span class="literal">print</span> with the result. This method is <span class="literal">const</span> because it doesn’t need to modify the state of a <span class="literal">SimpleString</span>.</p>&#13;
<p class="indent">The <span class="literal">append_line</span> method <span class="ent">➋</span> takes a null-terminated string <span class="literal">x</span> and adds its contents—plus a newline character—to <span class="literal">buffer</span>. It returns <span class="literal">true</span> if <span class="literal">x</span> was successfully appended and <span class="literal">false</span> if there wasn’t enough space. First, <span class="literal">append_line</span> must determine the length of <span class="literal">x</span>. For this, you employ the <span class="literal">strlen</span> function <span class="ent">➌</span> from the <span class="literal">&lt;cstring&gt;</span> header, which accepts a null-terminated string and returns its length:</p>&#13;
<pre>size_t strlen(const char* str);</pre>&#13;
<p class="indent">You use <span class="literal">strlen</span> to compute the length of <span class="literal">x</span> and initialize <span class="literal">x_len</span> with the result. This result is used to compute whether appending <span class="literal">x</span> (a newline character) and a null byte to the current string would result in a string with length greater than <span class="literal">max_size</span> <span class="ent">➍</span>. If it would, <span class="literal">append_line</span> returns <span class="literal">false</span>.</p>&#13;
<p class="indent">If there is enough room to append <span class="literal">x</span>, you need to copy its bytes into the correct location in <span class="literal">buffer</span>. The <span class="literal">std::strncpy</span> function <span class="ent">➎</span> from the <span class="literal">&lt;cstring&gt;</span> header is one possible tool for this job. It accepts three arguments: the <span class="literal">destination</span> address, the <span class="literal">source</span> address, and the <span class="literal">num</span> of characters to copy:</p>&#13;
<pre>char* std::strncpy(char* destination, const char* source, std::size_t num);</pre>&#13;
<p class="indent">The <span class="literal">strncpy</span> function will copy up to <span class="literal">num</span> bytes from <span class="literal">source</span> into <span class="literal">destination</span>. Once complete, it will return <span class="literal">destination</span> (which you discard).</p>&#13;
<p class="indent">After adding the number of bytes <span class="literal">x_len</span> copied into <span class="literal">buffer</span> to <span class="literal">length</span>, you finish by adding a newline character <span class="literal">\n</span> and a null byte to the end of <span class="literal">buffer</span>. You return <span class="literal">true</span> to indicate that you’ve successfully appended the input <span class="literal">x</span> as a line to the end of <span class="literal">buffer</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Use <span class="literal">strncpy</span> very carefully. It’s too easy to forget the null-terminator in the <span class="literal">source</span> string or not allocate enough space in the <span class="literal">destination</span> string. Both errors will cause undefined behavior. We’ll cover a safer alternative in <a href="part02.xhtml#part02">Part II</a> of the book.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec15"><strong><em>Using SimpleString</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04ex16">Listing 4-16</a> illustrates an example use of <span class="literal">SimpleString</span> where you append several strings and print intermediate results to the console.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;exception&gt;&#13;
&#13;
struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
<span epub:type="pagebreak" id="page_110"/>int main() {&#13;
  SimpleString string{ 115 }; <span class="ent">➊</span>&#13;
  string.append_line("Starbuck, whaddya hear?");&#13;
  string.append_line("Nothin' but the rain."); <span class="ent">➋</span>&#13;
  string.print("A") <span class="ent">➌</span>&#13;
  string.append_line("Grab your gun and bring the cat in.");&#13;
  string.append_line("Aye-aye sir, coming home."); <span class="ent">➍</span>&#13;
  string.print("B") <span class="ent">➎</span>&#13;
  if (!string.append_line("Galactica!")) { <span class="ent">➏</span>&#13;
    printf("String was not big enough to append another message."); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex16"/><em>Listing 4-16: The methods of <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent">First, you create a <span class="literal">SimpleString</span> with <span class="literal">max_length=115</span> <span class="ent">➊</span>. You use the <span class="literal">append_line</span> method twice <span class="ent">➋</span> to add some data to <span class="literal">string</span> and then print the contents along with the tag <span class="literal">A</span> <span class="ent">➌</span>. You then append more text <span class="ent">➍</span> and print the contents again, this time with the tag <span class="literal">B</span> <span class="ent">➎</span>. When <span class="literal">append_line</span> determines that <span class="literal">SimpleString</span> has run out of space <span class="ent">➏</span>, it returns <span class="literal">false</span> <span class="ent">➐</span>. (It’s your responsibility as a user of <span class="literal">SimpleString</span> to check for this condition.)</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex17">Listing 4-17</a> contains output from running this program.</p>&#13;
<pre>A: Starbuck, whaddya hear? <span class="ent">➊</span>&#13;
Nothin' but the rain.&#13;
B: Starbuck, whaddya hear? <span class="ent">➋</span>&#13;
Nothin' but the rain.&#13;
Grab your gun and bring the cat in.&#13;
Aye-aye sir, coming home.&#13;
String was not big enough to append another message. <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch04ex17"/><em>Listing 4-17: Output from running the program in <a href="ch04.xhtml#ch04ex16">Listing 4-16</a></em></p>&#13;
<p class="indent">As expected, the string contains <span class="literal">Starbuck, whaddya hear?\nNothin' but the rain.\n</span> at <span class="literal">A</span> <span class="ent">➊</span>. (Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that <span class="literal">\n</span> is the newline special character.) After appending <span class="literal">Grab your gun and bring the cat in.</span> and <span class="literal">Aye-aye sir, coming home.</span>, you get the expected output at <span class="literal">B</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">When <a href="ch04.xhtml#ch04ex17">Listing 4-17</a> tries to append <span class="literal">Galactica!</span> to <span class="literal">string</span>, <span class="literal">append_line</span> returns <span class="literal">false</span> because there is not enough space in <span class="literal">buffer</span>. This causes the message <span class="literal">String was not big enough to append another message</span> to print <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec16"><strong><em>Composing a SimpleString</em></strong></h4>&#13;
<p class="noindent">Consider what happens when you define a class with a <span class="literal">SimpleString</span> member, as demonstrated in <a href="ch04.xhtml#ch04ex18">Listing 4-18</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct SimpleStringOwner {&#13;
  SimpleStringOwner(const char* x)&#13;
    : string{ 10 } { <span class="ent">➊</span>&#13;
    if (!string.append_line(x)) {&#13;
      throw std::runtime_error{ "Not enough memory!" };&#13;
<span epub:type="pagebreak" id="page_111"/>    }&#13;
    string.print("Constructed");&#13;
  }&#13;
  ~SimpleStringOwner() {&#13;
    string.print("About to destroy"); <span class="ent">➋</span>&#13;
  }&#13;
private:&#13;
  SimpleString string;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex18"/><em>Listing 4-18: The implementation of <span class="literal">SimpleStringOwner</span></em></p>&#13;
<p class="indent">As suggested by the member initializer <span class="ent">➊</span>, <span class="literal">string</span> is fully constructed, and its class invariants are established once the constructor of <span class="literal">SimpleStringOwner</span> executes. This illustrates the order of an object’s members during construction: <em>members are constructed before the enclosing object’s constructor</em>. This makes sense: how can you establish a class’s invariants if you don’t know about its members’ invariants?</p>&#13;
<p class="indent">Destructors work the opposite way. Inside <span class="literal">~SimpleStringOwner()</span> <span class="ent">➋</span>, you need the class invariants of <span class="literal">string</span> to hold so you can print its contents. <em>All members are destructed after the object’s destructor is invoked.</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex19">Listing 4-19</a> exercises a <span class="literal">SimpleStringOwner</span>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleStringOwner x{ "x" };&#13;
  printf("x is alive\n");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructed: x <span class="ent">➊</span></span>&#13;
<span class="color1">x is alive</span>&#13;
<span class="color1">About to destroy: x <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch04ex19"/><em>Listing 4-19: A program containing a <span class="literal">SimpleStringOwner</span></em></p>&#13;
<p class="indent">As expected, the member <span class="literal">string</span> of <span class="literal">x</span> is created appropriately because <em>an object’s member constructors are called before the object’s constructor</em>, resulting in the message <span class="literal">Constructed: x</span> <span class="ent">➊</span>. As an automatic variable, <span class="literal">x</span> is destroyed just before <span class="literal">main</span> returns, and you get <span class="literal">About to destroy: x</span> <span class="ent">➋</span>. The member <span class="literal">string</span> is still valid at this point because member destructors are called after the enclosing object’s destructor.</p>&#13;
<h4 class="h4" id="ch04lev2sec17"><strong><em>Call Stack Unwinding</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04ex20">Listing 4-20</a> demonstrates how exception handling and stack unwinding work together. You establish a <span class="literal">try</span>-<span class="literal">catch</span> block in <span class="literal">main</span> and then make a series of function calls. One of these calls causes an exception.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void fn_c() {&#13;
  SimpleStringOwner c{ "cccccccccc" }; <span class="ent">➊</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_112"/>void fn_b() {&#13;
  SimpleStringOwner b{ "b" };&#13;
  fn_c(); <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  try { <span class="ent">➌</span>&#13;
    SimpleStringOwner a{ "a" };&#13;
    fn_b(); <span class="ent">➍</span>&#13;
    SimpleStringOwner d{ "d" }; <span class="ent">➎</span>&#13;
  } catch(const std::exception&amp; e) { <span class="ent">➏</span>&#13;
    printf("Exception: %s\n", e.what());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex20"/><em>Listing 4-20: A program illustrating the use of <span class="literal">SimpleStringOwner</span> and call stack unwinding</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex21">Listing 4-21</a> shows the results of running the program in <a href="ch04.xhtml#ch04ex20">Listing 4-20</a>.</p>&#13;
<pre>Constructed: a&#13;
Constructed: b&#13;
About to destroy: b&#13;
About to destroy: a&#13;
Exception: Not enough memory!</pre>&#13;
<p class="listing"><a id="ch04ex21"/><em>Listing 4-21: Output from running the program in <a href="ch04.xhtml#ch04ex20">Listing 4-20</a></em></p>&#13;
<p class="indent">You’ve set up a <span class="literal">try</span>-<span class="literal">catch</span> block <span class="ent">➌</span>. The first <span class="literal">SimpleStringOwner</span>, <span class="literal">a</span>, gets constructed without incident, and you see <span class="literal">Constructed: a</span> printed to the console. Next, <span class="literal">fn_b</span> is called <span class="ent">➍</span>. Notice that you’re still in the <span class="literal">try</span>-<span class="literal">catch</span> block, so any <span class="literal">exception</span> that gets thrown <em>will</em> be handled. Inside <span class="literal">fn_b</span>, another <span class="literal">SimpleString Owner</span>, <span class="literal">b</span>, gets constructed successfully, and <span class="literal">Constructed: b</span> is printed to the console. Next, there’s a call into yet another function, <span class="literal">fn_c</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Let’s pause for a moment to take an account of what the call stack looks like, what objects are alive, and what the exception-handling situation looks like. You have two <span class="literal">SimpleStringOwner</span> objects alive and valid: <span class="literal">a</span> and <span class="literal">b</span>. The call stack looks like <span class="literal">main() → fn_b() → fn_c()</span>, and you have an exception handler set up inside <span class="literal">main</span> to handle any exceptions. <a href="ch04.xhtml#ch04fig03">Figure 4-3</a> summarizes this situation.</p>&#13;
<p class="indent">At <span class="ent">➊</span>, you run into a little problem. Recall that <span class="literal">SimpleStringOwner</span> has a member <span class="literal">SimpleString</span> that is always initialized with a <span class="literal">max_size</span> of 10. When you try to construct <span class="literal">c</span>, the constructor of <span class="literal">SimpleStringOwner</span> throws an <span class="literal">exception</span> because you’ve tried to append <span class="literal">"cccccccccc"</span>, which has length 10 and is too big to fit alongside a newline and a null terminator.</p>&#13;
<p class="indent">Now you have an exception in flight. The stack will unwind until an appropriate handler is found, and all objects that fall out of scope as a result of this unwinding will be destructed. The handler is all the way up the stack <span class="ent">➏</span>, so <span class="literal">fn_c</span> and <span class="literal">fn_b</span> unwind. Because <span class="literal">SimpleStringOwner b</span> is an automatic variable in <span class="literal">fn_b</span>, it gets destructed and you see <span class="literal">About to destroy: b</span> printed to the console. After <span class="literal">fn_b</span>, the automatic variables inside <span class="literal">try{}</span> are destroyed. This includes <span class="literal">SimpleStringOwner a</span>, so you see <span class="literal">About to destroy: a</span> printed to the console.</p>&#13;
<div class="image"><img src="../images/fig4_3.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig03"><em>Figure 4-3: The call stack when <span class="literal">fn_c</span> calls the constructor of <span class="literal">SimpleStringOwner c</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Once an exception occurs in a <span class="literal">try{}</span> block, no further statements execute. As a result, <span class="literal">d</span> never initializes <span class="ent">➎</span>, and you never see the constructor of <span class="literal">d</span> print to console. After the call stack is unwound, execution proceeds immediately to the <span class="literal">catch</span> block. In the end, you print the message <span class="literal">Exception: Not enough memory!</span> to the console <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec18"><strong><em>Exceptions and Performance</em></strong></h4>&#13;
<p class="noindent">In your programs, you must handle errors; errors are unavoidable. When you use exceptions correctly and no errors occur, your code is faster than manually error-checked code. If an error does occur, exception handling can sometimes be slower, but you make huge gains in robustness and maintainability over the alternative. Kurt Guntheroth, the author of <em>Optimized C++</em>, puts it well: “use of exception handling leads to programs that are faster when they execute normally, and better behaved when they fail.” When a C++ program executes normally (without exceptions being thrown), there is no runtime overhead associated with checking exceptions. It’s only when an exception is thrown that you pay overhead.</p>&#13;
<p class="indent">Hopefully, you’re convinced of the central role exceptions play in idiomatic C++ programs. Sometimes, unfortunately, you won’t be able to use exceptions. One example is embedded development where real-time guarantees are required. Tools simply don’t (yet) exist in this setting. With luck, this will change soon, but for now, you’re stuck without exceptions in most embedded contexts. Another example is with some legacy code. Exceptions are elegant because of how they fit in with RAII objects. When destructors are responsible for cleaning up resources, stack unwinding is a direct and effective way to guarantee against resource leakages. In legacy code, you might find manual resource management and error handling instead of RAII objects. This makes using exceptions very dangerous, because stack unwinding is safe only with RAII objects. Without them, you could easily leak resources.</p>&#13;
<h4 class="h4" id="ch04lev2sec19"><span epub:type="pagebreak" id="page_114"/><strong><em>Alternatives to Exceptions</em></strong></h4>&#13;
<p class="noindent">In situations where exceptions are not available, all is not lost. Although you’ll need to keep track of errors manually, there are some helpful C++ features that you can employ to take the sting out a bit. First, you can manually enforce class invariants by exposing some method that communicates whether the class invariants could be established, as shown here:</p>&#13;
<pre>struct HumptyDumpty {&#13;
   HumptyDumpty();&#13;
   bool is_together_again();&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">In idiomatic C++, you would just throw an exception in the constructor, but here you must remember to check and treat the situation as an error condition in your calling code:</p>&#13;
<pre>bool send_kings_horses_and_men() {&#13;
  HumptyDumpty hd{};&#13;
  if (hd.is_together_again()) return false;&#13;
  // Class invariants of hd are now guaranteed.&#13;
  // Humpty Dumpty had a great fall.&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  return true;&#13;
}</pre>&#13;
<p class="indent">The second, complementary coping strategy is to return multiple values using <em>structured binding declaration</em>, a language feature that allows you to return multiple values from a function call. You can use this feature to return success flags alongside the usual return value, as demonstrated in <a href="ch04.xhtml#ch04ex22">Listing 4-22</a>.</p>&#13;
<pre>struct Result { <span class="ent">➊</span>&#13;
  HumptyDumpty hd;&#13;
  bool success;&#13;
};&#13;
&#13;
Result make_humpty() { <span class="ent">➋</span>&#13;
  HumptyDumpty hd{};&#13;
  bool is_valid;&#13;
  // Check that hd is valid and set is_valid appropriately&#13;
  return { hd, is_valid };&#13;
}&#13;
&#13;
bool send_kings_horses_and_men() {&#13;
  auto [hd, success] = make_humpty(); <span class="ent">➌</span>&#13;
  if(!success) return false;&#13;
  // Class invariants established&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  return true;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex22"/><em>Listing 4-22: A code segment illustrating structured binding declaration</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>First, you declare a POD that contains a <span class="literal">HumptyDumpty</span> and a <span class="literal">success</span> flag <span class="ent">➊</span>. Next, you define the function <span class="literal">make_humpty</span> <span class="ent">➋</span>, which builds and validates a <span class="literal">HumptyDumpty</span>. Such methods are called <em>factory methods</em>, because their purpose is to initialize objects. The <span class="literal">make_humpty</span> function packs this and the success flag into a <span class="literal">Result</span> when it returns. The syntax at the call site <span class="ent">➌</span> illustrates how you can unpack the <span class="literal">Result</span> into multiple, <span class="literal">auto</span>-type-deduced variables.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll explore structured bindings in more detail in “Structured Bindings” on <a href="ch08.xhtml#page_222">page 222</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Copy Semantics</strong></h3>&#13;
<p class="noindent"><em>Copy semantics</em> is “the meaning of copy.” In practice, programmers use the term to mean the rules for making copies of objects: after <span class="literal">x</span> is <em>copied into</em> <span class="literal">y</span>, they’re <em>equivalent</em> and <em>independent</em>. That is, <span class="literal">x == y</span> is true after a copy (equivalence), and a modification to <span class="literal">x</span> doesn’t cause a modification of <span class="literal">y</span> (independence).</p>&#13;
<p class="indent">Copying is extremely common, especially when passing objects to functions by value, as demonstrated in <a href="ch04.xhtml#ch04ex23">Listing 4-23</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int add_one_to(int x) {&#13;
  x++; <span class="ent">➊</span>&#13;
  return x;&#13;
}&#13;
&#13;
int main() {&#13;
  auto original = 1;&#13;
  auto result = add_one_to(original); <span class="ent">➋</span>&#13;
  printf("Original: %d; Result: %d", original, result);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Original: 1; Result: 2</span></pre>&#13;
<p class="listing"><a id="ch04ex23"/><em>Listing 4-23: A program illustrating that passing by value generates a copy</em></p>&#13;
<p class="indent">Here, <span class="literal">add_one_to</span> takes its argument <span class="literal">x</span> by value. It then modifies the value of <span class="literal">x</span> <span class="ent">➊</span>. This modification is isolated from the caller <span class="ent">➋</span>; <span class="literal">original</span> is unaffected because <span class="literal">add_one_to</span> gets a copy.</p>&#13;
<p class="indent">For user-defined POD types, the story is similar. Passing by value causes each member value to be copied into the parameter (a <em>member-wise copy</em>), as demonstrated in <a href="ch04.xhtml#ch04ex24">Listing 4-24</a>.</p>&#13;
<pre>struct Point {&#13;
  int x, y;&#13;
};&#13;
&#13;
Point make_transpose(Point p) {&#13;
  int tmp = p.x;&#13;
  p.x = p.y;&#13;
<span epub:type="pagebreak" id="page_116"/>  p.y = tmp;&#13;
  return p;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex24"/><em>Listing 4-24: The function <span class="literal">make_transpose</span> generates a copy of the POD type <span class="literal">Point</span>.</em></p>&#13;
<p class="indent">When <span class="literal">make_transpose</span> is invoked, it receives a copy <span class="literal">Point</span> in <span class="literal">p</span>, and the original is unaffected.</p>&#13;
<p class="indent">For fundamental and POD types, the story is straightforward. Copying these types is memberwise, which means each member gets copied into its corresponding destination. This is effectively a bitwise copy from one memory address to another.</p>&#13;
<p class="indent">Fully featured classes require some more thought. The default copy semantics for fully featured classes is also the memberwise copy, and this can be extremely dangerous. Consider again the <span class="literal">SimpleString</span> class. You would invite disaster if you allowed a user to make a memberwise copy of a live <span class="literal">SimpleString</span> class. Two <span class="literal">SimpleString</span> classes would point to the same <span class="literal">buffer</span>. With both of the copies appending to the same <span class="literal">buffer</span>, they’ll clobber each other. <a href="ch04.xhtml#ch04fig04">Figure 4-4</a> summarizes the situation.</p>&#13;
<div class="image"><img src="../images/fig4_4.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig04"><em>Figure 4-4: A depiction of default copy semantics on the <span class="literal">SimpleString</span> class</em></p>&#13;
<p class="indent">This result is bad, but even worse things happen when the <span class="literal">SimpleString</span> classes start destructing. When one of the <span class="literal">SimpleString</span> classes is destructed, <span class="literal">buffer</span> will be freed. When the remaining <span class="literal">SimpleString</span> class tries to write its <span class="literal">buffer</span>—bang!—you have undefined behavior. At some point, this remaining <span class="literal">SimpleString</span> class will be destructed and free <span class="literal">buffer</span> again, resulting in what is commonly called a <em>double free</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Like its nefarious cousin the use after free, the double free can result in subtle and hard-to-diagnose bugs that manifest only very infrequently. A double free occurs when you deallocate an object twice. Recall that once you’ve deallocated an object, its storage lifetime ends. This memory is now in an undefined state, and if you destruct an object that’s already been destructed, you’ve got undefined behavior. In certain situations, this can cause serious security vulnerabilities.</em></p>&#13;
</div>&#13;
<p class="indent">You can avoid this dumpster fire by taking control of copy semantics. You can specify copy constructors and copy assignment operators, as described in the following sections.</p>&#13;
<h4 class="h4" id="ch04lev2sec20"><span epub:type="pagebreak" id="page_117"/><strong><em>Copy Constructors</em></strong></h4>&#13;
<p class="noindent">There are two ways to copy an object. One is to use <em>copy construction</em>, which creates a copy and assigns it to a brand-new object. The copy constructor looks like other constructors:</p>&#13;
<pre>struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  SimpleString(const SimpleString&amp; other);&#13;
};</pre>&#13;
<p class="indent">Notice that <span class="literal">other</span> is <span class="literal">const</span>. You’re copying from some original <span class="literal">SimpleString</span>, and you have no reason to modify it. You use the copy constructor just like other constructors, using the uniform initialization syntax of braced initializers:</p>&#13;
<pre>SimpleString a;&#13;
SimpleString a_copy{ a };</pre>&#13;
<p class="indent">The second line invokes the copy constructor of <span class="literal">SimpleString</span> with <span class="literal">a</span> to yield <span class="literal">a_copy</span>.</p>&#13;
<p class="indent">Let’s implement the copy constructor of <span class="literal">SimpleString</span>. You want what is known as a <em>deep copy</em> where you copy the data pointed to by the original <span class="literal">buffer</span> into a new <span class="literal">buffer</span>, as depicted in <a href="ch04.xhtml#ch04fig05">Figure 4-5</a>.</p>&#13;
<div class="image"><img src="../images/fig4_5.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig05"><em>Figure 4-5: A depiction of a deep copy on the <span class="literal">SimpleString</span> class</em></p>&#13;
<p class="indent">Rather than copying the pointer <span class="literal">buffer</span>, you’ll make a new allocation on the free store and then copy all the data pointed to by the original <span class="literal">buffer</span>. This gives you two independent <span class="literal">SimpleString</span> classes. <a href="ch04.xhtml#ch04ex25">Listing 4-25</a> implements the copy constructor of <span class="literal">SimpleString</span>:</p>&#13;
<pre>SimpleString(const SimpleString&amp; other)&#13;
  : max_size{ other.max_size }, <span class="ent">➊</span>&#13;
    buffer{ new char[other.max_size] }, <span class="ent">➋</span>&#13;
    length{ other.length } { <span class="ent">➌</span>&#13;
    std::strncpy(buffer, other.buffer, max_size); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex25"/><em>Listing 4-25: <span class="literal">SimpleString</span> class’s copy constructor</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>You use member initializers for <span class="literal">max_size</span> <span class="ent">➊</span>, <span class="literal">buffer</span> <span class="ent">➋</span>, and <span class="literal">length</span> <span class="ent">➌</span> and pass in the corresponding fields on <span class="literal">other</span>. You can use array new <span class="ent">➋</span> to initialize <span class="literal">buffer</span> because you know <span class="literal">other.max_size</span> is greater than 0. The copy constructor’s body contains a single statement <span class="ent">➍</span> that copies the contents pointed to by <span class="literal">other.buffer</span> into the array pointed to by <span class="literal">buffer</span>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex26">Listing 4-26</a> uses this copy constructor by initializing a <span class="literal">SimpleString</span> with an existing <span class="literal">SimpleString</span>:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  SimpleString a_copy{ a }; <span class="ent">➊</span>&#13;
  a.append_line("inconvenience."); <span class="ent">➋</span>&#13;
  a_copy.append_line("incontinence."); <span class="ent">➌</span>&#13;
  a.print("a");&#13;
  a_copy.print("a_copy");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the</span>&#13;
<span class="color1">inconvenience.</span>&#13;
<span class="color1">a_copy: We apologize for the</span>&#13;
<span class="color1">incontinence.</span></pre>&#13;
<p class="listing"><a id="ch04ex26"/><em>Listing 4-26: A program using <span class="literal">SimpleString</span> class’s copy constructor</em></p>&#13;
<p class="indent">In the program, <span class="literal">SimpleString a_copy</span> <span class="ent">➊</span> is copy constructed from <span class="literal">a</span>. It’s equivalent to—and independent from—the original. You can append different messages to the end of <span class="literal">a</span> <span class="ent">➋</span> and <span class="literal">a_copy</span> <span class="ent">➌</span>, and the changes are isolated.</p>&#13;
<p class="indent">The copy constructor is invoked when passing <span class="literal">SimpleString</span> into a function by value, as demonstrated in <a href="ch04.xhtml#ch04ex27">Listing 4-27</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void foo(SimpleString x) {&#13;
  x.append_line("Change lost.");&#13;
}&#13;
&#13;
int main() {&#13;
  SimpleString a { 20 };&#13;
  foo(a); // Invokes copy constructor&#13;
  a.print("Still empty");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Still empty:</span></pre>&#13;
<p class="listing"><a id="ch04ex27"/><em>Listing 4-27: A program illustrating that copy constructors get invoked when passing an object by value</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You shouldn’t pass by value to avoid modification. Use a <span class="literal">const</span> reference.</em></p>&#13;
</div>&#13;
<p class="indent">The performance impact of copying can be substantial, especially in a situation where free store allocations and buffer copies are involved. For example, suppose you have a class that manages the life cycle of a gigabyte <span epub:type="pagebreak" id="page_119"/>of data. Each time you copy the object, you’ll need to allocate and copy a gigabyte of data. This can take a lot of time, so you should be absolutely sure you need the copy. If you can get away with passing a <span class="literal">const</span> reference, strongly prefer it.</p>&#13;
<h4 class="h4" id="ch04lev2sec21"><strong><em>Copy Assignment</em></strong></h4>&#13;
<p class="noindent">The other way to make a copy in C++ is with the <em>copy assignment operator</em>. You can create a copy of an object and assign it to another existing object, as demonstrated in <a href="ch04.xhtml#ch04ex28">Listing 4-28</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void dont_do_this() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message");&#13;
  b = a; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex28"/><em>Listing 4-28: Using the default copy assignment operator to create a copy of an object and assign it to another existing object</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The code in <a href="ch04.xhtml#ch04ex28">Listing 4-28</a> causes undefined behavior because it doesn’t have a user-defined copy assignment operator.</em></p>&#13;
</div>&#13;
<p class="indent">The line at <span class="ent">➊</span> <em>copy assigns</em> <span class="literal">a</span> to <span class="literal">b</span>. The major difference between copy assignment and copy construction is that in copy assignment, <span class="literal">b</span> might already have a value. You must clean up <span class="literal">b</span>’s resources before copying <span class="literal">a</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The default copy assignment operator for simple types just copies the members from the source object to the destination object. In the case of <span class="literal"><em>SimpleString</em></span>, this is very dangerous for two reasons. First, the original <span class="literal"><em>SimpleString</em></span> class’s buffer gets rewritten without freeing the dynamically allocated <span class="literal"><em>char</em></span> array. Second, now two <span class="literal"><em>SimpleString</em></span> classes own the same buffer, which can cause dangling pointers and double frees. You must implement a copy assignment operator that performs a clean hand-off.</em></p>&#13;
</div>&#13;
<p class="indent">The copy assignment operator uses the <span class="literal">operator=</span> syntax, as demonstrated in <a href="ch04.xhtml#ch04ex29">Listing 4-29</a>.</p>&#13;
<pre>struct SimpleString {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this; <span class="ent">➊</span>&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    return *this; <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex29"/><em>Listing 4-29: A user-defined copy assignment operator for <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>The copy assignment operator returns a reference to the result, which is always <span class="literal">*this</span> <span class="ent">➋</span>. It’s also generally good practice to check whether <span class="literal">other</span> refers to <span class="literal">this</span> <span class="ent">➊</span>.</p>&#13;
<p class="indent">You can implement copy assignment for <span class="literal">SimpleString</span> by following these guidelines: free the current <span class="literal">buffer</span> of <span class="literal">this</span> and then copy <span class="literal">other</span> as you did in copy construction, as shown in <a href="ch04.xhtml#ch04ex30">Listing 4-30</a>.</p>&#13;
<pre>  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this;&#13;
    const auto new_buffer = new char[other.max_size]; <span class="ent">➊</span>&#13;
    delete[] buffer; <span class="ent">➋</span>&#13;
    buffer = new_buffer; <span class="ent">➌</span>&#13;
    length = other.length; <span class="ent">➍</span>&#13;
    max_size = other.max_size; <span class="ent">➎</span>&#13;
    std::strncpy(buffer, other.buffer, max_size); <span class="ent">➏</span>&#13;
    return *this;&#13;
  }</pre>&#13;
<p class="listing"><a id="ch04ex30"/><em>Listing 4-30: A copy assignment operator for <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent">The copy assignment operator starts by allocating a <span class="literal">new_buffer</span> with the appropriate size <span class="ent">➊</span>. Next, you clean up <span class="literal">buffer</span> <span class="ent">➋</span>. The rest is essentially identical to the copy constructor in <a href="ch04.xhtml#ch04ex25">Listing 4-25</a>. You copy <span class="literal">buffer</span> <span class="ent">➌</span>, <span class="literal">length</span> <span class="ent">➍</span>, and <span class="literal">max_size</span> <span class="ent">➎</span> and then copy the contents from <span class="literal">other.buffer</span> into your own <span class="literal">buffer</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex31">Listing 4-31</a> illustrates how <span class="literal">SimpleString</span> copy assignment works (as implemented in <a href="ch04.xhtml#ch04ex30">Listing 4-30</a>).</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the"); <span class="ent">➊</span>&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message"); <span class="ent">➋</span>&#13;
  a.print("a"); <span class="ent">➌</span>&#13;
  b.print("b"); <span class="ent">➍</span>&#13;
  b = a; <span class="ent">➎</span>&#13;
  a.print("a"); <span class="ent">➏</span>&#13;
  b.print("b"); <span class="ent">➐</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the <span class="ent">➌</span></span>&#13;
<span class="color1">b: Last message <span class="ent">➍</span></span>&#13;
<span class="color1">a: We apologize for the <span class="ent">➏</span></span>&#13;
<span class="color1">b: We apologize for the <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch04ex31"/><em>Listing 4-31: A program illustrating copy assignment with the <span class="literal">SimpleString</span> class</em></p>&#13;
<p class="indent">You begin by declaring two <span class="literal">SimpleString</span> classes with different messages: the string <span class="literal">a</span> contains <span class="literal">We apologize for the</span> <span class="ent">➊</span>, and <span class="literal">b</span> contains <span class="literal">Last</span> <span epub:type="pagebreak" id="page_121"/><span class="literal">message</span> <span class="ent">➋</span>. You print these strings to verify that they contain the text you’ve specified <span class="ent">➌➍</span>. Next, you copy assign <span class="literal">b</span> equal to <span class="literal">a</span> <span class="ent">➎</span>. Now, <span class="literal">a</span> and <span class="literal">b</span> contain copies of the same message, <span class="literal">We apologize for the</span> <span class="ent">➏➐</span>. But—and this is important—that message resides in two separate memory locations.</p>&#13;
<h4 class="h4" id="ch04lev2sec22"><strong><em>Default Copy</em></strong></h4>&#13;
<p class="noindent">Often, the compiler will generate default implementations for copy construction and copy assignment. The default implementation is to invoke copy construction or copy assignment on each of a class’s members.</p>&#13;
<p class="indent">Any time a class manages a resource, you must be extremely careful with default copy semantics; they’re likely to be wrong (as you saw with <span class="literal">SimpleString</span>). Best practice dictates that you explicitly declare that default copy assignment and copy construction are acceptable for such classes using the <span class="literal">default</span> keyword. The <span class="literal">Replicant</span> class, for example, has default copy semantics, as demonstrated here:</p>&#13;
<pre>struct Replicant {&#13;
  Replicant(const Replicant&amp;) = default;&#13;
  Replicant&amp; operator=(const Replicant&amp;) = default;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">Some classes simply cannot or should not be copied—for example, if your class manages a file or if it represents a mutual exclusion lock for concurrent programming. You can suppress the compiler from generating a copy constructor and a copy assignment operator using the <span class="literal">delete</span> keyword. The <span class="literal">Highlander</span> class, for example, cannot be copied:</p>&#13;
<pre>struct Highlander {&#13;
  Highlander(const Highlander&amp;) = delete;&#13;
  Highlander&amp; operator=(const Highlander&amp;) = delete;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">Any attempt to copy a <span class="literal">Highlander</span> will result in a compiler error:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  Highlander a;&#13;
  Highlander b{ a }; // Bang! There can be only one.&#13;
}</pre>&#13;
<p class="indent">I highly recommend that you explicitly define the copy assignment operator and copy constructor for <em>any</em> class that owns a resource (like a printer, a network connection, or a file). If custom behavior is not needed, use either <span class="literal">default</span> or <span class="literal">delete</span>. This will save you from a lot of nasty and difficult-to-debug errors.</p>&#13;
<h4 class="h4" id="ch04lev2sec23"><strong><em><span epub:type="pagebreak" id="page_122"/>Copy Guidelines</em></strong></h4>&#13;
<p class="noindent">When you implement copy behavior, think about the following criteria:</p>&#13;
<p class="bq"><strong>Correctness</strong> You must ensure that class invariants are maintained. The <span class="literal">SimpleString</span> class demonstrated that the default copy constructor can violate invariants.</p>&#13;
<p class="bq"><strong>Independence</strong> After copy assignment or copy construction, the original object and the copy shouldn’t change each other’s state during modification. Had you simply copied <span class="literal">buffer</span> from one <span class="literal">SimpleString</span> to another, writing to one <span class="literal">buffer</span> could overwrite the data from the other.</p>&#13;
<p class="bq"><strong>Equivalence</strong> The original and the copy should be the <em>same</em>. The semantics of sameness depend on context. But generally, an operation applied to the original should yield the same result when applied to the copy.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Move Semantics</strong></h3>&#13;
<p class="noindent">Copying can be quite time-consuming at runtime when a large amount of data is involved. Often, you just want to <em>transfer ownership</em> of resources from one object to another. You could make a copy and destroy the original, but this is often inefficient. Instead, you can <em>move</em>.</p>&#13;
<p class="indent"><em>Move semantics</em> is move’s corollary to copy semantics, and it requires that after an object <span class="literal">y</span> is <em>moved into</em> an object <span class="literal">x</span>, <span class="literal">x</span> is equivalent to the former value of <span class="literal">y</span>. After the move, <span class="literal">y</span> is in a special state called the <em>moved-from</em> state. You can perform only two operations on moved-from objects: (re)assign them or destruct them. Note that moving an object <span class="literal">y</span> into an object <span class="literal">x</span> isn’t just a renaming: these are separate objects with separate storage and potentially separate lifetimes.</p>&#13;
<p class="indent">Similar to how you specify copying behavior, you specify how objects move with <em>move constructors</em> and <em>move assignment operators</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec24"><strong><em>Copying Can Be Wasteful</em></strong></h4>&#13;
<p class="noindent">Suppose you want to move a <span class="literal">SimpleString</span> into a <span class="literal">SimpleStringOwner</span> in the following way:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
void own_a_string() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the");&#13;
  a.append_line("inconvenience.");&#13;
  SimpleStringOwner b{ a };&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">You could add a constructor for <span class="literal">SimpleStringOwner</span> and then copy-construct its <span class="literal">SimpleString</span> member, as demonstrated in <a href="ch04.xhtml#ch04ex32">Listing 4-32.</a></p>&#13;
<pre><span epub:type="pagebreak" id="page_123"/>struct SimpleStringOwner {&#13;
  SimpleStringOwner(const SimpleString&amp; my_string) : string{ my_string }<span class="ent">➊</span> { }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  SimpleString string; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex32"/><em>Listing 4-32: A naive approach to member initialization containing a wasteful copy</em></p>&#13;
<p class="indent">There is hidden waste in this approach. You have a copy construction <span class="ent">➊</span>, but the caller never uses the pointed-to object again after constructing <span class="literal">string</span> <span class="ent">➋</span>. <a href="ch04.xhtml#ch04fig06">Figure 4-6</a> illustrates the issue.</p>&#13;
<div class="image"><img src="../images/fig4_6.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig06"><em>Figure 4-6: Using the copy constructor for <span class="literal">string</span> is wasteful.</em></p>&#13;
<p class="indent">You should move the guts of <span class="literal">SimpleString a</span> into the <span class="literal">string</span> field of <span class="literal">SimpleStringOwner</span>. <a href="ch04.xhtml#ch04fig07">Figure 4-7</a> shows what you want to achieve: <span class="literal">SimpleString Owner b</span> steals <span class="literal">buffer</span> and sets <span class="literal">SimpleString a</span> into a destructible state.</p>&#13;
<div class="image"><img src="../images/fig4_7.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig07"><em>Figure 4-7: Swapping the buffer of <span class="literal">a</span> into <span class="literal">b</span></em></p>&#13;
<p class="indent">After moving <span class="literal">a</span>, the <span class="literal">SimpleString</span> of <span class="literal">b</span> is equivalent to the former state of <span class="literal">a</span>, and <span class="literal">a</span> is destructible.</p>&#13;
<p class="indent">Moving can be dangerous. If you accidentally use moved-from <span class="literal">a</span>, you’d invite disaster. The class invariants of <span class="literal">SimpleString</span> aren’t satisfied when <span class="literal">a</span> is moved from.</p>&#13;
<p class="indent">Fortunately, the compiler has built-in safeguards: <em>lvalues</em> and <em>rvalues</em>.</p>&#13;
<h4 class="h4" id="ch04lev2sec25"><strong><em><span epub:type="pagebreak" id="page_124"/>Value Categories</em></strong></h4>&#13;
<p class="noindent">Every expression has two important characteristics: its <em>type</em> and its <em>value category</em>. A value category describes what kinds of operations are valid for the expression. Thanks to the evolutionary nature of C++, value categories are complicated: an expression can be a “generalized lvalue” (<em>glvalue</em>), a “pure rvalue” (<em>prvalue</em>), an “expiring value” (<em>xvalue</em>), an <em>lvalue</em> (a glvalue that isn’t an xvalue), or an <em>rvalue</em> (a prvalue or an xvalue). Fortunately for the newcomer, you don’t need to know much about most of these value categories.</p>&#13;
<p class="indent">We’ll consider a very simplified view of value categories. For now, you’ll just need a general understanding of lvalues and rvalues. An <em>lvalue</em> is any value that has a name, and an <em>rvalue</em> is anything that isn’t an lvalue.</p>&#13;
<p class="indent">Consider the following initializations:</p>&#13;
<pre>SimpleString a{ 50 };&#13;
SimpleStringOwner b{ a };                   // a is an lvalue&#13;
SimpleStringOwner c{ SimpleString{ 50 } };  // SimpleString{ 50 } is an rvalue</pre>&#13;
<p class="indent">The etymology of these terms is <em>right value</em> and <em>left value</em>, referring to where each appears with respect to the equal sign in construction. In the statement <span class="literal">int x = 50;</span>, <span class="literal">x</span> is left of the equal sign (lvalue) and <span class="literal">50</span> is right of the equal sign (rvalue). These terms aren’t totally accurate because you can have an lvalue on the right side of an equal sign (as in copy assignment, for example).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The ISO C++ Standard details Value Categories in [basic] and [expr].</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec26"><strong><em>lvalue and rvalue References</em></strong></h4>&#13;
<p class="noindent">You can communicate to the compiler that a function accepts lvalues or rvalues using <em>lvalue references</em> and <em>rvalue references</em>. Up to this point in this book, every reference parameter has been an lvalue reference, and these are denoted with a single <span class="literal">&amp;</span>. You can also take a parameter by rvalue reference using <span class="literal">&amp;&amp;</span>.</p>&#13;
<p class="indent">Fortunately, the compiler does an excellent job of determining whether an object is an lvalue or an rvalue. In fact, you can define multiple functions with the same name but with different parameters, and the compiler will automatically call the correct version depending on what arguments you provide when you invoke the function.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex33">Listing 4-33</a> contains two functions with the name <span class="literal">ref_type</span> function to discern whether the invoker passed an lvalue or an rvalue reference.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
void ref_type(int &amp;x) { <span class="ent">➊</span>&#13;
  printf("lvalue reference %d\n", x);&#13;
}&#13;
<span epub:type="pagebreak" id="page_125"/>void ref_type(int &amp;&amp;x) { <span class="ent">➋</span>&#13;
  printf("rvalue reference %d\n", x);&#13;
}&#13;
&#13;
int main() {&#13;
  auto x = 1;&#13;
  ref_type(x); <span class="ent">➌</span>&#13;
  ref_type(2); <span class="ent">➍</span>&#13;
  ref_type(x + 2); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">lvalue reference 1 <span class="ent">➌</span></span>&#13;
<span class="color1">rvalue reference 2 <span class="ent">➍</span></span>&#13;
<span class="color1">rvalue reference 3 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch04ex33"/><em>Listing 4-33: A program containing an overloaded function with lvalue and rvalue references</em></p>&#13;
<p class="indent">The <span class="literal">int &amp;x</span> version <span class="ent">➊</span> takes an lvalue reference, and the <span class="literal">int &amp;&amp;x</span> version <span class="ent">➋</span> takes an rvalue reference. You invoke <span class="literal">ref_type</span> three times. First, you invoke the lvalue reference version, because <span class="literal">x</span> is an lvalue (it has a name) <span class="ent">➌</span>. Second, you invoke the rvalue reference version because <span class="literal">2</span> is an integer literal without a name <span class="ent">➍</span>. Third, the result of adding 2 to <span class="literal">x</span> is not bound to a name, so it’s an rvalue <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Defining multiple functions with the same name but different parameters is called <em>function overloading</em>, a topic you’ll explore in detail in <a href="ch09.xhtml#ch09">Chapter 9</a>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec27"><strong><em>The std::move Function</em></strong></h4>&#13;
<p class="noindent">You can cast an lvalue reference to an rvalue reference using the <span class="literal">std::move</span> function from the <span class="literal">&lt;utility&gt;</span> header. <a href="ch04.xhtml#ch04ex34">Listing 4-34</a> updates <a href="ch04.xhtml#ch04ex33">Listing 4-33</a> to illustrate the use of the <span class="literal">std::move</span> function.</p>&#13;
<pre>#include &lt;utility&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  auto x = 1;&#13;
  ref_type(std::move(x)); <span class="ent">➊</span>&#13;
  ref_type(2);&#13;
  ref_type(x + 2);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">rvalue reference 1 <span class="ent">➊</span></span>&#13;
<span class="color1">rvalue reference 2</span>&#13;
<span class="color1">rvalue reference 3</span></pre>&#13;
<p class="listing"><a id="ch04ex34"/><em>Listing 4-34: An update to <a href="ch04.xhtml#ch04ex33">Listing 4-33</a> using <span class="literal">std::move</span> to cast <span class="literal">x</span> to an rvalue</em></p>&#13;
<p class="indent">As expected, <span class="literal">std::move</span> changes the lvalue <span class="literal">x</span> into an rvalue <span class="ent">➊</span>. You never call the lvalue <span class="literal">ref_type</span> overload.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_126"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The C++ committee probably should have named <span class="literal">std::move</span> as <span class="literal">std::rvalue</span>, but it’s the name we’re stuck with. The <span class="literal">std:move</span> function doesn’t actually move anything—it casts.</em></p>&#13;
</div>&#13;
<p class="indent">Be very careful when you’re using <span class="literal">std::move</span>, because you remove the safeguards keeping you from interacting with a moved-from object. You can perform two actions on a moved-from object: destroy it or reassign it.</p>&#13;
<p class="indent">How lvalue and rvalue semantics enable move semantics should now be clear. If an lvalue is at hand, moving is suppressed. If an rvalue is at hand, moving is enabled.</p>&#13;
<h4 class="h4" id="ch04lev2sec28"><strong><em>Move Construction</em></strong></h4>&#13;
<p class="noindent">Move constructors look like copy constructors except they take rvalue references instead of lvalue references.</p>&#13;
<p class="indent">Consider the <span class="literal">SimpleString</span> move constructor in <a href="ch04.xhtml#ch04ex35">Listing 4-35</a>.</p>&#13;
<pre>SimpleString(SimpleString&amp;&amp; other) noexcept&#13;
  : max_size{ other.max_size }, <span class="ent">➊</span>&#13;
  buffer(other.buffer),&#13;
  length(other.length) {&#13;
  other.length = 0; <span class="ent">➋</span>&#13;
  other.buffer = nullptr;&#13;
  other.max_size = 0;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex35"/><em>Listing 4-35: A move constructor for <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent">Because <span class="literal">other</span> is an rvalue reference, you’re allowed to cannibalize it. In the case of <span class="literal">SimpleString</span>, this is easy: just copy all fields of <span class="literal">other</span> into <span class="literal">this</span> <span class="ent">➊</span> and then zero out the fields of <span class="literal">other</span> <span class="ent">➋</span>. The latter step is important: it puts <span class="literal">other</span> in a moved-from state. (Consider what would happen upon the destruction of <span class="literal">other</span> had you not cleared its members.)</p>&#13;
<p class="indent">Executing this move constructor is a <em>lot</em> less expensive than executing the copy constructor.</p>&#13;
<p class="indent">The move constructor is designed to <em>not</em> throw an exception, so you mark it <span class="literal">noexcept</span>. Your preference should be to use <span class="literal">noexcept</span> move constructors; often, the compiler cannot use exception-throwing move constructors and will use copy constructors instead. Compilers prefer slow, correct code instead of fast, incorrect code.</p>&#13;
<h4 class="h4" id="ch04lev2sec29"><strong><em>Move Assignment</em></strong></h4>&#13;
<p class="noindent">You can also create a move analogue to copy assignment via <span class="literal">operator=</span>. The move assignment operator takes an rvalue reference rather than a <span class="literal">const</span> lvalue reference, and you usually mark it <span class="literal">noexcept</span>. <a href="ch04.xhtml#ch04ex36">Listing 4-36</a> implements such a move assignment operator for <span class="literal">SimpleString</span>.</p>&#13;
<pre>SimpleString&amp; operator=(SimpleString&amp;&amp; other) noexcept { <span class="ent">➊</span>&#13;
  if (this == &amp;other) return *this; <span class="ent">➋</span>&#13;
  delete[] buffer; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_127"/>  buffer = other.buffer; <span class="ent">➍</span>&#13;
  length = other.length;&#13;
  max_size = other.max_size;&#13;
  other.buffer = nullptr; <span class="ent">➎</span>&#13;
  other.length = 0;&#13;
  other.max_size = 0;&#13;
  return *this;&#13;
}</pre>&#13;
<p class="listing"><a id="ch04ex36"/><em>Listing 4-36: A move assignment operator for <span class="literal">SimpleString</span></em></p>&#13;
<p class="indent">You declare the move assignment operator using the rvalue reference syntax and the <span class="literal">noexcept</span> qualifier, as with the move constructor <span class="ent">➊</span>. The self-reference check <span class="ent">➋</span> handles the move assignment of a <span class="literal">SimpleString</span> to itself. You clean up <span class="literal">buffer</span> <span class="ent">➌</span> before assigning the fields of <span class="literal">this</span> to the fields of <span class="literal">other</span> <span class="ent">➍</span> and zero out the fields of <span class="literal">other</span> <span class="ent">➎</span>. Aside from the self-reference check <span class="ent">➋</span> and the cleanup <span class="ent">➌</span>, the move assignment operator and the move constructor are functionally identical.</p>&#13;
<p class="indent">Now that <span class="literal">SimpleString</span> is movable, you can complete the <span class="literal">SimpleString</span> constructor of <span class="literal">SimpleStringOwner</span>:</p>&#13;
<pre>SimpleStringOwner(SimpleString&amp;&amp; x) : string{ std::move(x)<span class="ent">➊</span> } { }</pre>&#13;
<p class="indent">The <span class="literal">x</span> is an lvalue, so you must <span class="literal">std::move x</span> into the move constructor of <span class="literal">string</span> <span class="ent">➊</span>. You might find <span class="literal">std::move</span> odd, because <span class="literal">x</span> is an rvalue reference. Recall that lvalue/rvalue and lvalue reference/rvalue reference are distinct descriptors.</p>&#13;
<p class="indent">Consider if <span class="literal">std::move</span> weren’t required here: what if you moved from <span class="literal">x</span> and then used it inside the constructor? This could lead to bugs that are hard to diagnose. Remember that you cannot use moved-from objects except to reassign or destruct them. Doing anything else is undefined behavior.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch04ex37">Listing 4-37</a> illustrates the <span class="literal">SimpleString</span> move assignment.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  SimpleString a{ 50 };&#13;
  a.append_line("We apologize for the"); <span class="ent">➊</span>&#13;
  SimpleString b{ 50 };&#13;
  b.append_line("Last message"); <span class="ent">➋</span>&#13;
  a.print("a"); <span class="ent">➌</span>&#13;
  b.print("b"); <span class="ent">➍</span>&#13;
  b = std::move(a); <span class="ent">➎</span>&#13;
  // a is "moved-from"&#13;
  b.print("b"); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">a: We apologize for the <span class="ent">➌</span></span>&#13;
<span class="color1">b: Last message <span class="ent">➍</span></span>&#13;
<span class="color1">b: We apologize for the <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch04ex37"/><em>Listing 4-37: A program illustrating move assignment with the <span class="literal">SimpleString</span> class</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/>As in <a href="ch04.xhtml#ch04ex31">Listing 4-31</a>, you begin by declaring two <span class="literal">SimpleString</span> classes with different messages: the string <span class="literal">a</span> contains <span class="literal">We apologize for the</span> <span class="ent">➊</span>, and <span class="literal">b</span> contains <span class="literal">Last message</span> <span class="ent">➋</span>. You print these strings to verify that they contain the strings you’ve specified <span class="ent">➌➍</span>. Next, you move assign <span class="literal">b</span> equal to <span class="literal">a</span> <span class="ent">➎</span>. Note that you had to cast <span class="literal">a</span> to an <span class="literal">rvalue</span> using <span class="literal">std::move</span>. After the move assignment, <span class="literal">a</span> is in a moved-from state, and you can’t use it unless you reassign it to a new value. Now, <span class="literal">b</span> owns the message that <span class="literal">a</span> used to own, <span class="literal">We apologize for the</span> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch04lev2sec30"><strong><em>The Final Product</em></strong></h4>&#13;
<p class="noindent">You now have a fully implemented <span class="literal">SimpleString</span> that supports move and copy semantics. <a href="ch04.xhtml#ch04ex38">Listing 4-38</a> brings these all together for your reference.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;stdexcept&gt;&#13;
#include &lt;utility&gt;&#13;
&#13;
struct SimpleString {&#13;
  SimpleString(size_t max_size)&#13;
    : max_size{ max_size },&#13;
    length{} {&#13;
    if (max_size == 0) {&#13;
      throw std::runtime_error{ "Max size must be at least 1." };&#13;
    }&#13;
    buffer = new char[max_size];&#13;
    buffer[0] = 0;&#13;
  }&#13;
  ~SimpleString() {&#13;
    delete[] buffer;&#13;
  }&#13;
  SimpleString(const SimpleString&amp; other)&#13;
    : max_size{ other.max_size },&#13;
    buffer{ new char[other.max_size] },&#13;
    length{ other.length } {&#13;
    std::strncpy(buffer, other.buffer, max_size);&#13;
  }&#13;
  SimpleString(SimpleString&amp;&amp; other) noexcept&#13;
    : max_size(other.max_size),&#13;
    buffer(other.buffer),&#13;
    length(other.length) {&#13;
    other.length = 0;&#13;
    other.buffer = nullptr;&#13;
    other.max_size = 0;&#13;
  }&#13;
  SimpleString&amp; operator=(const SimpleString&amp; other) {&#13;
    if (this == &amp;other) return *this;&#13;
    const auto new_buffer = new char[other.max_size];&#13;
    delete[] buffer;&#13;
    buffer = new_buffer;&#13;
    length = other.length;&#13;
    max_size = other.max_size;&#13;
    std::strncpy(buffer, other.buffer, max_size);&#13;
<span epub:type="pagebreak" id="page_129"/>    return *this;&#13;
  }&#13;
  SimpleString&amp; operator=(SimpleString&amp;&amp; other) noexcept {&#13;
    if (this == &amp;other) return *this;&#13;
    delete[] buffer;&#13;
    buffer = other.buffer;&#13;
    length = other.length;&#13;
    max_size = other.max_size;&#13;
    other.buffer = nullptr;&#13;
    other.length = 0;&#13;
    other.max_size = 0;&#13;
    return *this;&#13;
  }&#13;
  void print(const char* tag) const {&#13;
    printf("%s: %s", tag, buffer);&#13;
  }&#13;
  bool append_line(const char* x) {&#13;
    const auto x_len = strlen(x);&#13;
    if (x_len + length + 2 &gt; max_size) return false;&#13;
    std::strncpy(buffer + length, x, max_size - length);&#13;
    length += x_len;&#13;
    buffer[length++] = '\n';&#13;
    buffer[length] = 0;&#13;
    return true;&#13;
  }&#13;
private:&#13;
  size_t max_size;&#13;
  char* buffer;&#13;
  size_t length;&#13;
};</pre>&#13;
<p class="listing"><a id="ch04ex38"/><em>Listing 4-38: A fully specified <span class="literal">SimpleString</span> class supporting copy and move semantics</em></p>&#13;
<h4 class="h4" id="ch04lev2sec31"><strong><em>Compiler-Generated Methods</em></strong></h4>&#13;
<p class="noindent">Five methods govern move and copy behavior:</p>&#13;
<ul>&#13;
<li class="noindent">The destructor</li>&#13;
<li class="noindent">The copy constructor</li>&#13;
<li class="noindent">The move constructor</li>&#13;
<li class="noindent">The copy assignment operator</li>&#13;
<li class="noindent">The move assignment operator</li>&#13;
</ul>&#13;
<p class="indent">The compiler can generate default implementations for each under certain circumstances. Unfortunately, the rules for which methods get generated are complicated and potentially uneven across compilers.</p>&#13;
<p class="indent">You can eliminate this complexity by setting these methods to <span class="literal">default</span>/<span class="literal">delete</span> or by implementing them as appropriate. This general rule is the <em>rule of five</em>, because there are five methods to specify. Being explicit costs a little time, but it saves a lot of future headaches.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>The alternative is memorizing <a href="ch04.xhtml#ch04fig08">Figure 4-8</a>, which summarizes the interactions between each of the five functions you implement and each that the compiler generates on your behalf.</p>&#13;
<div class="image"><img src="../images/fig4_8.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch04fig08"><em>Figure 4-8: A chart illustrating which methods the compiler generates when given various inputs</em></p>&#13;
<p class="indent">If you provide nothing, the compiler will generate all five destruct/copy/move functions. This is the <em>rule of zero</em>.</p>&#13;
<p class="indent">If you explicitly define any of destructor/copy constructor/copy assignment operator, you get all three. This is dangerous, as demonstrated earlier with <span class="literal">SimpleString</span>: it’s too easy to get into an unintended situation in which the compiler will essentially convert all your moves into copies.</p>&#13;
<p class="indent">Finally, if you provide only move semantics for your class, the compiler will not automatically generate anything except a destructor.</p>&#13;
<h3 class="h3" id="ch04lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">You’ve completed the exploration of the object life cycle. Your journey began in storage durations, where you saw an object lifetime from construction to destruction. Subsequent study of exception handling illustrated deft, lifetime-aware error handling and enriched your understanding of RAII. Finally, you saw how copy and move semantics grant you granular control over object lifetimes.</p>&#13;
<div class="box5" id="bm03">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_131"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>4-1.</strong> Create a <span class="literal">struct TimerClass</span>. In its constructor, record the current time in a field called <span class="literal">timestamp</span> (compare with the POSIX function <span class="literal">gettimeofday</span>).</p>&#13;
<p class="noindent"><strong>4-2.</strong> In the destructor of  TimerClass, record the current time and subtract the time at construction. This time is roughly the <em>age</em> of the timer. Print this value.</p>&#13;
<p class="noindent"><strong>4-3.</strong> Implement a copy constructor and a copy assignment operator for  TimerClass. The copies should share  timestamp values.</p>&#13;
<p class="noindent"><strong>4-4.</strong> Implement a move constructor and a move assignment operator for  TimerClass. A moved-from  TimerClass shouldn’t print any output to the console when it gets destructed.</p>&#13;
<p class="noindent"><strong>4-5.</strong> Elaborate the  TimerClass constructor to accept an additional  <span class="literal">const char* name</span> parameter. When  <span class="literal">TimerClass</span> is destructed and prints to stdout, include the name of the timer in the output.</p>&#13;
<p class="noindent"><strong>4-6.</strong> Experiment with your  TimerClass. Create a timer and move it into a function that performs some computationally intensive operation (for example, lots of math in a loop). Verify that your timer behaves as you expect.</p>&#13;
<p class="noindent"><strong>4-7.</strong> Identify each method in the  SimpleString class (<a href="ch04.xhtml#ch04ex38">Listing 4-38</a>). Try reimplementing it from scratch without referring to the book.</p>&#13;
</div>&#13;
<div class="box6" id="bm04">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Optimized C++: Proven Techniques for Heightened Performance</em> by Kurt Guntheroth (O’Reilly Media, 2016)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</em> by Scott Meyers (O’Reilly Media, 2015)</li></ul>&#13;
</div>&#13;
</body></html>