<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;CONSTANTS, VARIABLES, AND DATA TYPES"><div class="titlepage"><div><div><h1 class="title"><a id="constants_comma_variables_comma_and_data"/>Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e14596"/><img alt="CONSTANTS, VARIABLES, AND DATA TYPES" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p><a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> discussed the basic format for data in memory. <a class="xref" href="ch03.html" title="Chapter 3. MEMORY ACCESS AND ORGANIZATION">Chapter 3</a> covered how a computer system physically organizes that data in memory. This chapter finishes the discussion by connecting the concept of <span class="emphasis"><em>data representation</em></span> to its actual physical representation. As the title implies, this chapter concerns itself with three main topics: constants, variables, and data structures. This chapter does not assume that you've had a formal course in data structures, though such experience would be useful.<a class="indexterm" id="IDX-CHP-4-0001"/></p><p>This chapter discusses how to declare and use constants, scalar variables, integers, data types, pointers, arrays, records/structures, unions, and namespaces. You must master these subjects before going on to the next chapter. Declaring and accessing arrays, in particular, seems to present a multitude of problems to beginning assembly language programmers. However, the rest of this text depends on your understanding of these data structures and their memory representation. Do not try to skim over this material with the expectation that you will pick it up as you need it later. You will need it right away, and trying to learn this material along with later material will only confuse you more.</p><div class="sect1" title="4.1 Some Additional Instructions: intmul, bound, into"><div class="titlepage"><div><div><h1 class="title"><a id="some_additional_instructions_colon_intmu"/>4.1 Some Additional Instructions: intmul, bound, into</h1></div></div></div><p>This chapter introduces arrays and other concepts that will require the expansion of your 80x86 instruction set knowledge. In particular, you will need to learn how to multiply two values; hence the first instruction we will look at is the <code class="literal">intmul</code> (integer multiply) instruction. Another common task when accessing arrays is to check to see if an array index is within bounds. The 80x86 <code class="literal">bound</code> instruction provides a convenient way to check a register's value to see if it is within some range. Finally, the <code class="literal">into</code> (interrupt on overflow) instruction provides a quick check for signed arithmetic overflow. Although <code class="literal">into</code> isn't really necessary for array (or other data type) access, its function is very similar to <code class="literal">bound</code>; hence the presentation of it at this point.<a class="indexterm" id="IDX-CHP-4-0002"/><a class="indexterm" id="IDX-CHP-4-0003"/><a class="indexterm" id="IDX-CHP-4-0004"/><a class="indexterm" id="IDX-CHP-4-0005"/><a class="indexterm" id="IDX-CHP-4-0006"/><a class="indexterm" id="IDX-CHP-4-0007"/><a class="indexterm" id="IDX-CHP-4-0008"/><a class="indexterm" id="IDX-CHP-4-0009"/><a class="indexterm" id="IDX-CHP-4-0010"/><a class="indexterm" id="IDX-CHP-4-0011"/><a class="indexterm" id="IDX-CHP-4-0012"/></p><p>The <code class="literal">intmul</code> instruction takes one of the following forms:</p><a id="I_programlisting4_d1e14685"/><pre class="programlisting">// The following compute <em class="replaceable"><code>destreg</code></em> = <em class="replaceable"><code>destreg</code></em> * <em class="replaceable"><code>constant</code></em>

          intmul( <em class="replaceable"><code>constant, destreg16</code></em> );
          intmul( <em class="replaceable"><code>constant, destreg32</code></em> );

          // The following compute <em class="replaceable"><code>dest</code></em> = <em class="replaceable"><code>src</code></em> * <em class="replaceable"><code>constant</code></em>

          intmul( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>srcreg16</code></em>, <em class="replaceable"><code>destreg16</code></em> );
          intmul( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>srcmem16</code></em>, <em class="replaceable"><code>destreg16</code></em> );

          intmul( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>srcreg32</code></em>, <em class="replaceable"><code>destreg32</code></em> );
          intmul( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>srcmem32</code></em>, <em class="replaceable"><code>destreg32</code></em> );

          // The following compute <em class="replaceable"><code>dest</code></em> = <em class="replaceable"><code>src</code></em> * <em class="replaceable"><code>constant</code></em>

          intmul( <em class="replaceable"><code>srcreg16</code></em>, <em class="replaceable"><code>destreg16</code></em> );
          intmul( <em class="replaceable"><code>srcmem16</code></em>, <em class="replaceable"><code>destreg16</code></em> );
          intmul( <em class="replaceable"><code>srcreg32</code></em>, <em class="replaceable"><code>destreg32</code></em> );
          intmul( <em class="replaceable"><code>srcmem32</code></em>, <em class="replaceable"><code>destreg32</code></em> );</pre><p>Note that the syntax of the <code class="literal">intmul</code> instruction is different from that of the <code class="literal">add</code> and <code class="literal">sub</code> instructions. In particular, the destination operand must be a register (<code class="literal">add</code> and <code class="literal">sub</code> both allow a memory operand as a destination). Also note that <code class="literal">intmul</code> allows three operands when the first operand is a constant. Another important difference is that the <code class="literal">intmul</code> instruction allows only 16-bit and 32-bit operands; it does not multiply 8-bit operands.</p><p>intmul computes the product of its specified operands and stores the result into the destination register. If an overflow occurs (which is always a signed overflow, because <code class="literal">intmul</code> multiplies only signed integer values), then this instruction sets both the carry and overflow flags. <code class="literal">intmul</code> leaves the other condition code flags undefined (so, for example, you cannot meaningfully check the sign flag or the zero flag after executing <code class="literal">intmul</code>).<a class="indexterm" id="IDX-CHP-4-0013"/></p><p>The <code class="literal">bound</code> instruction checks a 16-bit or 32-bit register to see if it is between two values. If the value is outside this range, the program raises an exception and aborts. This instruction is particularly useful for checking to see if an array index is within a given range. The <code class="literal">bound</code> instruction takes one of the following forms:</p><a id="I_programlisting4_d1e14831"/><pre class="programlisting">bound( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>LBconstant</code></em>, <em class="replaceable"><code>UBconstant</code></em> );
bound( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>LBconstant</code></em>, <em class="replaceable"><code>UBconstant</code></em> );

bound( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>Mem16</code></em>[2] );
bound( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>Mem32</code></em>[2] );</pre><p>The <code class="literal">bound</code> instruction compares its register operand against an unsigned lower bound value and an unsigned upper bound value to ensure that the register is in the range:</p><a id="I_programlisting4_d1e14869"/><pre class="programlisting"><em class="replaceable"><code>lower_bound</code></em> &lt;= <em class="replaceable"><code>register</code></em> &lt;= <em class="replaceable"><code>upper_bound</code></em></pre><p>The form of the <code class="literal">bound</code> instruction with three operands compares the register against the second and third parameters (the lower bound and upper bound, respectively).<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">47</a>]</sup> The <code class="literal">bound</code> instruction with two operands checks the register against one of the following ranges:<a class="indexterm" id="IDX-CHP-4-0014"/></p><a id="I_programlisting4_d1e14897"/><pre class="programlisting"><em class="replaceable"><code>Mem16</code></em>[0] &lt;= <em class="replaceable"><code>register16</code></em> &lt;= <em class="replaceable"><code>Mem16</code></em>[2]
<em class="replaceable"><code>Mem32</code></em>[0] &lt;= <em class="replaceable"><code>register32</code></em> &lt;= <em class="replaceable"><code>Mem32</code></em>[4]</pre><p>If the specified register is not within the given range, then the 80x86 raises an exception. You can trap this exception using the HLA <code class="literal">try..endtry</code> exception-handling statement. The <span class="emphasis"><em>excepts.hhf</em></span> header file defines an exception, <code class="literal">ex.BoundInstr</code>, specifically for this purpose. The program in <a class="xref" href="ch04.html#demonstration_of_the_bound_instruction" title="Example 4-1. Demonstration of the bound instruction">Example 4-1</a> demonstrates how to use the <code class="literal">bound</code> instruction to check some user input.<a class="indexterm" id="IDX-CHP-4-0015"/></p><div class="example"><a id="demonstration_of_the_bound_instruction"/><p class="title">Example 4-1. Demonstration of the <code class="literal">bound</code> instruction</p><div class="example-contents"><pre class="programlisting">program BoundDemo;
#include( "stdlib.hhf" );

static
    InputValue:int32;
    GoodInput:boolean;

begin BoundDemo;

    // Repeat until the user enters a good value:

    repeat

        // Assume the user enters a bad value.

        mov( false, GoodInput );

        // Catch bad numeric input via the try..endtry statement.

        try

            stdout.put( "Enter an integer between 1 and 10: " );
            stdin.flushInput();
            stdin.geti32();

            mov( eax, InputValue );

            // Use the BOUND instruction to verify that the
            // value is in the range 1..10.

            bound( eax, 1, 10 );

            // If we get to this point, the value was in the
            // range 1..10, so set the boolean GoodInput
            // flag to true so we can exit the loop.

            mov( true, GoodInput );


            // Handle inputs that are not legal integers.

          exception( ex.ConversionError )

            stdout.put( "Illegal numeric format, re-enter", nl );


            // Handle integer inputs that don't fit into an int32.

          exception( ex.ValueOutOfRange )

            stdout.put( "Value is *way* too big, re-enter", nl );


            // Handle values outside the range 1..10 (BOUND instruction).


          exception( ex.BoundInstr )

            stdout.put
            (
                "Value was ",
                InputValue,
                ", it must be between 1 and 10, re-enter",
                nl
            );


        endtry;

    until( GoodInput );
    stdout.put( "The value you entered, ", InputValue, " is valid.", nl );

end BoundDemo;</pre></div></div><p>The <code class="literal">into</code> instruction, like <code class="literal">bound</code>, also generates an exception under certain conditions. Specifically, <code class="literal">into</code> generates an exception if the overflow flag is set. Normally, you would use <code class="literal">into</code> immediately after a signed arithmetic operation (e.g., <code class="literal">intmul</code>) to see if an overflow occurs. If the overflow flag is not set, the system ignores <code class="literal">into</code>; however, if the overflow flag is set, then the <code class="literal">into</code> instruction raises the <code class="literal">ex.IntoInstr</code> exception. The program in <a class="xref" href="ch04.html#demonstration_of_the_into_instruction" title="Example 4-2. Demonstration of the into instruction">Example 4-2</a> demonstrates the use of the <code class="literal">into</code> instruction.<a class="indexterm" id="IDX-CHP-4-0016"/><a class="indexterm" id="IDX-CHP-4-0017"/><a class="indexterm" id="IDX-CHP-4-0018"/><a class="indexterm" id="IDX-CHP-4-0019"/><a class="indexterm" id="IDX-CHP-4-0020"/><a class="indexterm" id="IDX-CHP-4-0021"/></p><div class="example"><a id="demonstration_of_the_into_instruction"/><p class="title">Example 4-2. Demonstration of the <code class="literal">into</code> instruction</p><div class="example-contents"><pre class="programlisting">program INTOdemo;
#include( "stdlib.hhf" );

static
    LOperand:int8;
    ResultOp:int8;

begin INTOdemo;

    // The following try..endtry checks for bad numeric
    // input and handles the integer overflow check:

    try

        // Get the first of two operands:

        stdout.put( "Enter a small integer value (-128..+127):" );
        stdin.geti8();
        mov( al, LOperand );

        // Get the second operand:

        stdout.put( "Enter a second small integer value (-128..+127):" );
        stdin.geti8();

        // Produce their sum and check for overflow:

        add( LOperand, al );
        into();

        // Display the sum:

        stdout.put( "The eight-bit sum is ", (type int8 al), nl );


        // Handle bad input here:

      exception( ex.ConversionError )

        stdout.put( "You entered illegal characters in the number", nl );


        // Handle values that don't fit in a byte here:

      exception( ex.ValueOutOfRange )

        stdout.put( "The value must be in the range −128..+127", nl );


        // Handle integer overflow here:


      exception( ex.IntoInstr )

        stdout.put
        (
            "The sum of the two values is outside the range −128..+127",
            nl
        );


    endtry;

end INTOdemo;</pre></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">47</a>] </sup>This form isn't a true 80x86 instruction. HLA converts this form of the bound instruction to the two-operand form by creating two <code class="literal">readonly</code> memory variables initialized with the specified constants.</p></div></div></div>
<div class="sect1" title="4.2 HLA Constant and Value Declarations"><div class="titlepage"><div><div><h1 class="title"><a id="hla_constant_and_value_declarations"/>4.2 HLA Constant and Value Declarations</h1></div></div></div><p>HLA's <code class="literal">const</code> and <code class="literal">val</code> sections let you declare symbolic constants. The <code class="literal">const</code> section lets you declare identifiers whose value is constant throughout compilation and runtime; the <code class="literal">val</code> section lets you declare symbolic constants whose values can change at compile time but whose values are constant at runtime (that is, the same name can have a different value at several points in the source code, but the value of a <code class="literal">val</code> symbol at a given point in the program cannot change while the program is running).<a class="indexterm" id="IDX-CHP-4-0022"/><a class="indexterm" id="IDX-CHP-4-0023"/><a class="indexterm" id="IDX-CHP-4-0024"/><a class="indexterm" id="IDX-CHP-4-0025"/></p><p>The <code class="literal">const</code> section appears in the same area of your program as the <code class="literal">static</code>, <code class="literal">readonly</code>, <code class="literal">storage</code>, and <code class="literal">var</code> sections. It begins with the <code class="literal">const</code> reserved word and has a syntax that is nearly identical to the <code class="literal">readonly</code> section; that is, the <code class="literal">const</code> section contains a list of identifiers followed by a type and a constant expression. The following example will give you an idea of what the <code class="literal">const</code> section looks like:</p><a id="I_programlisting4_d1e15078"/><pre class="programlisting">const
     pi:                   real32  := 3.14159;
     MaxIndex:             uns32   := 15;
     Delimiter:            char    := '/';
     BitMask:              byte    := $F0;
     DebugActive:          boolean := true;</pre><p>Once you declare these constants in this manner, you may use the symbolic identifiers anywhere the corresponding literal constant is legal. These constants are known as manifest constants. A <span class="emphasis"><em>manifest constant</em></span> is a symbolic representation of a constant that allows you to substitute the literal value for the symbol anywhere in the program. Contrast this with <code class="literal">readonly</code> variables; a <code class="literal">readonly</code> variable is certainly a constant value because you cannot change such values at runtime. However, there is a memory location associated with <code class="literal">readonly</code> variables, and the operating system, not the HLA compiler, enforces the read-only attribute. Although it will certainly crash your program when it runs, it is perfectly legal to write an instruction like <code class="literal">mov( eax, ReadOnlyVar );</code>. On the other hand, it is no more legal to write <code class="literal">mov( eax, MaxIndex );</code> (using the declaration above) than it is to write <code class="literal">mov( eax, 15 );</code>. In fact, both of these statements are equivalent because the compiler substitutes <code class="literal">15</code> for <code class="literal">MaxIndex</code> whenever it encounters this manifest constant.<a class="indexterm" id="IDX-CHP-4-0026"/><a class="indexterm" id="IDX-CHP-4-0027"/></p><p>If there is absolutely no ambiguity about a constant's type, then you may declare a constant by specifying only the name and the constant's value, omitting the type specification. In the example earlier, the <code class="literal">pi</code>, <code class="literal">Delimiter</code>, <code class="literal">MaxIndex</code>, and <code class="literal">DebugActive</code> constants could use the following declarations:</p><a id="I_programlisting4_d1e15132"/><pre class="programlisting">const
     pi               := 3.14159;     // Default type is real80.
     MaxIndex         := 15;          // Default type is uns32.
     Delimiter        := '/';         // Default type is char.
     DebugActive      := true;        // Default type is boolean.</pre><p>Symbol constants that have an integer literal constant are always given the smallest possible unsigned type if the constant is zero or positive, or the smallest possible integer type (<code class="literal">int8</code>, <code class="literal">int16</code>, and so on) if the value is negative.</p><p>Constant declarations are great for defining "magic" numbers that might possibly change during program modification. The program in <a class="xref" href="ch04s02.html#data_alignment_program_rewritten_using_c" title="Example 4-3. Data alignment program rewritten using const definitions">Example 4-3</a> provides an example of using constants to parameterize "magic" values in the program. In this particular case, the program defines manifest constants for the amount of memory to allocate for the test, the (mis)alignment, and the number of loop and data repetitions. This program demonstrates the performance reduction that occurs on misaligned data accesses. Adjust the <code class="literal">MainRepetitions</code> constant if the program is too fast or too slow.</p><div class="example"><a id="data_alignment_program_rewritten_using_c"/><p class="title">Example 4-3. Data alignment program rewritten using <code class="literal">const</code> definitions</p><div class="example-contents"><pre class="programlisting">program ConstDemo;
#include( "stdlib.hhf" );

const
    MemToAllocate   := 4_000_000;
    NumDWords       := MemToAllocate div 4;
    MisalignBy      := 62;

    MainRepetitions := 10000;
    DataRepetitions := 999_900;

    CacheLineSize   := 16;

begin ConstDemo;

    //console.cls();
    stdout.put
    (
        "Memory Alignment Exercise",nl,
        nl,
        "Using a watch (preferably a stopwatch), time the execution of", nl
        "the following code to determine how many seconds it takes to", nl
        "execute.", nl
        nl
        "Press Enter to begin timing the code:"
    );


    // Allocate enough dynamic memory to ensure that it does not
    // all fit inside the cache. Note: The machine had better have
    // at least 4 megabytes mem.free or virtual memory will kick in
    // and invalidate the timing.

    mem.alloc( MemToAllocate );

    // Zero out the memory (this loop really exists just to
    // ensure that all memory is mapped in by the OS).

    mov( NumDWords, ecx );
    repeat

        dec( ecx );
        mov( 0, (type dword [eax+ecx*4]));

    until( !ecx );  // Repeat until ecx = 0.


    // Okay, wait for the user to press the Enter key.

    stdin.readLn();

    // Note: As processors get faster and faster, you may
    // want to increase the size of the following constant.
    // Execution time for this loop should be approximately
    // 10-30 seconds.

    mov( MainRepetitions, edx );
    add( MisalignBy, eax );     // Force misalignment of data.

    repeat

        mov( DataRepetitions, ecx );
        align( CacheLineSize );
        repeat

            sub( 4, ecx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );

        until( !ecx );
        dec( edx );

    until( !edx ); // Repeat until eax is zero.

    stdout.put( stdio.bell, "Stop timing and record time spent", nl, nl );


    // Okay, time the aligned access.

    stdout.put
    (
        "Press Enter again to begin timing access to aligned variable:"
    );
    stdin.readLn();

    // Note: If you change the constant above, be sure to change
    // this one, too!

    mov( MainRepetitions, edx );
    sub( MisalignBy, eax );     // Realign the data.
    repeat

        mov( DataRepetitions, ecx );
        align( CacheLineSize );
        repeat

            sub( 4, ecx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );
            mov( [eax+ecx*4], ebx );

        until( !ecx );
        dec( edx );

    until( !edx ); // Repeat until eax is zero.

    stdout.put( stdio.bell, "Stop timing and record time spent", nl, nl );
    mem.free( eax );


end ConstDemo;</pre></div></div><div class="sect2" title="4.2.1 Constant Types"><div class="titlepage"><div><div><h2 class="title"><a id="constant_types"/>4.2.1 Constant Types</h2></div></div></div><p>Manifest constants can be any of the HLA primitive types plus a few of the composite types this chapter discusses. <a class="xref" href="ch01.html" title="Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE">Chapter 1</a>, <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a>, and <a class="xref" href="ch03.html" title="Chapter 3. MEMORY ACCESS AND ORGANIZATION">Chapter 3</a> discussed most of the primitive types; the primitive types include the following:<sup>[<a class="footnote" href="#ftn.CHP-4-FN-2" id="CHP-4-FN-2">48</a>]</sup><a class="indexterm" id="IDX-CHP-4-0028"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">boolean</code> constants (true or false)</p></li><li class="listitem"><p><code class="literal">uns8</code> constants (0..255)</p></li><li class="listitem"><p><code class="literal">uns16</code> constants (0..65,535)</p></li><li class="listitem"><p><code class="literal">uns32</code> constants (0..4,294,967,295)</p></li><li class="listitem"><p><code class="literal">int8</code> constants (−128..+127)</p></li><li class="listitem"><p><code class="literal">int16</code> constants (−32,768..+32,767)</p></li><li class="listitem"><p><code class="literal">int32</code> constants (−2,147,483,648..+2,147,483,647)</p></li><li class="listitem"><p><code class="literal">char</code> constants (any ASCII character with a character code in the range 0..255)</p></li><li class="listitem"><p><code class="literal">byte</code> constants (any 8-bit value including integers, booleans, and characters)</p></li><li class="listitem"><p><code class="literal">word</code> constants (any 16-bit value)</p></li><li class="listitem"><p><code class="literal">dword</code> constants (any 32-bit value)</p></li><li class="listitem"><p><code class="literal">real32</code> constants (floating-point values)</p></li><li class="listitem"><p><code class="literal">real64</code> constants (floating-point values)</p></li><li class="listitem"><p><code class="literal">real80</code> constants (floating-point values)</p></li></ul></div><p>In addition to the constant types appearing above, the <code class="literal">const</code> section supports six additional constant types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">string</code> constants</p></li><li class="listitem"><p><code class="literal">text</code> constants</p></li><li class="listitem"><p>Enumerated constant values</p></li><li class="listitem"><p>Array constants</p></li><li class="listitem"><p>Record/Union constants</p></li><li class="listitem"><p>Character set constants</p></li></ul></div><p>These data types are the subject of this chapter, and the discussion of most of them appears a little later. However, the string and text constants are sufficiently important to warrant an early discussion of these constant types.</p></div><div class="sect2" title="4.2.2 String and Character Literal Constants"><div class="titlepage"><div><div><h2 class="title"><a id="string_and_character_literal_constants"/>4.2.2 String and Character Literal Constants</h2></div></div></div><p>HLA, like most programming languages, draws a distinction between a sequence of characters, a <span class="emphasis"><em>string</em></span>, and a single character. This distinction is present both in the type declarations and in the syntax for literal character and string constants. Until now, this text has not drawn a fine distinction between character and string literal constants; now is the time to do so.<a class="indexterm" id="IDX-CHP-4-0029"/><a class="indexterm" id="IDX-CHP-4-0030"/><a class="indexterm" id="IDX-CHP-4-0031"/><a class="indexterm" id="IDX-CHP-4-0032"/></p><p>String literal constants consist of a sequence of zero or more characters surrounded by ASCII quote characters. The following are examples of legal literal string constants:</p><a id="I_programlisting4_d1e15307"/><pre class="programlisting">"This is a string"          // String with 16 characters.
     ""                          // Zero length string.
     "a"                         // String with a single character.
     "123"                       // String of length 3.</pre><p>A string of length 1 is not the same thing as a character constant. HLA uses two completely different internal representations for character and string values. Hence, <code class="literal">"a"</code> is not a character; it is a string that just happens to contain a single character.</p><p>Character literal constants take a couple forms, but the most common form consists of a single character surrounded by ASCII apostrophe characters:</p><a id="I_programlisting4_d1e15316"/><pre class="programlisting">'2'               // Character constant equivalent to ASCII code $32.
     'a'               // Character constant for lowercase 'A'.</pre><p>As this section notes earlier, <code class="literal">"a"</code> and <code class="literal">'a'</code> are not equivalent.</p><p>Those who are familiar with C, C++, or Java probably recognize these literal constant forms, because they are similar to the character and string constants in C/C++/Java. In fact, this text has made a tacit assumption to this point that you are somewhat familiar with C/C++ insofar as examples appearing up to this point use character and string constants without an explicit definition of them.</p><p>Another similarity between C/C++ strings and HLA's is the automatic concatenation of adjacent literal string constants within your program. For example, HLA concatenates the two string constants<a class="indexterm" id="IDX-CHP-4-0033"/></p><a id="I_programlisting4_d1e15335"/><pre class="programlisting">"First part of string, "    "second part of string"</pre><p>to form the single-string constant</p><a id="I_programlisting4_d1e15340"/><pre class="programlisting">"First part of string, second part of string"</pre><p>Beyond these few similarities, however, HLA strings and C/C++ strings differ. For example, C/C++ strings let you specify special character values using the escape character sequence consisting of a backslash character followed by one or more special characters; HLA does not use this escape character mechanism. HLA does provide, however, several other ways to insert special characters into a string or character constant.<a class="indexterm" id="IDX-CHP-4-0034"/></p><p>Because HLA does not allow escape character sequences in literal string and character constants, the first question you might ask is, "How does one embed quote characters in string constants and apostrophe characters in character constants?" To solve this problem, HLA uses the same technique as Pascal and many other languages: You insert two quotes in a string constant to represent a single quote, or you place two apostrophes in a character constant to represent a single apostrophe character. For example:<a class="indexterm" id="IDX-CHP-4-0035"/></p><a id="I_programlisting4_d1e15352"/><pre class="programlisting">"He wrote a "" Hello World"" program as an example."</pre><p>The above is equivalent to:</p><a id="I_programlisting4_d1e15356"/><pre class="programlisting">He wrote a "Hello World" program as an example.</pre><p>As <a class="xref" href="ch01.html" title="Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE">Chapter 1</a> pointed out, to create a single apostrophe character constant, you place two adjacent apostrophes within a pair of apostrophes:</p><a id="I_programlisting4_d1e15362"/><pre class="programlisting">''''</pre><p>HLA provides a couple of other features that eliminate the need for escape characters. In addition to concatenating two adjacent string constants to form a longer string constant, HLA will also concatenate any combination of adjacent character and string constants to form a single string constant:</p><a id="I_programlisting4_d1e15366"/><pre class="programlisting">'1'  '2'  '3'                // Equivalent to "123"
          "He wrote a "  '"' "Hello World"  '"' " program as an example."</pre><p>Note that the two <span class="emphasis"><em>He wrote</em></span> strings in the previous examples are identical in HLA.</p><p>HLA provides a second way to specify character constants that handles all the other C/C++ escape character sequences: the ASCII code literal character constant. This literal character constant form uses the syntax:</p><a id="I_programlisting4_d1e15376"/><pre class="programlisting">#integer_constant</pre><p>This form creates a character constant whose value is the ASCII code specified by <code class="literal">integer_constant</code>. The numeric constant can be a decimal, hexadecimal, or binary value. For example:</p><a id="I_programlisting4_d1e15383"/><pre class="programlisting">#13          #$d          #%1101    // All three are the same
                                              // character, a carriage return.</pre><p>Because you may concatenate character literals with strings, and the <code class="literal">#constant</code> form is a character literal, the following are all legal strings:<a class="indexterm" id="IDX-CHP-4-0036"/><a class="indexterm" id="IDX-CHP-4-0037"/><a class="indexterm" id="IDX-CHP-4-0038"/><a class="indexterm" id="IDX-CHP-4-0039"/><a class="indexterm" id="IDX-CHP-4-0040"/></p><a id="I_programlisting4_d1e15413"/><pre class="programlisting">"Hello World" #13 #10       // #13 #10 is the Windows newline sequence
                                 // (carriage return followed by line feed).

     "Error: Bad Value" #7       // #7 is the bell character.
     "He wrote a " #$22 "Hello World" #$22 " program as an example."</pre><p>Because $22 is the ASCII code for the quote character, this last example is yet a third form of the <span class="emphasis"><em>He wrote</em></span> string literal.</p></div><div class="sect2" title="4.2.3 String and Text Constants in the const Section"><div class="titlepage"><div><div><h2 class="title"><a id="string_and_text_constants_in_the_const_s"/>4.2.3 String and Text Constants in the const Section</h2></div></div></div><p>String and text constants in the <code class="literal">const</code> section use the following declaration syntax:<a class="indexterm" id="IDX-CHP-4-0041"/></p><a id="I_programlisting4_d1e15431"/><pre class="programlisting">const
     AStringConst:     string := "123";
     ATextConst:       text   := "123";</pre><p>Other than the data type of these two constants, their declarations are identical. However, their behavior in an HLA program is quite different.</p><p>Whenever HLA encounters a symbolic string constant within your program, it substitutes the string literal constant in place of the string name. So a statement like <code class="literal">stdout.put( AStringConst );</code> prints the string <code class="literal">123</code> to the display. No real surprise here.</p><p>Whenever HLA encounters a symbolic text constant within your program, it substitutes the text of that string (rather than the string literal constant) for the identifier. That is, HLA substitutes the characters between the delimiting quotes in place of the symbolic text constant. Therefore, the following statement is perfectly legal given the declarations above:</p><a id="I_programlisting4_d1e15445"/><pre class="programlisting">mov( ATextConst, al );            // Equivalent to mov( 123, al );</pre><p>Note that substituting <code class="literal">AStringConst</code> for <code class="literal">ATextConst</code> in this example is illegal:</p><a id="I_programlisting4_d1e15455"/><pre class="programlisting">mov( AStringConst, al );          // Equivalent to mov( "123", al );</pre><p>This latter example is illegal because you cannot move a string literal constant into the AL register.</p><p>Whenever HLA encounters a symbolic text constant in your program, it immediately substitutes the value of the text constant's string for that text constant and continues the compilation as though you had written the text constant's value rather than the symbolic identifier in your program. This can save some typing and help make your programs a little more readable if you often enter some sequence of text in your program. For example, consider the <code class="literal">nl</code> (newline) text constant declaration found in the HLA <span class="emphasis"><em>stdio.hhf</em></span> library header file:<a class="indexterm" id="IDX-CHP-4-0042"/><a class="indexterm" id="IDX-CHP-4-0043"/></p><a id="I_programlisting4_d1e15476"/><pre class="programlisting">const
     nl: text := "#$d #$a";    // Windows version.

const
    nl:  text := " """" #$a";  // Linux, FreeBSD, and Mac OS X version.</pre><p>Whenever HLA encounters the symbol <code class="literal">nl</code>, it immediately substitutes the value of the string "<code class="literal">#$d #$a</code>" for the <code class="literal">nl</code> identifier. When HLA sees the <code class="literal">#$d</code> (carriage return) character constant followed by the <code class="literal">#$a</code> (line feed) character constants, it concatenates the two to form the string containing the Windows newline sequence (a carriage return followed by a line feed). Consider the following two statements:</p><a id="I_programlisting4_d1e15495"/><pre class="programlisting">stdout.put( "Hello World", nl );
          stdout.put( "Hello World"  nl );</pre><p>(Notice that the second statement above does not separate the string literal and the <code class="literal">nl</code> symbol with a comma.) In the first example, HLA emits code that prints the string <code class="literal">Hello World</code> and then emits some additional code that prints a newline sequence. In the second example, HLA expands the <code class="literal">nl</code> symbol as follows:</p><a id="I_programlisting4_d1e15508"/><pre class="programlisting">stdout.put( "Hello World" #$d #$a );</pre><p>Now HLA sees a string literal constant (<code class="literal">Hello World</code>) followed by two character constants. It concatenates the three of them together to form a single string and then prints this string with a single call. Therefore, leaving off the comma between the string literal and the <code class="literal">nl</code> symbol produces slightly more efficient code. Keep in mind that this works only with string literal constants. You cannot concatenate string variables, or a string variable with a string literal, by using this technique.</p><p>Linux, FreeBSD, and Mac OS X users should note that the Unix end-of-line sequence is just a single line-feed character. Therefore, the declaration for <code class="literal">nl</code> is slightly different in those operating systems (to always guarantee that <code class="literal">nl</code> expands to a string constant rather than a character constant).</p><p>In the constant section, if you specify only a constant identifier and a string constant (that is, you do not supply a type), HLA defaults to type <code class="literal">string</code>. If you want to declare a <code class="literal">text</code> constant, you must explicitly supply the type.</p><a id="I_programlisting4_d1e15534"/><pre class="programlisting">const
     AStrConst := "String Constant";
     ATextConst: text := "mov( 0, eax );";</pre></div><div class="sect2" title="4.2.4 Constant Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="constant_expressions"/>4.2.4 Constant Expressions</h2></div></div></div><p>Thus far, this chapter has given the impression that a symbolic constant definition consists of an identifier, an optional type, and a literal constant. Actually, HLA constant declarations can be a lot more sophisticated than this because HLA allows the assignment of a constant expression, not just a literal constant, to a symbolic constant. The generic constant declaration takes one of the following two forms:<a class="indexterm" id="IDX-CHP-4-0044"/><a class="indexterm" id="IDX-CHP-4-0045"/><a class="indexterm" id="IDX-CHP-4-0046"/><a class="indexterm" id="IDX-CHP-4-0047"/></p><a id="I_programlisting4_d1e15555"/><pre class="programlisting"><em class="replaceable"><code>Identifier</code></em> : <em class="replaceable"><code>typeName</code></em> := <em class="replaceable"><code>constant_expression</code></em> ;
          <em class="replaceable"><code>Identifier</code></em> := <em class="replaceable"><code>constant_expression</code></em> ;</pre><p>Constant expressions take the familiar form you're used to in high-level languages like C/C++ and Pascal. They may contain literal constant values, previously declared symbolic constants, and various arithmetic operators. <a class="xref" href="ch04s02.html#operations_allowed_in_constant_expressio" title="Table 4-1. Operations Allowed in Constant Expressions">Table 4-1</a> lists some of the operations possible in a constant expression.<a class="indexterm" id="IDX-CHP-4-0048"/></p><p>The constant expression operators follow standard precedence rules; you may use the parentheses to override the precedence if necessary. See the HLA reference at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://artofasm.com/">http://artofasm.com/</a> for the exact precedence relationships. In general, if the precedence isn't obvious, use parentheses to exactly state the order of evaluation. HLA actually provides a few more operators than these, though the ones above are the ones you will most commonly use; the HLA documentation provides a complete list of constant expression operators.</p><div class="table"><a id="operations_allowed_in_constant_expressio"/><p class="title">Table 4-1. Operations Allowed in Constant Expressions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operations Allowed in Constant Expressions"><colgroup><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>Arithmetic Operators</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">−</code> (unary negation)</p></td><td style="text-align: left" valign="top"><p>Negates the expression immediately following <code class="literal">"-"</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>Multiplies the integer or real values around the asterisk.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">div</code></p></td><td style="text-align: left" valign="top"><p>Divides the left integer operand by the right integer operand, producing an integer (truncated) result.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mod</code></p></td><td style="text-align: left" valign="top"><p>Divides the left integer operand by the right integer operand, producing an integer remainder.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">/</code></p></td><td style="text-align: left" valign="top"><p>Divides the left numeric operand by the second numeric operand, producing a floating point result.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>Adds the left and right numeric operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">−</code></p></td><td style="text-align: left" valign="top"><p>Subtracts the right numeric operand from the left numeric operand.</p></td></tr></tbody></table><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operations Allowed in Constant Expressions"><colgroup><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>Comparison Operators</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">=</code>, <code class="literal">==</code></p></td><td style="text-align: left" valign="top"><p>Compares left operand with right operand. Returns true if equal.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&gt;</code>, <code class="literal">!=</code></p></td><td style="text-align: left" valign="top"><p>Compares left operand with right operand. Returns true if not equal.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td><td style="text-align: left" valign="top"><p>Returns true if left operand is less than right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code></p></td><td style="text-align: left" valign="top"><p>Returns true if left operand is &lt;= right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td><td style="text-align: left" valign="top"><p>Returns true if left operand is greater than right operand.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td><td style="text-align: left" valign="top"><p>Returns true if left operand is &gt;= right operand.</p></td></tr></tbody></table><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operations Allowed in Constant Expressions"><colgroup><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>Logical Operators<sup>[<a class="footnote" href="#ftn.CHP-4-TFN-1" id="CHP-4-TFN-1">a</a>]</sup><a class="indexterm" id="IDX-CHP-4-0049"/><a class="indexterm" id="IDX-CHP-4-0050"/><a class="indexterm" id="IDX-CHP-4-0051"/><a class="indexterm" id="IDX-CHP-4-0052"/><a class="indexterm" id="IDX-CHP-4-0053"/></p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">&amp;</code></p></td><td style="text-align: left" valign="top"><p>For boolean operands, returns the logical <code class="literal">and</code> of the two operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">|</code></p></td><td style="text-align: left" valign="top"><p>For boolean operands, returns the logical <code class="literal">or</code> of the two operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>For boolean operands, returns the logical exclusive-or.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">!</code></p></td><td style="text-align: left" valign="top"><p>Returns the logical not of the single operand following <code class="literal">"!"</code>.</p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-TFN-1" id="ftn.CHP-4-TFN-1">a</a>] </sup>Note to C/C++ and Java users: HLA's constant expressions use complete boolean evaluation rather than short-circuit boolean evaluation. Hence, HLA constant expressions do not behave identically to C/C++/Java expressions.</p></div></td></tr></tbody></table><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operations Allowed in Constant Expressions"><colgroup><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>Bitwise Logical Operators</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">&amp;</code></p></td><td style="text-align: left" valign="top"><p>For integer numeric operands, returns bitwise <code class="literal">and</code> of the operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">|</code></p></td><td style="text-align: left" valign="top"><p>For integer numeric operands, returns bitwise <code class="literal">or</code> of the operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>For integer numeric operands, returns bitwise <code class="literal">xor</code> of the operands.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">!</code></p></td><td style="text-align: left" valign="top"><p>For an integer numeric operand, returns bitwise <code class="literal">not</code> of the operand.</p></td></tr></tbody></table><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Operations Allowed in Constant Expressions"><colgroup><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>String Operators</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">'+'</code></p></td><td style="text-align: left" valign="top"><p>Returns the concatenation of the left and right string operands.</p></td></tr></tbody></table></div></div><p>If an identifier appears in a constant expression, that identifier must be a constant identifier that you have previously defined in your program in a const or <code class="literal">val</code> section. You may not use variable identifiers in a constant expression; their values are not defined at compile time when HLA evaluates the constant expression. Also, don't confuse compile-time and runtime operations:</p><a id="I_programlisting4_d1e15870"/><pre class="programlisting">// Constant expression, computed while HLA is compiling your program:

const
          x          := 5;
          y          := 6;
          Sum        := x + y;


// Runtime calculation, computed while your program is running, long after
// HLA has compiled it:

     mov( x, al );
     add( y, al );</pre><p>HLA directly interprets the value of a constant expression during compilation. It does not emit any machine instructions to compute <code class="literal">x + y</code> in the constant expression above. Instead, it directly computes the sum of these two constant values. From that point forward in the program, HLA associates the value 11 with the constant <code class="literal">Sum</code> just as if the program had contained the statement <code class="literal">Sum := 11;</code> rather than <code class="literal">Sum := x + y;</code>. On the other hand, HLA does not precompute the value 11 in AL for the <code class="literal">mov</code> and <code class="literal">add</code> instructions above; it faithfully emits the object code for these two instructions and the 80x86 computes their sum when the program is run (sometime after the compilation is complete).<a class="indexterm" id="IDX-CHP-4-0054"/></p><p>In general, constant expressions don't get very sophisticated in assembly language programs. Usually, you're adding, subtracting, or multiplying two integer values. For example, the following <code class="literal">const</code> section defines a set of constants that have consecutive values:</p><a id="I_programlisting4_d1e15903"/><pre class="programlisting">const
     TapeDAT               :=     0;
     Tape8mm               :=     TapeDAT + 1;
     TapeQIC80             :=     Tape8mm + 1;
     TapeTravan            :=     TapeQIC80 + 1;
     TapeDLT               :=     TapeTravan + 1;</pre><p>The constants above have the following values: <code class="literal">TapeDAT=0</code>, <code class="literal">Tape8mm=1</code>, <code class="literal">TapeQIC80=2</code>, <code class="literal">TapeTravan=3</code>, and <code class="literal">TapeDLT=4</code>.</p></div><div class="sect2" title="4.2.5 Multiple const Sections and Their Order in an HLA Program"><div class="titlepage"><div><div><h2 class="title"><a id="multiple_const_sections_and_their_order"/>4.2.5 Multiple const Sections and Their Order in an HLA Program</h2></div></div></div><p>Although <code class="literal">const</code> sections must appear in the declaration section of an HLA program (for example, between the program <em class="replaceable"><code>pgmname</code></em><code class="literal">;</code> header and the corresponding <code class="literal">begin</code> <em class="replaceable"><code>pgmname</code></em><code class="literal">;</code> statement), they do not have to appear before or after any other items in the declaration section. In fact, like the variable declaration sections, you can place multiple <code class="literal">const</code> sections in a declaration section. The only restriction on HLA constant declarations is that you must declare any constant symbol before you use it in your program.</p><p>Some C/C++ programmers, for example, are more comfortable writing their constant declarations as follows (because this is closer to C/C++'s syntax for declaring constants):</p><a id="I_programlisting4_d1e15950"/><pre class="programlisting">const          TapeDAT               :=     0;
const          Tape8mm               :=     TapeDAT + 1;
const          TapeQIC80             :=     Tape8mm + 1;
const          TapeTravan            :=     TapeQIC80 + 1;
const          TapeDLT               :=     TapeTravan + 1;</pre><p>The placement of the <code class="literal">const</code> section in a program seems to be a personal issue among programmers. Other than the requirement of defining all constants before you use them, you may feel free to insert the <code class="literal">const</code> declaration section anywhere in the declaration section.</p></div><div class="sect2" title="4.2.6 The HLA val Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_hla_val_section"/>4.2.6 The HLA val Section</h2></div></div></div><p>You cannot change the value of a constant you define in the <code class="literal">const</code> section. While this seems perfectly reasonable (constants after all, are supposed to be, well, constant), there are different ways we can define the term <span class="emphasis"><em>constant</em></span>, and <code class="literal">const</code> objects follow the rules of only one specific definition. HLA's <code class="literal">val</code> section lets you define constant objects that follow slightly different rules. This section discusses the <code class="literal">val</code> section and the difference between <code class="literal">val</code> constants and <code class="literal">const</code> constants.<a class="indexterm" id="IDX-CHP-4-0055"/><a class="indexterm" id="IDX-CHP-4-0056"/></p><p>The concept of "<code class="literal">const</code>-ness" can exist at two different times: while HLA is compiling your program and later when your program executes (and HLA is no longer running). All reasonable definitions of a constant require that a value not change while the program is running. Whether or not the value of a "constant" can change during compilation is a separate issue. The difference between HLA <code class="literal">const</code> objects and HLA <code class="literal">val</code> objects is whether the value can change during compilation.</p><p>Once you define a constant in the <code class="literal">const</code> section, the value of that constant is immutable from that point forward <span class="emphasis"><em>both at runtime and while HLA is compiling your program</em></span>. Therefore, an instruction like <code class="literal">mov( SymbolicCONST, eax );</code> always moves the same value into EAX, regardless of where this instruction appears in the HLA main program. Once you define the symbol <code class="literal">SymbolicCONST</code> in the <code class="literal">const</code> section, this symbol has the same value from that point forward.</p><p>The HLA <code class="literal">val</code> section lets you declare symbolic constants, just like the <code class="literal">const</code> section. However, HLA <code class="literal">val</code> constants can change their value throughout the source code in your program. The following HLA declarations are perfectly legal:</p><a id="I_programlisting4_d1e16036"/><pre class="programlisting">val       InitialValue     := 0;
const     SomeVal          := InitialValue + 1;        // = 1
const     AnotherVal       := InitialValue + 2;        // = 2

val       InitialValue     := 100;
const     ALargerVal       := InitialValue;            // = 100
const     LargeValTwo      := InitialValue*2;          // = 200</pre><p>All of the symbols appearing in the <code class="literal">const</code> sections use the symbolic value <code class="literal">InitialValue</code> as part of the definition. Note, however, that <code class="literal">InitialValue</code> has different values at various points in this code sequence; at the beginning of the code sequence <code class="literal">InitialValue</code> has the value 0, while later it has the value 100.</p><p>Remember, at runtime a <code class="literal">val</code> object is not a variable; it is still a manifest constant and HLA will substitute the current value of a <code class="literal">val</code> identifier for that identifier.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-3" id="CHP-4-FN-3">49</a>]</sup> Statements like <code class="literal">mov( 25, InitialValue );</code> are no more legal than <code class="literal">mov( 25, 0 );</code> or <code class="literal">mov( 25, 100 );</code>.</p></div><div class="sect2" title="4.2.7 Modifying val Objects at Arbitrary Points in Your Programs"><div class="titlepage"><div><div><h2 class="title"><a id="modifying_val_objects_at_arbitrary_point"/>4.2.7 Modifying val Objects at Arbitrary Points in Your Programs</h2></div></div></div><p>If you declare all your <code class="literal">val</code> objects in the declaration section, it would seem that you would not be able to change the value of a <code class="literal">val</code> object between the <code class="literal">begin</code> and <code class="literal">end</code> statements of your program. After all, the <code class="literal">val</code> section must appear in the declaration section of the program, and the declaration section ends before the <code class="literal">begin</code> statement. In <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a>, you will learn that most <code class="literal">val</code> object modifications occur between the <code class="literal">begin</code> and <code class="literal">end</code> statements; hence, HLA must provide some way to change the value of a <code class="literal">val</code> object outside the declaration section. The mechanism to do this is the <code class="literal">?</code> operator. Not only does HLA allow you to change the value of a <code class="literal">val</code> object outside the declaration section, but it also allows you to change the value of a <code class="literal">val</code> object almost <span class="emphasis"><em>anywhere</em></span> in the program. Anywhere a space is allowed inside an HLA program, you can insert a statement of the form<a class="indexterm" id="IDX-CHP-4-0057"/><a class="indexterm" id="IDX-CHP-4-0058"/><a class="indexterm" id="IDX-CHP-4-0059"/><a class="indexterm" id="IDX-CHP-4-0060"/></p><a id="I_programlisting4_d1e16148"/><pre class="programlisting">? <em class="replaceable"><code>ValIdentifier</code></em> := <em class="replaceable"><code>constant_expression</code></em>;</pre><p>This means that you could write a short program like the one appearing in <a class="xref" href="ch04s02.html#demonstration_of_val_redefinition_using" title="Example 4-4. Demonstration of val redefinition using the ? operator">Example 4-4</a>.</p><div class="example"><a id="demonstration_of_val_redefinition_using"/><p class="title">Example 4-4. Demonstration of <code class="literal">val</code> redefinition using the <code class="literal">?</code> operator</p><div class="example-contents"><pre class="programlisting">program VALdemo;
#include( "stdlib.hhf" )

val
    NotSoConstant := 0;

begin VALdemo;

    mov( NotSoConstant, eax );
    stdout.put( "EAX = ", (type uns32 eax ), nl );

    ?NotSoConstant := 10;
    mov( NotSoConstant, eax );
    stdout.put( "EAX = ", (type uns32 eax ), nl );

    ?NotSoConstant := 20;
    mov( NotSoConstant, eax );
    stdout.put( "EAX = ", (type uns32 eax ), nl );

    ?NotSoConstant := 30;
    mov( NotSoConstant, eax );
    stdout.put( "EAX = ", (type uns32 eax ), nl );

end VALdemo;</pre></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-2" id="ftn.CHP-4-FN-2">48</a>] </sup>This is not a complete list. HLA also supports 64-bit and 128-bit data types. We'll discuss those in <a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-3" id="ftn.CHP-4-FN-3">49</a>] </sup>In this context, <span class="emphasis"><em>current</em></span> means the value last assigned to a <code class="literal">val</code> object looking backward in the source code.</p></div></div></div>
<div class="sect1" title="4.3 The HLA Type Section"><div class="titlepage"><div><div><h1 class="title"><a id="the_hla_type_section"/>4.3 The HLA Type Section</h1></div></div></div><p>Let's say that you simply do not like the names that HLA uses for declaring <code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, <code class="literal">real</code>, and other variables. Let's say that you prefer Pascal's naming convention or perhaps C's naming convention. You want to use terms like <code class="literal">integer</code>, <code class="literal">float</code>, <code class="literal">double</code>, or whatever. If HLA were Pascal, you could redefine the names in the <code class="literal">type</code> section of the program. With C you could use a <code class="literal">#define</code> or a <code class="literal">typedef</code> statement to accomplish the task. Well, HLA, like Pascal, has its own <code class="literal">type</code> statement that also lets you create aliases of these names. The following example demonstrates how to set up some C/C++/Pascal-compatible names in your HLA programs:<a class="indexterm" id="IDX-CHP-4-0061"/></p><a id="I_programlisting4_d1e16214"/><pre class="programlisting">type
     integer:             int32;
     float:               real32;
     double:              real64;
     colors:              byte;</pre><p>Now you can declare your variables with more meaningful statements like these:</p><a id="I_programlisting4_d1e16218"/><pre class="programlisting">static
     i:                    integer;
     x:                    float;
     HouseColor:           colors;</pre><p>If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter), you can pick type names you're more comfortable with. Of course, this doesn't change how the 80x86 or HLA reacts to these variables one iota, but it does let you create programs that are easier to read and understand because the type names are more indicative of the actual underlying types. One warning for C/C++ programmers: don't get too excited and go off and define an <code class="literal">int</code> data type. Unfortunately, <code class="literal">int</code> is an 80x86 machine instruction (interrupt), and therefore this is a reserved word in HLA.</p><p>The <code class="literal">type</code> section is useful for much more than creating type isomorphism (that is, giving a new name to an existing type). The following sections demonstrate many of the possible things you can do in the <code class="literal">type</code> section.</p></div>
<div class="sect1" title="4.4 enum and HLA Enumerated Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="enum_and_hla_enumerated_data_types"/>4.4 enum and HLA Enumerated Data Types</h1></div></div></div><p>In a previous section discussing constants and constant expressions, you saw the following example:</p><a id="I_programlisting4_d1e16241"/><pre class="programlisting">const          TapeDAT          :=     0;
const          Tape8mm          :=     TapeDAT + 1;
const          TapeQIC80        :=     Tape8mm + 1;
const          TapeTravan       :=     TapeQIC80 + 1;
const          TapeDLT          :=     TapeTravan + 1;</pre><p>This example demonstrates how to use constant expressions to develop a set of constants that contain unique, consecutive values. There are, however, a couple of problems with this approach. First, it involves a lot of typing (and extra reading when reviewing this program). Second, it's very easy to make a mistake when creating long lists of unique constants and reuse or skip some values. The HLA <code class="literal">enum</code> type provides a better way to create a list of constants with unique values.<a class="indexterm" id="IDX-CHP-4-0062"/><a class="indexterm" id="IDX-CHP-4-0063"/></p><p><code class="literal">enum</code> is an HLA type declaration that lets you associate a list of names with a new type. HLA associates a unique value with each name (that is, it <span class="emphasis"><em>enumerates</em></span> the list). The <code class="literal">enum</code> keyword typically appears in the <code class="literal">type</code> section, and you use it as follows:</p><a id="I_programlisting4_d1e16267"/><pre class="programlisting">type
     <em class="replaceable"><code>enumTypeID</code></em>:          enum { <em class="replaceable"><code>comma_separated_list_of_names</code></em> };</pre><p>The symbol <em class="replaceable"><code>enumTypeID</code></em> becomes a new type whose values are specified by a list of names. As a concrete example, consider the data type <code class="literal">TapeDrives</code> and a corresponding variable declaration of type <code class="literal">TapeDrives</code>:</p><a id="I_programlisting4_d1e16286"/><pre class="programlisting">type
     TapeDrives: enum{ TapeDAT, Tape8mm, TapeQIC80, TapeTravan, TapeDLT};

static
     BackupUnit:        TapeDrives := TapeDAT;

     .
     .
     .

     mov( BackupUnit, al );
     if( al = Tape8mm ) then

          ...

     endif;

     // etc.</pre><p>By default, HLA reserves 1 byte of storage for enumerated data types. So the <code class="literal">BackupUnit</code> variable will consume 1 byte of memory, and you would typically use an 8-bit register to access it.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-4" id="CHP-4-FN-4">50</a>]</sup> As for the constants, HLA associates consecutive <code class="literal">uns8</code> constant values starting at 0 with each of the enumerated identifiers. In the <code class="literal">TapeDrives</code> example, the tape drive identifiers would have the values <code class="literal">TapeDAT=0</code>, <code class="literal">Tape8mm=1</code>, <code class="literal">TapeQIC80=2</code>, <code class="literal">TapeTravan=3</code>, and <code class="literal">TapeDLT=4</code>. You may use these constants exactly as though you had defined them with these values in a <code class="literal">const</code> section.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-4" id="ftn.CHP-4-FN-4">50</a>] </sup>HLA provides a mechanism by which you can specify that enumerated data types consume 2 or 4 bytes of memory. See the HLA documentation for more details.</p></div></div></div>
<div class="sect1" title="4.5 Pointer Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="pointer_data_types"/>4.5 Pointer Data Types</h1></div></div></div><p>You've probably experienced pointers firsthand in the Pascal, C, or Ada programming languages, and you're probably getting worried right now. Almost everyone has a bad experience when they first encounter pointers in a high-level language. Well, fear not! Pointers are actually <span class="emphasis"><em>easier</em></span> to deal with in assembly language than in high-level languages. Besides, most of the problems you had with pointers probably had nothing to do with pointers but rather with the linked list and tree data structures you were trying to implement with them. Pointers, on the other hand, have many uses in assembly language that have nothing to do with linked lists, trees, and other scary data structures. Indeed, simple data structures like arrays and records often involve the use of pointers. So if you have some deep-rooted fear about pointers, forget everything you know about them. You're going to learn how <span class="emphasis"><em>great</em></span> pointers really are.</p><p>Probably the best place to start is with the definition of a pointer. Just exactly what is a pointer, anyway? Unfortunately, high-level languages like Pascal tend to hide the simplicity of pointers behind a wall of abstraction. This added complexity (which exists for good reason, by the way) tends to frighten programmers because <span class="emphasis"><em>they don't understand what's going on</em></span>.</p><p>If you're afraid of pointers, let's just ignore them for the time being and work with an array. Consider the following array declaration in Pascal:</p><a id="I_programlisting4_d1e16340"/><pre class="programlisting">M: array [0..1023] of integer;</pre><p>Even if you don't know Pascal, the concept here is pretty easy to understand. <code class="literal">M</code> is an array with 1,024 integers in it, indexed from <code class="literal">M[0]</code> to <code class="literal">M[1023]</code>. Each one of these array elements can hold an integer value that is independent of all the others. In other words, this array gives you 1,024 different integer variables, each of which you refer to by number (the array index) rather than by name.</p><p>If you encounter a program that has the statement <code class="literal">M[0]:=100;</code>, you probably won't have to think at all about what is happening with this statement. It is storing the value 100 into the first element of the array <code class="literal">M</code>. Now consider the following two statements:</p><a id="I_programlisting4_d1e16361"/><pre class="programlisting">i := 0; (* Assume "i" is an integer variable. *)
          M [i] := 100;</pre><p>You should agree, without too much hesitation, that these two statements perform the same operation as <code class="literal">M[0]:=100</code>;. Indeed, you're probably willing to agree that you can use any integer expression in the range 0..1,023 as an index into this array. The following statements still perform the same operation as our single assignment to index 0:</p><a id="I_programlisting4_d1e16368"/><pre class="programlisting">i := 5;               (* Assume all variables are integers.*)
          j := 10;
          k := 50;
          m [i*j-k] := 100;</pre><p>"Okay, so what's the point?" you're probably thinking. "Anything that produces an integer in the range 0..1,023 is legal. So what?" Okay, how about the following:<a class="indexterm" id="IDX-CHP-4-0064"/></p><a id="I_programlisting4_d1e16378"/><pre class="programlisting">M [1] := 0;
          M [ M [1] ] := 100;</pre><p>Whoa! Now that takes a few moments to digest. However, if you take it slowly, it makes sense and you'll discover that these two instructions perform the exact same operation you've been doing all along. The first statement stores 0 into array element <code class="literal">M[1]</code>. The second statement fetches the value of <code class="literal">M[1]</code>, which is an integer so you can use it as an array index into <code class="literal">M</code>, and uses that value (0) to control where it stores the value 100.</p><p>If you're willing to accept the above as reasonable, perhaps bizarre, but usable nonetheless, then you'll have no problems with pointers. <span class="emphasis"><em>Because</em></span> <em class="replaceable"><code>M[1]</code></em> <span class="emphasis"><em>is a pointer!</em></span> Well, not really, but if you were to change <code class="literal">M</code> to "memory" and treat this array as all of memory, this is the exact definition of a pointer. A pointer is simply a memory location whose value is the address (or index, if you prefer) of some other memory location. Pointers are very easy to declare and use in an assembly language program. You don't even have to worry about array indices or anything like that.<a class="indexterm" id="IDX-CHP-4-0065"/></p><div class="sect2" title="4.5.1 Using Pointers in Assembly Language"><div class="titlepage"><div><div><h2 class="title"><a id="using_pointers_in_assembly_language"/>4.5.1 Using Pointers in Assembly Language</h2></div></div></div><p>An HLA pointer is a 32-bit value that may contain the address of some other variable. If you have a <code class="literal">dword</code> variable <code class="literal">p</code> that contains $1000_0000, then <code class="literal">p</code> "points" at memory location $1000_0000. To access the <code class="literal">dword</code> that <code class="literal">p</code> points at, you could use code like the following:<a class="indexterm" id="IDX-CHP-4-0066"/></p><a id="I_programlisting4_d1e16434"/><pre class="programlisting">mov( p, ebx );            // Load ebx with the value of pointer p.
          mov( [ebx], eax );        // Fetch the data that p points at.</pre><p>By loading the value of <code class="literal">p</code> into EBX, this code loads the value $1000_0000 into EBX (assuming <code class="literal">p</code> contains $1000_0000 and, therefore, points at memory location $1000_0000). The second instruction above loads the EAX register with the <code class="literal">dword</code> starting at the location whose offset appears in EBX. Because EBX now contains $1000_0000, this will load EAX from locations $1000_0000 through $1000_0003.</p><p>Why not just load EAX directly from location $1000_0000 using an instruction like <code class="literal">mov( mem, eax )</code>; (assuming <code class="literal">mem</code> is at address $1000_0000)? Well, there are a lot of reasons. But the primary reason is that this <code class="literal">mov</code> instruction always loads EAX from location <code class="literal">mem</code>. You cannot change the address from where it loads EAX. The former instructions, however, always load EAX from the location where <code class="literal">p</code> is pointing. This is very easy to change under program control. In fact, the simple instruction <code class="literal">mov( &amp;mem2, p );</code> will cause those same two instructions above to load EAX from <code class="literal">mem2</code> the next time they execute. Consider the following instruction sequence:<a class="indexterm" id="IDX-CHP-4-0067"/></p><a id="I_programlisting4_d1e16474"/><pre class="programlisting">mov( &amp;i, p );        // Assume all variables are STATIC variables.
               .
               .
               .
          if( <em class="replaceable"><code>some_expression</code></em> ) then


             mov( &amp;j, p );      // Assume the code above skips this instruction
               .                // and you get to the next instruction by
               .                // jumping to this point from somewhere else.
               .

          endif;
          mov( p, ebx );        // Assume both of the above code paths wind up
          mov( [ebx], eax );    // down here.</pre><p>This short example demonstrates two execution paths through the program. The first path loads the variable <code class="literal">p</code> with the address of the variable <code class="literal">i</code>. The second path through the code loads <code class="literal">p</code> with the address of the variable <code class="literal">j</code>. Both execution paths converge on the last two <code class="literal">mov</code> instructions that load EAX with <code class="literal">i</code> or <code class="literal">j</code> depending upon which execution path was taken. In many respects, this is like a <span class="emphasis"><em>parameter</em></span> to a procedure in a high-level language like Pascal. Executing the same instructions accesses different variables depending on whose address (<code class="literal">i</code> or <code class="literal">j</code>) winds up in <code class="literal">p</code>.</p></div><div class="sect2" title="4.5.2 Declaring Pointers in HLA"><div class="titlepage"><div><div><h2 class="title"><a id="declaring_pointers_in_hla"/>4.5.2 Declaring Pointers in HLA</h2></div></div></div><p>Because pointers are 32-bits long, you could simply use the <code class="literal">dword</code> type to allocate storage for your pointers. However, there is a much better way to do this: HLA provides the <code class="literal">pointer to</code> phrase specifically for declaring pointer variables. Consider the following example:</p><a id="I_programlisting4_d1e16526"/><pre class="programlisting">static
     b:          byte;
     d:          dword;
     pByteVar:   pointer to byte := &amp;b;
     pDWordVar:  pointer to dword := &amp;d;</pre><p>This example demonstrates that it is possible to initialize as well as declare pointer variables in HLA. Note that you may only take addresses of static variables (<code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code> objects) with the address-of operator, so you can only initialize pointer variables with the addresses of static objects.</p><p>You can also define your own pointer types in the <code class="literal">type</code> section of an HLA program. For example, if you often use pointers to characters, you'll probably want to use a <code class="literal">type</code> declaration like the one in the following example.</p><a id="I_programlisting4_d1e16547"/><pre class="programlisting">type
     ptrChar:     pointer to char;

static
     cString:     ptrChar;</pre></div><div class="sect2" title="4.5.3 Pointer Constants and Pointer Constant Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="pointer_constants_and_pointer_constant_e"/>4.5.3 Pointer Constants and Pointer Constant Expressions</h2></div></div></div><p>HLA allows two literal pointer constant forms: the address-of operator followed by the name of a static variable or the constant <code class="literal">NULL</code>. In addition to these two literal pointer constants, HLA also supports simple pointer constant expressions.<a class="indexterm" id="IDX-CHP-4-0068"/></p><p>The <code class="literal">NULL</code> pointer is the constant 0. Zero is an illegal address that will raise an exception if you try to access it under modern operating systems. Programs typically initialize pointers with <code class="literal">NULL</code> to indicate that a pointer has explicitly <span class="emphasis"><em>not</em></span> been initialized with a valid address.</p><p>In addition to simple address literals and the value 0, HLA allows very simple constant expressions wherever a pointer constant is legal. Pointer constant expressions take one of the three following forms:</p><a id="I_programlisting4_d1e16575"/><pre class="programlisting">&amp;<em class="replaceable"><code>StaticVarName</code></em> [ <em class="replaceable"><code>PureConstantExpression</code></em> ]
          &amp;<em class="replaceable"><code>StaticVarName</code></em> + <em class="replaceable"><code>PureConstantExpression</code></em>
          &amp;<em class="replaceable"><code>StaticVarName</code></em> - <em class="replaceable"><code>PureConstantExpression</code></em></pre><p>The <em class="replaceable"><code>PureConstantExpression</code></em> term is a numeric constant expression that does not involve any pointer constants. This type of expression produces a memory address that is the specified number of bytes before or after (<code class="literal">−</code> or <code class="literal">+</code>, respectively) the <em class="replaceable"><code>StaticVarName</code></em> variable in memory. Note that the first two forms above are semantically equivalent; they both return a pointer constant whose address is the sum of the static variable and the constant expression.</p><p>Because you can create pointer constant expressions, it should come as no surprise to discover that HLA lets you define manifest pointer constants in the <code class="literal">const</code> section. The program in <a class="xref" href="ch04s05.html#pointer_constant_expressions_in_an_hla_p" title="Example 4-5. Pointer constant expressions in an HLA program">Example 4-5</a> demonstrates how you can do this.</p><div class="example"><a id="pointer_constant_expressions_in_an_hla_p"/><p class="title">Example 4-5. Pointer constant expressions in an HLA program</p><div class="example-contents"><pre class="programlisting">program PtrConstDemo;
#include( "stdlib.hhf" );

static
    b:  byte := 0;
        byte    1, 2, 3, 4, 5, 6, 7;

const
    pb := &amp;b + 1;

begin PtrConstDemo;

    mov( pb, ebx );
    mov( [ebx], al );
    stdout.put( "Value at address pb = $", al, nl );

end PtrConstDemo;</pre></div></div><p>Upon execution, this program prints the value of the byte just beyond <code class="literal">b</code> in memory (which contains the value $01).<a class="indexterm" id="IDX-CHP-4-0069"/><a class="indexterm" id="IDX-CHP-4-0070"/></p></div><div class="sect2" title="4.5.4 Pointer Variables and Dynamic Memory Allocation"><div class="titlepage"><div><div><h2 class="title"><a id="pointer_variables_and_dynamic_memory_all"/>4.5.4 Pointer Variables and Dynamic Memory Allocation</h2></div></div></div><p>Pointer variables are the perfect place to store the return result from the HLA Standard Library <code class="literal">mem.alloc</code> function. The <code class="literal">mem.alloc</code> function returns the address of the storage it allocates in the EAX register; therefore, you can store the address directly into a pointer variable with a single <code class="literal">mov</code> instruction immediately after a call to <code class="literal">mem.alloc</code>:<a class="indexterm" id="IDX-CHP-4-0071"/></p><a id="I_programlisting4_d1e16656"/><pre class="programlisting">type
     bytePtr:     pointer to byte;

var
     bPtr: bytePtr;
          .
          .
          .
     mem.alloc( 1024 );    // Allocate a block of 1,024 bytes.
     mov( eax, bPtr );     // Store address of block in bPtr.
          .
          .
          .
     mem.free( bPtr );     // Free the allocated block when done using it.
          .
          .
          .</pre></div><div class="sect2" title="4.5.5 Common Pointer Problems"><div class="titlepage"><div><div><h2 class="title"><a id="common_pointer_problems"/>4.5.5 Common Pointer Problems</h2></div></div></div><p>Programmers encounter five common problems when using pointers. Some of these errors will cause your programs to immediately stop with a diagnostic message; other problems are more subtle, yielding incorrect results without otherwise reporting an error or simply affecting the performance of your program without displaying an error. These five problems are:<a class="indexterm" id="IDX-CHP-4-0072"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Using an uninitialized pointer</p></li><li class="listitem"><p>Using a pointer that contains an illegal value (e.g., <code class="literal">NULL</code>)</p></li><li class="listitem"><p>Continuing to use <code class="literal">mem.alloc</code>'d storage after that storage has been freed<a class="indexterm" id="IDX-CHP-4-0073"/></p></li><li class="listitem"><p>Failing to <code class="literal">mem.free</code> storage once the program is finished using it</p></li><li class="listitem"><p>Accessing indirect data using the wrong data type</p></li></ul></div><p>The first problem above is using a pointer variable before you have assigned a valid memory address to the pointer. Beginning programmers often don't realize that declaring a pointer variable reserves storage only for the pointer itself; it does not reserve storage for the data that the pointer references. The short program in <a class="xref" href="ch04s05.html#uninitialized_pointer_demonstration" title="Example 4-6. Uninitialized pointer demonstration">Example 4-6</a> demonstrates this problem.</p><div class="example"><a id="uninitialized_pointer_demonstration"/><p class="title">Example 4-6. Uninitialized pointer demonstration</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate use of
// an uninitialized pointer. Note
// that this program should terminate
// with a Memory Access Violation exception.

program UninitPtrDemo;
#include( "stdlib.hhf" );

static

    // Note: By default, variables in the
    // static section are initialized with
    // zero (NULL) hence the following
    // is actually initialized with NULL,
    // but that will still cause our program
    // to fail because we haven't initialized
    // the pointer with a valid memory address.

    Uninitialized: pointer to byte;

begin UninitPtrDemo;

    mov( Uninitialized, ebx );
    mov( [ebx], al );
    stdout.put( "Value at address Uninitialized: = $", al, nl );

end UninitPtrDemo;</pre></div></div><p>Although variables you declare in the <code class="literal">static</code> section are, technically, initialized, static initialization still doesn't initialize the pointer in this program with a valid address (it initializes them with <code class="literal">0</code>, which is <code class="literal">NULL</code>).</p><p>Of course, there is no such thing as a truly uninitialized variable on the 80x86. What you really have are variables that you've explicitly given an initial value and variables that just happen to inherit whatever bit pattern was in memory when storage for the variable was allocated. Much of the time, these garbage bit patterns lying around in memory don't correspond to a valid memory address. Attempting to <span class="emphasis"><em>dereference</em></span> such a pointer (that is, access the data in memory at which it points) typically raises a <span class="emphasis"><em>Memory Access Violation</em></span> exception.</p><p>Sometimes, however, those random bits in memory just happen to correspond to a valid memory location you can access. In this situation, the CPU will access the specified memory location without aborting the program. Although to a naive programmer this situation may seem preferable to stopping the program, in reality this is far worse because your defective program continues to run without alerting you to the problem. If you store data through an uninitialized pointer, you may very well overwrite the values of other important variables in memory. This defect can produce some very difficult-to-locate problems in your program.<a class="indexterm" id="IDX-CHP-4-0074"/><a class="indexterm" id="IDX-CHP-4-0075"/></p><p>The second problem programmers have with pointers is storing invalid address values into a pointer. The first problem above is actually a special case of this second problem (with garbage bits in memory supplying the invalid address rather than you producing it via a miscalculation). The effects are the same; if you attempt to dereference a pointer containing an invalid address, either you will get a Memory Access Violation exception or you will access an unexpected memory location.</p><p>The third problem listed above is also known as the dangling pointer problem. To understand this problem, consider the following code fragment:</p><a id="I_programlisting4_d1e16740"/><pre class="programlisting">mem.alloc( 256 );   // Allocate some storage.
          mov( eax, ptr );    // Save address away in a pointer variable.
               .
               .              // Code that uses the pointer variable ptr.
               .
          mem.free( ptr );    // Free the storage associated with ptr.
               .
               .              // Code that does not change the value in ptr.
               .
          mov( ptr, ebx );
          mov( al, [ebx] );</pre><p>In this example you will note that the program allocates 256 bytes of storage and saves the address of that storage in the <code class="literal">ptr</code> variable. Then the code uses this block of 256 bytes for a while and frees the storage, returning it to the system for other uses. Note that calling <code class="literal">mem.free</code> does not change the value of <code class="literal">ptr</code> in any way; <code class="literal">ptr</code> still points at the block of memory allocated by <code class="literal">mem.alloc</code> earlier. Indeed, <code class="literal">mem.free</code> does not change any data in this block, so upon return from <code class="literal">mem.free</code>, <code class="literal">ptr</code> still points at the data stored into the block by this code. However, note that the call to <code class="literal">mem.free</code> tells the system that the program no longer needs this 256-byte block of memory and the system can use this region of memory for other purposes. The <code class="literal">mem.free</code> function cannot enforce the fact that you will never access this data again; you are simply promising that you won't. Of course, the code fragment above breaks this promise; as you can see in the last two instructions above, the program fetches the value in <code class="literal">ptr</code> and accesses the data it points at in memory.<a class="indexterm" id="IDX-CHP-4-0076"/></p><p>The biggest problem with dangling pointers is that you can get away with using them a good part of the time. As long as the system doesn't reuse the storage you've freed, using a dangling pointer produces no ill effects in your program. However, with each new call to <code class="literal">mem.alloc</code>, the system may decide to reuse the memory released by that previous call to <code class="literal">mem.free</code>. When this happens, any attempt to dereference the dangling pointer may produce some unintended consequences. The problems range from reading data that has been overwritten (by the new, legal use of the data storage), to overwriting the new data, to (the worst case) overwriting system heap management pointers (doing so will probably cause your program to crash). The solution is clear: <span class="emphasis"><em>Never use a pointer value once you free the storage associated with that pointer</em></span>.<a class="indexterm" id="IDX-CHP-4-0077"/></p><p>Of all the problems, the fourth (failing to free allocated storage) will probably have the least impact on the proper operation of your program. The following code fragment demonstrates this problem:</p><a id="I_programlisting4_d1e16803"/><pre class="programlisting">mem.alloc( 256 );
          mov( eax, ptr );
               .              // Code that uses the data where ptr is pointing.
               .              // This code does not free up the storage
               .              // associated with ptr.
          mem.alloc( 512 );
          mov( eax, ptr );

          // At this point, there is no way to reference the original
          // block of 256 bytes pointed at by ptr.</pre><p>In this example the program allocates 256 bytes of storage and references this storage using the <code class="literal">ptr</code> variable. At some later time the program allocates another block of bytes and overwrites the value in <code class="literal">ptr</code> with the address of this new block. Note that the former value in <code class="literal">ptr</code> is lost. Because the program no longer has this address value, there is no way to call <code class="literal">mem.free</code> to return the storage for later use. As a result, this memory is no longer available to your program. While making 256 bytes of memory inaccessible to your program may not seem like a big deal, imagine that this code is in a loop that repeats over and over again. With each execution of the loop the program loses another 256 bytes of memory. After a sufficient number of loop iterations, the program will exhaust the memory available on the heap. This problem is often called a <span class="emphasis"><em>memory leak</em></span> because the effect is the same as though the memory bits were leaking out of your computer (yielding less and less available storage) during program execution.</p><p>Memory leaks are far less damaging than dangling pointers. Indeed, there are only two problems with memory leaks: the danger of running out of heap space (which, ultimately, may cause the program to abort, though this is rare) and performance problems due to virtual memory page swapping. Nevertheless, you should get in the habit of always freeing all storage once you have finished using it. When your program quits, the operating system reclaims all storage, including the data lost via memory leaks. Therefore, memory lost via a leak is lost only to your program, not the whole system.</p><p>The last problem with pointers is the lack of type-safe access. This can occur because HLA cannot and does not enforce pointer type checking. For example, consider the program in <a class="xref" href="ch04s05.html#type-unsafe_pointer_access_example" title="Example 4-7. Type-unsafe pointer access example">Example 4-7</a>.</p><div class="example"><a id="type-unsafe_pointer_access_example"/><p class="title">Example 4-7. Type-unsafe pointer access example</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate use of
// lack of type checking in pointer
// accesses.

program BadTypePtrDemo;
#include("stdlib.hhf" );

static
    ptr:    pointer to char;
    cnt:    uns32;

begin BadTypePtrDemo;

    // Allocate sufficient characters
    // to hold a line of text input
    // by the user:

    mem.alloc( 256 );
    mov( eax, ptr );


    // Okay, read the text a character
    // at a time by the user:

    stdout.put( "Enter a line of text: " );
    stdin.flushInput();
    mov( 0, cnt );
    mov( ptr, ebx );
    repeat

        stdin.getc();       // Read a character from the user.
        mov( al, [ebx] );   // Store the character away.
        inc( cnt );         // Bump up count of characters.
        inc( ebx );         // Point at next position in memory.

    until( stdin.eoln());


    // Okay, we've read a line of text from the user,
    // now display the data:

    mov( ptr, ebx );
    for( mov( cnt, ecx ); ecx &gt; 0; dec( ecx )) do

        mov( [ebx], eax );
        stdout.put( "Current value is $", eax, nl );
        inc( ebx );

    endfor;
    mem.free( ptr );


end BadTypePtrDemo;</pre></div></div><p>This program reads in data from the user as character values and then displays the data as double-word hexadecimal values. While a powerful feature of assembly language is that it lets you ignore data types at will and automatically coerce the data without any effort, this power is a two-edged sword. If you make a mistake and access indirect data using the wrong data type, HLA and the 80x86 may not catch the mistake and your program may produce inaccurate results. Therefore, you need to take care when using pointers and indirection in your programs that you use the data consistently with respect to data type.<a class="indexterm" id="IDX-CHP-4-0078"/></p></div></div>
<div class="sect1" title="4.6 Composite Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="composite_data_types"/>4.6 Composite Data Types</h1></div></div></div><p>Composite data types, also known as <span class="emphasis"><em>aggregate</em></span> data types, are those that are built up from other (generally scalar) data types. This chapter covers several of the more important composite data types—character strings, character sets, arrays, records, and unions. A string is a good example of a composite data type; it is a data structure built up from a sequence of individual characters and some other data.<a class="indexterm" id="IDX-CHP-4-0079"/><a class="indexterm" id="IDX-CHP-4-0080"/><a class="indexterm" id="IDX-CHP-4-0081"/></p></div>
<div class="sect1" title="4.7 Character Strings"><div class="titlepage"><div><div><h1 class="title"><a id="character_strings"/>4.7 Character Strings</h1></div></div></div><p>After integer values, character strings are probably the most common data type that modern programs use. The 80x86 does support a handful of string instructions, but these instructions are really intended for block memory operations, not a specific implementation of a character string. Therefore, this section will concentrate mainly on the HLA definition of character strings and will also discuss the string-handling routines available in the HLA Standard Library.</p><p>In general, a character string is a sequence of ASCII characters that possesses two main attributes: a <span class="emphasis"><em>length</em></span> and some <span class="emphasis"><em>character data</em></span>. Different languages use different data structures to represent strings. To better understand the reasoning behind the design of HLA strings, it is probably instructive to look at two different string representations popularized by various high-level languages.</p><p>Without question, <span class="emphasis"><em>zero-terminated strings</em></span> are probably the most common string representation in use today because this is the native string format for C, C++, C#, Java, and other languages. A zero-terminated string consists of a sequence of zero or more ASCII characters ending with a 0 byte. For example, in C/C++, the string <code class="literal">"abc"</code> requires 4 bytes: the three characters <code class="literal">'a'</code>, <code class="literal">'b'</code>, and <code class="literal">'c'</code> followed by a 0. As you'll soon see, HLA character strings are upward compatible with zero-terminated strings, but in the meantime you should note that it is very easy to create zero-terminated strings in HLA. The easiest place to do this is in the <code class="literal">static</code> section using code like the following:<a class="indexterm" id="IDX-CHP-4-0082"/><a class="indexterm" id="IDX-CHP-4-0083"/><a class="indexterm" id="IDX-CHP-4-0084"/><a class="indexterm" id="IDX-CHP-4-0085"/><a class="indexterm" id="IDX-CHP-4-0086"/></p><a id="I_programlisting4_d1e16908"/><pre class="programlisting">static
     zeroTerminatedString:     char; @nostorage;
                               byte "This is the zero-terminated string", 0;</pre><p>Remember, when using the <code class="literal">@nostorage</code> option, HLA doesn't reserve any space for the variable, so the <code class="literal">zeroTerminatedString</code> variable's address in memory corresponds to the first character in the following <code class="literal">byte</code> directive. Whenever a character string appears in the <code class="literal">byte</code> directive as it does here, HLA emits each character in the string to successive memory locations. The 0 value at the end of the string terminates this string.</p><p>HLA supports a <code class="literal">zstring</code> data type. However, those objects are double word pointers that contain the address of a <code class="literal">zstring</code>, not the zero-terminated string itself. Here is an example of a <code class="literal">zstring</code> declaration (and static initialization):</p><a id="I_programlisting4_d1e16935"/><pre class="programlisting">static
     zeroTerminatedString:     char; @nostorage;
                               byte "This is the zero-terminated string", 0;
     zstrVar:                  zstring := &amp;zeroTerminatedString;</pre><p>Zero-terminated strings have two principal attributes: They are very simple to implement, and the strings can be any length. On the other hand, zero-terminated strings have a few drawbacks. First, though not usually important, zero-terminated strings cannot contain the NUL character (whose ASCII code is 0). Generally, this isn't a problem, but it does create havoc once in a while. The second problem with zero-terminated strings is that many operations on them are somewhat inefficient. For example, to compute the length of a zero-terminated string, you must scan the entire string looking for that 0 byte (counting characters up to the 0). The following program fragment demonstrates how to compute the length of the string above:</p><a id="I_programlisting4_d1e16939"/><pre class="programlisting">mov( &amp;zeroTerminatedString, ebx );
          mov( 0, eax );
          while( (type byte [ebx+eax]) &lt;&gt; 0 ) do

               inc( eax );

          endwhile;

          // String length is now in eax.</pre><p>As you can see from this code, the time it takes to compute the length of the string is proportional to the length of the string; as the string gets longer, it takes longer to compute its length.<a class="indexterm" id="IDX-CHP-4-0087"/><a class="indexterm" id="IDX-CHP-4-0088"/></p><p>A second string format, <span class="emphasis"><em>length-prefixed strings</em></span>, overcomes some of the problems with zero-terminated strings. Length-prefixed strings are common in languages like Pascal; they generally consist of a length byte followed by zero or more character values. The first byte specifies the string length, and the following bytes (up to the specified length) are the character data. In a length-prefixed scheme, the string <code class="literal">abc</code> would consist of the 4 bytes <code class="literal">$03</code> (the string length) followed by <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>. You can create length-prefixed strings in HLA using code like the following:<a class="indexterm" id="IDX-CHP-4-0089"/></p><a id="I_programlisting4_d1e16976"/><pre class="programlisting">static
     lengthPrefixedString:char; @nostorage;
                          byte 3, "abc";</pre><p>Counting the characters ahead of time and inserting them into the byte statement, as was done here, may seem like a major pain. Fortunately, there are ways to have HLA automatically compute the string length for you.</p><p>Length-prefixed strings solve the two major problems associated with zero-terminated strings. It is possible to include the NUL character in length-prefixed strings, and those operations on zero-terminated strings that are relatively inefficient (e.g., string length) are more efficient when using length-prefixed strings. However, length-prefixed strings have their own drawbacks. The principal drawback is that they are limited to a maximum of 255 characters in length (assuming a 1-byte length prefix).<a class="indexterm" id="IDX-CHP-4-0090"/></p><p>HLA uses an expanded scheme for strings that is upward compatible with both zero-terminated and length-prefixed strings. HLA strings enjoy the advantages of both zero-terminated and length-prefixed strings without the disadvantages. In fact, the only drawback to HLA strings over these other formats is that HLA strings consume a few additional bytes (the overhead for an HLA string is 9 to 12 bytes compared to 1 byte for zero-terminated or length-prefixed strings, the overhead being the number of bytes needed above and beyond the actual characters in the string).</p><p>An HLA string value consists of four components. The first element is a double-word value that specifies the maximum number of characters that the string can hold. The second element is a double-word value specifying the current length of the string. The third component is the sequence of characters in the string. The final component is a zero-terminating byte. You could create an HLA-compatible string in the <code class="literal">static</code> section using code like the following:<sup>[<a class="footnote" href="#ftn.CHP-4-FN-5" id="CHP-4-FN-5">51</a>]</sup></p><a id="I_programlisting4_d1e16995"/><pre class="programlisting">static
          align(4);
          dword 11;
          dword 11;
     TheString: char; @nostorage;
          byte "Hello there";
          byte 0;</pre><p>Note that the address associated with the HLA string is the address of the first character, not the maximum or current length values.<a class="indexterm" id="IDX-CHP-4-0091"/></p><p>"So what is the difference between the current and maximum string lengths?" you're probably wondering. In a literal string they are usually the same. However, when you allocate storage for a string variable at runtime, you will normally specify the maximum number of characters that can go into the string. When you store actual string data into the string, the number of characters you store must be less than or equal to this maximum value. The HLA Standard Library string routines will raise an exception if you attempt to exceed this maximum length (something the C/C++ and Pascal formats can't do).<a class="indexterm" id="IDX-CHP-4-0092"/></p><p>The terminating 0 byte at the end of the HLA string lets you treat an HLA string as a zero-terminated string if it is more efficient or more convenient to do so. For example, most calls to Windows, Mac OS X, FreeBSD, and Linux require zero-terminated strings for their string parameters. Placing a 0 at the end of an HLA string ensures compatibility with the operating system and other library modules that use zero-terminated strings.<a class="indexterm" id="IDX-CHP-4-0093"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-5" id="ftn.CHP-4-FN-5">51</a>] </sup>Actually, there are some restrictions on the placement of HLA strings in memory. This text will not cover those issues. See the HLA documentation for more details.</p></div></div></div>
<div class="sect1" title="4.8 HLA Strings"><div class="titlepage"><div><div><h1 class="title"><a id="hla_strings"/>4.8 HLA Strings</h1></div></div></div><p>As the previous section notes, HLA strings consist of four components: a maximum length, a current string length, character data, and a zero-terminating byte. However, HLA never requires you to create string data by manually emitting these components yourself. HLA is smart enough to automatically construct this data for you whenever it sees a string literal constant. So if you use a string constant like the following, understand that somewhere HLA is creating the four-component string in memory for you:</p><a id="I_programlisting4_d1e17020"/><pre class="programlisting">stdout.put( "This gets converted to a four-component string by HLA" );</pre><p>HLA doesn't actually work directly with the string data described in the previous section. Instead, when HLA sees a string object, it always works with a <span class="emphasis"><em>pointer</em></span> to that object rather than working directly with the object. Without question, this is the most important fact to know about HLA strings and is the biggest source of problems beginning HLA programmers have with strings in HLA: <span class="emphasis"><em>Strings are pointers!</em></span> A string variable consumes exactly 4 bytes, the same as a pointer (because it is a pointer!). Having said all that, let's look at a simple string variable declaration in HLA:<a class="indexterm" id="IDX-CHP-4-0094"/></p><a id="I_programlisting4_d1e17035"/><pre class="programlisting">static
          StrVariable:     string;</pre><p>Because a string variable is a pointer, you must initialize it before you can use it. There are three general ways you may initialize a string variable with a legal string address: using static initializers, using the <code class="literal">str.alloc</code> routine, or calling some other HLA Standard Library function that initializes a string or returns a pointer to a string.</p><p>In one of the static declaration sections that allow initialized variables (<code class="literal">static</code> and <code class="literal">readonly</code>) you can initialize a string variable using the standard initialization syntax. For example:</p><a id="I_programlisting4_d1e17050"/><pre class="programlisting">static
     InitializedString: string := "This is my string";</pre><p>Note that this does not initialize the string variable with the string data. Instead, HLA creates the string data structure (see <a class="xref" href="ch04s07.html" title="4.7 Character Strings">4.7 Character Strings</a>) in a special, hidden, memory segment and initializes the <code class="literal">InitializedString</code> variable with the address of the first character in this string (the <code class="literal">T</code> in <code class="literal">This</code>). <span class="emphasis"><em>Remember, strings are pointers!</em></span> The HLA compiler places the actual string data in a read-only memory segment. Therefore, you cannot modify the characters of this string literal at runtime. However, because the string variable (a pointer, remember) is in the <code class="literal">static</code> section, you can change the string variable so that it points at different string data.</p><p>Because string variables are pointers, you can load the value of a string variable into a 32-bit register. The pointer itself points at the first character position of the string. You can find the current string length in the double-word 4 bytes prior to this address, and you can find the maximum string length in the double-word 8 bytes prior to this address. The program in <a class="xref" href="ch04s08.html#accessing_the_length_and_maximum_length" title="Example 4-8. Accessing the length and maximum length fields of a string">Example 4-8</a> demonstrates one way to access this data.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-6" id="CHP-4-FN-6">52</a>]</sup></p><div class="example"><a id="accessing_the_length_and_maximum_length"/><p class="title">Example 4-8. Accessing the length and maximum length fields of a string</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate accessing Length and Maxlength fields of a string.

program StrDemo;
#include( "stdlib.hhf" );

static
    theString:string := "String of length 19";

begin StrDemo;

    mov( theString, ebx );  // Get pointer to the string.

    mov( [ebx-4], eax );    // Get current length.
    mov( [ebx-8], ecx );    // Get maximum length.

    stdout.put
    (
        "theString = '", theString, "'", nl,
        "length( theString )= ", (type uns32 eax ), nl,
        "maxLength( theString )= ", (type uns32 ecx ), nl
    );

end StrDemo;</pre></div></div><p>When accessing the various fields of a string variable, it is not wise to access them using fixed numeric offsets as done in <a class="xref" href="ch04s08.html#accessing_the_length_and_maximum_length" title="Example 4-8. Accessing the length and maximum length fields of a string">Example 4-8</a>. In the future, the definition of an HLA string may change slightly. In particular, the offsets to the maximum length and length fields are subject to change. A safer way to access string data is to coerce your string pointer using the <code class="literal">str.strRec</code> data type. The <code class="literal">str.strRec</code> data type is a <code class="literal">record</code> data type (see <a class="xref" href="ch04s25.html" title="4.25 Records">4.25 Records</a>) that defines symbolic names for the offsets of the length and maximum length fields in the <code class="literal">string</code> data type. If the offsets to the length and maximum length fields were to change in a future version of HLA, then the definitions in <code class="literal">str.strRec</code> would also change. So if you use <code class="literal">str.strRec</code>, then recompiling your program would automatically make any necessary changes to your program.<a class="indexterm" id="IDX-CHP-4-0095"/><a class="indexterm" id="IDX-CHP-4-0096"/></p><p>To use the <code class="literal">str.strRec</code> data type properly, you must first load the string pointer into a 32-bit register; for example, <code class="literal">mov( SomeString, ebx );</code>. Once the pointer to the string data is in a register, you can coerce that register to the <code class="literal">str.strRec</code> data type using the HLA construct <code class="literal">(type str.strRec [ebx])</code>. Finally, to access the length or maximum length fields, you would use either <code class="literal">(type str.strRec [ebx]).length</code> or <code class="literal">(type str.strRec [ebx]).maxlen</code> (respectively). Although there is a little more typing involved (versus using simple offsets like −4 or −8), these forms are far more descriptive and much safer than straight numeric offsets. The program in <a class="xref" href="ch04s08.html#correct_way_to_access_the_length_and_max" title="Example 4-9. Correct way to access the length and maxlen fields of a string">Example 4-9</a> corrects the example in <a class="xref" href="ch04s08.html#accessing_the_length_and_maximum_length" title="Example 4-8. Accessing the length and maximum length fields of a string">Example 4-8</a> by using the <code class="literal">str.strRec</code> data type.<a class="indexterm" id="IDX-CHP-4-0097"/></p><div class="example"><a id="correct_way_to_access_the_length_and_max"/><p class="title">Example 4-9. Correct way to access the <code class="literal">length</code> and <code class="literal">maxlen</code> fields of a string</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate accessing length and maxlen fields of a string

program LenMaxlenDemo;
#include( "stdlib.hhf" );

static
    theString:string := "String of length 19";

begin LenMaxlenDemo;

    mov( theString, ebx );  // Get pointer to the string.

    mov( (type str.strRec [ebx]).length, eax );  // Get current length.
    mov( (type str.strRec [ebx]).maxlen, ecx );  // Get maximum length.

    stdout.put
    (
        "theString = ", theString, "'", nl,
        "length( theString )= ", (type uns32 eax ), nl,
        "maxLength( theString )= ", (type uns32 ecx ), nl
    );

end LenMaxlenDemo;</pre></div></div><p>A second way to manipulate strings in HLA is to allocate storage on the heap to hold string data. Because strings can't directly use pointers returned by <code class="literal">mem.alloc</code> (string operations access the 8 bytes prior to the address), you shouldn't use <code class="literal">mem.alloc</code> to allocate storage for string data. Fortunately, the HLA Standard Library memory module provides a memory allocation routine specifically designed to allocate storage for strings: <code class="literal">str.alloc</code>. Like <code class="literal">mem.alloc</code>, <code class="literal">str.alloc</code> expects a single double-word parameter. This value specifies the maximum number of characters allowed in the string. The <code class="literal">str.alloc</code> routine will allocate the specified number of bytes of memory, plus between 9 and 13 additional bytes to hold the extra string information.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-7" id="CHP-4-FN-7">53</a>]</sup><a class="indexterm" id="IDX-CHP-4-0098"/><a class="indexterm" id="IDX-CHP-4-0099"/></p><p>The <code class="literal">str.alloc</code> routine will allocate storage for a string, initialize the maximum length to the value passed as the <code class="literal">str.alloc</code> parameter, initialize the current length to 0, and store a zero-terminating byte in the first character position of the string. After this, <code class="literal">str.alloc</code> returns the address of the zero-terminating byte (that is, the address of the first character element) in the EAX register.</p><p>Once you've allocated storage for a string, you can call various string-manipulation routines in the HLA Standard Library to manipulate the string. The next section discusses a few of the HLA string routines in detail; this section introduces a couple of string-related routines for the sake of example. The first such routine is the <code class="literal">stdin.gets(</code> <em class="replaceable"><code>strvar</code></em> <code class="literal">);</code>. This routine reads a string from the user and stores the string data into the string storage pointed at by the string parameter (<em class="replaceable"><code>strvar</code></em> in this case). If the user attempts to enter more characters than the maximum the string allows, then <code class="literal">stdin.gets</code> raises the <code class="literal">ex.StringOverflow</code> exception. The program in <a class="xref" href="ch04s08.html#reading_a_string_from_the_user" title="Example 4-10. Reading a string from the user">Example 4-10</a> demonstrates the use of <code class="literal">str.alloc</code>.<a class="indexterm" id="IDX-CHP-4-0100"/><a class="indexterm" id="IDX-CHP-4-0101"/></p><div class="example"><a id="reading_a_string_from_the_user"/><p class="title">Example 4-10. Reading a string from the user</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate str.alloc and stdin.gets

program strallocDemo;
#include( "stdlib.hhf" );

static
    theString:string;

begin strallocDemo;

    str.alloc( 16 );         // Allocate storage for the string and store
    mov( eax, theString );   // the pointer into the string variable.

    // Prompt the user and read the string from the user:

    stdout.put( "Enter a line of text (16 chars, max): " );
    stdin.flushInput();
    stdin.gets( theString );

    // Echo the string back to the user:

    stdout.put( "The string you entered was: ", theString, nl );

end strallocDemo;</pre></div></div><p>If you look closely, you'll see a slight defect in the program above. It allocates storage for the string by calling <code class="literal">str.alloc</code>, but it never frees the storage allocated. Even though the program immediately exits after the last use of the string variable, and the operating system will deallocate the storage, it's always a good idea to explicitly free up any storage you allocate. Doing so keeps you in the habit of freeing allocated storage (so you don't forget to do it when it's important); also, programs have a way of growing such that an innocent defect that doesn't affect anything in today's program becomes a show-stopping defect in tomorrow's version.</p><p>To free storage you allocate via <code class="literal">str.alloc</code>, you must call the <code class="literal">str.free</code> routine, passing the string pointer as the single parameter. The program in <a class="xref" href="ch04s08.html#corrected_program_that_reads_a_string_fr" title="Example 4-11. Corrected program that reads a string from the user">Example 4-11</a> is a correction of the program <a class="xref" href="ch04s08.html#reading_a_string_from_the_user" title="Example 4-10. Reading a string from the user">Example 4-10</a> with this defect corrected.<a class="indexterm" id="IDX-CHP-4-0102"/></p><div class="example"><a id="corrected_program_that_reads_a_string_fr"/><p class="title">Example 4-11. Corrected program that reads a string from the user</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate str.alloc, str.free, and stdin.gets

program strfreeDemo;
#include( "stdlib.hhf" );

static
    theString:string;

begin strfreeDemo;

    str.alloc( 16 );         // Allocate storage for the string and store
    mov( eax, theString );   // the pointer into the string variable.

    // Prompt the user and read the string from the user:

    stdout.put( "Enter a line of text (16 chars, max): " );
    stdin.flushInput();
    stdin.gets( theString );

    // Echo the string back to the user:

    stdout.put( "The string you entered was: ", theString, nl );

    // Free up the storage allocated by str.alloc:

    str.free( theString );

end strfreeDemo;</pre></div></div><p>When looking at this corrected program, please take note that the <code class="literal">stdin.gets</code> routine expects you to pass it a string parameter that points at an allocated string object. Without question, one of the most common mistakes beginning HLA programmers make is to call <code class="literal">stdin.gets</code> and pass it a string variable that they have not initialized. This may be getting old now, but keep in mind that <span class="emphasis"><em>strings are pointers!</em></span> Like pointers, if you do not initialize a string with a valid address, your program will probably crash when you attempt to manipulate that string object. The call to <code class="literal">str.alloc</code> and the following <code class="literal">mov</code> instruction is how the programs above initialize the string pointer. If you are going to use string variables in your programs, you must ensure that you allocate storage for the string data prior to writing data to the string object.<a class="indexterm" id="IDX-CHP-4-0103"/><a class="indexterm" id="IDX-CHP-4-0104"/></p><p>Allocating storage for a string is such a common operation that many HLA Standard Library routines will automatically allocate the storage for you. Generally, such routines have an <code class="literal">a_</code> prefix as part of their name. For example, the <code class="literal">stdin.a_gets</code> combines a call to <code class="literal">str.alloc</code> and <code class="literal">stdin.gets</code> into the same routine. This routine, which doesn't have any parameters, reads a line of text from the user, allocates a string object to hold the input data, and then returns a pointer to the string in the EAX register. <a class="xref" href="ch04s08.html#reading_a_string_from_the_user_with_stdi" title="Example 4-12. Reading a string from the user with stdin.a_gets">Example 4-12</a> presents an adaptation of the two programs in <a class="xref" href="ch04s08.html#reading_a_string_from_the_user" title="Example 4-10. Reading a string from the user">Example 4-10</a> and <a class="xref" href="ch04s08.html#corrected_program_that_reads_a_string_fr" title="Example 4-11. Corrected program that reads a string from the user">Example 4-11</a> that uses <code class="literal">stdin.a_gets</code>.<a class="indexterm" id="IDX-CHP-4-0105"/></p><div class="example"><a id="reading_a_string_from_the_user_with_stdi"/><p class="title">Example 4-12. Reading a string from the user with <code class="literal">stdin.a_gets</code></p><div class="example-contents"><pre class="programlisting">// Program to demonstrate str.free and stdin.a_gets

program strfreeDemo2;
#include( "stdlib.hhf" );

static
    theString:string;

begin strfreeDemo2;


    // Prompt the user and read the string from the user:

    stdout.put( "Enter a line of text: " );
    stdin.flushInput();
    stdin.a_gets();
    mov( eax, theString );

    // Echo the string back to the user:

    stdout.put( "The string you entered was: ", theString, nl );

    // Free up the storage allocated by stdin.a_gets:

    str.free( theString );

end strfreeDemo2;</pre></div></div><p>Note that, as before, you must still free up the storage <code class="literal">stdin.a_gets</code> allocates by calling the <code class="literal">str.free</code> routine. One big difference between this routine and the previous two is the fact that HLA will automatically allocate exactly enough space for the string read from the user. In the previous programs, the call to <code class="literal">str.alloc</code> allocates only 16 bytes. If the user types more than 16 characters, then the program raises an exception and quits. If the user types fewer than 16 characters, then some space at the end of the string is wasted. The <code class="literal">stdin.a_gets</code> routine, on the other hand, always allocates the minimum necessary space for the string read from the user. Because it allocates the storage, there is little chance of overflow.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-8" id="CHP-4-FN-8">54</a>]</sup><a class="indexterm" id="IDX-CHP-4-0106"/><a class="indexterm" id="IDX-CHP-4-0107"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-6" id="ftn.CHP-4-FN-6">52</a>] </sup>Note that this scheme is not recommended. If you need to extract the length information from a string, use the routines provided in the HLA string library for this purpose.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-7" id="ftn.CHP-4-FN-7">53</a>] </sup><code class="literal">str.alloc</code> may allocate more than 9 bytes for the overhead data because the memory allocated to an HLA string must always be double-word aligned, and the total length of the data structure must be a multiple of 4.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-8" id="ftn.CHP-4-FN-8">54</a>] </sup>Actually, there are limits on the maximum number of characters that <code class="literal">stdin.a_gets</code> will allocate. This is typically between 1,024 bytes and 4,096 bytes. See the HLA Standard Library source listings and your operating system documentation for the exact value.</p></div></div></div>
<div class="sect1" title="4.9 Accessing the Characters Within a String"><div class="titlepage"><div><div><h1 class="title"><a id="accessing_the_characters_within_a_string"/>4.9 Accessing the Characters Within a String</h1></div></div></div><p>Extracting individual characters from a string is a very common task. It is so easy that HLA doesn't provide any specific procedure or language syntax to accomplish this—you simply use machine instructions to accomplish this. Once you have a pointer to the string data, a simple indexed addressing mode will do the rest of the work for you.</p><p>Of course, the most important thing to keep in mind is that <span class="emphasis"><em>strings are pointers</em></span>. Therefore, you cannot apply an indexed addressing mode directly to a string variable and expect to extract characters from the string. That is, if <code class="literal">s</code> is a string variable, then <code class="literal">mov( s[ebx], al )</code>; does not fetch the character at position EBX in string <code class="literal">s</code> and place it in the AL register. Remember, <code class="literal">s</code> is just a pointer variable; an addressing mode like <code class="literal">s[ebx]</code> will simply fetch the byte at offset EBX in memory starting at the address of <code class="literal">s</code> (see <a class="xref" href="ch04s09.html#incorrectly_indexing_off_a_string_variab" title="Figure 4-1. Incorrectly indexing off a string variable">Figure 4-1</a>).</p><div class="figure"><a id="incorrectly_indexing_off_a_string_variab"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17401"/><img alt="Incorrectly indexing off a string variable" src="tagoreillycom20100401nostarchimages577979.png"/></div></div><p class="title">Figure 4-1. Incorrectly indexing off a string variable</p></div><p>In <a class="xref" href="ch04s09.html#incorrectly_indexing_off_a_string_variab" title="Figure 4-1. Incorrectly indexing off a string variable">Figure 4-1</a>, assuming EBX contains 3, <code class="literal">s[ebx]</code> does not access the fourth character in the string <code class="literal">s</code>; instead it fetches the fourth byte of the pointer to the string data. It is very unlikely that this is what you would want. <a class="xref" href="ch04s09.html#correctly_indexing_off_the_value_of_a_st" title="Figure 4-2. Correctly indexing off the value of a string variable">Figure 4-2</a> shows the operation that is necessary to fetch a character from the string, assuming EBX contains the value of <code class="literal">s</code>.</p><div class="figure"><a id="correctly_indexing_off_the_value_of_a_st"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17424"/><img alt="Correctly indexing off the value of a string variable" src="tagoreillycom20100401nostarchimages577981.png"/></div></div><p class="title">Figure 4-2. Correctly indexing off the value of a string variable</p></div><p>In <a class="xref" href="ch04s09.html#correctly_indexing_off_the_value_of_a_st" title="Figure 4-2. Correctly indexing off the value of a string variable">Figure 4-2</a> EBX contains the value of string <code class="literal">s</code>. The value of <code class="literal">s</code> is a pointer to the actual string data in memory. Therefore, EBX will point at the first character of the string when you load the value of <code class="literal">s</code> into EBX. The following code demonstrates how to access the fourth character of string <code class="literal">s</code> in this fashion:</p><a id="I_programlisting4_d1e17445"/><pre class="programlisting">mov( s, ebx );          // Get pointer to string data into ebx.
          mov( [ebx+3], al );     // Fetch the fourth character of the string.</pre><p>If you want to load the character at a variable, rather than fixed, offset into the string, then you can use one of the 80x86's scaled indexed addressing modes to fetch the character. For example, if an <code class="literal">uns32</code> variable <code class="literal">index</code> contains the desired offset into the string, you could use the following code to access the character at <code class="literal">s[index]</code>:</p><a id="I_programlisting4_d1e17458"/><pre class="programlisting">mov( s, ebx );          // Get address of string data into ebx.
          mov( index, ecx );      // Get desired offset into string.
          mov( [ebx+ecx], al );   // Get the desired character into al.</pre><p>There is only one problem with the code above—it does not check to ensure that the character at offset <code class="literal">index</code> actually exists. If <code class="literal">index</code> is greater than the current length of the string, then this code will fetch a garbage byte from memory. Unless you can a priori determine that <code class="literal">index</code> is always less than the length of the string, code like this is dangerous to use. A better solution is to check the index against the string's current length before attempting to access the character. The following code provides one way to do this:</p><a id="I_programlisting4_d1e17472"/><pre class="programlisting">mov( s, ebx );
          mov( index, ecx );
          if( ecx &lt; (type str.strRec [ebx]).length ) then

               mov( [ebx+ecx], al );

          else

               &lt;&lt; Code that handles out-of-bounds string index &gt;&gt;

          endif;</pre><p>In the <code class="literal">else</code> portion of this <code class="literal">if</code> statement you could take corrective action, print an error message, or raise an exception. If you want to explicitly raise an exception, you can use the HLA <code class="literal">raise</code> statement to accomplish this. The syntax for the <code class="literal">raise</code> statement is<a class="indexterm" id="IDX-CHP-4-0108"/><a class="indexterm" id="IDX-CHP-4-0109"/></p><a id="I_programlisting4_d1e17496"/><pre class="programlisting">raise( <em class="replaceable"><code>integer_constant</code></em> );
raise( <em class="replaceable"><code>reg32</code></em> );</pre><p>The value of the <em class="replaceable"><code>integer_constant</code></em> or 32-bit register must be an exception number. Usually, this is one of the predefined constants in the <span class="emphasis"><em>excepts.hhf</em></span> header file. An appropriate exception to raise when a string index is greater than the length of the string is <code class="literal">ex.StringIndexError</code>. The following code demonstrates raising this exception if the string index is out of bounds:<a class="indexterm" id="IDX-CHP-4-0110"/></p><a id="I_programlisting4_d1e17520"/><pre class="programlisting">mov( s, ebx );
          mov( index, ecx );
          if( ecx &lt; (type str.strRec [ebx]).length ) then

               mov( [ebx+ecx], al );

          else

               raise( ex.StringIndexError );

          endif;</pre></div>
<div class="sect1" title="4.10 The HLA String Module and Other String-Related Routines"><div class="titlepage"><div><div><h1 class="title"><a id="the_hla_string_module_and_other_string-r"/>4.10 The HLA String Module and Other String-Related Routines</h1></div></div></div><p>Although HLA provides a powerful definition for string data, the real power behind HLA's string capabilities lies in the HLA Standard Library, not in the definition of HLA string data. HLA provides hundreds of string-manipulation routines that far exceed the capabilities found in standard high-level languages like C/C++, Java, or Pascal; indeed, HLA's string-handling capabilities rival those in string-processing languages like Icon or SNOBOL4. This chapter discusses several of the string functions that the HLA Standard Library provides.</p><p>Perhaps the most basic string operation you will need is to assign one string to another. There are three different ways to assign strings in HLA: by reference, by copying a string, and by duplicating a string. Of these, assignment by reference is the fastest and easiest. If you have two strings and you wish to assign one string to the other, a simple and fast way to do this is to copy the string pointer. The following code fragment demonstrates this:<a class="indexterm" id="IDX-CHP-4-0111"/><a class="indexterm" id="IDX-CHP-4-0112"/></p><a id="I_programlisting4_d1e17537"/><pre class="programlisting">static
          string1:               string  := "Some String Data";
          string2:               string;
               .
               .
               .
          mov( string1, eax );
          mov( eax, string2 );
               .
               .
               .</pre><p>String assignment by reference is very efficient because it involves only two simple <code class="literal">mov</code> instructions regardless of the string length. Assignment by reference works great if you never modify the string data after the assignment operation. Do keep in mind, though, that both string variables (<code class="literal">string1</code> and <code class="literal">string2</code> in the example above) <span class="emphasis"><em>wind up pointing at the same data</em></span>. So if you make a change to the data pointed at by one string variable, you will change the string data pointed at by the second string object because both objects point at the same data. <a class="xref" href="ch04s10.html#problem_with_string_assignment_by_copyin" title="Example 4-13. Problem with string assignment by copying pointers">Example 4-13</a> provides a program that demonstrates this problem.</p><div class="example"><a id="problem_with_string_assignment_by_copyin"/><p class="title">Example 4-13. Problem with string assignment by copying pointers</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate the problem with string assignment by reference

program strRefAssignDemo;
#include( "stdlib.hhf" );

static
    string1:    string;
    string2:    string;

begin strRefAssignDemo;

    // Get a value into string1.

    forever

        stdout.put( "Enter a string with at least three characters: " );
        stdin.a_gets();
        mov( eax, string1 );

        breakif( (type str.strRec [eax]).length &gt;= 3 );

        stdout.put( "Please enter a string with at least three chars:" nl );

    endfor;

    stdout.put( "You entered: '", string1, "'" nl );

    // Do the string assignment by copying the pointer.

    mov( string1, ebx );
    mov( ebx, string2 );

    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( ""String2= '", string2, "'" nl );

    // Okay, modify the data in string1 by overwriting
    // the first three characters of the string (note that
    // a string pointer always points at the first character
    // position in the string and we know we've got at least
    // three characters here).

    mov( 'a', (type char [ebx]) );
    mov( 'b', (type char [ebx+1]) );
    mov( 'c', (type char [ebx+2]) );

    // Okay, demonstrate the problem with assignment via
    // pointer copy.

    stdout.put
    (
        "After assigning 'abc' to the first three characters in string1:"
        nl
        nl
    );
    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( "String2= '", string2, "'" nl );

    str.free( string1 );     // Don't free string2 as well!


end strRefAssignDemo;</pre></div></div><p>Because both <code class="literal">string1</code> and <code class="literal">string2</code> point at the same string data in this example, any change you make to one string is reflected in the other. While this is sometimes acceptable, most programmers expect assignment to produce a different copy of a string; that is, they expect the semantics of string assignment to produce two unique copies of the string data.<a class="indexterm" id="IDX-CHP-4-0113"/><a class="indexterm" id="IDX-CHP-4-0114"/></p><p>An important point to remember when using <span class="emphasis"><em>copy by reference</em></span> (this term means copying a pointer) is that you have created an alias of the string data. The term <span class="emphasis"><em>alias</em></span> means that you have two names for the same object in memory (for example, in the program above, <code class="literal">string1</code> and <code class="literal">string2</code> are two different names for the same string data). When you read a program, it is reasonable to expect that different variables refer to different memory objects. Aliases violate this rule, thus making your program harder to read and understand because you have to remember that aliases do not refer to different objects in memory. Failing to keep this in mind can lead to subtle bugs in your program. For instance, in the example above you have to remember that <code class="literal">string1</code> and <code class="literal">string2</code> are aliases so as not to free both objects at the end of the program. Worse still, you have to remember that <code class="literal">string1</code> and <code class="literal">string2</code> are aliases so that you don't continue to use <code class="literal">string2</code> after freeing <code class="literal">string1</code> because <code class="literal">string2</code> would be a dangling reference at that point.</p><p>Because using copy by reference makes your programs harder to read and increases the possibility that you might introduce subtle defects into your programs, you might wonder why someone would use copy by reference at all. There are two reasons for this: First, copy by reference is very efficient; it involves only the execution of two <code class="literal">mov</code> instructions. Second, some algorithms actually depend on copy-by-reference semantics. Nevertheless, before using this technique you should carefully consider whether copying string pointers is the appropriate way to do a string assignment in your program.</p><p>The second way to assign one string to another is to copy the string data. The HLA Standard Library <code class="literal">str.cpy</code> routine provides this capability. A call to the <code class="literal">str.cpy</code> procedure uses the following call syntax:<sup>[<a class="footnote" href="#ftn.CHP-4-FN-9" id="CHP-4-FN-9">55</a>]</sup><a class="indexterm" id="IDX-CHP-4-0115"/></p><a id="I_programlisting4_d1e17636"/><pre class="programlisting">str.cpy( <em class="replaceable"><code>source_string</code></em>, <em class="replaceable"><code>destination_string</code></em> );</pre><p>The source and destination strings must be string variables (pointers) or 32-bit registers containing the addresses of the string data in memory.</p><p>The <code class="literal">str.cpy</code> routine first checks the maximum length field of the destination string to ensure that it is at least as big as the source string's current length. If it is not, then <code class="literal">str.cpy</code> raises the <code class="literal">ex.StringOverflow</code> exception. If the destination string's maximum length is large enough, then <code class="literal">str.cpy</code> copies the string length, the characters, and the zero-terminating byte from the source string to the destination string. When this process is complete, the two strings point at identical data, but they do not point at the same data in memory.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-10" id="CHP-4-FN-10">56</a>]</sup> The program in <a class="xref" href="ch04s10.html#copying_strings_using_str.cpy" title="Example 4-14. Copying strings using str.cpy">Example 4-14</a> is a rework of the example in <a class="xref" href="ch04s10.html#problem_with_string_assignment_by_copyin" title="Example 4-13. Problem with string assignment by copying pointers">Example 4-13</a> using <code class="literal">str.cpy</code> rather than copy by reference.</p><div class="example"><a id="copying_strings_using_str.cpy"/><p class="title">Example 4-14. Copying strings using <code class="literal">str.cpy</code></p><div class="example-contents"><pre class="programlisting">// Program to demonstrate string assignment using str.cpy

program strcpyDemo;
#include( "stdlib.hhf" );

static
    string1:    string;
    string2:    string;

begin strcpyDemo;

    // Allocate storage for string2:

    str.alloc( 64 );
    mov( eax, string2 );

    // Get a value into string1.

    forever

        stdout.put( "Enter a string with at least three characters: " );
        stdin.a_gets();
        mov( eax, string1 );

        breakif( (type str.strRec [eax]).length &gt;= 3 );

        stdout.put( "Please enter a string with at least three chars:" nl );

    endfor;


    // Do the string assignment via str.cpy.

    str.cpy( string1, string2 );

    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( "String2= '", string2, "'" nl );

    // Okay, modify the data in string1 by overwriting
    // the first three characters of the string (note that
    // a string pointer always points at the first character
    // position in the string and we know we've got at least
    // three characters here).

    mov( string1, ebx );
    mov( 'a', (type char [ebx]) );
    mov( 'b', (type char [ebx+1]) );
    mov( 'c', (type char [ebx+2]) );

    // Okay, demonstrate that we have two different strings
    // because we used str.cpy to copy the data:

    stdout.put
    (
        "After assigning 'abc' to the first three characters in string1:"
        nl
        nl
    );
    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( "String2= '", string2, "'" nl );


    // Note that we have to free the data associated with both
    // strings because they are not aliases of one another.

    str.free( string1 );
    str.free( string2 );


end strcpyDemo;</pre></div></div><p>There are two important things to note about the program in <a class="xref" href="ch04s10.html#copying_strings_using_str.cpy" title="Example 4-14. Copying strings using str.cpy">Example 4-14</a>. First, note that this program begins by allocating storage for <code class="literal">string2</code>. Remember, the <code class="literal">str.cpy</code> routine does not allocate storage for the destination string; it assumes that the destination string already has storage allocated. Keep in mind that <code class="literal">str.cpy</code> does not initialize <code class="literal">string2</code>; it only copies data to the location where <code class="literal">string2</code> is pointing. It is the program's responsibility to initialize the string by allocating sufficient memory before calling <code class="literal">str.cpy</code>. The second thing to notice here is that the program calls <code class="literal">str.free</code> to free up the storage for both <code class="literal">string1</code> and <code class="literal">string2</code> before the program quits.<a class="indexterm" id="IDX-CHP-4-0116"/></p><p>Allocating storage for a string variable prior to calling <code class="literal">str.cpy</code> is so common that the HLA Standard Library provides a routine that allocates and copies the string: <code class="literal">str.a_cpy</code>. This routine uses the following call syntax:<a class="indexterm" id="IDX-CHP-4-0117"/></p><a id="I_programlisting4_d1e17733"/><pre class="programlisting">str.a_cpy( <em class="replaceable"><code>source_string</code></em> );</pre><p>Note that there is no destination string. This routine looks at the length of the source string, allocates sufficient storage, makes a copy of the string, and then returns a pointer to the new string in the EAX register. The program in <a class="xref" href="ch04s10.html#copying_strings_using_str.a_underscore_c" title="Example 4-15. Copying strings using str.a_cpy">Example 4-15</a> demonstrates how to do the same thing as the program in <a class="xref" href="ch04s10.html#copying_strings_using_str.cpy" title="Example 4-14. Copying strings using str.cpy">Example 4-14</a> using the <code class="literal">str.a_cpy</code> procedure.</p><div class="example"><a id="copying_strings_using_str.a_underscore_c"/><p class="title">Example 4-15. Copying strings using <code class="literal">str.a_cpy</code></p><div class="example-contents"><pre class="programlisting">// Program to demonstrate string assignment using str.a_cpy

program stra_cpyDemo;
#include( "stdlib.hhf" );

static
    string1:    string;
    string2:    string;

begin stra_cpyDemo;


    // Get a value into string1.

    forever

        stdout.put( "Enter a string with at least three characters: " );
        stdin.a_gets();
        mov( eax, string1 );

        breakif( (type str.strRec [eax]).length &gt;= 3 );

        stdout.put( "Please enter a string with at least three chars:" nl );

    endfor;


    // Do the string assignment via str.a_cpy.

    str.a_cpy( string1 );
    mov( eax, string2 );

    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( "String2= '", string2, "'" nl );

    // Okay, modify the data in string1 by overwriting
    // the first three characters of the string (note that
    // a string pointer always points at the first character
    // position in the string and we know we've got at least
    // three characters here).

    mov( string1, ebx );
    mov( 'a', (type char [ebx]) );
    mov( 'b', (type char [ebx+1]) );
    mov( 'c', (type char [ebx+2]) );

    // Okay, demonstrate that we have two different strings
    // because we used str.cpy to copy the data:

    stdout.put
    (
        "After assigning 'abc' to the first three characters in string1:"
        nl
        nl
    );
    stdout.put( "String1= '", string1, "'" nl );
    stdout.put( "String2= '", string2, "'" nl );


    // Note that we have to free the data associated with both
    // strings because they are not aliases of one another.

    str.free( string1 );
    str.free( string2 );


end stra_cpyDemo;</pre></div></div><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Whenever you use copy by reference or <code class="literal">str.a_cpy</code> to assign a string, don't forget to free the storage associated with the string when you have (completely) finished with that string's data. Failure to do so may produce a memory leak if you do not have another pointer to the previous string data lying around.<a class="indexterm" id="IDX-CHP-4-0118"/></p></div><p>Obtaining the length of a character string is so common that the HLA Standard Library provides a <code class="literal">str.length</code> routine specifically for this purpose. Of course, you can fetch the length by using the <code class="literal">str.strRec</code> data type to access the length field directly, but constant use of this mechanism can be tiring because it involves a lot of typing. The <code class="literal">str.length</code> routine provides a more compact and convenient way to fetch the length information. You call <code class="literal">str.length</code> using one of the following two formats:<a class="indexterm" id="IDX-CHP-4-0119"/></p><a id="I_programlisting4_d1e17782"/><pre class="programlisting">str.length( <em class="replaceable"><code>Reg32</code></em> );
str.length( <em class="replaceable"><code>string_variable</code></em> );</pre><p>This routine returns the current string length in the EAX register.</p><p>Another pair of useful string routines is the <code class="literal">str.cat</code> and <code class="literal">str.a_cat</code> procedures. They use the following syntax:<a class="indexterm" id="IDX-CHP-4-0120"/><a class="indexterm" id="IDX-CHP-4-0121"/></p><a id="I_programlisting4_d1e17811"/><pre class="programlisting">str.cat( <em class="replaceable"><code>srcRStr</code></em>, <em class="replaceable"><code>destLStr</code></em> );
str.a_cat( <em class="replaceable"><code>srcLStr</code></em>, <em class="replaceable"><code>srcRStr</code></em> );</pre><p>These two routines concatenate two strings (that is, they create a new string by joining the two strings together). The <code class="literal">str.cat</code> procedure concatenates the source string to the end of the destination string. Before the concatenation actually takes place, <code class="literal">str.cat</code> checks to make sure that the destination string is large enough to hold the concatenated result, and it raises the <code class="literal">ex.StringOverflow</code> exception if the destination string's maximum length is too small.<a class="indexterm" id="IDX-CHP-4-0122"/><a class="indexterm" id="IDX-CHP-4-0123"/><a class="indexterm" id="IDX-CHP-4-0124"/></p><p>The <code class="literal">str.a_cat</code> routine, as its name suggests, allocates storage for the resulting string before doing the concatenation. This routine will allocate sufficient storage to hold the concatenated result, then it will copy the <code class="literal">srcLStr</code> to the allocated storage, next it will append the string data pointed at by <code class="literal">srcRStr</code> to the end of this new string, and then it will return a pointer to the new string in the EAX register.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Note a potential source of confusion. The <code class="literal">str.cat</code> procedure concatenates its first operand to the end of the second operand. Therefore, <code class="literal">str.cat</code> follows the standard <code class="literal">(src, dest)</code> operand format present in many HLA statements. The <code class="literal">str.a_cat</code> routine, on the other hand, has two source operands rather than a source operand and a destination operand. The <code class="literal">str.a_cat</code> routine concatenates its two operands in an intuitive left-to-right fashion. This is the opposite of <code class="literal">str.cat</code>. Keep this in mind when using these two routines.</p></div><p><a class="xref" href="ch04s10.html#demonstration_of_str.cat_and_str.a_under" title="Example 4-16. Demonstration of str.cat and str.a_cat routines">Example 4-16</a> demonstrates the use of the <code class="literal">str.cat</code> and <code class="literal">str.a_cat</code> routines.</p><div class="example"><a id="demonstration_of_str.cat_and_str.a_under"/><p class="title">Example 4-16. Demonstration of <code class="literal">str.cat</code> and <code class="literal">str.a_cat</code> routines</p><div class="example-contents"><pre class="programlisting">// Program to demonstrate str.cat and str.a_cat

program strcatDemo;
#include( "stdlib.hhf" );

static
    UserName:   string;
    Hello:      string;
    a_Hello:    string;

begin strcatDemo;

    // Allocate storage for the concatenated result:

    str.alloc( 1024 );
    mov( eax, Hello );

    // Get some user input to use in this example:

    stdout.put( "Enter your name: " );
    stdin.flushInput();
    stdin.a_gets();
    mov( eax, UserName );

    // Use str.cat to combine the two strings:

    str.cpy( "Hello ", Hello );
    str.cat( UserName, Hello );

    // Use str.a_cat to combine the string strings:

    str.a_cat( "Hello ", UserName );
    mov( eax, a_Hello );

    stdout.put( "Concatenated string #1 is '", Hello, "'" nl );
    stdout.put( "Concatenated string #2 is '", a_Hello, "'" nl );

    str.free( UserName );
    str.free( a_Hello );
    str.free( Hello );

end strcatDemo;</pre></div></div><p>The <code class="literal">str.insert</code> and <code class="literal">str.a_insert</code> routines are similar to the string-concatenation procedures. However, the <code class="literal">str.insert</code> and <code class="literal">str.a_insert</code> routines let you insert one string anywhere into another string, not just at the end of the string. The calling sequences for these two routines are:<a class="indexterm" id="IDX-CHP-4-0125"/><a class="indexterm" id="IDX-CHP-4-0126"/></p><a id="I_programlisting4_d1e17926"/><pre class="programlisting">str.insert( <em class="replaceable"><code>src</code></em>, <em class="replaceable"><code>dest</code></em>, <em class="replaceable"><code>index</code></em> );
                    str.a_insert( <em class="replaceable"><code>src</code></em>, <em class="replaceable"><code>dest</code></em>, <em class="replaceable"><code>index</code></em> );</pre><p>These two routines insert the source string (<em class="replaceable"><code>src</code></em>) into the destination string (<em class="replaceable"><code>dest</code></em>) starting at character position <em class="replaceable"><code>index</code></em>. The <code class="literal">str.insert</code> routine inserts the source string directly into the destination string; if the destination string is not large enough to hold both strings, <code class="literal">str.insert</code> raises an <code class="literal">ex.StringOverflow</code> exception. The <code class="literal">str.a_insert</code> routine first allocates storage for a new string on the heap, copies the destination string (<em class="replaceable"><code>src</code></em>) to the new string, and then inserts the source string (<em class="replaceable"><code>dest</code></em>) into this new string at the specified offset; <code class="literal">str.a_insert</code> returns a pointer to the new string in the EAX register.<a class="indexterm" id="IDX-CHP-4-0127"/><a class="indexterm" id="IDX-CHP-4-0128"/></p><p>Indexes into a string are zero based. This means that if you supply the value 0 as the index in <code class="literal">str.insert</code> or <code class="literal">str.a_insert</code>, then these routines will insert the source string before the first character of the destination string. Likewise, if the <em class="replaceable"><code>index</code></em> is equal to the length of the string, then these routines will simply concatenate the source string to the end of the destination string.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>If the <code class="literal">index</code> is greater than the length of the string, the <code class="literal">str.insert</code> and <code class="literal">str.a_insert</code> procedures will not raise an exception; instead, they will simply append the source string to the end of the destination string.</p></div><p>The <code class="literal">str.delete</code> and <code class="literal">str.a_delete</code> routines let you remove characters from a string. They use the following calling sequence:<a class="indexterm" id="IDX-CHP-4-0129"/><a class="indexterm" id="IDX-CHP-4-0130"/></p><a id="I_programlisting4_d1e18031"/><pre class="programlisting">str.delete( <em class="replaceable"><code>strng</code></em>, <em class="replaceable"><code>StartIndex</code></em>, <em class="replaceable"><code>Length</code></em> );
str.a_delete( <em class="replaceable"><code>strng</code></em>, <em class="replaceable"><code>StartIndex</code></em>, <em class="replaceable"><code>Length</code></em> );</pre><p>Both routines delete <em class="replaceable"><code>Length</code></em> characters starting at character position <em class="replaceable"><code>StartIndex</code></em> in string <em class="replaceable"><code>strng</code></em>. The difference between the two is that <code class="literal">str.delete</code> deletes the characters directly from <em class="replaceable"><code>strng</code></em>, whereas <code class="literal">str.a_delete</code> first allocates storage and copies <em class="replaceable"><code>strng</code></em> and then deletes the characters from the new string (leaving <em class="replaceable"><code>strng</code></em> untouched). The <code class="literal">str.a_delete</code> routine returns a pointer to the new string in the EAX register.</p><p>The <code class="literal">str.delete</code> and <code class="literal">str.a_delete</code> routines are very forgiving with respect to the values you pass in <em class="replaceable"><code>StartIndex</code></em> and <em class="replaceable"><code>Length</code></em>. If <em class="replaceable"><code>StartIndex</code></em> is greater than the current length of the string, these routines do not delete any characters from the string. If <em class="replaceable"><code>StartIndex</code></em> is less than the current length of the string, but <em class="replaceable"><code>StartIndex</code></em>+<em class="replaceable"><code>Length</code></em> is greater than the length of the string, then these routines will delete all characters from <em class="replaceable"><code>StartIndex</code></em> to the end of the string.</p><p>Another very common string operation is the need to copy a portion of a string to another string without otherwise affecting the source string. The <code class="literal">str.substr</code> and <code class="literal">str.a_substr</code> routines provide this capability. These routines use the following syntax:<a class="indexterm" id="IDX-CHP-4-0131"/><a class="indexterm" id="IDX-CHP-4-0132"/></p><a id="I_programlisting4_d1e18130"/><pre class="programlisting">str.substr( <em class="replaceable"><code>src</code></em>, <em class="replaceable"><code>dest</code></em>, <em class="replaceable"><code>StartIndex</code></em>, <em class="replaceable"><code>Length</code></em> );
str.a_substr( <em class="replaceable"><code>src</code></em>, <em class="replaceable"><code>StartIndex</code></em>, <em class="replaceable"><code>Length</code></em> );</pre><p>The <code class="literal">str.substr</code> routine copies <em class="replaceable"><code>Length</code></em> characters, starting at position <em class="replaceable"><code>StartIndex</code></em>, from the <em class="replaceable"><code>src</code></em> string to the <em class="replaceable"><code>dest</code></em> string. The dest string must have sufficient storage to hold the new string or <code class="literal">str.substr</code> will raise an <code class="literal">ex.StringOverflow</code> exception. If the <em class="replaceable"><code>StartIndex</code></em> value is greater than the length of the string, then <code class="literal">str.substr</code> will raise an <code class="literal">ex.StringIndexError</code> exception. If <em class="replaceable"><code>StartIndex</code></em>+<em class="replaceable"><code>Length</code></em> is greater than the length of the source string, but <em class="replaceable"><code>StartIndex</code></em> is less than the length of the string, then <code class="literal">str.substr</code> will extract only those characters from <em class="replaceable"><code>StartIndex</code></em> to the end of the string.<a class="indexterm" id="IDX-CHP-4-0133"/><a class="indexterm" id="IDX-CHP-4-0134"/><a class="indexterm" id="IDX-CHP-4-0135"/><a class="indexterm" id="IDX-CHP-4-0136"/><a class="indexterm" id="IDX-CHP-4-0137"/><a class="indexterm" id="IDX-CHP-4-0138"/><a class="indexterm" id="IDX-CHP-4-0139"/></p><p>The <code class="literal">str.a_substr</code> procedure behaves in a fashion nearly identical to <code class="literal">str.substr</code>, except it allocates storage on the heap for the destination string. <code class="literal">str.a_substr</code> handles exceptions identically to <code class="literal">str.substr</code>, except it never raises a string overflow exception because this will never occur.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-11" id="CHP-4-FN-11">57</a>]</sup> As you can probably guess by now, <code class="literal">str.a_substr</code> returns a pointer to the newly allocated string in the EAX register.</p><p>After you have been working with string data for a little while, the need will invariably arise to compare two strings. A first attempt at string comparison, using the standard HLA relational operators, will compile but not necessarily produce the desired result:<a class="indexterm" id="IDX-CHP-4-0140"/></p><a id="I_programlisting4_d1e18278"/><pre class="programlisting">mov( s1, eax );
     if( eax = s2 ) then

          &lt;&lt; Code to execute if the strings are equal &gt;&gt;

     else

          &lt;&lt; Code to execute if the strings are not equal &gt;&gt;

     endif;</pre><p>Remember, <span class="emphasis"><em>strings are pointers</em></span>. This code compares the two pointers to see if they are equal. If they are equal, clearly the two strings are equal (because both <code class="literal">s1</code> and <code class="literal">s2</code> point at the exact same string data). However, the fact that the two pointers are different doesn't necessarily mean that the strings are not equivalent. Both <code class="literal">s1</code> and <code class="literal">s2</code> could contain different values (that is, they point at different addresses in memory), yet the string data at those two addresses could be identical. Most programmers expect a string comparison for equality to be true if the data for the two strings is the same. Clearly a pointer comparison does not provide this type of comparison. To overcome this problem, the HLA Standard Library provides a set of string-comparison routines that will compare the string data, not just their pointers. These routines use the following calling sequences:</p><a id="I_programlisting4_d1e18297"/><pre class="programlisting">str.eq( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ne( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.lt( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.le( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.gt( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ge( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );</pre><p>Each of these routines compares the <em class="replaceable"><code>src1</code></em> string to the <em class="replaceable"><code>src2</code></em> string and returns true (1) or false (0) in the EAX register depending on the comparison. For example, <code class="literal">str.eq( s1, s2);</code> returns true in EAX if <code class="literal">s1</code> is equal to <code class="literal">s2</code>. HLA provides a small extension that allows you to use the string-comparison routines within an <code class="literal">if</code> statement.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-12" id="CHP-4-FN-12">58</a>]</sup> The following code demonstrates the use of some of these comparison routines within an <code class="literal">if</code> statement:<a class="indexterm" id="IDX-CHP-4-0141"/><a class="indexterm" id="IDX-CHP-4-0142"/><a class="indexterm" id="IDX-CHP-4-0143"/><a class="indexterm" id="IDX-CHP-4-0144"/><a class="indexterm" id="IDX-CHP-4-0145"/><a class="indexterm" id="IDX-CHP-4-0146"/><a class="indexterm" id="IDX-CHP-4-0147"/></p><a id="I_programlisting4_d1e18403"/><pre class="programlisting">stdout.put( "Enter a single word: " );
          stdin.a_gets();
          if( str.eq( eax, "Hello" )) then

               stdout.put( "You entered 'Hello'", nl );

          endif;
          str.free( eax );</pre><p>Note that the string the user enters in this example must exactly match <code class="literal">Hello</code>, including the use of an uppercase <span class="emphasis"><em>H</em></span> at the beginning of the string. When processing user input, it is best to ignore alphabetic case in string comparisons because different users have different ideas about when they should be pressing the SHIFT key on the keyboard. An easy solution is to use the HLA case-insensitive string-comparison functions. These routines compare two strings, ignoring any differences in alphabetic case. These routines use the following calling sequences:<a class="indexterm" id="IDX-CHP-4-0148"/></p><a id="I_programlisting4_d1e18416"/><pre class="programlisting">str.ieq( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ine( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ilt( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ile( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.igt( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );
str.ige( <em class="replaceable"><code>src1</code></em>, <em class="replaceable"><code>src2</code></em> );</pre><p>Other than they treat uppercase characters the same as their lowercase equivalents, these routines behave exactly like the former routines, returning true or false in EAX depending on the result of the comparison.</p><p>Like most high-level languages, HLA compares strings using <span class="emphasis"><em>lexicographical ordering</em></span>. This means that two strings are equal if and only if their lengths are the same and the corresponding characters in the two strings are exactly the same. For less-than or greater-than comparisons, lexicographical ordering corresponds to the way words appear in a dictionary. That is, <code class="literal">a</code> is less than <code class="literal">b</code> is less than <code class="literal">c</code>, and so on. Actually, HLA compares the strings using the ASCII numeric codes for the characters, so if you are unsure whether <code class="literal">a</code> is less than a period, simply consult the ASCII character chart (incidentally, <code class="literal">a</code> is greater than a period in the ASCII character set, just in case you were wondering).<a class="indexterm" id="IDX-CHP-4-0149"/></p><p>If two strings have different lengths, lexicographical ordering worries about the length only if the two strings exactly match through the length of the shorter string. If this is the case, then the longer string is greater than the shorter string (and, conversely, the shorter string is less than the longer string). Note, however, that if the characters in the two strings do not match at all, then HLA's string-comparison routines ignore the length of the string; for example, <code class="literal">z</code> is always greater than <code class="literal">aaaaa</code>, even though it is shorter.</p><p>The <code class="literal">str.eq</code> routine checks to see if two strings are equal. Sometimes, however, you might want to know whether one string <span class="emphasis"><em>contains</em></span> another string. For example, you may want to know if some string contains the substring <code class="literal">north</code> or <code class="literal">south</code> to determine some action to take in a game. The HLA <code class="literal">str.index</code> routine lets you check to see if one string is contained as a substring of another. The <code class="literal">str.index</code> routine uses the following calling sequence:<a class="indexterm" id="IDX-CHP-4-0150"/></p><a id="I_programlisting4_d1e18517"/><pre class="programlisting">str.index( <em class="replaceable"><code>StrToSearch</code></em>, <em class="replaceable"><code>SubstrToSearchFor</code></em> );</pre><p>This function returns, in EAX, the offset into <em class="replaceable"><code>StrToSearch</code></em> where <em class="replaceable"><code>SubstrToSearchFor</code></em> appears. This routine returns −1 in EAX if <em class="replaceable"><code>SubstrToSearchFor</code></em> is not present in <em class="replaceable"><code>StrToSearch</code></em>. Note that <code class="literal">str.index</code> will do a case-sensitive search. Therefore, the strings must exactly match. There is no case-insensitive variant of <code class="literal">str.index</code> you can use.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-13" id="CHP-4-FN-13">59</a>]</sup></p><p>The HLA <code class="literal">strings</code> module contains hundreds of routines besides those appearing in this section. Space limitations and prerequisite knowledge prevent the presentation of all those functions here; however, this does not mean that the remaining string functions are unimportant. You should definitely take a look at the HLA Standard Library documentation to learn everything you can about the powerful HLA string library routines.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-9" id="ftn.CHP-4-FN-9">55</a>] </sup>Warning to C/C++ users: note that the order of the operands is opposite that of the C Standard Library <code class="literal">strcpy</code> function.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-10" id="ftn.CHP-4-FN-10">56</a>] </sup>Unless, of course, both string pointers contained the same address to begin with, in which case <code class="literal">str.cpy</code> copies the string data over itself.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-11" id="ftn.CHP-4-FN-11">57</a>] </sup>Technically, <code class="literal">str.a_substr</code>, like all routines that call <code class="literal">mem.alloc</code> to allocate storage, can raise an <code class="literal">ex.MemoryAllocationFailure</code> exception, but this is very unlikely to occur.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-12" id="ftn.CHP-4-FN-12">58</a>] </sup>This extension is actually a little more general than this section describes. <a class="xref" href="ch07.html" title="Chapter 7. LOW-LEVEL CONTROL STRUCTURES">Chapter 7</a> explains it fully.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-13" id="ftn.CHP-4-FN-13">59</a>] </sup>However, HLA does provide routines that will convert all the characters in a string to one case or another. So you can make copies of the strings, convert all the characters in both copies to lowercase, and then search using these converted strings. This will achieve the same result.</p></div></div></div>
<div class="sect1" title="4.11 In-Memory Conversions"><div class="titlepage"><div><div><h1 class="title"><a id="in-memory_conversions"/>4.11 In-Memory Conversions</h1></div></div></div><p>The HLA Standard Library's <code class="literal">string</code> module contains dozens of routines for converting between strings and other data formats. Although it's a little premature in this text to present a complete description of those functions, it would be rather criminal not to discuss at least one of the available functions: the <code class="literal">str.put</code> routine. This routine encapsulates the capabilities of many of the other string-conversion functions, so if you learn how to use this one, you'll have most of the capabilities of those other routines at your disposal.<a class="indexterm" id="IDX-CHP-4-0151"/></p><p>You use the <code class="literal">str.put</code> routine in a manner very similar to the <code class="literal">stdout.put</code> routine. The only difference is that the <code class="literal">str.put</code> routine "writes" its data to a string instead of the standard output device. A call to <code class="literal">str.put</code> has the following syntax:</p><a id="I_programlisting4_d1e18584"/><pre class="programlisting">str.put( <em class="replaceable"><code>destString</code></em>, <em class="replaceable"><code>values_to_convert</code></em> );</pre><p>Here's an example of a call to <code class="literal">str.put</code>:</p><a id="I_programlisting4_d1e18597"/><pre class="programlisting">str.put( <em class="replaceable"><code>destString</code></em>, "I =", i:4, " J= ", j, " s=", s );</pre><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Generally, you would not put a newline character sequence at the end of the string as you would if you were printing the string to the standard output device.</p></div><p>The <em class="replaceable"><code>destString</code></em> parameter at the beginning of the <code class="literal">str.put</code> parameter list must be a string variable, and it must already have storage associated with it. If <code class="literal">str.put</code> attempts to store more characters than allowed into the <em class="replaceable"><code>destString</code></em> parameter, then this function raises the <code class="literal">ex.StringOverflow</code> exception.</p><p>Most of the time you won't know the length of the string that <code class="literal">str.put</code> will produce. In those instances, you should allocate storage for a very large string, one that is much larger than you expect, and use this string object as the first parameter of the <code class="literal">str.put</code> call. This will prevent an exception from crashing your program. Generally, if you expect to produce about one screen line of text, then you should probably allocate at least 256 characters for the destination string. If you're creating longer strings, you should probably use a default of 1,024 characters (or more, if you're going to produce <span class="emphasis"><em>really</em></span> large strings).</p><p>Here's an example:</p><a id="I_programlisting4_d1e18635"/><pre class="programlisting">static
     s: string;
          .
          .
          .
     str.alloc( 256 );
     mov( eax, s );
          .
          .
          .
     str.put( s, "R: ", r:16:4, " strval: '", strval:-10, "'" );</pre><p>You can use the <code class="literal">str.put</code> routine to convert any data to a string that you can print using <code class="literal">stdout.put</code>. You will probably find this routine invaluable for common value-to-string conversions.</p></div>
<div class="sect1" title="4.12 Character Sets"><div class="titlepage"><div><div><h1 class="title"><a id="character_sets"/>4.12 Character Sets</h1></div></div></div><p>Character sets are another composite data type, like strings, built upon the character data type. A character set is a mathematical set of characters with the most important attribute being membership. That is, a character is either a member of a set or it is not a member of a set. The concept of sequence (for example, whether one character comes before another, as in a string) doesn't apply to character sets. Also, membership is a binary relation; a character is either in the set or it is not in the set; you cannot have multiple copies of the same character in a character set. Various operations are possible on character sets, including the mathematical set operations of union, intersection, difference, and membership test.<a class="indexterm" id="IDX-CHP-4-0152"/></p><p>HLA implements a restricted form of character sets that allows set members to be any of the 128 standard ASCII characters (that is, HLA's character set facilities do not support extended character codes in the range 128..255). Despite this restriction, HLA's character set facilities are very powerful and are handy when writing programs that work with string data. The following sections describe the implementation and use of HLA's character set facilities so you may take advantage of character sets in your own programs.<a class="indexterm" id="IDX-CHP-4-0153"/></p></div>
<div class="sect1" title="4.13 Character Set Implementation in HLA"><div class="titlepage"><div><div><h1 class="title"><a id="character_set_implementation_in_hla"/>4.13 Character Set Implementation in HLA</h1></div></div></div><p>There are many different ways to represent character sets in an assembly language program. HLA implements character sets using an array of 128 boolean values. Each boolean value determines whether the corresponding character is a member of the character set; that is, a true boolean value indicates that the corresponding character is a member of the set, whereas a false value indicates that the character is not a member of the set. To conserve memory, HLA allocates only a single bit for each character in the set; therefore, HLA character sets consume 16 bytes of memory because there are 128 bits in 16 bytes. This array of 128 bits is organized in memory as shown in <a class="xref" href="ch04s13.html#bit_layout_of_a_character_set_object" title="Figure 4-3. Bit layout of a character set object">Figure 4-3</a>.</p><div class="figure"><a id="bit_layout_of_a_character_set_object"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18671"/><img alt="Bit layout of a character set object" src="tagoreillycom20100401nostarchimages577983.png.jpg"/></div></div><p class="title">Figure 4-3. Bit layout of a character set object</p></div><p>Bit 0 of byte 0 corresponds to ASCII code 0 (the NUL character). If this bit is 1, then the character set contains the NUL character; if this bit contains false, then the character set does not contain the NUL character. Likewise, bit 0 of byte 1 (the ninth bit in the 128-bit array) corresponds to the backspace character (ASCII code is 8). Bit 1 of byte 8 corresponds to ASCII code 65, an uppercase <code class="literal">A</code>. Bit 65 will contain a 1 if <code class="literal">A</code> is a current member of the character set; it will contain 0 if <code class="literal">A</code> is not a member of the set.</p><p>While there are other possible ways to implement character sets, with this bit-vector implementation it is very easy to implement set operations such as union, intersection, difference comparison, and membership tests.</p><p>HLA supports character set variables using the <code class="literal">cset</code> data type. To declare a character set variable, you would use a declaration like the following:</p><a id="I_programlisting4_d1e18694"/><pre class="programlisting">static
     <em class="replaceable"><code>CharSetVar</code></em>: cset;</pre><p>This declaration will reserve 16 bytes of storage to hold the 128 bits needed to represent a set of ASCII characters.</p><p>Although it is possible to manipulate the bits in a character set using instructions like <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">xor</code>, and so on, the 80x86 instruction set includes several bit test, set, reset, and complement instructions that are nearly perfect for manipulating character sets. The <code class="literal">bt</code> (bit test) instruction, for example, will copy a single bit in memory to the carry flag. The <code class="literal">bt</code> instruction allows the following syntactical forms.</p><a id="I_programlisting4_d1e18718"/><pre class="programlisting">bt( <em class="replaceable"><code>BitNumber</code></em>, <em class="replaceable"><code>BitsToTest</code></em> );

bt( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>reg16</code></em> );
bt( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>reg32</code></em> );
bt( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>reg16</code></em> );
bt( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>reg32</code></em> );

bt( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>mem16</code></em> );
bt( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>mem32</code></em> );     // HLA treats cset objects as dwords within bt.
bt( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>mem16</code></em> );
bt( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>mem32</code></em> );  // HLA treats cset objects as dwords within bt.</pre><p>The first operand holds a bit number, and the second operand specifies a register or memory location whose bit should be copied into the carry flag. If the second operand is a register, the first operand must contain a value in the range 0..<span class="emphasis"><em>n</em></span>−1, where <span class="emphasis"><em>n</em></span> is the number of bits in the second operand. If the first operand is a constant and the second operand is a memory location, the constant must be in the range 0..255. Here are some examples of these instructions:<a class="indexterm" id="IDX-CHP-4-0154"/><a class="indexterm" id="IDX-CHP-4-0155"/><a class="indexterm" id="IDX-CHP-4-0156"/><a class="indexterm" id="IDX-CHP-4-0157"/><a class="indexterm" id="IDX-CHP-4-0158"/></p><a id="I_programlisting4_d1e18805"/><pre class="programlisting">bt( 7, ax );          // Copies bit 7 of ax into the carry flag (CF).
     mov( 20, eax );
     bt( eax, ebx );       // Copies bit 20 of ebx into CF.

     // Copies bit 0 of the byte at CharSetVar+3 into CF.

     bt( 24, CharSetVar );

     // Copies bit 4 of the byte at DWmem+2 into CF.

     bt( eax, DWmem);</pre><p>The <code class="literal">bt</code> instruction turns out to be quite useful for testing set membership. For example, to see if the character <code class="literal">A</code> is a member of a character set, you could use a code sequence like the following:</p><a id="I_programlisting4_d1e18815"/><pre class="programlisting">bt( 'A', CharSetVar );
          if( @c ) then

               &lt;&lt; Do something if 'A' is a member of the set. &gt;&gt;

          endif;</pre><p>The <code class="literal">bts</code> (bit test and set), <code class="literal">btr</code> (bit test and reset), and <code class="literal">btc</code> (bit test and complement) instructions are also useful for manipulating character set variables. Like the <code class="literal">bt</code> instruction, these instructions copy the specified bit into the carry flag; after copying the specified bit, these instructions will set (<code class="literal">bts</code>), reset/clear (<code class="literal">btr</code>), or complement/invert (<code class="literal">btc</code>) the specified bit. Therefore, you can use the <code class="literal">bts</code> instruction to add a character to a character set via set union (that is, it adds a character to the set if the character was not already a member of the set; otherwise the set is unaffected). You can use the <code class="literal">btr</code> instruction to remove a character from a character set via set intersection (that is, it removes a character from the set if and only if it was previously in the set; otherwise it has no effect on the set). The <code class="literal">btc</code> instruction lets you add a character to the set if it wasn't previously in the set; it removes the character from the set if it was previously a member (that is, it toggles the membership of that character in the set).<a class="indexterm" id="IDX-CHP-4-0159"/></p></div>
<div class="sect1" title="4.14 HLA Character Set Constants and Character Set Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="hla_character_set_constants_and_characte"/>4.14 HLA Character Set Constants and Character Set Expressions</h1></div></div></div><p>HLA supports literal character set constants. These <code class="literal">cset</code> constants make it easy to initialize <code class="literal">cset</code> variables at compile time and allow you to easily pass character set constants as procedure parameters. An HLA character set constant takes the following form:</p><a id="I_programlisting4_d1e18866"/><pre class="programlisting">{ <em class="replaceable"><code>Comma_separated_list_of_characters_and_character_ranges</code></em> }</pre><p>The following is an example of a simple character set holding the numeric digit characters:</p><a id="I_programlisting4_d1e18873"/><pre class="programlisting">{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }</pre><p>When specifying a character set literal that has several contiguous values, HLA lets you concisely specify the values using only the starting and ending values of the range thusly:</p><a id="I_programlisting4_d1e18877"/><pre class="programlisting">{ '0'..'9' }</pre><p>You may combine characters and various ranges within the same character set constant. For example, the following character set constant is all the alphanumeric characters:</p><a id="I_programlisting4_d1e18881"/><pre class="programlisting">{ '0'..'9', 'a'..'z', 'A'..'Z' }</pre><p>You can use these <code class="literal">cset</code> literal constants as initializers in the <code class="literal">const</code> and <code class="literal">val</code> sections. The following example demonstrates how to create the symbolic constant <code class="literal">AlphaNumeric</code> using the character set above:</p><a id="I_programlisting4_d1e18897"/><pre class="programlisting">const
     AlphaNumeric: cset := {'0'..'9', 'a'..'z', 'A'..'Z' };</pre><p>After the above declaration, you can use the identifier <code class="literal">AlphaNumeric</code> anywhere the character set literal is legal.</p><p>You can also use character set literals (and, of course, character set symbolic constants) as the initializer field for a <code class="literal">static</code> or <code class="literal">readonly</code> variable. The following code fragment demonstrates this:<a class="indexterm" id="IDX-CHP-4-0160"/><a class="indexterm" id="IDX-CHP-4-0161"/><a class="indexterm" id="IDX-CHP-4-0162"/><a class="indexterm" id="IDX-CHP-4-0163"/><a class="indexterm" id="IDX-CHP-4-0164"/><a class="indexterm" id="IDX-CHP-4-0165"/><a class="indexterm" id="IDX-CHP-4-0166"/><a class="indexterm" id="IDX-CHP-4-0167"/></p><a id="I_programlisting4_d1e18952"/><pre class="programlisting">static
     Alphabetic: cset := { 'a'..'z', 'A'..'Z' };</pre><p>Anywhere you can use a character set literal constant, a character set constant expression is also legal. <a class="xref" href="ch04s14.html#hla_character_set_operators" title="Table 4-2. HLA Character Set Operators">Table 4-2</a> shows the operators that HLA supports in character set constant expressions.<a class="indexterm" id="IDX-CHP-4-0168"/></p><div class="table"><a id="hla_character_set_operators"/><p class="title">Table 4-2. HLA Character Set Operators</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HLA Character Set Operators"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Operator</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">CSetConst1 + CSetConst2</code></p></td><td style="text-align: left" valign="top"><p>Computes the union of the two sets. The set union is the set of all characters that are in either set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CSetConst1 * CSetConst2</code></p></td><td style="text-align: left" valign="top"><p>Computes the intersection of the two sets. The set intersection is the set of all characters that appear in both operand sets.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CSetConst1 - CSetConst2</code></p></td><td style="text-align: left" valign="top"><p>Computes the set difference of the two sets. The set difference is the set of characters that appear in the first set but do not appear in the second set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-CSetConst</code></p></td><td style="text-align: left" valign="top"><p>Computes the set complement. The set complement is the set of all characters not in the set.</p></td></tr></tbody></table></div></div><p>Note that these operators produce only compile-time results. That is, the expressions above are computed by the compiler during compilation; they do not emit any machine code. If you want to perform these operations on two different sets while your program is running, the HLA Standard Library provides routines you can call to achieve the results you desire. HLA also provides other compile-time character set operators.</p></div>
<div class="sect1" title="4.15 Character Set Support in the HLA Standard Library"><div class="titlepage"><div><div><h1 class="title"><a id="character_set_support_in_the_hla_standar"/>4.15 Character Set Support in the HLA Standard Library</h1></div></div></div><p>The HLA Standard Library provides several character set routines you may find useful. The character set support routines fall into four categories: standard character set functions, character set tests, character set conversions, and character set I/O. This section describes these routines in the HLA Standard Library.</p><p>To begin with, let's consider the Standard Library routines that help you construct character sets. These routines include <code class="literal">cs.empty</code>, <code class="literal">cs.cpy</code>, <code class="literal">cs.charToCset</code>, <code class="literal">cs.unionChar</code>, <code class="literal">cs.removeChar</code>, <code class="literal">cs.rangeChar</code>, <code class="literal">cs.strToCset</code>, and <code class="literal">cs.unionStr</code>. These procedures let you build up character sets at runtime using character and string objects.<a class="indexterm" id="IDX-CHP-4-0169"/></p><p>The <code class="literal">cs.empty</code> procedure initializes a character set variable with the empty set by setting all the bits in the character set to 0. This procedure call uses the following syntax (<em class="replaceable"><code>CSvar</code></em> is a character set variable):</p><a id="I_programlisting4_d1e19057"/><pre class="programlisting">cs.empty( <em class="replaceable"><code>CSvar</code></em> );</pre><p>The <code class="literal">cs.cpy</code> procedure copies one character set to another, replacing any data previously held by the destination character set. The syntax for <code class="literal">cs.cpy</code> is:</p><a id="I_programlisting4_d1e19070"/><pre class="programlisting">cs.cpy( <em class="replaceable"><code>srcCsetValue</code></em>, <em class="replaceable"><code>destCsetVar</code></em> );</pre><p>The <code class="literal">cs.cpy</code> source character set can be either a character set constant or a character set variable. The destination character set must be a character set variable.</p><p>The <code class="literal">cs.unionChar</code> procedure adds a character to a character set. It uses the following calling sequence:</p><a id="I_programlisting4_d1e19088"/><pre class="programlisting">cs.unionChar( <em class="replaceable"><code>CharVar</code></em>, <em class="replaceable"><code>CSvar</code></em> );</pre><p>This call will add the first parameter, a character, to the set via set union. Note that you could use the <code class="literal">bts</code> instruction to achieve this same result; however, the <code class="literal">cs.unionChar</code> call is often more convenient. The character value must be in the range #0..#127.</p><p>The <code class="literal">cs.charToCset</code> function creates a singleton set (a set containing a single character). The calling format for this function is:</p><a id="I_programlisting4_d1e19110"/><pre class="programlisting">cs.charToCset( <em class="replaceable"><code>CharValue</code></em>, <em class="replaceable"><code>CSvar</code></em> );</pre><p>The first operand, the character value <em class="replaceable"><code>CharValue</code></em>, can be an 8-bit register, a constant, or a character variable that holds a value in the range #0..#127. The second operand (<em class="replaceable"><code>CSvar</code></em>) must be a character set variable. This function clears the destination character set to all zeros and then unions the specified character into the character set.</p><p>The <code class="literal">cs.removeChar</code> procedure lets you remove a single character from a character set without affecting the other characters in the set. This function uses the same syntax as <code class="literal">cs.charToCset</code>, and the parameters have the same attributes. The calling sequence is:</p><a id="I_programlisting4_d1e19134"/><pre class="programlisting">cs.removeChar( <em class="replaceable"><code>CharValue</code></em>, <em class="replaceable"><code>CSvar</code></em> );</pre><p>Note that if the character was not in the <em class="replaceable"><code>CSVar</code></em> set to begin with, <code class="literal">cs.removeChar</code> will not affect the set. This function roughly corresponds to the <code class="literal">btr</code> instruction.</p><p>The <code class="literal">cs.rangeChar</code> constructs a character set containing all the characters between two characters you pass as parameters. This function sets all bits outside the range of these two characters to 0. The calling sequence is:</p><a id="I_programlisting4_d1e19158"/><pre class="programlisting">cs.rangeChar( <em class="replaceable"><code>LowerBoundChar</code></em>, <em class="replaceable"><code>UpperBoundChar</code></em>, <em class="replaceable"><code>CSVar</code></em> );</pre><p>The <em class="replaceable"><code>LowerBoundChar</code></em> and <em class="replaceable"><code>UpperBoundChar</code></em> parameters can be constants, registers, or character variables. The values held in <em class="replaceable"><code>LowerBoundChar</code></em> and <em class="replaceable"><code>UpperBoundChar</code></em> must be in the range #0..#127. <code class="literal">CSVar</code>, the destination character set, must be a <code class="literal">cset</code> variable.</p><p>The <code class="literal">cs.strToCset</code> procedure creates a new character set containing the union of all the characters in a character string. This procedure begins by setting the destination character set to the empty set, and then it unions in the characters in the string one by one until it exhausts all characters in the string. The calling sequence is:<a class="indexterm" id="IDX-CHP-4-0170"/><a class="indexterm" id="IDX-CHP-4-0171"/><a class="indexterm" id="IDX-CHP-4-0172"/></p><a id="I_programlisting4_d1e19210"/><pre class="programlisting">cs.strToCset( <em class="replaceable"><code>StringValue</code></em>, <em class="replaceable"><code>CSVar</code></em> );</pre><p>Technically, the <em class="replaceable"><code>StringValue</code></em> parameter can be a string constant as well as a string variable; however, it doesn't make any sense to call <code class="literal">cs.strToCset</code> this way because <code class="literal">cs.cpy</code> is a much more efficient way to initialize a character set with a constant set of characters. As usual, the destination character set must be a <code class="literal">cset</code> variable. Typically, you'd use this function to create a character set based on a string input by the user.</p><p>The <code class="literal">cs.unionStr</code> procedure will add the characters in a string to an existing character set. Like <code class="literal">cs.strToCset</code>, you'd normally use this function to union characters into a set based on a string input by the user. The calling sequence for this is:</p><a id="I_programlisting4_d1e19241"/><pre class="programlisting">cs.unionStr( <em class="replaceable"><code>StringValue</code></em>, <em class="replaceable"><code>CSVar</code></em> );</pre><p>Standard set operations include union, intersection, and set difference. The HLA Standard Library routines <code class="literal">cs.setunion</code>, <code class="literal">cs.intersection</code>, and <code class="literal">cs.difference</code> provide these operations, respectively.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-14" id="CHP-4-FN-14">60</a>]</sup> These routines all use the same calling sequence:</p><a id="I_programlisting4_d1e19272"/><pre class="programlisting">cs.setunion( <em class="replaceable"><code>srcCset</code></em>, <em class="replaceable"><code>destCset</code></em> );
cs.intersection( <em class="replaceable"><code>srcCset</code></em>, <em class="replaceable"><code>destCset</code></em> );
cs.difference( <em class="replaceable"><code>srcCset</code></em>, <em class="replaceable"><code>destCset</code></em> );</pre><p>The first parameter can be a character set constant or a character set variable. The second parameter must be a character set variable. These procedures compute <em class="replaceable"><code>destCset</code></em> <code class="literal">:=</code> <em class="replaceable"><code>destCset op srcCset</code></em> where <em class="replaceable"><code>op</code></em> represents set union, intersection, or difference, depending on the function call.</p><p>The third category of character set routines test character sets in various ways. They typically return a boolean value indicating the result of the test. The HLA character set routines in this category include <code class="literal">cs.IsEmpty</code>, <code class="literal">cs.member</code>, <code class="literal">cs.subset</code>, <code class="literal">cs.psubset</code>, <code class="literal">cs.superset</code>, <code class="literal">cs.psuperset</code>, <code class="literal">cs.eq</code>, and <code class="literal">cs.ne</code>.</p><p>The <code class="literal">cs.IsEmpty</code> function tests a character set to see if it is the empty set. The function returns true or false in the EAX register. This function uses the following calling sequence:</p><a id="I_programlisting4_d1e19339"/><pre class="programlisting">cs.IsEmpty( <em class="replaceable"><code>CSetValue</code></em> );</pre><p>The single parameter may be a constant or a character set variable, although it doesn't make much sense to pass a character set constant to this procedure (because you would know at compile time whether this set is empty).<a class="indexterm" id="IDX-CHP-4-0173"/><a class="indexterm" id="IDX-CHP-4-0174"/><a class="indexterm" id="IDX-CHP-4-0175"/><a class="indexterm" id="IDX-CHP-4-0176"/><a class="indexterm" id="IDX-CHP-4-0177"/><a class="indexterm" id="IDX-CHP-4-0178"/><a class="indexterm" id="IDX-CHP-4-0179"/></p><p>The <code class="literal">cs.member</code> function tests to see if a character value is a member of a set. This function returns true in the EAX register if the character is a member of the set. Note that you can use the <code class="literal">bt</code> instruction to test this same condition. However, the <code class="literal">cs.member</code> function is probably a little more convenient to use if the character argument is not a constant. The calling sequence for <code class="literal">cs.member</code> is:</p><a id="I_programlisting4_d1e19396"/><pre class="programlisting">cs.member( <em class="replaceable"><code>CharValue</code></em>, <em class="replaceable"><code>CsetValue</code></em> );</pre><p>The first parameter is an 8-bit register, character variable, or a constant. The second parameter is either a character set constant or a character set variable. It would be unusual for both parameters to be constants.</p><p>The <code class="literal">cs.subset</code><span class="emphasis"><em>,</em></span> <code class="literal">cs.psubset</code> (proper subset), <code class="literal">cs.superset</code><span class="emphasis"><em>,</em></span> and <code class="literal">cs.psuperset</code> (proper superset) functions let you check to see if one character set is a subset or superset of another. The calling sequence for these four routines is nearly identical; it is one of the following:</p><a id="I_programlisting4_d1e19424"/><pre class="programlisting">cs.subset( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );
cs.psubset( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );
cs.superset( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );
cs.psuperset( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );</pre><p>These routines compare the first parameter against the second parameter and return true or false in the EAX register depending upon the result. One set is a subset of another if all the members of the first character set are present in the second character set. It is a proper subset if the second (right) character set also contains characters not found in the first (left) character set. Likewise, one character set is a superset of another if it contains all the characters in the second set (and possibly more). A proper superset contains additional characters beyond those found in the second set. The parameters can be either character set variables or character set constants; however, it would be unusual for both parameters to be character set constants (because you can determine this at compile time, there would be no need to call a runtime function to compute this).</p><p>The <code class="literal">cs.eq</code> and <code class="literal">cs.ne</code> functions check to see if two sets are equal or not equal. These functions return true or false in EAX depending upon the set comparison. The calling sequence is identical to the sub/superset functions above:</p><a id="I_programlisting4_d1e19461"/><pre class="programlisting">cs.eq( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );
cs.ne( <em class="replaceable"><code>CsetValue1</code></em>, <em class="replaceable"><code>CsetValue2</code></em> );</pre><p>Note that there are no functions that test for less than, less than or equal, greater than, or greater than or equal. The subset and proper subset functions are the equivalent of less than or equal and less than (respectively); likewise, the superset and proper superset functions are equivalent to greater than or equal and greater than (respectively).<a class="indexterm" id="IDX-CHP-4-0180"/></p><p>The <code class="literal">cs.extract</code> routine removes an arbitrary character from a character set and returns that character in the EAX register.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-15" id="CHP-4-FN-15">61</a>]</sup> The calling sequence is the following:</p><a id="I_programlisting4_d1e19491"/><pre class="programlisting">cs.extract( <em class="replaceable"><code>CsetVar</code></em> );</pre><p>The single parameter must be a character set variable. Note that this function will modify the character set variable by removing some character from the character set. This function returns $FFFF_FFFF (−1) in EAX if the character set was empty prior to the call.</p><p>In addition to the routines found in the <code class="literal">cset.hhf</code> (character set) library module, the string and standard output modules also provide functions that allow or expect character set parameters. For example, if you supply a character set value as a parameter to <code class="literal">stdout.put</code>, the <code class="literal">stdout.put</code> routine will print the characters currently in the set. See the HLA Standard Library documentation for more details on character set-handling procedures.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-14" id="ftn.CHP-4-FN-14">60</a>] </sup><code class="literal">cs.setunion</code> was used rather than <code class="literal">cs.union</code> because <span class="emphasis"><em>union</em></span> is an HLA reserved word.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-15" id="ftn.CHP-4-FN-15">61</a>] </sup>This routine returns the character in AL and zeros out the H.O. 3 bytes of EAX.</p></div></div></div>
<div class="sect1" title="4.16 Using Character Sets in Your HLA Programs"><div class="titlepage"><div><div><h1 class="title"><a id="using_character_sets_in_your_hla_program"/>4.16 Using Character Sets in Your HLA Programs</h1></div></div></div><p>Character sets are valuable for many different purposes in your programs. For example, one common use of character sets is to validate user input. This section will also present a couple of other applications for character sets to help you start thinking about how you could use them in your program.</p><p>Consider the following short code segment that gets a yes/no-type answer from the user:</p><a id="I_programlisting4_d1e19517"/><pre class="programlisting">static
     answer: char;
          .
          .
          .
     repeat
               .
               .
               .
          stdout.put( "Would you like to play again? " );
          stdin.FlushInput();
          stdin.get( answer );

     until( answer = 'n' );</pre><p>A major problem with this code sequence is that it will stop only if the user types a lowercase <span class="emphasis"><em>n</em></span> character. If the user types anything other than <span class="emphasis"><em>n</em></span> (including uppercase <span class="emphasis"><em>N</em></span>), the program will treat this as an affirmative answer and transfer back to the beginning of the <code class="literal">repeat..until</code> loop. A better solution would be to validate the user input before the <code class="literal">until</code> clause above to ensure that the user has only typed <span class="emphasis"><em>n</em></span>, <span class="emphasis"><em>N</em></span>, <span class="emphasis"><em>y</em></span>, or <span class="emphasis"><em>Y</em></span>. The following code sequence will accomplish this:<a class="indexterm" id="IDX-CHP-4-0181"/></p><a id="I_programlisting4_d1e19554"/><pre class="programlisting">repeat
               .
               .
               .
          repeat

               stdout.put( "Would you like to play again? " );
               stdin.FlushInput();
               stdin.get( answer );

          until( cs.member( answer, { 'n', 'N', 'Y', 'y' } );
          if( answer = 'N' ) then

               mov( 'n', answer );

          endif;

     until( answer = 'n' );</pre></div>
<div class="sect1" title="4.17 Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="arrays"/>4.17 Arrays</h1></div></div></div><p>Along with strings, arrays are probably the most commonly used composite data. Yet most beginning programmers don't understand how arrays operate internally and their associated efficiency trade-offs. It's surprising how many novice (and even advanced!) programmers view arrays from a completely different perspective once they learn how to deal with arrays at the machine level.</p><p>Abstractly, an array is an aggregate data type whose members (elements) are all the same type. Selection of a member from the array is by an integer index.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-16" id="CHP-4-FN-16">62</a>]</sup> Different indices select unique elements of the array. This text assumes that the integer indices are contiguous (though this is by no means required). That is, if the number <span class="emphasis"><em>x</em></span> is a valid index into the array and <span class="emphasis"><em>y</em></span> is also a valid index, with <span class="emphasis"><em>x</em></span> &lt; <span class="emphasis"><em>y</em></span>, then all <span class="emphasis"><em>i</em></span> such that <span class="emphasis"><em>x</em></span> &lt; <span class="emphasis"><em>i</em></span> &lt; <span class="emphasis"><em>y</em></span> are valid indices.</p><p>Whenever you apply the indexing operator to an array, the result is the specific array element chosen by that index. For example, <em class="replaceable"><code>A</code></em><code class="literal">[</code><em class="replaceable"><code>i</code></em><code class="literal">]</code> chooses the <span class="emphasis"><em>i</em></span>th element from array <code class="literal">A</code>. Note that there is no formal requirement that element <em class="replaceable"><code>i</code></em> be anywhere near element <em class="replaceable"><code>i</code></em><code class="literal">+1</code> in memory. As long as <em class="replaceable"><code>A</code></em><code class="literal">[</code><em class="replaceable"><code>i</code></em><code class="literal">]</code> always refers to the same memory location and <em class="replaceable"><code>A</code></em><code class="literal">[</code><em class="replaceable"><code>i+1</code></em><code class="literal">]</code> always refers to its corresponding location (and the two are different), the definition of an array is satisfied.<a class="indexterm" id="IDX-CHP-4-0182"/><a class="indexterm" id="IDX-CHP-4-0183"/><a class="indexterm" id="IDX-CHP-4-0184"/></p><p>In this text, we assume that array elements occupy contiguous locations in memory. An array with five elements will appear in memory as <a class="xref" href="ch04s17.html#array_layout_in_memory" title="Figure 4-4. Array layout in memory">Figure 4-4</a> shows.</p><div class="figure"><a id="array_layout_in_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e19655"/><img alt="Array layout in memory" src="tagoreillycom20100401nostarchimages577985.png"/></div></div><p class="title">Figure 4-4. Array layout in memory</p></div><p>The <span class="emphasis"><em>base address</em></span> of an array is the address of the first element on the array and always appears in the lowest memory location. The second array element directly follows the first in memory, the third element follows the second, and so on. Note that there is no requirement that the indices start at 0. They may start with any number as long as they are contiguous. However, for the purposes of discussion, this book will start all indexes at 0.</p><p>To access an element of an array, you need a function that translates an array index to the address of the indexed element. For a single-dimensional array, this function is very simple. It is:</p><a id="I_programlisting4_d1e19667"/><pre class="programlisting"><em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>Base_Address</code></em> + ((<em class="replaceable"><code>Index</code></em> - <em class="replaceable"><code>Initial_Index</code></em>) * <em class="replaceable"><code>Element_Size</code></em>)</pre><p>where <em class="replaceable"><code>Initial_Index</code></em> is the value of the first index in the array (which you can ignore if 0) and the value <em class="replaceable"><code>Element_Size</code></em> is the size, in bytes, of an individual array element.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-16" id="ftn.CHP-4-FN-16">62</a>] </sup>Or it could be some value whose underlying representation is integer, such as character, enumerated, and boolean types.</p></div></div></div>
<div class="sect1" title="4.18 Declaring Arrays in Your HLA Programs"><div class="titlepage"><div><div><h1 class="title"><a id="declaring_arrays_in_your_hla_programs"/>4.18 Declaring Arrays in Your HLA Programs</h1></div></div></div><p>Before you can access elements of an array, you need to set aside storage for that array. Fortunately, array declarations build on the declarations you've already seen. To allocate <code class="literal">n</code> elements in an array, you would use a declaration like the following in one of the variable declaration sections:</p><a id="I_programlisting4_d1e19699"/><pre class="programlisting"><em class="replaceable"><code>ArrayName</code></em>: <em class="replaceable"><code>basetype</code></em>[n];</pre><p><em class="replaceable"><code>ArrayName</code></em> is the name of the array variable and <em class="replaceable"><code>basetype</code></em> is the type of an element of that array. This sets aside storage for the array. To obtain the base address of the array, just use <em class="replaceable"><code>ArrayName</code></em>.</p><p>The <code class="literal">[n]</code> suffix tells HLA to duplicate the object <code class="literal">n</code> times. Now let's look at some specific examples.</p><a id="I_programlisting4_d1e19724"/><pre class="programlisting">static

     CharArray: char[128];    // Character array with elements 0..127.
     ByteArray: byte[10];     // Array of bytes with elements 0..9.
     PtrArray:  dword[4];     // Array of double words with elements 0..3.</pre><p>These examples all allocate storage for uninitialized arrays. You may also specify that the elements of the arrays be initialized using declarations like the following in the <code class="literal">static</code> and <code class="literal">readonly</code> sections:</p><a id="I_programlisting4_d1e19734"/><pre class="programlisting">RealArray: real32[8] := [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ];
IntegerAry: int32[8] := [ 1, 1, 1, 1, 1, 1, 1, 1 ];</pre><p>These definitions both create arrays with eight elements. The first definition initializes each 4-byte real value to 1.0, the second declaration initializes each <code class="literal">int32</code> element to 1. Note that the number of constants within the square brackets must exactly match the size of the array.</p><p>This initialization mechanism is fine if you want each element of the array to have the same value. What if you want to initialize each element of the array with a (possibly) different value? No sweat, just specify a different set of values in the list surrounded by the square brackets in the example above:</p><a id="I_programlisting4_d1e19743"/><pre class="programlisting">RealArray: real32[8] := [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ];
IntegerAry: int32[8] := [ 1, 2, 3, 4, 5, 6, 7, 8 ];</pre></div>
<div class="sect1" title="4.19 HLA Array Constants"><div class="titlepage"><div><div><h1 class="title"><a id="hla_array_constants"/>4.19 HLA Array Constants</h1></div></div></div><p>The last few examples in the previous section demonstrate the use of HLA array constants. An HLA array constant is nothing more than a list of values surrounded by a pair of brackets. The following are all legal array constants:</p><a id="I_programlisting4_d1e19751"/><pre class="programlisting">[ 1, 2, 3, 4 ]
[ 2.0, 3.14159, 1.0, 0.5 ]
[ 'a', 'b', 'c', 'd' ]
[ "Hello", "world", "of", "assembly" ]</pre><p>(Note that this last array constant contains four double-word pointers to the four HLA strings appearing elsewhere in memory.)</p><p>As you saw in the previous section, you can use array constants in the <code class="literal">static</code> and <code class="literal">readonly</code> sections to provide initial values for array variables. The number of comma-separated items in an array constant must exactly match the number of array elements in the variable declaration. Likewise, the type of each of the array constant's elements must match the array variable's declared base type.</p><p>Using array constants to initialize small arrays is very convenient. Of course, if your array has several thousand elements, entering them will be tedious. Most arrays initialized this way have no more than a couple hundred entries and generally far less than 100. It is reasonable to use an array constant to initialize such variables. However, at some point initializing arrays in this manner will become far too tedious and error prone. You probably would not want to manually initialize an array with 1,000 different elements using an array constant. However, if you want to initialize all the elements of an array with the same value, HLA does provide a special array constant syntax for doing so. Consider the following declaration:<a class="indexterm" id="IDX-CHP-4-0185"/><a class="indexterm" id="IDX-CHP-4-0186"/></p><a id="I_programlisting4_d1e19773"/><pre class="programlisting">BigArray: uns32[ 1000 ] := 1000 dup [ 1 ];</pre><p>This declaration creates a 1,000-element integer array initializing each element to one. The <code class="literal">1000 dup [ 1 ]</code> expression tells HLA to create an array constant by duplicating the single value <code class="literal">[ 1 ]</code> one thousand times. You can even use the <code class="literal">dup</code> operator to duplicate a series of values (rather than a single value), as the following example indicates:</p><a id="I_programlisting4_d1e19786"/><pre class="programlisting">SixteenInts: int32[16] := 4 dup [1,2,3,4];</pre><p>This example initializes <code class="literal">SixteenInts</code> with four copies of the sequence <code class="literal">1,2,3,4</code>, yielding a total of 16 different integers (i.e., 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4).</p><p>You will see some more possibilities with the <code class="literal">dup</code> operator when looking at multidimensional arrays in <a class="xref" href="ch04s22.html" title="4.22 Multidimensional Arrays">4.22 Multidimensional Arrays</a>.</p></div>
<div class="sect1" title="4.20 Accessing Elements of a Single-Dimensional Array"><div class="titlepage"><div><div><h1 class="title"><a id="accessing_elements_of_a_single-dimension"/>4.20 Accessing Elements of a Single-Dimensional Array</h1></div></div></div><p>To access an element of a zero-based array, you can use the simplified formula</p><a id="I_programlisting4_d1e19808"/><pre class="programlisting"><em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>Base_Address</code></em> + <em class="replaceable"><code>index</code></em> * Element_Size</pre><p>For the <em class="replaceable"><code>Base_Address</code></em> entry you can use the name of the array (because HLA associates the address of the first element of an array with the name of that array). The <em class="replaceable"><code>Element_Size</code></em> entry is the number of bytes for each array element. If the object is an array of bytes, the <em class="replaceable"><code>Element_Size</code></em> field is 1 (resulting in a very simple computation). If each element of the array is a word (or other 2-byte type), then <em class="replaceable"><code>Element_Size</code></em> is 2, and so on. To access an element of the <code class="literal">SixteenInts</code> array in the previous section, you'd use the following formula (the size is 4 because each element is an <em class="replaceable"><code>int32</code></em> object):</p><a id="I_programlisting4_d1e19839"/><pre class="programlisting"><em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>SixteenInts</code></em> + <em class="replaceable"><code>index</code></em>*4</pre><p>The 80x86 code equivalent to the statement <code class="literal">eax :=</code> <em class="replaceable"><code>SixteenInts</code></em><code class="literal">[</code><em class="replaceable"><code>index</code></em><code class="literal">]</code> is</p><a id="I_programlisting4_d1e19863"/><pre class="programlisting">mov( index, ebx );
               shl( 2, ebx );          // Sneaky way to compute 4*ebx
               mov( SixteenInts[ ebx ], eax );</pre><p>There are two important things to notice here. First of all, this code uses the <code class="literal">shl</code> instruction rather than the <code class="literal">intmul</code> instruction to compute <code class="literal">4*index</code>. The main reason for choosing <code class="literal">shl</code> is that it was more efficient. It turns out that <code class="literal">shl</code> is a <span class="emphasis"><em>lot</em></span> faster than <code class="literal">intmul</code> on many processors.</p><p>The second thing to note about this instruction sequence is that it does not explicitly compute the sum of the base address plus the index times 4. Instead, it relies on the indexed addressing mode to implicitly compute this sum. The instruction <code class="literal">mov( SixteenInts[ ebx ], eax );</code> loads EAX from location <code class="literal">SixteenInts + ebx</code>, which is the base address plus <code class="literal">index*4</code> (because EBX contains <code class="literal">index*4</code>). Sure, you could have used</p><a id="I_programlisting4_d1e19903"/><pre class="programlisting">lea( eax, SixteenInts );
               mov( index, ebx );
               shl( 2, ebx );            // Sneaky way to compute 4*ebx
               add( eax, ebx );          // Compute base address plus index*4
               mov( [ebx], eax );</pre><p>in place of the previous sequence, but why use five instructions where three will do the same job? This is a good example of why you should know your addressing modes inside and out. Choosing the proper addressing mode can reduce the size of your program, thereby speeding it up.</p><p>Of course, as long as we're discussing efficiency improvements, it's worth pointing out that the 80x86 scaled indexed addressing modes let you automatically multiply an index by 1, 2, 4, or 8. Because this current example multiplies the index by 4, we can simplify the code even more by using the scaled indexed addressing mode:</p><a id="I_programlisting4_d1e19910"/><pre class="programlisting">mov( index, ebx );
               mov( SixteenInts[ ebx*4 ], eax );</pre><p>Note, however, that if you need to multiply by some constant other than 1, 2, 4 or 8, then you cannot use the scaled indexed addressing modes. Similarly, if you need to multiply by some element size that is not a power of 2, you will not be able to use the <code class="literal">shl</code> instruction to multiply the index by the element size; instead, you will have to use <code class="literal">intmul</code> or some other instruction sequence to do the multiplication.</p><p>The indexed addressing mode on the 80x86 is a natural for accessing elements of a single-dimensional array. Indeed, its syntax even suggests an array access. The important thing to keep in mind is that you must remember to multiply the index by the size of an element. Failure to do so will produce incorrect results.</p></div>
<div class="sect1" title="4.21 Sorting an Array of Values"><div class="titlepage"><div><div><h1 class="title"><a id="sorting_an_array_of_values"/>4.21 Sorting an Array of Values</h1></div></div></div><p>Almost every textbook on this planet gives an example of a sort when introducing arrays. Because you've probably seen how to do a sort in high-level languages already, it's probably instructive to take a quick look at a sort in HLA. The example code in this section will use a variant of the bubble sort, which is great for short lists of data and lists that are nearly sorted but horrible for just about everything else.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-17" id="CHP-4-FN-17">63</a>]</sup></p><a id="I_programlisting4_d1e19932"/><pre class="programlisting">const
    NumElements := 16;

static
    DataToSort: uns32[ NumElements ] :=
                    [
                        1, 2, 16, 14,
                        3, 9, 4,  10,
                        5, 7, 15, 12,
                        8, 6, 11, 13
                    ];

    NoSwap: boolean;

          .
          .
          .

    // Bubble sort for the DataToSort array:

    repeat

        mov( true, NoSwap );
        for( mov( 0, ebx ); ebx &lt;= NumElements-2; inc( ebx )) do

            mov( DataToSort[ ebx*4], eax );
            if( eax &gt; DataToSort[ ebx*4 + 4] ) then

                mov( DataToSort[ ebx*4 + 4 ], ecx );
                mov( ecx, DataToSort[ ebx*4 ] );
                mov( eax, DataToSort[ ebx*4 + 4 ] ); // Note: eax contains
                mov( false, NoSwap );                // DataToSort[ ebx*4 ]

            endif;

        endfor;

    until( NoSwap );</pre><p>The bubble sort works by comparing adjacent elements in an array. The interesting thing to note in this code fragment is how it compares adjacent elements. You will note that the <code class="literal">if</code> statement compares EAX (which contains <code class="literal">DataToSort[ebx*4]</code>) against <code class="literal">DataToSort[ebx*4 + 4]</code>. Because each element of this array is 4 bytes (<code class="literal">uns32</code>), the index <code class="literal">[ebx*4 + 4]</code> references the next element beyond <code class="literal">[ebx*4]</code>.</p><p>As is typical for a bubble sort, this algorithm terminates if the innermost loop completes without swapping any data. If the data is already presorted, then the bubble sort is very efficient, making only one pass over the data. Unfortunately, if the data is not sorted (worst case, if the data is sorted in reverse order), then this algorithm is extremely inefficient. Indeed, although it is possible to modify the code above so that, on the average, it runs about twice as fast, such optimizations are wasted on such a poor algorithm. However, the bubble sort is very easy to implement and understand (which is why introductory texts continue to use it in examples).</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-17" id="ftn.CHP-4-FN-17">63</a>] </sup>Fear not, you'll see some better sorting algorithms in <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>.</p></div></div></div>
<div class="sect1" title="4.22 Multidimensional Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="multidimensional_arrays"/>4.22 Multidimensional Arrays</h1></div></div></div><p>The 80x86 hardware can easily handle single-dimensional arrays. Unfortunately, there is no magic addressing mode that lets you easily access elements of multidimensional arrays. That's going to take some work and several instructions.<a class="indexterm" id="IDX-CHP-4-0187"/></p><p>Before discussing how to declare or access multidimensional arrays, it would be a good idea to figure out how to implement them in memory. The first problem is to figure out how to store a multidimensional object into a one-dimensional memory space.</p><p>Consider for a moment a Pascal array of the form <code class="literal">A:array[0..3,0..3] of char;</code>. This array contains 16 bytes organized as four rows of four characters. Somehow you've got to draw a correspondence with each of the 16 bytes in this array and 16 contiguous bytes in main memory. <a class="xref" href="ch04s22.html#mapping_a_4x4_array_to_sequential_memory" title="Figure 4-5. Mapping a 4x4 array to sequential memory locations">Figure 4-5</a> shows one way to do this.</p><div class="figure"><a id="mapping_a_4x4_array_to_sequential_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e19979"/><img alt="Mapping a 4x4 array to sequential memory locations" src="tagoreillycom20100401nostarchimages577987.png"/></div></div><p class="title">Figure 4-5. Mapping a 4x4 array to sequential memory locations</p></div><p>The actual mapping is not important as long as two things occur: (1) Each element maps to a unique memory location (that is, no two entries in the array occupy the same memory locations), and (2) the mapping is consistent. That is, a given element in the array always maps to the same memory location. So what you really need is a function with two input parameters (row and column) that produces an offset into a linear array of 16 memory locations.</p><p>Now any function that satisfies the above constraints will work fine. Indeed, you could randomly choose a mapping as long as it was consistent. However, what you really want is a mapping that is efficient to compute at runtime and works for any size array (not just 4x4 or even limited to two dimensions). While a large number of possible functions fit this bill, there are two functions in particular that most programmers and high-level languages use: <span class="emphasis"><em>row-major ordering</em></span> and <span class="emphasis"><em>column-major ordering</em></span>.<a class="indexterm" id="IDX-CHP-4-0188"/><a class="indexterm" id="IDX-CHP-4-0189"/></p><div class="sect2" title="4.22.1 Row-Major Ordering"><div class="titlepage"><div><div><h2 class="title"><a id="row-major_ordering"/>4.22.1 Row-Major Ordering</h2></div></div></div><p>Row-major ordering assigns successive elements, moving across the rows and then down the columns, to successive memory locations. This mapping is demonstrated in <a class="xref" href="ch04s22.html#row-major_array_element_ordering" title="Figure 4-6. Row-major array element ordering">Figure 4-6</a>.</p><div class="figure"><a id="row-major_array_element_ordering"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20010"/><img alt="Row-major array element ordering" src="tagoreillycom20100401nostarchimages577989.png"/></div></div><p class="title">Figure 4-6. Row-major array element ordering</p></div><p>Row-major ordering is the method most high-level programming languages employ. It is very easy to implement and use in machine language. You start with the first row (row 0) and then concatenate the second row to its end. You then concatenate the third row to the end of the list, then the fourth row, and so on (see <a class="xref" href="ch04s22.html#another_view_of_row-major_ordering_for_a" title="Figure 4-7. Another view of row-major ordering for a 4×4 array">Figure 4-7</a>).</p><div class="figure"><a id="another_view_of_row-major_ordering_for_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20022"/><img alt="Another view of row-major ordering for a 4×4 array" src="tagoreillycom20100401nostarchimages577991.png.jpg"/></div></div><p class="title">Figure 4-7. Another view of row-major ordering for a 4×4 array</p></div><p>The actual function that converts a list of index values into an offset is a slight modification of the formula for computing the address of an element of a single-dimensional array. The formula to compute the offset for a two-dimensional row-major ordered array is:<a class="indexterm" id="IDX-CHP-4-0190"/></p><a id="I_programlisting4_d1e20034"/><pre class="programlisting"><em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>Base_Address</code></em> + (<em class="replaceable"><code>colindex</code></em> * <em class="replaceable"><code>row_size</code></em> + <em class="replaceable"><code>rowindex</code></em>) *
 <em class="replaceable"><code>Element_Size</code></em></pre><p>As usual, <em class="replaceable"><code>Base_Address</code></em> is the address of the first element of the array (<code class="literal">A[0][0]</code> in this case), and <em class="replaceable"><code>Element_Size</code></em> is the size of an individual element of the array, in bytes. <em class="replaceable"><code>colindex</code></em> is the leftmost index, and <em class="replaceable"><code>rowindex</code></em> is the rightmost index into the array. <em class="replaceable"><code>row_size</code></em> is the number of elements in one row of the array (four, in this case, because each row has four elements). Assuming <em class="replaceable"><code>Element_Size</code></em> is 1, this formula computes the following offsets from the base address:</p><a id="I_programlisting4_d1e20076"/><pre class="programlisting">Column          Row             Offset
     Index           Index           into Array
     0               0               0
     0               1               1
     0               2               2
     0               3               3
     1               0               4
     1               1               5
     1               2               6
     1               3               7
     2               0               8
     2               1               9
     2               2               10
     2               3               11
     3               0               12
     3               1               13
     3               2               14
     3               3               15</pre><p>For a three-dimensional array, the formula to compute the offset into memory is the following:</p><a id="I_programlisting4_d1e20080"/><pre class="programlisting"><em class="replaceable"><code>Address</code></em> = <em class="replaceable"><code>Base</code></em> + ((<em class="replaceable"><code>depthindex</code></em>*<em class="replaceable"><code>col_size</code></em>+<em class="replaceable"><code>colindex</code></em>) * <em class="replaceable"><code>row_size</code></em> + <em class="replaceable"><code>rowindex</code></em>)
 * <em class="replaceable"><code>Element_Size</code></em></pre><p><em class="replaceable"><code>col_size</code></em> is the number of items in a column, and <code class="literal">row_size</code> is the number of items in a row. In C/C++, if you've declared the array as <em class="replaceable"><code>type</code></em> <code class="literal">A[i] [j] [k];</code>, then <em class="replaceable"><code>row_size</code></em> is equal to <code class="literal">k</code> and <em class="replaceable"><code>col_size</code></em> is equal to <code class="literal">j</code>.</p><p>For a four-dimensional array, declared in C/C++ as <em class="replaceable"><code>type</code></em> <code class="literal">A[i] [j] [k] [m];</code>, the formula for computing the address of an array element is:</p><a id="I_programlisting4_d1e20140"/><pre class="programlisting"><em class="replaceable"><code>Address</code></em> =
<em class="replaceable"><code>Base</code></em> + (((<em class="replaceable"><code>LeftIndex</code></em>*<em class="replaceable"><code>depth_size</code></em>+<em class="replaceable"><code>depthindex</code></em>)*<em class="replaceable"><code>col_size</code></em>+<em class="replaceable"><code>colindex</code></em>) * <em class="replaceable"><code>row_size</code></em>
 + <em class="replaceable"><code>rowindex</code></em>) * <em class="replaceable"><code>Element_Size</code></em></pre><p><em class="replaceable"><code>depth_size</code></em> is equal to <code class="literal">j</code>, <em class="replaceable"><code>col_size</code></em> is equal to <code class="literal">k</code>, and <em class="replaceable"><code>row_size</code></em> is equal to <code class="literal">m</code>. <em class="replaceable"><code>LeftIndex</code></em> represents the value of the leftmost index.<a class="indexterm" id="IDX-CHP-4-0191"/></p><p>By now you're probably beginning to see a pattern. There is a generic formula that will compute the offset into memory for an array with <span class="emphasis"><em>any</em></span> number of dimensions; however, you'll rarely use more than four.</p><p>Another convenient way to think of row-major arrays is as arrays of arrays. Consider the following single-dimensional Pascal array definition:<a class="indexterm" id="IDX-CHP-4-0192"/><a class="indexterm" id="IDX-CHP-4-0193"/></p><a id="I_programlisting4_d1e20214"/><pre class="programlisting">A: array [0..3] of <em class="replaceable"><code>sometype</code></em>;</pre><p>Assume that <em class="replaceable"><code>sometype</code></em> is the type <em class="replaceable"><code>sometype</code></em> <code class="literal">= array [0..3] of char;</code>.</p><p><code class="literal">A</code> is a single-dimensional array. Its individual elements happen to be arrays, but you can safely ignore that for the time being. The formula to compute the address of an element of a single-dimensional array is:</p><a id="I_programlisting4_d1e20234"/><pre class="programlisting"><em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>Base</code></em> + <em class="replaceable"><code>Index</code></em> * <em class="replaceable"><code>Element_Size</code></em></pre><p>In this case <em class="replaceable"><code>Element_Size</code></em> happens to be 4 because each element of <em class="replaceable"><code>A</code></em> is an array of four characters. So what does this formula compute? It computes the base address of each row in this 4x4 array of characters (see <a class="xref" href="ch04s22.html#viewing_a_4x4_array_as_an_array_of_array" title="Figure 4-8. Viewing a 4x4 array as an array of arrays">Figure 4-8</a>).</p><div class="figure"><a id="viewing_a_4x4_array_as_an_array_of_array"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20260"/><img alt="Viewing a 4x4 array as an array of arrays" src="tagoreillycom20100401nostarchimages577993.png"/></div></div><p class="title">Figure 4-8. Viewing a 4x4 array as an array of arrays</p></div><p>Of course, once you compute the base address of a row, you can reapply the single-dimensional formula to get the address of a particular element. While this doesn't affect the computation, it's probably a little easier to deal with several single-dimensional computations rather than a complex multidimensional array computation.</p><p>Consider a Pascal array defined as <code class="literal">A:array [0..3] [0..3] [0..3] [0..3] [0..3] of char;</code>. You can view this five-dimensional array as a single-dimensional array of arrays. The following HLA code provides such a definition:</p><a id="I_programlisting4_d1e20272"/><pre class="programlisting">type
          OneD: char[4];
          TwoD: OneD[4];
          ThreeD: TwoD[4];
          FourD: ThreeD [4];
var
          A : FourD [4];</pre><p>The size of <code class="literal">OneD</code> is 4 bytes. Because <code class="literal">TwoD</code> contains four <code class="literal">OneD</code> arrays, its size is 16 bytes. Likewise, <code class="literal">ThreeD</code> is four <code class="literal">TwoD</code>s, so it is 64 bytes long. Finally, <code class="literal">FourD</code> is four <code class="literal">ThreeDs</code>, so it is 256 bytes long. To compute the address of <code class="literal">A [b, c, d, e, f]</code>, you could use the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Compute the address of <code class="literal">A [b]</code> as <em class="replaceable"><code>Base</code></em> <code class="literal">+ b *</code> <em class="replaceable"><code>size</code></em>. Here size is 256 bytes. Use this result as the new base address in the next computation.</p></li><li class="listitem"><p>Compute the address of <code class="literal">A [b, c]</code> by the formula <em class="replaceable"><code>Base</code></em> <code class="literal">+ c *</code> <em class="replaceable"><code>size</code></em>, where <em class="replaceable"><code>Base</code></em> is the value obtained in the previous step and <em class="replaceable"><code>size</code></em> is 64. Use the result as the new base in the next computation.</p></li><li class="listitem"><p>Compute the base address of <code class="literal">A [b, c, d]</code> by <em class="replaceable"><code>Base</code></em> <code class="literal">+ d *</code> <em class="replaceable"><code>size</code></em>, with <em class="replaceable"><code>Base</code></em> coming from the previous computation and <em class="replaceable"><code>size</code></em> is 16. Use the result as the new base in the next computation.</p></li><li class="listitem"><p>Compute the address of <code class="literal">A [b, c, d, e]</code> with the formula <em class="replaceable"><code>Base</code></em> <code class="literal">+ e *</code> <em class="replaceable"><code>size</code></em>, with <em class="replaceable"><code>Base</code></em> from the previous step with a size of 4. Use this value as the base for the next computation.</p></li><li class="listitem"><p>Finally, compute the address of <code class="literal">A [b, c, d, e, f]</code> using the formula <em class="replaceable"><code>Base</code></em> <code class="literal">+ f *</code> <em class="replaceable"><code>size</code></em>, where <em class="replaceable"><code>Base</code></em> comes from the previous computation and <em class="replaceable"><code>size</code></em> is 1 (obviously you can simply ignore this final multiplication). The result you obtain at this point is the address of the desired element.</p></li></ol></div><p>One of the main reasons you won't find higher-dimensional arrays in assembly language is that assembly language emphasizes the inefficiencies associated with such access. It's easy to enter something like <code class="literal">A [b, c, d, e, f]</code> into a Pascal program, not realizing what the compiler is doing with the code. Assembly language programmers are not so cavalier—they see the mess you wind up with when you use higher-dimensional arrays. Indeed, good assembly language programmers try to avoid two-dimensional arrays and often resort to tricks in order to access data in such an array when its use becomes absolutely mandatory.</p></div><div class="sect2" title="4.22.2 Column-Major Ordering"><div class="titlepage"><div><div><h2 class="title"><a id="column-major_ordering"/>4.22.2 Column-Major Ordering</h2></div></div></div><p>Column-major ordering is the other function high-level languages frequently used to compute the address of an array element. FORTRAN and various dialects of BASIC (e.g., older versions of Microsoft BASIC) use this method.<a class="indexterm" id="IDX-CHP-4-0194"/></p><p>In row-major ordering the rightmost index increases the fastest as you move through consecutive memory locations. In column-major ordering the leftmost index increases the fastest. Pictorially, a column-major ordered array is organized as shown in <a class="xref" href="ch04s22.html#column-major_array_element_ordering" title="Figure 4-9. Column-major array element ordering">Figure 4-9</a>.</p><div class="figure"><a id="column-major_array_element_ordering"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20421"/><img alt="Column-major array element ordering" src="tagoreillycom20100401nostarchimages577995.png"/></div></div><p class="title">Figure 4-9. Column-major array element ordering</p></div><p>The formula for computing the address of an array element when using column-major ordering is very similar to that for row-major ordering. You simply reverse the indexes and sizes in the computation:<a class="indexterm" id="IDX-CHP-4-0195"/></p><a id="I_programlisting4_d1e20431"/><pre class="programlisting">For a two-dimension column-major array:
<em class="replaceable"><code>Element_Address</code></em> = <em class="replaceable"><code>Base_Address</code></em> + (<em class="replaceable"><code>rowindex</code></em> * <em class="replaceable"><code>col_size</code></em> + <em class="replaceable"><code>colindex</code></em>) *
                  <em class="replaceable"><code>Element_Size</code></em>

For a three-dimension column-major array:
<em class="replaceable"><code>Address</code></em> = <em class="replaceable"><code>Base</code></em> + ((<em class="replaceable"><code>rowindex</code></em> * <em class="replaceable"><code>col_size</code></em>+<em class="replaceable"><code>colindex</code></em>) * <em class="replaceable"><code>depth_size</code></em> +
 <em class="replaceable"><code>depthindex</code></em>) *
          <em class="replaceable"><code>Element_Size</code></em>

For a four-dimension column-major array:
<em class="replaceable"><code>Address</code></em> =
     <em class="replaceable"><code>Base</code></em> + (((<em class="replaceable"><code>rowindex</code></em> * <em class="replaceable"><code>col_size</code></em> + <em class="replaceable"><code>colindex</code></em>)*<em class="replaceable"><code>depth_size</code></em> + <em class="replaceable"><code>depthindex</code></em>) *
          <em class="replaceable"><code>Left_size</code></em> + <em class="replaceable"><code>Leftindex</code></em>) * <em class="replaceable"><code>Element_Size</code></em></pre></div></div>
<div class="sect1" title="4.23 Allocating Storage for Multidimensional Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="allocating_storage_for_multidimensional"/>4.23 Allocating Storage for Multidimensional Arrays</h1></div></div></div><p>If you have an <em class="replaceable"><code>m</code></em> x <em class="replaceable"><code>n</code></em> array, it will have <em class="replaceable"><code>m</code></em> * <em class="replaceable"><code>n</code></em> elements and require <em class="replaceable"><code>m</code></em> * <em class="replaceable"><code>n</code></em> * <em class="replaceable"><code>Element_Size</code></em> bytes of storage. To allocate storage for an array you must reserve this memory. As usual, there are several different ways of accomplishing this task. Fortunately, HLA's array-declaration syntax is very similar to high-level language array-declaration syntax, so C/C++, Java, BASIC, and Pascal programmers will feel right at home. To declare a multidimensional array in HLA, you use a declaration like the following:</p><a id="I_programlisting4_d1e20535"/><pre class="programlisting"><em class="replaceable"><code>ArrayName</code></em>: <em class="replaceable"><code>elementType</code></em> [ <em class="replaceable"><code>comma_separated_list_of_dimension_bounds</code></em> ];</pre><p>For example, here is a declaration for a 4x4 array of characters:</p><a id="I_programlisting4_d1e20547"/><pre class="programlisting">GameGrid: char[ 4, 4 ];</pre><p>Here is another example that shows how to declare a three-dimensional array of strings:</p><a id="I_programlisting4_d1e20551"/><pre class="programlisting">NameItems: string[ 2, 3, 3 ];</pre><p>Remember, string objects are really pointers, so this array declaration reserves storage for 18 double-word pointers (2 * 3 * 3 = 18).</p><p>As was the case with single-dimensional arrays, you may initialize every element of the array to a specific value by following the declaration with the assignment operator and an array constant. Array constants ignore dimension information; all that matters is that the number of elements in the array constant corresponds to the number of elements in the actual array. The following example shows the <code class="literal">GameGrid</code> declaration with an initializer:</p><a id="I_programlisting4_d1e20560"/><pre class="programlisting">GameGrid: char[ 4, 4 ] :=
          [
               'a', 'b', 'c', 'd',
               'e', 'f', 'g', 'h',
               'i', 'j', 'k', 'l',
               'm', 'n', 'o', 'p'
          ];</pre><p>Note that HLA ignores the indentation and extra whitespace characters (e.g., newlines) appearing in this declaration. It was laid out to enhance readability (which is always a good idea). HLA does not interpret the four separate lines as representing rows of data in the array. Humans do, which is why it's good to write the data in this manner. All that matters is that there are 16 (4 * 4) characters in the array constant. You'll probably agree that this is much easier to read than</p><a id="I_programlisting4_d1e20565"/><pre class="programlisting">GameGrid: char[ 4,4 ] :=
          [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
            'n', 'o', 'p' ];</pre><p>Of course, if you have a large array, an array with really large rows, or an array with many dimensions, there is little hope for winding up with something readable. That's when comments that carefully explain everything come in handy.</p><p>As for single-dimensional arrays, you can use the <code class="literal">dup</code> operator to initialize each element of a large array with the same value. The following example initializes a 256x64 array of bytes so that each byte contains the value $FF:</p><a id="I_programlisting4_d1e20574"/><pre class="programlisting">StateValue: byte[ 256, 64 ] := 256*64 dup [$ff];</pre><p>Note the use of a constant expression to compute the number of array elements rather than simply using the constant 16,384 (256 * 64). The use of the constant expression more clearly suggests that this code is initializing each element of a 256x64 element array than does the simple literal constant 16,384.<a class="indexterm" id="IDX-CHP-4-0196"/></p><p>Another HLA trick you can use to improve the readability of your programs is to use <span class="emphasis"><em>nested array constants</em></span>. The following is an example of an HLA nested array constant:<a class="indexterm" id="IDX-CHP-4-0197"/></p><a id="I_programlisting4_d1e20591"/><pre class="programlisting">[ [0, 1, 2], [3, 4], [10, 11, 12, 13] ]</pre><p>Whenever HLA encounters an array constant nested inside another array constant, it simply removes the brackets surrounding the nested array constant and treats the whole constant as a single-array constant. For example, HLA converts this nested array constant to the following:</p><a id="I_programlisting4_d1e20595"/><pre class="programlisting">[ 0, 1, 2, 3, 4, 10, 11, 12, 13 ]</pre><p>You can take advantage of this fact to help make your programs a little more readable. For multidimensional array constants you can enclose each row of the constant in square brackets to denote that the data in each row is grouped and separate from the other rows. Consider the following declaration for the <code class="literal">GameGrid</code> array that is identical (as far as HLA is concerned) to the earlier declaration for <code class="literal">GameGrid</code>:</p><a id="I_programlisting4_d1e20605"/><pre class="programlisting">GameGrid: char[ 4, 4 ] :=
          [
               [ 'a', 'b', 'c', 'd' ],
               [ 'e', 'f', 'g', 'h' ],
               [ 'i', 'j', 'k', 'l' ],
               [ 'm', 'n', 'o', 'p' ]
          ];</pre><p>This declaration makes it clearer that the array constant is a 4x4 array rather than just a 16-element one-dimensional array whose elements wouldn't fit all on one line of source code. Little aesthetic improvements like this are what separate mediocre programmers from good programmers.</p></div>
<div class="sect1" title="4.24 Accessing Multidimensional Array Elements in Assembly Language"><div class="titlepage"><div><div><h1 class="title"><a id="accessing_multidimensional_array_element"/>4.24 Accessing Multidimensional Array Elements in Assembly Language</h1></div></div></div><p>Well, you've seen the formulas for computing the address of a multidimensional array element. Now it's time to see how to access elements of those arrays using assembly language.</p><p>The <code class="literal">mov</code>, <code class="literal">shl</code>, and <code class="literal">intmul</code> instructions make short work of the various equations that compute offsets into multidimensional arrays. Let's consider a two-dimensional array first.</p><a id="I_programlisting4_d1e20626"/><pre class="programlisting">static
     i:          int32;
     j:          int32;
     TwoD:       int32[ 4, 8 ];

           .
           .
           .

// To perform the operation TwoD[i,j] := 5; you'd use code like the following.
// Note that the array index computation is (i*8 + j)*4.

          mov( i, ebx );
          shl( 3, ebx );    // Multiply by 8 (shl by 3 is a multiply by 8).
          add( j, ebx );
          mov( 5, TwoD[ ebx*4 ] );</pre><p>Note that this code does <span class="emphasis"><em>not</em></span> require the use of a two-register addressing mode on the 80x86. Although an addressing mode like <code class="literal">TwoD[ebx][esi]</code> looks like it should be a natural for accessing two-dimensional arrays, that isn't the purpose of this addressing mode.</p><p>Now consider a second example that uses a three-dimensional array:</p><a id="I_programlisting4_d1e20638"/><pre class="programlisting">static
     i:               int32;
     j:               int32;
     k:               int32;
     ThreeD:          int32[ 3, 4, 5 ];
          .
          .
          .

// To perform the operation ThreeD[i,j,k] := esi; you'd use the following code
// that computes ((i*4 + j)*5 + k )*4 as the address of ThreeD[i,j,k].

          mov( i, ebx );
          shl( 2, ebx );                     // Four elements per column.
          add( j, ebx );
          intmul( 5, ebx );                  // Five elements per row.
          add( k, ebx );
          mov( esi, ThreeD[ ebx*4 ] );</pre><p>Note that this code uses the <code class="literal">intmul</code> instruction to multiply the value in EBX by 5. Remember, the <code class="literal">shl</code> instruction can only multiply a register by a power of 2. While there are ways to multiply the value in a register by a constant other than a power of 2, the <code class="literal">intmul</code> instruction is more convenient.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-18" id="CHP-4-FN-18">64</a>]</sup></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-18" id="ftn.CHP-4-FN-18">64</a>] </sup>A full discussion of multiplication by constants other than a power of 2 appears in <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a>.</p></div></div></div>
<div class="sect1" title="4.25 Records"><div class="titlepage"><div><div><h1 class="title"><a id="records"/>4.25 Records</h1></div></div></div><p>Another major composite data structure is the Pascal record or C/C++/C# structure.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-19" id="CHP-4-FN-19">65</a>]</sup> The Pascal terminology is probably better, because it tends to avoid confusion with the more general term <span class="emphasis"><em>data structure</em></span>. Because HLA uses the term <span class="emphasis"><em>record</em></span>, we'll adopt that term here.<a class="indexterm" id="IDX-CHP-4-0198"/></p><p>Whereas an array is homogeneous, whose elements are all the same type, the elements in a record can have different types. Arrays let you select a particular element via an integer index. With records, you must select an element (known as a <span class="emphasis"><em>field</em></span>) by name.<a class="indexterm" id="IDX-CHP-4-0199"/></p><p>The whole purpose of a record is to let you encapsulate different, though logically related, data into a single package. The Pascal record declaration for a student is a typical example:</p><a id="I_programlisting4_d1e20686"/><pre class="programlisting">student =
     record
          Name:     string[64];
          Major:    integer;
          SSN:      string[11];
          Midterm1: integer;
          Midterm2: integer;
          Final:    integer;
          Homework: integer;
          Projects: integer;
     end;</pre><p>Most Pascal compilers allocate each field in a record to contiguous memory locations. This means that Pascal will reserve the first 65 bytes for the name,<sup>[<a class="footnote" href="#ftn.CHP-4-FN-20" id="CHP-4-FN-20">66</a>]</sup> the next 2 bytes hold the major code, the next 12 bytes hold the Social Security number, and so on.</p><p>In HLA, you can also create record types using the <code class="literal">record</code>/<code class="literal">endrecord</code> declaration. You would encode the above record in HLA as follows:</p><a id="I_programlisting4_d1e20702"/><pre class="programlisting">type
     student:     record
          Name:     char[65];
          Major:    int16;
          SSN:      char[12];
          Midterm1: int16;
          Midterm2: int16;
          Final:    int16;
          Homework: int16;
          Projects: int16;
     endrecord;</pre><p>As you can see, the HLA declaration is very similar to the Pascal declaration. Note that, to be true to the Pascal declaration, this example uses character arrays rather than strings for the <code class="literal">Name</code> and <code class="literal">SSN</code> (US Social Security number) fields. In a real HLA record declaration you'd probably use a string type for at least the name (keeping in mind that a string variable is only a 4-byte pointer).</p><p>The field names within the record must be unique. That is, the same name may not appear two or more times in the same record. However, all field names are local to that record. Therefore, you may reuse those field names elsewhere in the program or in different records.</p><p>The <code class="literal">record</code>/<code class="literal">endrecord</code> declaration may appear in a variable declaration section (e.g., <code class="literal">static</code> or <code class="literal">var</code>) or in a <code class="literal">type</code> declaration section. In the previous example the <code class="literal">Student</code> declaration appears in the <code class="literal">type</code> section, so this does not actually allocate any storage for a <code class="literal">Student</code> variable. Instead, you have to explicitly declare a variable of type <code class="literal">Student</code>. The following example demonstrates how to do this:</p><a id="I_programlisting4_d1e20745"/><pre class="programlisting">var
     John: Student;</pre><p>This allocates 81 bytes of storage laid out in memory as shown in <a class="xref" href="ch04s25.html#student_data_structure_storage_in_memory" title="Figure 4-10. Student data structure storage in memory">Figure 4-10</a>.</p><div class="figure"><a id="student_data_structure_storage_in_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20754"/><img alt="Student data structure storage in memory" src="tagoreillycom20100401nostarchimages577997.png"/></div></div><p class="title">Figure 4-10. Student data structure storage in memory</p></div><p>If the label <code class="literal">John</code> corresponds to the <span class="emphasis"><em>base address</em></span> of this record, then the <code class="literal">Name</code> field is at offset <code class="literal">John+0</code>, the <code class="literal">Major</code> field is at offset <code class="literal">John+65</code>, the <code class="literal">SSN</code> field is at offset <code class="literal">John+67</code>, and so on.</p><p>To access an element of a structure, you need to know the offset from the beginning of the structure to the desired field. For example, the <code class="literal">Major</code> field in the variable <code class="literal">John</code> is at offset 65 from the base address of <code class="literal">John</code>. Therefore, you could store the value in AX into this field using the instruction</p><a id="I_programlisting4_d1e20797"/><pre class="programlisting">mov( ax, (type word John[65]) );</pre><p>Unfortunately, memorizing all the offsets to fields in a record defeats the whole purpose of using them in the first place. After all, if you have to deal with these numeric offsets, why not just use an array of bytes instead of a record?</p><p>Fortunately, HLA lets you refer to field names in a record using the same mechanism C/C++/C# and Pascal use: the dot operator. To store AX into the <code class="literal">Major</code> field, you could use <code class="literal">mov( ax, John.Major );</code> instead of the previous instruction. This is much more readable and certainly easier to use.<a class="indexterm" id="IDX-CHP-4-0200"/></p><p>Note that the use of the dot operator does <span class="emphasis"><em>not</em></span> introduce a new addressing mode. The instruction <code class="literal">mov( ax, John.Major );</code> still uses the displacement-only addressing mode. HLA simply adds the base address of <code class="literal">John</code> with the offset to the <code class="literal">Major</code> field (65) to get the actual displacement to encode into the instruction.</p><p>Like any type declaration, HLA requires all record type declarations to appear in the program before you use them. However, you don't have to define all records in the <code class="literal">type</code> section to create record variables. You can use the <code class="literal">record</code>/<code class="literal">endrecord</code> declaration directly in a variable declaration section. This is convenient if you have only one instance of a given record object in your program. The following example demonstrates this:</p><a id="I_programlisting4_d1e20837"/><pre class="programlisting">storage
     OriginPoint:  record
          x: uns8;
          y: uns8;
          z: uns8;
     endrecord;</pre><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-19" id="ftn.CHP-4-FN-19">65</a>] </sup>It also goes by some other names in other languages, but most people recognize at least one of these names.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-20" id="ftn.CHP-4-FN-20">66</a>] </sup>Strings require an extra byte, in addition to all the characters in the string, to encode the length.</p></div></div></div>
<div class="sect1" title="4.26 Record Constants"><div class="titlepage"><div><div><h1 class="title"><a id="record_constants"/>4.26 Record Constants</h1></div></div></div><p>HLA lets you define record constants. In fact, HLA supports both manifest (symbolic) record constants and literal record constants. Record constants are useful as initializers for static record variables. They are also quite useful as compile-time data structures when using the HLA compile-time language (see the HLA reference manual for more details on the HLA compile-time language). This section discusses how to create record constants.<a class="indexterm" id="IDX-CHP-4-0201"/><a class="indexterm" id="IDX-CHP-4-0202"/></p><p>A literal record constant takes the following form:</p><a id="I_programlisting4_d1e20854"/><pre class="programlisting"><em class="replaceable"><code>RecordTypeName</code></em>:[ <em class="replaceable"><code>List_of_comma_separated_constants</code></em> ]</pre><p>The <em class="replaceable"><code>RecordTypeName</code></em> is the name of a record data type you've defined in an HLA <code class="literal">type</code> section prior to using the constant.</p><p>The constant list appearing between the brackets is the data for each of the fields in the specified record. The first item in the list corresponds to the first field of the record, the second item in the list corresponds to the second field, and so on. The data types of each of the constants appearing in this list must match their respective field types. The following example demonstrates how to use a literal record constant to initialize a record variable:</p><a id="I_programlisting4_d1e20871"/><pre class="programlisting">type
     point:     record
          x:int32;
          y:int32;
          z:int32;
     endrecord;

static
     Vector: point := point:[ 1, −2, 3 ];</pre><p>This declaration initializes <code class="literal">Vector.x</code> with 1, <code class="literal">Vector.y</code> with −2, and <code class="literal">Vector.z</code> with 3.</p><p>You can also create manifest record constants by declaring record objects in the <code class="literal">const</code> or <code class="literal">val</code> sections of your program. You access fields of these symbolic record constants just as you would access the field of a record variable, using the dot operator. Because the object is a constant, you can specify the field of a record constant anywhere a constant of that field's type is legal. You can also employ symbolic record constants as variable initializers. The following example demonstrates this:<a class="indexterm" id="IDX-CHP-4-0203"/></p><a id="I_programlisting4_d1e20897"/><pre class="programlisting">type
     point:     record
          x:int32;
          y:int32;
          z:int32;
     endrecord;

const
     PointInSpace: point := point:[ 1, 2, 3 ];

static
     Vector: point := PointInSpace;
     XCoord: int32 := PointInSpace.x;
          .
          .
          .
     stdout.put( "Y Coordinate is ", PointInSpace.y, nl );
          .
          .
          .</pre></div>
<div class="sect1" title="4.27 Arrays of Records"><div class="titlepage"><div><div><h1 class="title"><a id="arrays_of_records"/>4.27 Arrays of Records</h1></div></div></div><p>It is a perfectly reasonable operation to create an array of records. To do so, you simply create a record type and then use the standard array declaration syntax. The following example demonstrates how you could do this:</p><a id="I_programlisting4_d1e20904"/><pre class="programlisting">type
     <em class="replaceable"><code>recElement</code></em>:
          record
               &lt;&lt; Fields for this record &gt;&gt;
          endrecord;
          .
          .
          .
static
     <em class="replaceable"><code>recArray</code></em>: <em class="replaceable"><code>recElement</code></em>[4];</pre><p>To access an element of this array you use the standard array indexing techniques. Because <em class="replaceable"><code>recArray</code></em> is a single-dimensional array, you'd compute the address of an element of this array using the formula <em class="replaceable"><code>baseAddress</code></em> <code class="literal">+</code> <em class="replaceable"><code>index</code></em><code class="literal">*@size(</code> <em class="replaceable"><code>recElement</code></em> <code class="literal">)</code>. For example, to access an element of <em class="replaceable"><code>recArray</code></em> you'd use code like the following:<a class="indexterm" id="IDX-CHP-4-0204"/><a class="indexterm" id="IDX-CHP-4-0205"/><a class="indexterm" id="IDX-CHP-4-0206"/></p><a id="I_programlisting4_d1e20954"/><pre class="programlisting">// Access element i of <em class="replaceable"><code>recArray</code></em>:

     intmul( @size( <em class="replaceable"><code>recElement</code></em> ), i, ebx );  // ebx := i*@size( <em class="replaceable"><code>recElement</code></em> )
     mov( <em class="replaceable"><code>recArray</code></em>.<em class="replaceable"><code>someField</code></em>[ebx], eax );</pre><p>Note that the index specification follows the entire variable name; remember, this is assembly, not a high-level language (in a high-level language you'd probably use <em class="replaceable"><code>recArray</code></em><code class="literal">[i].</code><em class="replaceable"><code>someField</code></em>).</p><p>Naturally, you can create multidimensional arrays of records as well. You would use the row-major or column-major order functions to compute the address of an element within such records. The only thing that really changes (from the discussion of arrays) is that the size of each element is the size of the record object.</p><a id="I_programlisting4_d1e20982"/><pre class="programlisting">static
     rec2D: recElement[ 4, 6 ];
          .
          .
          .
     // Access element [i,j] of rec2D and load <em class="replaceable"><code>someField</code></em> into eax:

     intmul( 6, i, ebx );
     add( j, ebx );
     intmul( @size( <em class="replaceable"><code>recElement</code></em> ), ebx );
     mov( rec2D.<em class="replaceable"><code>someField</code></em>[ ebx ], eax );</pre></div>
<div class="sect1" title="4.28 Arrays/Records as Record Fields"><div class="titlepage"><div><div><h1 class="title"><a id="arrays_solidus_records_as_record_fields"/>4.28 Arrays/Records as Record Fields</h1></div></div></div><p>Records may contain other records or arrays as fields. Consider the following definition:</p><a id="I_programlisting4_d1e20998"/><pre class="programlisting">type
     Pixel:
          record
               Pt:        point;
               color:     dword;
          endrecord;</pre><p>The definition above defines a single point with a 32-bit color component. When initializing an object of type <code class="literal">Pixel</code>, the first initializer corresponds to the <code class="literal">Pt</code> field, <span class="emphasis"><em>not the</em></span> <em class="replaceable"><code>x-coordinate</code></em> <span class="emphasis"><em>field</em></span>. The following definition is incorrect:</p><a id="I_programlisting4_d1e21017"/><pre class="programlisting">static
     ThisPt: Pixel := Pixel:[ 5, 10 ];   // Syntactically incorrect!</pre><p>The value of the first field (5) is not an object of type <code class="literal">point</code>. Therefore, the assembler generates an error when encountering this statement. HLA will allow you to initialize the fields of <code class="literal">Pixel</code> using declarations like the following:</p><a id="I_programlisting4_d1e21027"/><pre class="programlisting">static
     ThisPt: Pixel := Pixel:[ point:[ 1, 2, 3 ], 10 ];
     ThatPt: Pixel := Pixel:[ point:[ 0, 0, 0 ], 5 ];</pre><p>Accessing <code class="literal">Pixel</code> fields is very easy. As in a high-level language, you use a single period to reference the <code class="literal">Pt</code> field and a second period to access the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> fields of <code class="literal">point</code>:</p><a id="I_programlisting4_d1e21050"/><pre class="programlisting">stdout.put( "ThisPt.Pt.x = ", ThisPt.Pt.x, nl );
          stdout.put( "ThisPt.Pt.y = ", ThisPt.Pt.y, nl );
          stdout.put( "ThisPt.Pt.z = ", ThisPt.Pt.z, nl );
           .
           .
           .
     mov( eax, ThisPt.Color );</pre><p>You can also declare arrays as record fields. The following record creates a data type capable of representing an object with eight points (for example, a cube):</p><a id="I_programlisting4_d1e21054"/><pre class="programlisting">type
     Object8:
          record
               Pts:       point[8];
               Color:     dword;
          endrecord;</pre><p>This record allocates storage for eight different points. Accessing an element of the <code class="literal">Pts</code> array requires that you know the size of an object of type <code class="literal">point</code> (remember, you must multiply the index into the array by the size of one element, 12 in this particular case). Suppose, for example, that you have a variable <code class="literal">Cube</code> of type <code class="literal">Object8</code>. You could access elements of the <code class="literal">Pts</code> array as follows:</p><a id="I_programlisting4_d1e21074"/><pre class="programlisting">// Cube.Pts[i].x := 0;

          mov( i, ebx );
          intmul( 12, ebx );
          mov( 0, Cube.Pts.x[ebx] );</pre><p>The one unfortunate aspect of all this is that you must know the size of each element of the <code class="literal">Pts</code> array. Fortunately, you can rewrite the code above using <code class="literal">@size</code> as follows:</p><a id="I_programlisting4_d1e21084"/><pre class="programlisting">// Cube.Pts[i].x := 0;

          mov( i, ebx );
          intmul( @size( point ), ebx );
          mov( 0, Cube.Pts.x[ebx] );</pre><p>Note in this example that the index specification (<code class="literal">[ebx]</code>) follows the whole object name even though the array is <code class="literal">Pts</code>, not <code class="literal">x</code>. Remember, the <code class="literal">[ebx]</code> specification is an indexed addressing mode, not an array index. Indexes always follow the entire name, so you do not attach them to the array component as you would in a high-level language like C/C++ or Pascal. This produces the correct result because addition is commutative, and the dot operator (as well as the index operator) corresponds to addition. In particular, the expression <code class="literal">Cube.Pts.x[ebx]</code> tells HLA to compute the sum of <code class="literal">Cube</code> (the base address of the object) plus the offset to the <code class="literal">Pts</code> field, plus the offset to the <code class="literal">x</code> field, plus the value of EBX. Technically, we're really computing offset(<code class="literal">Cube</code>) + offset(<code class="literal">Pts</code>) + EBX + offset(<code class="literal">x</code>), but we can rearrange this because addition is commutative.<a class="indexterm" id="IDX-CHP-4-0207"/></p><p>You can also define two-dimensional arrays within a record. Accessing elements of such arrays is no different than accessing any other two-dimensional array other than the fact that you must specify the array's field name as the base address for the array. For example:</p><a id="I_programlisting4_d1e21128"/><pre class="programlisting">type
     RecW2DArray:
          record
               intField: int32;
               aField:   int32[4,5];
                    .
                    .
                    .
          endrecord;

static
     recVar: RecW2DArray;
          .
          .
          .
     // Access element [i,j] of the aField field using row-major ordering:

     mov( i, ebx );
     intmul( 5, ebx );
     add( j, ebx );
     mov( recVar.aField[ ebx*4 ], eax );
          .
          .
          .</pre><p>The code above uses the standard row-major calculation to index into a 4x5 array of double words. The only difference between this example and a standalone array access is the fact that the base address is <code class="literal">recVar.aField</code>.</p><p>There are two common ways to nest record definitions. As this section notes, you can create a record type in a <code class="literal">type</code> section and then use that type name as the data type of some field within a record (e.g., the <code class="literal">Pt:point</code> field in the <code class="literal">Pixel</code> data type above). It is also possible to declare a record directly within another record without creating a separate data type for that record; the following example demonstrates this:</p><a id="I_programlisting4_d1e21146"/><pre class="programlisting">type
     NestedRecs:
          record
               iField: int32;
               sField: string;
               rField:
                    record
                         i:int32;
                         u:uns32;
                    endrecord;
               cField:char;
          endrecord;</pre><p>Generally, it's a better idea to create a separate type rather than embed records directly in other records, but nesting them is perfectly legal.</p><p>If you have an array of records and one of the fields of that record type is an array, you must compute the indexes into the arrays independently of one another and then use the sum of these indexes as the ultimate index. The following example demonstrates how to do this:</p><a id="I_programlisting4_d1e21153"/><pre class="programlisting">type
     recType:
          record
               arrayField: dword[4,5];
               &lt;&lt; Other fields &gt;&gt;
          endrecord;

static
     aryOfRecs: recType[3,3];
          .
          .
          .
     // Access aryOfRecs[i,j].arrayField[k,l]:

     intmul( 5, i, ebx );               // Computes index into aryOfRecs
     add( j, ebx );                     // as (i*5 +j)*@size( recType ).
     intmul( @size( recType ), ebx );

     intmul( 3, k, eax );               // Computes index into aryOfRecs
     add( l, eax );                     // as (k*3 + j) (*4 handled later).

     mov( aryOfRecs.arrayField[ ebx + eax*4 ], eax );</pre><p>Note the use of the base plus scaled indexed addressing mode to simplify this operation.</p></div>
<div class="sect1" title="4.29 Aligning Fields Within a Record"><div class="titlepage"><div><div><h1 class="title"><a id="aligning_fields_within_a_record"/>4.29 Aligning Fields Within a Record</h1></div></div></div><p>To achieve maximum performance in your programs, or to ensure that HLA's records properly map to records or structures in some high-level language, you will often need to be able to control the alignment of fields within a record. For example, you might want to ensure that a double-word field's offset is an even multiple of 4. You use the <code class="literal">align</code> directive to do this. The following example shows how to align some fields on important boundaries:<a class="indexterm" id="IDX-CHP-4-0208"/><a class="indexterm" id="IDX-CHP-4-0209"/><a class="indexterm" id="IDX-CHP-4-0210"/><a class="indexterm" id="IDX-CHP-4-0211"/></p><a id="I_programlisting4_d1e21183"/><pre class="programlisting">type
     PaddedRecord:
          record
               c:  char;
               align(4);
               d:  dword;
               b:  boolean;
               align(2);
               w:  word;
          endrecord;</pre><p>Whenever HLA encounters the <code class="literal">align</code> directive within a record declaration, it automatically adjusts the following field's offset so that it is an even multiple of the value the <code class="literal">align</code> directive specifies. It accomplishes this by increasing the offset of that field, if necessary. In the example above, the fields would have the following offsets: <code class="literal">c:0</code>, <code class="literal">d:4</code>, <code class="literal">b:8</code>, <code class="literal">w:10</code>. Note that HLA inserts 3 bytes of padding between <code class="literal">c</code> and <code class="literal">d</code>, and it inserts 1 byte of padding between <code class="literal">b</code> and <code class="literal">w</code>. It goes without saying that you should never assume that this padding is present. If you want to use those extra bytes, then you must declare fields for them.</p><p>Note that specifying alignment within a record declaration does not guarantee that the field will be aligned on that boundary in memory; it only ensures that the field's offset is a multiple of the value you specify. If a variable of type <code class="literal">PaddedRecord</code> starts at an odd address in memory, then the <code class="literal">d</code> field will also start at an odd address (because any odd address plus 4 is an odd address). If you want to ensure that the fields are aligned on appropriate boundaries in memory, you must also use the <code class="literal">align</code> directive before variable declarations of that record type. For example:</p><a id="I_programlisting4_d1e21229"/><pre class="programlisting">static
          .
          .
          .
     align(4);
     PRvar: PaddedRecord;</pre><p>The value of the <code class="literal">align</code> operand should be an even value that is divisible by the largest <code class="literal">align</code> expression within the record type (4 is the largest value in this case, and it's already divisible by 2).</p><p>If you want to ensure that the record's size is a multiple of some value, then simply stick an <code class="literal">align</code> directive as the last item in the record declaration. HLA will emit an appropriate number of bytes of padding at the end of the record to fill it in to the appropriate size. The following example demonstrates how to ensure that the record's size is a multiple of 4 bytes:<a class="indexterm" id="IDX-CHP-4-0212"/><a class="indexterm" id="IDX-CHP-4-0213"/></p><a id="I_programlisting4_d1e21254"/><pre class="programlisting">type
     PaddedRec:
          record
               &lt;&lt; Some field declarations &gt;&gt;

               align(4);
          endrecord;</pre><p>HLA provides some additional alignment directives for records that let you easily control the alignment of all fields within a record and the starting offset of the fields in a record. If you're interested in more information, please consult the HLA reference manual.<a class="indexterm" id="IDX-CHP-4-0214"/></p></div>
<div class="sect1" title="4.30 Pointers to Records"><div class="titlepage"><div><div><h1 class="title"><a id="pointers_to_records"/>4.30 Pointers to Records</h1></div></div></div><p>During execution, your program may refer to record objects indirectly using a pointer. When you use a pointer to access fields of a structure, you must load one of the 80x86's 32-bit registers with the address of the desired record. Suppose you have the following variable declarations (assuming the <code class="literal">Object8</code> structure from an earlier section):</p><a id="I_programlisting4_d1e21272"/><pre class="programlisting">static
     Cube:          Object8;
     CubePtr:       pointer to Object8 := &amp;Cube;</pre><p><code class="literal">CubePtr</code> contains the address of (that is, it is a pointer to) the <code class="literal">Cube</code> object. To access the <code class="literal">Color</code> field of the <code class="literal">Cube</code> object, you could use an instruction like <code class="literal">mov( Cube.Color, eax );</code>. When accessing a field via a pointer, you first need to load the address of the object into a 32-bit register such as EBX. The instruction <code class="literal">mov( CubePtr, ebx );</code> will do the trick. After doing so, you can access fields of the <code class="literal">Cube</code> object using the <code class="literal">[ebx+offset]</code> addressing mode. The only problem is, "How do you specify which field to access?" Consider briefly the following <span class="emphasis"><em>incorrect</em></span> code:</p><a id="I_programlisting4_d1e21303"/><pre class="programlisting">mov( CubePtr, ebx );
          mov( [ebx].Color, eax );      // This does not work!</pre><p>Because field names are local to a structure and it's possible to reuse a field name in two or more structures, how does HLA determine which offset <code class="literal">Color</code> represents? When accessing structure members directly (e.g., <code class="literal">mov( Cube.Color, eax )</code>;), there is no ambiguity because <code class="literal">Cube</code> has a specific type that the assembler can check. <code class="literal">[ebx]</code>, on the other hand, can point at <span class="emphasis"><em>anything</em></span>. In particular, it can point at any structure that contains a <code class="literal">Color</code> field. So the assembler cannot, on its own, decide which offset to use for the <code class="literal">Color</code> symbol.<a class="indexterm" id="IDX-CHP-4-0215"/><a class="indexterm" id="IDX-CHP-4-0216"/><a class="indexterm" id="IDX-CHP-4-0217"/><a class="indexterm" id="IDX-CHP-4-0218"/><a class="indexterm" id="IDX-CHP-4-0219"/></p><p>HLA resolves this ambiguity by requiring that you explicitly supply a type. To do this, you must coerce <code class="literal">[ebx]</code> to type <code class="literal">Cube</code>. Once you do this, you can use the normal dot operator notation to access the <code class="literal">Color</code> field:</p><a id="I_programlisting4_d1e21361"/><pre class="programlisting">mov( CubePtr, ebx );
mov( (type Cube [ebx]).Color, eax );</pre><p>If you have a pointer to a record and one of that record's fields is an array, the easiest way to access elements of that field is by using the base-plus-indexed addressing mode. To do so, you just load the pointer's value into one register and compute the index into the array in a second register. Then you combine these two registers in the address expression. In the example above, the <code class="literal">Pts</code> field is an array of eight <code class="literal">point</code> objects. To access field <code class="literal">x</code> of the <code class="literal">i</code>th element of the <code class="literal">Cube.Pts</code> field, you'd use code like the following:</p><a id="I_programlisting4_d1e21380"/><pre class="programlisting">mov( CubePtr, ebx );
intmul( @size( point ), i, esi );   // Compute index into point array.
mov( (type Object8 [ebx]).Pts.x[ esi*4 ], eax );</pre><p>If you use a pointer to a particular record type frequently in your program, typing a coercion operator like <code class="literal">(type Object8 [ebx])</code> can get old very quickly. One way to reduce the typing needed to coerce EBX is to use a <code class="literal">text</code> constant. Consider the following statement:<a class="indexterm" id="IDX-CHP-4-0220"/><a class="indexterm" id="IDX-CHP-4-0221"/></p><a id="I_programlisting4_d1e21399"/><pre class="programlisting">const
     O8ptr: text := "(type Object8 [ebx])";</pre><p>With this statement at the beginning of your program, you can use <code class="literal">O8ptr</code> in place of the type coercion operator, and HLA will automatically substitute the appropriate text. With a text constant like the above, the former example becomes a little more readable and writable:</p><a id="I_programlisting4_d1e21406"/><pre class="programlisting">mov( CubePtr, ebx );
intmul( @size( point ), i, esi );   // Compute index into point array.
mov( O8Ptr.Pts.x[ esi*4 ], eax );</pre></div>
<div class="sect1" title="4.31 Unions"><div class="titlepage"><div><div><h1 class="title"><a id="unions"/>4.31 Unions</h1></div></div></div><p>A record definition assigns different offsets to each field in the record according to the size of those fields. This behavior is quite similar to the allocation of memory offsets in a <code class="literal">var</code> or <code class="literal">static</code> section. HLA provides a second type of structure declaration, the <code class="literal">union</code>, that does not assign different addresses to each object; instead, each field in a <code class="literal">union</code> declaration has the same offset—0. The following example demonstrates the syntax for a <code class="literal">union</code> declaration:<a class="indexterm" id="IDX-CHP-4-0222"/><a class="indexterm" id="IDX-CHP-4-0223"/></p><a id="I_programlisting4_d1e21439"/><pre class="programlisting">type
     <em class="replaceable"><code>unionType</code></em>:
          union
               &lt;&lt; Fields (syntactically identical to record declarations) &gt;&gt;
          endunion;</pre><p>You access the fields of a <code class="literal">union</code> exactly the same way you access the fields of a record: using dot notation and field names. The following is a concrete example of a <code class="literal">union</code> type declaration and a variable of the <code class="literal">union</code> type:</p><a id="I_programlisting4_d1e21455"/><pre class="programlisting">type
     numeric:
          union
               i: int32;
               u: uns32;
               r: real64;
          endunion;
               .
               .
               .
static
     number: numeric;
               .
               .
               .
     mov( 55, number.u );
               .
               .
               .
     mov( −5, number.i );
               .
               .
               .
     stdout.put( "Real value = ", number.r, nl );</pre><p>The important thing to note about <code class="literal">union</code> objects is that all the fields of a <code class="literal">union</code> have the same offset in the structure. In the example above, the <code class="literal">number.u</code>, <code class="literal">number.i</code>, and <code class="literal">number.r</code> fields all have the same offset: 0. Therefore, the fields of a <code class="literal">union</code> overlap in memory; this is very similar to the way the 80x86 8-, 16-, and 32-bit registers overlap one another. Usually, you may access only one field of a <code class="literal">union</code> at a time; that is, you do not manipulate separate fields of a particular <code class="literal">union</code> variable concurrently because writing to one field overwrites the other fields. In the example above, any modification of <code class="literal">number.u</code> would also change <code class="literal">number.i</code> and <code class="literal">number.r</code>.</p><p>Programmers typically use unions for two different reasons: to conserve memory or to create aliases. Memory conservation is the intended use of this data structure facility. To see how this works, let's compare the <code class="literal">numeric union</code> above with a corresponding record type.</p><a id="I_programlisting4_d1e21498"/><pre class="programlisting">type
     numericRec:
          record
               i: int32;
               u: uns32;
               r: real64;
          endrecord;</pre><p>If you declare a variable, say <code class="literal">n</code>, of type <code class="literal">numericRec</code>, you access the fields as <code class="literal">n.i</code>, <code class="literal">n.u</code>, and <code class="literal">n.r</code> exactly as though you had declared the variable to be type <code class="literal">numeric</code>. The difference between the two is that <code class="literal">numericRec</code> variables allocate separate storage for each field of the record, whereas <code class="literal">numeric</code> (union) objects allocate the same storage for all fields. Therefore, <code class="literal">@size(numericRec)</code> is 16 because the record contains two double-word fields and a quad word (<code class="literal">real64</code>) field. <code class="literal">@size(numeric)</code>, however, is 8. This is because all the fields of a <code class="literal">union</code> occupy the same memory locations, and the size of a <code class="literal">union</code> object is the size of the largest field of that object (see <a class="xref" href="ch04s31.html#layout_of_a_union_versus_a_record_variab" title="Figure 4-11. Layout of a union versus a record variable">Figure 4-11</a>).<a class="indexterm" id="IDX-CHP-4-0224"/><a class="indexterm" id="IDX-CHP-4-0225"/></p><div class="figure"><a id="layout_of_a_union_versus_a_record_variab"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e21562"/><img alt="Layout of a union versus a record variable" src="tagoreillycom20100401nostarchimages577999.png"/></div></div><p class="title">Figure 4-11. Layout of a <code class="literal">union</code> versus a <code class="literal">record</code> variable</p></div><p>In addition to conserving memory, programmers often use unions to create aliases in their code. As you may recall, an alias is a different name for the same memory object. Aliases are often a source of confusion in a program, so you should use them sparingly; sometimes, however, using an alias can be quite convenient. For example, in some section of your program you might need to constantly use type coercion to refer to an object using a different type. Although you can use an HLA <code class="literal">text</code> constant to simplify this process, another way to do this is to use a <code class="literal">union</code> variable with the fields representing the different types you want to use for the object. As an example, consider the following code:<a class="indexterm" id="IDX-CHP-4-0226"/></p><a id="I_programlisting4_d1e21579"/><pre class="programlisting">type
     CharOrUns:
          union
               c:char;
               u:uns32;
          endrecord;

static
     v:CharOrUns;</pre><p>With a declaration like the above, you can manipulate an <code class="literal">uns32</code> object by accessing <code class="literal">v.u</code>. If, at some point, you need to treat the L.O. byte of this <code class="literal">uns32</code> variable as a character, you can do so by simply accessing the <code class="literal">v.c</code> variable, for example,</p><a id="I_programlisting4_d1e21595"/><pre class="programlisting">mov( eax, v.u );
     stdout.put( "v, as a character, is '", v.c, "'" nl );</pre><p>You can use unions exactly the same way you use records in an HLA program. In particular, <code class="literal">union</code> declarations may appear as fields in records, <code class="literal">record</code> declarations may appear as fields in unions, array declarations may appear within unions, you can create arrays of unions, and so on.<a class="indexterm" id="IDX-CHP-4-0227"/><a class="indexterm" id="IDX-CHP-4-0228"/></p></div>
<div class="sect1" title="4.32 Anonymous Unions"><div class="titlepage"><div><div><h1 class="title"><a id="anonymous_unions"/>4.32 Anonymous Unions</h1></div></div></div><p>Within a <code class="literal">record</code> declaration you can place a <code class="literal">union</code> declaration without specifying a fieldname for the <code class="literal">union</code> object. The following example demonstrates the syntax for this:</p><a id="I_programlisting4_d1e21629"/><pre class="programlisting">type
     HasAnonUnion:
          record
               r:real64;
               union
                    u:uns32;
                    i:int32;
               endunion;
               s:string;
          endrecord;

static
     v: HasAnonUnion;</pre><p>Whenever an anonymous union appears within a <code class="literal">record</code> you can access the fields of the <code class="literal">union</code> as though they were direct fields of the <code class="literal">record</code>. In the example above, for example, you would access <code class="literal">v</code>'s <code class="literal">u</code> and <code class="literal">i</code> fields using the syntax <code class="literal">v.u</code> and <code class="literal">v.i</code>, respectively. The <code class="literal">u</code> and <code class="literal">i</code> fields have the same offset in the record (8, because they follow a <code class="literal">real64</code> object). The fields of <code class="literal">v</code> have the following offsets from <code class="literal">v</code>'s base address:</p><a id="I_programlisting4_d1e21674"/><pre class="programlisting">v.r           0
     v.u           8
     v.i           8
     v.s          12</pre><p><code class="literal">@size(v)</code> is 16 because the <code class="literal">u</code> and <code class="literal">i</code> fields consume only 4 bytes.</p><p>HLA also allows anonymous records within unions. Please see the HLA documentation for more details, though the syntax and usage are identical to anonymous unions within records.</p></div>
<div class="sect1" title="4.33 Variant Types"><div class="titlepage"><div><div><h1 class="title"><a id="variant_types"/>4.33 Variant Types</h1></div></div></div><p>One big use of unions in programs is to create <span class="emphasis"><em>variant</em></span> types. A variant variable can change its type dynamically while the program is running. A variant object can be an integer at one point in the program, switch to a string at a different part of the program, and then change to a real value at a later time. Many very-high-level language (VHLL) systems use a dynamic type system (that is, variant objects) to reduce the overall complexity of the program; indeed, proponents of many VHLLs insist that the use of a dynamic typing system is one of the reasons you can write complex programs with so few lines of code using those languages. Of course, if you can create variant objects in a VHLL, you can certainly do it in assembly language. In this section we'll look at how we can use the <code class="literal">union</code> structure to create variant types.<a class="indexterm" id="IDX-CHP-4-0229"/><a class="indexterm" id="IDX-CHP-4-0230"/><a class="indexterm" id="IDX-CHP-4-0231"/></p><p>At any one given instant during program execution, a variant object has a specific type, but under program control the variable can switch to a different type. Therefore, when the program processes a variant object, it must use an <code class="literal">if</code> statement or <code class="literal">switch</code> statement (or something similar) to execute different instructions based on the object's current type. Very-high-level languages do this transparently. In assembly language you will have to provide the code to test the type yourself. To achieve this, the variant type needs some additional information beyond the object's value. Specifically, the variant object needs a field that specifies the current type of the object. This field (often known as the <code class="literal">tag</code> field) is an enumerated type or integer that specifies the object's type at any given instant. The following code demonstrates how to create a variant type:</p><a id="I_programlisting4_d1e21721"/><pre class="programlisting">type
     VariantType:
          record
               tag:uns32;  // 0-uns32, 1-int32, 2-real64
               union
                    u:uns32;
                    i:int32;
                    r:real64;
               endunion;
          endrecord;

static
     v:VariantType;</pre><p>The program would test the <code class="literal">v.tag</code> field to determine the current type of the <code class="literal">v</code> object. Based on this test, the program would manipulate the <code class="literal">v.i</code>, <code class="literal">v.u</code>, or <code class="literal">v.r</code> field.</p><p>Of course, when operating on variant objects, the program's code must constantly be testing the <code class="literal">tag</code> field and executing a separate sequence of instructions for <code class="literal">uns32</code>, <code class="literal">int32</code>, or <code class="literal">real64</code> values. If you use the variant fields often, it makes a lot of sense to write procedures to handle these operations for you (e.g., <em class="replaceable"><code>vadd</code></em>, <em class="replaceable"><code>vsub</code></em>, <em class="replaceable"><code>vmul</code></em>, and <em class="replaceable"><code>vdiv</code></em>).</p></div>
<div class="sect1" title="4.34 Namespaces"><div class="titlepage"><div><div><h1 class="title"><a id="namespaces"/>4.34 Namespaces</h1></div></div></div><p>One really nice feature of records and unions is that the field names are local to a given <code class="literal">record</code> or <code class="literal">union</code> declaration. That is, you can reuse field names in different records or unions. This is an important feature of HLA because it helps avoid <span class="emphasis"><em>namespace pollution</em></span>. Namespace pollution occurs when you use up all the "good" names within your program and you have to start creating nondescriptive names for objects because you've already used the most appropriate name for something else. We use the term <span class="emphasis"><em>namespace</em></span> to describe how HLA associates names with a particular object. The field names of a <code class="literal">record</code> have a namespace that is limited to objects of that record type. HLA provides a generalization of this namespace mechanism that lets you create arbitrary namespaces. These namespace objects let you shield the names of constants, types, variables, and other objects so their names do not interfere with other declarations in your program.<a class="indexterm" id="IDX-CHP-4-0232"/><a class="indexterm" id="IDX-CHP-4-0233"/></p><p>An HLA <code class="literal">namespace</code> section encapsulates a set of generic declarations in much the same way that a <code class="literal">record</code> encapsulates a set of variable declarations. A <code class="literal">namespace</code> declaration takes the following form:</p><a id="I_programlisting4_d1e21809"/><pre class="programlisting">namespace <em class="replaceable"><code>name</code></em>;

     &lt;&lt; declarations &gt;&gt;

end <em class="replaceable"><code>name</code></em>;</pre><p>The <em class="replaceable"><code>name</code></em> identifier provides the name for the <code class="literal">namespace</code>. The identifier after the <code class="literal">end</code> clause must exactly match the identifier after <code class="literal">namespace</code>. Note that a <code class="literal">namespace</code> declaration section is a section unto itself. It does not have to appear in a <code class="literal">type</code> or <code class="literal">var</code> section. A <code class="literal">namespace</code> may appear anywhere one of the HLA declaration sections is legal. A program may contain any number of <code class="literal">namespace</code> declarations; in fact, the namespace identifiers don't even have to be unique, as you will soon see.</p><p>The declarations that appear between the <code class="literal">namespace</code> and <code class="literal">end</code> clauses are all the standard HLA declaration sections except that you cannot nest <code class="literal">namespace</code> declarations. You may, however, put <code class="literal">const</code>, <code class="literal">val</code>, <code class="literal">type</code>, <code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code> sections within a <code class="literal">namespace</code>.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-21" id="CHP-4-FN-21">67</a>]</sup> The following code provides an example of a typical <code class="literal">namespace</code> declaration in an HLA program:</p><a id="I_programlisting4_d1e21893"/><pre class="programlisting">namespace myNames;

     type
          integer: int32;

     static
          i:integer;
          j:uns32;

     const
          pi:real64 := 3.14159;

end myNames;</pre><p>To access the fields of a namespace you use the same dot notation that records and unions use. For example, to access the fields of <code class="literal">myNames</code> outside of the namespace, you'd use the following identifiers:<a class="indexterm" id="IDX-CHP-4-0234"/></p><a id="I_programlisting4_d1e21905"/><pre class="programlisting">myNames.integer       A type declaration equivalent to int32
myNames.i             An integer variable (int32)
myNames.j             An uns32 variable
myNames.pi            A real64 constant</pre><p>This example also demonstrates an important point about <code class="literal">namespace</code> declarations: Within a namespace you may reference other identifiers in that same <code class="literal">namespace</code> declaration without using the dot notation. For example, the <code class="literal">i</code> field above uses type <code class="literal">integer</code> from the <code class="literal">myNames</code> namespace without the <code class="literal">mynames</code>. prefix.</p><p>What is not obvious from the example above is that <code class="literal">namespace</code> declarations create a clean symbol table whenever you open up a namespace. The only external symbols that HLA recognizes in a <code class="literal">namespace</code> declaration are the predefined type identifiers (e.g., <code class="literal">int32</code>, <code class="literal">uns32</code>, and <code class="literal">char</code>). HLA does not recognize any symbols you've declared outside the namespace while it is processing your <code class="literal">namespace</code> declaration. This creates a problem if you want to use symbols from outside the namespace when declaring other symbols inside the namespace. For example, suppose the type <code class="literal">integer</code> had been defined outside <code class="literal">myNames</code> as follows:</p><a id="I_programlisting4_d1e21956"/><pre class="programlisting">type
     integer: int32;

namespace myNames;


     static
          i:integer;
          j:uns32;

     const
          pi:real64 := 3.14159;

end myNames;</pre><p>If you were to attempt to compile this code, HLA would complain that the symbol <code class="literal">integer</code> is undefined. Clearly <code class="literal">integer</code> is defined in this program, but HLA hides all external symbols when creating a namespace so that you can reuse (and redefine) those symbols within the namespace. Of course, this doesn't help much if you actually want to use a name that you've defined outside <code class="literal">myNames</code> within that namespace. HLA provides a solution to this problem: the <code class="literal">@global:</code> operator. If, within a <code class="literal">namespace</code> declaration section, you prefix a name with <code class="literal">@global:</code>, then HLA will use the global definition of that name rather than the local definition (if a local definition even exists). To correct the problem in the previous example, you'd use the following code:<a class="indexterm" id="IDX-CHP-4-0235"/></p><a id="I_programlisting4_d1e21982"/><pre class="programlisting">type
     integer: int32;

namespace myNames;


     static
          i:@global:integer;
          j:uns32;

     const
          pi:real64 := 3.14159;

end myNames;</pre><p>With the <code class="literal">@global:</code> prefix, the <code class="literal">i</code> variable will be type <code class="literal">int32</code> even if a different declaration of <code class="literal">integer</code> appears within the <code class="literal">myNames</code> namespace.</p><p>You cannot nest <code class="literal">namespace</code> declarations. Logically, there doesn't seem to be any need for this, hence its omission from the HLA language.</p><p>You can have multiple <code class="literal">namespace</code> declarations in the same program that use the same namespace identifier. For example:</p><a id="I_programlisting4_d1e22011"/><pre class="programlisting">namespace ns;

     &lt;&lt; Declaration group #1 &gt;&gt;

end ns;
     .
     .
     .
namespace ns;

     &lt;&lt; Declaration group #2 &gt;&gt;

end ns;</pre><p>When HLA encounters a second <code class="literal">namespace</code> declaration for a given identifier, it simply appends the declarations in the second group to the end of the symbol list it created for the first group. Therefore, after processing the two <code class="literal">namespace</code> declarations, the <code class="literal">ns</code> namespace would contain the set of all symbols you've declared in both <code class="literal">namespace</code> blocks.</p><p>Perhaps the most common use of namespaces is in library modules. If you create a set of library routines to use in various projects or distribute to others, you have to be careful about the names you choose for your functions and other objects. If you use common names like <code class="literal">get</code> and <code class="literal">put</code>, the users of your module will complain when your names collide with theirs. An easy solution is to put all your code in a <code class="literal">namespace</code> block. Then the only name you have to worry about is the <code class="literal">namespace</code> identifier itself. This is the only name that will collide with other users' identifiers. This can happen, but it's much less likely to happen than if you don't use a namespace and your library module introduces dozens, if not hundreds, of new names into the global namespace.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-22" id="CHP-4-FN-22">68</a>]</sup> The HLA Standard Library provides many good examples of namespaces in use. The HLA Standard Library defines several namespaces like <code class="literal">stdout</code>, <code class="literal">stdin</code>, <code class="literal">str</code>, <code class="literal">cs</code>, and <code class="literal">chars</code>. You refer to functions in these namespaces using names like <code class="literal">stdout.put</code>, <code class="literal">stdin.get</code>, <code class="literal">cs.intersection</code>, <code class="literal">str.eq</code>, and <code class="literal">chars.toUpper</code>. The use of namespaces in the HLA Standard Library prevents conflicts with similar names in your own programs.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-21" id="ftn.CHP-4-FN-21">67</a>] </sup>Procedure declarations, the subject of <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>, are also legal within a <code class="literal">namespace</code> declaration section.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-22" id="ftn.CHP-4-FN-22">68</a>] </sup>The global namespace is the global section of your program.</p></div></div></div>
<div class="sect1" title="4.35 Dynamic Arrays in Assembly Language"><div class="titlepage"><div><div><h1 class="title"><a id="dynamic_arrays_in_assembly_language"/>4.35 Dynamic Arrays in Assembly Language</h1></div></div></div><p>One problem with arrays as this chapter describes them is that their size is static. That is, the number of elements in all of the examples was chosen when writing the program; it was not selected while the program runs (that is, dynamically). Alas, sometimes you simply don't know how big an array needs to be when you're writing the program; you can only determine the size of the array while the program is running. This section describes how to allocate storage for arrays dynamically so you can set their size at runtime.<a class="indexterm" id="IDX-CHP-4-0236"/><a class="indexterm" id="IDX-CHP-4-0237"/></p><p>Allocating storage for a single-dimensional array, and accessing elements of that array, is a nearly trivial task at runtime. All you need to do is call the HLA Standard Library <code class="literal">mem.alloc</code> routine, specifying the size of the array in bytes. <code class="literal">mem.alloc</code> will return a pointer to the base address of the new array in the EAX register. Typically, you would save this address in a pointer variable and use that value as the base address of the array in all future array accesses.<a class="indexterm" id="IDX-CHP-4-0238"/></p><p>To access an element of a single-dimensional dynamic array, you would generally load the base address into a register and compute the index in a second register. Then you could use the base-indexed addressing mode to access elements of that array. This is not a whole lot more work than accessing elements of a statically allocated array. The following code fragment demonstrates how to allocate and access elements of a single-dimensional dynamic array.</p><a id="I_programlisting4_d1e22105"/><pre class="programlisting">static
     ArySize:                    uns32;
     BaseAdrs:                   pointer to uns32;
          .
          .
          .
     stdout.put( "How many elements do you want in your array? " );
     stdin.getu32();
     mov( eax, ArySize );  // Save away the upper bounds on this array.
     shl( 2, eax );        // Multiply eax by 4 to compute the number of bytes.
     mem.alloc( eax );     // Allocate storage for the array.
     mov( eax, BaseAdrs ); // Save away the base address of the new array.
          .
          .
          .

     // Zero out each element of the array:

     mov( BaseAdrs, ebx );
     mov( 0, eax );
     for( mov(0, esi); esi &lt; ArySize; inc( esi )) do

          mov( eax, [ebx + esi*4 ]);

     endfor;</pre><p>Dynamically allocating storage for a multidimensional array is fairly straightforward. The number of elements in a multidimensional array is the product of all the dimension values; for example, a 4x5 array has 20 elements. So if you get the bounds for each dimension from the user, all you need to do is compute the product of all of these bound values and multiply the result by the size of a single element. This computes the total number of bytes in the array, the value that <code class="literal">mem.alloc</code> expects.</p><p>Accessing elements of multidimensional arrays is a little more problematic. The problem is that you need to keep the dimension information (that is, the bounds on each dimension) around because these values are needed when computing the row-major (or column-major) index into the array.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-23" id="CHP-4-FN-23">69</a>]</sup> The conventional solution is to store these bounds into a static array (generally you know the <span class="emphasis"><em>arity</em></span>, or number of dimensions, at compile time, so it is possible to statically allocate storage for this array of dimension bounds). This array of dynamic array bounds is known as a <span class="emphasis"><em>dope vector</em></span>. The following code fragment shows how to allocate storage for a two-dimensional dynamic array using a simple dope vector.<a class="indexterm" id="IDX-CHP-4-0239"/><a class="indexterm" id="IDX-CHP-4-0240"/></p><a id="I_programlisting4_d1e22133"/><pre class="programlisting">var
    ArrayPtr:   pointer to uns32;
    ArrayDims:  uns32[2];  // The dope vector
          .
          .
          .
    // Get the array bounds from the user:

    stdout.put( "Enter the bounds for dimension #1: " );
    stdin.get( ArrayDims[0] );

    stdout.put( "Enter the bounds for dimension #2: " );
    stdin.get( ArrayDims[1*4] );

    // Allocate storage for the array:

    mov( ArrayDims[0], eax );
    intmul( ArrayDims[1*4], eax );
    shl( 2, eax );        // Multiply by 4 because each element is 4 bytes.
    mem.alloc( eax );     // Allocate storage for the array and
    mov( eax, ArrayPtr ); // save away the pointer to the array.


    // Initialize the array:

    mov( 0, edx );
    mov( ArrayPtr, edi );
    for( mov( 0, ebx ); ebx &lt; ArrayDims[0]; inc( ebx )) do

        for( mov( 0, ecx ); ecx &lt; ArrayDims[1*4]; inc( ecx )) do

            // Compute the index into the array
            // as esi := ( ebx * ArrayDims[1*4] + ecx ) * 4
            // (Note that the final multiplication by 4 is
            //  handled by the scaled indexed addressing mode below.)

            mov( ebx, esi );
            intmul( ArrayDims[1*4], esi );
            add( ecx, esi );

            // Initialize the current array element with edx.

            mov( edx, [edi+esi*4] );
            inc( edx );

        endfor;

    endfor;</pre><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-23" id="ftn.CHP-4-FN-23">69</a>] </sup>Technically, you don't need the value of the leftmost dimension bound to compute an index into the array; however, if you want to check the index bounds using the <code class="literal">bound</code> instruction (or some other technique), you will need this value around at runtime as well.</p></div></div></div>
<div class="sect1" title="4.36 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id3"/>4.36 For More Information</h1></div></div></div><p>In the electronic edition of this book, which you'll find at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>, you will find additional information about data types. The HLA Standard Library documentation describes the HLA arrays package that provides support for dynamically allocated (and statically allocated) arrays, indexing into arrays, and many other array options. You should consult the HLA stdlib documentation for more details about this array package. For additional information about data structure representation in memory, you should consider reading my book <span class="emphasis"><em>Write Great Code, Volume 1</em></span> (No Starch Press, 2004). For an in-depth discussion of data types, you should consult a textbook on data structures and algorithms.</p></div></body></html>