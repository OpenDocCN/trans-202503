- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ADVANCED MEMORY FORENSICS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whether you hack games as a hobby or a business, you’ll eventually find yourself
    between a rock and . . . an unintelligible memory dump. Be it a race with a rival
    bot developer to release a highly requested feature, a battle against a game company’s
    constant barrage of updates, or a struggle to locate some complex data structure
    in memory, you’ll need top-notch memory forensics skills to prevail.
  prefs: []
  type: TYPE_NORMAL
- en: Successful bot development is precariously balanced atop speed and skill, and
    tenacious hackers must rise to the challenge by swiftly releasing ingenious features,
    promptly responding to game updates, and readily searching for even the most elusive
    pieces of data. Doing this, however, requires a comprehensive understanding of
    common memory patterns, advanced data structures, and the purpose of different
    pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: Those three aspects of memory forensics are perhaps the most effective weapons
    in your arsenal, and this chapter will teach you how to use them. First, I’ll
    discuss advanced memory-scanning techniques that focus on searching for data by
    understanding its purpose and usage. Next, I’ll teach you how to use memory patterns
    to tackle game updates and tweak your bots without having to relocate all of your
    addresses from scratch. To wrap up, I’ll dissect the four most common complex
    data structures in the C++ standard library (`std::string`, `std::vector`, `std::list`,
    and `std::map`) so you can recognize them in memory and enumerate their contents.
    By the end of the chapter, my hope is that you’ll have a deep understanding of
    memory forensics and be able to take on any challenge related to memory scanning.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Memory Scanning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within a game’s source code, each piece of data has a cold, calculated definition.
    When the game is being played, however, all of that data comes together to create
    something new. Players only experience the beautiful scenery, visceral sounds,
    and intense adventures; the data that drives these experiences is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, imagine Hacker A has just started tearing into his favorite
    game, wanting to automate some of the boring bits with a bot. He doesn’t have
    a complete understanding of memory yet, and to him, the data is nothing but assumptions.
    He thinks, “I have 500 health, so I can find the health address by telling Cheat
    Engine to look for a 4-byte integer with a value of 500.” Hacker A has an accurate
    understanding of data: it’s just information (values) stored at particular locations
    (addresses) using defined structures (types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine Hacker B, who already understands the game both inside and out;
    she knows how playing the game alters its state in memory, and the data no longer
    has any secrets. She knows that every defined property of the data can be determined
    given its purpose. Unlike Hacker A, Hacker B has an understanding of data that
    transcends the confines of a single variable declaration: she considers the data’s
    *purpose* and *usage*. In this section, we’ll discuss both.'
  prefs: []
  type: TYPE_NORMAL
- en: Each piece of data in a game has a purpose, and the assembly code of the game
    must, at some point, reference the data to fulfill that purpose. Finding the unique
    code that uses a piece of data means finding a version-agnostic marker that persists
    across game updates until the data is either removed or its purpose is changed.
    Let me show you why this is important.
  prefs: []
  type: TYPE_NORMAL
- en: '***Deducing Purpose***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, I’ve only shown you how to blindly search memory for a given piece of
    data without considering how it’s being used. This method can be effective, but
    it is not always efficient. In many cases, it’s much quicker to deduce the purpose
    of data, determine what code might use that data, and then locate that code to
    ultimately find the address of the data.
  prefs: []
  type: TYPE_NORMAL
- en: This might not sound easy, but neither does “scan the game’s memory for a specific
    value of a specific data type, and then continuously filter the result list based
    on changing criteria,” which is what you’ve learned to do thus far. So let’s look
    at how we might locate the address for health given its purpose. Consider the
    code in [Listing 5-1](ch05.xhtml#ch5exe1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: A structure containing the player’s vitals, and a function that
    displays them*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pretend that `printString()` is a fancy function to draw text on an
    in-game interface, then this code is pretty close to what you might find in a
    game. The `PlayerVital` structure has two properties: the `current` value and
    a `maximum` value. The value `health` is a `PlayerVital` structure, so it has
    these properties, too. Based on the name alone, you can deduce that `health` exists
    to display information about the player’s health, and you can see this purpose
    fulfilled when `printString()` uses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Even without the code, you can intuitively draw similar conclusions by just
    looking at the health text displayed in the game’s interface; a computer can’t
    do anything without code, after all. Aside from the actual `health` variable,
    there are a few code elements that need to exist to show a player this text. First,
    there needs to be some function to display text. Second, the strings `Health`
    and `of` must be nearby.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Why do I assume the text is split into two separate strings instead of one?
    The game interface shows that the current health value is between these two strings,
    but there are many ways that could happen, including format strings,* `strcat(`)*,
    or text aligned with multiple display text calls. When you’re analyzing data,
    it’s best to keep your assumptions broad to account for all possibilities.*'
  prefs: []
  type: TYPE_NORMAL
- en: To find `health` without using a memory scanner, we could utilize these two
    distinct strings. We probably wouldn’t have a clue what the function to display
    text looks like, where it is, or how many times it’s called, though. Realistically,
    the strings are all we would know to look for, and that’s enough. Let’s walk through
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding the Player’s Health with OllyDbg***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll walk you through how to track down the `health` structure in this section,
    but I’ve also included the binary I analyze in the book’s resource files. To follow
    along and get some hands-on practice, use the file *Chapter5_AdvancedMemoryForensics_Scanning.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: First, open OllyDbg and attach it to the executable. Then, open OllyDbg’s Executable
    modules window and double-click the main module; in my example, the main module
    is the only *.exe* in the module’s window. The CPU window should pop up. Now,
    right-click in the Disassembler pane and select **Search for** ▸ **All referenced
    text strings**. This should open the References window, shown in [Figure 5-1](ch05.xhtml#ch5fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: OllyDbg’s References window, showing only a list of strings. There
    would be a lot more than four in a real game.*'
  prefs: []
  type: TYPE_NORMAL
- en: From this window, right-click and select **Search for text**. A search dialog
    appears. Enter the string you’re looking for, as shown in [Figure 5-2](ch05.xhtml#ch5fig2),
    and make the search as broad as possible by disabling **Case sensitive** and enabling
    **Entire scope**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Searching for strings in OllyDbg*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** to execute the search. The References window comes back into focus
    with the first match highlighted. Double-click the match to see the assembly code
    that uses the string inside the CPU window. The Disassembler pane focuses on the
    line of code at 0x401030, which pushes the format string parameter to `printString()`.
    You can see this line in [Figure 5-3](ch05.xhtml#ch5fig3), where I’ve highlighted
    the entire function call block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Viewing the `printString()` call in the CPU window’s Disassembler
    pane*'
  prefs: []
  type: TYPE_NORMAL
- en: By reading the assembly code, you can get a very accurate understanding of exactly
    what the game is doing. The black bracket on the left shows that the string `Health`
    is inside a function call. Notice the arguments to that function. In order, these
    are EAX ➊, ECX ➋, and the format string at 0x4020D0 ➌. EAX is the value at 0x40301C,
    ECX is the value at 0x403018, and the format string contains `Health`. Since the
    string contains two format placeholders, you can assume that the remaining two
    parameters are the arguments for those placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what the arguments are and that they are pushed in reverse order, you
    can work backward and conclude that the original code looked something like [Listing
    5-2](ch05.xhtml#ch5exe2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: How a game hacker might interpret the assembly that [Figure 5-3](ch05.xhtml#ch5fig3)
    compiles to*'
  prefs: []
  type: TYPE_NORMAL
- en: The values stored in EAX and ECX are adjacent in memory, which means they may
    be part of a structure. To keep it simple, though, this example just shows them
    as variable definitions. Either way, these are the two numbers used to display
    the player’s health. Because both of these important values were displayed in
    the game’s UI, it was easy to make assumptions about the underlying code that
    displays them. When you know the purpose of a piece of data, you can quickly find
    the code responsible for fulfilling it; in this case, that knowledge helped us
    quickly find both addresses.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, finding addresses can be this easy, but some pieces of data have
    such complex purposes that it’s harder to guess what to look for. Figuring out
    how to search for map data or character locations in OllyDbg, for instance, can
    be pretty tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are far from the only markers that you can use to find the data you
    want to change in a game, but they are definitely the easiest to teach without
    giving contrived examples. Moreover, some games have logging or error strings
    embedded in their code, and poking around in the Referenced text strings window
    of OllyDbg can be a quick way to determine whether these strings are present.
    If you become familiar with a game’s logging practices, you’ll be able to find
    values even more easily.
  prefs: []
  type: TYPE_NORMAL
- en: '***Determining New Addresses After Game Updates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When application code is modified and recompiled, a brand-new binary that reflects
    the changes is produced. This binary might be very similar to the previous one,
    or the binaries might be nothing alike; the difference between the two versions
    has a direct correlation to the complexity of the high-level changes. Small changes,
    like modified strings or updated constants, can leave binaries nearly identical
    and often have no effect on the addresses of code or data. But more complex changes—like
    added features, a new user interface, refactored internals, or new in-game content—often
    cause shifts in the location of crucial memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**AUTOMATICALLY FIND CURRENTHEALTH AND MAXHEALTH**'
  prefs: []
  type: TYPE_NORMAL
- en: In “[Searching for Assembly Patterns](ch01.xhtml#ch00lev1sec28)” on [page 19](ch01.xhtml#page_19)
    and “[Searching for Strings](ch01.xhtml#ch00lev1sec29)” on [page 21](ch01.xhtml#page_21),
    I showed a few Cheat Engine Lua scripts and explained how they worked. Using the
    `findString()` function in these examples, you can make Cheat Engine automatically
    locate the address of the format string that we just found manually in OllyDbg.
    Next, you can write a small function to scan for this address following byte 0x68
    (the byte for the `PUSH` command, as you can see beside it at 0x401030 in [Figure
    5-3](ch05.xhtml#ch5fig3)) to locate the address of the code that pushes it to
    the stack. Then, you can read 4 bytes from `pushAddress - 5` and `pushAddress
    - 12` to locate `currentHealth` and `maxHealth`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: This may not seem useful since we’ve already found the addresses, but if this
    were a real game, these addresses would change when an update is released. Using
    this knowledge to automate finding them can be very helpful. If you’re up to the
    challenge, give it a whirl!
  prefs: []
  type: TYPE_NORMAL
- en: Due to constant bug fixes, content improvements, and feature additions, online
    games are among the most rapidly evolving types of software. Some games release
    updates as often as once a week, and game hackers often spend a majority of their
    time reverse engineering the new binaries in order to accordingly update their
    bots.
  prefs: []
  type: TYPE_NORMAL
- en: If you create advanced bots, they will become increasingly supported by a foundation
    of memory addresses. When an update comes, determining the new addresses for a
    large number of values and functions is the most time-consuming inevitability
    you will face. Relying on the “[Tips for Winning the Update Race](ch05.xhtml#ch05sb01)”
    can be very beneficial, but the tips won’t help you locate the updated addresses.
    You can automatically locate some addresses using Cheat Engine scripts, but that
    won’t always work either. Sometimes you’ll have to do the dirty work by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to reinvent the wheel and find these addresses the same way you
    did initially, you’ll be wasting your time. You actually have a big advantage,
    though: the old binary and the addresses themselves. Using these two things, it
    is possible to find every single address you need to update in a fraction of the
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows two different disassemblies: a new game
    binary on the left and the previous version on the right. I have taken this image
    from an actual game (which will remain nameless) in order to give you a realistic
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Side-by-side disassemblies of two versions of one game*'
  prefs: []
  type: TYPE_NORMAL
- en: My bot modified the code at 0x047B542 (right), and I needed to find the corresponding
    code in the new version, which I discovered at 0x047B672 (left). This function
    call invokes a packet-parsing function when a packet has been received. In order
    to find this address originally (and by “originally,” I mean about 100 updates
    previous), I figured out how the game’s network protocol worked, set breakpoints
    on many network-related API calls, stepped through execution, and inspected data
    on the stack until I found something that looked similar to what I expected given
    my knowledge of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIPS FOR WINNING THE UPDATE RACE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In saturated markets, being the first bot developer to release a stable update
    is critical to success. The race starts the second the game updates, and hackers
    determined to be the fastest will spend hundreds of hours preparing. These are
    the most common ways to stay on top:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create update alarms** By writing software that alerts you as soon as the
    game patches, you can begin working on your updates as soon as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automate bot installs** Games often schedule expected updates at times when
    the fewest players are online. Botters hate waking up and downloading new software
    before they bot, but they love waking up to find it silently installed while the
    game is patching.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use fewer addresses** The less there is to update, the better. Consolidating
    related data into structures and eliminating unnecessary memory address usage
    can save a bunch of time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Have great test cases** Data changes, and hackers make mistakes. Having ways
    to quickly test every feature can be the difference between a stable bot and one
    that randomly crashes, gets users killed, or even leads to their characters being
    banned from the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking updates with these practices will give you a sizable head start, but
    they might not always be enough to lead you to victory. Above all else, strive
    to understand reverse engineering as much as possible and use that understanding
    to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: I could have followed the same steps for each of the 100+ updates since then,
    but that would have been unnecessary. The code stayed relatively the same throughout
    the years, which let me use patterns from the old code to find that function call’s
    address in the new code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider this chunk of assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Does it look familiar? Compare it to [Figure 5-4](ch05.xhtml#ch5fig4), and you’ll
    see that this exact code exists right above the highlighted function call in both
    versions of the game. Regardless of what it does, the combination of operations
    looks pretty distinctive; because of the number of different offsets the code
    is using relative to EBP, it’s unlikely that an identical chunk of code exists
    in any other part of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Every time I have to update this address, I open the old binary in OllyDbg,
    highlight this chunk of operations, right-click, and select Asm2Clipboard ▸ Copy
    fixed asm to clipboard. Then, I open the new binary in OllyDbg, navigate to the
    CPU Window, press CTRL-S, paste the assembly code, and hit Find. In 9.5 cases
    out of 10, this places me directly above the function call I need to find in the
    new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an update comes, you can use the same method to find nearly all of your
    known addresses. It should work for every address you can find easily in assembly
    code. There are a few caveats, though:'
  prefs: []
  type: TYPE_NORMAL
- en: • OllyDbg limits search to eight operations, so you must find code markers of
    that size or smaller.
  prefs: []
  type: TYPE_NORMAL
- en: • The operations you use cannot contain any other addresses, as those addresses
    have likely changed.
  prefs: []
  type: TYPE_NORMAL
- en: • If parts of the game have changed that use the address you’re looking for,
    the code might be different.
  prefs: []
  type: TYPE_NORMAL
- en: • If the game changes compilers or switches optimization settings, almost all
    code will be entirely different.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in “Automatically Find `currentHealth` and `maxHealth`” on [page
    102](ch05.xhtml#page_102), you can benefit from writing scripts that carry out
    these tasks for you. Serious game hackers work very hard to automatically locate
    as many addresses as possible, and some of the best bots are engineered to automatically
    detect their addresses at runtime, every time. It can be a lot of work initially,
    but the investment can definitely pay off.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying Complex Structures in Game Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.xhtml#ch04) described how a game might store data in static
    structures. This knowledge will suffice when you’re trying to find simple data,
    but it falls short for data that is stored through dynamic structures. This is
    because dynamic structures might be scattered across different memory locations,
    follow long pointer chains, or require complex algorithms to actually extract
    the data from them.'
  prefs: []
  type: TYPE_NORMAL
- en: This section explores common dynamic structures you’ll find in video game code,
    and how to read data from them once they’re found. To begin, I’ll talk about the
    underlying composition of each dynamic structure. Next, I’ll outline the algorithms
    needed to read the data from these structures. (For simplicity, each algorithm
    discussion assumes you have a pointer to an instance of the structure as well
    as some way to read from memory.) Lastly, I’ll cover tips and tricks that can
    help you determine when a value you’re searching for in memory is actually encapsulated
    in one of these structures, so you’ll know when to apply this knowledge. I’ll
    focus on C++, as its object-oriented nature and heavily used standard library
    are typically responsible for such structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of these structures might differ slightly from machine to machine based
    on compilers, optimization settings, or standard library implementations, but
    the basic concepts will remain the same. Also, in the interest of brevity, I will
    be omitting irrelevant parts of these structures, such as custom allocators or
    comparison functions. Working example code can be found at* [https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)
    *in the resource files for [Chapter 5](ch05.xhtml#ch05).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The std::string Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instances of `std::string` are among the most common culprits of dynamic storage.
    This class from the C++ Standard Template Library (STL) abstracts string operations
    away from the developer while preserving efficiency, making it widely used in
    all types of software. A video game might use `std::string` structure for any
    string data, such as creature names.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining the Structure of a std::string**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When you strip away the member functions and other nondata components of the
    `std::string` class, this is the structure that remains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class reserves 16 characters that are presumably used to store the string
    in place. It also, however, declares that the first 4 bytes can be a pointer to
    a character. This might seem odd, but it’s a result of optimization. At some point,
    the developers of this class decided that 15 characters (plus a null terminator)
    was a suitable length for many strings, and they chose to save on memory allocations
    and de-allocations by reserving 16 bytes of memory in advance. To accommodate
    longer strings, they allowed the first 4 bytes of this reserved memory to be used
    as a pointer to the characters of these longer strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the code were compiled to 64 bits, then it would actually be the first
    8 (not 4) bytes that point to a character. Throughout this example, however, you
    can assume 32-bit addresses and that* `int` *is the size of an address.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing string data this way takes some overhead. The function to locate
    the right buffer looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The fact that a `std::string` can be either a complete string or a pointer to
    a longer string makes this particular structure quite tricky from a game-hacking
    perspective. Some games may use `std::string` to store strings that only rarely
    exceed 15 characters. When this is the case, you might implement bots that rely
    on these strings, never knowing that the underlying structure is in fact more
    complicated than a simple string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlooking a std::string Can Ruin Your Fun**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not knowing the true nature of the structure containing the data you need can
    lead you to write a bot that works only some of the time and fails when it counts.
    Imagine, for example, that you’re trying to figure out how a game stores creature
    data. In your hypothetical search, you find that all the creatures in the game
    are stored in an array of structures that look something like [Listing 5-3](ch05.xhtml#ch5exe3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: How you might interpret creature data found in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: After scanning the creature data in memory, say you notice that the first 4
    bytes of each structure are unique for each creature, so you call those bytes
    the `uniqueID` and assume they form a single `int` property. Looking further in
    the memory, you find that the creature’s `name` is stored right after `uniqueID`,
    and after some deduction, you figure out the name is 16 bytes long. The next value
    you see in memory turns out to be the `nameLength`; it’s a bit strange that a
    null-terminated string has an associated length, but you ignore that oddity and
    continue analyzing the data in memory. After further analysis, you determine what
    the remaining values are for, define the structure shown in [Listing 5-3](ch05.xhtml#ch5exe3),
    and write a bot that automatically attacks creatures with certain names.
  prefs: []
  type: TYPE_NORMAL
- en: After weeks of testing your bot while hunting creatures with names like *Dragon*,
    *Cyclops*, *Giant*, and *Hound*, you decide it’s time to give your bot to your
    friends. For the inaugural use, you gather everyone together to kill a boss named
    *Super Bossman Supreme*. The entire team sets the bot to attack the boss first
    and target lesser creatures like a *Demon* or *Grim Reaper* when the boss goes
    out of range.
  prefs: []
  type: TYPE_NORMAL
- en: Once your team arrives at the boss’s dungeon . . . you’re all slowly obliterated.
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong in this scenario? Your game must be storing creature names with
    `std::string`, not just a simple character array. The `name` and `nameLength`
    fields in `creatureInfo` are, in fact, part of a `std::string` field, and the
    `name` character array is a union of `dataA` and `dataP` members. *Super Bossman
    Supreme* is longer than 15 characters, and because the bot was not aware of the
    `std::string` implementation, it didn’t recognize the boss. Instead, it constantly
    retargeted summoned *Demon* creatures, effectively keeping you from targeting
    the boss while he slowly drained your health and supplies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Whether Data Is Stored in a std::string**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Without knowing how the `std::string` class is structured, you’d have trouble
    tracking down bugs like the hypothetical one I just described. But pair what you’ve
    learned here with experience, and you can avoid these kinds of bugs entirely.
    When you find a string like `name` in memory, don’t just assume it’s stored in
    a simple array. To figure out whether a string is in fact a `std::string`, ask
    yourself these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: • Why is the string length present for a null-terminated string? If you can’t
    think of a good reason, then you may have a `std::string` on your hands.
  prefs: []
  type: TYPE_NORMAL
- en: • Do some creatures (or other game elements, depending on what you’re looking
    for) have names longer than 16 letters, but you find room for only 16 characters
    in memory? If so, the data is almost definitely stored in a `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: • Is the name stored in place, requiring the developer to use `strcpy()` to
    modify it? It’s probably a `std::string`, because working with raw C strings in
    this way is considered bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that there is also a class called `std::wstring` that
    is used to store wide strings. The implementation is very similar, but `wchar_t`
    is used in place of every `char`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The std::vector Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Games must keep track of many dynamic arrays of data, but managing dynamically
    sized arrays can be very tricky. For speed and flexibility, game developers often
    store such data using a templated STL class called `std::vector` instead of a
    simple array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining the Structure of a std::vector**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A declaration of this class looks something like [Listing 5-4](ch05.xhtml#ch5exe4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: An abstracted `std::vector` object*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This template adds an extra layer of abstraction, so I’ll continue this description
    using a `std::vector` declared with the `DWORD` type. Here’s how a game might
    declare that vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s dissect what a `std::vector` of `DWORD` objects would look like in
    memory. If you had the address of `_vec` and shared the same memory space, you
    could re-create the underlying structure of the class and access `_vec` as shown
    in [Listing 5-5](ch05.xhtml#ch5exe5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: A `DWORD std::vector` object*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat the member `begin` like a raw array, as it points to the first
    element in the `std::vector` object. There is no array length member, though,
    so you must calculate the vector’s length based on `begin` and `end`, which is
    an empty object following the final object in the array. The length calculation
    code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function simply subtracts the address stored in `begin` from the address
    stored in `end` to find the number of bytes between them. Then, to calculate the
    number of objects, it divides the number of bytes by the number of bytes per object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `begin` and this `length()` function, you can safely access elements
    in `_vec`. That code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Given an index, this code will fetch an item from the vector. But if the index
    is greater than the vector’s length, a `std::out_of_range` exception will be thrown.
    Adding values to a `std::vector` would be very expensive if the class couldn’t
    reserve or reuse memory, though. To remedy this, the class implements a function
    called `reserve()` that tells the vector how many objects to leave room for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The absolute size of a `std::vector` (its *capacity*) is determined through
    an additional pointer, which is called `tail` in the vector class we’ve re-created.
    The calculation for the capacity resembles the length calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the capacity of a `std::vector`, instead of subtracting the `begin`
    address from the `end` address, as you would to calculate length, this function
    subtracts the `begin` address from `tail`. Additionally, you can use this calculation
    a third time to determine the number of free elements in the vector by using `tail`
    and `end` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Given proper memory reading and writing functions, you can use the declaration
    in [Listing 5-4](ch05.xhtml#ch5exe4) and the calculations that follow to access
    and manipulate vectors in the memory of a game. [Chapter 6](ch06.xhtml#ch06) discusses
    reading memory in detail, but for now, let’s look at ways you can determine whether
    data you’re interested in is stored in a `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Whether Data Is Stored in a std::vector**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you’ve found an array of data in a game’s memory, there are a few steps
    you can follow to determine whether it is stored in a `std::vector`. First, you
    can be sure that the array is not stored in a `std::vector` if it has a static
    address, because `std::vector` objects require pointer paths to access the underlying
    array. If the array *does* require a pointer path, having a final offset of `0`
    would indicate a `std::vector`. To confirm, you can change the final offset to
    `4` and check if it points to the final object in the array instead of the first
    one. If so, you’re almost definitely looking at a vector, as you’ve just confirmed
    the `begin` and `end` pointers.
  prefs: []
  type: TYPE_NORMAL
- en: '***The std::list Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to `std::vector`, `std::list` is a class that you can use to store a
    collection of items in a linked list. The main differences are that `std::list`
    doesn’t require a contiguous storage space for elements, cannot directly access
    elements by their index, and can grow in size without affecting any previous elements.
    Due to the overhead required to access items, it is rare to see this class used
    in games, but it shows up in some special cases, which I’ll discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examining the Structure of a std::list**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `std::list` class looks something like [Listing 5-6](ch05.xhtml#ch5exe6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: An abstracted `std::list` object*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two classes here: `listItem` and `list`. To avoid extra abstraction
    while explaining how `std::list` works, I’ll describe this object as it would
    look when the type is `DWORD`. Here’s how a game would declare a `std::list` of
    the `DWORD` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Given that declaration, the `std::list` is structured like the code in [Listing
    5-7](ch05.xhtml#ch5exe7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-7: A `DWORD std::list` object*'
  prefs: []
  type: TYPE_NORMAL
- en: The class `list` represents the list header, while `listItem` represents a value
    stored in the list. Instead of being stored contiguously, the items in the list
    are stored independently. Each item contains a pointer to the item that comes
    after it (`next`) and the one that comes before it (`prev`), and these pointers
    are used to locate items in the list. The `root` item acts as a marker for the
    end of the list; the `next` pointer of the last item points to `root`, as does
    the `prev` pointer of the first item. The `root` item’s `next` and `prev` pointers
    also point to the first item and the last item, respectively. [Figure 5-5](ch05.xhtml#ch5fig5)
    shows what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this structure, you can use the following code to iterate over a `std::list`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: A `std::list` flowchart*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first loop starts at the first item (`root->next`) and iterates forward
    (`it = it->next`) until it hits the end marker (`root`). The second loop starts
    at the last item (`root->pres`) and iterates backward (`it = it->prev`) until
    it hits the end marker (`root`). This iteration relies on `next` and `prev` because
    unlike objects in an array, objects in a `std::list` are not contiguous. Since
    the memory of each object in a `std::list` is not contiguous, there’s no quick-and-dirty
    way to calculate the size. Instead, the class just defines a size member. Additionally,
    the concept of reserving space for new objects is irrelevant for lists, so there’s
    no variable or calculation to determine a list’s capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Whether Game Data Is Stored in a std::list**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Identifying objects stored in the `std::list` class can be tricky, but there
    are a few hints you can watch for. First, items in a `std::list` cannot have static
    addresses, so if the data you seek has a static address, then you’re in the clear.
    Items that are obviously part of a collection may, however, be part of a `std::list`
    if they’re not contiguous in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Also consider that objects in a `std::list` can have infinitely long pointer
    chains (think `it->prev->next->prev->next->prev` . . .), and pointer scanning
    for them in Cheat Engine will show many more results when No Looping Pointers
    is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a script to detect when a value is stored in a linked list.
    [Listing 5-8](ch05.xhtml#ch5exe8) shows a Cheat Engine script that does just this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-8: Determining whether data is in a `std::list` using a Cheat Engine
    Lua script*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s quite a bit of code here, but what it’s doing is actually pretty simple.
    The `isValueInLinkedList()` function takes an address of some value and then looks
    backward for up to 40 bytes (10 integer objects, in case the value is in some
    larger structure), starting 8 bytes above the address (two pointers must be present,
    and they are 4 bytes each). Because of memory alignment, this loop iterates in
    steps of 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On each iteration, the address is passed to the `_verifyLinkedList()` function,
    which is where the magic happens. If we look at it in terms of linked list structure
    as defined in this chapter, the function simply does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That is, the function basically assumes the memory address it’s given points
    to a linked list, and it makes sure the supposed node has valid next and previous
    nodes. If the nodes are valid, the assumption was correct and the address is that
    of a linked list node. If the nodes don’t exist or don’t point to the right locations,
    the assumption was wrong and the address is not part of a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this script won’t give you the address of the list’s root
    node but simply the address of the node containing the value you’ve given it.
    To properly traverse a linked list, you’ll need to scan for a valid pointer path
    to the root node, so you’ll need its address.
  prefs: []
  type: TYPE_NORMAL
- en: Finding that address can require some searching of memory dumps, a lot of trial
    and error, and a ton of head scratching, but it’s definitely possible. The best
    way to start is to follow the chain of `prev` and `next` nodes until you find
    a node with data that is either blank, nonsensical, or filled with the value `0xBAADF00D`
    (some, but not all, standard library implementations use this value to mark root
    nodes).
  prefs: []
  type: TYPE_NORMAL
- en: This investigation can also be made easier if you know exactly how many nodes
    are in the list. Even without the list header, you can determine the amount of
    nodes by continuously following the next pointer until you end up back at your
    starting node, as in [Listing 5-9](ch05.xhtml#ch5exe9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-9: Determining the size of an arbitrary `std::list` using a Cheat
    Engine Lua script*'
  prefs: []
  type: TYPE_NORMAL
- en: First, this function creates a counter to store the number of nodes and a variable
    to store the next node’s address. The `while` loop then iterates over the nodes
    until it ends up back at the initial node. Finally, it returns the counter variable,
    which was incremented on every iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIND THE ROOT NODE WITH A SCRIPT**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s actually possible to write a script that can find the root node, but I’ll
    leave it as an optional exercise for you. How does it work? Well, the root node
    must be in the chain of nodes, the list header points to the root, and the size
    of the list will immediately follow the root in memory. Given this information,
    you can write a script that will search for any memory containing a pointer to
    one of the list’s nodes, followed by the size of the list. More often than not,
    this piece of memory is the list header, and the node it points to is the root
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '***The std::map Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like a `std::list`, a `std::map` uses links between elements to form its structure.
    Unique to `std::map`, however, is the fact that each element stores two pieces
    of data (a key and a value), and sorting the elements is an inherent property
    of the underlying data structure: a red-black tree. The following code shows the
    structures that compose a `std::map`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A red-black tree is a self-balancing binary search tree, so a `std::map` is,
    too. In the STL’s `std::map` implementation, each element (or node) in the tree
    has three pointers: `left`, `parent`, and `right`. In addition to the pointers,
    each node also has a `key` and a `value`. The nodes are arranged in the tree based
    on a comparison between their keys. The `left` pointer of a node points to a node
    with a smaller key, and the `right` pointer points to a node with a larger key.
    The `parent` points to the upper node. The first node in the tree is called the
    `rootNode`, and nodes that lack children point to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visualizing a std::map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 5-6](ch05.xhtml#ch5fig6) shows a `std::map` that has the keys 1, 6,
    8, 11, 13, 15, 17, 22, 25, and 27.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f05-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: A red-black tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The top node (holding the value `13`) is pointed to by the `parent` of `rootNode`.
    Everything to the left of it has a smaller `key`, and everything to the right
    has a greater `key`. This is true for any node in the tree, and this truth enables
    efficient key-based search. While not represented in the image, the left pointer
    of the root node will point to the leftmost node (`1`), and the right pointer
    will point to the rightmost node (`27`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing Data in a std::map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once again, I’ll use a static `std::map` definition when discussing how to
    extract data from the structure. Since the template takes two types, I’ll also
    use some pseudotypes to keep things obvious. Here’s the declaration for the `std::map`
    object I’ll reference for the rest of the section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this declaration, the structure of `myMap` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some important algorithms that you might need to access the data
    in a `std::map` structure in a game. First, blindly iterating over every item
    in the map can be useful if you just want to see all of the data. To do this sequentially,
    you could write an iteration function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A function to iterate over an entire map would first read the current node and
    check whether it’s the `rootNode`. If not, it would recurse left, print the node,
    and recurse right.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this function, you’d have to pass a pointer to the `rootNode` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of a `std::map`, however, is to store keyed data in a quickly searchable
    way. When you need to locate a node given a specific `key`, mimicking the internal
    search algorithm is preferable to scanning the entire tree. The code for searching
    a `std::map` looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Starting at the top of the tree, you simply recurse left if the current key
    is greater than the search key and recurse right if it is smaller. If the keys
    are equal, you return the current node. If you reach the bottom of the tree and
    don’t find the key, you return `NULL` because the key isn’t stored in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way you might use this `findItem()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As long as `findItem()` doesn’t return `NULL`, this code should print a node
    from `_map`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Whether Game Data Is Stored in a std::map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Typically, I don’t even consider whether data could be in a `std::map` until
    I know the collection is not an array, a `std::vector`, or a `std::list`. If you
    rule out all three options, then as with a `std::list`, you can look at the three
    integer values before the value and check if they point to memory that could possibly
    be other map nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, this can be done with a Lua script in Cheat Engine. The script is
    similar to the one I showed for lists, looping backward over memory to see if
    a valid node structure is found before the value. Unlike the list code, though,
    the function that verifies a node is much trickier. Take a look at the code in
    [Listing 5-10](ch05.xhtml#ch5exe10), and then I’ll dissect it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-10: Determining whether data is in a `std::map` using a Cheat Engine
    Lua script*'
  prefs: []
  type: TYPE_NORMAL
- en: Given `address`, this function checks if `address` is in a map structure. It
    first checks if there’s a valid parent node and, if so, checks whether that parent
    node points to `address` on either side ➊. But this check isn’t enough. If the
    check passes, the function will also climb up the line of `parent` nodes until
    it reaches a node that is the parent of its own parent ➋, trying 200 times before
    calling it quits. If the climb succeeds in finding a node that is its own grandparent,
    then `address` definitely points to a map node. This works because, as I outlined
    in “[Visualizing a `std::map`](ch05.xhtml#ch00lev1sec116)” on [page 114](ch05.xhtml#page_114),
    at the top of every map is a root node whose parent points to the first node in
    the tree, and that node’s parent points back to the root node.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I bet you didn’t expect to run into the grandfather paradox from time travel
    when reading a game-hacking book!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this function and a slightly modified backtracking loop from [Listing
    5-8](ch05.xhtml#ch5exe8), you can automatically detect when a value is inside
    a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Aside from function names, the only change in this code from [Listing 5-8](ch05.xhtml#ch5exe8)
    is that it starts looping 12 bytes before the value instead of 8, because a map
    has three pointers instead of the two in a list. One good consequence of a map’s
    structure is that it’s easy to obtain the root node. When the `_verifyMap` function
    returns true, the `parentsParent` variable will contain the address of the root
    node. With some simple modifications, you could return this to the main call and
    have everything you need to read the data from a `std::map` in one place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memory forensics is the most time-consuming part of hacking games, and its obstacles
    can appear in all shapes and sizes. Using purpose, patterns, and a deep understanding
    of complex data structures, however, you can quickly overcome these obstacles.
    If you’re still a bit confused about what’s going on, make sure to download and
    play with the example code provided, as it contains proofs of concept for all
    of the algorithms covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.xhtml#ch06), we’ll start diving in to the code you need
    to read from and write to a game’s memory from your own programs so you can take
    the first step in putting to work all of this information about memory structures,
    addresses, and data.
  prefs: []
  type: TYPE_NORMAL
