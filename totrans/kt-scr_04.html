<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<span aria-label="87" epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch3">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">3</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">VISUALIZING WITH JAVAFX</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">Data visualization is the art of presenting complex data in a visually accessible format, allowing for quick and effective understanding. Through charts, graphs, maps, and other graphical representations, data visualization not only simplifies data interpretation but also uncovers patterns, trends, and insights that might otherwise be overlooked.</p>
<p class="tx">By transforming raw data into meaningful and actionable knowledge, visualization plays a pivotal role in decision-making across various domains, such as business analytics and scientific research. Another facet of data visualization involves the creation and presentation of intricate objects and patterns on a screen, often incorporating dynamic or moving elements within simulations or optimization processes.</p>
<p class="tx">In this chapter, we’ll explore creating data visualization and other output with Kotlin code. We’ll focus on the JavaFX library, allowing us to build standard charts, free-form drawings, and even animations. The <span aria-label="88" epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>programming patterns we cover in this chapter will pay dividends in later chapters when we work on projects with more elaborate visual components.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h"><span id="sec1"/><span id="h1-27"/><span class="sans_futura_std_bold_b_">Data Visualization Tools for Kotlin</span></h3>
<p class="tni">Several data visualization tools, both commercial and free, are available to run with Kotlin on the JVM. These tools make it possible to create interactive plots and charts and, in some cases, free-form drawings and fully featured user interfaces (UIs). They offer a variety of features and customization options to suit your needs. Here’s an overview of some of the visualization tools available:</p>
<p class="listhead"><b class="calibre6">Lets-Plot</b></p>
<p class="listplainfirst">A multiplatform plotting library for Kotlin that can be used to create interactive plots and charts. It’s primarily used to access graphics features within a Jupyter Notebook, a web application that facilitates the creation and sharing of documents containing live code, narrative text, and visualizations. You can access Lets-Plot’s graphics library through application programming interface (API) calls with predefined syntax. Lets-Plot doesn’t have a free-form drawing or sketching tool comparable to Tkinter in Python or the <span class="sans_thesansmonocd_w5regular_">Canvas</span> class in JavaFX.</p>
<p class="listhead"><b class="calibre6">Plotly</b></p>
<p class="listplainfirst">Another tool for creating interactive plots and charts for Kotlin applications. Plotly works on various platforms, including the JVM, JavaScript, and Python. Plotly is user friendly, has a simple API, and offers many customization options. Like Lets-Plot, it lacks a free-form drawing tool.</p>
<p class="listhead"><b class="calibre6">Jetpack Compose</b></p>
<p class="listplainfirst">A modern UI toolkit for building native Android, desktop, and web applications using a single codebase. While Jetpack Compose doesn’t have built-in support for charting, third-party libraries are available for creating interactive plots and charts. Jetpack Compose provides a canvas API that can be used to draw custom graphics and shapes.</p>
<p class="listhead"><b class="calibre6">JavaFX</b></p>
<p class="listplainfirst">An open source framework that lets you use Java to create applications for desktop, mobile, and embedded systems. It results from a collaborative effort by many individuals and companies that aim to provide a modern, efficient, and fully featured toolkit for developing rich client applications. You can use JavaFX to create user interfaces and interactive visualizations, as well as various charts such as line charts, bar charts, pie charts, and scatterplots. JavaFX works well with Kotlin because of its compatibility with Java.</p>
<p class="tx">In this book, we’ll use JavaFX as the graphics library of choice. This is because it’s a mature and feature-rich library that’s well documented <span aria-label="89" epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>and can seamlessly integrate with both Java and Kotlin applications. Most important, it has built-in features for charting and free-form drawing, including pixel-level manipulation of the display screen. These features will be useful in some projects we’ll work on later in the book.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h"><span id="sec2"/><span id="h1-28"/><span class="sans_futura_std_bold_b_">An Overview of JavaFX</span></h3>
<p class="tni">JavaFX was first introduced by Sun Microsystems in 2007 as a modern replacement for the aging Java Swing framework. It marked a significant step forward in Java’s capabilities for creating GUIs and multimedia-rich applications. Initially, JavaFX was shipped as part of the Java Development Kit (JDK). However, Oracle, the company that acquired JavaFX from Sun Microsystems, announced in 2018 that JavaFX would be open sourced and moved to the OpenFX project. The same year, JavaFX 11 was released as a stand-alone framework, decoupled from the JDK.</p>
<p class="tx">JavaFX has evolved over the years, thanks to numerous updates and improvements from its developers. It continues to thrive as an open source project under the stewardship of the OpenJFX community and is included as a standard library in many Java distributions.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1"><span id="sec3"/><span id="h2-41"/><span class="sans_futura_std_bold_condensed_oblique_">Key Functionalities</span></h4>
<p class="tni">JavaFX is a comprehensive toolkit for building cross-platform applications. While this chapter focuses on its charting and drawing features, JavaFX offers many other features that you can use in your projects. Here’s a quick overview of its key functionalities:</p>
<p class="listhead"><b class="calibre6">UI development</b></p>
<p class="listplainfirst">JavaFX enables the developer to simplify and enhance the development of visually rich and interactive user interfaces for desktop, web, and mobile applications. It provides a wide variety of UI controls, layouts, and styles, allowing the creation of visually appealing and highly customizable interfaces.</p>
<p class="listhead"><b class="calibre6">Cross-platform compatibility</b></p>
<p class="listplainfirst">JavaFX is designed to create applications that can run on various platforms, including Windows, macOS, Linux, and mobile devices, without major modifications. This cross-platform compatibility reduces development effort and allows for broader application distribution.</p>
<p class="listhead"><b class="calibre6">Charts and data visualization</b></p>
<p class="listplainfirst">JavaFX includes built-in support for creating various charts and graphs, making it a preferred choice for data visualization applications.</p>
<p class="listhead"><b class="calibre6">3D graphics</b></p>
<p class="listplainfirst">JavaFX provides versatile 3D graphics capabilities for developing mathematical and scientific applications that require 3D visualizations.</p>
<p class="listhead"><span aria-label="90" epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/><b class="calibre6">Rich media support</b></p>
<p class="listplainfirst">JavaFX is known for its robust multimedia support, making it suitable for applications that require video, audio, animations, and 2D or 3D graphics.</p>
<p class="listhead"><b class="calibre6">High performance</b></p>
<p class="listplainfirst">JavaFX provides hardware acceleration and optimizations for improved rendering performance, making it suitable for applications demanding smooth animations and responsive interfaces.</p>
<p class="listhead"><b class="calibre6">Integration with Java and Kotlin</b></p>
<p class="listplainfirst">JavaFX seamlessly integrates with the Java programming language, leveraging the robustness, security, and ecosystem of Java. Since Kotlin is fully interoperable with Java, JavaFX is a natural choice for developing desktop and web-based applications in Kotlin.</p>
<p class="tx">For more information about JavaFX features, see the project website at <span class="copyright_accent"><a href="https://openjfx.io" class="calibre2">https://openjfx.io</a></span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1"><span id="sec4"/><span id="h2-42"/><span class="sans_futura_std_bold_condensed_oblique_">Setup</span></h4>
<p class="tni">If you’ve followed the steps for installing IntelliJ IDEA and the Azul Zulu JDK as described in the <span>appendix</span>, you’re all set to start using JavaFX with Kotlin. You can access JavaFX features just as you’ve been accessing Kotlin features from the IDE. While the support for Kotlin is integrated within the IDE itself, the access to JavaFX is gained through the installed JDK.</p>
<p class="tx">If you haven’t followed the instructions in the <span>appendix</span>, I recommend using a JDK with JavaFX prepackaged so you can avoid the extra steps needed to link the library to your code. For example, Azul JDK FX and Liberica Full JDK are well-known distributions with integrated JavaFX support. Alternatively, you can download and install JavaFX separately from the OpenJFX website. There you’ll find detailed instructions on how to set up JavaFX for various operating systems, such as Windows, macOS, and Linux, including how to access JavaFX from your IDE.</p>
<p class="tx">Once both Kotlin and JavaFX are accessible from the IDE, you can focus on creating new JavaFX applications in Kotlin. The process is similar to creating regular Kotlin programs, except that you need to add some boilerplate JavaFX code, which I’ll explain in detail next.</p>
<p class="headaexercise" id="pre-3"><span class="sans_dogma_ot_bold_b_15-n">Project 3: Build “Hello, World!” in JavaFX</span></p>
<p class="tni">In this project, I’ll walk you through the process of building a simple “Hello, world!” application using JavaFX and Kotlin. This will serve as the foundation for constructing other applications that leverage JavaFX’s charting and visualization features. First, follow these steps to create a new JavaFX-enabled application from scratch:</p>
<p class="listnumber1"><span aria-label="91" epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/>  1.  Open IntelliJ IDEA and create a new Kotlin project by navigating to <b class="calibre6">File</b><span class="listnumber_menuarrow"></span><b class="calibre6">New</b><span class="listnumber_menuarrow"></span><b class="calibre6">Project</b>. You’ll be taken to the project setup window shown in <a href="chapter3.xhtml#fig3-1" class="calibre2">Figure 3-1</a>.</p>
<figure class="img"><img alt="" class="img1" height="928" id="fig3-1" src="../images/Figure3-1.jpg" width="1314"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-1: Configuration options for JavaFX-based Kotlin projects</span></p></figcaption>
</figure>
<p class="listnumber1">  2.  Name the project <span class="copyright_italic">HelloWorld</span> and note its location. Then select <b class="calibre6">Kotlin</b> as the language and <b class="calibre6">Maven</b> as the build system and choose a JDK that includes integrated support for JavaFX. (If you’ve followed the instructions in the <span>appendix</span>, that’ll be the latest long-term support version of Azul Zulu JDK FX.) For all JavaFX-based projects covered in this book, we’ll use these same settings (apart from the project name), as they eliminate the need for additional steps, such as manually linking a separate JavaFX library to the project.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_15-n">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre9">You may notice that the left-hand panel of IntelliJ IDEA has an option to autogenerate a new JavaFX project, complete with a default “Hello!” window. This preconfigured setup comes with objects and files that may not be necessary for each project, so I recommend creating a project from scratch and including only the required code and objects, as outlined here.</i></p>
<p class="listnumber1">  3.  Click <b class="calibre6">Create</b> to create a new project with the correct configuration.</p>
<p class="listnumber1">  4.  In the project panel on the left side of the IDE, expand the project tree by navigating to <b class="calibre6">HelloWorld</b><span class="listnumber_menuarrow"></span><b class="calibre6">src</b><span class="listnumber_menuarrow"></span><b class="calibre6">main</b><span class="listnumber_menuarrow"></span><b class="calibre6">kotlin</b>.</p>
<p class="listnumber1"><span aria-label="92" epub:type="pagebreak" id="pg_92" role="doc-pagebreak"/>  5.  Right-click the <span class="copyright_italic">kotlin</span> folder and choose <b class="calibre6">New</b><span class="listnumber_menuarrow"></span><b class="calibre6">Kotlin Class/File</b>. Then choose <b class="calibre6">File</b> and enter <b class="calibre6">HelloWorld</b> as the name of the Kotlin file. (For other projects, you can choose any other meaningful name.) Note that including the file extension, <span class="copyright_italic">.kt</span>, is optional. At this stage, the project screen should look like <a href="chapter3.xhtml#fig3-2" class="calibre2">Figure 3-2</a>.</p>
<figure class="img"><img alt="" class="img1" height="1111" id="fig3-2" src="../images/Figure3-2.jpg" width="1313"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-2: Creating the Kotlin file for a JavaFX application</span></p></figcaption>
</figure>
<p class="listnumber1">  6.  Once you’ve typed in the Kotlin filename, press <small class="calibre12">ENTER</small> to create the file, which also takes you to the code editor window.</p>
<p class="tx">With that, we’re ready to start coding our basic JavaFX application. For more complex projects, you may have to create additional classes or files. You can do so by using the same method outlined here.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1"><span id="sec5"/><span id="h2-43"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">The center of any JavaFX project is the <span class="sans_thesansmonocd_w5regular_">Application</span> class, an abstract class built into JavaFX that provides a framework for managing a graphical application. It features an abstract <span class="sans_thesansmonocd_w5regular_">start()</span> method that serves as the application’s entry point, much like the <span class="sans_thesansmonocd_w5regular_">main()</span> function is the point of entry for a console-based program. The project must feature a new class—what we’ll call <span class="sans_thesansmonocd_w5regular_">HelloWorld</span>, in this case—that extends the <span class="sans_thesansmonocd_w5regular_">Application</span> class and overrides the <span class="sans_thesansmonocd_w5regular_">start()</span> method. In the overridden method, you write the code for setting up and configuring the graphics window for data visualization and other aspects of your application. The project still needs a separate <span class="sans_thesansmonocd_w5regular_">main()</span> <span aria-label="93" epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/>function as well, but the sole purpose of that function is to call the built-in <span class="sans_thesansmonocd_w5regular_">launch()</span> method of the <span class="sans_thesansmonocd_w5regular_">Application</span> class, which in turn launches the JavaFX application and calls the <span class="sans_thesansmonocd_w5regular_">start()</span> method.</p>
<p class="tx">With that in mind, here’s the code to create a simple graphical application that displays a “Hello, world!” message to the user:</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.geometry.Pos
import javafx.stage.Stage
import javafx.scene.Scene
import javafx.scene.layout.VBox
import javafx.scene.text.Font
import javafx.scene.text.Text

class HelloWorld : Application() {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> override fun start(primaryStage: Stage) {
        primaryStage.title = "Primary Stage"
        val text = Text("Hello, world!")
        text.font = Font.font("Verdana", 20.0)

        val vbx = VBox(text)
        vbx.alignment = Pos.CENTER
        val scene = Scene(vbx, 300.0, 300.0)
        primaryStage.scene = scene
        primaryStage.show()
    }
}

fun main() {
  <span aria-label="annotation2" class="code_codeannotation">❷</span> Application.launch(HelloWorld::class.java)
}</code></pre>
<p class="tx">We first import several JavaFX classes, including <span class="sans_thesansmonocd_w5regular_">Application</span>, <span class="sans_thesansmonocd_w5regular_">Pos</span>, <span class="sans_thesansmonocd_w5regular_">Stage</span>, <span class="sans_thesansmonocd_w5regular_">Scene</span>, <span class="sans_thesansmonocd_w5regular_">VBox</span>, <span class="sans_thesansmonocd_w5regular_">Font</span>, and <span class="sans_thesansmonocd_w5regular_">Text</span>. These are required to create and manage the graphical elements for the “Hello, world!” application. Any JavaFX application will begin with a long import block like this, though the specifics will vary depending on the application’s functionality.</p>
<p class="tx">Next, we declare the <span class="sans_thesansmonocd_w5regular_">HelloWorld</span> class to inherit from the <span class="sans_thesansmonocd_w5regular_">Application</span> class, which, as mentioned, is standard practice in JavaFX applications. Inside the class, we override the <span class="sans_thesansmonocd_w5regular_">start()</span> method <span aria-label="annotation1" class="codeannotation">❶</span> to define the entry point for the application that will be executed when the program is launched. The <span class="sans_thesansmonocd_w5regular_">start()</span> method takes an argument called <span class="sans_thesansmonocd_w5regular_">primaryStage</span>, an object of the JavaFX <span class="sans_thesansmonocd_w5regular_">Stage</span> class, representing the application’s primary viewing window. Within the method, we do the following:</p>
<ul class="ul">
<li class="listbullet">Use <span class="sans_thesansmonocd_w5regular_">primaryStage.title</span> to set the title of the application window to <span class="sans_thesansmonocd_w5regular_">"Primary Stage"</span>.</li>
<li class="listbullet">Create a <span class="sans_thesansmonocd_w5regular_">Text</span> object named <span class="sans_thesansmonocd_w5regular_">text</span> containing the message <span class="sans_thesansmonocd_w5regular_">"Hello, world!"</span> with a custom font of Verdana size 20.0.</li>
<li class="listbullet">Create a <span class="sans_thesansmonocd_w5regular_">VBox</span> object named <span class="sans_thesansmonocd_w5regular_">vbx</span> and add the <span class="sans_thesansmonocd_w5regular_">text</span> object to it. In JavaFX, a <span class="sans_thesansmonocd_w5regular_">VBox</span> is a layout container that arranges its contents (in this case, <span class="sans_thesansmonocd_w5regular_">text</span>) <span aria-label="94" epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/>in a vertical column. We set its <span class="sans_thesansmonocd_w5regular_">alignment</span> property to <span class="sans_thesansmonocd_w5regular_">Pos.CENTER</span> to ensure the text will be centered within the window.</li>
<li class="listbullet">Create a <span class="sans_thesansmonocd_w5regular_">Scene</span> object named <span class="sans_thesansmonocd_w5regular_">scene</span> with the <span class="sans_thesansmonocd_w5regular_">vbx</span> attached to it and a size of 300.0×300.0 pixels. (The dimensions have to be given in the floating-point format as they’re of type <span class="sans_thesansmonocd_w5regular_">Double</span>.)</li>
<li class="listbullet">Assign the <span class="sans_thesansmonocd_w5regular_">Scene</span> object to the <span class="sans_thesansmonocd_w5regular_">primaryStage</span> parameter’s <span class="sans_thesansmonocd_w5regular_">scene</span> property, which adds the scene to the viewing window.</li>
<li class="listbullet">Call the <span class="sans_thesansmonocd_w5regular_">show()</span> method of the <span class="sans_thesansmonocd_w5regular_">primaryStage</span> object to display the JavaFX application window.</li>
</ul>
<p class="tni">We’ll discuss the significance of these JavaFX constructs in more detail shortly.</p>
<p class="tx">The final segment of the program is the <span class="sans_thesansmonocd_w5regular_">main()</span> function, which consists of just a single line of code <span aria-label="annotation2" class="codeannotation">❷</span>. As mentioned earlier, its sole purpose is to call the <span class="sans_thesansmonocd_w5regular_">launch()</span> method of the <span class="sans_thesansmonocd_w5regular_">Application</span> class, which activates the <span class="sans_thesansmonocd_w5regular_">start()</span> method of the <span class="sans_thesansmonocd_w5regular_">HelloWorld</span> application. The parameter inside the <span class="sans_thesansmonocd_w5regular_">launch()</span> method, <span class="sans_thesansmonocd_w5regular_">HelloWorld::class.java</span>, specifies the Java class corresponding to the <span class="sans_thesansmonocd_w5regular_">HelloWorld</span> Kotlin class that serves as the entry point for the JavaFX application.</p>
<aside aria-label="box-16" class="box">
<p class="boxtitle" id="box-16"><span class="sans_futura_std_bold_b_">HOW TO HIDE ::CLASS.JAVA</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Some Kotlin developers may prefer not to use constructs such as</span> <span class="sans_thesansmonocd_w5regular_">::class.java</span> <span class="sans_futura_std_book_">inside the</span> <span class="sans_thesansmonocd_w5regular_">main()</span> <span class="sans_futura_std_book_">function. We can avoid doing that by creating an inline function in a second file inside the</span> <span class="sans_futura_std_book_oblique_">kotlin</span> <span class="sans_futura_std_book_">folder (where other Kotlin files are located). Let’s name this new file</span> <span class="sans_futura_std_book_oblique_">Inline.kt</span> <span class="sans_futura_std_book_">and add the following lines to this file:</span></p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application

inline fun &lt;reified T : Application&gt; runApplication() {
    Application.launch(T::class.java)
}</code></pre>
<p class="box1"><span class="sans_futura_std_book_">Here,</span> <span class="sans_thesansmonocd_w5regular_">&lt;reified T: Application&gt;</span> <span class="sans_futura_std_book_">introduces a type parameter</span> <span class="sans_thesansmonocd_w5regular_">T</span> <span class="sans_futura_std_book_">whose type is determined at runtime based on the actual argument passed to the function. Now we can call the inline function from the</span> <span class="sans_thesansmonocd_w5regular_">main()</span> <span class="sans_futura_std_book_">function as follows:</span></p>
<pre class="calibre10"><code class="calibre11">fun main() {
    runApplication&lt;HelloWorld&gt;()
}</code></pre>
<p class="boxlast"><span class="sans_futura_std_book_">You can use this trick if you think this will make the main body of the code look nicer!</span></p>
</aside>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="95" epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec6"/><span id="h2-44"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Try running the application in IntelliJ IDEA. The output window shown in <a href="chapter3.xhtml#fig3-3" class="calibre2">Figure 3-3</a> should pop up.</p>
<figure class="img"><img alt="" class="img2" height="945" id="fig3-3" src="../images/Figure3-3.jpg" width="901"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-3: The minimal “Hello, world!” application in Kotlin and JavaFX</span></p></figcaption>
</figure>
<p class="tx">Let’s highlight a few details in this output. First, the window has a title, “Primary Stage,” which is what the <span class="sans_thesansmonocd_w5regular_">title</span> property of <span class="sans_thesansmonocd_w5regular_">primaryStage</span> was set to. Second, the text “Hello, world!” is neatly centered inside the window. This was achieved by setting the alignment property of <span class="sans_thesansmonocd_w5regular_">vbx</span> to <span class="sans_thesansmonocd_w5regular_">Pos.CENTER</span> so that its contents would be aligned centrally within its boundaries. Third, the initial size of the window was set by specifying the width and height of the scene. However, you can change the window size by dragging any of its boundaries. Finally, the application continues to run in the background as long as the display window is open. Once you close the window, the application terminates normally.</p>
<p class="tx">This code will be the foundational template for all our JavaFX-based applications, requiring only minor modifications. For example, you’ll be replacing the <span class="sans_thesansmonocd_w5regular_">Text</span> object with a <span class="sans_thesansmonocd_w5regular_">LineChart</span> or a <span class="sans_thesansmonocd_w5regular_">Canvas</span> object to adapt the code for creating a graph or a free-form drawing, respectively. JavaFX is a feature-rich framework, and I highly recommend exploring the resources listed at the end of this chapter to gain a thorough understanding of its core components and their relationships. For now, I’ll provide a brief overview of key features that we’ll be using in our upcoming JavaFX-based projects.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<span aria-label="96" epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>
<h3 class="h"><span id="sec7"/><span id="h1-29"/><span class="sans_futura_std_bold_b_">The JavaFX Object Hierarchy</span></h3>
<p class="tni">JavaFX uses a hierarchy of objects to represent the structure of a GUI and the elements that make up a visual display. At the top of this hierarchy is the <span class="sans_thesansmonocd_w5regular_">Stage</span>, which serves as the primary window for an application. The <span class="sans_thesansmonocd_w5regular_">Stage</span> is a container for one or more <span class="sans_thesansmonocd_w5regular_">Scene</span> objects, and each <span class="sans_thesansmonocd_w5regular_">Scene</span> is a container for various graphical elements, including other layout containers, controls, and shapes. All these components are considered <i class="calibre9">nodes</i> in the JavaFX object hierarchy.</p>
<p class="tx">We’ve already worked with several of these objects in our “Hello, world!” application. Let’s now take a closer look at what they are and how they relate to each other. Understanding and manipulating JavaFX’s object hierarchy is fundamental to creating visually appealing and interactive applications.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1"><span id="sec8"/><span id="h2-45"/><span class="sans_futura_std_bold_condensed_oblique_">The Stage</span></h4>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">Stage</span> is the top-level container in a JavaFX application. It represents the application window, complete with its title bar, borders, and any native OS-level components. The <span class="sans_thesansmonocd_w5regular_">Stage</span> serves as the primary object for creating a graphical window. You create a <span class="sans_thesansmonocd_w5regular_">Stage</span> and set its properties, such as the window title and dimensions:</p>
<pre class="calibre10"><code class="calibre11">val myStage = Stage()
myStage.title  = "This is a secondary window"
myStage.width  = 800.0 // in pixels
myStage.height = 600.0 // in pixels</code></pre>
<p class="tx">In JavaFX applications, at least one <span class="sans_thesansmonocd_w5regular_">Stage</span> object is essential. This primary <span class="sans_thesansmonocd_w5regular_">Stage</span> is created when you override the <span class="sans_thesansmonocd_w5regular_">start()</span> method. However, in this example, we’re explicitly creating an additional <span class="sans_thesansmonocd_w5regular_">Stage</span> object, which will appear as a second graphical window within our application. We achieve this by invoking the <span class="sans_thesansmonocd_w5regular_">Stage()</span> constructor and assigning it to a new class member, <span class="sans_thesansmonocd_w5regular_">myStage</span>.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h1"><span id="sec9"/><span id="h2-46"/><span class="sans_futura_std_bold_condensed_oblique_">Scenes</span></h4>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">Scene</span> represents a single, self-contained GUI component within the <span class="sans_thesansmonocd_w5regular_">Stage</span>. It acts as a container for all the visible elements in a specific part of an application, such as the main menu, a settings screen, or a game level. Typically, the root node of a <span class="sans_thesansmonocd_w5regular_">Scene</span> is set to a <i class="calibre9">layout container</i>, such as a <span class="sans_thesansmonocd_w5regular_">Group</span>, <span class="sans_thesansmonocd_w5regular_">Pane</span>, <span class="sans_thesansmonocd_w5regular_">VBox</span>, or <span class="sans_thesansmonocd_w5regular_">HBox</span> object, which in turn contains other nodes, such as buttons, labels, or shapes. Here’s an example of creating a <span class="sans_thesansmonocd_w5regular_">Scene</span> and setting its root node at the same time:</p>
<pre class="calibre10"><code class="calibre11">val root = Group()
val scene = Scene(root, 800.0, 600.0)</code></pre>
<p class="tx"><span aria-label="97" epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>We pass <span class="sans_thesansmonocd_w5regular_">root</span> as the first arguments to the <span class="sans_thesansmonocd_w5regular_">Scene</span> constructor. This mirrors how we assigned a <span class="sans_thesansmonocd_w5regular_">VBox</span> as the root node of our “Hello, world!” application’s <span class="sans_thesansmonocd_w5regular_">Scene</span> object.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1"><span id="sec10"/><span id="h2-47"/><span class="sans_futura_std_bold_condensed_oblique_">Layout Containers</span></h4>
<p class="tni">Layout containers like <span class="sans_thesansmonocd_w5regular_">Group</span> and <span class="sans_thesansmonocd_w5regular_">VBox</span> often serve as the root or parent node for a <span class="sans_thesansmonocd_w5regular_">Scene</span>. They’re used to position and size other <i class="calibre9">child nodes</i> displayed in the application window. In this way, layout containers are essential for designing the structure and layout of a user interface in JavaFX. In upcoming projects, we’ll use a few of these containers, so it’s worth taking a closer look at their properties to see which is most appropriate for different applications. Sometimes more than one type can be equally suitable.</p>
<section aria-labelledby="sec11" epub:type="division">
<h5 class="h2"><span id="sec11"/><span id="h3-22"/><span class="sans_futura_std_bold_b_">Group</span></h5>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">Group</span> is a container that groups other nodes together without providing any layout capabilities. This can be useful when you want to apply a transformation or effect to a set of shapes collectively. For example, you can group multiple shapes together and apply a rotation or scaling effect to the entire group.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h5 class="h2"><span id="sec12"/><span id="h3-23"/><span class="sans_futura_std_bold_b_">Pane</span></h5>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">Pane</span> is a layout container that serves as a building block for organizing and positioning nodes in a user interface. It’s not specialized for a particular layout, which makes it a versatile choice for various UI design scenarios. JavaFX provides several subclasses of <span class="sans_thesansmonocd_w5regular_">Pane</span> that you can choose from based on the requirements of your application. These subclasses include:</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">FlowPane</span> A container for arranging nodes in a fluid manner, automatically wrapping when the container’s boundaries are reached. By default, a <span class="sans_thesansmonocd_w5regular_">FlowPane</span> is horizontal, meaning it lays out nodes in rows, starting from the left boundary. When the right boundary is reached, nodes wrap (move) to the next row.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">StackPane</span> A container for stacking nodes on top of one another, such that one node blocks another. This enables creative layering of elements. All child nodes are automatically centered both horizontally and vertically within the available space.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">BorderPane</span> A container for positioning nodes in a structured manner in the top, bottom, left, right, and center positions.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">AnchorPane</span> Similar to <span class="sans_thesansmonocd_w5regular_">BorderPane</span>, except it allows nodes to attach to the top, bottom, left, and right edges of the pane.</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">GridPane</span> A container for arranging nodes in a grid of rows and columns.</p>
<p class="tx">Panes are essential components of JavaFX applications, as they provide the layout and structure for the user interface. By using panes, you can create flexible and responsive UIs that can adapt to different screen sizes and resolutions.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<span aria-label="98" epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec13"/><span id="h3-24"/><span class="sans_futura_std_bold_b_">VBox and HBox</span></h5>
<p class="tni"><span class="sans_thesansmonocd_w5regular_">VBox</span> and <span class="sans_thesansmonocd_w5regular_">HBox</span> are layout containers designed to organize their child nodes neatly. <span class="sans_thesansmonocd_w5regular_">VBox</span> arranges its children in a vertical column, while <span class="sans_thesansmonocd_w5regular_">HBox</span> places them in a horizontal line.</p>
</section>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="h1"><span id="sec14"/><span id="h2-48"/><span class="sans_futura_std_bold_condensed_oblique_">Child Nodes</span></h4>
<p class="tni">Child nodes are the fundamental building blocks of a JavaFX application. They represent specific visual elements, including shapes (for example, rectangles or circles), images, text, and interactive controls like buttons or text fields. The different types of chart objects that we’ll soon create are also considered nodes in JavaFX. By adding, removing, and modifying nodes within the application’s hierarchy of objects, you can design intuitive and engaging user interfaces.</p>
<p class="tx">You can add child nodes to parent nodes such as a <span class="sans_thesansmonocd_w5regular_">Group</span>, <span class="sans_thesansmonocd_w5regular_">Pane</span>, <span class="sans_thesansmonocd_w5regular_">VBox</span>, or <span class="sans_thesansmonocd_w5regular_">HBox</span> to create complex hierarchies of UI components. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">// Create a rectangle object (child node).
val rectangle = Rectangle(100.0, 100.0, Color.BLUE)

// Pass the child node to its parent node.
val root = Group(rectangle)</code></pre>
<p class="tx">We create a blue <span class="sans_thesansmonocd_w5regular_">Rectangle</span> object that’s 100×100 pixels. We then assign the rectangle as a child node of a <span class="sans_thesansmonocd_w5regular_">Group</span> object called <span class="sans_thesansmonocd_w5regular_">root</span>. In this case, we assign the child node by passing it as an argument to the parent node’s constructor, but children don’t always have to be assigned immediately upon the creation of the parent. You can also assign a child node to a parent later by using the <span class="sans_thesansmonocd_w5regular_">children.add()</span> method:</p>
<pre class="calibre10"><code class="calibre11">// Create a Button object with the text "Click me".
val button = Button("Click me")

// Create a Pane object.
val pane = Pane()

// Add the Button as a child node to the Pane.
pane.children.add(button)</code></pre>
<p class="tx">In this example, we create a <span class="sans_thesansmonocd_w5regular_">Button</span> object (<span class="sans_thesansmonocd_w5regular_">button</span>) and a <span class="sans_thesansmonocd_w5regular_">Pane</span> object (<span class="sans_thesansmonocd_w5regular_">pane</span>). Then we add the button as a child node of the pane by using the <span class="sans_thesansmonocd_w5regular_">children.add()</span> method. This method takes a single node as an argument and appends it to the list of children of the pane. We could also add or pass multiple children to the pane by using the <span class="sans_thesansmonocd_w5regular_">children.addAll()</span> method.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="h"><span id="sec15"/><span id="h1-30"/><span class="sans_futura_std_bold_b_">Creating JavaFX Charts</span></h3>
<p class="tni">JavaFX provides a set of built-in features for creating visually appealing charts. You can feed a dataset into a chart for visualization and customize <span aria-label="99" epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/>the result by changing the colors, fonts, and other properties. Here are the basic steps for creating a chart with JavaFX and Kotlin:</p>
<p class="listnumber">  1.  Create objects to represent the x-axis and y-axis of the chart. These can be of two types: <span class="sans_thesansmonocd_w5regular_">NumberAxis</span> and <span class="sans_thesansmonocd_w5regular_">CategoryAxis</span>. Use the former for visualizing numerical data and the latter for string-type data.</p>
<p class="listnumber1">  2.  Create an instance of a class representing the type of chart you want to design, such as <span class="sans_thesansmonocd_w5regular_">LineChart</span>, <span class="sans_thesansmonocd_w5regular_">BarChart</span>, <span class="sans_thesansmonocd_w5regular_">ScatterChart</span>, <span class="sans_thesansmonocd_w5regular_">PieChart</span>, or <span class="sans_thesansmonocd_w5regular_">BubbleChart</span>. You pass the objects created in step 1 as arguments to the chart’s constructor.</p>
<p class="listnumber1">  3.  Create one or more <span class="sans_thesansmonocd_w5regular_">Series</span> objects to represent the data series you want to display in the chart.</p>
<p class="listnumber1">  4.  Add data points to each series by using the <span class="sans_thesansmonocd_w5regular_">data.add()</span> method for a single data point or the <span class="sans_thesansmonocd_w5regular_">data.addAll()</span> method for several data points at once.</p>
<p class="listnumber1">  5.  Add each series to the chart also by using the <span class="sans_thesansmonocd_w5regular_">data.add()</span> method.</p>
<p class="listnumber1">  6.  Create a new <span class="sans_thesansmonocd_w5regular_">Scene</span> object and add the chart to it. Although you can directly assign a chart object as the root of a scene, you may want to first assign the chart as a child of a layout container and make that container the root of the scene. This way, you can have better control over the result.</p>
<p class="listnumber2">  7.  Assign the <span class="sans_thesansmonocd_w5regular_">Scene</span> to the <span class="sans_thesansmonocd_w5regular_">Stage</span> object where the chart should be displayed. Don’t forget to display the <span class="sans_thesansmonocd_w5regular_">Stage</span> by using its <span class="sans_thesansmonocd_w5regular_">show()</span> method!</p>
<p class="tx">These steps are generic and can be used to create any of the chart types available in JavaFX. We’ll now look at two representative examples of creating different chart objects that use actual data: a bar chart and a line chart.</p>
<p class="headaexercise" id="pre-4"><span class="sans_dogma_ot_bold_b_15-n">Project 4: Visualize Data as a Bar Chart</span></p>
<p class="tni">In this project, we’ll generate a bar chart to visualize the monthly sales data for a fictitious company named ABC &amp; Co. over the first quarter of a year. The chart will feature the months of January through March along the x-axis, with vertical bars illustrating the sales total for each month along the y-axis. The code will follow the same general outline we used for the simple “Hello, world!” application, with modifications to implement the charting steps we discussed.</p>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h1"><span id="sec16"/><span id="h2-49"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Here’s the code for creating a bar chart:</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.geometry.Side
import javafx.scene.Scene
import javafx.scene.chart.CategoryAxis
import javafx.scene.chart.BarChart
<span aria-label="100" epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/>import javafx.scene.chart.NumberAxis
import javafx.scene.chart.XYChart
import javafx.stage.Stage

class BarChartExample : Application() {
    override fun start(primaryStage: Stage) {
      <span aria-label="annotation1" class="code_codeannotation">❶</span> primaryStage.title = "Bar Chart Example"

      <span aria-label="annotation2" class="code_codeannotation">❷</span> // Create XYAxis objects and set their properties.
        val xAxis = CategoryAxis()
        val yAxis = NumberAxis()
        xAxis.label = "Months"
        yAxis.label = "Sales in thousands of dollars"

      <span aria-label="annotation3" class="code_codeannotation">❸</span> // Create BarChart object and set its properties.
        val barChart = BarChart(xAxis, yAxis)
        barChart.title = "Monthly Sales"
        barChart.legendSide = Side.TOP

      <span aria-label="annotation4" class="code_codeannotation">❹</span> // Create Series, populate with data, and assign to chart.
        val dataSeries = XYChart.Series&lt;String, Number&gt;()
        dataSeries.name = "Q1 Data for ABC &amp; Co."
      <span aria-label="annotation5" class="code_codeannotation">❺</span> getData(dataSeries)
        barChart.data.add(dataSeries)

        val scene = Scene(barChart, 400.0, 400.0)
        primaryStage.scene = scene
        primaryStage.show()
    }
}

fun main() {
    Application.launch(BarChartExample::class.java)
}</code></pre>
<p class="tx">We begin by importing the necessary JavaFX classes. In addition to the general <span class="sans_thesansmonocd_w5regular_">Application</span>, <span class="sans_thesansmonocd_w5regular_">Scene</span>, and <span class="sans_thesansmonocd_w5regular_">Stage</span> classes common to any JavaFX application, we import some classes specific to charting, such as <span class="sans_thesansmonocd_w5regular_">Side</span>, <span class="sans_thesansmonocd_w5regular_">CategoryAxis</span>, <span class="sans_thesansmonocd_w5regular_">BarChart</span>, <span class="sans_thesansmonocd_w5regular_">NumberAxis</span>, and <span class="sans_thesansmonocd_w5regular_">XYChart</span>. After the import block, we declare the <span class="sans_thesansmonocd_w5regular_">BarChartExample</span> class, which once again extends JavaFX’s abstract <span class="sans_thesansmonocd_w5regular_">Application</span> class. Much like the “Hello, world!” application, we override the <span class="sans_thesansmonocd_w5regular_">start()</span> method with a custom definition. This time we use the method to create a bar chart.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">start()</span> method is organized into several blocks. In the first block, we set the title of <span class="sans_thesansmonocd_w5regular_">primaryStage</span> (the <span class="sans_thesansmonocd_w5regular_">Stage</span> object passed into the <span class="sans_thesansmonocd_w5regular_">start()</span> <span aria-label="101" epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/>method) to <span class="sans_thesansmonocd_w5regular_">"Bar Chart Example"</span> <span aria-label="annotation1" class="codeannotation">❶</span>. In the second block <span aria-label="annotation2" class="codeannotation">❷</span>, we create two objects representing the chart’s x- and y-axes. We use the <span class="sans_thesansmonocd_w5regular_">CategoryAxis</span> class for the x-axis, where the data points will be months of the year (strings), and the <span class="sans_thesansmonocd_w5regular_">NumberAxis</span> class for the y-axis, where the data points will be numeric sales totals. We also use the <span class="sans_thesansmonocd_w5regular_">label</span> property of each axis object to give the axis a descriptive label. In the third block <span aria-label="annotation3" class="codeannotation">❸</span>, we create the <span class="sans_thesansmonocd_w5regular_">BarChart</span> object, passing the <span class="sans_thesansmonocd_w5regular_">xAxis</span> and <span class="sans_thesansmonocd_w5regular_">yAxis</span> objects as arguments. We also assign the chart a title and position its legend at the top of the chart. The legend explains the significance of the colors or patterns used to visualize the data.</p>
<p class="tx">In the fourth code block <span aria-label="annotation4" class="codeannotation">❹</span>, we create a series called <span class="sans_thesansmonocd_w5regular_">dataSeries</span> of type <span class="sans_thesansmonocd_w5regular_">XYChart.Series</span>. Each data point of this series will have a pair of elements of type <span class="sans_thesansmonocd_w5regular_">&lt;String, Number&gt;</span>, representing a month and its corresponding sales total in thousands of dollars. We set the name for the series; this name will appear in the chart’s legend. Then, to keep the <span class="sans_thesansmonocd_w5regular_">start()</span> method itself concise, we call a custom <span class="sans_thesansmonocd_w5regular_">getData()</span> function <span aria-label="annotation5" class="codeannotation">❺</span> to add data points to the series before adding the series to the <span class="sans_thesansmonocd_w5regular_">BarChart</span> object to plot the data on the chart. Here’s a look at the <span class="sans_thesansmonocd_w5regular_">getData()</span> function:</p>
<pre class="calibre10"><code class="calibre11">fun getData(dataSeries: XYChart.Series&lt;String, Number&gt;) {
    dataSeries.data.addAll(
        XYChart.Data("Jan", 150),
        XYChart.Data("Feb", 100),
        XYChart.Data("Mar", 225)
    )
}</code></pre>
<p class="tx">This function’s sole job is to add the data points to the <span class="sans_thesansmonocd_w5regular_">dataSeries</span> object in bulk by using the <span class="sans_thesansmonocd_w5regular_">data.addAll()</span> method. Each data point is an instance of the <span class="sans_thesansmonocd_w5regular_">XYChart.Data</span> class, which encapsulates the x- and y-axis values of a data point together in one container. In particular, each data point has a string month abbreviation for the x-value and an integer sales total for the y-value. We could also provide the sales totals as floating-point values; JavaFX recognizes both forms as numbers.</p>
<p class="tx">The remaining part of the application class is standard JavaFX template code, virtually identical to that of our “Hello, world!” application. We construct a <span class="sans_thesansmonocd_w5regular_">Scene</span> object, assigning <span class="sans_thesansmonocd_w5regular_">barChart</span> as its root node. Then we assign the <span class="sans_thesansmonocd_w5regular_">Scene</span> object to <span class="sans_thesansmonocd_w5regular_">primaryStage</span> and call the latter’s <span class="sans_thesansmonocd_w5regular_">show()</span> method, which displays the bar chart we’ve created on the screen.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h1"><span id="sec17"/><span id="h2-50"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">If you run this code, the resulting bar chart should look like <a href="chapter3.xhtml#fig3-4" class="calibre2">Figure 3-4</a>.</p>
<span aria-label="102" epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img2" height="1134" id="fig3-4" src="../images/Figure3-4.jpg" width="1142"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-4: A bar chart drawn using JavaFX</span></p></figcaption>
</figure>
<p class="tx">Notice how JavaFX has automatically generated a bar with the correct height for each data point, with the months spaced evenly along the x-axis and ticks labeled in increments of 25 along the y-axis, stopping just past the maximum value displayed in the chart. You can also verify that the chart correctly displays the properties we set explicitly, such as the title (“Monthly Sales”), the x- and y-axes labels (“Months” and “Sales in thousands of dollars”), and the legend (“Q1 Data for ABC &amp; Co.”), which is positioned correctly at the top.</p>
<p class="headaexercise" id="pre-5"><span class="sans_dogma_ot_bold_b_15-n">Project 5: Create a Multiseries Line Chart</span></p>
<p class="tni">In this next project, we’ll create a line chart in JavaFX that displays the average heights of males and females at different ages. In a line chart, both axes are numeric, and their properties can be adjusted—for example, by setting the tick intervals and bounds. We’ll visualize age on the x-axis and height (in inches) on the y-axis. A key feature of the chart is that it will have two datasets, one for males and one for females, each in its own <span class="sans_thesansmonocd_w5regular_">Series</span> object. JavaFX will automatically plot the datasets separately, giving each a different colored line.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<span aria-label="103" epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec18"/><span id="h2-51"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Our code will follow the same structure as the code for the bar chart, with modifications to instead make a line chart with two series. The program can be easily extended to chart three or more series. Here’s the code:</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.geometry.Side
import javafx.scene.Scene
import javafx.scene.chart.LineChart
import javafx.scene.chart.NumberAxis
import javafx.scene.chart.XYChart
import javafx.stage.Stage

class LineChartExample : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title = "Multiseries Line Chart Example"

        // Create XYAxis objects and set their properties.
        val xAxis = NumberAxis()
        xAxis.label = "Age"
        val yAxis = NumberAxis()
        yAxis.label = "Height (inches)"

      <span aria-label="annotation1" class="code_codeannotation">❶</span> // Adjust tick interval and lower/upper bounds.
        xAxis.isAutoRanging = false
        xAxis.tickUnit = 5.0    // custom tick interval
        xAxis.lowerBound = 0.0  // minimum value for x-axis
        xAxis.upperBound = 35.0 // maximum value for x-axis

        yAxis.isAutoRanging = false
        yAxis.lowerBound = 20.0 // minimum value for y-axis
        yAxis.upperBound = 75.0 // maximum value for y-axis

        // Create LineChart object and set its properties.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val lineChart = LineChart(xAxis, yAxis)
        lineChart.title = "Average Heights at Different Ages"
        lineChart.legendSide = Side.TOP

        // Create Series, populate with data, and assign to chart.
        val maleData = XYChart.Series&lt;Number, Number&gt;()
        maleData.name = "Male"
      <span aria-label="annotation3" class="code_codeannotation">❸</span> getMaleData(maleData)
        val femaleData = XYChart.Series&lt;Number, Number&gt;()
        femaleData.name = "Female"
      <span aria-label="annotation4" class="code_codeannotation">❹</span> getFemaleData(femaleData)

      <span aria-label="annotation5" class="code_codeannotation">❺</span> lineChart.data.addAll(maleData, femaleData)

        val scene = Scene(lineChart, 800.0, 600.0)
        primaryStage.scene = scene
        primaryStage.show()
    }
}

<span aria-label="104" epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>fun main() {
    Application.launch(LineChartExample::class.java)
}</code></pre>
<p class="tx">We begin with a typical JavaFX import block, this time importing the <span class="sans_thesansmonocd_w5regular_">LineChart</span> class instead of <span class="sans_thesansmonocd_w5regular_">BarChart</span>. Then we declare an application class called <span class="sans_thesansmonocd_w5regular_">LineChartExample</span> and override its <span class="sans_thesansmonocd_w5regular_">start()</span> method as usual. Inside the method, we first set the <span class="sans_thesansmonocd_w5regular_">primaryStage</span> title to <span class="sans_thesansmonocd_w5regular_">"Average Heights at Different Ages"</span>, create the x- and y-axes, and set their labels. We use the <span class="sans_thesansmonocd_w5regular_">NumberAxis</span> class for both axes, since ages and heights are both numerical data.</p>
<p class="tx">In the next code block <span aria-label="annotation1" class="codeannotation">❶</span>, we further customize the axes. For both axes, we turn off the autoranging capability by setting the <span class="sans_thesansmonocd_w5regular_">isAutoRanging</span> property to <span class="sans_thesansmonocd_w5regular_">false</span> (this is necessary for the subsequent changes to take effect). Then we set the lower and upper bounds for the axes: ages <span class="sans_thesansmonocd_w5regular_">0.0</span> to <span class="sans_thesansmonocd_w5regular_">35.0</span> on the x-axis and heights <span class="sans_thesansmonocd_w5regular_">20.0</span> to <span class="sans_thesansmonocd_w5regular_">75.0</span> on the y-axis. We also set a tick interval of <span class="sans_thesansmonocd_w5regular_">5.0</span> on the x-axis. We let JavaFX work out all these settings automatically for the bar chart, but here we exert more control to remove the unnecessary autogenerated space and better position the two series in the chart window. In particular, JavaFX defaults to a lower bound of <span class="sans_thesansmonocd_w5regular_">0.0</span> for any numeric axis (when x- and y-values are positive), which in this case would create a lot of extra space near the bottom of the chart since the lowest height in the dataset is <span class="sans_thesansmonocd_w5regular_">36.0</span>.</p>
<p class="tx">The next few blocks are very similar to the bar chart example. We create a <span class="sans_thesansmonocd_w5regular_">LineChart</span> object <span aria-label="annotation2" class="codeannotation">❷</span>, set its title, and set the position of the legend. Then we create two <span class="sans_thesansmonocd_w5regular_">XYChart.Series</span> objects, <span class="sans_thesansmonocd_w5regular_">maleData</span> and <span class="sans_thesansmonocd_w5regular_">femaleData</span>, and call two helper functions, <span class="sans_thesansmonocd_w5regular_">getMaleData()</span> <span aria-label="annotation3" class="codeannotation">❸</span> and <span class="sans_thesansmonocd_w5regular_">getFemaleData()</span> <span aria-label="annotation4" class="codeannotation">❹</span>, to populate the series with data. Here are the definitions of those functions:</p>
<pre class="calibre10"><code class="calibre11">fun getMaleData(maleData: XYChart.Series&lt;Number, Number&gt;) {
    maleData.data.addAll(
        XYChart.Data(5, 38.0),
        XYChart.Data(10, 50.0),
        XYChart.Data(15, 62.0),
        XYChart.Data(20, 68.0),
        XYChart.Data(30, 69.0)
    )
}

fun getFemaleData(femaleData: XYChart.Series&lt;Number, Number&gt;) {
    femaleData.data.addAll(
        XYChart.Data(5, 36.0),
        XYChart.Data(10, 48.0),
        XYChart.Data(15, 60.0),
        XYChart.Data(20, 64.0),
        XYChart.Data(30, 65.0)
    )
}</code></pre>
<p class="tx"><span aria-label="105" epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>Much like the bar chart project, we use the <span class="sans_thesansmonocd_w5regular_">data.addAll()</span> method to add all the data points to each series in one go. As before, the x- and y-values for each data point are packaged into an <span class="sans_thesansmonocd_w5regular_">XYChart.Data</span> object.</p>
<p class="tx">Returning to the main code, once both series (<span class="sans_thesansmonocd_w5regular_">maleData</span> and <span class="sans_thesansmonocd_w5regular_">femaleData</span>) are populated, we add them to the <span class="sans_thesansmonocd_w5regular_">lineChart</span> object by using the <span class="sans_thesansmonocd_w5regular_">data.addAll()</span> method <span aria-label="annotation5" class="codeannotation">❺</span>. Finally, we assign <span class="sans_thesansmonocd_w5regular_">lineChart</span> to <span class="sans_thesansmonocd_w5regular_">scene</span> and <span class="sans_thesansmonocd_w5regular_">scene</span> to <span class="sans_thesansmonocd_w5regular_">primaryStage</span>, and call the <span class="sans_thesansmonocd_w5regular_">primaryStage</span> object’s <span class="sans_thesansmonocd_w5regular_">show()</span> method to display the line chart, following our normal pattern of displaying a JavaFX visualization.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1"><span id="sec19"/><span id="h2-52"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni"><a href="chapter3.xhtml#fig3-5" class="calibre2">Figure 3-5</a> shows the line chart that results from running the code.</p>
<figure class="img"><img alt="" class="img2" height="900" id="fig3-5" src="../images/Figure3-5.jpg" width="1145"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-5: A multiseries line chart drawn using JavaFX</span></p></figcaption>
</figure>
<p class="tx">The line chart displays the average heights for males and females of different age groups as a set of two series plotted on the same x- and y-axes. JavaFX uses the chart’s legend to distinguish one plot from the other. You can verify that the chart has been configured based on the properties we’ve set manually; for example, the y-axis has a lower bound of 20, and the x-axis ticks are labeled in increments of 5.</p>
<p class="tx">You can do a lot more customization beyond the basic settings we’ve adjusted in this project. I’ll leave it to you to explore other options based on your additional reading and experimentation with JavaFX.</p>
<span aria-label="106" epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>
<aside aria-label="box-17" class="box2">
<p class="boxtitle" id="box-17"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Try developing a simple pie chart application using JavaFX and Kotlin. It should show the market shares of four different products as percentages. Use these data points:</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">Product A: 13.0 percent</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Product B: 28.0 percent</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Product C: 35.0 percent</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Product D: 24.0 percent</span></li>
</ul>
<p class="box3"><span class="sans_futura_std_book_">Here are some tips on how to proceed:</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">Be sure to import the</span> <span class="sans_thesansmonocd_w5regular_">javafx.scene.chart.PieChart</span> <span class="sans_futura_std_book_">class. You can also leave out some of the other typical imports, since pie charts don’t have x- and y-axes.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">You can create a</span> <span class="sans_thesansmonocd_w5regular_">PieChart</span> <span class="sans_futura_std_book_">object without passing any arguments to the constructor:</span></li>
</ul>
<pre class="calibre10"><code class="calibre11">   val pieChart = PieChart()</code></pre>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">You don’t have to create a series for the data points. Instead, you can provide the data points directly to the</span> <span class="sans_thesansmonocd_w5regular_">PieChart</span> <span class="sans_futura_std_book_">object by using its</span> <span class="sans_thesansmonocd_w5regular_">data .addAll()</span> <span class="sans_futura_std_book_">method. I recommend writing a helper function to fetch the data instead of doing it all from within the</span> <span class="sans_thesansmonocd_w5regular_">start()</span> <span class="sans_futura_std_book_">method.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Inside the helper function, add data points to the</span> <span class="sans_thesansmonocd_w5regular_">pieChart</span> <span class="sans_futura_std_book_">object as follows:</span></li>
</ul>
<pre class="calibre10"><code class="calibre11">pieChart.data.addAll(
    PieChart.Data("Product A", 13.0),
    <var class="calibre18">--snip--</var>
    PieChart.Data("Product D", 24.0),
)</code></pre>
<p class="boxlist"><span class="sans_futura_std_book_">Notice that the data points are supplied using a</span> <span class="sans_thesansmonocd_w5regular_">&lt;String, Double&gt;</span> <span class="sans_futura_std_book_">format—that is, for a given data point we specify the product name as a string and the percent share as a floating-point value.</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">Experiment with turning the pie chart’s data labels off (they’re on by default). This can be done by setting the</span> <span class="sans_thesansmonocd_w5regular_">labelsVisible</span> <span class="sans_futura_std_book_">property of</span> <span class="sans_thesansmonocd_w5regular_">pieChart</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">false</span><span class="sans_futura_std_book_">.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">JavaFX will assign default colors to the pie chart slices. Try changing those colors or using patterns instead of colors, since patterns are easily recognized even in grayscale images. Search for “change PieChart color in JavaFX” online for more information on how to do this.</span></li>
</ul>
</aside>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<span aria-label="107" epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>
<h3 class="h"><span id="sec20"/><span id="h1-31"/><span class="sans_futura_std_bold_b_">Drawing with the Canvas</span></h3>
<p class="tni">In JavaFX, a <i class="calibre9">canvas</i> is a region that provides a drawing surface for rendering custom 2D graphics. Whereas JavaFX’s charting features handle much of the drawing automatically, a canvas allows you to write low-level code for drawing individual lines, shapes, text fields, and more. You create a canvas by instantiating the <span class="sans_thesansmonocd_w5regular_">Canvas</span> class. Then you draw to the canvas object by accessing its <i class="calibre9">graphics context</i>.</p>
<p class="tx">In this section, we’ll look at a simple first example of working with a JavaFX canvas and explore some commonly used drawing methods. Then we’ll get better acquainted with the canvas through a more elaborate drawing project.</p>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="h1"><span id="sec21"/><span id="h2-53"/><span class="sans_futura_std_bold_condensed_oblique_">A Simple Shape</span></h4>
<p class="tni">Let’s get started with the JavaFX <span class="sans_thesansmonocd_w5regular_">Canvas</span> class by using it to draw a simple shape. Here’s the code for an application that draws a rectangle to the canvas:</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.canvas.Canvas
import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.stage.Stage

class CanvasExample_1 : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title = "Canvas Example"

      <span aria-label="annotation1" class="code_codeannotation">❶</span> val canvas = Canvas(400.0, 200.0)
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val gc = canvas.getGraphicsContext2D()
        val pane = Pane(canvas)
        val scene = Scene(pane)
        primaryStage.setScene(scene)
        primaryStage.show()

      <span aria-label="annotation3" class="code_codeannotation">❸</span> drawRectangle(gc)
    }
    fun drawRectangle(gc: GraphicsContext) {
      <span aria-label="annotation4" class="code_codeannotation">❹</span> with(gc) {
            stroke = Color.RED
            strokeRect(100.0, 50.0, 200.0, 100.0)
        }
    }
}

fun main() {
    Application.launch(CanvasExample_1::class.java)
}</code></pre>
<p class="tx"><span aria-label="108" epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>Inside the application class’s <span class="sans_thesansmonocd_w5regular_">start()</span> method, we create an instance of the <span class="sans_thesansmonocd_w5regular_">Canvas</span> class with a size of 400×200 pixels and call it <span class="sans_thesansmonocd_w5regular_">canvas</span> <span aria-label="annotation1" class="codeannotation">❶</span>. Then we call the canvas object’s <span class="sans_thesansmonocd_w5regular_">getGraphicsContext2D()</span> method. It returns a reference to the canvas’s <span class="sans_thesansmonocd_w5regular_">GraphicsContext</span> object, which we store in the <span class="sans_thesansmonocd_w5regular_">gc</span> variable <span aria-label="annotation2" class="codeannotation">❷</span>. This object provides the interface for drawing to the canvas. We then follow the usual steps of assigning the canvas to a layout container (a <span class="sans_thesansmonocd_w5regular_">Pane</span> object), the container to a scene, and the scene to the primary stage, which we display with the <span class="sans_thesansmonocd_w5regular_">show()</span> method. We need the <span class="sans_thesansmonocd_w5regular_">Pane</span> since <span class="sans_thesansmonocd_w5regular_">Canvas</span> isn’t a parent-type node and thus can’t be passed directly to a scene. Also, by making the <span class="sans_thesansmonocd_w5regular_">Canvas</span> object a child node to a container such as a <span class="sans_thesansmonocd_w5regular_">Pane</span> or <span class="sans_thesansmonocd_w5regular_">VBox</span>, we can further customize its placement and size if needed.</p>
<p class="tx">To draw the rectangle, we call a custom <span class="sans_thesansmonocd_w5regular_">drawRectangle()</span> method <span aria-label="annotation3" class="codeannotation">❸</span> that takes one argument, the graphics context. In the method’s definition, we use Kotlin’s <span class="sans_thesansmonocd_w5regular_">with</span> scope function to group the actions requiring access to the graphics content, <span class="sans_thesansmonocd_w5regular_">gc</span> <span aria-label="annotation4" class="codeannotation">❹</span>. This saves us from adding <span class="sans_thesansmonocd_w5regular_">gc.</span> to the start of each line of code, which is a big help in longer drawing methods. We set the <span class="sans_thesansmonocd_w5regular_">stroke</span> color of the graphics context to red (in computer graphics, a <i class="calibre9">stroke</i> is the outline of a geometric shape), then call JavaFX’s <span class="sans_thesansmonocd_w5regular_">strokeRect()</span> method to draw a rectangle. The first two arguments (<span class="sans_thesansmonocd_w5regular_">100.0</span> and <span class="sans_thesansmonocd_w5regular_">50.0</span>) set the x- and y-coordinates of the rectangle’s top-left corner, and the remaining arguments (<span class="sans_thesansmonocd_w5regular_">200.0</span> and <span class="sans_thesansmonocd_w5regular_">100.0</span>) define its width and height (in pixels). By default, the origin of the coordinate system (<span class="sans_thesansmonocd_w5regular_">0.0, 0.0</span>) is positioned at the top-left corner of the canvas.</p>
<p class="tx"><a href="chapter3.xhtml#fig3-6" class="calibre2">Figure 3-6</a> shows the result of running this simple canvas application.</p>
<figure class="img"><img alt="" class="img1" height="738" id="fig3-6" src="../images/Figure3-6.jpg" width="1388"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-6: A red-outlined rectangle (shown here in gray) on a canvas</span></p></figcaption>
</figure>
<p class="tx">In this example, we’ve defined the <span class="sans_thesansmonocd_w5regular_">drawRectangle()</span> method within the <span class="sans_thesansmonocd_w5regular_">CanvasExample_1</span> class. Alternatively, we could have created it as an independent function, similar to the <span class="sans_thesansmonocd_w5regular_">getData()</span> functions in the bar chart and line chart examples. Both approaches are valid. When a function is generic and could be reused by other classes or modules, consider making it a stand-alone function. Otherwise, creating it as an internal method of a class enhances data encapsulation.</p>
<span aria-label="109" epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/>
<aside aria-label="box-18" class="box2">
<p class="boxtitle" id="box-18"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Modify the rectangle-drawing code to achieve the following:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Write a</span> <span class="sans_thesansmonocd_w5regular_">drawSquare()</span> <span class="sans_futura_std_book_">method to draw a filled square in the middle of a canvas. You’ll need to use the</span> <span class="sans_thesansmonocd_w5regular_">gc.fill</span> <span class="sans_futura_std_book_">feature to set the fill color and the</span> <span class="sans_thesansmonocd_w5regular_">gc.fillRect()</span> <span class="sans_futura_std_book_">method to draw the square.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Write a</span> <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> <span class="sans_futura_std_book_">method that will draw a filled triangle in the middle of a canvas. You’ll again need to use the</span> <span class="sans_thesansmonocd_w5regular_">gc.fill</span> <span class="sans_futura_std_book_">feature to set the fill color, plus the</span> <span class="sans_thesansmonocd_w5regular_">gc.fillPolygon()</span> <span class="sans_futura_std_book_">method to draw the triangle. This method takes three arguments: an array of x-coordinates for the polygon’s vertices, an array of corresponding y-coordinates, and an integer specifying the number of vertices. In this case, use</span> <span class="sans_thesansmonocd_w5regular_">doubleArrayOf(x1, x2, x3)</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">doubleArrayOf(y1, y2, y3)</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">n</span><span class="sans_futura_std_book_">, where</span> <span class="sans_thesansmonocd_w5regular_">x1</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">x2</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">x3</span> <span class="sans_futura_std_book_">are the x-coordinates;</span> <span class="sans_thesansmonocd_w5regular_">y1</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">y2</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">y3</span> <span class="sans_futura_std_book_">are the y-coordinates; and</span> <span class="sans_thesansmonocd_w5regular_">n</span> <span class="sans_futura_std_book_">is</span> <span class="sans_thesansmonocd_w5regular_">3</span><span class="sans_futura_std_book_">.</span></p>
</div>
</aside>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="h1"><span id="sec22"/><span id="h2-54"/><span class="sans_futura_std_bold_condensed_oblique_">Common Graphics Context Methods</span></h4>
<p class="tni">The graphics context is an essential tool associated with any canvas that enables you to design 2D graphics in JavaFX. Before moving on to more advanced projects involving the canvas, let’s consider some of the key features and capabilities of the <span class="sans_thesansmonocd_w5regular_">GraphicsContext</span> class and how to apply them in Kotlin. The most commonly used features are listed in <a href="chapter3.xhtml#tab3-1" class="calibre2">Table 3-1</a> for ease of reference.</p>
<p class="tt" id="tab3-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 3-1:</span></span> <span class="sans_futura_std_book_">Commonly Used Graphics Context Methods</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Feature</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Description</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Usage in Kotlin</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">Drawing shapes</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">Draw various 2D shapes, such as lines, rectangles, circles, and polygons.</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.strokeRect(</span><span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">width</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">height</span><span class="sans_thesansmonocd_w5regular_">) gc.fillOval(</span><span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">radiusX</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">radiusY</span><span class="sans_thesansmonocd_w5regular_">) gc.fillPolygon(</span><span class="sans_thesansmonocd_w5regular_italic_">x-array</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y-array</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">n</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Setting colors</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Set stroke (outline) and fill colors for shapes.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.stroke</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">Color.RED gc.fill</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">Color.BLUE</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Line width</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Set line width and line style.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.lineWidth</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">2.0 gc.setLineDashes(</span><span class="sans_thesansmonocd_w5regular_italic_">dash</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">gap</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Text rendering</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Draw text on the canvas with specified fonts and sizes.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.font</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">Font("Arial", 14.0) gc.fillText("Hello, world!",</span> <span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Image rendering</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Draw images on the canvas.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">val image</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">Image("image.png") gc.drawImage(image,</span> <span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Transformations</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Translate (move the origin of the coordinate system by the specified x- and y-values) and rotate (rotate the subsequent drawings by a specified angle).</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.translate(</span><span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">) gc.rotate(</span><span class="sans_thesansmonocd_w5regular_italic_">angle</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Clearing canvas</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Clear the entire canvas or a specific region.</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">gc.clearRect(0.0, 0.0, canvas.width, canvas.height) gc.clearRect(</span><span class="sans_thesansmonocd_w5regular_italic_">x</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">y</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">width</span><span class="sans_thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">height</span><span class="sans_thesansmonocd_w5regular_">)</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="110" epub:type="pagebreak" id="pg_110" role="doc-pagebreak"/><a href="chapter3.xhtml#tab3-1" class="calibre2">Table 3-1</a> shows the rich set of capabilities that the graphics context provides. For example, we can draw and fill geometric shapes such as rectangles and ovals with different colors. We can also adjust the width and style of a line. We have many options for rendering text as well. Besides shapes, we can use images of various formats (for example, JPG, PNG, or GIF) and creatively place them on the canvas. Moreover, we can move the origin of the coordinate system and rotate objects drawn on the canvas, altering their orientation relative to the current coordinate system. And finally, we can wipe the entire canvas clean, providing a fresh starting point for dynamic simulations.</p>
<p class="tx">In the projects to follow in this chapter and elsewhere in the book, we’ll use many of these features and see how they work in more detail.</p>
<p class="headaexercise" id="pre-6"><span class="sans_dogma_ot_bold_b_15-n">Project 6: Draw a Spiral Seashell</span></p>
<p class="tni">In this project, we’ll dive deeper into the drawing capabilities of the JavaFX canvas and its 2D graphics context. We’ll create a complex figure with many circles of increasing sizes, arranged in a spiral around the center of the canvas. By changing the key parameters, we can produce various visual effects. Here we’ll use the parameters to make a figure that resembles a seashell with a spiral growth pattern.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="h1"><span id="sec23"/><span id="h2-55"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">Before diving into the code, let’s strategize the approach required to generate a spiral pattern. A spiral resembles a circle, with one important difference: its leading edge never returns to the origin point. Instead, it continuously moves farther away from the center while encircling the initial starting point. To achieve this mathematically, we’ll employ a method involving a sequence of lines, as illustrated in <a href="chapter3.xhtml#fig3-7" class="calibre2">Figure 3-7</a>.</p>
<figure class="img"><img alt="" class="img1" height="674" id="fig3-7" src="../images/Figure3-7.jpg" width="1503"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-7: The strategy for making a spiral pattern</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="111" epub:type="pagebreak" id="pg_111" role="doc-pagebreak"/>Each line has one end anchored at a specific point F, which we’ll set to the center of the canvas. The position of the other end of the line, C, is determined by two key factors: the length <i class="calibre9">r</i> of the line and an angle of rotation <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> relative to the positive x-axis (or another fixed reference). Given the values of <i class="calibre9">r</i> and <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, we can use some basic trigonometry to calculate the coordinates of point C. By gradually increasing both the angle of rotation and the length of the line by preset amounts, the successive values of C will form a spiral as the points simultaneously circle around the fixed point F and grow more distant from it. We’ll repeat this until the spiral has achieved the desired number of turns (one turn equals 360 degrees).</p>
<p class="tx">To create the spiral pattern, we’ll treat each point C as the center of a circle with a radius of length <i class="calibre9">r</i>. These circles will grow larger and move farther away from the starting point as we repeat the process.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="h1"><span id="sec24"/><span id="h2-56"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Here’s the general structure of the code that will be used to draw the seashell spiral:</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.canvas.Canvas
import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.stage.Stage

import kotlin.math.cos
import kotlin.math.sin

class MultiTurnSpiral : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title = "Multi-Turn Spiral"

        // Create a canvas and set its graphics context.
        val canvas = Canvas(600.0, 600.0)
        val gc = canvas.graphicsContext2D

      <span aria-label="annotation1" class="code_codeannotation">❶</span> primaryStage.scene = Scene(Pane(canvas))
        primaryStage.show()

        // Call helper function to draw the spiral.
        drawMultiTurnSpiral(gc, canvas.width, canvas.height)
    }

    fun drawMultiTurnSpiral(
        gc: GraphicsContext,
        width: Double, height: Double) {
        <var class="calibre18">--snip--</var>
    }

    fun printParams(
        gc: GraphicsContext,
<span aria-label="112" epub:type="pagebreak" id="pg_112" role="doc-pagebreak"/>        radiusStep: Double, numCircles: Int) {
        <var class="calibre18">--snip--</var>
    }

    fun drawCircle(
        gc: GraphicsContext,
        x: Double, y: Double, radius: Double) {
        <var class="calibre18">--snip--</var>
    }
}

fun main() {
    Application.launch(MultiTurnSpiral::class.java)
}</code></pre>
<p class="tx">We begin by importing the required graphics-related classes, as well as the <span class="sans_thesansmonocd_w5regular_">cos()</span> and <span class="sans_thesansmonocd_w5regular_">sin()</span> trigonometric functions from Kotlin’s <span class="sans_thesansmonocd_w5regular_">math</span> library. Then we declare the <span class="sans_thesansmonocd_w5regular_">MultiTurnSpiral</span> application class. Much like the rectangle example, we first create and set the graphics elements, then call a custom method, in this case <span class="sans_thesansmonocd_w5regular_">drawMultiTurnSpiral()</span>, to coordinate the actual drawing. This approach keeps the overridden <span class="sans_thesansmonocd_w5regular_">start()</span> method concise. Notice that we’ve condensed the creation of the necessary JavaFX nodes by setting the <span class="sans_thesansmonocd_w5regular_">scene</span> property of the <span class="sans_thesansmonocd_w5regular_">primaryStage</span> object to <span class="sans_thesansmonocd_w5regular_">Scene(Pane(canvas))</span> <span aria-label="annotation1" class="codeannotation">❶</span>. Nested assignments like this can help eliminate a few lines of code when the intermediate objects aren’t needed for other purposes.</p>
<p class="tx">Beyond the <span class="sans_thesansmonocd_w5regular_">start()</span> method, the application class contains three methods that collectively define and render the spiral pattern. Among them, <span class="sans_thesansmonocd_w5regular_">drawMultiTurnSpiral()</span> is the primary method, while the other two, <span class="sans_thesansmonocd_w5regular_">printParams()</span> and <span class="sans_thesansmonocd_w5regular_">drawCircle()</span>, are helpers. We’ll look at each of these methods in detail, starting with <span class="sans_thesansmonocd_w5regular_">drawMultiTurnSpiral()</span>.</p>
<pre class="calibre10"><code class="calibre11">fun drawMultiTurnSpiral(
          gc: GraphicsContext,
          width: Double, height: Double) {

  <span aria-label="annotation1" class="code_codeannotation">❶</span> // Set key parameters for the spiral.
    val numCircles = 70  // number of circles
    val turns = 2.0      // 360 degrees per turn
    val maxAngle = 360.0 * turns
    // rotation in degrees per step
    val rotationStep = (maxAngle / numCircles)

    // Ensure the circles stay inside the canvas boundaries.
    val maxRadius = minOf(width, height) / 10.0
    // Set the amplification factor.
    val spacingFactor = 2.0
    val radiusStep = (maxRadius / numCircles) * spacingFactor

  <span aria-label="annotation2" class="code_codeannotation">❷</span> printParams(gc, radiusStep, numCircles)

  <span aria-label="annotation3" class="code_codeannotation">❸</span> for (i in 0..&lt; numCircles) {
        val angle = i * rotationStep
        val radius = i * radiusStep

<span aria-label="113" epub:type="pagebreak" id="pg_113" role="doc-pagebreak"/>        val x = (width / 2.0) + radius * cos(Math.toRadians(angle))
        val y = (height / 2.0) + radius * sin(Math.toRadians(angle))

        // Draw circles with increasing radii.
      <span aria-label="annotation4" class="code_codeannotation">❹</span> drawCircle(gc, x, y, radius)
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">drawMultiTurnSpiral()</span> method takes three parameters: <span class="sans_thesansmonocd_w5regular_">gc</span>, <span class="sans_thesansmonocd_w5regular_">width</span>, and <span class="sans_thesansmonocd_w5regular_">height</span>, which are the graphics context and the width and height of the canvas, respectively. We first set some key parameters for the spiral <span aria-label="annotation1" class="codeannotation">❶</span>. The <span class="sans_thesansmonocd_w5regular_">numCircles</span> variable sets the number of circles we’ll draw and <span class="sans_thesansmonocd_w5regular_">turns</span> dictates the number of rotations we’ll make around the center of the spiral. Multiplying <span class="sans_thesansmonocd_w5regular_">turns</span> by <span class="sans_thesansmonocd_w5regular_">360</span> gives us the maximum angle of rotation we’ll achieve, and dividing that value by <span class="sans_thesansmonocd_w5regular_">numCircles</span> gives us <span class="sans_thesansmonocd_w5regular_">rotationStep</span>, the amount we’ll rotate between drawing each circle. Similarly, we set <span class="sans_thesansmonocd_w5regular_">maxRadius</span>, the radius of the largest circle, to one-tenth the width or height of the canvas (whichever is lower), then divide this by <span class="sans_thesansmonocd_w5regular_">numCircles</span> and multiply the result by <span class="sans_thesansmonocd_w5regular_">spacingFactor</span> to get <span class="sans_thesansmonocd_w5regular_">radiusStep</span>, the amount by which the radius will grow from one circle to the next. Dividing the minimum of the width and height by <span class="sans_thesansmonocd_w5regular_">10</span> gives us some space to play with, and varying the <span class="sans_thesansmonocd_w5regular_">spacingFactor</span> allows us to better utilize that space by adjusting the distance between the circles. I’ve used a <span class="sans_thesansmonocd_w5regular_">spacingFactor</span> of <span class="sans_thesansmonocd_w5regular_">2</span> to create a visually pleasing pattern, but feel free to experiment with the values to understand how they affect the final figure.</p>
<p class="tx">With these parameters set, we call the <span class="sans_thesansmonocd_w5regular_">printParams()</span> method <span aria-label="annotation2" class="codeannotation">❷</span>, which prints some key parameter values to the canvas. (We’ll look at this method shortly.) Then we use a <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation3" class="codeannotation">❸</span> to iterate over the desired number of circles and draw them on the canvas. For each circle, we multiply looping variable <span class="sans_thesansmonocd_w5regular_">i</span> by <span class="sans_thesansmonocd_w5regular_">rotationStep</span> to calculate the current angle of rotation relative to the positive x-direction, and we multiply <span class="sans_thesansmonocd_w5regular_">i</span> by <span class="sans_thesansmonocd_w5regular_">radiusStep</span> to get the circle’s radius. We then calculate the coordinates of the circle’s center (<span class="sans_thesansmonocd_w5regular_">x</span>, <span class="sans_thesansmonocd_w5regular_">y</span>) by using trigonometric functions, taking the center of the canvas as the fixed point at the center of the spiral. (See <a href="chapter3.xhtml#fig3-7" class="calibre2">Figure 3-7</a> for how these calculations are derived.) Note that the <span class="sans_thesansmonocd_w5regular_">cos()</span> and <span class="sans_thesansmonocd_w5regular_">sin()</span> functions expect angles measured in radians rather than degrees, so we call <span class="sans_thesansmonocd_w5regular_">toRadians()</span> on the angle. Finally, we pass along the circle’s parameters to the custom <span class="sans_thesansmonocd_w5regular_">drawCircle()</span> method to actually draw the circle, including its center <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
<p class="tx">Now let’s look at the definitions of the two helper methods, <span class="sans_thesansmonocd_w5regular_">printParams()</span> and <span class="sans_thesansmonocd_w5regular_">drawCircle()</span>:</p>
<pre class="calibre10"><code class="calibre11">fun printParams(gc: GraphicsContext, radiusStep: Double, numCircles: Int) {

    val msg1 = "Base radius: " + "%.4f".format(radiusStep) + " pixels"
    val msg2 = "Number of shapes (circles): $numCircles"
    gc.fillText(msg1, 25.0, 555.0)
    gc.fillText(msg2, 25.0, 575.0)
}

fun drawCircle(
        gc: GraphicsContext,
        x: Double, y: Double, radius: Double) {

<span aria-label="114" epub:type="pagebreak" id="pg_114" role="doc-pagebreak"/>  <span aria-label="annotation1" class="code_codeannotation">❶</span> // Set draw parameters.
    val topLeftX = x - radius
    val topLeftY = y - radius
    val pointSize = 8.0

    with (gc) {
        lineWidth = 2.0
        stroke = Color.LIGHTBLUE
        fill = Color.RED
      <span aria-label="annotation2" class="code_codeannotation">❷</span> fillOval(x – pointSize / 2, y - pointSize / 2,
                 pointSize, pointSize)
      <span aria-label="annotation3" class="code_codeannotation">❸</span> strokeOval(topLeftX, topLeftY, radius * 2, radius * 2)
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">printParams()</span> method takes in the graphics context and two key parameters of the spiral: the radius step and the number of circles. We create two string templates by using these parameters in the <span class="sans_thesansmonocd_w5regular_">msg1</span> and <span class="sans_thesansmonocd_w5regular_">msg2</span> variables. In <span class="sans_thesansmonocd_w5regular_">msg1</span>, we format <span class="sans_thesansmonocd_w5regular_">radiusStep</span>, a floating-point number, to four decimal places. In <span class="sans_thesansmonocd_w5regular_">msg2</span>, the number of circles, <span class="sans_thesansmonocd_w5regular_">numCircles</span>, is an integer, so no formatting is needed. We then pass the messages along to the <span class="sans_thesansmonocd_w5regular_">gc.fillText()</span> method, which displays the text at a specified location on the canvas (we’re using coordinates near the bottom-left corner). This method offers a valuable alternative to using the <span class="sans_thesansmonocd_w5regular_">println()</span> function, which is limited to displaying text in the console. With <span class="sans_thesansmonocd_w5regular_">fillText()</span>, we have the capability to print text directly on the canvas, enhancing the visual representation of the program’s output.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">drawCircle()</span> method draws an individual circle in the spiral in two ways: as a light blue outline of the full circle and as a smaller red dot to mark the center of the circle. The method takes in the graphics context, the x- and y-coordinates of the circle’s center, and the circle’s radius. There’s a catch, however: the canvas’s methods for drawing a circle, <span class="sans_thesansmonocd_w5regular_">fillOval()</span> and <span class="sans_thesansmonocd_w5regular_">strokeOval()</span>, position the circle not from its center but from the top-left corner of a rectangle that surrounds the circle. We therefore subtract the <span class="sans_thesansmonocd_w5regular_">radius</span> from <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span> to get the coordinates for the top-left corner <span aria-label="annotation1" class="codeannotation">❶</span>. We also set <span class="sans_thesansmonocd_w5regular_">pointSize</span>, which defines the diameter of the small, filled circle marking the circle’s center.</p>
<p class="tx">For the rest of the method, we use the scoping function <span class="sans_thesansmonocd_w5regular_">with</span> to access the properties and methods of the graphics context more easily. We set the line width and stroke color for the outlined circle and the fill color for the central circle. Then we draw the small central circle by using <span class="sans_thesansmonocd_w5regular_">fillOval()</span> <span aria-label="annotation2" class="codeannotation">❷</span> and the larger outlined circle by using <span class="sans_thesansmonocd_w5regular_">strokeOval()</span> <span aria-label="annotation3" class="codeannotation">❸</span>. The first two arguments are the coordinates of the bounding rectangle’s top-left corner, and the remaining two are the desired width and height (which for a circle are both twice the radius).</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<span aria-label="115" epub:type="pagebreak" id="pg_115" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec25"/><span id="h2-57"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">We’re now ready to run the code. It should produce the output shown in <a href="chapter3.xhtml#fig3-8" class="calibre2">Figure 3-8</a>.</p>
<figure class="img"><img alt="" class="img2" height="1053" id="fig3-8" src="../images/Figure3-8.jpg" width="1053"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-8: A two-turn spiral created with circles of increasing radii</span></p></figcaption>
</figure>
<p class="tx">Take a few moments to appreciate the spiral’s visual intricacy. By plotting the centers of the circles with a contrasting color, we can clearly see how the successive circles get bigger and farther away from the center of the canvas (recall that the radius was a linear function of <span class="sans_thesansmonocd_w5regular_">radiusStep</span>). Ignoring the trajectory of the central dots for a moment, the circles create a visual illusion of a spiral seashell. This is no coincidence: some real-life seashells grow in spirals based on precise mathematical rules.</p>
</section>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="h"><span id="sec26"/><span id="h1-32"/><span class="sans_futura_std_bold_b_">Animation in JavaFX</span></h3>
<p class="tni">Animation is a powerful tool for creating engaging and interactive applications. JavaFX offers various animation options, from simple transitions to complex sequences. You can animate onscreen objects in JavaFX in two main ways: by using the <span class="sans_thesansmonocd_w5regular_">TranslateTransition</span> class or by using the <span class="sans_thesansmonocd_w5regular_">Timeline</span> and <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> classes. In the following projects, we’ll explore both of these methods through hands-on examples.</p>
<p class="headaexercise" id="pre-7"><span aria-label="116" epub:type="pagebreak" id="pg_116" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_15-n">Project 7: Animate a Square</span></p>
<p class="tni">Transition-based animation treats animation as a gradual shift from one state to another. You define the start and end states of a visual object, and JavaFX works out a way to smoothly transition between the two. With transitions, you can make objects move, rotate, scale, fade, and so on, creating simple effects such as sliding, bouncing, flipping, and fading in or out. Transitions are easy to use and require minimal coding, but they’re more limited than the timeline and keyframe approach we’ll consider in the next project.</p>
<p class="tx">To use a transition, you need to create an instance of a transition class, such as <span class="sans_thesansmonocd_w5regular_">TranslateTransition</span> to move an object or <span class="sans_thesansmonocd_w5regular_">RotateTransition</span> to make it spin. You pass the node you want to animate as an argument to the transition’s constructor. Then you set transition properties such as the duration, cycle count, and autoreverse. Finally, you call the transition object’s <span class="sans_thesansmonocd_w5regular_">play()</span> method to start the animation.</p>
<section aria-labelledby="sec27" epub:type="division">
<h4 class="h1"><span id="sec27"/><span id="h2-58"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Here’s a simple example that uses transitions to move a square back and forth from one side of the screen to the other:</p>
<pre class="calibre10"><code class="calibre11">// graphics-related imports
import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.scene.shape.Rectangle
import javafx.stage.Stage

// animation-related imports
import javafx.animation.Transition
import javafx.animation.TranslateTransition
import javafx.util.Duration

class TransitionExample : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title = "Transition Example"

        // Create a square.
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val square = Rectangle(50.0, 50.0, Color.RED)
        square.y = 100.0
        // Create a pane to hold the square.
        val pane = Pane(square)

        // Create a scene and show the stage.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val scene = Scene(pane, 300.0, 300.0)
        primaryStage.scene = scene
        primaryStage.show()

        // Create a TranslateTransition class instance
        // and set its properties.
<span aria-label="117" epub:type="pagebreak" id="pg_117" role="doc-pagebreak"/>      <span aria-label="annotation3" class="code_codeannotation">❸</span> val transition =
            TranslateTransition(Duration.seconds(2.0), square)

        with (transition) {
            fromX = 0.0
            toX = pane.width - square.width
            cycleCount = Transition.INDEFINITE
            isAutoReverse = true
          <span aria-label="annotation4" class="code_codeannotation">❹</span> play()
        }
    }
}

fun main() {
    Application.launch(TransitionExample::class.java)
}</code></pre>
<p class="tx">We begin with the import block, which is now organized into imports related to graphics and imports related to animation. The application class, <span class="sans_thesansmonocd_w5regular_">TransitionExample</span>, has the same familiar structure we’ve seen throughout the chapter. I’ll highlight only the problem-specific parts.</p>
<p class="tx">To animate a square, we first create one by using the <span class="sans_thesansmonocd_w5regular_">Rectangle</span> class <span aria-label="annotation1" class="codeannotation">❶</span>. We set the side lengths of the square to 50 pixels and its color to red. By default, the square would be positioned at the top-left corner of the window, but we update the square’s <span class="sans_thesansmonocd_w5regular_">y</span> property to put it 100 pixels lower. We create a <span class="sans_thesansmonocd_w5regular_">Pane</span> layout, place the square inside it, and set it as the root node for a 300×300-pixel scene <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">To set the transitions, we create an instance of the <span class="sans_thesansmonocd_w5regular_">TranslateTransition</span> class named <span class="sans_thesansmonocd_w5regular_">transition</span> <span aria-label="annotation3" class="codeannotation">❸</span>. In the constructor, we set the duration of the animation to two seconds and assign the <span class="sans_thesansmonocd_w5regular_">square</span> object as the node to be animated. We then use <span class="sans_thesansmonocd_w5regular_">with (transition)</span> to set the properties controlling the movements of the square. We specify the starting x-position for animation by using the <span class="sans_thesansmonocd_w5regular_">fromX</span> property (we’ll move the square only from side to side) and the end position by using the <span class="sans_thesansmonocd_w5regular_">toX</span> property. For the latter, we use <span class="sans_thesansmonocd_w5regular_">pane .width - square.width</span> to ensure the square won’t move outside the scene’s boundaries. The transition will interpolate the value of the x-position of the square from the <span class="sans_thesansmonocd_w5regular_">fromX</span> value to the <span class="sans_thesansmonocd_w5regular_">toX</span> value over the duration of the animation. Since we set <span class="sans_thesansmonocd_w5regular_">cycleCount</span> to <span class="sans_thesansmonocd_w5regular_">Transition.INDEFINITE</span> and <span class="sans_thesansmonocd_w5regular_">isAutoReverse</span> to <span class="sans_thesansmonocd_w5regular_">true</span>, the transition will reverse direction when it ends and start interpolating back to the <span class="sans_thesansmonocd_w5regular_">fromX</span> value—it will continue repeating as long as the window remains open. Finally, we set the transition in motion by using its <span class="sans_thesansmonocd_w5regular_">play()</span> method <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="h1"><span id="sec28"/><span id="h2-59"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">When you run this code, you should see a red square initially positioned next to the left boundary of the scene. It should start moving toward the right boundary, then reverse its course once it hits the right boundary. This back-and-forth movement should continue until you close the window to terminate the program.</p>
<p class="headaexercise" id="pre-8"><span aria-label="118" epub:type="pagebreak" id="pg_118" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_15-n">Project 8: Animate a Bouncing Ball</span></p>
<p class="tni">The timeline and keyframe approach to animation offers exceptional versatility and is ideal for creating complex and precisely controlled animations. Each <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> object defines a specific point in time where you set the values of certain properties, while the <span class="sans_thesansmonocd_w5regular_">Timeline</span> class manages the progression between keyframes. In JavaFX, you can find two approaches to this animation method. One is to define the properties of each <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> object explicitly. The other is to set the properties of each <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> programmatically by using an <i class="calibre9">action event handler</i>, a block of code similar to a lambda expression. This block of code is called periodically and contains rules for updating the scene. In this project, we’ll look at examples of both methods.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="h1"><span id="sec29"/><span id="h2-60"/><span class="sans_futura_std_bold_condensed_oblique_">Setting Keyframes Explicitly</span></h4>
<p class="tni">In the first example, we’ll create an animated circle that grows and shrinks continuously. We’ll explicitly define the starting and ending <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> objects, representing the circle at its smallest and largest sizes. Then we’ll use the <span class="sans_thesansmonocd_w5regular_">Timeline</span> class to interpolate back and forth between the keyframes. Here’s the code:</p>
<pre class="calibre10"><code class="calibre11">// graphics-related imports
import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.layout.StackPane
import javafx.scene.paint.Color
import javafx.scene.shape.Circle
import javafx.stage.Stage

// animation-related imports
import javafx.animation.KeyFrame
import javafx.animation.KeyValue
import javafx.animation.Timeline
import javafx.util.Duration

class KeyframeAnimationExample : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title =
            "Animation Example: A Growing and Shrinking Circle"
        // Create a circle.
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val circle = Circle(50.0, Color.BLUE)

      <span aria-label="annotation2" class="code_codeannotation">❷</span> val root = StackPane(circle) // autocenters child node
        val scene = Scene(root, 600.0, 600.0)
        primaryStage.scene = scene
        primaryStage.show()

        // Create a Timeline for the animation.
        val timeline = Timeline()
        // Define keyframes.
<span aria-label="119" epub:type="pagebreak" id="pg_119" role="doc-pagebreak"/>        val startFrame = KeyFrame(
                         Duration.ZERO,
                         KeyValue(circle.radiusProperty(), 50.0))

        val endFrame = KeyFrame(
                       Duration.seconds(5.0),
                       KeyValue(circle.radiusProperty(), 250.0))

        // Add keyframes to the timeline.
      <span aria-label="annotation3" class="code_codeannotation">❸</span> timeline.keyFrames.addAll(startFrame, endFrame)

        // Set and play the timeline.
        with (timeline) {
            cycleCount = Timeline.INDEFINITE
            isAutoReverse = true
          <span aria-label="annotation4" class="code_codeannotation">❹</span> play()
        }
    }
}

fun main() {
    Application.launch(KeyframeAnimationExample::class.java)
}</code></pre>
<p class="tx">We create a blue <span class="sans_thesansmonocd_w5regular_">Circle</span> object with an initial radius of <span class="sans_thesansmonocd_w5regular_">50.0</span> pixels <span aria-label="annotation1" class="codeannotation">❶</span> and attach it to a <span class="sans_thesansmonocd_w5regular_">StackPane</span> <span aria-label="annotation2" class="codeannotation">❷</span>, which automatically centers the node it contains. We manage the animation through a <span class="sans_thesansmonocd_w5regular_">Timeline</span> and two <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> objects: <span class="sans_thesansmonocd_w5regular_">startFrame</span> and <span class="sans_thesansmonocd_w5regular_">endFrame</span>. For <span class="sans_thesansmonocd_w5regular_">startFrame</span>, we set the initial state of the circle’s radius property to <span class="sans_thesansmonocd_w5regular_">50.0</span> pixels at the start time of the animation (0 seconds). Notice how we set the radius through an instance of the <span class="sans_thesansmonocd_w5regular_">KeyValue</span> class, which we pass to the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> constructor. Any property of an object that should be animated between keyframes must be defined through a separate <span class="sans_thesansmonocd_w5regular_">KeyValue</span> object. The second keyframe, <span class="sans_thesansmonocd_w5regular_">endFrame</span>, sets the circle’s radius property to <span class="sans_thesansmonocd_w5regular_">250.0</span> pixels at the end time (five seconds) of the animation. We use the <span class="sans_thesansmonocd_w5regular_">keyFrames.addAll()</span> method to attach the two keyframes to the <span class="sans_thesansmonocd_w5regular_">Timeline</span> object <span aria-label="annotation3" class="codeannotation">❸</span>.</p>
<p class="tx">In the final code block, inside the <span class="sans_thesansmonocd_w5regular_">with</span> scoping function, we configure the animation to keep repeating by setting the <span class="sans_thesansmonocd_w5regular_">Timeline</span> object’s <span class="sans_thesansmonocd_w5regular_">cycleCount</span> property to <span class="sans_thesansmonocd_w5regular_">Timeline.INDEFINITE</span>, and we turn on autoreversing so that the circle will start shrinking once it’s grown to its maximum size. Then we initiate the animation by invoking the <span class="sans_thesansmonocd_w5regular_">play()</span> method <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
<p class="tx">If you run this code, an application window should open up where you’ll see a blue circle repeatedly grow and shrink, with each cycle lasting five seconds. The animation should continue indefinitely until you close the application window.</p>
<span aria-label="120" epub:type="pagebreak" id="pg_120" role="doc-pagebreak"/>
<aside aria-label="box-19" class="box">
<p class="boxtitle" id="box-19"><span class="sans_futura_std_bold_b_">FRAME RATE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">An animation is nothing more than a series of still images, or</span> <span class="sans_futura_std_book_oblique_">frames</span><span class="sans_futura_std_book_">, strung together in rapid succession to create the illusion of motion. The</span> <span class="sans_futura_std_book_oblique_">frame rate</span> <span class="sans_futura_std_book_">controls how many frames unfold each second. By default, JavaFX uses a frame rate of 60 frames per second, which as of this writing is the maximum possible rate. In the case of the growing and shrinking circle, where one cycle of growing or shrinking lasts five seconds, this means 5 × 60 = 300 frames will be created and displayed per cycle. JavaFX automatically generates the intermediate frames between the start and end times, using linear interpolation to calculate the radius of the circle for each frame.</span></p>
</aside>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="h1"><span id="sec30"/><span id="h2-61"/><span class="sans_futura_std_bold_condensed_oblique_">Using an Action Event Listener</span></h4>
<p class="tni">We’ll now explore a second example of creating animations with a timeline and keyframes. Unlike the previous example, where we specified distinct starting and ending keyframes for each animation cycle, we’ll rely on an action event listener block to execute the animation code. Specifically, we’ll create a red ball that continually traverses the scene, bouncing off the window boundaries. We’ll use the action event listener to set general rules for how the ball should move and when it should bounce. We’ll also encapsulate all the animation-related code within a dedicated method instead of putting it all in <span class="sans_thesansmonocd_w5regular_">start()</span>. This is a more structured and efficient coding method, which is particularly useful if we want to animate multiple balls by using the same method.</p>
<p class="tx">Here’s the code for animating a bouncing red ball:</p>
<pre class="calibre10"><code class="calibre11">// graphics-related imports
import javafx.application.Application
import javafx.scene.layout.Pane
import javafx.scene.Scene
import javafx.scene.paint.Color
import javafx.scene.shape.Circle
import javafx.stage.Stage

// animation-related imports
import javafx.animation.Animation
import javafx.animation.KeyFrame
import javafx.animation.Timeline
import javafx.util.Duration

class BouncingBall : Application() {
    override fun start(primaryStage: Stage) {
        primaryStage.title = "Bouncing Red Ball"
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val redBall = Circle(250.0, 200.0,
            30.0, Color.RED)
<span aria-label="121" epub:type="pagebreak" id="pg_121" role="doc-pagebreak"/>        val root = Pane(redBall)
        val scene = Scene(root, 500.0, 400.0)
        primaryStage.scene = scene
        primaryStage.show()

        // Call the bouncyBall method.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> bouncyBall(redBall, scene)
    }

    fun bouncyBall(redBall: Circle, scene: Scene) {
        // displacement parameters
        var dx = 2
        var dy = 2

        // Timeline-KeyFrame with ActionEvent
      <span aria-label="annotation3" class="code_codeannotation">❸</span> val tl = Timeline()
      <span aria-label="annotation4" class="code_codeannotation">❹</span> val moveBall = KeyFrame(
            Duration.seconds(0.015),
            {
                // Get min/max boundary coordinates.
                val xMin = redBall.boundsInParent.minX
                val xMax = redBall.boundsInParent.maxX
                val yMin = redBall.boundsInParent.minY
                val yMax = redBall.boundsInParent.maxY

                // Change direction if boundary is hit/crossed.
                if (xMin &lt; 0 || xMax &gt; scene.width) {
                    dx = - dx
                }
                if (yMin &lt; 0 || yMax &gt; scene.height) {
                    dy = - dy
                }
                // Continue to move.
                redBall.translateX += dx
                redBall.translateY += dy
            })

        with (tl) {
          <span aria-label="annotation5" class="code_codeannotation">❺</span> keyFrames.add(moveBall)
            cycleCount = Animation.INDEFINITE
          <span aria-label="annotation6" class="code_codeannotation">❻</span> play()
        }
    }
}

fun main() {
    Application.launch(BouncingBall::class.java)
}</code></pre>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">start()</span> method of the <span class="sans_thesansmonocd_w5regular_">BouncingBall</span> application class, we first instantiate a red ball (<span class="sans_thesansmonocd_w5regular_">redBall</span>) with a radius of 30 pixels, positioning it at coordinates (250, 200) relative to the top-left corner (0, 0) of the scene <span aria-label="annotation1" class="codeannotation">❶</span>. To prevent the ball from constantly occupying the center of the scene, we assign it to a <span class="sans_thesansmonocd_w5regular_">Pane</span> instead of a <span class="sans_thesansmonocd_w5regular_">StackPane</span>. The rest of the code up to <span aria-label="122" epub:type="pagebreak" id="pg_122" role="doc-pagebreak"/>calling the <span class="sans_thesansmonocd_w5regular_">show()</span> method of <span class="sans_thesansmonocd_w5regular_">primaryStage</span> is practically the same as in the previous example.</p>
<p class="tx">Once we’re done with setting the graphics part of the application, we call the custom <span class="sans_thesansmonocd_w5regular_">bouncyBall()</span> method, passing <span class="sans_thesansmonocd_w5regular_">redBall</span> and <span class="sans_thesansmonocd_w5regular_">scene</span> as its arguments <span aria-label="annotation2" class="codeannotation">❷</span>. This method encapsulates the process of setting up the <span class="sans_thesansmonocd_w5regular_">Timeline</span> and <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> objects and maneuvering the ball inside the scene. Inside the method, we first define two displacement parameters, <span class="sans_thesansmonocd_w5regular_">dx</span> and <span class="sans_thesansmonocd_w5regular_">dy</span>, which set the horizontal and vertical distance (in pixels) that the red ball should travel in each animation frame. We initialize these values to <span class="sans_thesansmonocd_w5regular_">2</span>, but if you modify them, the speed of the ball will change. For example, using <span class="sans_thesansmonocd_w5regular_">4</span> would double the ball’s speed, but this adjustment might introduce a perceptible jitter in the ball’s motion.</p>
<p class="tx">Next, we create <span class="sans_thesansmonocd_w5regular_">tl</span>, an instance of the <span class="sans_thesansmonocd_w5regular_">Timeline</span> class <span aria-label="annotation3" class="codeannotation">❸</span>, and define a single <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> object named <span class="sans_thesansmonocd_w5regular_">moveBall</span> <span aria-label="annotation4" class="codeannotation">❹</span>. We set the duration of the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> to <span class="sans_thesansmonocd_w5regular_">0.015</span> seconds (you can play with this value to get a sense of what happens when the duration is increased or decreased). The rest of the code block, surrounded by braces, is the action event handler block. This block, which we pass as the second argument to the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> constructor, is executed each time the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> is visited along the timeline.</p>
<p class="tx">The first few lines inside the action event handler block get the ball’s minimum and maximum coordinates in the x- and y-directions based on its current position. This is done by checking the corresponding coordinates of the parent container (a square, in this case) that holds the child (the circular ball). We then use these values to check if the ball has crossed the boundary of the scene during the last update of its position. For example, if <span class="sans_thesansmonocd_w5regular_">xMin &lt; 0</span> is <span class="sans_thesansmonocd_w5regular_">true</span>, the leftmost edge of the ball will be outside the left boundary of the scene. Similarly, if <span class="sans_thesansmonocd_w5regular_">xMax &gt; scene.width</span> is <span class="sans_thesansmonocd_w5regular_">true</span>, the rightmost edge of the ball will be beyond the right boundary of the scene. For any such situations, we reverse the ball’s direction of movement along the appropriate axis by negating the corresponding displacement parameter (<span class="sans_thesansmonocd_w5regular_">dx</span> or <span class="sans_thesansmonocd_w5regular_">dy</span>), which creates a bouncing effect. The last step inside the action event block is to update the ball’s position by adding the displacement parameters to the coordinates of the ball, which are accessed by using the <span class="sans_thesansmonocd_w5regular_">redBall</span> object’s <span class="sans_thesansmonocd_w5regular_">translateX</span> and <span class="sans_thesansmonocd_w5regular_">translateY</span> properties.</p>
<p class="tx">We conclude the <span class="sans_thesansmonocd_w5regular_">bouncyBall()</span> method by using the <span class="sans_thesansmonocd_w5regular_">with</span> scoping function to assign the <span class="sans_thesansmonocd_w5regular_">moveBall</span> keyframe to the timeline <span aria-label="annotation5" class="codeannotation">❺</span>, set the timeline to cycle indefinitely, and call the <span class="sans_thesansmonocd_w5regular_">play()</span> method <span aria-label="annotation6" class="codeannotation">❻</span> to start moving the ball on its bouncy path. Although we can’t show the dynamic motion of the ball on the static page of a book, <a href="chapter3.xhtml#fig3-9" class="calibre2">Figure 3-9</a> gives you a sense of what to expect when you run this code.</p>
<span aria-label="123" epub:type="pagebreak" id="pg_123" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img2" height="958" id="fig3-9" src="../images/Figure3-9.jpg" width="1053"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 3-9: Animating a bouncing red ball (shown here in gray)</span></p></figcaption>
</figure>
<p class="tx">If you run this code several times and carefully observe the motion of the ball, you’ll notice that it actually follows the exact same path every time. In other words, its path is predetermined. Can you explain why that’s the case? What could we do to make its path less predictable?</p>
<aside aria-label="box-20" class="box2">
<p class="boxtitle" id="box-20"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Enhance the bouncing ball code by adding new features. Here are some ideas to try:</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">Add more balls to the screen, each with a different color, speed, and starting location. You can vary these properties randomly by using Kotlin’s built-in random number generator function. For example, to generate a random integer between 0 and 10 (inclusive), you could use this code:</span></li>
</ul>
<pre class="calibre10"><code class="calibre11">val randInt = (0..10).random()</code></pre>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">Introduce collisions between the balls. That is, instead of the balls simply moving past each other, they should bounce off each other according to the rules of physics. This is a common feature in many games.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Introduce additional walls inside the canvas, and allow the balls to bounce off these walls as well.</span></li>
</ul>
</aside>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<span aria-label="124" epub:type="pagebreak" id="pg_124" role="doc-pagebreak"/>
<h3 class="h"><span id="sec31"/><span id="h1-33"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, we explored how to integrate JavaFX with Kotlin to create data visualizations. We covered fundamental JavaFX components such as <span class="sans_thesansmonocd_w5regular_">Stage</span>, <span class="sans_thesansmonocd_w5regular_">Scene</span>, and various layout containers and nodes. We also discussed using the <span class="sans_thesansmonocd_w5regular_">Canvas</span> class and its graphics context to create free-form drawings, and how to implement animations by using transitions or the <span class="sans_thesansmonocd_w5regular_">Timeline</span> and <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> classes. We practiced these concepts through projects drawing various charts, generating a seashell-like spiral pattern, and even animating a bouncing ball. Throughout the book, we’ll continue to draw on the basic JavaFX tools covered here to add visual components to our various projects.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h3 class="h"><span id="sec32"/><span id="h1-34"/><span class="sans_futura_std_bold_b_">Resources</span></h3>
<p class="reference">Balasubramanian, Anirudh. “Crash Course into JavaFX: The Best Way to Make GUI Apps.” (Free tutorial.) Accessed June 15, 2024. <i class="calibre9"><a href="https://www.udemy.com" class="calibre2">https://<wbr/>www<wbr/>.udemy<wbr/>.com</a></i>.</p>
<p class="reference">Dea, Carl, Gerrit Grunwald, Jos<span class="copyright_accent">é</span> Pereda, Sean Phillips, and Mark Heckler. <i class="calibre9">JavaFX 9 by Example</i>. 3rd ed. New York: Apress, 2017.</p>
<p class="reference">JavaFX. The Official Website for the Open JavaFX Project. Accessed June 15, 2024. <i class="calibre9"><a href="https://openjfx.io" class="calibre2">https://openjfx.io</a></i>.</p>
<p class="reference">Lowe, Doug. <i class="calibre9">JavaFX for Dummies</i>. Hoboken, NJ: John Wiley &amp; Sons, 2015.</p>
</section>
</section>
</div></body></html>