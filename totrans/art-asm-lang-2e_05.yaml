- en: Chapter 6. ARITHMETIC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 算术
- en: '![ARITHMETIC](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![算术运算](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: This chapter discusses arithmetic computation in assembly language. By the end
    of this chapter you should be able to translate arithmetic expressions and assignment
    statements from high-level languages like Pascal and C/C++ into 80x86 assembly
    language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论在汇编语言中的算术运算。到本章结束时，你应该能够将高级语言（如Pascal和C/C++）中的算术表达式和赋值语句翻译为80x86汇编语言。
- en: 6.1 80x86 Integer Arithmetic Instructions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 80x86整数算术指令
- en: Before describing how to encode arithmetic expressions in assembly language,
    it would be a good idea to first discuss the remaining arithmetic instructions
    in the 80x86 instruction set. Previous chapters have covered most of the arithmetic
    and logical instructions, so this section covers the few remaining instructions
    you'll need.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何在汇编语言中编码算术表达式之前，最好先讨论80x86指令集中剩余的算术指令。前几章已经介绍了大部分算术和逻辑指令，因此本节将介绍你所需要的少数剩余指令。
- en: 6.1.1 The mul and imul Instructions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.1 `mul`和`imul`指令
- en: The multiplication instructions provide you with another taste of irregularity
    in the 80x86's instruction set. Instructions like `add`, `sub`, and many others
    in the 80x86 instruction set support two operands, just like the `mov` instruction.
    Unfortunately, there weren't enough bits in the 80x86's opcode byte to support
    all instructions, so the 80x86 treats the `mul` (unsigned multiply) and `imul`
    (signed integer multiply) instructions as single-operand instructions, just like
    the `inc`, `dec`, and `neg` instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令为你提供了80x86指令集中的另一种不规则性。像`add`、`sub`等许多指令都支持两个操作数，就像`mov`指令一样。不幸的是，80x86的操作码字节没有足够的位数来支持所有指令，因此80x86将`mul`（无符号乘法）和`imul`（有符号整数乘法）指令视为单操作数指令，就像`inc`、`dec`和`neg`指令一样。
- en: Of course, multiplication *is* a two-operand function. To work around this fact,
    the 80x86 always assumes the accumulator (AL, AX, or EAX) is the destination operand.
    This irregularity makes using multiplication on the 80x86 a little more difficult
    than other instructions because one operand has to be in the accumulator. Intel
    adopted this unorthogonal approach because it felt that programmers would use
    multiplication far less often than instructions like `add` and `sub`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，乘法*是*一个双操作数的函数。为了绕过这一点，80x86总是假设累加器（AL、AX或EAX）是目标操作数。这一不规则性使得在80x86上使用乘法比其他指令稍微困难，因为一个操作数必须在累加器中。英特尔采用了这种非正交的方法，因为他们认为程序员使用乘法的频率远低于`add`和`sub`等指令。
- en: Another problem with the `mul` and `imul` instructions is that you cannot multiply
    the accumulator by a constant using these instructions. Intel quickly discovered
    the need to support multiplication by a constant and added the `intmul` instruction
    to overcome this problem. Nevertheless, you must be aware that the basic `mul`
    and `imul` instructions do not support the full range of operands as `intmul`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul`和`imul`指令的另一个问题是，你不能使用这些指令将累加器与常量相乘。英特尔很快发现了支持常量乘法的需求，并添加了`intmul`指令来解决这个问题。然而，你必须意识到，基本的`mul`和`imul`指令不支持与`intmul`一样的所有操作数范围。'
- en: 'There are two forms of the multiply instruction: unsigned multiplication (`mul`)
    and signed multiplication (`imul`). Unlike addition and subtraction, you need
    separate instructions for signed and unsigned operations.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令有两种形式：无符号乘法（`mul`）和有符号乘法（`imul`）。与加法和减法不同，你需要为有符号和无符号操作分别使用不同的指令。
- en: 'The multiply instructions take the following forms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令有以下几种形式：
- en: 'Unsigned multiplication:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号乘法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Signed (integer) multiplication:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号（整数）乘法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The returns values above are the strings these instructions return for use with
    instruction composition in HLA. (`i`)`mul`, available on all 80x86 processors,
    multiplies 8-, 16-, or 32-bit operands.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上面返回的值是这些指令在HLA中用于指令组合的字符串。(`i`)`mul`，适用于所有80x86处理器，用于乘法8位、16位或32位操作数。
- en: When multiplying two *n*-bit values, the result may require as many as 2 * *n*
    bits. Therefore, if the operand is an 8-bit quantity, the result could require
    16 bits. Likewise, a 16-bit operand produces a 32-bit result and a 32-bit operand
    requires 64 bits to hold the result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘以两个*n*位值时，结果可能需要多达2 * *n*位。因此，如果操作数是8位的，结果可能需要16位。同样，16位操作数会产生32位结果，32位操作数则需要64位来存储结果。
- en: The (`i`)`mul` instruction, with an 8-bit operand, multiplies AL by the operand
    and leaves the 16-bit product in AX. So
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (`i`)`mul` 指令，使用 8 位操作数时，会将 AL 与操作数相乘，并将 16 位乘积保存在 AX 中。因此
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: computes
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`*` represents an unsigned multiplication for `mul` and a signed multiplication
    for `imul`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 表示 `mul` 的无符号乘法和 `imul` 的有符号乘法。'
- en: If you specify a 16-bit operand, then `mul` and `imul` compute
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定 16 位操作数，则 `mul` 和 `imul` 计算如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`*` has the same meanings as above, and `dx:ax` means that DX contains the
    H.O. word of the 32-bit result and AX contains the L.O. word of the 32-bit result.
    If you''re wondering why Intel didn''t put the 32-bit result in EAX, just note
    that Intel introduced the `mul` and `imul` instructions in the earliest 80x86
    processors, before the advent of 32-bit registers in the 80386 CPU.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 的含义与上述相同，`dx:ax` 表示 DX 包含 32 位结果的高字（H.O.），AX 包含 32 位结果的低字（L.O.）。如果你在疑惑为何英特尔没有将
    32 位结果放入 EAX 中，请注意，英特尔在最早期的 80x86 处理器中引入了 `mul` 和 `imul` 指令，在 80386 CPU 引入 32
    位寄存器之前。'
- en: 'If you specify a 32-bit operand, then `mul` and `imul` compute the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定 32 位操作数，则 `mul` 和 `imul` 计算如下：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`*` has the same meanings as above, and `edx:eax` means that EDX contains the
    H.O. double word of the 64-bit result and EAX contains the L.O. double word of
    the 64-bit result.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 的含义与上述相同，`edx:eax` 表示 EDX 包含 64 位结果的高字（H.O.），EAX 包含 64 位结果的低字（L.O.）。'
- en: If an 8×8-, 16×16-, or 32×32-bit product requires more than 8, 16, or 32 bits
    (respectively), the `mul` and `imul` instructions set the carry and overflow flags.
    `mul` and `imul` scramble the sign and zero flags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 8×8 位、16×16 位或 32×32 位的乘积需要超过 8、16 或 32 位（分别），则 `mul` 和 `imul` 指令会设置进位标志和溢出标志。`mul`
    和 `imul` 会扰乱符号标志和零标志。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Especially note that the sign and zero flags do not contain meaningful values
    after the execution of these two instructions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是，在执行这两条指令后，符号标志和零标志不包含有意义的值。
- en: 'To help reduce some of the syntax irregularities with the use of the `mul`
    and `imul` instructions, HLA provides an extended syntax that allows the following
    two-operand forms:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少使用 `mul` 和 `imul` 指令时的一些语法不规范，HLA 提供了一种扩展语法，允许使用以下两操作数形式：
- en: 'Unsigned multiplication:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号乘法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Signed (integer) multiplication:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号（整数）乘法：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two-operand forms let you specify the (L.O.) destination register as the
    second operand. By specifying the destination register you can make your programs
    easier to read. Note that just because HLA allows two operands here, you can't
    specify an arbitrary register. The destination operand must always be AL, AX,
    or EAX, depending on the source operand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两操作数形式让你可以指定（低字）目标寄存器作为第二操作数。通过指定目标寄存器，你可以使程序更易读。请注意，尽管 HLA 允许在这里使用两个操作数，但你不能指定任意寄存器。目标操作数必须始终是
    AL、AX 或 EAX，具体取决于源操作数。
- en: HLA provides a form that lets you specify a constant. The 80x86 doesn't actually
    support a `mul` or `imul` instruction that has a constant operand. HLA will take
    the constant you specify and create a variable in a read-only segment in memory
    and initialize that variable with this value. Then HLA converts the instruction
    to the (`i`)`mul`( *`memory`* ); instruction. Note that when you specify a constant
    as the source operand, the instruction requires two operands (because HLA uses
    the second operand to determine whether the multiplication is 8, 16, or 32 bits).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了一种形式，可以让你指定常量。80x86 实际上不支持带有常量操作数的 `mul` 或 `imul` 指令。HLA 会将你指定的常量存储在内存的只读段中，并用该值初始化该变量。然后
    HLA 将指令转换为 (`i`)`mul`（*`memory`*）；指令。请注意，当你指定常量作为源操作数时，指令需要两个操作数（因为 HLA 使用第二个操作数来确定乘法是
    8 位、16 位还是 32 位）。
- en: 'You''ll use the `mul` and `imul` instructions quite a lot when you learn about
    extended-precision arithmetic in [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC").
    Unless you''re doing multiprecision work, however, you''ll probably just want
    to use the `intmul` instruction in place of the `mul` or `imul` because it is
    more general. However, `intmul` is not a complete replacement for these two instructions.
    Besides the number of operands, there are several differences between the `intmul`
    and the `mul`/`imul` instructions. The following rules apply specifically to the
    `intmul` instruction:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习扩展精度算术时，你会经常使用 `mul` 和 `imul` 指令，详见 [第 8 章](ch08.html "第 8 章：高级算术")。不过，除非你在进行多精度运算，否则你可能更倾向于用
    `intmul` 指令来替代 `mul` 或 `imul`，因为它更为通用。然而，`intmul` 并不能完全替代这两条指令。除了操作数的数量外，`intmul`
    和 `mul`/`imul` 指令之间还有几个差异。以下规则专门适用于 `intmul` 指令：
- en: There isn't an 8×8-bit `intmul` instruction available.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并没有可用的 8×8 位 `intmul` 指令。
- en: The `intmul` instruction does not produce a 2*×n*-bit result. That is, a 16×16-bit
    multiply produces a 16-bit result. Likewise, a 32×32-bit multiply produces a 32-bit
    result. These instructions set the carry and overflow flags if the result does
    not fit into the destination register.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intmul` 指令不会产生 2*×n* 位的结果。也就是说，16×16 位的乘法会产生 16 位的结果。同样，32×32 位的乘法会产生 32 位的结果。如果结果不能适配目标寄存器，这些指令会设置进位标志和溢出标志。'
- en: 6.1.2 The div and idiv Instructions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.2 div 和 idiv 指令
- en: 'The 80x86 divide instructions perform a 64/32-bit division, a 32/16-bit division,
    or a 16/8-bit division. These instructions take the following forms:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 除法指令执行 64/32 位除法、32/16 位除法或 16/8 位除法。这些指令有以下几种形式：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `div` instruction is an unsigned division operation. If the operand is an
    8-bit operand, `div` divides the AX register by the operand leaving the quotient
    in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, then
    the `div` instruction divides the 32-bit quantity in `dx:ax` by the operand, leaving
    the quotient in AX and the remainder in DX. With 32-bit operands `div` divides
    the 64-bit value in `edx:eax` by the operand, leaving the quotient in EAX and
    the remainder in EDX.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`div` 指令是无符号除法操作。如果操作数是 8 位操作数，`div` 将 AX 寄存器除以该操作数，商存储在 AL 寄存器中，余数（模）存储在 AH
    寄存器中。如果操作数是 16 位数，则 `div` 指令将 `dx:ax` 中的 32 位数除以操作数，商存储在 AX 中，余数存储在 DX 中。对于 32
    位操作数，`div` 将 `edx:eax` 中的 64 位值除以操作数，商存储在 EAX 中，余数存储在 EDX 中。'
- en: Like `mul` and `imul`, HLA provides special syntax to allow the use of constant
    operands even though the low-level machine instructions don't actually support
    them. See the previous list of `div` instructions for these extensions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `mul` 和 `imul` 一样，HLA 提供了特殊语法，允许使用常量操作数，即使底层机器指令实际上不支持它们。有关这些扩展的更多信息，请参阅之前列出的
    `div` 指令。
- en: The `idiv` instruction computes a signed quotient and remainder. The syntax
    for the `idiv` instruction is identical to `div` (except for the use of the `idiv`
    mnemonic), though creating signed operands for `idiv` may require a different
    sequence of instructions prior to executing `idiv` than for `div`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`idiv` 指令计算有符号商和余数。`idiv` 指令的语法与 `div` 相同（除了使用了 `idiv` 作为助记符），尽管为 `idiv` 创建有符号操作数可能需要在执行
    `idiv` 之前使用不同的指令序列，而不是 `div`。'
- en: You cannot, on the 80x86, simply divide one unsigned 8-bit value by another.
    If the denominator is an 8-bit value, the numerator must be a 16-bit value. If
    you need to divide one unsigned 8-bit value by another, you must zero extend the
    numerator to 16 bits. You can accomplish this by loading the numerator into the
    AL register and then moving 0 into the AH register. Then you can divide AX by
    the denominator operand to produce the correct result. *Failing to zero extend
    AL before executing* *`div`* *may cause the 80x86 to produce incorrect results!*
    When you need to divide two 16-bit unsigned values, you must zero extend the AX
    register (which contains the numerator) into the DX register. To do this, just
    load 0 into the DX register. If you need to divide one 32-bit value by another,
    you must zero extend the EAX register into EDX (by loading a 0 into EDX) before
    the division.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 80x86 架构上，你不能简单地将一个无符号 8 位值除以另一个。如果除数是一个 8 位值，分子必须是一个 16 位值。如果你需要将一个无符号 8
    位值除以另一个，你必须将分子扩展为 16 位。你可以通过将分子加载到 AL 寄存器中，然后将 0 移入 AH 寄存器来实现这一点。然后，你可以将 AX 除以除数操作数，得到正确的结果。*在执行*
    *`div`* *之前没有将 AL 扩展为 0 可能导致 80x86 产生错误的结果！* 当你需要除以两个 16 位无符号值时，你必须将包含分子的 AX 寄存器零扩展到
    DX 寄存器。为此，只需将 0 加载到 DX 寄存器中。如果你需要将一个 32 位值除以另一个，你必须在除法操作之前将 EAX 寄存器零扩展到 EDX（通过将
    0 加载到 EDX）。
- en: When dealing with signed integer values, you will need to sign extend AL into
    AX, AX into DX, or EAX into EDX before executing `idiv`. To do so, use the `cbw`,
    `cwd`, `cdq`, or `movsx` instruction. If the H.O. byte, word, or double word does
    not already contain significant bits, then you must sign extend the value in the
    accumulator (AL/AX/EAX) before doing the `idiv` operation. Failure to do so may
    produce incorrect results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理有符号整数值时，你需要在执行 `idiv` 之前，将 AL 扩展到 AX，AX 扩展到 DX，或 EAX 扩展到 EDX。为此，可以使用 `cbw`、`cwd`、`cdq`
    或 `movsx` 指令。如果高位字节、字或双字中没有包含有效位，则必须在执行 `idiv` 操作之前对累加器（AL/AX/EAX）中的值进行符号扩展。未能执行此操作可能会导致错误的结果。
- en: 'There is one other issue with the 80x86''s divide instructions: You can get
    a fatal error when using this instruction. First, of course, you can attempt to
    divide a value by 0\. Another problem is that the quotient may be too large to
    fit into the EAX, AX, or AL register. For example, the 16/8-bit division $8000/2
    produces the quotient $4000 with a remainder of 0\. $4000 will not fit into 8
    bits. If this happens, or you attempt to divide by 0, the 80x86 will generate
    an `ex.DivisionError` exception or integer overflow error (`ex.IntoInstr`). This
    usually means your program will display the appropriate dialog and abort. If this
    happens to you, chances are you didn''t sign or zero extend your numerator before
    executing the division operation. Because this error may cause your program to
    crash, you should be very careful about the values you select when using division.
    Of course, you can use the `try..endtry` block with `ex.DivisionError` and `ex.IntoInstr`
    to trap this problem in your program.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 80x86 除法指令的问题：你可能会遇到致命错误。首先，当然，你可以尝试将一个值除以 0。另一个问题是，商可能太大，无法适应 EAX、AX 或
    AL 寄存器。例如，16/8 位除法 $8000/2 产生商 $4000，余数为 0。$4000 无法适应 8 位。如果发生这种情况，或者你尝试除以 0，80x86
    将生成 `ex.DivisionError` 异常或整数溢出错误（`ex.IntoInstr`）。这通常意味着你的程序会显示适当的对话框并中止。如果发生这种情况，可能是你在执行除法操作之前没有对分子进行符号扩展或零扩展。由于此错误可能导致程序崩溃，因此在使用除法时应非常小心选择值。当然，你可以使用
    `try..endtry` 块与 `ex.DivisionError` 和 `ex.IntoInstr` 来捕获程序中的这个问题。
- en: The 80x86 leaves the carry, overflow, sign, and zero flags undefined after a
    division operation. Therefore, you cannot test for problems after a division operation
    by checking the flag bits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 在执行除法操作后，会使进位标志、溢出标志、符号标志和零标志未定义。因此，你不能通过检查标志位来检测除法操作后的问题。
- en: 'The 80x86 does not provide a separate instruction to compute the remainder
    of one number divided by another. The `div` and `idiv` instructions automatically
    compute the remainder at the same time they compute the quotient. HLA, however,
    provides mnemonics (instructions) for the `mod` and `imod` instructions. These
    special HLA instructions compile into the exact same code as their `div` and `idiv`
    counterparts. The only difference is the returns value for the instruction (because
    these instructions return the remainder in a different location than the quotient).
    The `mod` and `imod` instructions that HLA supports are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 并没有提供一个独立的指令来计算一个数除以另一个数的余数。`div` 和 `idiv` 指令在计算商的同时也会自动计算余数。然而，HLA 提供了
    `mod` 和 `imod` 指令的助记符（指令）。这些特殊的 HLA 指令编译成与 `div` 和 `idiv` 相同的代码。唯一的区别是返回值的位置不同（因为这些指令将余数返回到与商不同的位置）。HLA
    支持的 `mod` 和 `imod` 指令如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 6.1.3 The cmp Instruction
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.3 cmp 指令
- en: 'The `cmp` (compare) instruction is identical to the `sub` instruction with
    one crucial semantic difference—it does not retain the difference it computes;
    it just sets the condition code bits in the flags register. The syntax for the
    `cmp` instruction is similar to that of `sub` (though the operands are reversed
    so it reads better); the generic form is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`（比较）指令与 `sub` 指令基本相同，唯一的语义区别是：它不会保留计算出的差值，而只是设置标志寄存器中的条件码位。`cmp` 指令的语法与
    `sub` 指令相似（虽然操作数的顺序被调整过，以便更易理解）；其通用形式如下：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This instruction computes *`LeftOperand`* `-` *`RightOperand`* (note the reversal
    from `sub`). The specific forms are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算 *`LeftOperand`* `-` *`RightOperand`*（注意与 `sub` 的区别）。具体形式如下：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `cmp` instruction updates the 80x86's flags according to the result of the
    subtraction operation (*`LeftOperand`* `-` *`RightOperand`*). The 80x86 sets the
    flags in an appropriate fashion so that we can read this instruction as "compare
    *`LeftOperand`* to *`RightOperand`*." You can test the result of the comparison
    by checking the appropriate flags in the flags register using the conditional
    set instructions (see [6.1.4 The setcc Instructions](ch06.html#the_set_cc_instructions
    "6.1.4 The setcc Instructions")) or the conditional jump instructions (see [Chapter 7](ch07.html
    "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令根据减法操作 (*`LeftOperand`* `-` *`RightOperand`*) 的结果更新 80x86 的标志位。80x86
    会以适当的方式设置标志位，以便我们可以将此指令理解为“将 *`LeftOperand`* 与 *`RightOperand`* 进行比较。”你可以通过检查标志寄存器中的相关标志位，使用条件设置指令（见
    [6.1.4 setcc 指令](ch06.html#the_set_cc_instructions "6.1.4 setcc 指令")）或条件跳转指令（见
    [第 7 章](ch07.html "第 7 章. 低级控制结构")）来测试比较的结果。'
- en: 'Probably the first place to start when exploring the `cmp` instruction is to
    look at exactly how the `cmp` instruction affects the flags. Consider the following
    `cmp` instruction:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `cmp` 指令时，最好的起点可能是查看 `cmp` 指令如何具体影响标志位。考虑以下 `cmp` 指令：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This instruction performs the computation AX - BX and sets the flags depending
    upon the result of the computation. The flags are set as follows (also see [Table 6-1](ch06.html#condition_code_settings_after_cmp
    "Table 6-1. Condition Code Settings After cmp")):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令执行 AX - BX 的计算，并根据计算结果设置标志位。标志位设置如下（另见 [表 6-1](ch06.html#condition_code_settings_after_cmp
    "表 6-1. cmp 后的条件码设置")）：
- en: '**`Z`**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Z`**'
- en: The zero flag is set if and only if AX = BX. This is the only time AX - BX produces
    a zero result. Hence, you can use the zero flag to test for equality or inequality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 AX = BX 时，零标志才会被设置。这是 AX - BX 结果为零的唯一情况。因此，你可以通过零标志来测试相等或不相等。
- en: '**`S`**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**`S`**'
- en: The sign flag is set to 1 if the result is negative. At first glance, you might
    think that this flag would be set if AX is less than BX, but this isn't always
    the case. If AX = $7FFF and BX = −1 ($FFFF), then subtracting AX from BX produces
    $8000, which is negative (and so the sign flag will be set). So, for signed comparisons
    anyway, the sign flag doesn't contain the proper status. For unsigned operands,
    consider AX = $FFFF and BX = 1\. AX is greater than BX but their difference is
    $FFFE, which is still negative. As it turns out, the sign flag and the overflow
    flag, taken together, can be used for comparing two signed values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果为负数，则设置符号标志为1。乍一看，你可能认为当AX小于BX时会设置该标志，但实际上并非总是如此。如果AX = $7FFF，BX = −1 ($FFFF)，那么从BX减去AX的结果是$8000，负数（因此符号标志会被设置）。所以对于有符号比较来说，符号标志并没有提供正确的状态。对于无符号操作数，考虑AX
    = $FFFF和BX = 1。AX大于BX，但它们的差值是$FFFE，仍然是负数。事实证明，符号标志和溢出标志可以一起用于比较两个有符号值。
- en: '**`O`**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**`O`**'
- en: The overflow flag is set after a `cmp` operation if the difference of AX and
    BX produced an overflow or underflow. As mentioned above, the sign flag and the
    overflow flag are both used when performing signed comparisons.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AX和BX的差值产生了溢出或下溢，则在`cmp`操作后设置溢出标志。如上所述，符号标志和溢出标志在进行有符号比较时都被使用。
- en: '**`C`**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**`C`**'
- en: The carry flag is set after a `cmp` operation if subtracting BX from AX requires
    a borrow. This occurs only when AX is less than BX where AX and BX are both unsigned
    values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从AX中减去BX需要借位，则在`cmp`操作后设置进位标志。这仅在AX小于BX且AX和BX都是无符号值时发生。
- en: 'Given that the `cmp` instruction sets the flags in this fashion, you can test
    the comparison of the two operands with the following flags:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cmp`指令以这种方式设置标志，你可以通过以下标志来测试两个操作数的比较：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Table 6-1. Condition Code Settings After `cmp`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1. `cmp`后的条件码设置
- en: '| Unsigned Operands | Signed Operands |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 无符号操作数 | 有符号操作数 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Z: Equality/inequality | Z: Equality/inequality |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Z: 相等/不相等 | Z: 相等/不相等 |'
- en: '| C: Left < Right (C = 1)Left >= Right (C = 0) | C: No meaning |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| C: 左边 < 右边 (C = 1) 左边 >= 右边 (C = 0) | C: 无意义 |'
- en: '| S: No meaning | S: See discussion in this section |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| S: 无意义 | S: 请参阅本节讨论 |'
- en: '| O: No meaning | O: See discussion in this section |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| O: 无意义 | O: 请参阅本节讨论 |'
- en: 'For signed comparisons, the S (sign) and O (overflow) flags, taken together,
    have the following meaning:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号比较，S（符号）和O（溢出）标志一起有以下含义：
- en: If [(S = 0) and (O = 1)] or [(S = 1) and (O = 0)] then Left < Right for a signed
    comparison.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[(S = 0)且(O = 1)]或[(S = 1)且(O = 0)]，则在有符号比较中左边 < 右边。
- en: If [(S = 0) and (O = 0)] or [(S = 1) and (O = 1)] then Left >= Right for a signed
    comparison.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[(S = 0)且(O = 0)]或[(S = 1)且(O = 1)]，则在有符号比较中左边 >= 右边。
- en: Note that (S `xor` O) is 1 if the left operand is less than the right operand.
    Conversely, (S `xor` O) is 0 if the left operand is greater or equal to the right
    operand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当左操作数小于右操作数时，（S `xor` O）为1。相反，当左操作数大于或等于右操作数时，（S `xor` O）为0。
- en: 'To understand why these flags are set in this manner, consider the following
    examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些标志为什么以这种方式设置，请考虑以下示例：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember, the `cmp` operation is really a subtraction; therefore, the first
    example above computes (−1) - (−2), which is (+1). The result is positive and
    an overflow did not occur, so both the S and O flags are 0\. Because (S `xor`
    O) is 0, `Left` is greater than or equal to `Right`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`cmp`操作实际上是减法；因此，上面的第一个例子计算（−1）-（−2），结果是（+1）。结果为正且没有发生溢出，因此S和O标志均为0。因为（S
    `xor` O）为0，所以`Left`大于或等于`Right`。
- en: In the second example, the `cmp` instruction would compute (−32,768) - (+1),
    which is (−32,769). Because a 16-bit signed integer cannot represent this value,
    the value wraps around to $7FFF (+32,767) and sets the overflow flag. The result
    is positive (at least as a 16-bit value), so the CPU clears the sign flag. (S
    `xor` O) is 1 here, so `Left` is less than `Right`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，`cmp`指令将计算（−32,768）-（+1），结果是（−32,769）。由于16位有符号整数无法表示该值，因此该值会环绕到$7FFF（+32,767）并设置溢出标志。结果是正数（至少作为16位值），所以CPU会清除符号标志。这里（S
    `xor` O）为1，因此`Left`小于`Right`。
- en: In the third example above, `cmp` computes (−2) - (−1), which produces (−1).
    No overflow occurred, so the O flag is 0, the result is negative, so the sign
    flag is 1\. Because (S `xor` O) is 1, `Left` is less than `Right`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的第三个例子中，`cmp`计算（−2）-（−1），结果是（−1）。没有发生溢出，因此O标志为0，结果为负数，因此符号标志为1。因为（S `xor`
    O）为1，所以`Left`小于`Right`。
- en: In the fourth (and final) example, `cmp` computes (+32,767) - (−1). This produces
    (+32,768), setting the overflow flag. Furthermore, the value wraps around to $8000
    (−32,768), so the sign flag is set as well. Because (S `xor` O) is 0, `Left` is
    greater than or equal to `Right`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个（也是最后一个）示例中，`cmp`计算（+32,767）-（−1）。这产生了（+32,768），设置了溢出标志。此外，值会环绕回$8000（−32,768），因此符号标志也被设置。因为（S
    `xor` O）等于0，所以`Left`大于或等于`Right`。
- en: You may test the flags after a `cmp` instruction using HLA high-level control
    statements and the boolean flag expressions (e.g., `@c`, `@nc`, `@z`, `@nz`, `@o`,
    `@no`, `@s`, `@ns`, and so on). [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") lists the boolean expressions
    HLA supports that let you check various conditions after a compare instruction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cmp`指令后使用HLA高级控制语句和布尔标志表达式（例如`@c`，`@nc`，`@z`，`@nz`，`@o`，`@no`，`@s`，`@ns`等）测试标志。[表6-2](ch06.html#hla_condition_code_boolean_expressions
    "表6-2. HLA条件码布尔表达式")列出了HLA支持的布尔表达式，允许你在比较指令后检查各种条件。
- en: Table 6-2. HLA Condition Code Boolean Expressions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2. HLA条件码布尔表达式
- en: '| HLA Syntax | Condition | Comment |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| HLA语法 | 条件 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@c` | Carry set | Carry flag is set if the first operand is less than the
    second operand (unsigned). Same condition as `@b` and `@nae`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `@c` | 进位设置 | 如果第一个操作数小于第二个操作数（无符号），则进位标志设置。与`@b`和`@nae`相同条件。 |'
- en: '| `@nc` | Carry clear (no carry) | Carry flag is clear if the first operand
    is greater than or equal to the second (using an unsigned comparison). Same condition
    as `@nb` and `@ae`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `@nc` | 进位清除（无进位） | 如果第一个操作数大于或等于第二个操作数（使用无符号比较），则进位标志清除。与`@nb`和`@ae`相同条件。
    |'
- en: '| `@z` | Zero flag set | Zero flag is set if the first operand equals the second
    operand. Same condition as `@e`. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `@z` | 零标志设置 | 如果第一个操作数等于第二个操作数，则零标志设置。与`@e`相同条件。 |'
- en: '| `@nz` | Zero flag clear (no zero) | Zero flag is clear if the first operand
    is not equal to the second. Same condition as `@ne`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `@nz` | 零标志清除（无零） | 如果第一个操作数不等于第二个操作数，则零标志清除。与`@ne`相同条件。 |'
- en: '| `@o` | Overflow flag set | This flag is set if there was a signed arithmetic
    overflow as a result of the comparison operation. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `@o` | 溢出标志设置 | 如果比较操作导致符号算术溢出，则此标志设置。 |'
- en: '| `@no` | Overflow flag clear (no overflow) | The overflow flag is clear if
    there was no signed arithmetic overflow during the compare operation. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `@no` | 溢出标志清除（无溢出） | 如果在比较操作过程中没有发生符号算术溢出，则溢出标志清除。 |'
- en: '| `@s` | Sign flag set | The sign flag is set if the result of the compare
    (subtraction) produces a negative result. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `@s` | 符号标志设置 | 如果比较（减法）结果为负，则符号标志被设置。 |'
- en: '| `@ns` | Sign flag clear (no sign) | The sign flag is clear if the compare
    operation produces a nonnegative (zero or positive) result. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `@ns` | 符号标志清除（无符号） | 如果比较操作产生非负（零或正）结果，则符号标志清除。 |'
- en: '| `@a` | Above (unsigned greater than) | The `@a` condition checks the carry
    and zero flags to see if `@c` = 0 and `@z` = 0\. This condition exists if the
    first (unsigned) operand is greater than the second (unsigned) operand. This is
    the same condition as `@nbe`. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `@a` | 大于（无符号大于） | `@a`条件检查进位和零标志，查看`@c` = 0且`@z` = 0。此条件存在于第一个（无符号）操作数大于第二个（无符号）操作数时。这与`@nbe`相同。
    |'
- en: '| `@na` | Not above | The `@na` condition checks to see if the carry flag is
    set (`@c`) or the zero flag is set (`@z`). This is equivalent to an unsigned "not
    greater than" condition. Note that this condition is the same as `@be`. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `@na` | 不大于 | `@na`条件检查进位标志是否被设置（`@c`）或零标志是否被设置（`@z`）。这等同于无符号的“非大于”条件。请注意，这个条件与`@be`相同。
    |'
- en: '| `@ae` | Above or equal (unsigned greater than or equal) | The `@ae` condition
    is true if the first operand is greater than or equal to the second using an unsigned
    comparison. This is equivalent to the `@nb` and `@nc` conditions. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `@ae` | 大于或等于（无符号大于等于） | 如果第一个操作数使用无符号比较大于或等于第二个操作数，则`@ae`条件为真。这等同于`@nb`和`@nc`条件。
    |'
- en: '| `@nae` | Not above or equal | The `@nae` condition is true if the first operand
    is not greater than or equal to the second using an unsigned comparison. This
    is equivalent to the `@b` and `@c` conditions. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `@nae` | 非大于或等于 | 如果第一个操作数使用无符号比较不大于或等于第二个操作数，则`@nae`条件为真。这等同于`@b`和`@c`条件。
    |'
- en: '| `@b` | Below (unsigned less than) | The `@b` condition is true if the first
    operand is less than the second using an unsigned comparison. This is equivalent
    to the `@nae` and `@c` conditions. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `@b` | 小于（无符号小于） | 如果第一个操作数使用无符号比较小于第二个操作数，则`@b`条件为真。这相当于`@nae`和`@c`条件。 |'
- en: '| `@nb` | Not below | This condition is true if the first operand is not less
    than the second using an unsigned comparison. This condition is equivalent to
    the `@nc` and `@ae` conditions. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `@nb` | 不小于 | 如果第一个操作数使用无符号比较不小于第二个操作数，则此条件为真。此条件等同于`@nc`和`@ae`条件。 |'
- en: '| `@be` | Below or equal (unsigned less than or equal) | The `@be` condition
    is true when the first operand is less than or equal to the second using an unsigned
    comparison. This condition is equivalent to `@na`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `@be` | 小于或等于（无符号小于或等于） | 如果第一个操作数使用无符号比较小于或等于第二个操作数，则`@be`条件为真。此条件等同于`@na`。
    |'
- en: '| `@nbe` | Not below or equal | The `@be` condition is true when the first
    operand is not less than or equal to the second using an unsigned comparison.
    This condition is equivalent to `@a`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `@nbe` | 不小于或等于 | 如果第一个操作数使用无符号比较不小于或等于第二个操作数，则`@be`条件为真。此条件等同于`@a`。 |'
- en: '| `@g` | Greater (signed greater than) | The `@g` condition is true if the
    first operand is greater than the second using a signed comparison. This is equivalent
    to the `@nle` condition. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `@g` | 大于（有符号大于） | 如果第一个操作数使用有符号比较大于第二个操作数，则`@g`条件为真。这相当于`@nle`条件。 |'
- en: '| `@ng` | Not greater | The `@ng` condition is true if the first operand is
    not greater than the second using a signed comparison. This is equivalent to the
    `@le` condition. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `@ng` | 不大于 | 如果第一个操作数使用有符号比较不大于第二个操作数，则`@ng`条件为真。这相当于`@le`条件。 |'
- en: '| `@ge` | Greater or equal (signed greater than or equal) | The `@ge` condition
    is true if the first operand is greater than or equal to the second using a signed
    comparison. This is equivalent to the `@nl` condition. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@ge` | 大于或等于（有符号大于或等于） | 如果第一个操作数使用有符号比较大于或等于第二个操作数，则`@ge`条件为真。这相当于`@nl`条件。
    |'
- en: '| `@nge` | Not greater or equal | The `@nge` condition is true if the first
    operand is not greater than or equal to the second using a signed comparison.
    This is equivalent to the `@l` condition. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `@nge` | 不大于或等于 | 如果第一个操作数使用有符号比较不大于或等于第二个操作数，则`@nge`条件为真。这相当于`@l`条件。 |'
- en: '| `@l` | Less than (signed less than) | The `@l` condition is true if the first
    operand is less than the second using a signed comparison. This is equivalent
    to the `@nge` condition. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `@l` | 小于（有符号小于） | 如果第一个操作数使用有符号比较小于第二个操作数，则`@l`条件为真。这相当于`@nge`条件。 |'
- en: '| `@nl` | Not less than | The `@ng` condition is true if the first operand
    is not less than the second using a signed comparison. This is equivalent to the
    `@ge` condition. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `@nl` | 不小于 | 如果第一个操作数使用有符号比较不小于第二个操作数，则`@ng`条件为真。这相当于`@ge`条件。 |'
- en: '| `@le` | Less than or equal (signed) | The `@le` condition is true if the
    first operand is less than or equal to the second using a signed comparison. This
    is equivalent to the `@ng` condition. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `@le` | 小于或等于（有符号） | 如果第一个操作数使用有符号比较小于或等于第二个操作数，则`@le`条件为真。这相当于`@ng`条件。 |'
- en: '| `@nle` | Not less than or equal | The `@nle` condition is true if the first
    operand is not less than or equal to the second using a signed comparison. This
    is equivalent to the `@g` condition. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `@nle` | 不小于或等于 | 如果第一个操作数使用有符号比较不小于或等于第二个操作数，则`@nle`条件为真。这相当于`@g`条件。 |'
- en: '| `@e` | Equal (signed or unsigned) | This condition is true if the first operand
    equals the second. The `@e` condition is equivalent to the `@z` condition. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `@e` | 等于（有符号或无符号） | 如果第一个操作数等于第二个操作数，则此条件为真。`@e`条件等同于`@z`条件。 |'
- en: '| `@ne` | Not equal (signed or unsigned) | `@ne` is true if the first operand
    does not equal the second. This condition is equivalent to `@nz`. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `@ne` | 不等于（有符号或无符号） | 如果第一个操作数不等于第二个操作数，则`@ne`为真。此条件等同于`@nz`。 |'
- en: 'You may use the boolean conditions appearing in [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") within an `if` statement,
    `while` statement, or any other HLA high-level control statement that allows boolean
    expressions. Immediately after the execution of a `cmp` instruction, you would
    typically use one of these conditions in an `if` statement. For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`if`语句、`while`语句或任何其他允许布尔表达式的HLA高级控制语句中使用出现在[表6-2](ch06.html#hla_condition_code_boolean_expressions
    "表6-2。HLA条件代码布尔表达式")中的布尔条件。在执行完`cmp`指令后，通常会在`if`语句中使用这些条件。例如：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the example above is equivalent to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的示例等同于以下内容：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 6.1.4 The set*cc* Instructions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.4 `set*cc*` 指令
- en: 'The *set on condition* (or `set`*`cc`*) instructions set a single-byte operand
    (register or memory) to 0 or 1 depending on the values in the flags register.
    The general formats for the `set`*`cc`* instructions are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件设置*（或`set`*`cc`*）指令根据标志寄存器中的值，将一个字节的操作数（寄存器或内存）设置为0或1。`set`*`cc`*指令的一般格式如下：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`set`*`cc`* represents a mnemonic appearing in [Table 6-3](ch06.html#setcc_instructions_that_test_flags
    "Table 6-3. setcc Instructions That Test Flags"), [Table 6-4](ch06.html#setcc_instructions_for_unsigned_comparis
    "Table 6-4. setcc Instructions for Unsigned Comparisons"), and [Table 6-5](ch06.html#setcc_instructions_for_signed_comparison
    "Table 6-5. setcc Instructions for Signed Comparisons"). These instructions store
    a 0 into the corresponding operand if the condition is false, and they store a
    1 into the 8-bit operand if the condition is true.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`*`cc`*表示一个助记符，出现在[表6-3](ch06.html#setcc_instructions_that_test_flags "表6-3。测试标志的setcc指令")、[表6-4](ch06.html#setcc_instructions_for_unsigned_comparis
    "表6-4。无符号比较的setcc指令")和[表6-5](ch06.html#setcc_instructions_for_signed_comparison
    "表6-5。带符号比较的setcc指令")中。这些指令在条件为假时将0存入相应的操作数，如果条件为真，则将1存入8位操作数中。'
- en: Table 6-3. `set`*`cc`* Instructions That Test Flags
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3。`set`*`cc`* 指令测试标志
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `setc` | Set if carry | Carry = 1 | Same as `setb`, `setnae` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `setc` | 如果进位，则设置 | 进位 = 1 | 与`setb`、`setnae`相同 |'
- en: '| `setnc` | Set if no carry | Carry = 0 | Same as `setnb`, `setae` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `setnc` | 如果没有进位，则设置 | 进位 = 0 | 与`setnb`、`setae`相同 |'
- en: '| `setz` | Set if zero | Zero = 1 | Same as `sete` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `setz` | 如果为零，则设置 | 零 = 1 | 与`sete`相同 |'
- en: '| `setnz` | Set if not zero | Zero = 0 | Same as `setne` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `setnz` | 如果不为零，则设置 | 零 = 0 | 与`setne`相同 |'
- en: '| `sets` | Set if sign | Sign = 1 |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `sets` | 如果为符号，则设置 | 符号 = 1 |   |'
- en: '| `setns` | Set if no sign | Sign = 0 |   |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `setns` | 如果没有符号，则设置 | 符号 = 0 |   |'
- en: '| `seto` | Set if overflow | Overflow = 1 |   |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `seto` | 如果溢出，则设置 | 溢出 = 1 |   |'
- en: '| `setno` | Set if no overflow | Overflow = 0 |   |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `setno` | 如果没有溢出，则设置 | 溢出 = 0 |   |'
- en: '| `setp` | Set if parity | Parity = 1 | Same as `setpe` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `setp` | 如果为奇偶性，则设置 | 奇偶性 = 1 | 与`setpe`相同 |'
- en: '| `setpe` | Set if parity even | Parity = 1 | Same as `setp` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `setpe` | 如果为偶数奇偶性，则设置 | 奇偶性 = 1 | 与`setp`相同 |'
- en: '| `setnp` | Set if no parity | Parity = 0 | Same as `setpo` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `setnp` | 如果没有奇偶性，则设置 | 奇偶性 = 0 | 与`setpo`相同 |'
- en: '| `setpo` | Set if parity odd | Parity = 0 | Same as `setnp` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `setpo` | 如果奇偶性为奇数，则设置 | 奇偶性 = 0 | 与`setnp`相同 |'
- en: The `set`*`cc`* instructions above simply test the flags without any other meaning
    attached to the operation. You could, for example, use `setc` to check the carry
    flag after a shift, rotate, bit test, or arithmetic operation. You might notice
    the `setp`, `setpe`, and `setnp` instructions above. They check the parity flag.
    These instructions appear here for completeness, but this text will not spend
    too much time discussing the parity flag (its use is somewhat obsolete).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`set`*`cc`*指令仅仅测试标志，而没有附加其他含义。例如，你可以在执行移位、旋转、位测试或算术操作后使用`setc`来检查进位标志。你可能注意到上面有`setp`、`setpe`和`setnp`指令。它们检查奇偶性标志。这些指令在此列出以完整性为目的，但本文不会花太多时间讨论奇偶性标志（它的使用有些过时）。
- en: The `cmp` instruction works synergistically with the setcc instructions. Immediately
    after a `cmp` operation the processor flags provide information concerning the
    relative values of those operands. They allow you to see if one operand is less
    than, equal to, or greater than the other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`指令与setcc指令协同工作。在执行`cmp`操作后，处理器的标志会提供关于操作数相对值的信息。它们可以帮助你判断一个操作数是否小于、等于或大于另一个操作数。'
- en: Two additional groups of `set`*`cc`* instructions are very useful after a `cmp`
    operation. The first group deals with the result of an unsigned comparison; the
    second group deals with the result of a signed comparison.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两组额外的 `set`*`cc`* 指令在 `cmp` 操作后非常有用。第一组处理无符号比较的结果；第二组处理有符号比较的结果。
- en: Table 6-4. `set`*`cc`* Instructions for Unsigned Comparisons
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4. `set`*`cc`* 无符号比较指令
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `seta` | Set if above (>) | Carry = 0, Zero = 0 | Same as `setnbe` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `seta` | 如果高于（>）则设置 | Carry = 0，Zero = 0 | 与`setnbe`相同 |'
- en: '| `setnbe` | Set if not below or equal (not <=) | Carry = 0, Zero = 0 | Same
    as `seta` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `setnbe` | 如果不低于或等于（不 <=）则设置 | Carry = 0，Zero = 0 | 与`seta`相同 |'
- en: '| `setae` | Set if above or equal (>=) | Carry = 0 | Same as `setnc`, `setnb`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `setae` | 如果高于或等于（>=）则设置 | Carry = 0 | 与`setnc`、`setnb`相同 |'
- en: '| `setnb` | Set if not below (not <) | Carry = 0 | Same as `setnc`, `setae`
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `setnb` | 如果不低于（不 <）则设置 | Carry = 0 | 与`setnc`、`setae`相同 |'
- en: '| `setb` | Set if below (<) | Carry = 1 | Same as `setc`, `setna` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `setb` | 如果低于（<）则设置 | Carry = 1 | 与`setc`、`setna`相同 |'
- en: '| `setnae` | Set if not above or equal (not >=) | Carry = 1 | Same as `setc`,
    `setb` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `setnae` | 如果不高于或等于（不 >=）则设置 | Carry = 1 | 与`setc`、`setb`相同 |'
- en: '| `setbe` | Set if below or equal (<=) | Carry = 1 or Zero = 1 | Same as `setna`
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `setbe` | 如果低于或等于（<=）则设置 | Carry = 1 或 Zero = 1 | 与`setna`相同 |'
- en: '| `setna` | Set if not above (not >) | Carry = 1 or Zero = 1 | Same as `setbe`
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `setna` | 如果不高于（不 >）则设置 | Carry = 1 或 Zero = 1 | 与`setbe`相同 |'
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `sete` | 如果相等则设置（=） | Zero = 1 | 与`setz`相同 |'
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `setne` | 如果不相等则设置（¦） | Zero = 0 | 与`setnz`相同 |'
- en: '[Table 6-5](ch06.html#setcc_instructions_for_signed_comparison "Table 6-5. setcc
    Instructions for Signed Comparisons") lists the corresponding signed comparisons.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-5](ch06.html#setcc_instructions_for_signed_comparison "表 6-5. setcc 有符号比较指令")
    列出了相应的有符号比较。'
- en: Table 6-5. `set`*`cc`* Instructions for Signed Comparisons
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-5. `set`*`cc`* 有符号比较指令
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `setg` | Set if greater (>) | Sign = Overflow and Zero = 0 | Same as `setnle`
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `setg` | 如果大于（>）则设置 | Sign = Overflow 且 Zero = 0 | 与`setnle`相同 |'
- en: '| `setnle` | Set if not less than or equal (not <=) | Sign = Overflow or Zero
    = 0 | Same as `setg` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `setnle` | 如果不小于或等于（不 <=）则设置 | Sign = Overflow 或 Zero = 0 | 与`setg`相同 |'
- en: '| `setge` | Set if greater than or equal (>=) | Sign = Overflow | Same as `setnl`
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `setge` | 如果大于或等于（>=）则设置 | Sign = Overflow | 与`setnl`相同 |'
- en: '| `setnl` | Set if not less than (not <) | Sign = Overflow | Same as `setge`
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `setnl` | 如果不小于（不 <）则设置 | Sign = Overflow | 与`setge`相同 |'
- en: '| `setl` | Set if less than (<) | Sign ¦ Overflow | Same as `setnge` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `setl` | 如果小于（<）则设置 | Sign ¦ Overflow | 与`setnge`相同 |'
- en: '| `setnge` | Set if not greater or equal (not >=) | Sign ¦ Overflow | Same
    as `setl` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `setnge` | 如果不大于或等于（不 >=）则设置 | Sign ¦ Overflow | 与`setl`相同 |'
- en: '| `setl` | Set if less than or equal (<=) | Sign ¦ Overflow or Zero = 1 | Same
    as `setng` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `setl` | 如果小于或等于（<=）则设置 | Sign ¦ Overflow 或 Zero = 1 | 与`setng`相同 |'
- en: '| `setng` | Set if not greater than (not >) | Sign ¦ Overflow or Zero = 1 |
    Same as `setle` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `setng` | 如果不大于（不 >）则设置 | Sign ¦ Overflow 或 Zero = 1 | 与`setle`相同 |'
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `sete` | 如果相等则设置（=） | Zero = 1 | 与`setz`相同 |'
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `setne` | 如果不相等则设置（¦） | Zero = 0 | 与`setnz`相同 |'
- en: Note the correspondence between the `set`*`cc`* instructions and the HLA flag
    conditions that may appear in boolean instructions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `set`*`cc`* 指令与可能出现在布尔指令中的 HLA 标志条件之间的对应关系。
- en: 'The `set`*`cc`* instructions are particularly valuable because they can convert
    the result of a comparison to a boolean value (false/true or 0/1). This is especially
    important when translating statements from a high-level language like Pascal or
    C/C++ into assembly language. The following example shows how to use these instructions
    in this manner:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`*`cc`* 指令特别有价值，因为它们可以将比较结果转换为布尔值（假/真或 0/1）。这在将高级语言如 Pascal 或 C/C++ 转换为汇编语言时尤其重要。以下示例展示了如何以这种方式使用这些指令：'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because the `set`*`cc`* instructions always produce 0 or 1, you can use the
    results with the `and` and `or` instructions to compute complex boolean values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `set`*`cc`* 指令总是产生 0 或 1，你可以使用 `and` 和 `or` 指令与这些结果一起计算复杂的布尔值：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 6.1.5 The test Instruction
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.5 测试指令
- en: 'The 80x86 `test` instruction is to the `and` instruction what the `cmp` instruction
    is to `sub`. That is, the `test` instruction computes the logical `and` of its
    two operands and sets the condition code flags based on the result; it does not,
    however, store the result of the logical and back into the destination operand.
    The syntax for the `test` instruction is similar to `and`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 的 `test` 指令就像 `cmp` 指令之于 `sub` 指令。也就是说，`test` 指令计算其两个操作数的逻辑 `and`，并根据结果设置条件码标志；然而，它不会将逻辑
    `and` 的结果存储回目标操作数。`test` 指令的语法类似于 `and`：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `test` instruction sets the zero flag if the result of the logical `and`
    operation is 0\. It sets the sign flag if the H.O. bit of the result contains
    a 1\. The `test` instruction always clears the carry and overflow flags.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令在逻辑 `and` 运算结果为 0 时会设置零标志。如果结果的高位比特为 1，则会设置符号标志。`test` 指令始终清除进位标志和溢出标志。'
- en: The primary use of the `test` instruction is to check to see if an individual
    bit contains a 0 or a 1\. Consider the instruction `test( 1, al);`. This instruction
    logically `and`s AL with the value 1; if bit 0 of AL contains 0, the result will
    be 0 (setting the zero flag) because all the other bits in the constant 1 are
    0\. Conversely, if bit 1 of AL contains 1, then the result is not 0, so `test`
    clears the zero flag. Therefore, you can test the zero flag after this `test`
    instruction to see if bit 0 contains a 0 or a 1 (e.g., using a `setz` or `setnz`
    instruction).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令的主要用途是检查单个比特是否为 0 或 1。考虑指令 `test( 1, al);`。这条指令将 AL 与值 1 进行逻辑 `and`
    运算；如果 AL 的第 0 位为 0，则结果为 0（设置零标志），因为常数 1 中的其他比特都是 0。相反，如果 AL 的第 1 位为 1，则结果不为 0，因此
    `test` 会清除零标志。因此，你可以在这条 `test` 指令之后测试零标志，查看第 0 位是 0 还是 1（例如，使用 `setz` 或 `setnz`
    指令）。'
- en: The `test` instruction can also check to see if all the bits in a specified
    set of bits contain 0\. The instruction `test( $F, al);` sets the zero flag if
    and only if the L.O. 4 bits of AL all contain 0.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令还可以检查指定的比特集中的所有比特是否为 0。指令 `test( $F, al);` 仅在 AL 的最低 4 位都为 0 时，才会设置零标志。'
- en: 'One very important use of the `test` instruction is to check whether a register
    contains 0\. The instruction `test(` *`reg`*`,` *`reg`* `);` where both operands
    are the same register will logically `and` that register with itself. If the register
    contains 0, then the result is 0 and the CPU will set the zero flag. However,
    if the register contains a nonzero value, logically `and`ing that value with itself
    produces that same nonzero value, so the CPU clears the zero flag. Therefore,
    you can check the zero flag immediately after the execution of this instruction
    (e.g., using the `setz` or `setnz` instructions or the `@z` and `@nz` boolean
    conditions) to see if the register contains 0\. Here are some examples:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 指令的一个非常重要的用途是检查一个寄存器是否包含 0。指令 `test(` *`reg`*`,` *`reg`* `);`，其中两个操作数是相同的寄存器，将该寄存器与自身做逻辑
    `and` 运算。如果寄存器的值为 0，则结果为 0，CPU 将设置零标志。但是，如果寄存器包含非零值，将该值与自身做逻辑 `and` 运算将得到相同的非零值，CPU
    会清除零标志。因此，你可以在执行此指令后立即检查零标志（例如，使用 `setz` 或 `setnz` 指令，或者使用 `@z` 和 `@nz` 布尔条件）来判断寄存器是否为
    0。以下是一些示例：'
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 6.2 Arithmetic Expressions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 算术表达式
- en: 'Probably the biggest shock to beginners facing assembly language for the very
    first time is the lack of familiar arithmetic expressions. Arithmetic expressions,
    in most high-level languages, look similar to their algebraic equivalents. For
    example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次接触汇编语言的初学者来说，最大的震惊可能是缺乏熟悉的算术表达式。在大多数高级语言中，算术表达式看起来与它们的代数等价物类似。例如：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In assembly language, you''ll need several statements to accomplish this same
    task:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你需要几个语句来完成相同的任务：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Obviously the HLL version is much easier to type, read, and understand. This
    point, more than any other, is responsible for scaring people away from assembly
    language. Although there is a lot of typing involved, converting an arithmetic
    expression into assembly language isn't difficult at all. By attacking the problem
    in steps, the same way you would solve the problem by hand, you can easily break
    down any arithmetic expression into an equivalent sequence of assembly language
    statements. By learning how to convert such expressions to assembly language in
    three steps, you'll discover there is little difficulty to this task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，高级语言版本要输入、阅读和理解起来都要容易得多。这个事实，胜过其他任何原因，导致了人们远离汇编语言。尽管涉及很多输入，但将一个算术表达式转换成汇编语言并不难。通过分步解决问题，就像你手动解题一样，你可以轻松地将任何算术表达式分解为等效的汇编语言指令。通过学习如何将这种表达式分三步转换成汇编语言，你会发现这个任务几乎没有难度。
- en: 6.2.1 Simple Assignments
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.1 简单赋值
- en: 'The easiest expressions to convert to assembly language are simple assignments.
    Simple assignments copy a single value into a variable and take one of two forms:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编语言最简单的表达式是简单赋值。简单赋值将一个单一的值复制到变量中，具有两种形式之一：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: or
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Converting the first form to assembly language is simple—just use the assembly
    language statement:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一种形式转换为汇编语言很简单——只需使用汇编语言指令：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `mov` instruction copies the constant into the variable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mov`指令将常量复制到变量中。
- en: 'The second assignment above is slightly more complicated because the 80x86
    doesn''t provide a memory-to-memory `mov` instruction. Therefore, to copy one
    memory variable into another, you must move the data through a register. By convention
    (and for slight efficiency reasons), most programmers tend to favor AL/AX/EAX
    for this purpose. For example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述第二个赋值稍微复杂一些，因为80x86并没有提供内存到内存的`mov`指令。因此，要将一个内存变量复制到另一个内存变量，必须通过寄存器传递数据。根据惯例（并出于轻微的效率考虑），大多数程序员倾向于使用AL/AX/EAX作为这个目的。例如：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: becomes
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is assuming, of course, that *`var1`* and *`var2`* are 32-bit variables.
    Use AL if they are 8-bit variables; use AX if they are 16-bit variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是假设*`var1`*和*`var2`*是32位变量。如果它们是8位变量，使用AL；如果是16位变量，使用AX。
- en: Of course, if you're already using AL, AX, or EAX for something else, one of
    the other registers will suffice. Regardless, you will generally use a register
    to transfer one memory location to another.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你已经用AL、AX或EAX做了其他事情，使用其他寄存器也可以。无论如何，通常会使用寄存器将一个内存位置转移到另一个内存位置。
- en: 6.2.2 Simple Expressions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.2 简单表达式
- en: 'The next level of complexity is a simple expression. A simple expression takes
    the following form:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层复杂性是一个简单表达式。一个简单的表达式具有以下形式：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*`var1`* is a variable, *`term1`* and *`term2`* are variables or constants,
    and *`op`* is some arithmetic operator (addition, subtraction, multiplication,
    and so on). Most expressions take this form. It should come as no surprise, then,
    that the 80x86 architecture was optimized for just this type of expression.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*`var1`*是一个变量，*`term1`*和*`term2`*是变量或常量，*`op`*是某个算术运算符（加法、减法、乘法等等）。大多数表达式都采用这种形式。由此看来，80x86架构是为这种类型的表达式优化的，这一点应该不足为奇。'
- en: 'A typical conversion for this type of expression takes the following form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表达式的典型转换形式如下：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*`op`* is the mnemonic that corresponds to the specified operation (e.g., +
    is `add`, `−` is `sub`, etc.).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*`op`*是与指定操作相对应的助记符（例如，+是`add`，−是`sub`，等等）。'
- en: Note that the simple expression *`var1`* `:=` *`const1 op const2`*`;` is easily
    handled with a compile-time expression and a single `mov` instruction. For example,
    to compute *`var1`* `:= 5+3;`, just use the single instruction `mov( 5+3`, *`var1`*
    `);`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，简单的表达式*`var1`* `:=` *`const1 op const2`*`;`可以通过编译时表达式和单个`mov`指令轻松处理。例如，要计算*`var1`*
    `:= 5+3;`，只需使用单条指令`mov( 5+3`, *`var1`* `);`。
- en: There are a few inconsistencies you need to be aware of. When dealing with the
    (`i`)`mul`, (`i`)`div`, and (`i`)`mod` instructions on the 80x86, you must use
    the AL/AX/EAX and DX/EDX registers. You cannot use arbitrary registers as you
    can with other operations. Also, don't forget the sign extension instructions
    if you're performing a division operation and you're dividing one 16/32-bit number
    by another. Finally, don't forget that some instructions may cause overflow. You
    may want to check for an overflow (or underflow) condition after an arithmetic
    operation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不一致之处需要注意。当处理 80x86 上的（`i`）`mul`、（`i`）`div` 和（`i`）`mod` 指令时，你必须使用 AL/AX/EAX
    和 DX/EDX 寄存器。你不能像其他操作那样使用任意寄存器。此外，如果你正在执行除法操作，并且是在将一个 16/32 位数字除以另一个时，别忘了使用符号扩展指令。最后，别忘了某些指令可能会引发溢出。你可能需要在算术操作之后检查是否发生溢出（或下溢）。
- en: 'Here are some examples of common simple expressions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见简单表达式的例子：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Certain unary operations also qualify as simple expressions, producing additional
    inconsistencies in the general rule. A good example of a unary operation is negation.
    In a high-level language, negation takes one of two possible forms:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 某些一元运算也可以作为简单表达式，导致一般规则中的额外不一致性。一个好的例子是一元运算是取反。在高级语言中，取反有两种可能的形式：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: or
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that *`var`* `:= -`*`constant`* is really a simple assignment, not a simple
    expression. You can specify a negative constant as an operand to the `mov` instruction:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*`var`* `:= -`*`constant`* 实际上是一个简单的赋值，而不是简单表达式。你可以将负常量作为操作数传递给 `mov` 指令：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To handle *`var1`* `= -`*`var1`*`;`, use this single assembly language statement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 *`var1`* `= -`*`var1`*`；`，使用以下单条汇编语言语句：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If two different variables are involved, then use the following.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及两个不同的变量，则使用以下方式。
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6.2.3 Complex Expressions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.3 复杂表达式
- en: A complex expression is any arithmetic expression involving more than two terms
    and one operator. Such expressions are commonly found in programs written in a
    high-level language. Complex expressions may include parentheses to override operator
    precedence, function calls, array accesses, and so on. While the conversion of
    many complex expressions to assembly language is fairly straightforward, other
    conversions require some effort. This section outlines the rules you use to convert
    such expressions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂表达式是指涉及多个项和一个运算符的任何算术表达式。这类表达式通常出现在用高级语言编写的程序中。复杂表达式可能包含括号，用于覆盖运算符优先级，函数调用，数组访问等等。虽然许多复杂表达式转换为汇编语言相对直接，但其他转换则需要一些努力。本节概述了将这类表达式转换的规则。
- en: 'A complex expression that is easy to convert to assembly language is one that
    involves three terms and two operators. For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容易转换为汇编语言的复杂表达式是涉及三个项和两个运算符的表达式。例如：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Clearly the straightforward assembly language conversion of this statement
    will require two `sub` instructions. However, even with an expression as simple
    as this one, the conversion is not trivial. There are actually *two ways* to convert
    this from the statement above into assembly language:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，直接将这个语句转换为汇编语言将需要两个 `sub` 指令。然而，即使是像这样的简单表达式，转换也不是小事。实际上，从上面的语句转换到汇编语言有*两种方法*：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second conversion, because it is shorter, looks better. However, it produces
    an incorrect result (assuming Pascal-like semantics for the original statement).
    *Associativity* is the problem. The second sequence above computes `w := w - (y
    - z)`, which is not the same as `w := (w - y) - z`. How we place the parentheses
    around the subexpressions can affect the result. Note that if you are interested
    in a shorter form, you can use the following sequence:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种转换方法由于较短，看起来更好。然而，它会产生一个错误的结果（假设原语句采用类似 Pascal 的语义）。*结合性*是问题所在。上述第二个表达式计算的是
    `w := w - (y - z)`，这与 `w := (w - y) - z` 不相同。我们如何在子表达式周围放置括号会影响结果。请注意，如果你更关注简洁的形式，可以使用以下序列：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This computes `w := w - (y + z)`. This is equivalent to `w := (w - y) - z`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这会计算 `w := w - (y + z)`。这等同于 `w := (w - y) - z`。
- en: '*Precedence* is another issue. Consider this Pascal expression:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先级*是另一个问题。考虑这个 Pascal 表达式：'
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once again there are two ways we can evaluate this expression:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过两种方式来计算这个表达式：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: or
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By now, you're probably thinking that this text is crazy. Everyone knows the
    correct way to evaluate these expressions is by the second form. However, you're
    wrong to think that way. The APL programming language, for example, evaluates
    expressions solely from right to left and does not give one operator precedence
    over another. Which way is "correct" depends entirely on how you define precedence
    in your arithmetic system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，你可能会觉得这段文字有点疯狂。大家都知道，正确的求值方式是第二种形式。然而，你认为那样是错误的。比如APL编程语言，它是从右到左进行表达式求值的，并且不会让某个运算符优先于另一个运算符。到底哪种方式是“正确”的，完全取决于你如何在你的算术系统中定义优先级。
- en: Most high-level languages use a fixed set of precedence rules to describe the
    order of evaluation in an expression involving two or more different operators.
    Such programming languages usually compute multiplication and division before
    addition and subtraction. Those that support exponentiation (for example, FORTRAN
    and BASIC) usually compute that before multiplication and division. These rules
    are intuitive because almost everyone learns them before high school. Consider
    the expression
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言使用一组固定的优先级规则来描述涉及两个或多个不同运算符的表达式中的求值顺序。这类编程语言通常会在加法和减法之前计算乘法和除法。那些支持指数运算的语言（例如FORTRAN和BASIC）通常会在乘法和除法之前计算指数运算。这些规则是直观的，因为几乎每个人在上高中之前就学过它们。考虑以下表达式
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If *`op1`* takes precedence over *`op2`*, then this evaluates to `(x` *`op1`*
    `y)` *`op2`* `z`; otherwise, if *`op2`* takes precedence over *`op1`*, then this
    evaluates to `x` *`op1`* `(y` *`op2`* `z)`. Depending upon the operators and operands
    involved, these two computations could produce different results. When converting
    an expression of this form into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`op1`*的优先级高于*`op2`*，那么这将计算为`(x` *`op1`* `y)` *`op2`* `z`；否则，如果*`op2`*的优先级高于*`op1`*，则将计算为`x`
    *`op1`* `(y` *`op2`* `z)`。根据涉及的运算符和操作数，这两种计算可能会产生不同的结果。当将这种形式的表达式转换为汇编语言时，必须确保首先计算优先级最高的子表达式。以下示例演示了这一技术：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If two operators appearing within an expression have the same precedence, then
    you determine the order of evaluation using *associativity* rules. Most operators
    are left associative, meaning that they evaluate from left to right. Addition,
    subtraction, multiplication, and division are all left associative. A *right-associative*
    operator evaluates from right to left. The exponentiation operator in FORTRAN
    and BASIC is a good example of a right-associative operator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在表达式中出现的两个运算符具有相同的优先级，那么你需要使用*结合性*规则来确定求值顺序。大多数运算符是左结合的，意味着它们从左到右进行求值。加法、减法、乘法和除法都是左结合的。一个*右结合*运算符则从右到左进行求值。例如，FORTRAN
    和 BASIC 中的指数运算符就是一个典型的右结合运算符：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级和结合性规则决定了求值顺序。间接地，这些规则告诉你在表达式中放置括号的位置，以确定求值顺序。当然，你可以始终使用括号来覆盖默认的优先级和结合性。然而，最重要的是，你的汇编代码必须在正确的顺序中完成某些操作，才能正确计算给定表达式的值。以下示例演示了这一原则：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There is one exception to the associativity rule. If an expression involves
    multiplication and division, it is generally better to perform the multiplication
    first. For example, given an expression of the form
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结合性规则，有一个例外。如果一个表达式涉及乘法和除法，通常最好先进行乘法。例如，给定一个类似以下形式的表达式
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: it is usually better to compute `x * z` and then divide the result by `y` rather
    than divide `x` by `y` and multiply the quotient by `z`. There are two reasons
    why this approach is better. First, remember that the `imul` instruction always
    produces a 64-bit result (assuming 32-bit operands). By doing the multiplication
    first, you automatically *sign extend* the product into the EDX register so you
    do not have to sign extend EAX prior to the division. A second reason for doing
    the multiplication first is to increase the accuracy of the computation. Remember,
    (integer) division often produces an inexact result. For example, if you compute
    5/2 you will get the value 2, not 2.5\. Computing (5 / 2) * 3 produces 6\. However,
    if you compute `(5 * 3) / 2` you get the value 7, which is a little closer to
    the real quotient (7.5). Therefore, if you encounter an expression of the form
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好先计算`x * z`，然后将结果除以`y`，而不是先将`x`除以`y`，再将商乘以`z`。这种方法更好的原因有两个。首先，记住`imul`指令总是生成一个64位的结果（假设操作数是32位）。通过先进行乘法，你会自动将乘积*符号扩展*到EDX寄存器中，这样就不需要在除法前对EAX进行符号扩展。第二个理由是先进行乘法可以提高计算的精确度。记住，（整数）除法往往会产生不准确的结果。例如，如果你计算5/2，你会得到值2，而不是2.5。计算(5
    / 2) * 3得到6。但如果你计算`(5 * 3) / 2`，你会得到值7，这更接近真实的商（7.5）。因此，如果你遇到以下形式的表达式：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'you can usually convert it to the following assembly code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以将其转换为以下汇编代码：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, if the algorithm you''re encoding depends on the truncation effect
    of the division operation, you cannot use this trick to improve the algorithm.
    Moral of the story: Always make sure you fully understand any expression you are
    converting to assembly language. Obviously, if the semantics dictate that you
    must perform the division first, then do so.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你正在编码的算法依赖于除法操作的截断效应，你就不能使用这种技巧来改善算法。这个故事的寓意是：在将任何表达式转换为汇编语言之前，一定要完全理解它的含义。显然，如果语义要求你必须先进行除法操作，那就按照要求做。
- en: 'Consider the following Pascal statement:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下的Pascal语句：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is similar to a previous example except it uses subtraction rather than
    addition. Because subtraction is not commutative, you cannot compute `y * x` and
    then subtract `x` from this result. This tends to complicate the conversion a
    tiny amount. Rather than use a straightforward multiplication-and-addition sequence,
    you''ll have to load `x` into a register, multiply `y` and `x` leaving their product
    in a different register, and then subtract this product from `x`. For example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的例子类似，只不过它使用了减法而不是加法。由于减法不是交换律的，你不能先计算`y * x`然后从这个结果中减去`x`。这会稍微增加转换的复杂度。你需要先将`x`加载到寄存器中，计算`y`与`x`的乘积，并将它们的乘积保存在另一个寄存器中，然后从`x`中减去这个乘积。例如：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is a trivial example that demonstrates the need for *temporary variables*
    in an expression. This code uses the EBX register to temporarily hold a copy of
    `x` until it computes the product of `y` and `x`. As your expressions increase
    in complexity, the need for temporaries grows. Consider the following Pascal statement:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，演示了在表达式中使用*临时变量*的必要性。这段代码使用了EBX寄存器暂时保存`x`的副本，直到计算出`y`和`x`的乘积。随着表达式复杂度的增加，临时变量的需求也会增加。考虑以下的Pascal语句：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Following the normal rules of algebraic evaluation, you compute the subexpressions
    inside the parentheses (that is, the two subexpressions with the highest precedence)
    first and set their values aside. When you''ve computed the values for both subexpressions,
    you can compute their sum. One way to deal with a complex expression like this
    one is to reduce it to a sequence of simple expressions whose results wind up
    in temporary variables. For example, you can convert the single expression above
    into the following sequence:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代数求值的正常规则，你首先计算括号内的子表达式（即具有最高优先级的两个子表达式），并将它们的值暂存。当你计算出两个子表达式的值后，你可以计算它们的和。处理像这样的复杂表达式的一种方式是将其简化为一系列简单的表达式，这些简单表达式的结果最终存储在临时变量中。例如，你可以将上面的单一表达式转换为以下的序列：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Because converting simple expressions to assembly language is quite easy, it''s
    now a snap to compute the former complex expression in assembly. The code is:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因为将简单的表达式转换为汇编语言相对容易，现在你可以轻松地将之前复杂的表达式转换为汇编代码。代码如下：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Of course, this code is grossly inefficient, and it requires that you declare
    a couple of temporary variables in your data segment. However, it is very easy
    to optimize this code by keeping temporary variables, as much as possible, in
    80x86 registers. By using 80x86 registers to hold the temporary results, this
    code becomes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码极为低效，并且要求你在数据段中声明几个临时变量。然而，通过尽量将临时变量保存在 80x86 寄存器中，这段代码是非常容易优化的。使用 80x86
    寄存器来存储临时结果后，这段代码变成了：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s yet another example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This can be converted to a set of four simple expressions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以转换为四个简单的表达式：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can convert these four simple expressions into the following assembly language
    statements:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这四个简单的表达式转换为以下汇编语言语句：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The most important thing to keep in mind is that you should attempt to keep
    temporary values in registers. Remember, accessing an 80x86 register is much more
    efficient than accessing a memory location. Use memory locations to hold temporaries
    only if you've run out of registers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，你应该尽量将临时值保存在寄存器中。记住，访问 80x86 寄存器比访问内存位置高效得多。只有在寄存器用完的情况下，才使用内存位置来保存临时变量。
- en: Ultimately, converting a complex expression to assembly language is little different
    than solving the expression by hand. Instead of actually computing the result
    at each stage of the computation, you simply write the assembly code that computes
    the result. Because you were probably taught to compute only one operation at
    a time, this means that manual computation works on "simple expressions" that
    exist in a complex expression. Of course, converting those simple expressions
    to assembly is fairly simple. Therefore, anyone who can solve a complex expression
    by hand can convert it to assembly language following the rules for simple expressions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，将复杂的表达式转换为汇编语言与手动求解表达式没什么不同。你不是在每个计算阶段实际计算结果，而是编写计算结果的汇编代码。因为你可能被教导一次只计算一个操作，这意味着手动计算是在复杂表达式中处理“简单表达式”。当然，将这些简单表达式转换成汇编语言是相当简单的。因此，任何能够手动求解复杂表达式的人，都可以按照简单表达式的规则将其转换为汇编语言。
- en: 6.2.4 Commutative Operators
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.4 交换律运算符
- en: 'If *`op`* represents some operator, that operator is *commutative* if the following
    relationship is always true:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *`op`* 表示某个运算符，且该运算符是 *交换律* 的话，那么以下关系总是成立：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you saw in the previous section, commutative operators are nice because the
    order of their operands is immaterial, and this lets you rearrange a computation,
    often making that computation easier or more efficient. Often, rearranging a computation
    allows you to use fewer temporary variables. Whenever you encounter a commutative
    operator in an expression, you should always check to see if there is a better
    sequence you can use to improve the size or speed of your code. [Table 6-6](ch06s02.html#some_common_commutative_binary_operators
    "Table 6-6. Some Common Commutative Binary Operators") and [Table 6-7](ch06s02.html#some_common_noncommutative_binary_operat
    "Table 6-7. Some Common Noncommutative Binary Operators"), respectively, list
    the commutative and noncommutative operators you typically find in high-level
    languages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上一节中看到的，交换律运算符很有用，因为其操作数的顺序无关紧要，这使得你可以重新排列计算步骤，通常可以使计算更简单或更高效。通常，重新排列计算步骤能让你使用更少的临时变量。每当你在表达式中遇到交换律运算符时，应该始终检查是否有更好的顺序能提高代码的大小或速度。[表
    6-6](ch06s02.html#some_common_commutative_binary_operators "表 6-6. 一些常见的交换律二元运算符")
    和 [表 6-7](ch06s02.html#some_common_noncommutative_binary_operat "表 6-7. 一些常见的非交换律二元运算符")
    列出了你在高级语言中通常遇到的交换律和非交换律运算符。
- en: Table 6-6. Some Common Commutative Binary Operators
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-6. 一些常见的交换律二元运算符
- en: '| Pascal | C/C++ | Description |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| Pascal | C/C++ | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `+` | `+` | Addition |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `+` | 加法 |'
- en: '| `*` | `*` | Multiplication |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `*` | 乘法 |'
- en: '| `and` | `&&` or `&` | Logical or bitwise `and` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `and` | `&&` 或 `&` | 逻辑与与按位与 |'
- en: '| `or` | `&#124;&#124;` or `&#124;` | Logical or bitwise `or` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `or` | `&#124;&#124;` 或 `&#124;` | 逻辑或与按位或 |'
- en: '| `xor` | `^` | (Logical or) bitwise exclusive-`or` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `xor` | `^` | （逻辑或）按位异或 |'
- en: '| `=` | `==` | Equality |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `=` | `==` | 等式 |'
- en: '| `<>` | `!=` | Inequality |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | `!=` | 不等式 |'
- en: Table 6-7. Some Common Noncommutative Binary Operators
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-7. 一些常见的非交换律二元运算符
- en: '| Pascal | C/C++ | Description |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| Pascal | C/C++ | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-` | `-` | Subtraction |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `-` | 减法 |'
- en: '| `/` or `div` | `/` | Division |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `/` 或 `div` | `/` | 除法 |'
- en: '| `mod` | `%` | Modulo or remainder |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | `%` | 取模或余数 |'
- en: '| `<` | `<` | Less than |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `<` | 小于 |'
- en: '| `<=` | `<=` | Less than or equal |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `<=` | 小于或等于 |'
- en: '| `>` | `>` | Greater than |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `>` | 大于 |'
- en: '| `>=` | `>=` | Greater than or equal |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `>=` | 大于或等于 |'
- en: 6.3 Logical (Boolean) Expressions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 逻辑（布尔）表达式
- en: 'Consider the following expression from a Pascal program:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面一个来自Pascal程序的表达式：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`b` is a boolean variable and the remaining variables are all integers.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`是一个布尔变量，其他变量都是整数。'
- en: How do we represent boolean variables in assembly language? Although it takes
    only a single bit to represent a boolean value, most assembly language programmers
    allocate a whole byte or word for this purpose (thus, HLA also allocates a whole
    byte for a boolean variable). With a byte, there are 256 possible values we can
    use to represent the two values true and false. So which two values (or which
    two sets of values) do we use to represent these boolean values? Because of the
    machine's architecture, it's much easier to test for conditions like zero or not
    zero and positive or negative rather than to test for one of two particular boolean
    values. Most programmers (and, indeed, some programming languages like C) choose
    0 to represent false and anything else to represent true. Some people prefer to
    represent true and false with 1 and 0 (respectively) and not allow any other values.
    Others select all 1 bits ($FFFF_FFFF, $FFFF, or $FF) for true and 0 for false.
    You could also use a positive value for true and a negative value for false. All
    these mechanisms have their advantages and drawbacks.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在汇编语言中表示布尔变量？尽管表示一个布尔值只需要一个位，但大多数汇编语言程序员会为此分配一个完整的字节或字（因此，HLA也为布尔变量分配了一个完整的字节）。有了一个字节，我们可以使用256个可能的值来表示两个布尔值：真和假。那么我们用哪两个值（或哪两组值）来表示这些布尔值呢？由于机器的架构，测试像零或非零、正数或负数这样的条件比测试两个特定布尔值要容易得多。大多数程序员（事实上，一些编程语言，如C语言）选择用0表示假，其他任何值表示真。也有人更倾向于用1和0（分别表示真和假）来表示布尔值，并且不允许其他值。还有些人选择将所有1位（$FFFF_FFFF,
    $FFFF 或 $FF）表示真，0表示假。你也可以用正值表示真，负值表示假。这些机制各有其优缺点。
- en: 'Using only 0 and 1 to represent false and true offers two very big advantages:
    (1) The setcc instructions produce these results, so this scheme is compatible
    with those instructions; (2) the 80x86 logical instructions (`and`, `or`, `xor`,
    and, to a lesser extent, `not`) operate on these values exactly as you would expect.
    That is, if you have two boolean variables `A` and `B`, then the following instructions
    perform the basic logical operations on these two variables:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用0和1来表示假和真有两个非常大的优点：（1）setcc指令会产生这些结果，因此这个方案与这些指令兼容；（2）80x86的逻辑指令（`and`、`or`、`xor`，以及在较小程度上，`not`）对这些值的操作完全符合预期。也就是说，如果你有两个布尔变量`A`和`B`，那么以下指令会对这两个变量执行基本的逻辑操作：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note, as pointed out above, that the not instruction will not properly compute
    logical negation. The bitwise `not` of 0 is $FF and the bitwise `not` of 1 is
    $FE. Neither result is 0 or 1\. However, by `and`ing the result with 1 you get
    the proper result. Note that you can implement the `not` operation more efficiently
    using the `xor( 1, ax );` instruction because it affects only the L.O. bit.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如上所述，`not`指令不能正确地计算逻辑非运算。0的按位`not`是$FF，而1的按位`not`是$FE。两者的结果都不是0或1。然而，通过将结果与1进行`and`操作，你可以得到正确的结果。注意，你可以通过使用`xor(
    1, ax );`指令更高效地实现`not`操作，因为它只影响最低有效位（L.O. bit）。
- en: 'As it turns out, using 0 for false and anything else for true has a lot of
    subtle advantages. Specifically, the test for true or false is often implicit
    in the execution of any logical instruction. However, this mechanism suffers from
    a very big disadvantage: You cannot use the 80x86 `and`, `or`, `xor`, and `not`
    instructions to implement the boolean operations of the same name. Consider the
    two values $55 and $AA. They''re both nonzero so they both represent the value
    true. However, if you logically `and` $55 and $AA together using the 80x86 `and`
    instruction, the result is 0\. True `and` true should produce true, not false.
    Although you can account for situations like this, it usually requires a few extra
    instructions and is somewhat less efficient when computing boolean operations.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，使用0表示假，其他任何值表示真有许多微妙的优势。具体来说，真或假的测试通常在执行任何逻辑指令时是隐式的。然而，这种机制有一个很大的缺点：你无法使用80x86的`and`、`or`、`xor`和`not`指令来实现同名的布尔操作。考虑两个值$55和$AA。它们都是非零的，因此它们都表示真值。然而，如果你使用80x86的`and`指令对$55和$AA进行逻辑与操作，结果是0。真`and`真应该得到真，而不是假。尽管你可以处理这种情况，但通常需要额外的几条指令，并且在计算布尔操作时效率较低。
- en: A system that uses nonzero values to represent true and 0 to represent false
    is an *arithmetic logical system*. A system that uses the two distinct values
    like 0 and 1 to represent false and true is called a *boolean logical system*,
    or simply a boolean system. You can use either system, as convenient. Consider
    again the boolean expression
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非零值表示真，0表示假，是一种*算术逻辑系统*。使用0和1这两个不同值来表示假和真的是一种*布尔逻辑系统*，或者简称布尔系统。你可以根据需要选择任何一个系统。再考虑一下布尔表达式
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The simple expressions resulting from this expression might be:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表达式得到的简单表达式可能是：
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When working with boolean expressions don't forget that you might be able to
    optimize your code by simplifying those boolean expressions. You can use algebraic
    transformations to help reduce the complexity of an expression. In the chapter
    on control structures, you'll also see how to use control flow to calculate a
    boolean result. This is generally quite a bit more efficient than using *complete
    boolean evaluation* as the examples in this section teach.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理布尔表达式时，别忘了你可能可以通过简化这些布尔表达式来优化你的代码。你可以使用代数变换来帮助简化表达式的复杂性。在控制结构章节中，你还将看到如何使用控制流来计算布尔结果。与本节中的例子所教的*完全布尔运算*相比，这通常要高效得多。
- en: 6.4 Machine and Arithmetic Idioms
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 机器和算术成语
- en: An idiom is an idiosyncrasy. Several arithmetic operations and 80x86 instructions
    have idiosyncrasies that you can take advantage of when writing assembly language
    code. Some people refer to the use of machine and arithmetic idioms as "tricky
    programming" that you should always avoid in well-written programs. While it is
    wise to avoid tricks just for the sake of tricks, many machine and arithmetic
    idioms are well known and commonly found in assembly language programs. Some of
    them are little more than tricks, but a good number of them are simply "tricks
    of the trade." This text cannot even begin to present all of the idioms in common
    use today; they are too numerous and the list is constantly changing. Nevertheless,
    there are some very important idioms that you will see all the time, so it makes
    sense to discuss those.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 成语是一种特有的表达方式。几种算术操作和80x86指令都有其特有之处，在编写汇编语言代码时，你可以利用这些特性。有些人称使用机器和算术成语为“技巧性编程”，并认为在编写优良程序时应当避免。然而，虽然为了避免单纯的技巧使用是明智的，但许多机器和算术成语是广为人知且在汇编语言程序中常见的。它们中的一些只是技巧而已，但有相当一部分则是简单的“行业技巧”。这篇文本甚至无法开始列举当前常用的所有成语，它们太多了，且列表不断变化。尽管如此，还是有一些非常重要的成语你将经常看到，因此讨论这些是很有意义的。
- en: 6.4.1 Multiplying without mul, imul, or intmul
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.1 不使用mul、imul或intmul进行乘法运算
- en: When multiplying by a constant, you can sometimes write faster code by using
    shifts, additions, and subtractions in place of multiplication instructions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘以常数时，你有时可以通过使用移位、加法和减法来代替乘法指令，从而编写更快的代码。
- en: 'Remember, a `shl` instruction computes the same result as multiplying the specified
    operand by 2\. Shifting to the left two bit positions multiplies the operand by
    4\. Shifting to the left three bit positions multiplies the operand by 8\. In
    general, shifting an operand to the left *n* bits multiplies it by 2^(*n*). You
    can multiply any value by some constant using a series of shifts and additions
    or shifts and subtractions. For example, to multiply the AX register by 10, you
    need only multiply it by 8 and then add in two times the original value. That
    is, `10 * ax = 8 * ax + 2 * ax`. The code to accomplish this is:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`shl`指令计算的结果与将指定操作数乘以2相同。将操作数左移两位乘以4。将操作数左移三位乘以8。通常，将操作数左移*n*位将其乘以2的*n*次方。您可以使用一系列移位和加法或移位和减法将任意值乘以某个常数。例如，要将AX寄存器乘以10，您只需将其乘以8，然后加上两倍的原始值。也就是说，`10
    * ax = 8 * ax + 2 * ax`。执行此操作的代码如下：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Many x86 processors can multiply the AX register (or just about any register,
    for that matter) by various constant values much faster by using `shl` than by
    using the `mul` instruction. This may seem hard to believe because it takes only
    one instruction to compute this product:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 许多x86处理器可以通过使用`shl`比使用`mul`指令快得多来更快地将AX寄存器（或几乎任何寄存器）乘以各种常数值。这可能难以置信，因为仅需一条指令即可计算此乘积：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: However, if you look at the instruction timings, the shift and add example above
    requires fewer clock cycles on many processors in the 80x86 family than the `mul`
    instruction. Of course, the code is somewhat larger (by a few bytes), but the
    performance improvement is usually worth it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您查看指令时序，上面的移位加法示例在许多80x86系列处理器上需要的时钟周期比`mul`指令少。当然，代码稍微大一些（多出几个字节），但性能改进通常是值得的。
- en: 'You can also use subtraction with shifts to perform a multiplication operation.
    Consider the following multiplication by 7:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用移位结合减法来执行乘法操作。考虑以下乘以7的乘法运算：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A common error beginning assembly language programmers make is subtracting
    or adding 1 or 2 rather than `eax * 1` or `eax * 2`. The following does not compute
    `eax * 7`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 初学汇编语言程序员常犯的一个错误是减去或加上1或2，而不是`eax * 1`或`eax * 2`。以下内容不计算`eax * 7`：
- en: '[PRE69]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It computes `(8 * eax) - 1`, something entirely different (unless, of course,
    EAX = 1). Beware of this pitfall when using shifts, additions, and subtractions
    to perform multiplication operations.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算的是`(8 * eax) - 1`，完全不同的东西（当然，如果EAX = 1除外）。在使用移位、加法和减法执行乘法操作时要注意此陷阱。
- en: 'You can also use the `lea` instruction to compute certain products. The trick
    is to use the scaled index addressing modes. The following examples demonstrate
    some simple cases:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`lea`指令来计算某些乘积。诀窍是使用缩放索引寻址模式。以下示例演示了一些简单的情况：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 6.4.2 Division Without div or idiv
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.2 无需使用div或idiv进行除法
- en: Just as the `shl` instruction is useful for simulating a multiplication by a
    power of 2, the `shr` and `sar` instructions can simulate a division by a power
    of 2\. Unfortunately, you cannot easily use shifts, additions, and subtractions
    to perform a division by an arbitrary constant. Therefore, keep in mind that this
    trick is useful only when dividing by powers of 2\. Also, don't forget that the
    `sar` instruction rounds towards negative infinity rather than toward 0; this
    is not the way the `idiv` instruction operates (it rounds toward 0).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`shl`指令对模拟乘以2的幂非常有用一样，`shr`和`sar`指令可以模拟除以2的幂。不幸的是，您不能轻松地使用移位、加法和减法来执行任意常数的除法。因此，请记住，此技巧仅在除以2的幂时才有用。此外，请不要忘记，`sar`指令向负无穷方向舍入，而不是向0舍入；这与`idiv`指令的操作方式不同（它向0舍入）。
- en: Another way to perform division is to use the multiply instructions. You can
    divide by some value by multiplying by its reciprocal. Because the multiply instruction
    is faster than the divide instruction, multiplying by a reciprocal is usually
    faster than division.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种进行除法的方法是使用乘法指令。通过乘以其倒数，您可以除以某个值。由于乘法指令比除法指令快，乘以倒数通常比除法快。
- en: 'Now you''re probably wondering, "How does one multiply by a reciprocal when
    the values we''re dealing with are all integers?" The answer, of course, is that
    we must cheat to do this. If you want to multiply by 1/10, there is no way you
    can load the value 1/10 into an 80x86 integer register prior to performing the
    multiplication. However, we could multiply 1/10 by 10, perform the multiplication,
    and then divide the result by 10 to get the final result. Of course, this wouldn''t
    buy you anything; in fact, it would make things worse because you''re now doing
    a multiplication by 10 as well as a division by 10\. However, suppose you multiply
    1/10 by 65,536 (6,553), perform the multiplication, and then divide by 65,536\.
    This would still perform the correct operation, and, as it turns out, if you set
    up the problem correctly, you can get the division operation for free. Consider
    the following code that divides AX by 10:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会想，“当我们处理的值都是整数时，怎么通过倒数来进行乘法运算？”当然，答案是我们必须作弊来实现这一点。如果你想乘以1/10，事先将1/10加载到80x86整数寄存器中是不可能的。然而，我们可以将1/10乘以10，进行乘法运算，然后将结果除以10得到最终结果。当然，这并不会带来任何好处；实际上，这样做反而会更糟，因为你现在不仅要做乘以10的运算，还要做除以10的运算。然而，假设你将1/10乘以65,536（6,553），进行乘法运算，然后再除以65,536，这仍然能完成正确的操作，实际上，如果你正确地设置问题，除法操作是免费的。考虑以下将AX除以10的代码：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This code leaves AX/10 in the DX register.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将AX/10的结果保存在DX寄存器中。
- en: To understand how this works, consider what happens when you multiply AX by
    65,536 ($1_0000). This simply moves AX into DX and sets AX to 0 (a multiply by
    $1_0000 is equivalent to a shift left by 16 bits). Multiplying by 6,554 (65,536
    divided by 10) puts AX divided by 10 into the DX register. Because `mul` is faster
    than `div`, this technique runs a little faster than using a division.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，考虑当你将AX乘以65,536（$1_0000）时会发生什么。这实际上将AX移动到DX并将AX设置为0（乘以$1_0000相当于左移16位）。将AX乘以6,554（65,536除以10）将AX除以10的结果存储在DX寄存器中。因为`mul`比`div`更快，所以这种技术比使用除法稍微快一点。
- en: Multiplying by a reciprocal works well when you need to divide by a constant.
    You could even use it to divide by a variable, but the overhead to compute the
    reciprocal pays off only if you perform the division many, many times (by the
    same value).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要除以常数时，乘以倒数的方式非常有效。你甚至可以用它来除以一个变量，但计算倒数的开销只有在你进行多次相同值的除法时才会得到回报。
- en: 6.4.3 Implementing Modulo-N Counters with and
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.3 使用与实现模N计数器
- en: 'If you want to implement a counter variable that counts up to 2^(*n*) - 1 and
    then resets to 0, simply use the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想实现一个计数器变量，使其计数直到2^(*n*) - 1，然后重置为0，只需使用以下代码：
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'where `nBits` is a binary value containing *n* bits containing ones right justified
    in the number. For example, to create a counter that cycles between 0 and 15 (2⁴
    − 1), you could use the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `nBits` 是一个二进制值，包含* n *个右对齐的1位。例如，要创建一个在0和15之间循环的计数器（2⁴ - 1），你可以使用以下代码：
- en: '[PRE73]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 6.5 Floating-Point Arithmetic
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 浮点运算
- en: When the 8086 CPU first appeared in the late 1970s, semiconductor technology
    was not to the point where Intel could put floating-point instructions directly
    on the 8086 CPU. Therefore, Intel devised a scheme whereby it could use a second
    chip to perform the floating-point calculations—the floating-point unit (or FPU).^([[102](#ftn.CHP-6-FN-1)])
    By the release of the Intel Pentium chip, semiconductor technology had advanced
    to the point that the FPU was fully integrated onto the 80x86 CPU. Therefore,
    almost all modern 80x86 CPU devices fully support floating-point arithmetic directly
    on the CPU.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当8086 CPU在1970年代末期首次亮相时，半导体技术还没有发展到Intel可以直接在8086 CPU上放置浮点指令的地步。因此，Intel设计了一种方案，使用第二颗芯片来执行浮点运算——即浮点单元（FPU）。^([[102](#ftn.CHP-6-FN-1)])
    随着Intel Pentium芯片的发布，半导体技术已经发展到FPU完全集成到80x86 CPU中的程度。因此，几乎所有现代的80x86 CPU设备都完全支持在CPU上直接进行浮点运算。
- en: 6.5.1 FPU Registers
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.1 FPU寄存器
- en: 'The 80x86 FPUs add 13 registers to the 80x86: eight floating-point data registers,
    a control register, a status register, a tag register, an instruction pointer,
    and a data pointer. The data registers are similar to the 80x86''s general-purpose
    register set insofar as all floating-point calculations take place in these registers.
    The control register contains bits that let you decide how the FPU handles certain
    degenerate cases like rounding of inaccurate computations; it also contains bits
    that control precision and so on. The status register is similar to the 80x86''s
    flags register; it contains the condition code bits and several other floating-point
    flags that describe the state of the FPU. The tag register contains several groups
    of bits that determine the state of the value in each of the eight floating-point
    data registers. The instruction and data pointer registers contain certain state
    information about the last floating-point instruction executed. We will not consider
    the last three registers here; see the Intel documentation for more details.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 FPU为80x86添加了13个寄存器：八个浮点数据寄存器，一个控制寄存器，一个状态寄存器，一个标签寄存器，一个指令指针和一个数据指针。数据寄存器类似于80x86的通用寄存器集，因为所有浮点计算都在这些寄存器中进行。控制寄存器包含位，用于决定FPU如何处理某些退化情况，如不准确计算的舍入；它还包含控制精度等的位。状态寄存器类似于80x86的标志寄存器；它包含条件码位和描述FPU状态的其他几个浮点标志。标签寄存器包含几组位，用于确定每个浮点数据寄存器中值的状态。指令指针和数据指针寄存器包含关于上次执行的浮点指令的某些状态信息。我们在此不讨论最后三个寄存器；有关详细信息，请参阅英特尔文档。
- en: 6.5.1.1 FPU Data Registers
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1.1 FPU 数据寄存器
- en: The FPUs provide eight 80-bit data registers organized as a stack. This is a
    significant departure from the organization of the general-purpose registers on
    the 80x86 CPU. HLA refers to these registers as ST0, ST1, . . . ST7.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: FPU提供了八个80位的数据寄存器，组织成一个堆栈。这与80x86 CPU上通用寄存器的组织方式有显著不同。HLA将这些寄存器称为ST0、ST1、……ST7。
- en: The biggest difference between the FPU register set and the 80x86 register set
    is the stack organization. On the 80x86 CPU, the AX register is always the AX
    register, no matter what happens. On the FPU, however, the register set is an
    eight-element stack of 80-bit floating-point values (see [Figure 6-1](ch06s05.html#fpu_floating-point_register_stack
    "Figure 6-1. FPU floating-point register stack")).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: FPU寄存器集与80x86寄存器集之间最大的区别是堆栈结构。在80x86 CPU上，AX寄存器始终是AX寄存器，无论发生什么。然而，在FPU上，寄存器集是一个包含8个元素的堆栈，存储的是80位浮点值（见[图6-1](ch06s05.html#fpu_floating-point_register_stack
    "图6-1. FPU 浮点寄存器堆栈")））。
- en: '![FPU floating-point register stack](tagoreillycom20100401nostarchimages578021.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![FPU 浮点寄存器堆栈](tagoreillycom20100401nostarchimages578021.png)'
- en: Figure 6-1. FPU floating-point register stack
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. FPU 浮点寄存器堆栈
- en: ST0 refers to the item on the top of the stack, ST1 refers to the next item
    on the stack, and so on. Many floating-point instructions push and pop items on
    the stack; therefore, ST1 will refer to the previous contents of ST0 after you
    push something onto the stack. It will take some thought and practice to get used
    to the fact that the register numbers change, but this is an easy problem to overcome.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ST0表示堆栈顶部的项，ST1表示堆栈中的下一项，以此类推。许多浮点指令会在堆栈上推入和弹出项；因此，在将某个项推入堆栈后，ST1将表示ST0的先前内容。习惯于寄存器编号会变化这一事实需要一些思考和练习，但这并不难克服。
- en: 6.5.1.2 The FPU Control Register
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1.2 FPU 控制寄存器
- en: When Intel designed the 80x87 (and, essentially, the IEEE floating-point standard),
    there were no standards in floating-point hardware. Different (mainframe and mini)
    computer manufacturers all had different and incompatible floating-point formats.
    Unfortunately, several applications had been written taking into account the idiosyncrasies
    of these different floating-point formats. Intel wanted to design an FPU that
    could work with the majority of the software out there (keep in mind that the
    IBM-PC was three to four years away when Intel began designing the 8087, so Intel
    couldn't rely on that "mountain" of software available for the PC to make its
    chip popular). Unfortunately, many of the features found in these older floating-point
    formats were mutually incompatible. For example, in some floating-point systems
    rounding would occur when there was insufficient precision; in others, truncation
    would occur. Some applications would work with one floating-point system but not
    with the other. Intel wanted as many applications as possible to work with as
    few changes as possible on its 80x87 FPUs, so it added a special register, the
    FPU *control register*, that lets the user choose one of several possible operating
    modes for the FPU.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当英特尔设计80x87（以及本质上是IEEE浮点标准）时，浮点硬件没有标准化。不同的（大型机和小型机）计算机制造商都有不同且不兼容的浮点格式。不幸的是，许多应用程序已经根据这些不同浮点格式的特殊性进行了编写。英特尔希望设计一个能够与大多数现有软件兼容的FPU（请记住，英特尔开始设计8087时，IBM-PC还差三到四年才问世，所以英特尔无法依赖那个“山一样”的PC软件来让其芯片流行）。不幸的是，这些较老浮点格式中的许多特性是互不兼容的。例如，在某些浮点系统中，当精度不足时会发生舍入；而在其他系统中则会发生截断。有些应用程序可以与一种浮点系统兼容，但与另一种不兼容。英特尔希望尽可能多的应用程序能够在尽可能少的修改下与其80x87
    FPU兼容，因此它添加了一个特殊寄存器，即FPU *控制寄存器*，让用户可以选择FPU的几种操作模式之一。
- en: The 80x87 control register contains 16 bits organized as shown in [Figure 6-2](ch06s05.html#fpu_control_register
    "Figure 6-2. FPU control register").
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 80x87控制寄存器包含16位，组织方式如[图6-2](ch06s05.html#fpu_control_register "Figure 6-2. FPU
    control register")所示。
- en: '![FPU control register](tagoreillycom20100401nostarchimages578023.png.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![FPU控制寄存器](tagoreillycom20100401nostarchimages578023.png.jpg)'
- en: Figure 6-2. FPU control register
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. FPU控制寄存器
- en: Bits 10 and 11 of the FPU control register provide rounding control according
    to the values appearing in [Table 6-8](ch06s05.html#rounding_control "Table 6-8. Rounding
    Control").
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: FPU控制寄存器的第10位和第11位提供了舍入控制，具体取决于[表6-8](ch06s05.html#rounding_control "Table 6-8. Rounding
    Control")中显示的值。
- en: Table 6-8. Rounding Control
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-8. 舍入控制
- en: '| Bits 10 & 11 | Function |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 第10位和第11位 | 功能 |'
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00 | To nearest or even |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 00 | 舍入到最近的或偶数 |'
- en: '| 01 | Round down |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 向下舍入 |'
- en: '| 10 | Round up |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 向上舍入 |'
- en: '| 11 | Truncate |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 截断 |'
- en: The 00 setting is the default. The FPU rounds up values above one-half of the
    least significant bit. It rounds down values below one-half of the least significant
    bit. If the value below the least significant bit is exactly one-half of the least
    significant bit, then the FPU rounds the value toward the value whose least significant
    bit is 0\. For long strings of computations, this provides a reasonable, automatic
    way to maintain maximum precision.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 00设置是默认设置。FPU会将大于最小有效位一半的值舍入到上面，低于最小有效位一半的值则舍入到下面。如果最小有效位下面的值恰好是最小有效位的一半，则FPU会将该值舍入到最接近的、最小有效位为0的值。对于长字符串的计算，这提供了一种合理的、自动的方式来保持最大的精度。
- en: The round-up and round-down options are present for those computations where
    it is important to keep track of the accuracy during a computation. By setting
    the rounding control to round down and performing the operation, then repeating
    the operation with the rounding control set to round up, you can determine the
    minimum and maximum ranges between which the true result will fall.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 向上舍入和向下舍入选项适用于那些在计算过程中需要跟踪精度的计算。通过将舍入控制设置为向下舍入并执行操作，然后重复执行该操作，将舍入控制设置为向上舍入，你可以确定真实结果将落入的最小和最大范围之间。
- en: The truncate option forces all computations to truncate any excess bits during
    the computation. You will rarely use this option if accuracy is important to you.
    However, if you are porting older software to the FPU, you might use this option
    to help when porting the software. One place where this option is extremely useful
    is when converting a floating-point value to an integer. Because most software
    expects floating-point-to-integer conversions to truncate the result, you will
    need to use the truncation/rounding mode to achieve this.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 截断选项强制所有计算在过程中截断任何多余的位。如果精度对你来说很重要，你很少会使用此选项。然而，如果你正在将旧软件移植到 FPU 上，可能会使用此选项来帮助软件移植。此选项在将浮点值转换为整数时非常有用。因为大多数软件期望浮点到整数的转换会截断结果，你需要使用截断/舍入模式来实现这一点。
- en: Bits 8 and 9 of the control register specify the precision during computation.
    This capability is provided to allow compatibility with older software as required
    by the IEEE 754 standard. The precision control bits use the values in [Table 6-9](ch06s05.html#mantissa_precision_control_bits
    "Table 6-9. Mantissa Precision Control Bits").
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 控制寄存器的第 8 位和第 9 位指定计算过程中的精度。此功能提供了与旧软件兼容的能力，以符合 IEEE 754 标准的要求。精度控制位使用[表 6-9](ch06s05.html#mantissa_precision_control_bits
    "表 6-9. 尾数精度控制位")中的值。
- en: Table 6-9. Mantissa Precision Control Bits
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-9. 尾数精度控制位
- en: '| Bits 8 & 9 | Precision Control |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 位 8 和 9 | 精度控制 |'
- en: '| --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00 | 24 bits |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 00 | 24 位 |'
- en: '| 01 | Reserved |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 保留 |'
- en: '| 10 | 53 bits |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 53 位 |'
- en: '| 11 | 64 bits |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 64 位 |'
- en: Some CPUs may operate faster with floating-point values whose precision is 53
    bits (i.e., 64-bit floating-point format) rather than 64 bits (i.e., 80-bit floating-point
    format). Please see the documentation for your specific processor for details.
    Generally, the CPU defaults these bits to %11 to select the 64-bit mantissa precision.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 CPU 在处理精度为 53 位（即 64 位浮点格式）的浮点值时，可能比处理 64 位（即 80 位浮点格式）更快。有关详细信息，请参见特定处理器的文档。通常，CPU
    默认将这些位设置为 %11，以选择 64 位尾数精度。
- en: Bits 0..5 are the *exception masks*. These are similar to the interrupt enable
    bit in the 80x86's flags register. If these bits contain a 1, the corresponding
    condition is ignored by the FPU. However, if any bit contains 0, and the corresponding
    condition occurs, then the FPU immediately generates an interrupt so the program
    can handle the degenerate condition (typically, this would wind up raising an
    HLA exception; see the *excepts.hhf* header file for the exception values).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0..5 是*异常屏蔽位*。这些位类似于 80x86 的标志寄存器中的中断使能位。如果这些位为 1，则相应的条件会被 FPU 忽略。然而，如果任一位为
    0，并且相应条件发生，则 FPU 会立即生成中断，程序可以处理这种退化条件（通常这会引发 HLA 异常；异常值见 *excepts.hhf* 头文件）。
- en: Bit 0 corresponds to an invalid operation error. This generally occurs as the
    result of a programming error. Situations that raise the invalid operation exception
    (`ex.fInvalidOperation`) include pushing more than eight items onto the stack
    or attempting to pop an item off an empty stack, taking the square root of a negative
    number, or loading a nonempty register.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 对应无效操作错误。这通常是由于编程错误引起的。引发无效操作异常（`ex.fInvalidOperation`）的情况包括将超过八个项压入栈中，或者尝试从空栈中弹出项，取负数的平方根，或加载非空寄存器。
- en: Bit 1 masks the *denormalized* interrupt that occurs whenever you try to manipulate
    denormalized values. Denormalized exceptions occur when you load arbitrary extended-precision
    values into the FPU or work with very small numbers just beyond the range of the
    FPU's capabilities. Normally, you would probably *not* enable this exception.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.fDenormal` exception.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 位 1 屏蔽*非规范化*中断，每当你尝试操作非规范化的值时都会触发。非规范化异常发生在你将任意扩展精度的值加载到 FPU 或者处理非常小的超出 FPU
    能力范围的数值时。通常情况下，你可能*不会*启用此异常。如果启用了此异常且 FPU 生成了此中断，则 HLA 运行时系统会触发 `ex.fDenormal`
    异常。
- en: Bit 2 masks the *zero divide* exception. If this bit contains 0, the FPU will
    generate an interrupt if you attempt to divide a nonzero value by 0\. If you do
    not enable the zero division exception, the FPU will produce `NaN` (not a number)
    whenever you perform a zero division. It's probably a good idea to enable this
    exception by programming a 0 into this bit. Note that if your program generates
    this interrupt, the HLA runtime system will raise the `ex.fDivByZero` exception.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 位 2 屏蔽*零除*异常。如果此位为 0，当你尝试将非零值除以 0 时，FPU 会生成中断。如果你不启用零除异常，FPU 会在执行零除时产生 `NaN`（不是一个数）。通过将
    0 编程到此位，启用此异常可能是个好主意。请注意，如果你的程序生成此中断，HLA 运行时系统会引发`ex.fDivByZero`异常。
- en: Bit 3 masks the *overflow* exception. The FPU will raise the overflow exception
    if a calculation overflows or if you attempt to store a value that is too large
    to fit into the destination operand (for example, storing a large extended-precision
    value into a single-precision variable). If you enable this exception and the
    FPU generates this interrupt, the HLA runtime system raises the `ex.fOverflow`
    exception.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 位 3 屏蔽*溢出*异常。如果计算发生溢出，或者你试图将一个太大的值存入目标操作数（例如，将一个大的扩展精度值存入单精度变量），FPU 将引发溢出异常。如果你启用此异常并且
    FPU 生成此中断，HLA 运行时系统会引发`ex.fOverflow`异常。
- en: Bit 4, if set, masks the *underflow* exception. Underflow occurs when the result
    is too *small* to fit in the destination operand. Like overflow, this exception
    can occur whenever you store a small extended-precision value into a smaller variable
    (single or double precision) or when the result of a computation is too small
    for extended precision. If you enable this exception and the FPU generates this
    interrupt, the HLA runtime system raises the `ex.fUnderflow` exception.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 位 4，如果设置，会屏蔽*下溢*异常。下溢发生在结果太*小*，无法适应目标操作数时。像溢出一样，这个异常可以在你将一个小的扩展精度值存入一个较小的变量（单精度或双精度）时发生，或者当计算结果对扩展精度来说太小时。如果你启用此异常并且
    FPU 生成此中断，HLA 运行时系统会引发`ex.fUnderflow`异常。
- en: Bit 5 controls whether the *precision* exception can occur. A precision exception
    occurs whenever the FPU produces an imprecise result, generally the result of
    an internal rounding operation. Although many operations will produce an exact
    result, many more will not. For example, dividing 1 by 10 will produce an inexact
    result. Therefore, this bit is usually 1 because inexact results are very common.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.InexactResult` exception.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 位 5 控制是否可以发生*精度*异常。精度异常发生在 FPU 产生不精确的结果时，通常是内部四舍五入操作的结果。虽然许多操作会产生精确的结果，但更多操作不会。例如，将
    1 除以 10 会产生不精确的结果。因此，这个位通常为 1，因为不精确的结果非常常见。如果你启用此异常并且 FPU 生成此中断，HLA 运行时系统会引发`ex.InexactResult`异常。
- en: Bits 6..7 and 12..15 in the control register are currently undefined and reserved
    for future use (bits 7 and 12 were valid on older FPUs but are no longer used).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 控制寄存器中的位 6..7 和 12..15 目前是未定义的，并保留用于未来使用（位 7 和 12 在旧的 FPU 上有效，但现在不再使用）。
- en: 'The FPU provides two instructions, `fldcw` (load control word) and `fstcw`
    (store control word), that let you load and store the contents of the control
    register. The single operand to these instructions must be a 16-bit memory location.
    The `fldcw` instruction loads the control register from the specified memory location.
    `fstcw` stores the control register into the specified memory location. The syntax
    for these instructions is:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 提供了两条指令，`fldcw`（加载控制字）和 `fstcw`（存储控制字），让你可以加载和存储控制寄存器的内容。这些指令的单操作数必须是一个
    16 位内存位置。`fldcw` 指令从指定的内存位置加载控制寄存器。`fstcw` 将控制寄存器存储到指定的内存位置。这些指令的语法是：
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here''s some example code that sets the rounding control to "truncate result"
    and sets the rounding precision to 24 bits:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些示例代码，设置四舍五入控制为“截断结果”，并将四舍五入精度设置为 24 位：
- en: '[PRE75]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 6.5.1.3 The FPU Status Register
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1.3 FPU 状态寄存器
- en: The FPU status register provides the status of the FPU at the instant you read
    it. The `fstsw` instruction stores the16-bit floating-point status register into
    a word variable. The status register is a 16-bit register; its layout appears
    in [Figure 6-3](ch06s05.html#the_fpu_status_register-id1 "Figure 6-3. The FPU
    status register").
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 状态寄存器提供了读取时刻 FPU 的状态。`fstsw` 指令将 16 位浮点状态寄存器存储到一个字变量中。状态寄存器是一个 16 位寄存器；其布局见[图
    6-3](ch06s05.html#the_fpu_status_register-id1 "图 6-3. FPU 状态寄存器")。
- en: '![The FPU status register](tagoreillycom20100401nostarchimages578025.png.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![FPU 状态寄存器](tagoreillycom20100401nostarchimages578025.png.jpg)'
- en: Figure 6-3. The FPU status register
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3. FPU 状态寄存器
- en: Bits 0 through 5 are the exception flags. These bits appear in the same order
    as the exception masks in the control register. If the corresponding condition
    exists, then the bit is set. These bits are independent of the exception masks
    in the control register. The FPU sets and clears these bits regardless of the
    corresponding mask setting.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 到位 5 是异常标志。这些位的顺序与控制寄存器中的异常掩码相同。如果存在相应的条件，则该位被设置。这些位独立于控制寄存器中的异常掩码设置。FPU
    无论对应的掩码设置如何，都会设置和清除这些位。
- en: Bit 6 indicates a *stack fault*. A stack fault occurs whenever there is a stack
    overflow or underflow. When this bit is set, the C[1] condition code bit determines
    whether there was a stack overflow (C[1] = 1) or stack underflow (C[1] = 0) condition.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 位 6 表示*堆栈故障*。堆栈故障发生在堆栈溢出或下溢时。当该位被设置时，C[1] 状态码位确定是堆栈溢出（C[1] = 1）还是堆栈下溢（C[1] =
    0）。
- en: Bit 7 of the status register is set if *any* error condition bit is set. It
    is the logical `or` of bits 0 through 5\. A program can test this bit to quickly
    determine if an error condition exists.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了*任何*错误条件位，状态寄存器的第 7 位将被设置。它是位 0 到位 5 的逻辑 `或` 运算结果。程序可以测试这个位，以快速判断是否存在错误条件。
- en: Bits 8, 9, 10, and 14 are the coprocessor condition code bits. Various instructions
    set the condition code bits, as shown in [Table 6-10](ch06s05.html#fpu_condition_code_bits_open_parenthesis
    "Table 6-10. FPU Condition Code Bits (X = "Don't care")") and [Table 6-11](ch06s05.html#condition_code_interpretations_open_pare
    "Table 6-11. Condition Code Interpretations (X = "Don't care")"), respectively.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 位 8、9、10 和 14 是协处理器状态码位。不同的指令设置状态码位，如 [表 6-10](ch06s05.html#fpu_condition_code_bits_open_parenthesis
    "表 6-10. FPU 状态码位 (X = \"不关心\")") 和 [表 6-11](ch06s05.html#condition_code_interpretations_open_pare
    "表 6-11. 状态码解释 (X = \"不关心\")") 所示。
- en: Table 6-10. FPU Condition Code Bits (X = "Don't care")
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-10. FPU 状态码位 (X = "不关心")
- en: '| Instruction | Condition Code Bits | Condition |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 状态码位 | 条件 |'
- en: '| --- | --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | C[3] | C[2] | C[1] | C[0] |   |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|   | C[3] | C[2] | C[1] | C[0] |   |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `fcom``fcomp``fcompp``ficom``ficomp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST
    < sourceST = sourceST or source undefined |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `fcom``fcomp``fcompp``ficom``ficomp` | 0011 | 0001 | XXXX | 0101 | ST > 源ST
    < 源ST = 源ST 或源未定义 |'
- en: '| `ftst` | 0011 | 0001 | XXXX | 0101 | ST is positiveST is negativeST is 0
    (+ or −)ST is uncomparable |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `ftst` | 0011 | 0001 | XXXX | 0101 | ST 为正ST 为负ST 为 0（+ 或 −）ST 无法比较 |'
- en: '| `fxam` | 0000111100001 | 001100110011X | 010101010101X | 000000011111 | +
    Unnormalized− Unnormalized+ Normalized− Normalized+ 0− 0+ Denormalized− Denormalized+
    NaN− NaN+ Infinity− InfinityEmpty register |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `fxam` | 0000111100001 | 001100110011X | 010101010101X | 000000011111 | +
    非规范化− 非规范化+ 规范化− 规范化+ 0− 0+ 非正规化− 非正规化+ NaN− NaN+ 无穷大− 无穷大空寄存器 |'
- en: '| `fucom``fucomp``fucompp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST < sourceST
    = sourceUnordered |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `fucom``fucomp``fucompp` | 0011 | 0001 | XXXX | 0101 | ST > 源ST < 源ST = 源无序
    |'
- en: Table 6-11. Condition Code Interpretations (X = “Don’t care”)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-11. 状态码解释 (X = "不关心")
- en: '| **Instruction(s)** | **Condition Code Bits** |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **状态码位** |'
- en: '| --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  | C[0] | C[3] | C[2] | C[1] |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  | C[0] | C[3] | C[2] | C[1] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `fcom, fcomp, fcmpp, ftst, fucom, fucomp, fucompp, ficom, ficomp` | Result
    of comparison. See previous table. | Result of comparison. See previous table.
    | Operands are not comparable | Result of comparison. See previous table.Also
    denotes stack overflow/underflow if stack exception bit is set. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `fcom, fcomp, fcmpp, ftst, fucom, fucomp, fucompp, ficom, ficomp` | 比较结果。请参见前表。
    | 比较结果。请参见前表。 | 操作数不可比较 | 比较结果。请参见前表。如果设置了堆栈异常位，还表示堆栈溢出/下溢。 |'
- en: '| `fxam` | See previous table. | See previous table. | See previous table.
    | Sign of result, or stack overflow/underflow (if stack exception bit is set).
    |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `fxam` | 请参见前表。 | 请参见前表。 | 请参见前表。 | 结果符号，或堆栈溢出/下溢（如果堆栈异常位被设置）。 |'
- en: '| `fprem, fprem1` | Bit 2 of remainder | Bit 0 of remainder | 0 – reduction
    done.1 – reduction incomplete. | Bit 1 of remainder or stack overflow/underflow
    (if stack exception bit is set). |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `fprem, fprem1` | 余数的第 2 位 | 余数的第 0 位 | 0 – 减法已完成。1 – 减法未完成。 | 余数的第 1 位或堆栈溢出/下溢（如果堆栈异常位被设置）。
    |'
- en: '| `fist, fbstp, frndint, fst, fstp, fadd, fmul, fdiv, fdivr, fsub, fsubr, fscale,
    fsqrt, fpatan, f2xm1, fyl2x, fyl2xp1` | Undefined | Undefined | Undefined | Round
    up occurred or stack overflow/underflow (if stack exception bit is set). |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `fist, fbstp, frndint, fst, fstp, fadd, fmul, fdiv, fdivr, fsub, fsubr, fscale,
    fsqrt, fpatan, f2xm1, fyl2x, fyl2xp1` | 未定义 | 未定义 | 未定义 | 上舍入发生或栈溢出/下溢（如果栈异常位被置位）。
    |'
- en: '| `fptan, fsin, fcos, fsincos` | Undefined | Undefined | 0 – reduction done.1
    – reduction incomplete. | Round up occurred or stack overflow/underflow (if stack
    exception bit is set). |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `fptan, fsin, fcos, fsincos` | 未定义 | 未定义 | 0 – 减少完成。 1 – 减少未完成。 | 上舍入发生或栈溢出/下溢（如果栈异常位被置位）。
    |'
- en: '| `fchs, fabs, fxch, fincstp, fdecstp,``constant``loads,fxtract, fld, fild,
    fbld, fstp (80 bit)` | Undefined | Undefined | Undefined | Zero result or stack
    overflow/underflow (if stack exception bit is set). |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `fchs, fabs, fxch, fincstp, fdecstp, ``constant``加载, fxtract, fld, fild,
    fbld, fstp (80位)` | 未定义 | 未定义 | 未定义 | 零结果或栈溢出/下溢（如果栈异常位被置位）。 |'
- en: '| `fldenv, fstor` | Restored from memory operand. | Restored from memory operand.
    | Restored from memory operand. | Restored from memory operand. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `fldenv, fstor` | 从内存操作数恢复。 | 从内存操作数恢复。 | 从内存操作数恢复。 | 从内存操作数恢复。 |'
- en: '| `fldcw, fstenv, fstcw, fstsw, fclex` | Undefined | Undefined | Undefined
    | Undefined |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `fldcw, fstenv, fstcw, fstsw, fclex` | 未定义 | 未定义 | 未定义 | 未定义 |'
- en: '| `finit, fsave` | Cleared to zero. | Cleared to zero. | Cleared to zero. |
    Cleared to zero. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `finit, fsave` | 清除为零。 | 清除为零。 | 清除为零。 | 清除为零。 |'
- en: Bits 11–13 of the FPU status register provide the register number of the top
    of stack. During computations, the FPU adds (modulo-8) the *logical* register
    numbers supplied by the programmer to these three bits to determine the *physical*
    register number at runtime.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: FPU状态寄存器的位11–13提供了栈顶的寄存器编号。在计算过程中，FPU将程序员提供的*逻辑*寄存器编号与这三个位进行加法（模-8运算），以确定运行时的*物理*寄存器编号。
- en: Bit 15 of the status register is the *busy* bit. It is set whenever the FPU
    is busy. This bit is a historical artifact from the days when the FPU was a separate
    chip; most programs will have little reason to access this bit.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 状态寄存器的位15是*忙碌*位。当FPU忙碌时，此位被置为1。这一位是FPU曾作为独立芯片时的历史遗留物；大多数程序几乎没有理由访问此位。
- en: 6.5.2 FPU Data Types
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.2 FPU数据类型
- en: 'The FPU supports seven different data types: three integer types, a packed
    decimal type, and three floating-point types. The integer type supports 64-bit
    integers, although it is often faster to do the 64-bit arithmetic using the integer
    unit of the CPU (see [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC")).
    Certainly it is faster to do 16-bit and 32-bit integer arithmetic using the standard
    integer registers. The packed decimal type provides a 17-digit signed decimal
    (BCD) integer. The primary purpose of the BCD format is to convert between strings
    and floating-point values. The remaining three data types are the 32-bit, 64-bit,
    and 80-bit floating-point data types. The 80x87 data types appear in [Figure 6-4](ch06s05.html#fpu_floating-point_formats
    "Figure 6-4. FPU floating-point formats"), [Figure 6-5](ch06s05.html#fpu_integer_formats
    "Figure 6-5. FPU integer formats"), and [Figure 6-6](ch06s05.html#fpu_packed_decimal_format
    "Figure 6-6. FPU packed decimal format").'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: FPU支持七种不同的数据类型：三种整数类型，一种打包十进制类型，三种浮点类型。整数类型支持64位整数，尽管通常使用CPU的整数单元进行64位算术运算更为高效（参见[第8章](ch08.html
    "第8章. 高级算术")）。当然，使用标准整数寄存器进行16位和32位整数算术运算更为快速。打包十进制类型提供一个17位的有符号十进制（BCD）整数。BCD格式的主要用途是进行字符串与浮点值之间的转换。其余三种数据类型是32位、64位和80位的浮点数据类型。80x87数据类型出现在[图6-4](ch06s05.html#fpu_floating-point_formats
    "图6-4. FPU浮点格式")、[图6-5](ch06s05.html#fpu_integer_formats "图6-5. FPU整数格式")和[图6-6](ch06s05.html#fpu_packed_decimal_format
    "图6-6. FPU打包十进制格式")中。
- en: '![FPU floating-point formats](tagoreillycom20100401nostarchimages578027.png.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![FPU浮点格式](tagoreillycom20100401nostarchimages578027.png.jpg)'
- en: Figure 6-4. FPU floating-point formats
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4. FPU浮点格式
- en: '![FPU integer formats](tagoreillycom20100401nostarchimages578029.png.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![FPU整数格式](tagoreillycom20100401nostarchimages578029.png.jpg)'
- en: Figure 6-5. FPU integer formats
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5. FPU整数格式
- en: '![FPU packed decimal format](tagoreillycom20100401nostarchimages578031.png.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![FPU打包十进制格式](tagoreillycom20100401nostarchimages578031.png.jpg)'
- en: Figure 6-6. FPU packed decimal format
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6. FPU打包十进制格式
- en: The FPU generally stores values in a *normalized* format. When a floating-point
    number is normalized, the H.O. bit of the mantissa is always 1\. In the 32- and
    64-bit floating-point formats, the FPU does not actually store this bit; the FPU
    always assumes that it is 1\. Therefore, 32- and 64-bit floating-point numbers
    are always normalized. In the extended-precision 80-bit floating-point format,
    the FPU does *not* assume that the H.O. bit of the mantissa is 1; the H.O. bit
    of the mantissa appears as part of the string of bits.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 通常以*归一化*格式存储值。当浮点数被归一化时，尾数的最高有效位总是1。在32位和64位浮点格式中，FPU实际上并不存储这一位；FPU总是假设它为1。因此，32位和64位浮点数总是归一化的。在扩展精度80位浮点格式中，FPU
    *不*假设尾数的最高有效位为1；尾数的最高有效位作为位串的一部分出现。
- en: Normalized values provide the greatest precision for a given number of bits.
    However, there are a large number of nonnormalized values that we *cannot* represent
    with the 80-bit format. These values are very close to 0 and represent the set
    of values whose mantissa H.O. bit is not 0\. The FPUs support a special 80-bit
    form known as *denormalized* values. Denormalized values allow the FPU to encode
    very small values it cannot encode using normalized values, but denormalized values
    offer fewer bits of precision than normalized values. Therefore, using denormalized
    values in a computation may introduce some slight inaccuracy into a computation.
    Of course, this is always better than underflowing the denormalized value to 0
    (which could make the computation even less accurate), but you must keep in mind
    that if you work with very small values you may lose some accuracy in your computations.
    Note that the FPU status register contains a bit you can use to detect when the
    FPU uses a denormalized value in a computation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化值在给定位数下提供最大的精度。然而，有大量的非归一化值是我们*无法*使用80位格式表示的。这些值非常接近0，表示那些尾数最高有效位（H.O. bit）不是0的值。FPU支持一种特殊的80位形式，称为*非归一化*值。非归一化值允许FPU编码它无法通过归一化值编码的非常小的值，但非归一化值的精度比归一化值低。因此，在计算中使用非归一化值可能会引入一些轻微的不准确性。当然，这总比将非归一化值下溢为0（这可能会使计算更加不准确）要好，但你必须记住，如果你处理的是非常小的值，可能会在计算中丢失一些精度。请注意，FPU
    状态寄存器包含一个位，你可以用来检测 FPU 在计算中何时使用非归一化值。
- en: 6.5.3 The FPU Instruction Set
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.3 FPU 指令集
- en: The FPU adds many instructions to the 80x86 instruction set. We can classify
    these instructions as data movement instructions, conversions, arithmetic instructions,
    comparisons, constant instructions, transcendental instructions, and miscellaneous
    instructions. The following sections describe each of the instructions in these
    categories.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 在80x86指令集中添加了许多指令。我们可以将这些指令分类为数据传输指令、转换指令、算术指令、比较指令、常量指令、超越指令和其他指令。以下章节将描述这些类别中的每一条指令。
- en: 6.5.4 FPU Data Movement Instructions
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.4 FPU 数据传输指令
- en: The data movement instructions transfer data between the internal FPU registers
    and memory. The instructions in this category are `fld`, `fst`, `fstp`, and `fxch`.
    The `fld` instruction always pushes its operand onto the floating-point stack.
    The `fstp` instruction always pops the top of stack after storing the top of stack
    (TOS). The remaining instructions do not affect the number of items on the stack.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输指令在内部 FPU 寄存器和内存之间传输数据。该类别的指令有`fld`、`fst`、`fstp`和`fxch`。`fld`指令总是将操作数压入浮点栈。`fstp`指令总是在存储栈顶元素（TOS）后弹出栈顶元素。其余指令不会影响栈中的元素个数。
- en: 6.5.4.1 The fld Instruction
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4.1 `fld` 指令
- en: The `fld` instruction loads a 32-bit, 64-bit, or 80-bit floating-point value
    onto the stack. This instruction converts 32- and 64-bit operands to an 80-bit
    extended-precision value before pushing the value onto the floating-point stack.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`fld`指令将一个32位、64位或80位浮点值加载到栈中。此指令在将值压入浮点栈之前，会将32位和64位操作数转换为80位扩展精度值。'
- en: The `fld` instruction first decrements the TOS pointer (bits 11–13 of the status
    register) and then stores the 80-bit value in the physical register specified
    by the new TOS pointer. If the source operand of the FLD instruction is a floating-point
    data register, `st`*`i`*, then the actual register the FPU uses for the load operation
    is the register number *before* decrementing the TOS pointer. Therefore, `fld(
    st0 );` duplicates the value on the top of the stack.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`fld` 指令首先递减 TOS 指针（状态寄存器的第 11–13 位），然后将 80 位值存储到新 TOS 指针指定的物理寄存器中。如果 FLD 指令的源操作数是一个浮点数据寄存器，`st`*`i`*，那么
    FPU 用于加载操作的实际寄存器是递减 TOS 指针之前的寄存器。因此，`fld( st0 );` 会复制堆栈顶部的值。'
- en: The `fld` instruction sets the stack fault bit if stack overflow occurs. It
    sets the denormalized exception bit if you load an 80-bit denormalized value.
    It sets the invalid operation bit if you attempt to load an empty floating-point
    register onto the top of stack (or perform some other invalid operation).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生堆栈溢出，`fld` 指令会设置堆栈故障位。如果您加载的是 80 位的非正规值，它会设置非正规异常位。如果您尝试将空的浮点寄存器加载到堆栈顶部（或执行其他无效操作），它会设置无效操作位。
- en: 'Here are some examples:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE76]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that there is no way to directly load a 32-bit integer register onto the
    floating-point stack, even if that register contains a `real32` value. To accomplish
    this, you must first store the integer register into a memory location; then you
    can push that memory location onto the FPU stack using the `fld` instruction.
    For example:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有直接将 32 位整数寄存器加载到浮点堆栈中的方法，即使该寄存器包含 `real32` 值。为了实现这一点，您必须首先将整数寄存器存储到内存位置；然后您可以使用
    `fld` 指令将该内存位置压入 FPU 堆栈。例如：
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that loading a constant via `fld` is actually an HLA extension. The FPU
    doesn't support this instruction type. HLA creates a `real80` object in the constants
    segment and uses the address of this memory object as the true operand for `fld`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过 `fld` 加载常量实际上是 HLA 扩展。FPU 不支持这种指令类型。HLA 会在常量段创建一个 `real80` 对象，并使用该内存对象的地址作为
    `fld` 的实际操作数。
- en: 6.5.4.2 The fst and fstp Instructions
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4.2 fst 和 fstp 指令
- en: The `fst` and `fstp` instructions copy the value on the top of the floating-point
    stack to another floating-point register or to a 32-, 64 -, or 80-bit memory variable.
    When copying data to a 32- or 64-bit memory variable, the FPU rounds the 80-bit
    extended-precision value on the top of stack to the smaller format as specified
    by the rounding control bits in the FPU control register.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`fst` 和 `fstp` 指令将浮点堆栈顶部的值复制到另一个浮点寄存器或 32 位、64 位或 80 位的内存变量中。当将数据复制到 32 位或
    64 位内存变量时，FPU 会根据 FPU 控制寄存器中的舍入控制位，将堆栈顶部的 80 位扩展精度值舍入到较小的格式。'
- en: The `fstp` instruction pops the value off the top of the stack when moving it
    to the destination location. It does this by incrementing the TOS pointer in the
    status register after accessing the data in ST0\. If the destination operand is
    a floating-point register, the FPU stores the value at the specified register
    number *before* popping the data off the top of the stack.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`fstp` 指令在将值移动到目标位置时会将其从堆栈顶部弹出。它通过在访问 ST0 中的数据后递增状态寄存器中的 TOS 指针来完成这一操作。如果目标操作数是一个浮点寄存器，FPU
    会在弹出堆栈顶部数据之前，将值存储到指定的寄存器号中。'
- en: 'Executing an `fstp( st0 );` instruction effectively pops the data off the top
    of stack with no data transfer. Here are some examples:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `fstp( st0 );` 指令有效地将堆栈顶部的数据弹出，但没有数据传输。以下是一些示例：
- en: '[PRE78]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The last example above effectively pops ST1 while leaving ST0 on the top of
    stack.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后一个示例有效地弹出了 ST1，同时将 ST0 保留在堆栈顶部。
- en: The `fst` and `fstp` instructions will set the stack exception bit if a stack
    underflow occurs (attempting to store a value from an empty register stack). They
    will set the precision bit if there is a loss of precision during the store operation
    (this will occur, for example, when storing an 80-bit extended-precision value
    into a 32- or 64-bit memory variable and some bits are lost during conversion).
    They will set the underflow exception bit when storing an 80-bit value into a
    32- or 64-bit memory variable, but the value is too small to fit into the destination
    operand. Likewise, these instructions will set the overflow exception bit if the
    value on the top of stack is too big to fit into a 32- or 64-bit memory variable.
    The `fst` and `fstp` instructions set the denormalized flag when you try to store
    a denormalized value into an 80-bit register or variable.^([[103](#ftn.CHP-6-FN-2)])
    They set the invalid operation flag if an invalid operation (such as storing into
    an empty register) occurs. Finally, these instructions set the C[1] condition
    bit if rounding occurs during the store operation (this occurs only when storing
    into a 32- or 64-bit memory variable and you have to round the mantissa to fit
    into the destination).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`fst` 和 `fstp` 指令将在发生栈下溢时设置栈异常标志位（即尝试从空的寄存器栈存储值）。如果在存储操作过程中发生精度丢失，它们将设置精度位（例如，当将一个
    80 位扩展精度值存储到 32 位或 64 位内存变量时，部分位会在转换过程中丢失）。当将一个 80 位的值存储到 32 位或 64 位内存变量时，如果该值太小而无法适配目标操作数，它们将设置下溢异常位。同样，如果栈顶的值太大，无法适配到
    32 位或 64 位内存变量，它们会设置溢出异常位。`fst` 和 `fstp` 指令在你试图将一个非规范值存储到 80 位寄存器或变量时，会设置非规范标志位^[([103](#ftn.CHP-6-FN-2))]。如果发生无效操作（例如存储到空寄存器中），它们会设置无效操作标志位。最后，如果在存储操作过程中发生舍入，它们会设置
    C[1] 条件位（这种情况仅在存储到 32 位或 64 位内存变量时发生，并且需要将尾数舍入以适应目标）。'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because of an idiosyncrasy in the FPU instruction set related to the encoding
    of the instructions, you cannot use the `fst` instruction to store data into a
    `real80` memory variable. You may, however, store 80-bit data using the `fstp`
    instruction.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与指令编码相关的 FPU 指令集中的特殊性，不能使用 `fst` 指令将数据存储到 `real80` 内存变量中。但是，你可以使用 `fstp` 指令存储
    80 位数据。
- en: 6.5.4.3 The fxch Instruction
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4.3 `fxch` 指令
- en: 'The `fxch` instruction exchanges the value on the top of stack with one of
    the other FPU registers. This instruction takes two forms: one with a single FPU
    register as an operand and the second without any operands. The first form exchanges
    the top of stack with the specified register. The second form of `fxch` swaps
    the top of stack with ST1.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`fxch` 指令交换栈顶的值与其他 FPU 寄存器中的值。该指令有两种形式：一种是操作数为单个 FPU 寄存器，另一种是不带操作数。第一种形式交换栈顶与指定寄存器的值；第二种形式的
    `fxch` 会将栈顶与 ST1 交换。'
- en: 'Many FPU instructions, for example, `fsqrt`, operate only on the top of the
    register stack. If you want to perform such an operation on a value that is not
    on the top of stack, you can use the `fxch` instruction to swap that register
    with TOS, perform the desired operation, and then use the `fxch` to swap the TOS
    with the original register. The following example takes the square root of ST2:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 FPU 指令，例如 `fsqrt`，仅对寄存器栈的栈顶进行操作。如果你想对栈顶以外的值执行这样的操作，可以使用 `fxch` 指令交换该寄存器与栈顶寄存器（TOS），执行所需的操作，然后再使用
    `fxch` 指令将栈顶寄存器与原寄存器交换。以下示例演示了如何对 ST2 取平方根：
- en: '[PRE79]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `fxch` instruction sets the stack exception bit if the stack is empty. It
    sets the invalid operation bit if you specify an empty register as the operand.
    This instruction always clears the C[1] condition code bit.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`fxch` 指令在栈为空时设置栈异常位。如果你指定一个空寄存器作为操作数，它会设置无效操作位。该指令始终清除 C[1] 条件码位。'
- en: 6.5.5 Conversions
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.5 转换
- en: The FPU performs all arithmetic operations on 80-bit real quantities. In a sense,
    the `fld` and `fst`/`fstp` instructions are conversion instructions because they
    automatically convert between the internal 80-bit real format and the 32- and
    64-bit memory formats. Nonetheless, we'll simply classify them as data movement
    operations, rather than conversions, because they are moving real values to and
    from memory. The FPU provides six other instructions that convert to or from integer
    or binary-coded decimal (BCD) format when moving data. These instructions are
    `fild`, `fist`, `fistp`, `fisttp`, `fbld`, and `fbstp`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 对 80 位实数进行所有算术操作。从某种意义上说，`fld` 和 `fst`/`fstp` 指令是转换指令，因为它们在 80 位实数格式与 32
    位和 64 位内存格式之间自动转换。然而，我们会将它们简单归类为数据移动操作，而不是转换操作，因为它们是将实数值从内存中移入或移出。FPU 提供了其他六条指令，在移动数据时可以在整数或二进制编码十进制（BCD）格式之间转换。这些指令包括
    `fild`、`fist`、`fistp`、`fisttp`、`fbld` 和 `fbstp`。
- en: 6.5.5.1 The fild Instruction
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5.1 fild 指令
- en: The `fild` (integer load) instruction converts a 16-, 32-, or 64-bit two's complement
    integer to the 80-bit extended-precision format and pushes the result onto the
    stack. This instruction always expects a single operand. This operand must be
    the address of a word, double-word, or quad-word integer variable. You cannot
    specify one of the 80x86's 16- or 32-bit general-purpose registers. If you want
    to push the value of an 80x86 general-purpose register onto the FPU stack, you
    must first store it into a memory variable and then use `fild` to push that memory
    variable.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`fild`（整数加载）指令将 16 位、32 位或 64 位的补码整数转换为 80 位扩展精度格式，并将结果推送到堆栈中。此指令总是期望一个操作数。该操作数必须是字、双字或四字整数变量的地址。你不能指定
    80x86 的 16 位或 32 位通用寄存器。如果你想将 80x86 通用寄存器的值推送到 FPU 堆栈中，必须先将其存储到内存变量中，然后使用 `fild`
    指令将该内存变量推送到堆栈。'
- en: 'The fild instruction sets the stack exception bit and C[1] (accordingly) if
    stack overflow occurs while pushing the converted value. Look at these examples:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在推送转换后的值时发生堆栈溢出，fild 指令会设置堆栈异常位并相应地设置 C[1]。来看一些示例：
- en: '[PRE80]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 6.5.5.2 The fist, fistp, and fisttp Instructions
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5.2 fist、fistp 和 fisttp 指令
- en: The `fist`, `fistp`, and `fisttp` instructions convert the 80-bit extended-precision
    variable on the top of stack to a 16-, 32-, or 64-bit integer and store the result
    away into the memory variable specified by the single operand. The `fist` and
    `fistp` instructions convert the value on TOS to an integer according to the rounding
    setting in the FPU control register (bits 10 and 11). The `fisttp` instruction
    always does the conversion using the truncation mode. As for the `fild` instruction,
    the `fist`, `fistp`, and `fisttp` instructions will not let you specify one of
    the 80x86's general-purpose 16- or 32-bit registers as the destination operand.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`fist`、`fistp` 和 `fisttp` 指令将堆栈顶部的 80 位扩展精度变量转换为 16 位、32 位或 64 位整数，并将结果存储到由单一操作数指定的内存变量中。`fist`
    和 `fistp` 指令根据 FPU 控制寄存器中的舍入设置（第 10 位和第 11 位）将堆栈顶部的值转换为整数。`fisttp` 指令始终使用截断模式进行转换。与
    `fild` 指令类似，`fist`、`fistp` 和 `fisttp` 指令不允许你指定 80x86 的 16 位或 32 位通用寄存器作为目标操作数。'
- en: The `fist` instruction converts the value on the top of stack to an integer
    and then stores the result; it does not otherwise affect the floating-point register
    stack. The `fistp` and `fisttp` instructions pop the value off the floating-point
    register stack after storing the converted value.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`fist` 指令将堆栈顶部的值转换为整数，并存储结果；它不会对浮点寄存器堆栈产生其他影响。`fistp` 和 `fisttp` 指令在存储转换后的值后，会将值从浮点寄存器堆栈中弹出。'
- en: 'These instructions set the stack exception bit if the floating-point register
    stack is empty (this will also clear C[1]). They set the precision (imprecise
    operation) and C[1] bits if rounding occurs (that is, if there is any fractional
    component to the value in ST0). These instructions set the underflow exception
    bit if the result is too small (that is, less than 1 but greater than 0 or less
    than 0 but greater than −1). Here are some examples:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浮点寄存器堆栈为空，这些指令会设置堆栈异常位（这也会清除 C[1]）。如果发生四舍五入（即，如果 ST0 中的值有任何小数部分），它们会设置精度（不精确操作）和
    C[1] 位。如果结果太小（即小于 1 但大于 0，或小于 0 但大于 −1），这些指令会设置下溢异常位。以下是一些示例：
- en: '[PRE81]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Don''t forget that the `fist` and `fistp` instructions use the rounding control
    settings to determine how they will convert the floating-point data to an integer
    during the store operation. Be default, the rounding control is usually set to
    "round" mode; yet most programmers expect `fist`/`fistp` to truncate the decimal
    portion during conversion. If you want `fist`/`fistp` to truncate floating-point
    values when converting them to an integer, you will need to set the rounding control
    bits appropriately in the floating-point control register (or use the `fisttp`
    instruction to truncate the result regardless of the rounding control bits). Here''s
    an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，`fist` 和 `fistp` 指令使用舍入控制设置来决定它们如何在存储操作期间将浮点数据转换为整数。默认情况下，舍入控制通常设置为“舍入”模式；然而，大多数程序员希望
    `fist`/`fistp` 在转换时截断小数部分。如果你希望 `fist`/`fistp` 在将浮点值转换为整数时截断，你需要在浮点控制寄存器中适当地设置舍入控制位（或者使用
    `fisttp` 指令，不论舍入控制位如何，都将结果截断）。这是一个例子：
- en: '[PRE82]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 6.5.5.3 The fbld and fbstp Instructions
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5.3 `fbld` 和 `fbstp` 指令
- en: The `fbld` and `fbstp` instructions load and store 80-bit BCD values. The `fbld`
    instruction converts a BCD value to its 80-bit extended-precision equivalent and
    pushes the result onto the stack. The `fbstp` instruction pops the extended-precision
    real value on TOS, converts it to an 80-bit BCD value (rounding according to the
    bits in the floating-point control register), and stores the converted result
    at the address specified by the destination memory operand. Note that there is
    no `fbst` instruction.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbld` 和 `fbstp` 指令加载和存储 80 位 BCD 值。`fbld` 指令将 BCD 值转换为其 80 位扩展精度等效值，并将结果压入堆栈。`fbstp`
    指令弹出堆栈顶部的扩展精度实数值，将其转换为 80 位 BCD 值（根据浮点控制寄存器中的位进行舍入），并将转换后的结果存储在目标内存操作数指定的地址中。注意，`fbst`
    指令并不存在。'
- en: 'The `fbld` instruction sets the stack exception bit and C[1] if stack overflow
    occurs. It sets the invalid operation bit if you attempt to load an invalid BCD
    value. The `fbstp` instruction sets the stack exception bit and clears C[1] if
    stack underflow occurs (the stack is empty). It sets the underflow flag under
    the same conditions as `fist` and `fistp`. Look at these examples:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbld` 指令在堆栈溢出时设置堆栈异常位和 C[1]。如果尝试加载无效的 BCD 值，它会设置无效操作位。`fbstp` 指令在堆栈下溢（堆栈为空）时设置堆栈异常位并清除
    C[1]。它在与 `fist` 和 `fistp` 相同的条件下设置下溢标志。看看这些例子：'
- en: '[PRE83]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: These two instructions are especially useful for converting between string and
    floating-point formats. See the floating-point-to-string and string-to-floating-point
    conversion routines in the HLA Standard Library for more details.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令特别适用于在字符串格式和浮点格式之间转换。有关更多细节，请参见 HLA 标准库中的浮点到字符串和字符串到浮点转换例程。
- en: 6.5.6 Arithmetic Instructions
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.6 算术指令
- en: 'The arithmetic instructions make up a small but important subset of the FPU''s
    instruction set. These instructions fall into two general categories: those that
    operate on real values and those that operate on a real and an integer value.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 算术指令构成了 FPU 指令集中的一小部分，但却是重要的子集。这些指令大致分为两类：一类作用于实数值，另一类作用于实数和整数值。
- en: 6.5.6.1 The fadd and faddp Instructions
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.1 `fadd` 和 `faddp` 指令
- en: 'These two instructions take the following forms:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令有以下几种形式：
- en: '[PRE84]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `fadd` instruction, with no operands, adds the value in ST0 to the value
    in ST1 and stores the result into ST1\. The `faddp` instruction (with no operands)
    pops the two values on the top of stack, adds them, and pushes their sum back
    onto the stack.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadd` 指令没有操作数时，将 ST0 中的值加到 ST1 中的值，并将结果存储到 ST1 中。`faddp` 指令（没有操作数）弹出堆栈顶部的两个值，将它们相加，并将它们的和重新压入堆栈。'
- en: The next two forms of the `fadd` instruction, those with two FPU register operands,
    behave like the 80x86's `add` instruction. They add the value in the source register
    operand to the value in the destination register operand. Note that one of the
    register operands must be ST0.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadd` 指令的接下来的两种形式，具有两个 FPU 寄存器操作数，行为类似于 80x86 的 `add` 指令。它们将源寄存器操作数中的值加到目标寄存器操作数中的值。注意，其中一个寄存器操作数必须是
    ST0。'
- en: The `faddp` instruction with two operands adds ST0 (which must always be the
    source operand) to the destination operand and then pops ST0\. The destination
    operand must be one of the other FPU registers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`faddp` 指令带有两个操作数，它将 ST0（必须始终是源操作数）加到目标操作数中，然后弹出 ST0。目标操作数必须是其他 FPU 寄存器之一。'
- en: The last form above, `fadd` with a memory operand, adds a 32- or 64-bit floating-point
    variable to the value in ST0\. This instruction will convert the 32- or 64-bit
    operands to an 80-bit extended-precision value before performing the addition.
    Note that this instruction does *not* allow an 80-bit memory operand.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 上面最后的形式，带内存操作数的 `fadd`，将一个 32 位或 64 位浮点变量加到 ST0 中的值。这条指令在执行加法之前会将 32 位或 64 位操作数转换为
    80 位扩展精度值。请注意，这条指令不允许 80 位内存操作数。
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以根据需要触发堆栈、精度、下溢、上溢、非标准化和非法操作异常。如果发生堆栈故障异常，C[1] 表示堆栈溢出或下溢。
- en: Like `fld(` *`real_constant`*`)`, the `fadd(` *`real_constant`* `)` instruction
    is an HLA extension. Note that it creates a 64-bit variable holding the constant
    value and emits the `fadd(` *`mem64`* `)` instruction, specifying the read-only
    object it creates in the constants segment.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `fld(` *`real_constant`* `)`，`fadd(` *`real_constant`* `)` 指令是 HLA 扩展。注意，它创建一个
    64 位变量来保存常数值，并发出 `fadd(` *`mem64`* `)` 指令，指定它在常数段中创建的只读对象。
- en: 6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.2 `fsub`、`fsubp`、`fsubr` 和 `fsurpb` 指令
- en: 'These four instructions take the following forms:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这四条指令采取以下形式：
- en: '[PRE85]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With no operands, the `fsub` instruction subtracts ST0 from ST1 and leaves the
    result in ST1\. With no operands the `fsubp` instruction pops ST0 and ST1 from
    the register stack, computes `st1 - st0` and then pushes the difference back onto
    the stack. The `fsubr` and `fsubrp` instructions (reverse subtraction) operate
    in an almost identical fashion except they compute `st0 - st1`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsub` 指令在没有操作数的情况下将 ST0 从 ST1 中减去，并将结果保留在 ST1 中。没有操作数时，`fsubp` 指令从寄存器堆栈中弹出
    ST0 和 ST1，计算 `st1 - st0`，然后将差值推回堆栈。`fsubr` 和 `fsubrp` 指令（反向减法）几乎以相同的方式工作，唯一的区别是它们计算
    `st0 - st1`。'
- en: With two register operands (*`source`*, *`destination`*) the `fsub` instruction
    computes *`destination`* `:=` *`destination`* `-` *`source`*. One of the two registers
    must be ST0\. With two registers as operands, the `fsubp` also computes *`destination`*
    `:=` *`destination`* `-` *`source`*, and then it pops ST0 off the stack after
    computing the difference. For the `fsubp` instruction, the source operand must
    be ST0.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当有两个寄存器操作数（*`source`*，*`destination`*）时，`fsub` 指令计算 *`destination`* `:=` *`destination`*
    `-` *`source`*。这两个寄存器之一必须是 ST0。对于有两个寄存器作为操作数的 `fsubp`，它也计算 *`destination`* `:=`
    *`destination`* `-` *`source`*，并在计算差值后将 ST0 从堆栈中弹出。对于 `fsubp` 指令，源操作数必须是 ST0。
- en: With two register operands, the `fsubr` and `fsubrp` instructions work in a
    similar fashion to `fsub` and `fsubp`, except they compute *`destination`* `:=`
    *`source`* `-` *`destination`*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 当有两个寄存器操作数时，`fsubr` 和 `fsubrp` 指令的工作方式与 `fsub` 和 `fsubp` 类似，唯一的区别是它们计算 *`destination`*
    `:=` *`source`* `-` *`destination`*。
- en: The `fsub(` *`mem`* `)` and `fsubr(` *`mem`* `)` instructions accept a 32- or
    64-bit memory operand. They convert the memory operand to an 80-bit extended-precision
    value and subtract this from ST0 (`fsub`) or subtract ST0 from this value (`fsubr`)
    and store the result back into ST0.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsub(` *`mem`* `)` 和 `fsubr(` *`mem`* `)` 指令接受 32 位或 64 位内存操作数。它们将内存操作数转换为
    80 位扩展精度值，并将其从 ST0 中减去（`fsub`），或者将 ST0 从该值中减去（`fsubr`），并将结果存储回 ST0 中。'
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以根据需要触发堆栈、精度、下溢、上溢、非标准化和非法操作异常。如果发生堆栈故障异常，C[1] 表示堆栈溢出或下溢。
- en: Note
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The instructions that have real constants as operands aren't true FPU instructions.
    These are extensions provided by HLA. HLA generates a constant segment memory
    object initialized with the constant's value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 具有真实常数作为操作数的指令不是严格的 FPU 指令。这些是 HLA 提供的扩展。HLA 生成一个常数段内存对象，并用常数的值初始化它。
- en: 6.5.6.3 The fmul and fmulp Instructions
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.3 `fmul` 和 `fmulp` 指令
- en: 'The `fmul` and `fmulp` instructions multiply two floating-point values. These
    instructions allow the following forms:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmul` 和 `fmulp` 指令用于相乘两个浮点值。这些指令允许以下形式：'
- en: '[PRE86]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: With no operands, `fmul` will compute `st0 * st1` and store the product into
    ST1\. The `fmulp` instruction, with no operands, will pop ST0 and ST1, multiply
    these values, and push their product back onto the stack. The `fmul` instructions
    with two register operands compute *`destination`* `:=` *`destination`* `*` *`source`*.
    One of the registers (source or destination) must be ST0.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有操作数，`fmul` 将计算 `st0 * st1` 并将乘积存储到 ST1 中。没有操作数的 `fmulp` 指令会弹出 ST0 和 ST1，将这两个值相乘，并将乘积重新压入栈中。带有两个寄存器操作数的
    `fmul` 指令会计算 *`destination`* `:=` *`destination`* `*` *`source`*。其中一个寄存器（源寄存器或目标寄存器）必须是
    ST0。
- en: The `fmulp( st0, st`*`i`* `)` instruction computes `st`*`i`* `:= st`*`i`* `*
    st0` and then pops ST0\. This instruction uses the value for ST*i* before popping
    ST0\. The `fmul(` *`mem`* `)` instruction requires a 32- or 64-bit memory operand.
    It converts the specified memory variable to an 80-bit extended-precision value
    and then multiplies ST0 by this value.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmulp( st0, st`*`i`* `)` 指令计算 `st`*`i`* `:= st`*`i`* `* st0`，然后弹出 ST0。该指令在弹出
    ST0 之前使用 ST*i* 的值。`fmul(` *`mem`* `)` 指令需要一个 32 位或 64 位的内存操作数。它将指定的内存变量转换为 80
    位扩展精度值，然后将 ST0 与该值相乘。'
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If rounding occurs during the
    computation, these instructions set the C[1] condition code bit. If a stack fault
    exception occurs, C[1] denotes stack overflow or underflow.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以根据情况引发栈、精度、下溢、上溢、非正规、以及非法操作异常。如果在计算过程中发生了四舍五入，这些指令会设置 C[1] 条件码位。如果发生栈故障异常，C[1]
    表示栈溢出或下溢。
- en: Note
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The instruction that has a real constant as its operand isn't a true FPU instruction.
    It is an extension provided by HLA (see the note at the end of [6.5.6.2 The fsub,
    fsubp, fsubr, and fsurpb Instructions](ch06s05.html#the_fsub_comma_fsubp_comma_fsubr_comma_a
    "6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions") for details).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数为实常数的指令不是严格意义上的 FPU 指令。它是由 HLA 提供的扩展（有关详细信息，请参阅 [6.5.6.2 fsub, fsubp, fsubr
    和 fsurpb 指令](ch06s05.html#the_fsub_comma_fsubp_comma_fsubr_comma_a) 末尾的注释）。
- en: 6.5.6.4 The fdiv, fdivp, fdivr, and fdivrp Instructions
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.4 fdiv, fdivp, fdivr 和 fdivrp 指令
- en: 'These four instructions allow the following forms:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这四条指令支持以下形式：
- en: '[PRE87]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: With no operands, the `fdivp` instruction pops ST0 and ST1, computes `st1/st0`,
    and pushes the result back onto the stack. The `fdiv` instruction with no operands
    computes `st1 := st1/st0`. The `fdivr` and `fdivrp` instructions work in a similar
    fashion to `fdiv` and `fdivp` except that they compute `st0/st1` rather than `st1/st0`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有操作数，`fdivp` 指令会弹出 ST0 和 ST1，计算 `st1/st0`，并将结果重新压入栈中。没有操作数的 `fdiv` 指令会计算
    `st1 := st1/st0`。`fdivr` 和 `fdivrp` 指令与 `fdiv` 和 `fdivp` 的工作方式相似，只是它们计算的是 `st0/st1`，而不是
    `st1/st0`。
- en: 'With two register operands, these instructions compute the following quotients:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个寄存器操作数，这些指令会计算以下商：
- en: '[PRE88]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `fdivp` and `fdivrp` instructions also pop ST0 after performing the division
    operation. The value for *`i`* in these two instructions is computed before popping
    ST0.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdivp` 和 `fdivrp` 指令在执行除法操作后也会弹出 ST0。这两个指令中的 *`i`* 的值在弹出 ST0 之前就已计算完毕。'
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    zero divide, and illegal operation exceptions, as appropriate. If rounding occurs
    during the computation, these instructions set the C[1] condition code bit. If
    a stack fault exception occurs, C[1] denotes stack overflow or underflow.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以根据情况引发栈、精度、下溢、上溢、非正规、零除以及非法操作异常。如果在计算过程中发生了四舍五入，这些指令会设置 C[1] 条件码位。如果发生栈故障异常，C[1]
    表示栈溢出或下溢。
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作数为实常数的指令不是严格意义上的 FPU 指令。这些是由 HLA 提供的扩展。
- en: 6.5.6.5 The fsqrt Instruction
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.5 fsqrt 指令
- en: The `fsqrt` routine does not allow any operands. It computes the square root
    of the value on top of stack (TOS) and replaces ST0 with this result. The value
    on TOS must be 0 or positive; otherwise `fsqrt` will generate an invalid operation
    exception.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsqrt` 例程不允许任何操作数。它计算栈顶值（TOS）的平方根，并用该结果替换 ST0。TOS 上的值必须为 0 或正数；否则，`fsqrt`
    会生成非法操作异常。'
- en: This instruction can raise the stack, precision, denormalized, and invalid operation
    exceptions, as appropriate. If rounding occurs during the computation, `fsqrt`
    sets the C[1] condition code bit. If a stack fault exception occurs, C[1] denotes
    stack overflow or underflow.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令可以根据需要触发堆栈、精度、非规范化和无效操作异常。如果在计算过程中发生舍入，`fsqrt` 会设置 C[1] 条件码位。如果发生堆栈故障异常，C[1]
    表示堆栈溢出或下溢。
- en: 'Here''s an example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE89]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 6.5.6.6 The fprem and fprem1 Instructions
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.6 fprem 和 fprem1 指令
- en: The `fprem` and `fprem1` instructions compute a *partial remainder*. Intel designed
    the `fprem` instruction before the IEEE finalized its floating-point standard.
    In the final draft of the IEEE floating-point standard, the definition of `fprem`
    was a little different than Intel's original design. Unfortunately, Intel needed
    to maintain compatibility with the existing software that used the `fprem` instruction,
    so it designed a new version to handle the IEEE partial remainder operation, `fprem1`.
    You should always use `fprem1` in new software; therefore we will discuss only
    `fprem1` here, although you use `fprem` in an identical fashion.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`fprem` 和 `fprem1` 指令计算 *部分余数*。英特尔在IEEE最终确定浮点标准之前设计了 `fprem` 指令。在IEEE浮点标准的最终草案中，`fprem`
    的定义与英特尔原始设计略有不同。不幸的是，英特尔需要与现有使用 `fprem` 指令的软件保持兼容，因此设计了一个新版本来处理IEEE部分余数操作，即 `fprem1`。在新的软件中，您应始终使用
    `fprem1`；因此，我们这里只讨论 `fprem1`，尽管您以相同的方式使用 `fprem`。'
- en: '`fprem1` computes the *partial* remainder of `st0/st1`. If the difference between
    the exponents of ST0 and ST1 is less than 64, `fprem1` can compute the exact remainder
    in one operation. Otherwise you will have to execute the `fprem1` two or more
    times to get the correct remainder value. The C[2] condition code bit determines
    when the computation is complete. Note that `fprem1` does *not* pop the two operands
    off the stack; it leaves the partial remainder in ST0 and the original divisor
    in ST1 in case you need to compute another partial product to complete the result.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`fprem1` 计算 `st0/st1` 的 *部分* 余数。如果 ST0 和 ST1 的指数差小于 64，`fprem1` 可以在一次操作中计算出精确的余数。否则，您将需要执行两次或更多次
    `fprem1` 来获取正确的余数值。C[2] 条件码位决定了计算何时完成。请注意，`fprem1` 并不会将两个操作数从堆栈中弹出；它将部分余数保留在 ST0
    中，原始除数保留在 ST1 中，以防您需要计算另一个部分积来完成结果。'
- en: The `fprem1` instruction sets the stack exception flag if there aren't two values
    on the top of stack. It sets the underflow and denormal exception bits if the
    result is too small. It sets the invalid operation bit if the values on TOS are
    inappropriate for this operation. It sets the C[2] condition code bit if the partial
    remainder operation is not complete. Finally, it loads C[3], C[1], and C[0] with
    bits 0, 1, and 2 of the quotient, respectively.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`fprem1` 指令如果堆栈顶部没有两个值，则会设置堆栈异常标志。如果结果太小，它会设置下溢和非规范化异常位。如果 TOS 上的值不适合该操作，它会设置无效操作位。如果部分余数操作未完成，它会设置
    C[2] 条件码位。最后，它会将 C[3]、C[1] 和 C[0] 分别加载为商的第 0、1 和 2 位。'
- en: 'An example follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE90]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 6.5.6.7 The frndint Instruction
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.7 frndint 指令
- en: The `frndint` instruction rounds the value on the top of stack (TOS) to the
    nearest integer using the rounding algorithm specified in the control register.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`frndint` 指令使用控制寄存器中指定的舍入算法，将堆栈顶部（TOS）值舍入到最接近的整数。'
- en: This instruction sets the stack exception flag if there is no value on the TOS
    (it will also clear C[1] in this case). It sets the precision and denormal exception
    bits if there was a loss of precision. It sets the invalid operation flag if the
    value on the TOS is not a valid number. Note that the result on TOS is still a
    floating-point value; it simply does not have a fractional component.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 TOS 上没有值，此指令将设置堆栈异常标志（此时它还会清除 C[1]）。如果出现精度丧失，它会设置精度和非规范化异常位。如果 TOS 上的值不是有效数字，它会设置无效操作标志。请注意，TOS
    上的结果仍然是浮点值；它只是没有小数部分。
- en: 6.5.6.8 The fabs Instruction
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.8 fabs 指令
- en: '`fabs` computes the absolute value of ST0 by clearing the mantissa sign bit
    of ST0\. It sets the stack exception bit and invalid operation bits if the stack
    is empty.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`fabs` 通过清除 ST0 的尾数符号位来计算 ST0 的绝对值。如果堆栈为空，它会设置堆栈异常位和无效操作位。'
- en: 'Here''s an example:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE91]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 6.5.6.9 The fchs Instruction
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6.9 fchs 指令
- en: '`fchs` changes the sign of ST0''s value by inverting the mantissa sign bit
    (that is, this is the floating-point negation instruction). It sets the stack
    exception bit and invalid operation bits if the stack is empty.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`fchs` 通过反转 ST0 值的尾数符号位（即这是浮点数取反指令）来改变 ST0 值的符号。如果堆栈为空，它将设置堆栈异常位和无效操作位。'
- en: 'Look at this example:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子：
- en: '[PRE92]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 6.5.7 Comparison Instructions
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.7 比较指令
- en: The FPU provides several instructions for comparing real values. The `fcom`,
    `fcomp`, and `fcompp` instructions compare the two values on the top of stack
    and set the condition codes appropriately. The `ftst` instruction compares the
    value on the top of stack with 0.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 提供了几条指令用于比较实数值。`fcom`、`fcomp` 和 `fcompp` 指令比较堆栈顶端的两个值，并相应地设置条件码。`ftst` 指令将堆栈顶端的值与
    0 进行比较。
- en: Generally, most programs test the condition code bits immediately after a comparison.
    Unfortunately, there are no FPU instructions that test the FPU condition codes.
    Instead, you use the `fstsw` instruction to copy the floating-point status register
    into the AX register; then you can use the `sahf` instruction to copy the AH register
    into the 80x86's condition code bits. After doing this, you can test the standard
    80x86 flags to check for some condition. This technique copies C[0] into the carry
    flag, C[2] into the parity flag, and C[3] into the zero flag. The `sahf` instruction
    does not copy C[1] into any of the 80x86's flag bits.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数程序在比较后立即测试条件码位。不幸的是，没有 FPU 指令可以测试 FPU 条件码。相反，你需要使用 `fstsw` 指令将浮点状态寄存器复制到
    AX 寄存器；然后可以使用 `sahf` 指令将 AH 寄存器复制到 80x86 的条件码位。完成此操作后，你可以测试标准的 80x86 标志以检查某些条件。此技巧将
    C[0] 复制到进位标志，将 C[2] 复制到奇偶标志，将 C[3] 复制到零标志。`sahf` 指令不会将 C[1] 复制到任何 80x86 标志位。
- en: Because the `sahf` instruction does not copy any FPU status bits into the sign
    or overflow flags, you cannot use signed comparison instructions. Instead, use
    unsigned operations (e.g., `seta`, `setb`) when testing the results of a floating-point
    comparison. *Yes, these instructions normally test unsigned values, and floating-point
    numbers are signed values*. However, use the unsigned operations anyway; the `fstsw`
    and `sahf` instructions set the 80x86 flags register as though you had compared
    unsigned values with the `cmp` instruction.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `sahf` 指令不会将任何 FPU 状态位复制到符号标志或溢出标志，因此不能使用带符号比较指令。相反，在测试浮点比较结果时，应使用无符号操作（例如
    `seta`、`setb`）。*是的，这些指令通常测试无符号值，而浮点数是带符号值*。然而，仍然应使用无符号操作；`fstsw` 和 `sahf` 指令将
    80x86 标志寄存器设置为仿佛你已经使用 `cmp` 指令比较了无符号值。
- en: The Pentium II and (upward) compatible processors provide an extra set of floating-point
    comparison instructions that directly affect the 80x86 condition code flags. These
    instructions circumvent having to use `fstsw` and `sahf` to copy the FPU status
    into the 80x86 condition codes. These instructions include `fcomi` and `fcomip`.
    You use them just like the `fcom` and `fcomp` instructions, except, of course,
    you do not have to manually copy the status bits to the FLAGS register.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: Pentium II 及其兼容的处理器提供了一组额外的浮点比较指令，直接影响 80x86 的条件码标志。这些指令避免了使用 `fstsw` 和 `sahf`
    将 FPU 状态复制到 80x86 条件码的过程。这些指令包括 `fcomi` 和 `fcomip`。使用它们的方法与 `fcom` 和 `fcomp` 指令相同，当然，不需要手动将状态位复制到
    FLAGS 寄存器。
- en: 6.5.7.1 The fcom, fcomp, and fcompp Instructions
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.7.1 `fcom`、`fcomp` 和 `fcompp` 指令
- en: 'The `fcom`, `fcomp`, and `fcompp` instructions compare ST0 to the specified
    operand and set the corresponding FPU condition code bits based on the result
    of the comparison. The legal forms for these instructions are:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcom`、`fcomp` 和 `fcompp` 指令将 ST0 与指定的操作数进行比较，并根据比较结果设置相应的 FPU 状态码位。这些指令的合法形式如下：'
- en: '[PRE93]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: With no operands, `fcom`, `fcomp`, and `fcompp` compare ST0 against ST1 and
    set the FPU flags accordingly. In addition, `fcomp` pops ST0 off the stack and
    `fcompp` pops both ST0 and ST1 off the stack.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有操作数的情况下，`fcom`、`fcomp` 和 `fcompp` 将 ST0 与 ST1 进行比较，并相应地设置 FPU 标志。此外，`fcomp`
    会将 ST0 弹出堆栈，而 `fcompp` 会将 ST0 和 ST1 都从堆栈中弹出。
- en: With a single-register operand, `fcom` and `fcomp` compare `ST0` against the
    specified register. `fcomp` also pops ST0 after the comparison.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在单寄存器操作数的情况下，`fcom` 和 `fcomp` 将 `ST0` 与指定的寄存器进行比较。`fcomp` 在比较后也会弹出 ST0。
- en: With a 32- or 64-bit memory operand, the `fcom` and `fcomp` instructions convert
    the memory variable to an 80-bit extended-precision value and then compare ST0
    against this value, setting the condition code bits accordingly. `fcomp` also
    pops ST0 after the comparison.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位或64位内存操作数，`fcom`和`fcomp`指令将内存变量转换为80位扩展精度值，然后将ST0与此值进行比较，并相应地设置条件码位。`fcomp`在比较后还会弹出ST0。
- en: These instructions set C[2] (which winds up in the parity flag) if the two operands
    are not comparable (e.g., `NaN`). If it is possible for an illegal floating-point
    value to wind up in a comparison, you should check the parity flag for an error
    before checking the desired condition (e.g., using HLA's `@p` and `@np` conditions,
    or by using the `setp`/`setnp` instructions).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数不可比较（例如，`NaN`），这些指令会设置C[2]（它最终会影响到奇偶标志）。如果在比较中可能出现非法的浮点值，应该在检查期望条件之前，先检查奇偶标志以确认是否有错误（例如，使用HLA的`@p`和`@np`条件，或者使用`setp`/`setnp`指令）。
- en: These instructions set the stack fault bit if there aren't two items on the
    top of the register stack. They set the denormalized exception bit if either or
    both operands are denormalized. They set the invalid operation flag if either
    or both operands are quiet `NaN`s. These instructions always clear the C[1] condition
    code.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果寄存器栈顶部没有两个项，这些指令会设置堆栈故障位。如果操作数之一或两者是非正规化数，它们会设置非正规化异常位。如果操作数之一或两者是安静的`NaN`，它们会设置无效操作标志。这些指令总是清除C[1]条件码。
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA. When HLA encounters such
    an instruction, it creates a `real64` read-only variable in the constants segment
    and initializes this variable with the specified constant. Then HLA translates
    the instruction to one that specifies a `real64` memory operand.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有实数常量作为操作数的指令并不是真正的FPU指令。这些是HLA提供的扩展。当HLA遇到这样的指令时，它会在常量段创建一个`real64`只读变量，并将此变量初始化为指定的常量。然后，HLA将指令翻译为指定`real64`内存操作数的指令。
- en: Note
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because of the precision differences (64 bits versus 80 bits), if you use a
    constant operand in a floating-point instruction you may not get results that
    are as precise as you would expect.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精度差异（64位与80位），如果在浮点指令中使用常量操作数，你可能不会得到与预期相符的精确结果。
- en: 'Let''s look at an example of a floating-point comparison:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个浮点比较的示例：
- en: '[PRE94]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Note that you cannot compare floating-point values in an HLA runtime boolean
    expression (e.g., within an `if` statement). You may, however, test the conditions
    in such statements after a floating-point comparison like the sequence above.
    For example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能在HLA运行时的布尔表达式中比较浮点值（例如，在`if`语句中）。然而，在浮点比较之后，你可以在这些语句中测试条件，就像上面的序列一样。例如：
- en: '[PRE95]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 6.5.7.2 The fcomi and fcomip Instructions
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.7.2 `fcomi`和`fcomip`指令
- en: 'The `fcomi` and `fcomip` instructions compare ST0 to the specified operand
    and set the corresponding EFLAG condition code bits based on the result of the
    comparison. You use these instructions in a similar manner to `fcom` and `fcomp`
    except you can test the CPU''s flag bits directly after the execution of these
    instructions without first moving the FPU status bits into the EFLAGS register.
    The legal forms for these instructions are as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcomi`和`fcomip`指令将ST0与指定的操作数进行比较，并根据比较结果设置相应的EFLAG条件码位。你可以像使用`fcom`和`fcomp`一样使用这些指令，只是执行这些指令后，你可以直接测试CPU的标志位，而无需先将FPU状态位移动到EFLAGS寄存器。这些指令的合法形式如下：'
- en: '[PRE96]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 6.5.7.3 The ftst Instruction
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.7.3 `ftst` 指令
- en: The `ftst` instruction compares the value in ST0 against 0.0\. It behaves just
    like the `fcom` instruction would if ST1 contained 0.0\. Note that this instruction
    does not differentiate −0.0 from +0.0\. If the value in ST0 is either of these
    values, `ftst` will set C[3] to denote equality. This instruction does *not* pop
    ST0 off the stack.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftst`指令将ST0中的值与0.0进行比较。它的行为就像`fcom`指令，如果ST1中包含0.0。注意，这个指令不会区分−0.0和+0.0。如果ST0中的值是这两个值之一，`ftst`将设置C[3]来表示相等。这个指令*不会*弹出ST0。'
- en: 'Here''s an example:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE97]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 6.5.8 Constant Instructions
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.8 常量指令
- en: 'The FPU provides several instructions that let you load commonly used constants
    onto the FPU''s register stack. These instructions set the stack fault, invalid
    operation, and C[1] flags if a stack overflow occurs; they do not otherwise affect
    the FPU flags. The specific instructions in this category include the following:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 提供了几个指令，允许你将常用的常数加载到 FPU 的寄存器堆栈中。如果发生堆栈溢出，这些指令会设置堆栈故障、无效操作和 C[1] 标志；否则，它们不会影响
    FPU 标志。此类别中的特定指令包括以下内容：
- en: '[PRE98]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 6.5.9 Transcendental Instructions
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.9 超越函数指令
- en: The FPU provides eight transcendental (logarithmic and trigonometric) instructions
    to compute sine, cosine, partial tangent, partial arctangent, 2*x* - 1, *y* *
    log[2](*x*), and *y* * log[2](*x* + 1). Using various algebraic identities, it
    is easy to compute most of the other common transcendental functions using these
    instructions.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 提供了八个超越函数（对数和三角函数）指令，用于计算正弦、余弦、部分正切、部分反正切、2*x* - 1、*y* * log[2](*x*) 和 *y*
    * log[2](*x* + 1)。通过使用各种代数恒等式，可以方便地使用这些指令计算其他常见的超越函数。
- en: 6.5.9.1 The f2xm1 Instruction
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.1 f2xm1 指令
- en: '`f2xm1` computes 2^(ST0) - 1\. The value in ST0 must be in the range −1.0..ST0..+1.0\.
    If ST0 is out of range, `f2xm1` generates an undefined result but raises no exceptions.
    The computed value replaces the value in ST0.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`f2xm1` 计算 2^(ST0) - 1。ST0 中的值必须在 −1.0 到 ST0 到 +1.0 的范围内。如果 ST0 超出此范围，`f2xm1`
    会生成未定义的结果，但不会引发异常。计算得到的值会替换 ST0 中的值。'
- en: Here's an example computing 10^(*x*) using the identity 10^(*x*) = 2^(*x* *log2(10)).
    This is only useful for a small range of *x* that doesn't put ST0 outside of the
    previously mentioned valid range.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，使用恒等式 10^(*x*) = 2^(*x* *log2(10)) 来计算 10^(*x*)。这仅对 *x* 在一个小范围内有效，避免
    ST0 超出前述有效范围。
- en: '[PRE99]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note that `f2xm1` computes 2*x* - 1, which is why the code above adds 1.0 to
    the result at the end of the computation.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`f2xm1` 计算的是 2*x* - 1，这就是为什么上述代码在计算结束时要加 1.0。
- en: 6.5.9.2 The fsin, fcos, and fsincos Instructions
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.2 fsin、fcos 和 fsincos 指令
- en: These instructions pop the value off the top of the register stack and compute
    the sine, cosine, or both and push the result(s) back onto the stack. The `fsincos`
    instruction pushes the sine followed by the cosine of the original operand; hence
    it leaves cos(ST0) in ST0 and sin(ST0) in ST1.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将栈顶的值弹出，计算正弦、余弦或两者，然后将结果推回栈中。`fsincos` 指令首先推送原操作数的正弦值，然后推送余弦值；因此，它将 cos(ST0)
    保存在 ST0 中，并将 sin(ST0) 保存在 ST1 中。
- en: These instructions assume ST0 specifies an angle in radians and this angle must
    be in the range −2^(63) < ST0 < +2^(63). If the original operand is out of range,
    these instructions set the C[2] flag and leave ST0 unchanged. You can use the
    `fprem1` instruction, with a divisor of 2π, to reduce the operand to a reasonable
    range.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令假定 ST0 指定的是弧度角度，并且该角度必须在 −2^(63) < ST0 < +2^(63) 的范围内。如果原操作数超出此范围，这些指令会设置
    C[2] 标志，并保持 ST0 不变。你可以使用 `fprem1` 指令，将除数设为 2π，来将操作数限制在合理的范围内。
- en: These instructions set the stack fault/C[1], precision, underflow, denormalized,
    and invalid operation flags according to the result of the computation.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令会根据计算结果设置堆栈故障/C[1]、精度、下溢、非标准化和无效操作标志。
- en: 6.5.9.3 The fptan Instruction
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.3 fptan 指令
- en: '`fptan` computes the tangent of ST0 and pushes this value, and then it pushes
    1.0 onto the stack. Like the `fsin` and `fcos` instructions, the value of ST0
    must be in radians and in the range −2^(63) < ST0 < +2^(63). If the value is outside
    this range, `fptan` sets C[2] to indicate that the conversion did not take place.
    As with the `fsin`, `fcos`, and `fsincos` instructions, you can use the `fprem1`
    instruction to reduce this operand to a reasonable range using a divisor of 2π.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`fptan` 计算 ST0 的正切并将该值推送到栈上，然后将 1.0 推送到栈上。与 `fsin` 和 `fcos` 指令类似，ST0 的值必须为弧度，并且在
    −2^(63) < ST0 < +2^(63) 的范围内。如果值超出此范围，`fptan` 会设置 C[2] 标志，表示转换未发生。与 `fsin`、`fcos`
    和 `fsincos` 指令一样，你可以使用 `fprem1` 指令，使用 2π 作为除数，将操作数限制在合理范围内。'
- en: If the argument is invalid (i.e., zero or π radians, which causes a division
    by 0), the result is undefined and this instruction raises no exceptions. `fptan`
    will set the stack fault, precision, underflow, denormal, invalid operation, C[2],
    and C[1] bits as required by the operation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数无效（即为零或 π 弧度，导致除以 0），则结果是未定义的，并且该指令不会引发异常。`fptan` 会根据操作要求设置堆栈故障、精度、下溢、非标准化、无效操作、C[2]
    和 C[1] 位。
- en: 6.5.9.4 The fpatan Instruction
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.4 fpatan 指令
- en: This instruction expects two values on the top of stack. It pops them and computes
    ST0 = tan^(−1)(ST1/ST0).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令期望栈顶有两个值。它将它们弹出并计算 ST0 = tan^(−1)(ST1/ST0)。
- en: The resulting value is the arctangent of the ratio on the stack expressed in
    radians. If you have a value you wish to compute the tangent of, use `fld1` to
    create the appropriate ratio and then execute the `fpatan` instruction.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 结果值是栈上比值的反正切，单位为弧度。如果你有一个值需要计算其正切，可以使用 `fld1` 创建适当的比值，然后执行 `fpatan` 指令。
- en: This instruction affects the stack fault/C[1], precision, underflow, denormal,
    and invalid operation bits if a problem occurs during the computation. It sets
    the C[1] condition code bit if it has to round the result.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令会影响栈故障/C[1]、精度、下溢、非正规化和无效操作位，如果计算过程中出现问题。如果必须对结果进行舍入，它会设置 C[1] 条件码位。
- en: 6.5.9.5 The fyl2x Instruction
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.5 fyl2x 指令
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0).'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令期望 FPU 栈中有两个操作数：`y` 位于 ST1，`x` 位于 ST0。此函数计算 ST0 = ST1 * log[2](ST0)。
- en: 'This instruction has no operands (to the instruction itself ). The instruction
    uses the following syntax:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令没有操作数（对指令本身而言）。此指令使用以下语法：
- en: '[PRE100]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note that this instruction computes the base-2 logarithm. Of course, it is a
    trivial matter to compute the log of any other base by multiplying by the appropriate
    constant.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此指令计算的是以 2 为底的对数。当然，通过乘以适当的常数，计算其他底数的对数是非常简单的。
- en: 6.5.9.6 The fyl2xp1 Instruction
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.9.6 fyl2xp1 指令
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0 + 1.0).'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令期望 FPU 栈中有两个操作数：`y` 位于 ST1，`x` 位于 ST0。此函数计算 ST0 = ST1 * log[2](ST0 + 1.0)。
- en: 'The syntax for this instruction is:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令的语法如下：
- en: '[PRE101]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Otherwise, the instruction is identical to `fyl2x`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，此指令与 `fyl2x` 相同。
- en: 6.5.10 Miscellaneous Instructions
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.10 杂项指令
- en: The FPU includes several additional instructions that control the FPU, synchronize
    operations, and let you test or set various status bits. These instructions include
    `finit`/`fninit`, `fldcw`, `fstcw`, `fclex`/`fnclex`, and `fstsw`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 包含若干额外的指令，用于控制 FPU、同步操作，并让你测试或设置各种状态位。这些指令包括 `finit`/`fninit`、`fldcw`、`fstcw`、`fclex`/`fnclex`
    和 `fstsw`。
- en: 6.5.10.1 The finit and fninit Instructions
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.10.1 finit 和 fninit 指令
- en: The `finit` instruction initializes the FPU for proper operation. Your applications
    should execute this instruction before executing any other FPU instructions. This
    instruction initializes the control register to $37F, the status register to 0,
    and the tag word to $FFFF. The other registers are unaffected.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`finit` 指令初始化 FPU 以确保正确操作。您的应用程序应该在执行其他任何 FPU 指令之前执行此指令。此指令将控制寄存器初始化为 $37F，状态寄存器初始化为
    0，标签字初始化为 $FFFF。其他寄存器不受影响。'
- en: 'Here are some examples:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '[PRE102]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The difference between `finit` and `fninit` is that `finit` first checks for
    any pending floating-point exceptions before initializing the FPU; `fninit` does
    not.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`finit` 和 `fninit` 的区别在于，`finit` 在初始化 FPU 之前会检查是否有任何待处理的浮点异常；而 `fninit` 不会。'
- en: 6.5.10.2 The fldcw and fstcw Instructions
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.10.2 fldcw 和 fstcw 指令
- en: 'The `fldcw` and `fstcw` instructions require a single 16-bit memory operand:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`fldcw` 和 `fstcw` 指令需要一个 16 位内存操作数：'
- en: '[PRE103]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: These two instructions load the control register from a memory location (`fldcw`)
    or store the control word to a 16-bit memory location (`fstcw`).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令分别从内存位置加载控制寄存器（`fldcw`）或将控制字存储到 16 位内存位置（`fstcw`）。
- en: When using the `fldcw` instruction to turn on one of the exceptions, if the
    corresponding exception flag is set when you enable that exception, the FPU will
    generate an immediate interrupt before the CPU executes the next instruction.
    Therefore, you should use the `fclex` instruction to clear any pending interrupts
    before changing the FPU exception enable bits.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `fldcw` 指令开启某个异常时，如果在启用该异常时相应的异常标志已设置，FPU 会在 CPU 执行下一个指令之前生成一个即时中断。因此，在更改
    FPU 异常使能位之前，应该使用 `fclex` 指令清除任何待处理的中断。
- en: 6.5.10.3 The fclex and fnclex Instructions
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.10.3 fclex 和 fnclex 指令
- en: The `fclex` and `fnclex` instructions clear all exception bits, the stack fault
    bit, and the busy flag in the FPU status register.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`fclex` 和 `fnclex` 指令清除所有异常位、栈故障位以及 FPU 状态寄存器中的忙碌标志。'
- en: 'Here are some examples:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '[PRE104]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The difference between these instructions is the same as between `finit` and
    `fninit`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令之间的区别与 `finit` 和 `fninit` 之间的区别相同。
- en: 6.5.10.4 The fstsw and fnstsw Instructions
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.10.4 `fstsw` 和 `fnstsw` 指令
- en: These instructions store the FPU status register into a 16-bit memory location
    or the AX register.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 FPU 状态寄存器存储到一个 16 位内存位置或 AX 寄存器中。
- en: '[PRE105]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: These instructions are unusual in the sense that they can copy an FPU value
    into one of the 80x86 general-purpose registers (specifically, AX). Of course,
    the whole purpose behind allowing the transfer of the status register into AX
    is to allow the CPU to easily test the condition code register with the `sahf`
    instruction. The difference between `fstsw` and `fnstsw` is the same as for `fclex`
    and `fnclex`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令不同寻常，因为它们可以将 FPU 值复制到其中一个 80x86 通用寄存器（具体是 AX）。当然，允许将状态寄存器传输到 AX 的整个目的，是为了让
    CPU 能够轻松通过 `sahf` 指令测试条件码寄存器。`fstsw` 和 `fnstsw` 之间的区别与 `fclex` 和 `fnclex` 之间的区别相同。
- en: 6.5.11 Integer Operations
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.11 整数操作
- en: 'The FPU provides special instructions that combine integer-to-extended-precision
    conversion with various arithmetic and comparison operations. These instructions
    are the following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 提供了特殊指令，结合了整数到扩展精度转换以及各种算术和比较操作。以下是这些指令：
- en: '[PRE106]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: These instructions convert their 16- or 32-bit integer operands to an 80-bit
    extended-precision floating-point value and then use this value as the source
    operand for the specified operation. These instructions use ST0 as the destination
    operand.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将它们的 16 位或 32 位整数操作数转换为 80 位扩展精度浮点值，然后将该值作为指定操作的源操作数。这些指令使用 ST0 作为目标操作数。
- en: '* * *'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[102](#CHP-6-FN-1)]) Intel has also referred to this device as the Numeric
    Data Processor (NDP), Numeric Processor Extension (NPX), and math coprocessor.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[102](#CHP-6-FN-1)]) 英特尔还将该设备称为数字数据处理器（NDP）、数字处理器扩展（NPX）以及数学协处理器。
- en: ^([[103](#CHP-6-FN-2)]) Storing a denormalized value into a 32- or 64-bit memory
    variable will always set the underflow exception bit.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[103](#CHP-6-FN-2)]) 将一个非标准化值存储到 32 位或 64 位内存变量中将始终设置下溢异常位。
- en: 6.6 Converting Floating-Point Expressions to Assembly Language
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 将浮点表达式转换为汇编语言
- en: Because the FPU register organization is different than the 80x86 integer register
    set, translating arithmetic expressions involving floating-point operands is a
    little different than the techniques for translating integer expressions. Therefore,
    it makes sense to spend some time discussing how to manually translate floating-point
    expressions into assembly language.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FPU 寄存器组织与 80x86 整数寄存器集不同，涉及浮点操作数的算术表达式翻译与整数表达式的翻译技巧有所不同。因此，花一些时间讨论如何手动将浮点表达式翻译为汇编语言是很有意义的。
- en: In one respect, it's actually easier to translate floating-point expressions
    into assembly language. The stack architecture of the Intel FPU eases the translation
    of arithmetic expressions into assembly language. If you've ever used a Hewlett-Packard
    calculator, you'll be right at home on the FPU because, like the HP calculator,
    the FPU uses *postfix notation* (also called *Reverse Polish notation*, or *RPN*
    ), for arithmetic operations. Once you get used to using postfix notation, it's
    actually a bit more convenient for translating expressions because you don't have
    to worry about allocating temporary variables—they always wind up on the FPU stack.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个方面来说，将浮点表达式翻译成汇编语言其实更容易。英特尔 FPU 的堆栈架构简化了将算术表达式翻译为汇编语言的过程。如果你曾使用过惠普计算器，你会发现自己很容易上手
    FPU，因为像惠普计算器一样，FPU 使用*后缀表示法*（也叫做*逆波兰表示法*，或 *RPN*）进行算术操作。一旦习惯了使用后缀表示法，翻译表达式实际上更方便，因为你无需担心分配临时变量——它们总是会出现在
    FPU 堆栈上。
- en: 'Postfix notation, as opposed to standard *infix notation*, places the operands
    before the operator. The following examples give some simple examples of infix
    notation and the corresponding postfix notation:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀表示法与标准的 *中缀表示法* 相对，将操作数放在运算符之前。以下示例展示了中缀表示法和对应的后缀表示法的一些简单例子：
- en: '[PRE107]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A postfix expression like `5 6 +` says, "push 5 onto the stack, push 6 onto
    the stack, and then pop the value off the top of stack (6) and add it to the new
    top of stack." Sound familiar? This is exactly what the `fld` and `fadd` instructions
    do. In fact, you can calculate this using the following code:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `5 6 +` 这样的后缀表达式表示：“将 5 推送到堆栈，将 6 推送到堆栈，然后从堆栈顶部弹出值（6），并将其加到新的堆栈顶部。”听起来熟悉吗？这正是
    `fld` 和 `fadd` 指令所做的。事实上，你可以使用以下代码来计算这个：
- en: '[PRE108]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As you can see, postfix is a convenient notation because it's very easy to translate
    this code into FPU instructions.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，后缀表示法是一种方便的符号，因为它非常容易将此代码转换为FPU指令。
- en: 'One advantage to postfix notation is that it doesn''t require any parentheses.
    The following examples demonstrate some slightly more complex infix-to-postfix
    conversions:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀表示法的一个优点是它不需要括号。以下示例演示了几个稍微复杂的中缀到后缀的转换：
- en: '[PRE109]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The postfix expression `x y + 2 *` says, "Push `x`, then push `y`; next, add
    those values on the stack (producing `x + y` on the stack). Next, push 2 and then
    multiply the two values (2 and `x + y`) on the stack to produce two times the
    quantity `x + y`." Once again, we can translate these postfix expressions directly
    into assembly language. The following code demonstrates the conversion for each
    of the above expressions:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀表达式`x y + 2 *`的意思是：“先推送`x`，然后推送`y`；接下来，将栈中的这两个值相加（生成`x + y`）。接着，推送2，并将栈中的两个值（2和`x
    + y`）相乘，得到`2 * (x + y)`。”同样，我们可以直接将这些后缀表达式转换为汇编语言。以下代码展示了上述每个表达式的转换：
- en: '[PRE110]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 6.6.1 Converting Arithmetic Expressions to Postfix Notation
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.1 将算术表达式转换为后缀表示法
- en: Because the process of translating arithmetic expressions into assembly language
    involves postfix notation (RPN), converting arithmetic expressions into postfix
    notation seems like a good place to begin our discussion of floating-point expression
    conversion. This section will concentrate on postfix conversion.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将算术表达式转换为汇编语言涉及后缀表示法（RPN），将算术表达式转换为后缀表示法似乎是我们讨论浮动点表达式转换的一个不错的起点。本节将集中讨论后缀转换。
- en: For simple expressions, those involving two operands and a single expression,
    the translation is trivial. Simply move the operator from the infix position to
    the postfix position (that is, move the operator from between the operands to
    after the second operand). For example, `5 + 6` becomes `5 6 +`. Other than separating
    your operands so you don't confuse them (i.e., is it 5 and 6 or 56?), converting
    simple infix expressions into postfix notation is straightforward.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的表达式，涉及两个操作数和一个单一操作符的转换是很简单的。只需将操作符从中缀位置移到后缀位置（即，将操作符从两个操作数之间移到第二个操作数之后）。例如，`5
    + 6`变为`5 6 +`。除了将操作数分开以避免混淆（即，它是5和6还是56？），将简单的中缀表达式转换为后缀表示法是直接的。
- en: For complex expressions, the idea is to convert the simple subexpressions into
    postfix notation and then treat each converted subexpression as a single operand
    in the remaining expression. The following discussion surrounds completed conversions
    with square brackets so it is easy to see which text needs to be treated as a
    single operand in the conversion.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂表达式，思路是将简单的子表达式转换为后缀表示法，然后将每个转换后的子表达式视为剩余表达式中的一个单独操作数。以下讨论围绕已完成的转换，并使用方括号使得很容易看出哪些文本需要作为单一操作数进行转换。
- en: 'As for integer expression conversion, the best place to start is in the innermost
    parenthetical subexpression and then work your way outward considering precedence,
    associativity, and other parenthetical subexpressions. As a concrete working example,
    consider the following expression:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 至于整数表达式转换，最好的做法是从最内层的括号子表达式开始，然后向外处理，考虑优先级、结合性以及其他括号子表达式。作为一个具体的示例，考虑以下表达式：
- en: '[PRE111]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'A possible first translation is to convert the subexpression `(y - z)` into
    postfix notation:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的首次转换是将子表达式`(y - z)`转换为后缀表示法：
- en: '[PRE112]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Square brackets surround the converted postfix code just to separate it from
    the infix code. These exist only to make the partial translations more readable.
    Remember, for the purposes of conversion we will treat the text inside the square
    brackets as a single operand. Therefore, you would treat `[y z -]` as though it
    were a single variable name or constant.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号包围着转换后的后缀代码，以将其与中缀代码区分开。这些方括号仅用于使部分转换更易于阅读。请记住，在转换过程中，我们将方括号内的文本视为单一的操作数。因此，您应将`[y
    z -]`视为一个单独的变量名或常量。
- en: 'The next step is to translate the subexpression `([y z -] * a )` into postfix
    form. This yields the following:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将子表达式`([y z -] * a )`转换为后缀形式。结果如下：
- en: '[PRE113]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we work on the parenthetical expression `( a + b * c )`. Because multiplication
    has higher precedence than addition, we convert `b * c` first:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理括号表达式`(a + b * c)`。由于乘法的优先级高于加法，我们首先转换`b * c`：
- en: '[PRE114]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'After converting `b * c` we finish the parenthetical expression:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换`b * c`后，我们完成了括号表达式：
- en: '[PRE115]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This leaves only two infix operators: subtraction and division. Because division
    has the higher precedence, we''ll convert that first:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这只剩下两个中缀运算符：减法和除法。因为除法优先级更高，我们首先转换除法：
- en: '[PRE116]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finally, we convert the entire expression into postfix notation by dealing
    with the last infix operation, subtraction:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过处理最后一个中缀运算（减法）将整个表达式转换为后缀表示法：
- en: '[PRE117]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Removing the square brackets to give us true postfix notation yields the following
    postfix expression:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 去掉方括号，得到真正的后缀表示法，得到如下后缀表达式：
- en: '[PRE118]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The following steps demonstrate another infix-to-postfix conversion for the
    expression:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了另一个中缀到后缀的转换过程：
- en: '[PRE119]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Work inside the parentheses. Because multiplication has the highest precedence,
    convert that first:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在括号内进行操作。由于乘法具有最高优先级，先转换乘法：
- en: '[PRE120]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Still working inside the parentheses, we note that addition and subtraction
    have the same precedence, so we rely on associativity to determine what to do
    next. These operators are left associative, so we must translate the expressions
    in a left-to-right order. This means translate the subtraction operator first:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在括号内工作，我们注意到加法和减法具有相同的优先级，因此我们依赖结合性来决定下一步该做什么。这些运算符是左结合的，因此我们必须按照从左到右的顺序翻译表达式。这意味着首先翻译减法运算符：
- en: '[PRE121]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now translate the addition operator inside the parentheses. Because this finishes
    the parenthetical operators, we can drop the parentheses:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在翻译括号内的加法运算符。因为这完成了括号内的运算符，我们可以去掉括号：
- en: '[PRE122]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Translate the final infix operator (division). This yields the following:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换最后的中缀运算符（除法）。得到如下结果：
- en: '[PRE123]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Drop the square brackets and we''re done:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去掉方括号，完成：
- en: '[PRE124]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 6.6.2 Converting Postfix Notation to Assembly Language
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.2 后缀表示法转换为汇编语言
- en: Once you've translated an arithmetic expression into postfix notation, finishing
    the conversion to assembly language is easy. All you have to do is issue an `fld`
    instruction whenever you encounter an operand and issue an appropriate arithmetic
    instruction when you encounter an operator. This section uses the completed examples
    from the previous section to demonstrate how little there is to this process.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将算术表达式转换为后缀表示法，完成到汇编语言的转换就变得很容易。你所要做的就是每次遇到操作数时发出 `fld` 指令，每次遇到运算符时发出相应的算术指令。本节使用上一节的完整示例来展示这个过程是多么简单。
- en: '[PRE125]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Convert `y` to `fld(y)`.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `y` 转换为 `fld(y)`。
- en: Convert `z` to `fld(z)`.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `z` 转换为 `fld(z)`。
- en: Convert `-` to `fsub()`.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `-` 转换为 `fsub()`。
- en: Convert `a` to `fld(a)`.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `a` 转换为 `fld(a)`。
- en: Convert `*` to `fmul()`.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `*` 转换为 `fmul()`。
- en: 'Continuing in a left-to-right fashion, generate the following code for the
    expression:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照从左到右的顺序继续，生成以下表达式的代码：
- en: '[PRE126]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Here''s the translation for the second example in the previous section:'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是上一节中第二个示例的翻译：
- en: '[PRE127]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: As you can see, the translation is fairly simple once you've converted the infix
    notation to postfix notation. Also note that, unlike integer expression conversion,
    you don't need any explicit temporaries. It turns out that the FPU stack provides
    the temporaries for you.^([[104](#ftn.CHP-6-FN-3)]) For these reasons, conversion
    of floating-point expressions into assembly language is actually easier than converting
    integer expressions.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦你将中缀表示法转换为后缀表示法，翻译过程就相当简单了。还要注意，与整数表达式转换不同，浮点表达式不需要显式的临时变量。事实证明，FPU
    栈为你提供了临时变量。^([[104](#ftn.CHP-6-FN-3)]) 基于这些原因，浮点表达式转换为汇编语言实际上比整数表达式更简单。
- en: '* * *'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[104](#CHP-6-FN-3)]) This assumes, of course, that your calculations aren't
    so complex that you exceed the eight-element limitation of the FPU stack.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[104](#CHP-6-FN-3)]) 当然，这假设你的计算并不复杂到超出了 FPU 栈的八元素限制。
- en: 6.7 HLA Standard Library Support for Floating-Point Arithmetic
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 HLA 标准库对浮点算术的支持
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") briefly mentioned the
    `stdin.getf` function. What it left out of that discussion is where `stdin.getf`
    returns the floating-point value is reads from the standard input. Now that you''ve
    seen the floating-point extensions to the 80x86, it''s possible to finish the
    discussion of that standard library function. The `stdin.getf` function reads
    a string of characters from the standard input, converts those characters to an
    80-bit floating-point number, and leaves the result sitting on the FPU stack (in
    ST0).'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library also provides the `math.hhf` module that includes several
    mathematical functions that the FPU doesn't directly support as well as support
    for various functions (like sine and cosine) that the FPU partially supports.
    Some of the functions that the `math.hhf` module provides are `acos`, `acot`,
    `acsc`, `asec`, `asin`, `cot`, `csc`, `sec`, `2^x`, `10^x`, `y^x`, `e^x`, `log`,
    and `ln`. Please consult the HLA standard library documentation for more information
    about these functions and other mathematical functions the HLA standard library
    supports.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 For More Information
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Intel/AMD processor manuals fully describe the operation of each of the
    integer and floating-point arithmetic instructions, including a detailed description
    of how these instructions affect the condition code bits and other flags in the
    EFLAGS and FPU status registers. To write the best possible assembly language
    code, you need to be intimately familiar with how the arithmetic instructions
    affect the execution environment, so spending time with the Intel/AMD manuals
    is a good idea.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library provides a large number of floating-point functions
    for which there are no individual machine instructions. The HLA Standard Library
    also provides functions like `math.sin` and `math.cos` that overcome limitations
    of the native machine instructions. See the HLA Standard Library reference manual
    for more details. Also, the HLA Standard Library is available in source code form,
    so you can look at the implementation of these mathematical functions for more
    examples of floating-point coding.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") discusses multiprecision
    integer arithmetic. See that chapter for details on handling integer operands
    that are greater than 32 bits in size.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 SSE instruction set found on later members of the CPU provides support
    for floating-point arithmetic using the SSE register set. Consult [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or the Intel/AMD documentation for details concerning the SSE floating-point instruction
    set.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
