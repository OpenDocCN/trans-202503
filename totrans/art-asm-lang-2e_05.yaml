- en: Chapter 6. ARITHMETIC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![ARITHMETIC](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses arithmetic computation in assembly language. By the end
    of this chapter you should be able to translate arithmetic expressions and assignment
    statements from high-level languages like Pascal and C/C++ into 80x86 assembly
    language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 80x86 Integer Arithmetic Instructions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before describing how to encode arithmetic expressions in assembly language,
    it would be a good idea to first discuss the remaining arithmetic instructions
    in the 80x86 instruction set. Previous chapters have covered most of the arithmetic
    and logical instructions, so this section covers the few remaining instructions
    you'll need.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 The mul and imul Instructions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The multiplication instructions provide you with another taste of irregularity
    in the 80x86's instruction set. Instructions like `add`, `sub`, and many others
    in the 80x86 instruction set support two operands, just like the `mov` instruction.
    Unfortunately, there weren't enough bits in the 80x86's opcode byte to support
    all instructions, so the 80x86 treats the `mul` (unsigned multiply) and `imul`
    (signed integer multiply) instructions as single-operand instructions, just like
    the `inc`, `dec`, and `neg` instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Of course, multiplication *is* a two-operand function. To work around this fact,
    the 80x86 always assumes the accumulator (AL, AX, or EAX) is the destination operand.
    This irregularity makes using multiplication on the 80x86 a little more difficult
    than other instructions because one operand has to be in the accumulator. Intel
    adopted this unorthogonal approach because it felt that programmers would use
    multiplication far less often than instructions like `add` and `sub`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the `mul` and `imul` instructions is that you cannot multiply
    the accumulator by a constant using these instructions. Intel quickly discovered
    the need to support multiplication by a constant and added the `intmul` instruction
    to overcome this problem. Nevertheless, you must be aware that the basic `mul`
    and `imul` instructions do not support the full range of operands as `intmul`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of the multiply instruction: unsigned multiplication (`mul`)
    and signed multiplication (`imul`). Unlike addition and subtraction, you need
    separate instructions for signed and unsigned operations.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiply instructions take the following forms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsigned multiplication:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Signed (integer) multiplication:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The returns values above are the strings these instructions return for use with
    instruction composition in HLA. (`i`)`mul`, available on all 80x86 processors,
    multiplies 8-, 16-, or 32-bit operands.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: When multiplying two *n*-bit values, the result may require as many as 2 * *n*
    bits. Therefore, if the operand is an 8-bit quantity, the result could require
    16 bits. Likewise, a 16-bit operand produces a 32-bit result and a 32-bit operand
    requires 64 bits to hold the result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The (`i`)`mul` instruction, with an 8-bit operand, multiplies AL by the operand
    and leaves the 16-bit product in AX. So
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (`i`)`mul` 指令，使用 8 位操作数时，会将 AL 与操作数相乘，并将 16 位乘积保存在 AX 中。因此
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: computes
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`*` represents an unsigned multiplication for `mul` and a signed multiplication
    for `imul`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 表示 `mul` 的无符号乘法和 `imul` 的有符号乘法。'
- en: If you specify a 16-bit operand, then `mul` and `imul` compute
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定 16 位操作数，则 `mul` 和 `imul` 计算如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`*` has the same meanings as above, and `dx:ax` means that DX contains the
    H.O. word of the 32-bit result and AX contains the L.O. word of the 32-bit result.
    If you''re wondering why Intel didn''t put the 32-bit result in EAX, just note
    that Intel introduced the `mul` and `imul` instructions in the earliest 80x86
    processors, before the advent of 32-bit registers in the 80386 CPU.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 的含义与上述相同，`dx:ax` 表示 DX 包含 32 位结果的高字（H.O.），AX 包含 32 位结果的低字（L.O.）。如果你在疑惑为何英特尔没有将
    32 位结果放入 EAX 中，请注意，英特尔在最早期的 80x86 处理器中引入了 `mul` 和 `imul` 指令，在 80386 CPU 引入 32
    位寄存器之前。'
- en: 'If you specify a 32-bit operand, then `mul` and `imul` compute the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定 32 位操作数，则 `mul` 和 `imul` 计算如下：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`*` has the same meanings as above, and `edx:eax` means that EDX contains the
    H.O. double word of the 64-bit result and EAX contains the L.O. double word of
    the 64-bit result.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 的含义与上述相同，`edx:eax` 表示 EDX 包含 64 位结果的高字（H.O.），EAX 包含 64 位结果的低字（L.O.）。'
- en: If an 8×8-, 16×16-, or 32×32-bit product requires more than 8, 16, or 32 bits
    (respectively), the `mul` and `imul` instructions set the carry and overflow flags.
    `mul` and `imul` scramble the sign and zero flags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 8×8 位、16×16 位或 32×32 位的乘积需要超过 8、16 或 32 位（分别），则 `mul` 和 `imul` 指令会设置进位标志和溢出标志。`mul`
    和 `imul` 会扰乱符号标志和零标志。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Especially note that the sign and zero flags do not contain meaningful values
    after the execution of these two instructions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是，在执行这两条指令后，符号标志和零标志不包含有意义的值。
- en: 'To help reduce some of the syntax irregularities with the use of the `mul`
    and `imul` instructions, HLA provides an extended syntax that allows the following
    two-operand forms:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少使用 `mul` 和 `imul` 指令时的一些语法不规范，HLA 提供了一种扩展语法，允许使用以下两操作数形式：
- en: 'Unsigned multiplication:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号乘法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Signed (integer) multiplication:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号（整数）乘法：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two-operand forms let you specify the (L.O.) destination register as the
    second operand. By specifying the destination register you can make your programs
    easier to read. Note that just because HLA allows two operands here, you can't
    specify an arbitrary register. The destination operand must always be AL, AX,
    or EAX, depending on the source operand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两操作数形式让你可以指定（低字）目标寄存器作为第二操作数。通过指定目标寄存器，你可以使程序更易读。请注意，尽管 HLA 允许在这里使用两个操作数，但你不能指定任意寄存器。目标操作数必须始终是
    AL、AX 或 EAX，具体取决于源操作数。
- en: HLA provides a form that lets you specify a constant. The 80x86 doesn't actually
    support a `mul` or `imul` instruction that has a constant operand. HLA will take
    the constant you specify and create a variable in a read-only segment in memory
    and initialize that variable with this value. Then HLA converts the instruction
    to the (`i`)`mul`( *`memory`* ); instruction. Note that when you specify a constant
    as the source operand, the instruction requires two operands (because HLA uses
    the second operand to determine whether the multiplication is 8, 16, or 32 bits).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了一种形式，可以让你指定常量。80x86 实际上不支持带有常量操作数的 `mul` 或 `imul` 指令。HLA 会将你指定的常量存储在内存的只读段中，并用该值初始化该变量。然后
    HLA 将指令转换为 (`i`)`mul`（*`memory`*）；指令。请注意，当你指定常量作为源操作数时，指令需要两个操作数（因为 HLA 使用第二个操作数来确定乘法是
    8 位、16 位还是 32 位）。
- en: 'You''ll use the `mul` and `imul` instructions quite a lot when you learn about
    extended-precision arithmetic in [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC").
    Unless you''re doing multiprecision work, however, you''ll probably just want
    to use the `intmul` instruction in place of the `mul` or `imul` because it is
    more general. However, `intmul` is not a complete replacement for these two instructions.
    Besides the number of operands, there are several differences between the `intmul`
    and the `mul`/`imul` instructions. The following rules apply specifically to the
    `intmul` instruction:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习扩展精度算术时，你会经常使用 `mul` 和 `imul` 指令，详见 [第 8 章](ch08.html "第 8 章：高级算术")。不过，除非你在进行多精度运算，否则你可能更倾向于用
    `intmul` 指令来替代 `mul` 或 `imul`，因为它更为通用。然而，`intmul` 并不能完全替代这两条指令。除了操作数的数量外，`intmul`
    和 `mul`/`imul` 指令之间还有几个差异。以下规则专门适用于 `intmul` 指令：
- en: There isn't an 8×8-bit `intmul` instruction available.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并没有可用的 8×8 位 `intmul` 指令。
- en: The `intmul` instruction does not produce a 2*×n*-bit result. That is, a 16×16-bit
    multiply produces a 16-bit result. Likewise, a 32×32-bit multiply produces a 32-bit
    result. These instructions set the carry and overflow flags if the result does
    not fit into the destination register.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intmul` 指令不会产生 2*×n* 位的结果。也就是说，16×16 位的乘法会产生 16 位的结果。同样，32×32 位的乘法会产生 32 位的结果。如果结果不能适配目标寄存器，这些指令会设置进位标志和溢出标志。'
- en: 6.1.2 The div and idiv Instructions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.2 div 和 idiv 指令
- en: 'The 80x86 divide instructions perform a 64/32-bit division, a 32/16-bit division,
    or a 16/8-bit division. These instructions take the following forms:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 除法指令执行 64/32 位除法、32/16 位除法或 16/8 位除法。这些指令有以下几种形式：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `div` instruction is an unsigned division operation. If the operand is an
    8-bit operand, `div` divides the AX register by the operand leaving the quotient
    in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, then
    the `div` instruction divides the 32-bit quantity in `dx:ax` by the operand, leaving
    the quotient in AX and the remainder in DX. With 32-bit operands `div` divides
    the 64-bit value in `edx:eax` by the operand, leaving the quotient in EAX and
    the remainder in EDX.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`div` 指令是无符号除法操作。如果操作数是 8 位操作数，`div` 将 AX 寄存器除以该操作数，商存储在 AL 寄存器中，余数（模）存储在 AH
    寄存器中。如果操作数是 16 位数，则 `div` 指令将 `dx:ax` 中的 32 位数除以操作数，商存储在 AX 中，余数存储在 DX 中。对于 32
    位操作数，`div` 将 `edx:eax` 中的 64 位值除以操作数，商存储在 EAX 中，余数存储在 EDX 中。'
- en: Like `mul` and `imul`, HLA provides special syntax to allow the use of constant
    operands even though the low-level machine instructions don't actually support
    them. See the previous list of `div` instructions for these extensions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `mul` 和 `imul` 一样，HLA 提供了特殊语法，允许使用常量操作数，即使底层机器指令实际上不支持它们。有关这些扩展的更多信息，请参阅之前列出的
    `div` 指令。
- en: The `idiv` instruction computes a signed quotient and remainder. The syntax
    for the `idiv` instruction is identical to `div` (except for the use of the `idiv`
    mnemonic), though creating signed operands for `idiv` may require a different
    sequence of instructions prior to executing `idiv` than for `div`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`idiv` 指令计算有符号商和余数。`idiv` 指令的语法与 `div` 相同（除了使用了 `idiv` 作为助记符），尽管为 `idiv` 创建有符号操作数可能需要在执行
    `idiv` 之前使用不同的指令序列，而不是 `div`。'
- en: You cannot, on the 80x86, simply divide one unsigned 8-bit value by another.
    If the denominator is an 8-bit value, the numerator must be a 16-bit value. If
    you need to divide one unsigned 8-bit value by another, you must zero extend the
    numerator to 16 bits. You can accomplish this by loading the numerator into the
    AL register and then moving 0 into the AH register. Then you can divide AX by
    the denominator operand to produce the correct result. *Failing to zero extend
    AL before executing* *`div`* *may cause the 80x86 to produce incorrect results!*
    When you need to divide two 16-bit unsigned values, you must zero extend the AX
    register (which contains the numerator) into the DX register. To do this, just
    load 0 into the DX register. If you need to divide one 32-bit value by another,
    you must zero extend the EAX register into EDX (by loading a 0 into EDX) before
    the division.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with signed integer values, you will need to sign extend AL into
    AX, AX into DX, or EAX into EDX before executing `idiv`. To do so, use the `cbw`,
    `cwd`, `cdq`, or `movsx` instruction. If the H.O. byte, word, or double word does
    not already contain significant bits, then you must sign extend the value in the
    accumulator (AL/AX/EAX) before doing the `idiv` operation. Failure to do so may
    produce incorrect results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other issue with the 80x86''s divide instructions: You can get
    a fatal error when using this instruction. First, of course, you can attempt to
    divide a value by 0\. Another problem is that the quotient may be too large to
    fit into the EAX, AX, or AL register. For example, the 16/8-bit division $8000/2
    produces the quotient $4000 with a remainder of 0\. $4000 will not fit into 8
    bits. If this happens, or you attempt to divide by 0, the 80x86 will generate
    an `ex.DivisionError` exception or integer overflow error (`ex.IntoInstr`). This
    usually means your program will display the appropriate dialog and abort. If this
    happens to you, chances are you didn''t sign or zero extend your numerator before
    executing the division operation. Because this error may cause your program to
    crash, you should be very careful about the values you select when using division.
    Of course, you can use the `try..endtry` block with `ex.DivisionError` and `ex.IntoInstr`
    to trap this problem in your program.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 leaves the carry, overflow, sign, and zero flags undefined after a
    division operation. Therefore, you cannot test for problems after a division operation
    by checking the flag bits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The 80x86 does not provide a separate instruction to compute the remainder
    of one number divided by another. The `div` and `idiv` instructions automatically
    compute the remainder at the same time they compute the quotient. HLA, however,
    provides mnemonics (instructions) for the `mod` and `imod` instructions. These
    special HLA instructions compile into the exact same code as their `div` and `idiv`
    counterparts. The only difference is the returns value for the instruction (because
    these instructions return the remainder in a different location than the quotient).
    The `mod` and `imod` instructions that HLA supports are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 并没有提供一个独立的指令来计算一个数除以另一个数的余数。`div` 和 `idiv` 指令在计算商的同时也会自动计算余数。然而，HLA 提供了
    `mod` 和 `imod` 指令的助记符（指令）。这些特殊的 HLA 指令编译成与 `div` 和 `idiv` 相同的代码。唯一的区别是返回值的位置不同（因为这些指令将余数返回到与商不同的位置）。HLA
    支持的 `mod` 和 `imod` 指令如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 6.1.3 The cmp Instruction
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.3 cmp 指令
- en: 'The `cmp` (compare) instruction is identical to the `sub` instruction with
    one crucial semantic difference—it does not retain the difference it computes;
    it just sets the condition code bits in the flags register. The syntax for the
    `cmp` instruction is similar to that of `sub` (though the operands are reversed
    so it reads better); the generic form is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`（比较）指令与 `sub` 指令基本相同，唯一的语义区别是：它不会保留计算出的差值，而只是设置标志寄存器中的条件码位。`cmp` 指令的语法与
    `sub` 指令相似（虽然操作数的顺序被调整过，以便更易理解）；其通用形式如下：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This instruction computes *`LeftOperand`* `-` *`RightOperand`* (note the reversal
    from `sub`). The specific forms are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算 *`LeftOperand`* `-` *`RightOperand`*（注意与 `sub` 的区别）。具体形式如下：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `cmp` instruction updates the 80x86's flags according to the result of the
    subtraction operation (*`LeftOperand`* `-` *`RightOperand`*). The 80x86 sets the
    flags in an appropriate fashion so that we can read this instruction as "compare
    *`LeftOperand`* to *`RightOperand`*." You can test the result of the comparison
    by checking the appropriate flags in the flags register using the conditional
    set instructions (see [6.1.4 The setcc Instructions](ch06.html#the_set_cc_instructions
    "6.1.4 The setcc Instructions")) or the conditional jump instructions (see [Chapter 7](ch07.html
    "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令根据减法操作 (*`LeftOperand`* `-` *`RightOperand`*) 的结果更新 80x86 的标志位。80x86
    会以适当的方式设置标志位，以便我们可以将此指令理解为“将 *`LeftOperand`* 与 *`RightOperand`* 进行比较。”你可以通过检查标志寄存器中的相关标志位，使用条件设置指令（见
    [6.1.4 setcc 指令](ch06.html#the_set_cc_instructions "6.1.4 setcc 指令")）或条件跳转指令（见
    [第 7 章](ch07.html "第 7 章. 低级控制结构")）来测试比较的结果。'
- en: 'Probably the first place to start when exploring the `cmp` instruction is to
    look at exactly how the `cmp` instruction affects the flags. Consider the following
    `cmp` instruction:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `cmp` 指令时，最好的起点可能是查看 `cmp` 指令如何具体影响标志位。考虑以下 `cmp` 指令：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This instruction performs the computation AX - BX and sets the flags depending
    upon the result of the computation. The flags are set as follows (also see [Table 6-1](ch06.html#condition_code_settings_after_cmp
    "Table 6-1. Condition Code Settings After cmp")):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令执行 AX - BX 的计算，并根据计算结果设置标志位。标志位设置如下（另见 [表 6-1](ch06.html#condition_code_settings_after_cmp
    "表 6-1. cmp 后的条件码设置")）：
- en: '**`Z`**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Z`**'
- en: The zero flag is set if and only if AX = BX. This is the only time AX - BX produces
    a zero result. Hence, you can use the zero flag to test for equality or inequality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 AX = BX 时，零标志才会被设置。这是 AX - BX 结果为零的唯一情况。因此，你可以通过零标志来测试相等或不相等。
- en: '**`S`**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**`S`**'
- en: The sign flag is set to 1 if the result is negative. At first glance, you might
    think that this flag would be set if AX is less than BX, but this isn't always
    the case. If AX = $7FFF and BX = −1 ($FFFF), then subtracting AX from BX produces
    $8000, which is negative (and so the sign flag will be set). So, for signed comparisons
    anyway, the sign flag doesn't contain the proper status. For unsigned operands,
    consider AX = $FFFF and BX = 1\. AX is greater than BX but their difference is
    $FFFE, which is still negative. As it turns out, the sign flag and the overflow
    flag, taken together, can be used for comparing two signed values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**`O`**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The overflow flag is set after a `cmp` operation if the difference of AX and
    BX produced an overflow or underflow. As mentioned above, the sign flag and the
    overflow flag are both used when performing signed comparisons.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**`C`**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The carry flag is set after a `cmp` operation if subtracting BX from AX requires
    a borrow. This occurs only when AX is less than BX where AX and BX are both unsigned
    values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that the `cmp` instruction sets the flags in this fashion, you can test
    the comparison of the two operands with the following flags:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Table 6-1. Condition Code Settings After `cmp`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '| Unsigned Operands | Signed Operands |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Z: Equality/inequality | Z: Equality/inequality |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| C: Left < Right (C = 1)Left >= Right (C = 0) | C: No meaning |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| S: No meaning | S: See discussion in this section |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| O: No meaning | O: See discussion in this section |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: 'For signed comparisons, the S (sign) and O (overflow) flags, taken together,
    have the following meaning:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: If [(S = 0) and (O = 1)] or [(S = 1) and (O = 0)] then Left < Right for a signed
    comparison.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If [(S = 0) and (O = 0)] or [(S = 1) and (O = 1)] then Left >= Right for a signed
    comparison.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that (S `xor` O) is 1 if the left operand is less than the right operand.
    Conversely, (S `xor` O) is 0 if the left operand is greater or equal to the right
    operand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why these flags are set in this manner, consider the following
    examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember, the `cmp` operation is really a subtraction; therefore, the first
    example above computes (−1) - (−2), which is (+1). The result is positive and
    an overflow did not occur, so both the S and O flags are 0\. Because (S `xor`
    O) is 0, `Left` is greater than or equal to `Right`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `cmp` instruction would compute (−32,768) - (+1),
    which is (−32,769). Because a 16-bit signed integer cannot represent this value,
    the value wraps around to $7FFF (+32,767) and sets the overflow flag. The result
    is positive (at least as a 16-bit value), so the CPU clears the sign flag. (S
    `xor` O) is 1 here, so `Left` is less than `Right`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In the third example above, `cmp` computes (−2) - (−1), which produces (−1).
    No overflow occurred, so the O flag is 0, the result is negative, so the sign
    flag is 1\. Because (S `xor` O) is 1, `Left` is less than `Right`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth (and final) example, `cmp` computes (+32,767) - (−1). This produces
    (+32,768), setting the overflow flag. Furthermore, the value wraps around to $8000
    (−32,768), so the sign flag is set as well. Because (S `xor` O) is 0, `Left` is
    greater than or equal to `Right`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个（也是最后一个）示例中，`cmp`计算（+32,767）-（−1）。这产生了（+32,768），设置了溢出标志。此外，值会环绕回$8000（−32,768），因此符号标志也被设置。因为（S
    `xor` O）等于0，所以`Left`大于或等于`Right`。
- en: You may test the flags after a `cmp` instruction using HLA high-level control
    statements and the boolean flag expressions (e.g., `@c`, `@nc`, `@z`, `@nz`, `@o`,
    `@no`, `@s`, `@ns`, and so on). [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") lists the boolean expressions
    HLA supports that let you check various conditions after a compare instruction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cmp`指令后使用HLA高级控制语句和布尔标志表达式（例如`@c`，`@nc`，`@z`，`@nz`，`@o`，`@no`，`@s`，`@ns`等）测试标志。[表6-2](ch06.html#hla_condition_code_boolean_expressions
    "表6-2. HLA条件码布尔表达式")列出了HLA支持的布尔表达式，允许你在比较指令后检查各种条件。
- en: Table 6-2. HLA Condition Code Boolean Expressions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2. HLA条件码布尔表达式
- en: '| HLA Syntax | Condition | Comment |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| HLA语法 | 条件 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@c` | Carry set | Carry flag is set if the first operand is less than the
    second operand (unsigned). Same condition as `@b` and `@nae`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `@c` | 进位设置 | 如果第一个操作数小于第二个操作数（无符号），则进位标志设置。与`@b`和`@nae`相同条件。 |'
- en: '| `@nc` | Carry clear (no carry) | Carry flag is clear if the first operand
    is greater than or equal to the second (using an unsigned comparison). Same condition
    as `@nb` and `@ae`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `@nc` | 进位清除（无进位） | 如果第一个操作数大于或等于第二个操作数（使用无符号比较），则进位标志清除。与`@nb`和`@ae`相同条件。
    |'
- en: '| `@z` | Zero flag set | Zero flag is set if the first operand equals the second
    operand. Same condition as `@e`. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `@z` | 零标志设置 | 如果第一个操作数等于第二个操作数，则零标志设置。与`@e`相同条件。 |'
- en: '| `@nz` | Zero flag clear (no zero) | Zero flag is clear if the first operand
    is not equal to the second. Same condition as `@ne`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `@nz` | 零标志清除（无零） | 如果第一个操作数不等于第二个操作数，则零标志清除。与`@ne`相同条件。 |'
- en: '| `@o` | Overflow flag set | This flag is set if there was a signed arithmetic
    overflow as a result of the comparison operation. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `@o` | 溢出标志设置 | 如果比较操作导致符号算术溢出，则此标志设置。 |'
- en: '| `@no` | Overflow flag clear (no overflow) | The overflow flag is clear if
    there was no signed arithmetic overflow during the compare operation. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `@no` | 溢出标志清除（无溢出） | 如果在比较操作过程中没有发生符号算术溢出，则溢出标志清除。 |'
- en: '| `@s` | Sign flag set | The sign flag is set if the result of the compare
    (subtraction) produces a negative result. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `@s` | 符号标志设置 | 如果比较（减法）结果为负，则符号标志被设置。 |'
- en: '| `@ns` | Sign flag clear (no sign) | The sign flag is clear if the compare
    operation produces a nonnegative (zero or positive) result. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `@ns` | 符号标志清除（无符号） | 如果比较操作产生非负（零或正）结果，则符号标志清除。 |'
- en: '| `@a` | Above (unsigned greater than) | The `@a` condition checks the carry
    and zero flags to see if `@c` = 0 and `@z` = 0\. This condition exists if the
    first (unsigned) operand is greater than the second (unsigned) operand. This is
    the same condition as `@nbe`. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `@a` | 大于（无符号大于） | `@a`条件检查进位和零标志，查看`@c` = 0且`@z` = 0。此条件存在于第一个（无符号）操作数大于第二个（无符号）操作数时。这与`@nbe`相同。
    |'
- en: '| `@na` | Not above | The `@na` condition checks to see if the carry flag is
    set (`@c`) or the zero flag is set (`@z`). This is equivalent to an unsigned "not
    greater than" condition. Note that this condition is the same as `@be`. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `@na` | 不大于 | `@na`条件检查进位标志是否被设置（`@c`）或零标志是否被设置（`@z`）。这等同于无符号的“非大于”条件。请注意，这个条件与`@be`相同。
    |'
- en: '| `@ae` | Above or equal (unsigned greater than or equal) | The `@ae` condition
    is true if the first operand is greater than or equal to the second using an unsigned
    comparison. This is equivalent to the `@nb` and `@nc` conditions. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `@ae` | 大于或等于（无符号大于等于） | 如果第一个操作数使用无符号比较大于或等于第二个操作数，则`@ae`条件为真。这等同于`@nb`和`@nc`条件。
    |'
- en: '| `@nae` | Not above or equal | The `@nae` condition is true if the first operand
    is not greater than or equal to the second using an unsigned comparison. This
    is equivalent to the `@b` and `@c` conditions. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `@nae` | 非大于或等于 | 如果第一个操作数使用无符号比较不大于或等于第二个操作数，则`@nae`条件为真。这等同于`@b`和`@c`条件。
    |'
- en: '| `@b` | Below (unsigned less than) | The `@b` condition is true if the first
    operand is less than the second using an unsigned comparison. This is equivalent
    to the `@nae` and `@c` conditions. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `@nb` | Not below | This condition is true if the first operand is not less
    than the second using an unsigned comparison. This condition is equivalent to
    the `@nc` and `@ae` conditions. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `@be` | Below or equal (unsigned less than or equal) | The `@be` condition
    is true when the first operand is less than or equal to the second using an unsigned
    comparison. This condition is equivalent to `@na`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `@nbe` | Not below or equal | The `@be` condition is true when the first
    operand is not less than or equal to the second using an unsigned comparison.
    This condition is equivalent to `@a`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `@g` | Greater (signed greater than) | The `@g` condition is true if the
    first operand is greater than the second using a signed comparison. This is equivalent
    to the `@nle` condition. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `@ng` | Not greater | The `@ng` condition is true if the first operand is
    not greater than the second using a signed comparison. This is equivalent to the
    `@le` condition. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `@ge` | Greater or equal (signed greater than or equal) | The `@ge` condition
    is true if the first operand is greater than or equal to the second using a signed
    comparison. This is equivalent to the `@nl` condition. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `@nge` | Not greater or equal | The `@nge` condition is true if the first
    operand is not greater than or equal to the second using a signed comparison.
    This is equivalent to the `@l` condition. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `@l` | Less than (signed less than) | The `@l` condition is true if the first
    operand is less than the second using a signed comparison. This is equivalent
    to the `@nge` condition. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `@nl` | Not less than | The `@ng` condition is true if the first operand
    is not less than the second using a signed comparison. This is equivalent to the
    `@ge` condition. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `@le` | Less than or equal (signed) | The `@le` condition is true if the
    first operand is less than or equal to the second using a signed comparison. This
    is equivalent to the `@ng` condition. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `@nle` | Not less than or equal | The `@nle` condition is true if the first
    operand is not less than or equal to the second using a signed comparison. This
    is equivalent to the `@g` condition. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `@e` | Equal (signed or unsigned) | This condition is true if the first operand
    equals the second. The `@e` condition is equivalent to the `@z` condition. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `@ne` | Not equal (signed or unsigned) | `@ne` is true if the first operand
    does not equal the second. This condition is equivalent to `@nz`. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: 'You may use the boolean conditions appearing in [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") within an `if` statement,
    `while` statement, or any other HLA high-level control statement that allows boolean
    expressions. Immediately after the execution of a `cmp` instruction, you would
    typically use one of these conditions in an `if` statement. For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the example above is equivalent to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 6.1.4 The set*cc* Instructions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *set on condition* (or `set`*`cc`*) instructions set a single-byte operand
    (register or memory) to 0 or 1 depending on the values in the flags register.
    The general formats for the `set`*`cc`* instructions are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`set`*`cc`* represents a mnemonic appearing in [Table 6-3](ch06.html#setcc_instructions_that_test_flags
    "Table 6-3. setcc Instructions That Test Flags"), [Table 6-4](ch06.html#setcc_instructions_for_unsigned_comparis
    "Table 6-4. setcc Instructions for Unsigned Comparisons"), and [Table 6-5](ch06.html#setcc_instructions_for_signed_comparison
    "Table 6-5. setcc Instructions for Signed Comparisons"). These instructions store
    a 0 into the corresponding operand if the condition is false, and they store a
    1 into the 8-bit operand if the condition is true.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3. `set`*`cc`* Instructions That Test Flags
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `setc` | Set if carry | Carry = 1 | Same as `setb`, `setnae` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `setnc` | Set if no carry | Carry = 0 | Same as `setnb`, `setae` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `setz` | Set if zero | Zero = 1 | Same as `sete` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `setnz` | Set if not zero | Zero = 0 | Same as `setne` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `sets` | Set if sign | Sign = 1 |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `setns` | Set if no sign | Sign = 0 |   |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `seto` | Set if overflow | Overflow = 1 |   |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `setno` | Set if no overflow | Overflow = 0 |   |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `setp` | Set if parity | Parity = 1 | Same as `setpe` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `setpe` | Set if parity even | Parity = 1 | Same as `setp` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `setnp` | Set if no parity | Parity = 0 | Same as `setpo` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `setpo` | Set if parity odd | Parity = 0 | Same as `setnp` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: The `set`*`cc`* instructions above simply test the flags without any other meaning
    attached to the operation. You could, for example, use `setc` to check the carry
    flag after a shift, rotate, bit test, or arithmetic operation. You might notice
    the `setp`, `setpe`, and `setnp` instructions above. They check the parity flag.
    These instructions appear here for completeness, but this text will not spend
    too much time discussing the parity flag (its use is somewhat obsolete).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The `cmp` instruction works synergistically with the setcc instructions. Immediately
    after a `cmp` operation the processor flags provide information concerning the
    relative values of those operands. They allow you to see if one operand is less
    than, equal to, or greater than the other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Two additional groups of `set`*`cc`* instructions are very useful after a `cmp`
    operation. The first group deals with the result of an unsigned comparison; the
    second group deals with the result of a signed comparison.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4. `set`*`cc`* Instructions for Unsigned Comparisons
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `seta` | Set if above (>) | Carry = 0, Zero = 0 | Same as `setnbe` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `setnbe` | Set if not below or equal (not <=) | Carry = 0, Zero = 0 | Same
    as `seta` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `setae` | Set if above or equal (>=) | Carry = 0 | Same as `setnc`, `setnb`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `setnb` | Set if not below (not <) | Carry = 0 | Same as `setnc`, `setae`
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `setb` | Set if below (<) | Carry = 1 | Same as `setc`, `setna` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `setnae` | Set if not above or equal (not >=) | Carry = 1 | Same as `setc`,
    `setb` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `setbe` | Set if below or equal (<=) | Carry = 1 or Zero = 1 | Same as `setna`
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `setna` | Set if not above (not >) | Carry = 1 or Zero = 1 | Same as `setbe`
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '[Table 6-5](ch06.html#setcc_instructions_for_signed_comparison "Table 6-5. setcc
    Instructions for Signed Comparisons") lists the corresponding signed comparisons.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-5. `set`*`cc`* Instructions for Signed Comparisons
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `setg` | Set if greater (>) | Sign = Overflow and Zero = 0 | Same as `setnle`
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `setnle` | Set if not less than or equal (not <=) | Sign = Overflow or Zero
    = 0 | Same as `setg` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `setge` | Set if greater than or equal (>=) | Sign = Overflow | Same as `setnl`
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `setnl` | Set if not less than (not <) | Sign = Overflow | Same as `setge`
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `setl` | Set if less than (<) | Sign ¦ Overflow | Same as `setnge` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `setnge` | Set if not greater or equal (not >=) | Sign ¦ Overflow | Same
    as `setl` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `setl` | Set if less than or equal (<=) | Sign ¦ Overflow or Zero = 1 | Same
    as `setng` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `setng` | Set if not greater than (not >) | Sign ¦ Overflow or Zero = 1 |
    Same as `setle` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: Note the correspondence between the `set`*`cc`* instructions and the HLA flag
    conditions that may appear in boolean instructions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set`*`cc`* instructions are particularly valuable because they can convert
    the result of a comparison to a boolean value (false/true or 0/1). This is especially
    important when translating statements from a high-level language like Pascal or
    C/C++ into assembly language. The following example shows how to use these instructions
    in this manner:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because the `set`*`cc`* instructions always produce 0 or 1, you can use the
    results with the `and` and `or` instructions to compute complex boolean values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 6.1.5 The test Instruction
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 `test` instruction is to the `and` instruction what the `cmp` instruction
    is to `sub`. That is, the `test` instruction computes the logical `and` of its
    two operands and sets the condition code flags based on the result; it does not,
    however, store the result of the logical and back into the destination operand.
    The syntax for the `test` instruction is similar to `and`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `test` instruction sets the zero flag if the result of the logical `and`
    operation is 0\. It sets the sign flag if the H.O. bit of the result contains
    a 1\. The `test` instruction always clears the carry and overflow flags.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `test` instruction is to check to see if an individual
    bit contains a 0 or a 1\. Consider the instruction `test( 1, al);`. This instruction
    logically `and`s AL with the value 1; if bit 0 of AL contains 0, the result will
    be 0 (setting the zero flag) because all the other bits in the constant 1 are
    0\. Conversely, if bit 1 of AL contains 1, then the result is not 0, so `test`
    clears the zero flag. Therefore, you can test the zero flag after this `test`
    instruction to see if bit 0 contains a 0 or a 1 (e.g., using a `setz` or `setnz`
    instruction).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The `test` instruction can also check to see if all the bits in a specified
    set of bits contain 0\. The instruction `test( $F, al);` sets the zero flag if
    and only if the L.O. 4 bits of AL all contain 0.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'One very important use of the `test` instruction is to check whether a register
    contains 0\. The instruction `test(` *`reg`*`,` *`reg`* `);` where both operands
    are the same register will logically `and` that register with itself. If the register
    contains 0, then the result is 0 and the CPU will set the zero flag. However,
    if the register contains a nonzero value, logically `and`ing that value with itself
    produces that same nonzero value, so the CPU clears the zero flag. Therefore,
    you can check the zero flag immediately after the execution of this instruction
    (e.g., using the `setz` or `setnz` instructions or the `@z` and `@nz` boolean
    conditions) to see if the register contains 0\. Here are some examples:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 6.2 Arithmetic Expressions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the biggest shock to beginners facing assembly language for the very
    first time is the lack of familiar arithmetic expressions. Arithmetic expressions,
    in most high-level languages, look similar to their algebraic equivalents. For
    example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In assembly language, you''ll need several statements to accomplish this same
    task:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Obviously the HLL version is much easier to type, read, and understand. This
    point, more than any other, is responsible for scaring people away from assembly
    language. Although there is a lot of typing involved, converting an arithmetic
    expression into assembly language isn't difficult at all. By attacking the problem
    in steps, the same way you would solve the problem by hand, you can easily break
    down any arithmetic expression into an equivalent sequence of assembly language
    statements. By learning how to convert such expressions to assembly language in
    three steps, you'll discover there is little difficulty to this task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Simple Assignments
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest expressions to convert to assembly language are simple assignments.
    Simple assignments copy a single value into a variable and take one of two forms:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: or
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Converting the first form to assembly language is simple—just use the assembly
    language statement:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `mov` instruction copies the constant into the variable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The second assignment above is slightly more complicated because the 80x86
    doesn''t provide a memory-to-memory `mov` instruction. Therefore, to copy one
    memory variable into another, you must move the data through a register. By convention
    (and for slight efficiency reasons), most programmers tend to favor AL/AX/EAX
    for this purpose. For example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: becomes
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is assuming, of course, that *`var1`* and *`var2`* are 32-bit variables.
    Use AL if they are 8-bit variables; use AX if they are 16-bit variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you're already using AL, AX, or EAX for something else, one of
    the other registers will suffice. Regardless, you will generally use a register
    to transfer one memory location to another.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Simple Expressions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next level of complexity is a simple expression. A simple expression takes
    the following form:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*`var1`* is a variable, *`term1`* and *`term2`* are variables or constants,
    and *`op`* is some arithmetic operator (addition, subtraction, multiplication,
    and so on). Most expressions take this form. It should come as no surprise, then,
    that the 80x86 architecture was optimized for just this type of expression.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical conversion for this type of expression takes the following form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*`op`* is the mnemonic that corresponds to the specified operation (e.g., +
    is `add`, `−` is `sub`, etc.).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Note that the simple expression *`var1`* `:=` *`const1 op const2`*`;` is easily
    handled with a compile-time expression and a single `mov` instruction. For example,
    to compute *`var1`* `:= 5+3;`, just use the single instruction `mov( 5+3`, *`var1`*
    `);`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: There are a few inconsistencies you need to be aware of. When dealing with the
    (`i`)`mul`, (`i`)`div`, and (`i`)`mod` instructions on the 80x86, you must use
    the AL/AX/EAX and DX/EDX registers. You cannot use arbitrary registers as you
    can with other operations. Also, don't forget the sign extension instructions
    if you're performing a division operation and you're dividing one 16/32-bit number
    by another. Finally, don't forget that some instructions may cause overflow. You
    may want to check for an overflow (or underflow) condition after an arithmetic
    operation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of common simple expressions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Certain unary operations also qualify as simple expressions, producing additional
    inconsistencies in the general rule. A good example of a unary operation is negation.
    In a high-level language, negation takes one of two possible forms:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: or
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that *`var`* `:= -`*`constant`* is really a simple assignment, not a simple
    expression. You can specify a negative constant as an operand to the `mov` instruction:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To handle *`var1`* `= -`*`var1`*`;`, use this single assembly language statement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If two different variables are involved, then use the following.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6.2.3 Complex Expressions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex expression is any arithmetic expression involving more than two terms
    and one operator. Such expressions are commonly found in programs written in a
    high-level language. Complex expressions may include parentheses to override operator
    precedence, function calls, array accesses, and so on. While the conversion of
    many complex expressions to assembly language is fairly straightforward, other
    conversions require some effort. This section outlines the rules you use to convert
    such expressions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'A complex expression that is easy to convert to assembly language is one that
    involves three terms and two operators. For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Clearly the straightforward assembly language conversion of this statement
    will require two `sub` instructions. However, even with an expression as simple
    as this one, the conversion is not trivial. There are actually *two ways* to convert
    this from the statement above into assembly language:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second conversion, because it is shorter, looks better. However, it produces
    an incorrect result (assuming Pascal-like semantics for the original statement).
    *Associativity* is the problem. The second sequence above computes `w := w - (y
    - z)`, which is not the same as `w := (w - y) - z`. How we place the parentheses
    around the subexpressions can affect the result. Note that if you are interested
    in a shorter form, you can use the following sequence:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This computes `w := w - (y + z)`. This is equivalent to `w := (w - y) - z`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '*Precedence* is another issue. Consider this Pascal expression:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once again there are two ways we can evaluate this expression:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: or
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By now, you're probably thinking that this text is crazy. Everyone knows the
    correct way to evaluate these expressions is by the second form. However, you're
    wrong to think that way. The APL programming language, for example, evaluates
    expressions solely from right to left and does not give one operator precedence
    over another. Which way is "correct" depends entirely on how you define precedence
    in your arithmetic system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Most high-level languages use a fixed set of precedence rules to describe the
    order of evaluation in an expression involving two or more different operators.
    Such programming languages usually compute multiplication and division before
    addition and subtraction. Those that support exponentiation (for example, FORTRAN
    and BASIC) usually compute that before multiplication and division. These rules
    are intuitive because almost everyone learns them before high school. Consider
    the expression
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If *`op1`* takes precedence over *`op2`*, then this evaluates to `(x` *`op1`*
    `y)` *`op2`* `z`; otherwise, if *`op2`* takes precedence over *`op1`*, then this
    evaluates to `x` *`op1`* `(y` *`op2`* `z)`. Depending upon the operators and operands
    involved, these two computations could produce different results. When converting
    an expression of this form into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If two operators appearing within an expression have the same precedence, then
    you determine the order of evaluation using *associativity* rules. Most operators
    are left associative, meaning that they evaluate from left to right. Addition,
    subtraction, multiplication, and division are all left associative. A *right-associative*
    operator evaluates from right to left. The exponentiation operator in FORTRAN
    and BASIC is a good example of a right-associative operator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There is one exception to the associativity rule. If an expression involves
    multiplication and division, it is generally better to perform the multiplication
    first. For example, given an expression of the form
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: it is usually better to compute `x * z` and then divide the result by `y` rather
    than divide `x` by `y` and multiply the quotient by `z`. There are two reasons
    why this approach is better. First, remember that the `imul` instruction always
    produces a 64-bit result (assuming 32-bit operands). By doing the multiplication
    first, you automatically *sign extend* the product into the EDX register so you
    do not have to sign extend EAX prior to the division. A second reason for doing
    the multiplication first is to increase the accuracy of the computation. Remember,
    (integer) division often produces an inexact result. For example, if you compute
    5/2 you will get the value 2, not 2.5\. Computing (5 / 2) * 3 produces 6\. However,
    if you compute `(5 * 3) / 2` you get the value 7, which is a little closer to
    the real quotient (7.5). Therefore, if you encounter an expression of the form
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'you can usually convert it to the following assembly code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, if the algorithm you''re encoding depends on the truncation effect
    of the division operation, you cannot use this trick to improve the algorithm.
    Moral of the story: Always make sure you fully understand any expression you are
    converting to assembly language. Obviously, if the semantics dictate that you
    must perform the division first, then do so.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Pascal statement:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is similar to a previous example except it uses subtraction rather than
    addition. Because subtraction is not commutative, you cannot compute `y * x` and
    then subtract `x` from this result. This tends to complicate the conversion a
    tiny amount. Rather than use a straightforward multiplication-and-addition sequence,
    you''ll have to load `x` into a register, multiply `y` and `x` leaving their product
    in a different register, and then subtract this product from `x`. For example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is a trivial example that demonstrates the need for *temporary variables*
    in an expression. This code uses the EBX register to temporarily hold a copy of
    `x` until it computes the product of `y` and `x`. As your expressions increase
    in complexity, the need for temporaries grows. Consider the following Pascal statement:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Following the normal rules of algebraic evaluation, you compute the subexpressions
    inside the parentheses (that is, the two subexpressions with the highest precedence)
    first and set their values aside. When you''ve computed the values for both subexpressions,
    you can compute their sum. One way to deal with a complex expression like this
    one is to reduce it to a sequence of simple expressions whose results wind up
    in temporary variables. For example, you can convert the single expression above
    into the following sequence:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Because converting simple expressions to assembly language is quite easy, it''s
    now a snap to compute the former complex expression in assembly. The code is:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Of course, this code is grossly inefficient, and it requires that you declare
    a couple of temporary variables in your data segment. However, it is very easy
    to optimize this code by keeping temporary variables, as much as possible, in
    80x86 registers. By using 80x86 registers to hold the temporary results, this
    code becomes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s yet another example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This can be converted to a set of four simple expressions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can convert these four simple expressions into the following assembly language
    statements:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The most important thing to keep in mind is that you should attempt to keep
    temporary values in registers. Remember, accessing an 80x86 register is much more
    efficient than accessing a memory location. Use memory locations to hold temporaries
    only if you've run out of registers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, converting a complex expression to assembly language is little different
    than solving the expression by hand. Instead of actually computing the result
    at each stage of the computation, you simply write the assembly code that computes
    the result. Because you were probably taught to compute only one operation at
    a time, this means that manual computation works on "simple expressions" that
    exist in a complex expression. Of course, converting those simple expressions
    to assembly is fairly simple. Therefore, anyone who can solve a complex expression
    by hand can convert it to assembly language following the rules for simple expressions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.4 Commutative Operators
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If *`op`* represents some operator, that operator is *commutative* if the following
    relationship is always true:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you saw in the previous section, commutative operators are nice because the
    order of their operands is immaterial, and this lets you rearrange a computation,
    often making that computation easier or more efficient. Often, rearranging a computation
    allows you to use fewer temporary variables. Whenever you encounter a commutative
    operator in an expression, you should always check to see if there is a better
    sequence you can use to improve the size or speed of your code. [Table 6-6](ch06s02.html#some_common_commutative_binary_operators
    "Table 6-6. Some Common Commutative Binary Operators") and [Table 6-7](ch06s02.html#some_common_noncommutative_binary_operat
    "Table 6-7. Some Common Noncommutative Binary Operators"), respectively, list
    the commutative and noncommutative operators you typically find in high-level
    languages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6. Some Common Commutative Binary Operators
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '| Pascal | C/C++ | Description |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| `+` | `+` | Addition |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| `*` | `*` | Multiplication |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| `and` | `&&` or `&` | Logical or bitwise `and` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `or` | `&#124;&#124;` or `&#124;` | Logical or bitwise `or` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| `xor` | `^` | (Logical or) bitwise exclusive-`or` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| `=` | `==` | Equality |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| `<>` | `!=` | Inequality |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: Table 6-7. Some Common Noncommutative Binary Operators
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '| Pascal | C/C++ | Description |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| `-` | `-` | Subtraction |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| `/` or `div` | `/` | Division |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| `mod` | `%` | Modulo or remainder |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| `<` | `<` | Less than |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `<=` | Less than or equal |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| `>` | `>` | Greater than |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `>=` | Greater than or equal |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: 6.3 Logical (Boolean) Expressions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following expression from a Pascal program:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`b` is a boolean variable and the remaining variables are all integers.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: How do we represent boolean variables in assembly language? Although it takes
    only a single bit to represent a boolean value, most assembly language programmers
    allocate a whole byte or word for this purpose (thus, HLA also allocates a whole
    byte for a boolean variable). With a byte, there are 256 possible values we can
    use to represent the two values true and false. So which two values (or which
    two sets of values) do we use to represent these boolean values? Because of the
    machine's architecture, it's much easier to test for conditions like zero or not
    zero and positive or negative rather than to test for one of two particular boolean
    values. Most programmers (and, indeed, some programming languages like C) choose
    0 to represent false and anything else to represent true. Some people prefer to
    represent true and false with 1 and 0 (respectively) and not allow any other values.
    Others select all 1 bits ($FFFF_FFFF, $FFFF, or $FF) for true and 0 for false.
    You could also use a positive value for true and a negative value for false. All
    these mechanisms have their advantages and drawbacks.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Using only 0 and 1 to represent false and true offers two very big advantages:
    (1) The setcc instructions produce these results, so this scheme is compatible
    with those instructions; (2) the 80x86 logical instructions (`and`, `or`, `xor`,
    and, to a lesser extent, `not`) operate on these values exactly as you would expect.
    That is, if you have two boolean variables `A` and `B`, then the following instructions
    perform the basic logical operations on these two variables:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note, as pointed out above, that the not instruction will not properly compute
    logical negation. The bitwise `not` of 0 is $FF and the bitwise `not` of 1 is
    $FE. Neither result is 0 or 1\. However, by `and`ing the result with 1 you get
    the proper result. Note that you can implement the `not` operation more efficiently
    using the `xor( 1, ax );` instruction because it affects only the L.O. bit.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, using 0 for false and anything else for true has a lot of
    subtle advantages. Specifically, the test for true or false is often implicit
    in the execution of any logical instruction. However, this mechanism suffers from
    a very big disadvantage: You cannot use the 80x86 `and`, `or`, `xor`, and `not`
    instructions to implement the boolean operations of the same name. Consider the
    two values $55 and $AA. They''re both nonzero so they both represent the value
    true. However, if you logically `and` $55 and $AA together using the 80x86 `and`
    instruction, the result is 0\. True `and` true should produce true, not false.
    Although you can account for situations like this, it usually requires a few extra
    instructions and is somewhat less efficient when computing boolean operations.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A system that uses nonzero values to represent true and 0 to represent false
    is an *arithmetic logical system*. A system that uses the two distinct values
    like 0 and 1 to represent false and true is called a *boolean logical system*,
    or simply a boolean system. You can use either system, as convenient. Consider
    again the boolean expression
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The simple expressions resulting from this expression might be:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When working with boolean expressions don't forget that you might be able to
    optimize your code by simplifying those boolean expressions. You can use algebraic
    transformations to help reduce the complexity of an expression. In the chapter
    on control structures, you'll also see how to use control flow to calculate a
    boolean result. This is generally quite a bit more efficient than using *complete
    boolean evaluation* as the examples in this section teach.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Machine and Arithmetic Idioms
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An idiom is an idiosyncrasy. Several arithmetic operations and 80x86 instructions
    have idiosyncrasies that you can take advantage of when writing assembly language
    code. Some people refer to the use of machine and arithmetic idioms as "tricky
    programming" that you should always avoid in well-written programs. While it is
    wise to avoid tricks just for the sake of tricks, many machine and arithmetic
    idioms are well known and commonly found in assembly language programs. Some of
    them are little more than tricks, but a good number of them are simply "tricks
    of the trade." This text cannot even begin to present all of the idioms in common
    use today; they are too numerous and the list is constantly changing. Nevertheless,
    there are some very important idioms that you will see all the time, so it makes
    sense to discuss those.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.1 Multiplying without mul, imul, or intmul
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When multiplying by a constant, you can sometimes write faster code by using
    shifts, additions, and subtractions in place of multiplication instructions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, a `shl` instruction computes the same result as multiplying the specified
    operand by 2\. Shifting to the left two bit positions multiplies the operand by
    4\. Shifting to the left three bit positions multiplies the operand by 8\. In
    general, shifting an operand to the left *n* bits multiplies it by 2^(*n*). You
    can multiply any value by some constant using a series of shifts and additions
    or shifts and subtractions. For example, to multiply the AX register by 10, you
    need only multiply it by 8 and then add in two times the original value. That
    is, `10 * ax = 8 * ax + 2 * ax`. The code to accomplish this is:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Many x86 processors can multiply the AX register (or just about any register,
    for that matter) by various constant values much faster by using `shl` than by
    using the `mul` instruction. This may seem hard to believe because it takes only
    one instruction to compute this product:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: However, if you look at the instruction timings, the shift and add example above
    requires fewer clock cycles on many processors in the 80x86 family than the `mul`
    instruction. Of course, the code is somewhat larger (by a few bytes), but the
    performance improvement is usually worth it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use subtraction with shifts to perform a multiplication operation.
    Consider the following multiplication by 7:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A common error beginning assembly language programmers make is subtracting
    or adding 1 or 2 rather than `eax * 1` or `eax * 2`. The following does not compute
    `eax * 7`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It computes `(8 * eax) - 1`, something entirely different (unless, of course,
    EAX = 1). Beware of this pitfall when using shifts, additions, and subtractions
    to perform multiplication operations.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `lea` instruction to compute certain products. The trick
    is to use the scaled index addressing modes. The following examples demonstrate
    some simple cases:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 6.4.2 Division Without div or idiv
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as the `shl` instruction is useful for simulating a multiplication by a
    power of 2, the `shr` and `sar` instructions can simulate a division by a power
    of 2\. Unfortunately, you cannot easily use shifts, additions, and subtractions
    to perform a division by an arbitrary constant. Therefore, keep in mind that this
    trick is useful only when dividing by powers of 2\. Also, don't forget that the
    `sar` instruction rounds towards negative infinity rather than toward 0; this
    is not the way the `idiv` instruction operates (it rounds toward 0).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Another way to perform division is to use the multiply instructions. You can
    divide by some value by multiplying by its reciprocal. Because the multiply instruction
    is faster than the divide instruction, multiplying by a reciprocal is usually
    faster than division.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re probably wondering, "How does one multiply by a reciprocal when
    the values we''re dealing with are all integers?" The answer, of course, is that
    we must cheat to do this. If you want to multiply by 1/10, there is no way you
    can load the value 1/10 into an 80x86 integer register prior to performing the
    multiplication. However, we could multiply 1/10 by 10, perform the multiplication,
    and then divide the result by 10 to get the final result. Of course, this wouldn''t
    buy you anything; in fact, it would make things worse because you''re now doing
    a multiplication by 10 as well as a division by 10\. However, suppose you multiply
    1/10 by 65,536 (6,553), perform the multiplication, and then divide by 65,536\.
    This would still perform the correct operation, and, as it turns out, if you set
    up the problem correctly, you can get the division operation for free. Consider
    the following code that divides AX by 10:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This code leaves AX/10 in the DX register.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, consider what happens when you multiply AX by
    65,536 ($1_0000). This simply moves AX into DX and sets AX to 0 (a multiply by
    $1_0000 is equivalent to a shift left by 16 bits). Multiplying by 6,554 (65,536
    divided by 10) puts AX divided by 10 into the DX register. Because `mul` is faster
    than `div`, this technique runs a little faster than using a division.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying by a reciprocal works well when you need to divide by a constant.
    You could even use it to divide by a variable, but the overhead to compute the
    reciprocal pays off only if you perform the division many, many times (by the
    same value).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.3 Implementing Modulo-N Counters with and
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to implement a counter variable that counts up to 2^(*n*) - 1 and
    then resets to 0, simply use the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'where `nBits` is a binary value containing *n* bits containing ones right justified
    in the number. For example, to create a counter that cycles between 0 and 15 (2⁴
    − 1), you could use the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 6.5 Floating-Point Arithmetic
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the 8086 CPU first appeared in the late 1970s, semiconductor technology
    was not to the point where Intel could put floating-point instructions directly
    on the 8086 CPU. Therefore, Intel devised a scheme whereby it could use a second
    chip to perform the floating-point calculations—the floating-point unit (or FPU).^([[102](#ftn.CHP-6-FN-1)])
    By the release of the Intel Pentium chip, semiconductor technology had advanced
    to the point that the FPU was fully integrated onto the 80x86 CPU. Therefore,
    almost all modern 80x86 CPU devices fully support floating-point arithmetic directly
    on the CPU.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 FPU Registers
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 FPUs add 13 registers to the 80x86: eight floating-point data registers,
    a control register, a status register, a tag register, an instruction pointer,
    and a data pointer. The data registers are similar to the 80x86''s general-purpose
    register set insofar as all floating-point calculations take place in these registers.
    The control register contains bits that let you decide how the FPU handles certain
    degenerate cases like rounding of inaccurate computations; it also contains bits
    that control precision and so on. The status register is similar to the 80x86''s
    flags register; it contains the condition code bits and several other floating-point
    flags that describe the state of the FPU. The tag register contains several groups
    of bits that determine the state of the value in each of the eight floating-point
    data registers. The instruction and data pointer registers contain certain state
    information about the last floating-point instruction executed. We will not consider
    the last three registers here; see the Intel documentation for more details.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1.1 FPU Data Registers
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FPUs provide eight 80-bit data registers organized as a stack. This is a
    significant departure from the organization of the general-purpose registers on
    the 80x86 CPU. HLA refers to these registers as ST0, ST1, . . . ST7.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference between the FPU register set and the 80x86 register set
    is the stack organization. On the 80x86 CPU, the AX register is always the AX
    register, no matter what happens. On the FPU, however, the register set is an
    eight-element stack of 80-bit floating-point values (see [Figure 6-1](ch06s05.html#fpu_floating-point_register_stack
    "Figure 6-1. FPU floating-point register stack")).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU floating-point register stack](tagoreillycom20100401nostarchimages578021.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. FPU floating-point register stack
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: ST0 refers to the item on the top of the stack, ST1 refers to the next item
    on the stack, and so on. Many floating-point instructions push and pop items on
    the stack; therefore, ST1 will refer to the previous contents of ST0 after you
    push something onto the stack. It will take some thought and practice to get used
    to the fact that the register numbers change, but this is an easy problem to overcome.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1.2 The FPU Control Register
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Intel designed the 80x87 (and, essentially, the IEEE floating-point standard),
    there were no standards in floating-point hardware. Different (mainframe and mini)
    computer manufacturers all had different and incompatible floating-point formats.
    Unfortunately, several applications had been written taking into account the idiosyncrasies
    of these different floating-point formats. Intel wanted to design an FPU that
    could work with the majority of the software out there (keep in mind that the
    IBM-PC was three to four years away when Intel began designing the 8087, so Intel
    couldn't rely on that "mountain" of software available for the PC to make its
    chip popular). Unfortunately, many of the features found in these older floating-point
    formats were mutually incompatible. For example, in some floating-point systems
    rounding would occur when there was insufficient precision; in others, truncation
    would occur. Some applications would work with one floating-point system but not
    with the other. Intel wanted as many applications as possible to work with as
    few changes as possible on its 80x87 FPUs, so it added a special register, the
    FPU *control register*, that lets the user choose one of several possible operating
    modes for the FPU.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The 80x87 control register contains 16 bits organized as shown in [Figure 6-2](ch06s05.html#fpu_control_register
    "Figure 6-2. FPU control register").
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU control register](tagoreillycom20100401nostarchimages578023.png.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. FPU control register
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Bits 10 and 11 of the FPU control register provide rounding control according
    to the values appearing in [Table 6-8](ch06s05.html#rounding_control "Table 6-8. Rounding
    Control").
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-8. Rounding Control
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits 10 & 11 | Function |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| 00 | To nearest or even |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| 01 | Round down |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| 10 | Round up |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| 11 | Truncate |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: The 00 setting is the default. The FPU rounds up values above one-half of the
    least significant bit. It rounds down values below one-half of the least significant
    bit. If the value below the least significant bit is exactly one-half of the least
    significant bit, then the FPU rounds the value toward the value whose least significant
    bit is 0\. For long strings of computations, this provides a reasonable, automatic
    way to maintain maximum precision.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The round-up and round-down options are present for those computations where
    it is important to keep track of the accuracy during a computation. By setting
    the rounding control to round down and performing the operation, then repeating
    the operation with the rounding control set to round up, you can determine the
    minimum and maximum ranges between which the true result will fall.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The truncate option forces all computations to truncate any excess bits during
    the computation. You will rarely use this option if accuracy is important to you.
    However, if you are porting older software to the FPU, you might use this option
    to help when porting the software. One place where this option is extremely useful
    is when converting a floating-point value to an integer. Because most software
    expects floating-point-to-integer conversions to truncate the result, you will
    need to use the truncation/rounding mode to achieve this.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Bits 8 and 9 of the control register specify the precision during computation.
    This capability is provided to allow compatibility with older software as required
    by the IEEE 754 standard. The precision control bits use the values in [Table 6-9](ch06s05.html#mantissa_precision_control_bits
    "Table 6-9. Mantissa Precision Control Bits").
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-9. Mantissa Precision Control Bits
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits 8 & 9 | Precision Control |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| 00 | 24 bits |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| 01 | Reserved |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| 10 | 53 bits |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| 11 | 64 bits |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: Some CPUs may operate faster with floating-point values whose precision is 53
    bits (i.e., 64-bit floating-point format) rather than 64 bits (i.e., 80-bit floating-point
    format). Please see the documentation for your specific processor for details.
    Generally, the CPU defaults these bits to %11 to select the 64-bit mantissa precision.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Bits 0..5 are the *exception masks*. These are similar to the interrupt enable
    bit in the 80x86's flags register. If these bits contain a 1, the corresponding
    condition is ignored by the FPU. However, if any bit contains 0, and the corresponding
    condition occurs, then the FPU immediately generates an interrupt so the program
    can handle the degenerate condition (typically, this would wind up raising an
    HLA exception; see the *excepts.hhf* header file for the exception values).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 corresponds to an invalid operation error. This generally occurs as the
    result of a programming error. Situations that raise the invalid operation exception
    (`ex.fInvalidOperation`) include pushing more than eight items onto the stack
    or attempting to pop an item off an empty stack, taking the square root of a negative
    number, or loading a nonempty register.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Bit 1 masks the *denormalized* interrupt that occurs whenever you try to manipulate
    denormalized values. Denormalized exceptions occur when you load arbitrary extended-precision
    values into the FPU or work with very small numbers just beyond the range of the
    FPU's capabilities. Normally, you would probably *not* enable this exception.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.fDenormal` exception.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Bit 2 masks the *zero divide* exception. If this bit contains 0, the FPU will
    generate an interrupt if you attempt to divide a nonzero value by 0\. If you do
    not enable the zero division exception, the FPU will produce `NaN` (not a number)
    whenever you perform a zero division. It's probably a good idea to enable this
    exception by programming a 0 into this bit. Note that if your program generates
    this interrupt, the HLA runtime system will raise the `ex.fDivByZero` exception.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Bit 3 masks the *overflow* exception. The FPU will raise the overflow exception
    if a calculation overflows or if you attempt to store a value that is too large
    to fit into the destination operand (for example, storing a large extended-precision
    value into a single-precision variable). If you enable this exception and the
    FPU generates this interrupt, the HLA runtime system raises the `ex.fOverflow`
    exception.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Bit 4, if set, masks the *underflow* exception. Underflow occurs when the result
    is too *small* to fit in the destination operand. Like overflow, this exception
    can occur whenever you store a small extended-precision value into a smaller variable
    (single or double precision) or when the result of a computation is too small
    for extended precision. If you enable this exception and the FPU generates this
    interrupt, the HLA runtime system raises the `ex.fUnderflow` exception.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Bit 5 controls whether the *precision* exception can occur. A precision exception
    occurs whenever the FPU produces an imprecise result, generally the result of
    an internal rounding operation. Although many operations will produce an exact
    result, many more will not. For example, dividing 1 by 10 will produce an inexact
    result. Therefore, this bit is usually 1 because inexact results are very common.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.InexactResult` exception.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Bits 6..7 and 12..15 in the control register are currently undefined and reserved
    for future use (bits 7 and 12 were valid on older FPUs but are no longer used).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'The FPU provides two instructions, `fldcw` (load control word) and `fstcw`
    (store control word), that let you load and store the contents of the control
    register. The single operand to these instructions must be a 16-bit memory location.
    The `fldcw` instruction loads the control register from the specified memory location.
    `fstcw` stores the control register into the specified memory location. The syntax
    for these instructions is:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here''s some example code that sets the rounding control to "truncate result"
    and sets the rounding precision to 24 bits:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 6.5.1.3 The FPU Status Register
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FPU status register provides the status of the FPU at the instant you read
    it. The `fstsw` instruction stores the16-bit floating-point status register into
    a word variable. The status register is a 16-bit register; its layout appears
    in [Figure 6-3](ch06s05.html#the_fpu_status_register-id1 "Figure 6-3. The FPU
    status register").
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![The FPU status register](tagoreillycom20100401nostarchimages578025.png.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. The FPU status register
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Bits 0 through 5 are the exception flags. These bits appear in the same order
    as the exception masks in the control register. If the corresponding condition
    exists, then the bit is set. These bits are independent of the exception masks
    in the control register. The FPU sets and clears these bits regardless of the
    corresponding mask setting.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Bit 6 indicates a *stack fault*. A stack fault occurs whenever there is a stack
    overflow or underflow. When this bit is set, the C[1] condition code bit determines
    whether there was a stack overflow (C[1] = 1) or stack underflow (C[1] = 0) condition.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Bit 7 of the status register is set if *any* error condition bit is set. It
    is the logical `or` of bits 0 through 5\. A program can test this bit to quickly
    determine if an error condition exists.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Bits 8, 9, 10, and 14 are the coprocessor condition code bits. Various instructions
    set the condition code bits, as shown in [Table 6-10](ch06s05.html#fpu_condition_code_bits_open_parenthesis
    "Table 6-10. FPU Condition Code Bits (X = "Don't care")") and [Table 6-11](ch06s05.html#condition_code_interpretations_open_pare
    "Table 6-11. Condition Code Interpretations (X = "Don't care")"), respectively.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-10. FPU Condition Code Bits (X = "Don't care")
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Condition Code Bits | Condition |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '|   | C[3] | C[2] | C[1] | C[0] |   |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| `fcom``fcomp``fcompp``ficom``ficomp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST
    < sourceST = sourceST or source undefined |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| `ftst` | 0011 | 0001 | XXXX | 0101 | ST is positiveST is negativeST is 0
    (+ or −)ST is uncomparable |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| `fxam` | 0000111100001 | 001100110011X | 010101010101X | 000000011111 | +
    Unnormalized− Unnormalized+ Normalized− Normalized+ 0− 0+ Denormalized− Denormalized+
    NaN− NaN+ Infinity− InfinityEmpty register |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| `fucom``fucomp``fucompp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST < sourceST
    = sourceUnordered |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: Table 6-11. Condition Code Interpretations (X = “Don’t care”)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction(s)** | **Condition Code Bits** |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '|  | C[0] | C[3] | C[2] | C[1] |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| `fcom, fcomp, fcmpp, ftst, fucom, fucomp, fucompp, ficom, ficomp` | Result
    of comparison. See previous table. | Result of comparison. See previous table.
    | Operands are not comparable | Result of comparison. See previous table.Also
    denotes stack overflow/underflow if stack exception bit is set. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| `fxam` | See previous table. | See previous table. | See previous table.
    | Sign of result, or stack overflow/underflow (if stack exception bit is set).
    |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| `fprem, fprem1` | Bit 2 of remainder | Bit 0 of remainder | 0 – reduction
    done.1 – reduction incomplete. | Bit 1 of remainder or stack overflow/underflow
    (if stack exception bit is set). |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '| `fist, fbstp, frndint, fst, fstp, fadd, fmul, fdiv, fdivr, fsub, fsubr, fscale,
    fsqrt, fpatan, f2xm1, fyl2x, fyl2xp1` | Undefined | Undefined | Undefined | Round
    up occurred or stack overflow/underflow (if stack exception bit is set). |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| `fptan, fsin, fcos, fsincos` | Undefined | Undefined | 0 – reduction done.1
    – reduction incomplete. | Round up occurred or stack overflow/underflow (if stack
    exception bit is set). |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| `fchs, fabs, fxch, fincstp, fdecstp,``constant``loads,fxtract, fld, fild,
    fbld, fstp (80 bit)` | Undefined | Undefined | Undefined | Zero result or stack
    overflow/underflow (if stack exception bit is set). |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| `fldenv, fstor` | Restored from memory operand. | Restored from memory operand.
    | Restored from memory operand. | Restored from memory operand. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `fldcw, fstenv, fstcw, fstsw, fclex` | Undefined | Undefined | Undefined
    | Undefined |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `finit, fsave` | Cleared to zero. | Cleared to zero. | Cleared to zero. |
    Cleared to zero. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: Bits 11–13 of the FPU status register provide the register number of the top
    of stack. During computations, the FPU adds (modulo-8) the *logical* register
    numbers supplied by the programmer to these three bits to determine the *physical*
    register number at runtime.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Bit 15 of the status register is the *busy* bit. It is set whenever the FPU
    is busy. This bit is a historical artifact from the days when the FPU was a separate
    chip; most programs will have little reason to access this bit.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 FPU Data Types
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU supports seven different data types: three integer types, a packed
    decimal type, and three floating-point types. The integer type supports 64-bit
    integers, although it is often faster to do the 64-bit arithmetic using the integer
    unit of the CPU (see [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC")).
    Certainly it is faster to do 16-bit and 32-bit integer arithmetic using the standard
    integer registers. The packed decimal type provides a 17-digit signed decimal
    (BCD) integer. The primary purpose of the BCD format is to convert between strings
    and floating-point values. The remaining three data types are the 32-bit, 64-bit,
    and 80-bit floating-point data types. The 80x87 data types appear in [Figure 6-4](ch06s05.html#fpu_floating-point_formats
    "Figure 6-4. FPU floating-point formats"), [Figure 6-5](ch06s05.html#fpu_integer_formats
    "Figure 6-5. FPU integer formats"), and [Figure 6-6](ch06s05.html#fpu_packed_decimal_format
    "Figure 6-6. FPU packed decimal format").'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU floating-point formats](tagoreillycom20100401nostarchimages578027.png.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. FPU floating-point formats
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU integer formats](tagoreillycom20100401nostarchimages578029.png.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. FPU integer formats
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU packed decimal format](tagoreillycom20100401nostarchimages578031.png.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. FPU packed decimal format
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The FPU generally stores values in a *normalized* format. When a floating-point
    number is normalized, the H.O. bit of the mantissa is always 1\. In the 32- and
    64-bit floating-point formats, the FPU does not actually store this bit; the FPU
    always assumes that it is 1\. Therefore, 32- and 64-bit floating-point numbers
    are always normalized. In the extended-precision 80-bit floating-point format,
    the FPU does *not* assume that the H.O. bit of the mantissa is 1; the H.O. bit
    of the mantissa appears as part of the string of bits.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Normalized values provide the greatest precision for a given number of bits.
    However, there are a large number of nonnormalized values that we *cannot* represent
    with the 80-bit format. These values are very close to 0 and represent the set
    of values whose mantissa H.O. bit is not 0\. The FPUs support a special 80-bit
    form known as *denormalized* values. Denormalized values allow the FPU to encode
    very small values it cannot encode using normalized values, but denormalized values
    offer fewer bits of precision than normalized values. Therefore, using denormalized
    values in a computation may introduce some slight inaccuracy into a computation.
    Of course, this is always better than underflowing the denormalized value to 0
    (which could make the computation even less accurate), but you must keep in mind
    that if you work with very small values you may lose some accuracy in your computations.
    Note that the FPU status register contains a bit you can use to detect when the
    FPU uses a denormalized value in a computation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.3 The FPU Instruction Set
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU adds many instructions to the 80x86 instruction set. We can classify
    these instructions as data movement instructions, conversions, arithmetic instructions,
    comparisons, constant instructions, transcendental instructions, and miscellaneous
    instructions. The following sections describe each of the instructions in these
    categories.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4 FPU Data Movement Instructions
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data movement instructions transfer data between the internal FPU registers
    and memory. The instructions in this category are `fld`, `fst`, `fstp`, and `fxch`.
    The `fld` instruction always pushes its operand onto the floating-point stack.
    The `fstp` instruction always pops the top of stack after storing the top of stack
    (TOS). The remaining instructions do not affect the number of items on the stack.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.1 The fld Instruction
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fld` instruction loads a 32-bit, 64-bit, or 80-bit floating-point value
    onto the stack. This instruction converts 32- and 64-bit operands to an 80-bit
    extended-precision value before pushing the value onto the floating-point stack.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The `fld` instruction first decrements the TOS pointer (bits 11–13 of the status
    register) and then stores the 80-bit value in the physical register specified
    by the new TOS pointer. If the source operand of the FLD instruction is a floating-point
    data register, `st`*`i`*, then the actual register the FPU uses for the load operation
    is the register number *before* decrementing the TOS pointer. Therefore, `fld(
    st0 );` duplicates the value on the top of the stack.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The `fld` instruction sets the stack fault bit if stack overflow occurs. It
    sets the denormalized exception bit if you load an 80-bit denormalized value.
    It sets the invalid operation bit if you attempt to load an empty floating-point
    register onto the top of stack (or perform some other invalid operation).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that there is no way to directly load a 32-bit integer register onto the
    floating-point stack, even if that register contains a `real32` value. To accomplish
    this, you must first store the integer register into a memory location; then you
    can push that memory location onto the FPU stack using the `fld` instruction.
    For example:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that loading a constant via `fld` is actually an HLA extension. The FPU
    doesn't support this instruction type. HLA creates a `real80` object in the constants
    segment and uses the address of this memory object as the true operand for `fld`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.2 The fst and fstp Instructions
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fst` and `fstp` instructions copy the value on the top of the floating-point
    stack to another floating-point register or to a 32-, 64 -, or 80-bit memory variable.
    When copying data to a 32- or 64-bit memory variable, the FPU rounds the 80-bit
    extended-precision value on the top of stack to the smaller format as specified
    by the rounding control bits in the FPU control register.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The `fstp` instruction pops the value off the top of the stack when moving it
    to the destination location. It does this by incrementing the TOS pointer in the
    status register after accessing the data in ST0\. If the destination operand is
    a floating-point register, the FPU stores the value at the specified register
    number *before* popping the data off the top of the stack.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing an `fstp( st0 );` instruction effectively pops the data off the top
    of stack with no data transfer. Here are some examples:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The last example above effectively pops ST1 while leaving ST0 on the top of
    stack.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The `fst` and `fstp` instructions will set the stack exception bit if a stack
    underflow occurs (attempting to store a value from an empty register stack). They
    will set the precision bit if there is a loss of precision during the store operation
    (this will occur, for example, when storing an 80-bit extended-precision value
    into a 32- or 64-bit memory variable and some bits are lost during conversion).
    They will set the underflow exception bit when storing an 80-bit value into a
    32- or 64-bit memory variable, but the value is too small to fit into the destination
    operand. Likewise, these instructions will set the overflow exception bit if the
    value on the top of stack is too big to fit into a 32- or 64-bit memory variable.
    The `fst` and `fstp` instructions set the denormalized flag when you try to store
    a denormalized value into an 80-bit register or variable.^([[103](#ftn.CHP-6-FN-2)])
    They set the invalid operation flag if an invalid operation (such as storing into
    an empty register) occurs. Finally, these instructions set the C[1] condition
    bit if rounding occurs during the store operation (this occurs only when storing
    into a 32- or 64-bit memory variable and you have to round the mantissa to fit
    into the destination).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of an idiosyncrasy in the FPU instruction set related to the encoding
    of the instructions, you cannot use the `fst` instruction to store data into a
    `real80` memory variable. You may, however, store 80-bit data using the `fstp`
    instruction.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.3 The fxch Instruction
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fxch` instruction exchanges the value on the top of stack with one of
    the other FPU registers. This instruction takes two forms: one with a single FPU
    register as an operand and the second without any operands. The first form exchanges
    the top of stack with the specified register. The second form of `fxch` swaps
    the top of stack with ST1.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Many FPU instructions, for example, `fsqrt`, operate only on the top of the
    register stack. If you want to perform such an operation on a value that is not
    on the top of stack, you can use the `fxch` instruction to swap that register
    with TOS, perform the desired operation, and then use the `fxch` to swap the TOS
    with the original register. The following example takes the square root of ST2:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `fxch` instruction sets the stack exception bit if the stack is empty. It
    sets the invalid operation bit if you specify an empty register as the operand.
    This instruction always clears the C[1] condition code bit.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5 Conversions
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU performs all arithmetic operations on 80-bit real quantities. In a sense,
    the `fld` and `fst`/`fstp` instructions are conversion instructions because they
    automatically convert between the internal 80-bit real format and the 32- and
    64-bit memory formats. Nonetheless, we'll simply classify them as data movement
    operations, rather than conversions, because they are moving real values to and
    from memory. The FPU provides six other instructions that convert to or from integer
    or binary-coded decimal (BCD) format when moving data. These instructions are
    `fild`, `fist`, `fistp`, `fisttp`, `fbld`, and `fbstp`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5.1 The fild Instruction
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fild` (integer load) instruction converts a 16-, 32-, or 64-bit two's complement
    integer to the 80-bit extended-precision format and pushes the result onto the
    stack. This instruction always expects a single operand. This operand must be
    the address of a word, double-word, or quad-word integer variable. You cannot
    specify one of the 80x86's 16- or 32-bit general-purpose registers. If you want
    to push the value of an 80x86 general-purpose register onto the FPU stack, you
    must first store it into a memory variable and then use `fild` to push that memory
    variable.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'The fild instruction sets the stack exception bit and C[1] (accordingly) if
    stack overflow occurs while pushing the converted value. Look at these examples:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 6.5.5.2 The fist, fistp, and fisttp Instructions
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fist`, `fistp`, and `fisttp` instructions convert the 80-bit extended-precision
    variable on the top of stack to a 16-, 32-, or 64-bit integer and store the result
    away into the memory variable specified by the single operand. The `fist` and
    `fistp` instructions convert the value on TOS to an integer according to the rounding
    setting in the FPU control register (bits 10 and 11). The `fisttp` instruction
    always does the conversion using the truncation mode. As for the `fild` instruction,
    the `fist`, `fistp`, and `fisttp` instructions will not let you specify one of
    the 80x86's general-purpose 16- or 32-bit registers as the destination operand.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The `fist` instruction converts the value on the top of stack to an integer
    and then stores the result; it does not otherwise affect the floating-point register
    stack. The `fistp` and `fisttp` instructions pop the value off the floating-point
    register stack after storing the converted value.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions set the stack exception bit if the floating-point register
    stack is empty (this will also clear C[1]). They set the precision (imprecise
    operation) and C[1] bits if rounding occurs (that is, if there is any fractional
    component to the value in ST0). These instructions set the underflow exception
    bit if the result is too small (that is, less than 1 but greater than 0 or less
    than 0 but greater than −1). Here are some examples:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Don''t forget that the `fist` and `fistp` instructions use the rounding control
    settings to determine how they will convert the floating-point data to an integer
    during the store operation. Be default, the rounding control is usually set to
    "round" mode; yet most programmers expect `fist`/`fistp` to truncate the decimal
    portion during conversion. If you want `fist`/`fistp` to truncate floating-point
    values when converting them to an integer, you will need to set the rounding control
    bits appropriately in the floating-point control register (or use the `fisttp`
    instruction to truncate the result regardless of the rounding control bits). Here''s
    an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 6.5.5.3 The fbld and fbstp Instructions
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fbld` and `fbstp` instructions load and store 80-bit BCD values. The `fbld`
    instruction converts a BCD value to its 80-bit extended-precision equivalent and
    pushes the result onto the stack. The `fbstp` instruction pops the extended-precision
    real value on TOS, converts it to an 80-bit BCD value (rounding according to the
    bits in the floating-point control register), and stores the converted result
    at the address specified by the destination memory operand. Note that there is
    no `fbst` instruction.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fbld` instruction sets the stack exception bit and C[1] if stack overflow
    occurs. It sets the invalid operation bit if you attempt to load an invalid BCD
    value. The `fbstp` instruction sets the stack exception bit and clears C[1] if
    stack underflow occurs (the stack is empty). It sets the underflow flag under
    the same conditions as `fist` and `fistp`. Look at these examples:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: These two instructions are especially useful for converting between string and
    floating-point formats. See the floating-point-to-string and string-to-floating-point
    conversion routines in the HLA Standard Library for more details.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6 Arithmetic Instructions
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arithmetic instructions make up a small but important subset of the FPU''s
    instruction set. These instructions fall into two general categories: those that
    operate on real values and those that operate on a real and an integer value.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.1 The fadd and faddp Instructions
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two instructions take the following forms:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `fadd` instruction, with no operands, adds the value in ST0 to the value
    in ST1 and stores the result into ST1\. The `faddp` instruction (with no operands)
    pops the two values on the top of stack, adds them, and pushes their sum back
    onto the stack.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The next two forms of the `fadd` instruction, those with two FPU register operands,
    behave like the 80x86's `add` instruction. They add the value in the source register
    operand to the value in the destination register operand. Note that one of the
    register operands must be ST0.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The `faddp` instruction with two operands adds ST0 (which must always be the
    source operand) to the destination operand and then pops ST0\. The destination
    operand must be one of the other FPU registers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: The last form above, `fadd` with a memory operand, adds a 32- or 64-bit floating-point
    variable to the value in ST0\. This instruction will convert the 32- or 64-bit
    operands to an 80-bit extended-precision value before performing the addition.
    Note that this instruction does *not* allow an 80-bit memory operand.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Like `fld(` *`real_constant`*`)`, the `fadd(` *`real_constant`* `)` instruction
    is an HLA extension. Note that it creates a 64-bit variable holding the constant
    value and emits the `fadd(` *`mem64`* `)` instruction, specifying the read-only
    object it creates in the constants segment.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These four instructions take the following forms:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With no operands, the `fsub` instruction subtracts ST0 from ST1 and leaves the
    result in ST1\. With no operands the `fsubp` instruction pops ST0 and ST1 from
    the register stack, computes `st1 - st0` and then pushes the difference back onto
    the stack. The `fsubr` and `fsubrp` instructions (reverse subtraction) operate
    in an almost identical fashion except they compute `st0 - st1`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: With two register operands (*`source`*, *`destination`*) the `fsub` instruction
    computes *`destination`* `:=` *`destination`* `-` *`source`*. One of the two registers
    must be ST0\. With two registers as operands, the `fsubp` also computes *`destination`*
    `:=` *`destination`* `-` *`source`*, and then it pops ST0 off the stack after
    computing the difference. For the `fsubp` instruction, the source operand must
    be ST0.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: With two register operands, the `fsubr` and `fsubrp` instructions work in a
    similar fashion to `fsub` and `fsubp`, except they compute *`destination`* `:=`
    *`source`* `-` *`destination`*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: The `fsub(` *`mem`* `)` and `fsubr(` *`mem`* `)` instructions accept a 32- or
    64-bit memory operand. They convert the memory operand to an 80-bit extended-precision
    value and subtract this from ST0 (`fsub`) or subtract ST0 from this value (`fsubr`)
    and store the result back into ST0.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instructions that have real constants as operands aren't true FPU instructions.
    These are extensions provided by HLA. HLA generates a constant segment memory
    object initialized with the constant's value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.3 The fmul and fmulp Instructions
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fmul` and `fmulp` instructions multiply two floating-point values. These
    instructions allow the following forms:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: With no operands, `fmul` will compute `st0 * st1` and store the product into
    ST1\. The `fmulp` instruction, with no operands, will pop ST0 and ST1, multiply
    these values, and push their product back onto the stack. The `fmul` instructions
    with two register operands compute *`destination`* `:=` *`destination`* `*` *`source`*.
    One of the registers (source or destination) must be ST0.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The `fmulp( st0, st`*`i`* `)` instruction computes `st`*`i`* `:= st`*`i`* `*
    st0` and then pops ST0\. This instruction uses the value for ST*i* before popping
    ST0\. The `fmul(` *`mem`* `)` instruction requires a 32- or 64-bit memory operand.
    It converts the specified memory variable to an 80-bit extended-precision value
    and then multiplies ST0 by this value.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If rounding occurs during the
    computation, these instructions set the C[1] condition code bit. If a stack fault
    exception occurs, C[1] denotes stack overflow or underflow.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instruction that has a real constant as its operand isn't a true FPU instruction.
    It is an extension provided by HLA (see the note at the end of [6.5.6.2 The fsub,
    fsubp, fsubr, and fsurpb Instructions](ch06s05.html#the_fsub_comma_fsubp_comma_fsubr_comma_a
    "6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions") for details).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.4 The fdiv, fdivp, fdivr, and fdivrp Instructions
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These four instructions allow the following forms:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: With no operands, the `fdivp` instruction pops ST0 and ST1, computes `st1/st0`,
    and pushes the result back onto the stack. The `fdiv` instruction with no operands
    computes `st1 := st1/st0`. The `fdivr` and `fdivrp` instructions work in a similar
    fashion to `fdiv` and `fdivp` except that they compute `st0/st1` rather than `st1/st0`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'With two register operands, these instructions compute the following quotients:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `fdivp` and `fdivrp` instructions also pop ST0 after performing the division
    operation. The value for *`i`* in these two instructions is computed before popping
    ST0.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    zero divide, and illegal operation exceptions, as appropriate. If rounding occurs
    during the computation, these instructions set the C[1] condition code bit. If
    a stack fault exception occurs, C[1] denotes stack overflow or underflow.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.5 The fsqrt Instruction
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fsqrt` routine does not allow any operands. It computes the square root
    of the value on top of stack (TOS) and replaces ST0 with this result. The value
    on TOS must be 0 or positive; otherwise `fsqrt` will generate an invalid operation
    exception.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: This instruction can raise the stack, precision, denormalized, and invalid operation
    exceptions, as appropriate. If rounding occurs during the computation, `fsqrt`
    sets the C[1] condition code bit. If a stack fault exception occurs, C[1] denotes
    stack overflow or underflow.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 6.5.6.6 The fprem and fprem1 Instructions
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fprem` and `fprem1` instructions compute a *partial remainder*. Intel designed
    the `fprem` instruction before the IEEE finalized its floating-point standard.
    In the final draft of the IEEE floating-point standard, the definition of `fprem`
    was a little different than Intel's original design. Unfortunately, Intel needed
    to maintain compatibility with the existing software that used the `fprem` instruction,
    so it designed a new version to handle the IEEE partial remainder operation, `fprem1`.
    You should always use `fprem1` in new software; therefore we will discuss only
    `fprem1` here, although you use `fprem` in an identical fashion.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '`fprem1` computes the *partial* remainder of `st0/st1`. If the difference between
    the exponents of ST0 and ST1 is less than 64, `fprem1` can compute the exact remainder
    in one operation. Otherwise you will have to execute the `fprem1` two or more
    times to get the correct remainder value. The C[2] condition code bit determines
    when the computation is complete. Note that `fprem1` does *not* pop the two operands
    off the stack; it leaves the partial remainder in ST0 and the original divisor
    in ST1 in case you need to compute another partial product to complete the result.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The `fprem1` instruction sets the stack exception flag if there aren't two values
    on the top of stack. It sets the underflow and denormal exception bits if the
    result is too small. It sets the invalid operation bit if the values on TOS are
    inappropriate for this operation. It sets the C[2] condition code bit if the partial
    remainder operation is not complete. Finally, it loads C[3], C[1], and C[0] with
    bits 0, 1, and 2 of the quotient, respectively.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'An example follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 6.5.6.7 The frndint Instruction
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `frndint` instruction rounds the value on the top of stack (TOS) to the
    nearest integer using the rounding algorithm specified in the control register.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: This instruction sets the stack exception flag if there is no value on the TOS
    (it will also clear C[1] in this case). It sets the precision and denormal exception
    bits if there was a loss of precision. It sets the invalid operation flag if the
    value on the TOS is not a valid number. Note that the result on TOS is still a
    floating-point value; it simply does not have a fractional component.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.8 The fabs Instruction
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fabs` computes the absolute value of ST0 by clearing the mantissa sign bit
    of ST0\. It sets the stack exception bit and invalid operation bits if the stack
    is empty.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 6.5.6.9 The fchs Instruction
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fchs` changes the sign of ST0''s value by inverting the mantissa sign bit
    (that is, this is the floating-point negation instruction). It sets the stack
    exception bit and invalid operation bits if the stack is empty.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 6.5.7 Comparison Instructions
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU provides several instructions for comparing real values. The `fcom`,
    `fcomp`, and `fcompp` instructions compare the two values on the top of stack
    and set the condition codes appropriately. The `ftst` instruction compares the
    value on the top of stack with 0.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Generally, most programs test the condition code bits immediately after a comparison.
    Unfortunately, there are no FPU instructions that test the FPU condition codes.
    Instead, you use the `fstsw` instruction to copy the floating-point status register
    into the AX register; then you can use the `sahf` instruction to copy the AH register
    into the 80x86's condition code bits. After doing this, you can test the standard
    80x86 flags to check for some condition. This technique copies C[0] into the carry
    flag, C[2] into the parity flag, and C[3] into the zero flag. The `sahf` instruction
    does not copy C[1] into any of the 80x86's flag bits.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Because the `sahf` instruction does not copy any FPU status bits into the sign
    or overflow flags, you cannot use signed comparison instructions. Instead, use
    unsigned operations (e.g., `seta`, `setb`) when testing the results of a floating-point
    comparison. *Yes, these instructions normally test unsigned values, and floating-point
    numbers are signed values*. However, use the unsigned operations anyway; the `fstsw`
    and `sahf` instructions set the 80x86 flags register as though you had compared
    unsigned values with the `cmp` instruction.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: The Pentium II and (upward) compatible processors provide an extra set of floating-point
    comparison instructions that directly affect the 80x86 condition code flags. These
    instructions circumvent having to use `fstsw` and `sahf` to copy the FPU status
    into the 80x86 condition codes. These instructions include `fcomi` and `fcomip`.
    You use them just like the `fcom` and `fcomp` instructions, except, of course,
    you do not have to manually copy the status bits to the FLAGS register.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.7.1 The fcom, fcomp, and fcompp Instructions
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fcom`, `fcomp`, and `fcompp` instructions compare ST0 to the specified
    operand and set the corresponding FPU condition code bits based on the result
    of the comparison. The legal forms for these instructions are:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: With no operands, `fcom`, `fcomp`, and `fcompp` compare ST0 against ST1 and
    set the FPU flags accordingly. In addition, `fcomp` pops ST0 off the stack and
    `fcompp` pops both ST0 and ST1 off the stack.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: With a single-register operand, `fcom` and `fcomp` compare `ST0` against the
    specified register. `fcomp` also pops ST0 after the comparison.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: With a 32- or 64-bit memory operand, the `fcom` and `fcomp` instructions convert
    the memory variable to an 80-bit extended-precision value and then compare ST0
    against this value, setting the condition code bits accordingly. `fcomp` also
    pops ST0 after the comparison.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set C[2] (which winds up in the parity flag) if the two operands
    are not comparable (e.g., `NaN`). If it is possible for an illegal floating-point
    value to wind up in a comparison, you should check the parity flag for an error
    before checking the desired condition (e.g., using HLA's `@p` and `@np` conditions,
    or by using the `setp`/`setnp` instructions).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set the stack fault bit if there aren't two items on the
    top of the register stack. They set the denormalized exception bit if either or
    both operands are denormalized. They set the invalid operation flag if either
    or both operands are quiet `NaN`s. These instructions always clear the C[1] condition
    code.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA. When HLA encounters such
    an instruction, it creates a `real64` read-only variable in the constants segment
    and initializes this variable with the specified constant. Then HLA translates
    the instruction to one that specifies a `real64` memory operand.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the precision differences (64 bits versus 80 bits), if you use a
    constant operand in a floating-point instruction you may not get results that
    are as precise as you would expect.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a floating-point comparison:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Note that you cannot compare floating-point values in an HLA runtime boolean
    expression (e.g., within an `if` statement). You may, however, test the conditions
    in such statements after a floating-point comparison like the sequence above.
    For example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 6.5.7.2 The fcomi and fcomip Instructions
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fcomi` and `fcomip` instructions compare ST0 to the specified operand
    and set the corresponding EFLAG condition code bits based on the result of the
    comparison. You use these instructions in a similar manner to `fcom` and `fcomp`
    except you can test the CPU''s flag bits directly after the execution of these
    instructions without first moving the FPU status bits into the EFLAGS register.
    The legal forms for these instructions are as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 6.5.7.3 The ftst Instruction
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ftst` instruction compares the value in ST0 against 0.0\. It behaves just
    like the `fcom` instruction would if ST1 contained 0.0\. Note that this instruction
    does not differentiate −0.0 from +0.0\. If the value in ST0 is either of these
    values, `ftst` will set C[3] to denote equality. This instruction does *not* pop
    ST0 off the stack.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 6.5.8 Constant Instructions
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU provides several instructions that let you load commonly used constants
    onto the FPU''s register stack. These instructions set the stack fault, invalid
    operation, and C[1] flags if a stack overflow occurs; they do not otherwise affect
    the FPU flags. The specific instructions in this category include the following:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 6.5.9 Transcendental Instructions
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU provides eight transcendental (logarithmic and trigonometric) instructions
    to compute sine, cosine, partial tangent, partial arctangent, 2*x* - 1, *y* *
    log[2](*x*), and *y* * log[2](*x* + 1). Using various algebraic identities, it
    is easy to compute most of the other common transcendental functions using these
    instructions.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.1 The f2xm1 Instruction
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`f2xm1` computes 2^(ST0) - 1\. The value in ST0 must be in the range −1.0..ST0..+1.0\.
    If ST0 is out of range, `f2xm1` generates an undefined result but raises no exceptions.
    The computed value replaces the value in ST0.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example computing 10^(*x*) using the identity 10^(*x*) = 2^(*x* *log2(10)).
    This is only useful for a small range of *x* that doesn't put ST0 outside of the
    previously mentioned valid range.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note that `f2xm1` computes 2*x* - 1, which is why the code above adds 1.0 to
    the result at the end of the computation.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.2 The fsin, fcos, and fsincos Instructions
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These instructions pop the value off the top of the register stack and compute
    the sine, cosine, or both and push the result(s) back onto the stack. The `fsincos`
    instruction pushes the sine followed by the cosine of the original operand; hence
    it leaves cos(ST0) in ST0 and sin(ST0) in ST1.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: These instructions assume ST0 specifies an angle in radians and this angle must
    be in the range −2^(63) < ST0 < +2^(63). If the original operand is out of range,
    these instructions set the C[2] flag and leave ST0 unchanged. You can use the
    `fprem1` instruction, with a divisor of 2π, to reduce the operand to a reasonable
    range.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set the stack fault/C[1], precision, underflow, denormalized,
    and invalid operation flags according to the result of the computation.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.3 The fptan Instruction
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fptan` computes the tangent of ST0 and pushes this value, and then it pushes
    1.0 onto the stack. Like the `fsin` and `fcos` instructions, the value of ST0
    must be in radians and in the range −2^(63) < ST0 < +2^(63). If the value is outside
    this range, `fptan` sets C[2] to indicate that the conversion did not take place.
    As with the `fsin`, `fcos`, and `fsincos` instructions, you can use the `fprem1`
    instruction to reduce this operand to a reasonable range using a divisor of 2π.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is invalid (i.e., zero or π radians, which causes a division
    by 0), the result is undefined and this instruction raises no exceptions. `fptan`
    will set the stack fault, precision, underflow, denormal, invalid operation, C[2],
    and C[1] bits as required by the operation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.4 The fpatan Instruction
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This instruction expects two values on the top of stack. It pops them and computes
    ST0 = tan^(−1)(ST1/ST0).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: The resulting value is the arctangent of the ratio on the stack expressed in
    radians. If you have a value you wish to compute the tangent of, use `fld1` to
    create the appropriate ratio and then execute the `fpatan` instruction.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: This instruction affects the stack fault/C[1], precision, underflow, denormal,
    and invalid operation bits if a problem occurs during the computation. It sets
    the C[1] condition code bit if it has to round the result.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.5 The fyl2x Instruction
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0).'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction has no operands (to the instruction itself ). The instruction
    uses the following syntax:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note that this instruction computes the base-2 logarithm. Of course, it is a
    trivial matter to compute the log of any other base by multiplying by the appropriate
    constant.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.6 The fyl2xp1 Instruction
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0 + 1.0).'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this instruction is:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Otherwise, the instruction is identical to `fyl2x`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10 Miscellaneous Instructions
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU includes several additional instructions that control the FPU, synchronize
    operations, and let you test or set various status bits. These instructions include
    `finit`/`fninit`, `fldcw`, `fstcw`, `fclex`/`fnclex`, and `fstsw`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.1 The finit and fninit Instructions
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `finit` instruction initializes the FPU for proper operation. Your applications
    should execute this instruction before executing any other FPU instructions. This
    instruction initializes the control register to $37F, the status register to 0,
    and the tag word to $FFFF. The other registers are unaffected.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The difference between `finit` and `fninit` is that `finit` first checks for
    any pending floating-point exceptions before initializing the FPU; `fninit` does
    not.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.2 The fldcw and fstcw Instructions
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fldcw` and `fstcw` instructions require a single 16-bit memory operand:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: These two instructions load the control register from a memory location (`fldcw`)
    or store the control word to a 16-bit memory location (`fstcw`).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: When using the `fldcw` instruction to turn on one of the exceptions, if the
    corresponding exception flag is set when you enable that exception, the FPU will
    generate an immediate interrupt before the CPU executes the next instruction.
    Therefore, you should use the `fclex` instruction to clear any pending interrupts
    before changing the FPU exception enable bits.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.3 The fclex and fnclex Instructions
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fclex` and `fnclex` instructions clear all exception bits, the stack fault
    bit, and the busy flag in the FPU status register.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The difference between these instructions is the same as between `finit` and
    `fninit`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.4 The fstsw and fnstsw Instructions
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These instructions store the FPU status register into a 16-bit memory location
    or the AX register.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: These instructions are unusual in the sense that they can copy an FPU value
    into one of the 80x86 general-purpose registers (specifically, AX). Of course,
    the whole purpose behind allowing the transfer of the status register into AX
    is to allow the CPU to easily test the condition code register with the `sahf`
    instruction. The difference between `fstsw` and `fnstsw` is the same as for `fclex`
    and `fnclex`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.11 Integer Operations
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU provides special instructions that combine integer-to-extended-precision
    conversion with various arithmetic and comparison operations. These instructions
    are the following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: These instructions convert their 16- or 32-bit integer operands to an 80-bit
    extended-precision floating-point value and then use this value as the source
    operand for the specified operation. These instructions use ST0 as the destination
    operand.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: ^([[102](#CHP-6-FN-1)]) Intel has also referred to this device as the Numeric
    Data Processor (NDP), Numeric Processor Extension (NPX), and math coprocessor.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: ^([[103](#CHP-6-FN-2)]) Storing a denormalized value into a 32- or 64-bit memory
    variable will always set the underflow exception bit.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Converting Floating-Point Expressions to Assembly Language
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because the FPU register organization is different than the 80x86 integer register
    set, translating arithmetic expressions involving floating-point operands is a
    little different than the techniques for translating integer expressions. Therefore,
    it makes sense to spend some time discussing how to manually translate floating-point
    expressions into assembly language.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: In one respect, it's actually easier to translate floating-point expressions
    into assembly language. The stack architecture of the Intel FPU eases the translation
    of arithmetic expressions into assembly language. If you've ever used a Hewlett-Packard
    calculator, you'll be right at home on the FPU because, like the HP calculator,
    the FPU uses *postfix notation* (also called *Reverse Polish notation*, or *RPN*
    ), for arithmetic operations. Once you get used to using postfix notation, it's
    actually a bit more convenient for translating expressions because you don't have
    to worry about allocating temporary variables—they always wind up on the FPU stack.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'Postfix notation, as opposed to standard *infix notation*, places the operands
    before the operator. The following examples give some simple examples of infix
    notation and the corresponding postfix notation:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A postfix expression like `5 6 +` says, "push 5 onto the stack, push 6 onto
    the stack, and then pop the value off the top of stack (6) and add it to the new
    top of stack." Sound familiar? This is exactly what the `fld` and `fadd` instructions
    do. In fact, you can calculate this using the following code:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As you can see, postfix is a convenient notation because it's very easy to translate
    this code into FPU instructions.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage to postfix notation is that it doesn''t require any parentheses.
    The following examples demonstrate some slightly more complex infix-to-postfix
    conversions:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The postfix expression `x y + 2 *` says, "Push `x`, then push `y`; next, add
    those values on the stack (producing `x + y` on the stack). Next, push 2 and then
    multiply the two values (2 and `x + y`) on the stack to produce two times the
    quantity `x + y`." Once again, we can translate these postfix expressions directly
    into assembly language. The following code demonstrates the conversion for each
    of the above expressions:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 6.6.1 Converting Arithmetic Expressions to Postfix Notation
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the process of translating arithmetic expressions into assembly language
    involves postfix notation (RPN), converting arithmetic expressions into postfix
    notation seems like a good place to begin our discussion of floating-point expression
    conversion. This section will concentrate on postfix conversion.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: For simple expressions, those involving two operands and a single expression,
    the translation is trivial. Simply move the operator from the infix position to
    the postfix position (that is, move the operator from between the operands to
    after the second operand). For example, `5 + 6` becomes `5 6 +`. Other than separating
    your operands so you don't confuse them (i.e., is it 5 and 6 or 56?), converting
    simple infix expressions into postfix notation is straightforward.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: For complex expressions, the idea is to convert the simple subexpressions into
    postfix notation and then treat each converted subexpression as a single operand
    in the remaining expression. The following discussion surrounds completed conversions
    with square brackets so it is easy to see which text needs to be treated as a
    single operand in the conversion.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'As for integer expression conversion, the best place to start is in the innermost
    parenthetical subexpression and then work your way outward considering precedence,
    associativity, and other parenthetical subexpressions. As a concrete working example,
    consider the following expression:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'A possible first translation is to convert the subexpression `(y - z)` into
    postfix notation:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Square brackets surround the converted postfix code just to separate it from
    the infix code. These exist only to make the partial translations more readable.
    Remember, for the purposes of conversion we will treat the text inside the square
    brackets as a single operand. Therefore, you would treat `[y z -]` as though it
    were a single variable name or constant.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to translate the subexpression `([y z -] * a )` into postfix
    form. This yields the following:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we work on the parenthetical expression `( a + b * c )`. Because multiplication
    has higher precedence than addition, we convert `b * c` first:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'After converting `b * c` we finish the parenthetical expression:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This leaves only two infix operators: subtraction and division. Because division
    has the higher precedence, we''ll convert that first:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finally, we convert the entire expression into postfix notation by dealing
    with the last infix operation, subtraction:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Removing the square brackets to give us true postfix notation yields the following
    postfix expression:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The following steps demonstrate another infix-to-postfix conversion for the
    expression:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Work inside the parentheses. Because multiplication has the highest precedence,
    convert that first:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Still working inside the parentheses, we note that addition and subtraction
    have the same precedence, so we rely on associativity to determine what to do
    next. These operators are left associative, so we must translate the expressions
    in a left-to-right order. This means translate the subtraction operator first:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now translate the addition operator inside the parentheses. Because this finishes
    the parenthetical operators, we can drop the parentheses:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Translate the final infix operator (division). This yields the following:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Drop the square brackets and we''re done:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 6.6.2 Converting Postfix Notation to Assembly Language
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've translated an arithmetic expression into postfix notation, finishing
    the conversion to assembly language is easy. All you have to do is issue an `fld`
    instruction whenever you encounter an operand and issue an appropriate arithmetic
    instruction when you encounter an operator. This section uses the completed examples
    from the previous section to demonstrate how little there is to this process.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Convert `y` to `fld(y)`.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `z` to `fld(z)`.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `-` to `fsub()`.
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `a` to `fld(a)`.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `*` to `fmul()`.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continuing in a left-to-right fashion, generate the following code for the
    expression:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Here''s the translation for the second example in the previous section:'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: As you can see, the translation is fairly simple once you've converted the infix
    notation to postfix notation. Also note that, unlike integer expression conversion,
    you don't need any explicit temporaries. It turns out that the FPU stack provides
    the temporaries for you.^([[104](#ftn.CHP-6-FN-3)]) For these reasons, conversion
    of floating-point expressions into assembly language is actually easier than converting
    integer expressions.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: ^([[104](#CHP-6-FN-3)]) This assumes, of course, that your calculations aren't
    so complex that you exceed the eight-element limitation of the FPU stack.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 HLA Standard Library Support for Floating-Point Arithmetic
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") briefly mentioned the
    `stdin.getf` function. What it left out of that discussion is where `stdin.getf`
    returns the floating-point value is reads from the standard input. Now that you''ve
    seen the floating-point extensions to the 80x86, it''s possible to finish the
    discussion of that standard library function. The `stdin.getf` function reads
    a string of characters from the standard input, converts those characters to an
    80-bit floating-point number, and leaves the result sitting on the FPU stack (in
    ST0).'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library also provides the `math.hhf` module that includes several
    mathematical functions that the FPU doesn't directly support as well as support
    for various functions (like sine and cosine) that the FPU partially supports.
    Some of the functions that the `math.hhf` module provides are `acos`, `acot`,
    `acsc`, `asec`, `asin`, `cot`, `csc`, `sec`, `2^x`, `10^x`, `y^x`, `e^x`, `log`,
    and `ln`. Please consult the HLA standard library documentation for more information
    about these functions and other mathematical functions the HLA standard library
    supports.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 For More Information
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Intel/AMD processor manuals fully describe the operation of each of the
    integer and floating-point arithmetic instructions, including a detailed description
    of how these instructions affect the condition code bits and other flags in the
    EFLAGS and FPU status registers. To write the best possible assembly language
    code, you need to be intimately familiar with how the arithmetic instructions
    affect the execution environment, so spending time with the Intel/AMD manuals
    is a good idea.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library provides a large number of floating-point functions
    for which there are no individual machine instructions. The HLA Standard Library
    also provides functions like `math.sin` and `math.cos` that overcome limitations
    of the native machine instructions. See the HLA Standard Library reference manual
    for more details. Also, the HLA Standard Library is available in source code form,
    so you can look at the implementation of these mathematical functions for more
    examples of floating-point coding.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") discusses multiprecision
    integer arithmetic. See that chapter for details on handling integer operands
    that are greater than 32 bits in size.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 SSE instruction set found on later members of the CPU provides support
    for floating-point arithmetic using the SSE register set. Consult [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or the Intel/AMD documentation for details concerning the SSE floating-point instruction
    set.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
