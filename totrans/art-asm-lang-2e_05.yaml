- en: Chapter 6. ARITHMETIC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![ARITHMETIC](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses arithmetic computation in assembly language. By the end
    of this chapter you should be able to translate arithmetic expressions and assignment
    statements from high-level languages like Pascal and C/C++ into 80x86 assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 80x86 Integer Arithmetic Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before describing how to encode arithmetic expressions in assembly language,
    it would be a good idea to first discuss the remaining arithmetic instructions
    in the 80x86 instruction set. Previous chapters have covered most of the arithmetic
    and logical instructions, so this section covers the few remaining instructions
    you'll need.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 The mul and imul Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The multiplication instructions provide you with another taste of irregularity
    in the 80x86's instruction set. Instructions like `add`, `sub`, and many others
    in the 80x86 instruction set support two operands, just like the `mov` instruction.
    Unfortunately, there weren't enough bits in the 80x86's opcode byte to support
    all instructions, so the 80x86 treats the `mul` (unsigned multiply) and `imul`
    (signed integer multiply) instructions as single-operand instructions, just like
    the `inc`, `dec`, and `neg` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, multiplication *is* a two-operand function. To work around this fact,
    the 80x86 always assumes the accumulator (AL, AX, or EAX) is the destination operand.
    This irregularity makes using multiplication on the 80x86 a little more difficult
    than other instructions because one operand has to be in the accumulator. Intel
    adopted this unorthogonal approach because it felt that programmers would use
    multiplication far less often than instructions like `add` and `sub`.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the `mul` and `imul` instructions is that you cannot multiply
    the accumulator by a constant using these instructions. Intel quickly discovered
    the need to support multiplication by a constant and added the `intmul` instruction
    to overcome this problem. Nevertheless, you must be aware that the basic `mul`
    and `imul` instructions do not support the full range of operands as `intmul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of the multiply instruction: unsigned multiplication (`mul`)
    and signed multiplication (`imul`). Unlike addition and subtraction, you need
    separate instructions for signed and unsigned operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiply instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsigned multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Signed (integer) multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The returns values above are the strings these instructions return for use with
    instruction composition in HLA. (`i`)`mul`, available on all 80x86 processors,
    multiplies 8-, 16-, or 32-bit operands.
  prefs: []
  type: TYPE_NORMAL
- en: When multiplying two *n*-bit values, the result may require as many as 2 * *n*
    bits. Therefore, if the operand is an 8-bit quantity, the result could require
    16 bits. Likewise, a 16-bit operand produces a 32-bit result and a 32-bit operand
    requires 64 bits to hold the result.
  prefs: []
  type: TYPE_NORMAL
- en: The (`i`)`mul` instruction, with an 8-bit operand, multiplies AL by the operand
    and leaves the 16-bit product in AX. So
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: computes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`*` represents an unsigned multiplication for `mul` and a signed multiplication
    for `imul`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a 16-bit operand, then `mul` and `imul` compute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`*` has the same meanings as above, and `dx:ax` means that DX contains the
    H.O. word of the 32-bit result and AX contains the L.O. word of the 32-bit result.
    If you''re wondering why Intel didn''t put the 32-bit result in EAX, just note
    that Intel introduced the `mul` and `imul` instructions in the earliest 80x86
    processors, before the advent of 32-bit registers in the 80386 CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specify a 32-bit operand, then `mul` and `imul` compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`*` has the same meanings as above, and `edx:eax` means that EDX contains the
    H.O. double word of the 64-bit result and EAX contains the L.O. double word of
    the 64-bit result.'
  prefs: []
  type: TYPE_NORMAL
- en: If an 8×8-, 16×16-, or 32×32-bit product requires more than 8, 16, or 32 bits
    (respectively), the `mul` and `imul` instructions set the carry and overflow flags.
    `mul` and `imul` scramble the sign and zero flags.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Especially note that the sign and zero flags do not contain meaningful values
    after the execution of these two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help reduce some of the syntax irregularities with the use of the `mul`
    and `imul` instructions, HLA provides an extended syntax that allows the following
    two-operand forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsigned multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Signed (integer) multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The two-operand forms let you specify the (L.O.) destination register as the
    second operand. By specifying the destination register you can make your programs
    easier to read. Note that just because HLA allows two operands here, you can't
    specify an arbitrary register. The destination operand must always be AL, AX,
    or EAX, depending on the source operand.
  prefs: []
  type: TYPE_NORMAL
- en: HLA provides a form that lets you specify a constant. The 80x86 doesn't actually
    support a `mul` or `imul` instruction that has a constant operand. HLA will take
    the constant you specify and create a variable in a read-only segment in memory
    and initialize that variable with this value. Then HLA converts the instruction
    to the (`i`)`mul`( *`memory`* ); instruction. Note that when you specify a constant
    as the source operand, the instruction requires two operands (because HLA uses
    the second operand to determine whether the multiplication is 8, 16, or 32 bits).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use the `mul` and `imul` instructions quite a lot when you learn about
    extended-precision arithmetic in [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC").
    Unless you''re doing multiprecision work, however, you''ll probably just want
    to use the `intmul` instruction in place of the `mul` or `imul` because it is
    more general. However, `intmul` is not a complete replacement for these two instructions.
    Besides the number of operands, there are several differences between the `intmul`
    and the `mul`/`imul` instructions. The following rules apply specifically to the
    `intmul` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: There isn't an 8×8-bit `intmul` instruction available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `intmul` instruction does not produce a 2*×n*-bit result. That is, a 16×16-bit
    multiply produces a 16-bit result. Likewise, a 32×32-bit multiply produces a 32-bit
    result. These instructions set the carry and overflow flags if the result does
    not fit into the destination register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.2 The div and idiv Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 divide instructions perform a 64/32-bit division, a 32/16-bit division,
    or a 16/8-bit division. These instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `div` instruction is an unsigned division operation. If the operand is an
    8-bit operand, `div` divides the AX register by the operand leaving the quotient
    in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, then
    the `div` instruction divides the 32-bit quantity in `dx:ax` by the operand, leaving
    the quotient in AX and the remainder in DX. With 32-bit operands `div` divides
    the 64-bit value in `edx:eax` by the operand, leaving the quotient in EAX and
    the remainder in EDX.
  prefs: []
  type: TYPE_NORMAL
- en: Like `mul` and `imul`, HLA provides special syntax to allow the use of constant
    operands even though the low-level machine instructions don't actually support
    them. See the previous list of `div` instructions for these extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The `idiv` instruction computes a signed quotient and remainder. The syntax
    for the `idiv` instruction is identical to `div` (except for the use of the `idiv`
    mnemonic), though creating signed operands for `idiv` may require a different
    sequence of instructions prior to executing `idiv` than for `div`.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot, on the 80x86, simply divide one unsigned 8-bit value by another.
    If the denominator is an 8-bit value, the numerator must be a 16-bit value. If
    you need to divide one unsigned 8-bit value by another, you must zero extend the
    numerator to 16 bits. You can accomplish this by loading the numerator into the
    AL register and then moving 0 into the AH register. Then you can divide AX by
    the denominator operand to produce the correct result. *Failing to zero extend
    AL before executing* *`div`* *may cause the 80x86 to produce incorrect results!*
    When you need to divide two 16-bit unsigned values, you must zero extend the AX
    register (which contains the numerator) into the DX register. To do this, just
    load 0 into the DX register. If you need to divide one 32-bit value by another,
    you must zero extend the EAX register into EDX (by loading a 0 into EDX) before
    the division.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with signed integer values, you will need to sign extend AL into
    AX, AX into DX, or EAX into EDX before executing `idiv`. To do so, use the `cbw`,
    `cwd`, `cdq`, or `movsx` instruction. If the H.O. byte, word, or double word does
    not already contain significant bits, then you must sign extend the value in the
    accumulator (AL/AX/EAX) before doing the `idiv` operation. Failure to do so may
    produce incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other issue with the 80x86''s divide instructions: You can get
    a fatal error when using this instruction. First, of course, you can attempt to
    divide a value by 0\. Another problem is that the quotient may be too large to
    fit into the EAX, AX, or AL register. For example, the 16/8-bit division $8000/2
    produces the quotient $4000 with a remainder of 0\. $4000 will not fit into 8
    bits. If this happens, or you attempt to divide by 0, the 80x86 will generate
    an `ex.DivisionError` exception or integer overflow error (`ex.IntoInstr`). This
    usually means your program will display the appropriate dialog and abort. If this
    happens to you, chances are you didn''t sign or zero extend your numerator before
    executing the division operation. Because this error may cause your program to
    crash, you should be very careful about the values you select when using division.
    Of course, you can use the `try..endtry` block with `ex.DivisionError` and `ex.IntoInstr`
    to trap this problem in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 leaves the carry, overflow, sign, and zero flags undefined after a
    division operation. Therefore, you cannot test for problems after a division operation
    by checking the flag bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 80x86 does not provide a separate instruction to compute the remainder
    of one number divided by another. The `div` and `idiv` instructions automatically
    compute the remainder at the same time they compute the quotient. HLA, however,
    provides mnemonics (instructions) for the `mod` and `imod` instructions. These
    special HLA instructions compile into the exact same code as their `div` and `idiv`
    counterparts. The only difference is the returns value for the instruction (because
    these instructions return the remainder in a different location than the quotient).
    The `mod` and `imod` instructions that HLA supports are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.3 The cmp Instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cmp` (compare) instruction is identical to the `sub` instruction with
    one crucial semantic difference—it does not retain the difference it computes;
    it just sets the condition code bits in the flags register. The syntax for the
    `cmp` instruction is similar to that of `sub` (though the operands are reversed
    so it reads better); the generic form is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction computes *`LeftOperand`* `-` *`RightOperand`* (note the reversal
    from `sub`). The specific forms are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `cmp` instruction updates the 80x86's flags according to the result of the
    subtraction operation (*`LeftOperand`* `-` *`RightOperand`*). The 80x86 sets the
    flags in an appropriate fashion so that we can read this instruction as "compare
    *`LeftOperand`* to *`RightOperand`*." You can test the result of the comparison
    by checking the appropriate flags in the flags register using the conditional
    set instructions (see [6.1.4 The setcc Instructions](ch06.html#the_set_cc_instructions
    "6.1.4 The setcc Instructions")) or the conditional jump instructions (see [Chapter 7](ch07.html
    "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the first place to start when exploring the `cmp` instruction is to
    look at exactly how the `cmp` instruction affects the flags. Consider the following
    `cmp` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction performs the computation AX - BX and sets the flags depending
    upon the result of the computation. The flags are set as follows (also see [Table 6-1](ch06.html#condition_code_settings_after_cmp
    "Table 6-1. Condition Code Settings After cmp")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Z`**'
  prefs: []
  type: TYPE_NORMAL
- en: The zero flag is set if and only if AX = BX. This is the only time AX - BX produces
    a zero result. Hence, you can use the zero flag to test for equality or inequality.
  prefs: []
  type: TYPE_NORMAL
- en: '**`S`**'
  prefs: []
  type: TYPE_NORMAL
- en: The sign flag is set to 1 if the result is negative. At first glance, you might
    think that this flag would be set if AX is less than BX, but this isn't always
    the case. If AX = $7FFF and BX = −1 ($FFFF), then subtracting AX from BX produces
    $8000, which is negative (and so the sign flag will be set). So, for signed comparisons
    anyway, the sign flag doesn't contain the proper status. For unsigned operands,
    consider AX = $FFFF and BX = 1\. AX is greater than BX but their difference is
    $FFFE, which is still negative. As it turns out, the sign flag and the overflow
    flag, taken together, can be used for comparing two signed values.
  prefs: []
  type: TYPE_NORMAL
- en: '**`O`**'
  prefs: []
  type: TYPE_NORMAL
- en: The overflow flag is set after a `cmp` operation if the difference of AX and
    BX produced an overflow or underflow. As mentioned above, the sign flag and the
    overflow flag are both used when performing signed comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '**`C`**'
  prefs: []
  type: TYPE_NORMAL
- en: The carry flag is set after a `cmp` operation if subtracting BX from AX requires
    a borrow. This occurs only when AX is less than BX where AX and BX are both unsigned
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that the `cmp` instruction sets the flags in this fashion, you can test
    the comparison of the two operands with the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Table 6-1. Condition Code Settings After `cmp`
  prefs: []
  type: TYPE_NORMAL
- en: '| Unsigned Operands | Signed Operands |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Z: Equality/inequality | Z: Equality/inequality |'
  prefs: []
  type: TYPE_TB
- en: '| C: Left < Right (C = 1)Left >= Right (C = 0) | C: No meaning |'
  prefs: []
  type: TYPE_TB
- en: '| S: No meaning | S: See discussion in this section |'
  prefs: []
  type: TYPE_TB
- en: '| O: No meaning | O: See discussion in this section |'
  prefs: []
  type: TYPE_TB
- en: 'For signed comparisons, the S (sign) and O (overflow) flags, taken together,
    have the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: If [(S = 0) and (O = 1)] or [(S = 1) and (O = 0)] then Left < Right for a signed
    comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If [(S = 0) and (O = 0)] or [(S = 1) and (O = 1)] then Left >= Right for a signed
    comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that (S `xor` O) is 1 if the left operand is less than the right operand.
    Conversely, (S `xor` O) is 0 if the left operand is greater or equal to the right
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why these flags are set in this manner, consider the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the `cmp` operation is really a subtraction; therefore, the first
    example above computes (−1) - (−2), which is (+1). The result is positive and
    an overflow did not occur, so both the S and O flags are 0\. Because (S `xor`
    O) is 0, `Left` is greater than or equal to `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `cmp` instruction would compute (−32,768) - (+1),
    which is (−32,769). Because a 16-bit signed integer cannot represent this value,
    the value wraps around to $7FFF (+32,767) and sets the overflow flag. The result
    is positive (at least as a 16-bit value), so the CPU clears the sign flag. (S
    `xor` O) is 1 here, so `Left` is less than `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example above, `cmp` computes (−2) - (−1), which produces (−1).
    No overflow occurred, so the O flag is 0, the result is negative, so the sign
    flag is 1\. Because (S `xor` O) is 1, `Left` is less than `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth (and final) example, `cmp` computes (+32,767) - (−1). This produces
    (+32,768), setting the overflow flag. Furthermore, the value wraps around to $8000
    (−32,768), so the sign flag is set as well. Because (S `xor` O) is 0, `Left` is
    greater than or equal to `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: You may test the flags after a `cmp` instruction using HLA high-level control
    statements and the boolean flag expressions (e.g., `@c`, `@nc`, `@z`, `@nz`, `@o`,
    `@no`, `@s`, `@ns`, and so on). [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") lists the boolean expressions
    HLA supports that let you check various conditions after a compare instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2. HLA Condition Code Boolean Expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| HLA Syntax | Condition | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@c` | Carry set | Carry flag is set if the first operand is less than the
    second operand (unsigned). Same condition as `@b` and `@nae`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nc` | Carry clear (no carry) | Carry flag is clear if the first operand
    is greater than or equal to the second (using an unsigned comparison). Same condition
    as `@nb` and `@ae`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@z` | Zero flag set | Zero flag is set if the first operand equals the second
    operand. Same condition as `@e`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nz` | Zero flag clear (no zero) | Zero flag is clear if the first operand
    is not equal to the second. Same condition as `@ne`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@o` | Overflow flag set | This flag is set if there was a signed arithmetic
    overflow as a result of the comparison operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `@no` | Overflow flag clear (no overflow) | The overflow flag is clear if
    there was no signed arithmetic overflow during the compare operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `@s` | Sign flag set | The sign flag is set if the result of the compare
    (subtraction) produces a negative result. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ns` | Sign flag clear (no sign) | The sign flag is clear if the compare
    operation produces a nonnegative (zero or positive) result. |'
  prefs: []
  type: TYPE_TB
- en: '| `@a` | Above (unsigned greater than) | The `@a` condition checks the carry
    and zero flags to see if `@c` = 0 and `@z` = 0\. This condition exists if the
    first (unsigned) operand is greater than the second (unsigned) operand. This is
    the same condition as `@nbe`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@na` | Not above | The `@na` condition checks to see if the carry flag is
    set (`@c`) or the zero flag is set (`@z`). This is equivalent to an unsigned "not
    greater than" condition. Note that this condition is the same as `@be`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ae` | Above or equal (unsigned greater than or equal) | The `@ae` condition
    is true if the first operand is greater than or equal to the second using an unsigned
    comparison. This is equivalent to the `@nb` and `@nc` conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nae` | Not above or equal | The `@nae` condition is true if the first operand
    is not greater than or equal to the second using an unsigned comparison. This
    is equivalent to the `@b` and `@c` conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| `@b` | Below (unsigned less than) | The `@b` condition is true if the first
    operand is less than the second using an unsigned comparison. This is equivalent
    to the `@nae` and `@c` conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nb` | Not below | This condition is true if the first operand is not less
    than the second using an unsigned comparison. This condition is equivalent to
    the `@nc` and `@ae` conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| `@be` | Below or equal (unsigned less than or equal) | The `@be` condition
    is true when the first operand is less than or equal to the second using an unsigned
    comparison. This condition is equivalent to `@na`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nbe` | Not below or equal | The `@be` condition is true when the first
    operand is not less than or equal to the second using an unsigned comparison.
    This condition is equivalent to `@a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@g` | Greater (signed greater than) | The `@g` condition is true if the
    first operand is greater than the second using a signed comparison. This is equivalent
    to the `@nle` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ng` | Not greater | The `@ng` condition is true if the first operand is
    not greater than the second using a signed comparison. This is equivalent to the
    `@le` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ge` | Greater or equal (signed greater than or equal) | The `@ge` condition
    is true if the first operand is greater than or equal to the second using a signed
    comparison. This is equivalent to the `@nl` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nge` | Not greater or equal | The `@nge` condition is true if the first
    operand is not greater than or equal to the second using a signed comparison.
    This is equivalent to the `@l` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@l` | Less than (signed less than) | The `@l` condition is true if the first
    operand is less than the second using a signed comparison. This is equivalent
    to the `@nge` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nl` | Not less than | The `@ng` condition is true if the first operand
    is not less than the second using a signed comparison. This is equivalent to the
    `@ge` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@le` | Less than or equal (signed) | The `@le` condition is true if the
    first operand is less than or equal to the second using a signed comparison. This
    is equivalent to the `@ng` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@nle` | Not less than or equal | The `@nle` condition is true if the first
    operand is not less than or equal to the second using a signed comparison. This
    is equivalent to the `@g` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@e` | Equal (signed or unsigned) | This condition is true if the first operand
    equals the second. The `@e` condition is equivalent to the `@z` condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ne` | Not equal (signed or unsigned) | `@ne` is true if the first operand
    does not equal the second. This condition is equivalent to `@nz`. |'
  prefs: []
  type: TYPE_TB
- en: 'You may use the boolean conditions appearing in [Table 6-2](ch06.html#hla_condition_code_boolean_expressions
    "Table 6-2. HLA Condition Code Boolean Expressions") within an `if` statement,
    `while` statement, or any other HLA high-level control statement that allows boolean
    expressions. Immediately after the execution of a `cmp` instruction, you would
    typically use one of these conditions in an `if` statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the example above is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.4 The set*cc* Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *set on condition* (or `set`*`cc`*) instructions set a single-byte operand
    (register or memory) to 0 or 1 depending on the values in the flags register.
    The general formats for the `set`*`cc`* instructions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`set`*`cc`* represents a mnemonic appearing in [Table 6-3](ch06.html#setcc_instructions_that_test_flags
    "Table 6-3. setcc Instructions That Test Flags"), [Table 6-4](ch06.html#setcc_instructions_for_unsigned_comparis
    "Table 6-4. setcc Instructions for Unsigned Comparisons"), and [Table 6-5](ch06.html#setcc_instructions_for_signed_comparison
    "Table 6-5. setcc Instructions for Signed Comparisons"). These instructions store
    a 0 into the corresponding operand if the condition is false, and they store a
    1 into the 8-bit operand if the condition is true.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3. `set`*`cc`* Instructions That Test Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setc` | Set if carry | Carry = 1 | Same as `setb`, `setnae` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnc` | Set if no carry | Carry = 0 | Same as `setnb`, `setae` |'
  prefs: []
  type: TYPE_TB
- en: '| `setz` | Set if zero | Zero = 1 | Same as `sete` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnz` | Set if not zero | Zero = 0 | Same as `setne` |'
  prefs: []
  type: TYPE_TB
- en: '| `sets` | Set if sign | Sign = 1 |   |'
  prefs: []
  type: TYPE_TB
- en: '| `setns` | Set if no sign | Sign = 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| `seto` | Set if overflow | Overflow = 1 |   |'
  prefs: []
  type: TYPE_TB
- en: '| `setno` | Set if no overflow | Overflow = 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| `setp` | Set if parity | Parity = 1 | Same as `setpe` |'
  prefs: []
  type: TYPE_TB
- en: '| `setpe` | Set if parity even | Parity = 1 | Same as `setp` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnp` | Set if no parity | Parity = 0 | Same as `setpo` |'
  prefs: []
  type: TYPE_TB
- en: '| `setpo` | Set if parity odd | Parity = 0 | Same as `setnp` |'
  prefs: []
  type: TYPE_TB
- en: The `set`*`cc`* instructions above simply test the flags without any other meaning
    attached to the operation. You could, for example, use `setc` to check the carry
    flag after a shift, rotate, bit test, or arithmetic operation. You might notice
    the `setp`, `setpe`, and `setnp` instructions above. They check the parity flag.
    These instructions appear here for completeness, but this text will not spend
    too much time discussing the parity flag (its use is somewhat obsolete).
  prefs: []
  type: TYPE_NORMAL
- en: The `cmp` instruction works synergistically with the setcc instructions. Immediately
    after a `cmp` operation the processor flags provide information concerning the
    relative values of those operands. They allow you to see if one operand is less
    than, equal to, or greater than the other.
  prefs: []
  type: TYPE_NORMAL
- en: Two additional groups of `set`*`cc`* instructions are very useful after a `cmp`
    operation. The first group deals with the result of an unsigned comparison; the
    second group deals with the result of a signed comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4. `set`*`cc`* Instructions for Unsigned Comparisons
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `seta` | Set if above (>) | Carry = 0, Zero = 0 | Same as `setnbe` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnbe` | Set if not below or equal (not <=) | Carry = 0, Zero = 0 | Same
    as `seta` |'
  prefs: []
  type: TYPE_TB
- en: '| `setae` | Set if above or equal (>=) | Carry = 0 | Same as `setnc`, `setnb`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setnb` | Set if not below (not <) | Carry = 0 | Same as `setnc`, `setae`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setb` | Set if below (<) | Carry = 1 | Same as `setc`, `setna` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnae` | Set if not above or equal (not >=) | Carry = 1 | Same as `setc`,
    `setb` |'
  prefs: []
  type: TYPE_TB
- en: '| `setbe` | Set if below or equal (<=) | Carry = 1 or Zero = 1 | Same as `setna`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setna` | Set if not above (not >) | Carry = 1 or Zero = 1 | Same as `setbe`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 6-5](ch06.html#setcc_instructions_for_signed_comparison "Table 6-5. setcc
    Instructions for Signed Comparisons") lists the corresponding signed comparisons.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-5. `set`*`cc`* Instructions for Signed Comparisons
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Description | Condition | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setg` | Set if greater (>) | Sign = Overflow and Zero = 0 | Same as `setnle`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setnle` | Set if not less than or equal (not <=) | Sign = Overflow or Zero
    = 0 | Same as `setg` |'
  prefs: []
  type: TYPE_TB
- en: '| `setge` | Set if greater than or equal (>=) | Sign = Overflow | Same as `setnl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setnl` | Set if not less than (not <) | Sign = Overflow | Same as `setge`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setl` | Set if less than (<) | Sign ¦ Overflow | Same as `setnge` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnge` | Set if not greater or equal (not >=) | Sign ¦ Overflow | Same
    as `setl` |'
  prefs: []
  type: TYPE_TB
- en: '| `setl` | Set if less than or equal (<=) | Sign ¦ Overflow or Zero = 1 | Same
    as `setng` |'
  prefs: []
  type: TYPE_TB
- en: '| `setng` | Set if not greater than (not >) | Sign ¦ Overflow or Zero = 1 |
    Same as `setle` |'
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (=) | Zero = 1 | Same as `setz` |'
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (¦) | Zero = 0 | Same as `setnz` |'
  prefs: []
  type: TYPE_TB
- en: Note the correspondence between the `set`*`cc`* instructions and the HLA flag
    conditions that may appear in boolean instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set`*`cc`* instructions are particularly valuable because they can convert
    the result of a comparison to a boolean value (false/true or 0/1). This is especially
    important when translating statements from a high-level language like Pascal or
    C/C++ into assembly language. The following example shows how to use these instructions
    in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `set`*`cc`* instructions always produce 0 or 1, you can use the
    results with the `and` and `or` instructions to compute complex boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.5 The test Instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 `test` instruction is to the `and` instruction what the `cmp` instruction
    is to `sub`. That is, the `test` instruction computes the logical `and` of its
    two operands and sets the condition code flags based on the result; it does not,
    however, store the result of the logical and back into the destination operand.
    The syntax for the `test` instruction is similar to `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `test` instruction sets the zero flag if the result of the logical `and`
    operation is 0\. It sets the sign flag if the H.O. bit of the result contains
    a 1\. The `test` instruction always clears the carry and overflow flags.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `test` instruction is to check to see if an individual
    bit contains a 0 or a 1\. Consider the instruction `test( 1, al);`. This instruction
    logically `and`s AL with the value 1; if bit 0 of AL contains 0, the result will
    be 0 (setting the zero flag) because all the other bits in the constant 1 are
    0\. Conversely, if bit 1 of AL contains 1, then the result is not 0, so `test`
    clears the zero flag. Therefore, you can test the zero flag after this `test`
    instruction to see if bit 0 contains a 0 or a 1 (e.g., using a `setz` or `setnz`
    instruction).
  prefs: []
  type: TYPE_NORMAL
- en: The `test` instruction can also check to see if all the bits in a specified
    set of bits contain 0\. The instruction `test( $F, al);` sets the zero flag if
    and only if the L.O. 4 bits of AL all contain 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very important use of the `test` instruction is to check whether a register
    contains 0\. The instruction `test(` *`reg`*`,` *`reg`* `);` where both operands
    are the same register will logically `and` that register with itself. If the register
    contains 0, then the result is 0 and the CPU will set the zero flag. However,
    if the register contains a nonzero value, logically `and`ing that value with itself
    produces that same nonzero value, so the CPU clears the zero flag. Therefore,
    you can check the zero flag immediately after the execution of this instruction
    (e.g., using the `setz` or `setnz` instructions or the `@z` and `@nz` boolean
    conditions) to see if the register contains 0\. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 6.2 Arithmetic Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the biggest shock to beginners facing assembly language for the very
    first time is the lack of familiar arithmetic expressions. Arithmetic expressions,
    in most high-level languages, look similar to their algebraic equivalents. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In assembly language, you''ll need several statements to accomplish this same
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Obviously the HLL version is much easier to type, read, and understand. This
    point, more than any other, is responsible for scaring people away from assembly
    language. Although there is a lot of typing involved, converting an arithmetic
    expression into assembly language isn't difficult at all. By attacking the problem
    in steps, the same way you would solve the problem by hand, you can easily break
    down any arithmetic expression into an equivalent sequence of assembly language
    statements. By learning how to convert such expressions to assembly language in
    three steps, you'll discover there is little difficulty to this task.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Simple Assignments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest expressions to convert to assembly language are simple assignments.
    Simple assignments copy a single value into a variable and take one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the first form to assembly language is simple—just use the assembly
    language statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This `mov` instruction copies the constant into the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second assignment above is slightly more complicated because the 80x86
    doesn''t provide a memory-to-memory `mov` instruction. Therefore, to copy one
    memory variable into another, you must move the data through a register. By convention
    (and for slight efficiency reasons), most programmers tend to favor AL/AX/EAX
    for this purpose. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is assuming, of course, that *`var1`* and *`var2`* are 32-bit variables.
    Use AL if they are 8-bit variables; use AX if they are 16-bit variables.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you're already using AL, AX, or EAX for something else, one of
    the other registers will suffice. Regardless, you will generally use a register
    to transfer one memory location to another.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Simple Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next level of complexity is a simple expression. A simple expression takes
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*`var1`* is a variable, *`term1`* and *`term2`* are variables or constants,
    and *`op`* is some arithmetic operator (addition, subtraction, multiplication,
    and so on). Most expressions take this form. It should come as no surprise, then,
    that the 80x86 architecture was optimized for just this type of expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical conversion for this type of expression takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*`op`* is the mnemonic that corresponds to the specified operation (e.g., +
    is `add`, `−` is `sub`, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the simple expression *`var1`* `:=` *`const1 op const2`*`;` is easily
    handled with a compile-time expression and a single `mov` instruction. For example,
    to compute *`var1`* `:= 5+3;`, just use the single instruction `mov( 5+3`, *`var1`*
    `);`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few inconsistencies you need to be aware of. When dealing with the
    (`i`)`mul`, (`i`)`div`, and (`i`)`mod` instructions on the 80x86, you must use
    the AL/AX/EAX and DX/EDX registers. You cannot use arbitrary registers as you
    can with other operations. Also, don't forget the sign extension instructions
    if you're performing a division operation and you're dividing one 16/32-bit number
    by another. Finally, don't forget that some instructions may cause overflow. You
    may want to check for an overflow (or underflow) condition after an arithmetic
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of common simple expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Certain unary operations also qualify as simple expressions, producing additional
    inconsistencies in the general rule. A good example of a unary operation is negation.
    In a high-level language, negation takes one of two possible forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that *`var`* `:= -`*`constant`* is really a simple assignment, not a simple
    expression. You can specify a negative constant as an operand to the `mov` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle *`var1`* `= -`*`var1`*`;`, use this single assembly language statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If two different variables are involved, then use the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 6.2.3 Complex Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex expression is any arithmetic expression involving more than two terms
    and one operator. Such expressions are commonly found in programs written in a
    high-level language. Complex expressions may include parentheses to override operator
    precedence, function calls, array accesses, and so on. While the conversion of
    many complex expressions to assembly language is fairly straightforward, other
    conversions require some effort. This section outlines the rules you use to convert
    such expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complex expression that is easy to convert to assembly language is one that
    involves three terms and two operators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly the straightforward assembly language conversion of this statement
    will require two `sub` instructions. However, even with an expression as simple
    as this one, the conversion is not trivial. There are actually *two ways* to convert
    this from the statement above into assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second conversion, because it is shorter, looks better. However, it produces
    an incorrect result (assuming Pascal-like semantics for the original statement).
    *Associativity* is the problem. The second sequence above computes `w := w - (y
    - z)`, which is not the same as `w := (w - y) - z`. How we place the parentheses
    around the subexpressions can affect the result. Note that if you are interested
    in a shorter form, you can use the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This computes `w := w - (y + z)`. This is equivalent to `w := (w - y) - z`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Precedence* is another issue. Consider this Pascal expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again there are two ways we can evaluate this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By now, you're probably thinking that this text is crazy. Everyone knows the
    correct way to evaluate these expressions is by the second form. However, you're
    wrong to think that way. The APL programming language, for example, evaluates
    expressions solely from right to left and does not give one operator precedence
    over another. Which way is "correct" depends entirely on how you define precedence
    in your arithmetic system.
  prefs: []
  type: TYPE_NORMAL
- en: Most high-level languages use a fixed set of precedence rules to describe the
    order of evaluation in an expression involving two or more different operators.
    Such programming languages usually compute multiplication and division before
    addition and subtraction. Those that support exponentiation (for example, FORTRAN
    and BASIC) usually compute that before multiplication and division. These rules
    are intuitive because almost everyone learns them before high school. Consider
    the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If *`op1`* takes precedence over *`op2`*, then this evaluates to `(x` *`op1`*
    `y)` *`op2`* `z`; otherwise, if *`op2`* takes precedence over *`op1`*, then this
    evaluates to `x` *`op1`* `(y` *`op2`* `z)`. Depending upon the operators and operands
    involved, these two computations could produce different results. When converting
    an expression of this form into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If two operators appearing within an expression have the same precedence, then
    you determine the order of evaluation using *associativity* rules. Most operators
    are left associative, meaning that they evaluate from left to right. Addition,
    subtraction, multiplication, and division are all left associative. A *right-associative*
    operator evaluates from right to left. The exponentiation operator in FORTRAN
    and BASIC is a good example of a right-associative operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There is one exception to the associativity rule. If an expression involves
    multiplication and division, it is generally better to perform the multiplication
    first. For example, given an expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: it is usually better to compute `x * z` and then divide the result by `y` rather
    than divide `x` by `y` and multiply the quotient by `z`. There are two reasons
    why this approach is better. First, remember that the `imul` instruction always
    produces a 64-bit result (assuming 32-bit operands). By doing the multiplication
    first, you automatically *sign extend* the product into the EDX register so you
    do not have to sign extend EAX prior to the division. A second reason for doing
    the multiplication first is to increase the accuracy of the computation. Remember,
    (integer) division often produces an inexact result. For example, if you compute
    5/2 you will get the value 2, not 2.5\. Computing (5 / 2) * 3 produces 6\. However,
    if you compute `(5 * 3) / 2` you get the value 7, which is a little closer to
    the real quotient (7.5). Therefore, if you encounter an expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'you can usually convert it to the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if the algorithm you''re encoding depends on the truncation effect
    of the division operation, you cannot use this trick to improve the algorithm.
    Moral of the story: Always make sure you fully understand any expression you are
    converting to assembly language. Obviously, if the semantics dictate that you
    must perform the division first, then do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to a previous example except it uses subtraction rather than
    addition. Because subtraction is not commutative, you cannot compute `y * x` and
    then subtract `x` from this result. This tends to complicate the conversion a
    tiny amount. Rather than use a straightforward multiplication-and-addition sequence,
    you''ll have to load `x` into a register, multiply `y` and `x` leaving their product
    in a different register, and then subtract this product from `x`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a trivial example that demonstrates the need for *temporary variables*
    in an expression. This code uses the EBX register to temporarily hold a copy of
    `x` until it computes the product of `y` and `x`. As your expressions increase
    in complexity, the need for temporaries grows. Consider the following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the normal rules of algebraic evaluation, you compute the subexpressions
    inside the parentheses (that is, the two subexpressions with the highest precedence)
    first and set their values aside. When you''ve computed the values for both subexpressions,
    you can compute their sum. One way to deal with a complex expression like this
    one is to reduce it to a sequence of simple expressions whose results wind up
    in temporary variables. For example, you can convert the single expression above
    into the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Because converting simple expressions to assembly language is quite easy, it''s
    now a snap to compute the former complex expression in assembly. The code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this code is grossly inefficient, and it requires that you declare
    a couple of temporary variables in your data segment. However, it is very easy
    to optimize this code by keeping temporary variables, as much as possible, in
    80x86 registers. By using 80x86 registers to hold the temporary results, this
    code becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s yet another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be converted to a set of four simple expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert these four simple expressions into the following assembly language
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The most important thing to keep in mind is that you should attempt to keep
    temporary values in registers. Remember, accessing an 80x86 register is much more
    efficient than accessing a memory location. Use memory locations to hold temporaries
    only if you've run out of registers.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, converting a complex expression to assembly language is little different
    than solving the expression by hand. Instead of actually computing the result
    at each stage of the computation, you simply write the assembly code that computes
    the result. Because you were probably taught to compute only one operation at
    a time, this means that manual computation works on "simple expressions" that
    exist in a complex expression. Of course, converting those simple expressions
    to assembly is fairly simple. Therefore, anyone who can solve a complex expression
    by hand can convert it to assembly language following the rules for simple expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.4 Commutative Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If *`op`* represents some operator, that operator is *commutative* if the following
    relationship is always true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the previous section, commutative operators are nice because the
    order of their operands is immaterial, and this lets you rearrange a computation,
    often making that computation easier or more efficient. Often, rearranging a computation
    allows you to use fewer temporary variables. Whenever you encounter a commutative
    operator in an expression, you should always check to see if there is a better
    sequence you can use to improve the size or speed of your code. [Table 6-6](ch06s02.html#some_common_commutative_binary_operators
    "Table 6-6. Some Common Commutative Binary Operators") and [Table 6-7](ch06s02.html#some_common_noncommutative_binary_operat
    "Table 6-7. Some Common Noncommutative Binary Operators"), respectively, list
    the commutative and noncommutative operators you typically find in high-level
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6. Some Common Commutative Binary Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Pascal | C/C++ | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | `+` | Addition |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `*` | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | `&&` or `&` | Logical or bitwise `and` |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | `&#124;&#124;` or `&#124;` | Logical or bitwise `or` |'
  prefs: []
  type: TYPE_TB
- en: '| `xor` | `^` | (Logical or) bitwise exclusive-`or` |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | `==` | Equality |'
  prefs: []
  type: TYPE_TB
- en: '| `<>` | `!=` | Inequality |'
  prefs: []
  type: TYPE_TB
- en: Table 6-7. Some Common Noncommutative Binary Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Pascal | C/C++ | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `-` | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `/` or `div` | `/` | Division |'
  prefs: []
  type: TYPE_TB
- en: '| `mod` | `%` | Modulo or remainder |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | `<` | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `<=` | Less than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | `>` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `>=` | Greater than or equal |'
  prefs: []
  type: TYPE_TB
- en: 6.3 Logical (Boolean) Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following expression from a Pascal program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`b` is a boolean variable and the remaining variables are all integers.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we represent boolean variables in assembly language? Although it takes
    only a single bit to represent a boolean value, most assembly language programmers
    allocate a whole byte or word for this purpose (thus, HLA also allocates a whole
    byte for a boolean variable). With a byte, there are 256 possible values we can
    use to represent the two values true and false. So which two values (or which
    two sets of values) do we use to represent these boolean values? Because of the
    machine's architecture, it's much easier to test for conditions like zero or not
    zero and positive or negative rather than to test for one of two particular boolean
    values. Most programmers (and, indeed, some programming languages like C) choose
    0 to represent false and anything else to represent true. Some people prefer to
    represent true and false with 1 and 0 (respectively) and not allow any other values.
    Others select all 1 bits ($FFFF_FFFF, $FFFF, or $FF) for true and 0 for false.
    You could also use a positive value for true and a negative value for false. All
    these mechanisms have their advantages and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using only 0 and 1 to represent false and true offers two very big advantages:
    (1) The setcc instructions produce these results, so this scheme is compatible
    with those instructions; (2) the 80x86 logical instructions (`and`, `or`, `xor`,
    and, to a lesser extent, `not`) operate on these values exactly as you would expect.
    That is, if you have two boolean variables `A` and `B`, then the following instructions
    perform the basic logical operations on these two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note, as pointed out above, that the not instruction will not properly compute
    logical negation. The bitwise `not` of 0 is $FF and the bitwise `not` of 1 is
    $FE. Neither result is 0 or 1\. However, by `and`ing the result with 1 you get
    the proper result. Note that you can implement the `not` operation more efficiently
    using the `xor( 1, ax );` instruction because it affects only the L.O. bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, using 0 for false and anything else for true has a lot of
    subtle advantages. Specifically, the test for true or false is often implicit
    in the execution of any logical instruction. However, this mechanism suffers from
    a very big disadvantage: You cannot use the 80x86 `and`, `or`, `xor`, and `not`
    instructions to implement the boolean operations of the same name. Consider the
    two values $55 and $AA. They''re both nonzero so they both represent the value
    true. However, if you logically `and` $55 and $AA together using the 80x86 `and`
    instruction, the result is 0\. True `and` true should produce true, not false.
    Although you can account for situations like this, it usually requires a few extra
    instructions and is somewhat less efficient when computing boolean operations.'
  prefs: []
  type: TYPE_NORMAL
- en: A system that uses nonzero values to represent true and 0 to represent false
    is an *arithmetic logical system*. A system that uses the two distinct values
    like 0 and 1 to represent false and true is called a *boolean logical system*,
    or simply a boolean system. You can use either system, as convenient. Consider
    again the boolean expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The simple expressions resulting from this expression might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When working with boolean expressions don't forget that you might be able to
    optimize your code by simplifying those boolean expressions. You can use algebraic
    transformations to help reduce the complexity of an expression. In the chapter
    on control structures, you'll also see how to use control flow to calculate a
    boolean result. This is generally quite a bit more efficient than using *complete
    boolean evaluation* as the examples in this section teach.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Machine and Arithmetic Idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An idiom is an idiosyncrasy. Several arithmetic operations and 80x86 instructions
    have idiosyncrasies that you can take advantage of when writing assembly language
    code. Some people refer to the use of machine and arithmetic idioms as "tricky
    programming" that you should always avoid in well-written programs. While it is
    wise to avoid tricks just for the sake of tricks, many machine and arithmetic
    idioms are well known and commonly found in assembly language programs. Some of
    them are little more than tricks, but a good number of them are simply "tricks
    of the trade." This text cannot even begin to present all of the idioms in common
    use today; they are too numerous and the list is constantly changing. Nevertheless,
    there are some very important idioms that you will see all the time, so it makes
    sense to discuss those.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.1 Multiplying without mul, imul, or intmul
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When multiplying by a constant, you can sometimes write faster code by using
    shifts, additions, and subtractions in place of multiplication instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, a `shl` instruction computes the same result as multiplying the specified
    operand by 2\. Shifting to the left two bit positions multiplies the operand by
    4\. Shifting to the left three bit positions multiplies the operand by 8\. In
    general, shifting an operand to the left *n* bits multiplies it by 2^(*n*). You
    can multiply any value by some constant using a series of shifts and additions
    or shifts and subtractions. For example, to multiply the AX register by 10, you
    need only multiply it by 8 and then add in two times the original value. That
    is, `10 * ax = 8 * ax + 2 * ax`. The code to accomplish this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Many x86 processors can multiply the AX register (or just about any register,
    for that matter) by various constant values much faster by using `shl` than by
    using the `mul` instruction. This may seem hard to believe because it takes only
    one instruction to compute this product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: However, if you look at the instruction timings, the shift and add example above
    requires fewer clock cycles on many processors in the 80x86 family than the `mul`
    instruction. Of course, the code is somewhat larger (by a few bytes), but the
    performance improvement is usually worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use subtraction with shifts to perform a multiplication operation.
    Consider the following multiplication by 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A common error beginning assembly language programmers make is subtracting
    or adding 1 or 2 rather than `eax * 1` or `eax * 2`. The following does not compute
    `eax * 7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It computes `(8 * eax) - 1`, something entirely different (unless, of course,
    EAX = 1). Beware of this pitfall when using shifts, additions, and subtractions
    to perform multiplication operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `lea` instruction to compute certain products. The trick
    is to use the scaled index addressing modes. The following examples demonstrate
    some simple cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 6.4.2 Division Without div or idiv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as the `shl` instruction is useful for simulating a multiplication by a
    power of 2, the `shr` and `sar` instructions can simulate a division by a power
    of 2\. Unfortunately, you cannot easily use shifts, additions, and subtractions
    to perform a division by an arbitrary constant. Therefore, keep in mind that this
    trick is useful only when dividing by powers of 2\. Also, don't forget that the
    `sar` instruction rounds towards negative infinity rather than toward 0; this
    is not the way the `idiv` instruction operates (it rounds toward 0).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to perform division is to use the multiply instructions. You can
    divide by some value by multiplying by its reciprocal. Because the multiply instruction
    is faster than the divide instruction, multiplying by a reciprocal is usually
    faster than division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re probably wondering, "How does one multiply by a reciprocal when
    the values we''re dealing with are all integers?" The answer, of course, is that
    we must cheat to do this. If you want to multiply by 1/10, there is no way you
    can load the value 1/10 into an 80x86 integer register prior to performing the
    multiplication. However, we could multiply 1/10 by 10, perform the multiplication,
    and then divide the result by 10 to get the final result. Of course, this wouldn''t
    buy you anything; in fact, it would make things worse because you''re now doing
    a multiplication by 10 as well as a division by 10\. However, suppose you multiply
    1/10 by 65,536 (6,553), perform the multiplication, and then divide by 65,536\.
    This would still perform the correct operation, and, as it turns out, if you set
    up the problem correctly, you can get the division operation for free. Consider
    the following code that divides AX by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This code leaves AX/10 in the DX register.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, consider what happens when you multiply AX by
    65,536 ($1_0000). This simply moves AX into DX and sets AX to 0 (a multiply by
    $1_0000 is equivalent to a shift left by 16 bits). Multiplying by 6,554 (65,536
    divided by 10) puts AX divided by 10 into the DX register. Because `mul` is faster
    than `div`, this technique runs a little faster than using a division.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying by a reciprocal works well when you need to divide by a constant.
    You could even use it to divide by a variable, but the overhead to compute the
    reciprocal pays off only if you perform the division many, many times (by the
    same value).
  prefs: []
  type: TYPE_NORMAL
- en: 6.4.3 Implementing Modulo-N Counters with and
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to implement a counter variable that counts up to 2^(*n*) - 1 and
    then resets to 0, simply use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'where `nBits` is a binary value containing *n* bits containing ones right justified
    in the number. For example, to create a counter that cycles between 0 and 15 (2⁴
    − 1), you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 6.5 Floating-Point Arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the 8086 CPU first appeared in the late 1970s, semiconductor technology
    was not to the point where Intel could put floating-point instructions directly
    on the 8086 CPU. Therefore, Intel devised a scheme whereby it could use a second
    chip to perform the floating-point calculations—the floating-point unit (or FPU).^([[102](#ftn.CHP-6-FN-1)])
    By the release of the Intel Pentium chip, semiconductor technology had advanced
    to the point that the FPU was fully integrated onto the 80x86 CPU. Therefore,
    almost all modern 80x86 CPU devices fully support floating-point arithmetic directly
    on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 FPU Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 FPUs add 13 registers to the 80x86: eight floating-point data registers,
    a control register, a status register, a tag register, an instruction pointer,
    and a data pointer. The data registers are similar to the 80x86''s general-purpose
    register set insofar as all floating-point calculations take place in these registers.
    The control register contains bits that let you decide how the FPU handles certain
    degenerate cases like rounding of inaccurate computations; it also contains bits
    that control precision and so on. The status register is similar to the 80x86''s
    flags register; it contains the condition code bits and several other floating-point
    flags that describe the state of the FPU. The tag register contains several groups
    of bits that determine the state of the value in each of the eight floating-point
    data registers. The instruction and data pointer registers contain certain state
    information about the last floating-point instruction executed. We will not consider
    the last three registers here; see the Intel documentation for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1.1 FPU Data Registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FPUs provide eight 80-bit data registers organized as a stack. This is a
    significant departure from the organization of the general-purpose registers on
    the 80x86 CPU. HLA refers to these registers as ST0, ST1, . . . ST7.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference between the FPU register set and the 80x86 register set
    is the stack organization. On the 80x86 CPU, the AX register is always the AX
    register, no matter what happens. On the FPU, however, the register set is an
    eight-element stack of 80-bit floating-point values (see [Figure 6-1](ch06s05.html#fpu_floating-point_register_stack
    "Figure 6-1. FPU floating-point register stack")).
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU floating-point register stack](tagoreillycom20100401nostarchimages578021.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. FPU floating-point register stack
  prefs: []
  type: TYPE_NORMAL
- en: ST0 refers to the item on the top of the stack, ST1 refers to the next item
    on the stack, and so on. Many floating-point instructions push and pop items on
    the stack; therefore, ST1 will refer to the previous contents of ST0 after you
    push something onto the stack. It will take some thought and practice to get used
    to the fact that the register numbers change, but this is an easy problem to overcome.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1.2 The FPU Control Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Intel designed the 80x87 (and, essentially, the IEEE floating-point standard),
    there were no standards in floating-point hardware. Different (mainframe and mini)
    computer manufacturers all had different and incompatible floating-point formats.
    Unfortunately, several applications had been written taking into account the idiosyncrasies
    of these different floating-point formats. Intel wanted to design an FPU that
    could work with the majority of the software out there (keep in mind that the
    IBM-PC was three to four years away when Intel began designing the 8087, so Intel
    couldn't rely on that "mountain" of software available for the PC to make its
    chip popular). Unfortunately, many of the features found in these older floating-point
    formats were mutually incompatible. For example, in some floating-point systems
    rounding would occur when there was insufficient precision; in others, truncation
    would occur. Some applications would work with one floating-point system but not
    with the other. Intel wanted as many applications as possible to work with as
    few changes as possible on its 80x87 FPUs, so it added a special register, the
    FPU *control register*, that lets the user choose one of several possible operating
    modes for the FPU.
  prefs: []
  type: TYPE_NORMAL
- en: The 80x87 control register contains 16 bits organized as shown in [Figure 6-2](ch06s05.html#fpu_control_register
    "Figure 6-2. FPU control register").
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU control register](tagoreillycom20100401nostarchimages578023.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. FPU control register
  prefs: []
  type: TYPE_NORMAL
- en: Bits 10 and 11 of the FPU control register provide rounding control according
    to the values appearing in [Table 6-8](ch06s05.html#rounding_control "Table 6-8. Rounding
    Control").
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-8. Rounding Control
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits 10 & 11 | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00 | To nearest or even |'
  prefs: []
  type: TYPE_TB
- en: '| 01 | Round down |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Round up |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Truncate |'
  prefs: []
  type: TYPE_TB
- en: The 00 setting is the default. The FPU rounds up values above one-half of the
    least significant bit. It rounds down values below one-half of the least significant
    bit. If the value below the least significant bit is exactly one-half of the least
    significant bit, then the FPU rounds the value toward the value whose least significant
    bit is 0\. For long strings of computations, this provides a reasonable, automatic
    way to maintain maximum precision.
  prefs: []
  type: TYPE_NORMAL
- en: The round-up and round-down options are present for those computations where
    it is important to keep track of the accuracy during a computation. By setting
    the rounding control to round down and performing the operation, then repeating
    the operation with the rounding control set to round up, you can determine the
    minimum and maximum ranges between which the true result will fall.
  prefs: []
  type: TYPE_NORMAL
- en: The truncate option forces all computations to truncate any excess bits during
    the computation. You will rarely use this option if accuracy is important to you.
    However, if you are porting older software to the FPU, you might use this option
    to help when porting the software. One place where this option is extremely useful
    is when converting a floating-point value to an integer. Because most software
    expects floating-point-to-integer conversions to truncate the result, you will
    need to use the truncation/rounding mode to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 8 and 9 of the control register specify the precision during computation.
    This capability is provided to allow compatibility with older software as required
    by the IEEE 754 standard. The precision control bits use the values in [Table 6-9](ch06s05.html#mantissa_precision_control_bits
    "Table 6-9. Mantissa Precision Control Bits").
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-9. Mantissa Precision Control Bits
  prefs: []
  type: TYPE_NORMAL
- en: '| Bits 8 & 9 | Precision Control |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00 | 24 bits |'
  prefs: []
  type: TYPE_TB
- en: '| 01 | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 53 bits |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 64 bits |'
  prefs: []
  type: TYPE_TB
- en: Some CPUs may operate faster with floating-point values whose precision is 53
    bits (i.e., 64-bit floating-point format) rather than 64 bits (i.e., 80-bit floating-point
    format). Please see the documentation for your specific processor for details.
    Generally, the CPU defaults these bits to %11 to select the 64-bit mantissa precision.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 0..5 are the *exception masks*. These are similar to the interrupt enable
    bit in the 80x86's flags register. If these bits contain a 1, the corresponding
    condition is ignored by the FPU. However, if any bit contains 0, and the corresponding
    condition occurs, then the FPU immediately generates an interrupt so the program
    can handle the degenerate condition (typically, this would wind up raising an
    HLA exception; see the *excepts.hhf* header file for the exception values).
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 corresponds to an invalid operation error. This generally occurs as the
    result of a programming error. Situations that raise the invalid operation exception
    (`ex.fInvalidOperation`) include pushing more than eight items onto the stack
    or attempting to pop an item off an empty stack, taking the square root of a negative
    number, or loading a nonempty register.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 1 masks the *denormalized* interrupt that occurs whenever you try to manipulate
    denormalized values. Denormalized exceptions occur when you load arbitrary extended-precision
    values into the FPU or work with very small numbers just beyond the range of the
    FPU's capabilities. Normally, you would probably *not* enable this exception.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.fDenormal` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 2 masks the *zero divide* exception. If this bit contains 0, the FPU will
    generate an interrupt if you attempt to divide a nonzero value by 0\. If you do
    not enable the zero division exception, the FPU will produce `NaN` (not a number)
    whenever you perform a zero division. It's probably a good idea to enable this
    exception by programming a 0 into this bit. Note that if your program generates
    this interrupt, the HLA runtime system will raise the `ex.fDivByZero` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 3 masks the *overflow* exception. The FPU will raise the overflow exception
    if a calculation overflows or if you attempt to store a value that is too large
    to fit into the destination operand (for example, storing a large extended-precision
    value into a single-precision variable). If you enable this exception and the
    FPU generates this interrupt, the HLA runtime system raises the `ex.fOverflow`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 4, if set, masks the *underflow* exception. Underflow occurs when the result
    is too *small* to fit in the destination operand. Like overflow, this exception
    can occur whenever you store a small extended-precision value into a smaller variable
    (single or double precision) or when the result of a computation is too small
    for extended precision. If you enable this exception and the FPU generates this
    interrupt, the HLA runtime system raises the `ex.fUnderflow` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 5 controls whether the *precision* exception can occur. A precision exception
    occurs whenever the FPU produces an imprecise result, generally the result of
    an internal rounding operation. Although many operations will produce an exact
    result, many more will not. For example, dividing 1 by 10 will produce an inexact
    result. Therefore, this bit is usually 1 because inexact results are very common.
    If you enable this exception and the FPU generates this interrupt, the HLA runtime
    system raises the `ex.InexactResult` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 6..7 and 12..15 in the control register are currently undefined and reserved
    for future use (bits 7 and 12 were valid on older FPUs but are no longer used).
  prefs: []
  type: TYPE_NORMAL
- en: 'The FPU provides two instructions, `fldcw` (load control word) and `fstcw`
    (store control word), that let you load and store the contents of the control
    register. The single operand to these instructions must be a 16-bit memory location.
    The `fldcw` instruction loads the control register from the specified memory location.
    `fstcw` stores the control register into the specified memory location. The syntax
    for these instructions is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s some example code that sets the rounding control to "truncate result"
    and sets the rounding precision to 24 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.1.3 The FPU Status Register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FPU status register provides the status of the FPU at the instant you read
    it. The `fstsw` instruction stores the16-bit floating-point status register into
    a word variable. The status register is a 16-bit register; its layout appears
    in [Figure 6-3](ch06s05.html#the_fpu_status_register-id1 "Figure 6-3. The FPU
    status register").
  prefs: []
  type: TYPE_NORMAL
- en: '![The FPU status register](tagoreillycom20100401nostarchimages578025.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. The FPU status register
  prefs: []
  type: TYPE_NORMAL
- en: Bits 0 through 5 are the exception flags. These bits appear in the same order
    as the exception masks in the control register. If the corresponding condition
    exists, then the bit is set. These bits are independent of the exception masks
    in the control register. The FPU sets and clears these bits regardless of the
    corresponding mask setting.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 6 indicates a *stack fault*. A stack fault occurs whenever there is a stack
    overflow or underflow. When this bit is set, the C[1] condition code bit determines
    whether there was a stack overflow (C[1] = 1) or stack underflow (C[1] = 0) condition.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 7 of the status register is set if *any* error condition bit is set. It
    is the logical `or` of bits 0 through 5\. A program can test this bit to quickly
    determine if an error condition exists.
  prefs: []
  type: TYPE_NORMAL
- en: Bits 8, 9, 10, and 14 are the coprocessor condition code bits. Various instructions
    set the condition code bits, as shown in [Table 6-10](ch06s05.html#fpu_condition_code_bits_open_parenthesis
    "Table 6-10. FPU Condition Code Bits (X = "Don't care")") and [Table 6-11](ch06s05.html#condition_code_interpretations_open_pare
    "Table 6-11. Condition Code Interpretations (X = "Don't care")"), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-10. FPU Condition Code Bits (X = "Don't care")
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Condition Code Bits | Condition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | C[3] | C[2] | C[1] | C[0] |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fcom``fcomp``fcompp``ficom``ficomp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST
    < sourceST = sourceST or source undefined |'
  prefs: []
  type: TYPE_TB
- en: '| `ftst` | 0011 | 0001 | XXXX | 0101 | ST is positiveST is negativeST is 0
    (+ or −)ST is uncomparable |'
  prefs: []
  type: TYPE_TB
- en: '| `fxam` | 0000111100001 | 001100110011X | 010101010101X | 000000011111 | +
    Unnormalized− Unnormalized+ Normalized− Normalized+ 0− 0+ Denormalized− Denormalized+
    NaN− NaN+ Infinity− InfinityEmpty register |'
  prefs: []
  type: TYPE_TB
- en: '| `fucom``fucomp``fucompp` | 0011 | 0001 | XXXX | 0101 | ST > sourceST < sourceST
    = sourceUnordered |'
  prefs: []
  type: TYPE_TB
- en: Table 6-11. Condition Code Interpretations (X = “Don’t care”)
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction(s)** | **Condition Code Bits** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | C[0] | C[3] | C[2] | C[1] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fcom, fcomp, fcmpp, ftst, fucom, fucomp, fucompp, ficom, ficomp` | Result
    of comparison. See previous table. | Result of comparison. See previous table.
    | Operands are not comparable | Result of comparison. See previous table.Also
    denotes stack overflow/underflow if stack exception bit is set. |'
  prefs: []
  type: TYPE_TB
- en: '| `fxam` | See previous table. | See previous table. | See previous table.
    | Sign of result, or stack overflow/underflow (if stack exception bit is set).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fprem, fprem1` | Bit 2 of remainder | Bit 0 of remainder | 0 – reduction
    done.1 – reduction incomplete. | Bit 1 of remainder or stack overflow/underflow
    (if stack exception bit is set). |'
  prefs: []
  type: TYPE_TB
- en: '| `fist, fbstp, frndint, fst, fstp, fadd, fmul, fdiv, fdivr, fsub, fsubr, fscale,
    fsqrt, fpatan, f2xm1, fyl2x, fyl2xp1` | Undefined | Undefined | Undefined | Round
    up occurred or stack overflow/underflow (if stack exception bit is set). |'
  prefs: []
  type: TYPE_TB
- en: '| `fptan, fsin, fcos, fsincos` | Undefined | Undefined | 0 – reduction done.1
    – reduction incomplete. | Round up occurred or stack overflow/underflow (if stack
    exception bit is set). |'
  prefs: []
  type: TYPE_TB
- en: '| `fchs, fabs, fxch, fincstp, fdecstp,``constant``loads,fxtract, fld, fild,
    fbld, fstp (80 bit)` | Undefined | Undefined | Undefined | Zero result or stack
    overflow/underflow (if stack exception bit is set). |'
  prefs: []
  type: TYPE_TB
- en: '| `fldenv, fstor` | Restored from memory operand. | Restored from memory operand.
    | Restored from memory operand. | Restored from memory operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `fldcw, fstenv, fstcw, fstsw, fclex` | Undefined | Undefined | Undefined
    | Undefined |'
  prefs: []
  type: TYPE_TB
- en: '| `finit, fsave` | Cleared to zero. | Cleared to zero. | Cleared to zero. |
    Cleared to zero. |'
  prefs: []
  type: TYPE_TB
- en: Bits 11–13 of the FPU status register provide the register number of the top
    of stack. During computations, the FPU adds (modulo-8) the *logical* register
    numbers supplied by the programmer to these three bits to determine the *physical*
    register number at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 15 of the status register is the *busy* bit. It is set whenever the FPU
    is busy. This bit is a historical artifact from the days when the FPU was a separate
    chip; most programs will have little reason to access this bit.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.2 FPU Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU supports seven different data types: three integer types, a packed
    decimal type, and three floating-point types. The integer type supports 64-bit
    integers, although it is often faster to do the 64-bit arithmetic using the integer
    unit of the CPU (see [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC")).
    Certainly it is faster to do 16-bit and 32-bit integer arithmetic using the standard
    integer registers. The packed decimal type provides a 17-digit signed decimal
    (BCD) integer. The primary purpose of the BCD format is to convert between strings
    and floating-point values. The remaining three data types are the 32-bit, 64-bit,
    and 80-bit floating-point data types. The 80x87 data types appear in [Figure 6-4](ch06s05.html#fpu_floating-point_formats
    "Figure 6-4. FPU floating-point formats"), [Figure 6-5](ch06s05.html#fpu_integer_formats
    "Figure 6-5. FPU integer formats"), and [Figure 6-6](ch06s05.html#fpu_packed_decimal_format
    "Figure 6-6. FPU packed decimal format").'
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU floating-point formats](tagoreillycom20100401nostarchimages578027.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. FPU floating-point formats
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU integer formats](tagoreillycom20100401nostarchimages578029.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. FPU integer formats
  prefs: []
  type: TYPE_NORMAL
- en: '![FPU packed decimal format](tagoreillycom20100401nostarchimages578031.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. FPU packed decimal format
  prefs: []
  type: TYPE_NORMAL
- en: The FPU generally stores values in a *normalized* format. When a floating-point
    number is normalized, the H.O. bit of the mantissa is always 1\. In the 32- and
    64-bit floating-point formats, the FPU does not actually store this bit; the FPU
    always assumes that it is 1\. Therefore, 32- and 64-bit floating-point numbers
    are always normalized. In the extended-precision 80-bit floating-point format,
    the FPU does *not* assume that the H.O. bit of the mantissa is 1; the H.O. bit
    of the mantissa appears as part of the string of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Normalized values provide the greatest precision for a given number of bits.
    However, there are a large number of nonnormalized values that we *cannot* represent
    with the 80-bit format. These values are very close to 0 and represent the set
    of values whose mantissa H.O. bit is not 0\. The FPUs support a special 80-bit
    form known as *denormalized* values. Denormalized values allow the FPU to encode
    very small values it cannot encode using normalized values, but denormalized values
    offer fewer bits of precision than normalized values. Therefore, using denormalized
    values in a computation may introduce some slight inaccuracy into a computation.
    Of course, this is always better than underflowing the denormalized value to 0
    (which could make the computation even less accurate), but you must keep in mind
    that if you work with very small values you may lose some accuracy in your computations.
    Note that the FPU status register contains a bit you can use to detect when the
    FPU uses a denormalized value in a computation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.3 The FPU Instruction Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU adds many instructions to the 80x86 instruction set. We can classify
    these instructions as data movement instructions, conversions, arithmetic instructions,
    comparisons, constant instructions, transcendental instructions, and miscellaneous
    instructions. The following sections describe each of the instructions in these
    categories.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4 FPU Data Movement Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data movement instructions transfer data between the internal FPU registers
    and memory. The instructions in this category are `fld`, `fst`, `fstp`, and `fxch`.
    The `fld` instruction always pushes its operand onto the floating-point stack.
    The `fstp` instruction always pops the top of stack after storing the top of stack
    (TOS). The remaining instructions do not affect the number of items on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.1 The fld Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fld` instruction loads a 32-bit, 64-bit, or 80-bit floating-point value
    onto the stack. This instruction converts 32- and 64-bit operands to an 80-bit
    extended-precision value before pushing the value onto the floating-point stack.
  prefs: []
  type: TYPE_NORMAL
- en: The `fld` instruction first decrements the TOS pointer (bits 11–13 of the status
    register) and then stores the 80-bit value in the physical register specified
    by the new TOS pointer. If the source operand of the FLD instruction is a floating-point
    data register, `st`*`i`*, then the actual register the FPU uses for the load operation
    is the register number *before* decrementing the TOS pointer. Therefore, `fld(
    st0 );` duplicates the value on the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The `fld` instruction sets the stack fault bit if stack overflow occurs. It
    sets the denormalized exception bit if you load an 80-bit denormalized value.
    It sets the invalid operation bit if you attempt to load an empty floating-point
    register onto the top of stack (or perform some other invalid operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no way to directly load a 32-bit integer register onto the
    floating-point stack, even if that register contains a `real32` value. To accomplish
    this, you must first store the integer register into a memory location; then you
    can push that memory location onto the FPU stack using the `fld` instruction.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that loading a constant via `fld` is actually an HLA extension. The FPU
    doesn't support this instruction type. HLA creates a `real80` object in the constants
    segment and uses the address of this memory object as the true operand for `fld`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.2 The fst and fstp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fst` and `fstp` instructions copy the value on the top of the floating-point
    stack to another floating-point register or to a 32-, 64 -, or 80-bit memory variable.
    When copying data to a 32- or 64-bit memory variable, the FPU rounds the 80-bit
    extended-precision value on the top of stack to the smaller format as specified
    by the rounding control bits in the FPU control register.
  prefs: []
  type: TYPE_NORMAL
- en: The `fstp` instruction pops the value off the top of the stack when moving it
    to the destination location. It does this by incrementing the TOS pointer in the
    status register after accessing the data in ST0\. If the destination operand is
    a floating-point register, the FPU stores the value at the specified register
    number *before* popping the data off the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing an `fstp( st0 );` instruction effectively pops the data off the top
    of stack with no data transfer. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The last example above effectively pops ST1 while leaving ST0 on the top of
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: The `fst` and `fstp` instructions will set the stack exception bit if a stack
    underflow occurs (attempting to store a value from an empty register stack). They
    will set the precision bit if there is a loss of precision during the store operation
    (this will occur, for example, when storing an 80-bit extended-precision value
    into a 32- or 64-bit memory variable and some bits are lost during conversion).
    They will set the underflow exception bit when storing an 80-bit value into a
    32- or 64-bit memory variable, but the value is too small to fit into the destination
    operand. Likewise, these instructions will set the overflow exception bit if the
    value on the top of stack is too big to fit into a 32- or 64-bit memory variable.
    The `fst` and `fstp` instructions set the denormalized flag when you try to store
    a denormalized value into an 80-bit register or variable.^([[103](#ftn.CHP-6-FN-2)])
    They set the invalid operation flag if an invalid operation (such as storing into
    an empty register) occurs. Finally, these instructions set the C[1] condition
    bit if rounding occurs during the store operation (this occurs only when storing
    into a 32- or 64-bit memory variable and you have to round the mantissa to fit
    into the destination).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of an idiosyncrasy in the FPU instruction set related to the encoding
    of the instructions, you cannot use the `fst` instruction to store data into a
    `real80` memory variable. You may, however, store 80-bit data using the `fstp`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.4.3 The fxch Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fxch` instruction exchanges the value on the top of stack with one of
    the other FPU registers. This instruction takes two forms: one with a single FPU
    register as an operand and the second without any operands. The first form exchanges
    the top of stack with the specified register. The second form of `fxch` swaps
    the top of stack with ST1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many FPU instructions, for example, `fsqrt`, operate only on the top of the
    register stack. If you want to perform such an operation on a value that is not
    on the top of stack, you can use the `fxch` instruction to swap that register
    with TOS, perform the desired operation, and then use the `fxch` to swap the TOS
    with the original register. The following example takes the square root of ST2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `fxch` instruction sets the stack exception bit if the stack is empty. It
    sets the invalid operation bit if you specify an empty register as the operand.
    This instruction always clears the C[1] condition code bit.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5 Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU performs all arithmetic operations on 80-bit real quantities. In a sense,
    the `fld` and `fst`/`fstp` instructions are conversion instructions because they
    automatically convert between the internal 80-bit real format and the 32- and
    64-bit memory formats. Nonetheless, we'll simply classify them as data movement
    operations, rather than conversions, because they are moving real values to and
    from memory. The FPU provides six other instructions that convert to or from integer
    or binary-coded decimal (BCD) format when moving data. These instructions are
    `fild`, `fist`, `fistp`, `fisttp`, `fbld`, and `fbstp`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.5.1 The fild Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fild` (integer load) instruction converts a 16-, 32-, or 64-bit two's complement
    integer to the 80-bit extended-precision format and pushes the result onto the
    stack. This instruction always expects a single operand. This operand must be
    the address of a word, double-word, or quad-word integer variable. You cannot
    specify one of the 80x86's 16- or 32-bit general-purpose registers. If you want
    to push the value of an 80x86 general-purpose register onto the FPU stack, you
    must first store it into a memory variable and then use `fild` to push that memory
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fild instruction sets the stack exception bit and C[1] (accordingly) if
    stack overflow occurs while pushing the converted value. Look at these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.5.2 The fist, fistp, and fisttp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fist`, `fistp`, and `fisttp` instructions convert the 80-bit extended-precision
    variable on the top of stack to a 16-, 32-, or 64-bit integer and store the result
    away into the memory variable specified by the single operand. The `fist` and
    `fistp` instructions convert the value on TOS to an integer according to the rounding
    setting in the FPU control register (bits 10 and 11). The `fisttp` instruction
    always does the conversion using the truncation mode. As for the `fild` instruction,
    the `fist`, `fistp`, and `fisttp` instructions will not let you specify one of
    the 80x86's general-purpose 16- or 32-bit registers as the destination operand.
  prefs: []
  type: TYPE_NORMAL
- en: The `fist` instruction converts the value on the top of stack to an integer
    and then stores the result; it does not otherwise affect the floating-point register
    stack. The `fistp` and `fisttp` instructions pop the value off the floating-point
    register stack after storing the converted value.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions set the stack exception bit if the floating-point register
    stack is empty (this will also clear C[1]). They set the precision (imprecise
    operation) and C[1] bits if rounding occurs (that is, if there is any fractional
    component to the value in ST0). These instructions set the underflow exception
    bit if the result is too small (that is, less than 1 but greater than 0 or less
    than 0 but greater than −1). Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget that the `fist` and `fistp` instructions use the rounding control
    settings to determine how they will convert the floating-point data to an integer
    during the store operation. Be default, the rounding control is usually set to
    "round" mode; yet most programmers expect `fist`/`fistp` to truncate the decimal
    portion during conversion. If you want `fist`/`fistp` to truncate floating-point
    values when converting them to an integer, you will need to set the rounding control
    bits appropriately in the floating-point control register (or use the `fisttp`
    instruction to truncate the result regardless of the rounding control bits). Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.5.3 The fbld and fbstp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fbld` and `fbstp` instructions load and store 80-bit BCD values. The `fbld`
    instruction converts a BCD value to its 80-bit extended-precision equivalent and
    pushes the result onto the stack. The `fbstp` instruction pops the extended-precision
    real value on TOS, converts it to an 80-bit BCD value (rounding according to the
    bits in the floating-point control register), and stores the converted result
    at the address specified by the destination memory operand. Note that there is
    no `fbst` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fbld` instruction sets the stack exception bit and C[1] if stack overflow
    occurs. It sets the invalid operation bit if you attempt to load an invalid BCD
    value. The `fbstp` instruction sets the stack exception bit and clears C[1] if
    stack underflow occurs (the stack is empty). It sets the underflow flag under
    the same conditions as `fist` and `fistp`. Look at these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: These two instructions are especially useful for converting between string and
    floating-point formats. See the floating-point-to-string and string-to-floating-point
    conversion routines in the HLA Standard Library for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6 Arithmetic Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arithmetic instructions make up a small but important subset of the FPU''s
    instruction set. These instructions fall into two general categories: those that
    operate on real values and those that operate on a real and an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.1 The fadd and faddp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `fadd` instruction, with no operands, adds the value in ST0 to the value
    in ST1 and stores the result into ST1\. The `faddp` instruction (with no operands)
    pops the two values on the top of stack, adds them, and pushes their sum back
    onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The next two forms of the `fadd` instruction, those with two FPU register operands,
    behave like the 80x86's `add` instruction. They add the value in the source register
    operand to the value in the destination register operand. Note that one of the
    register operands must be ST0.
  prefs: []
  type: TYPE_NORMAL
- en: The `faddp` instruction with two operands adds ST0 (which must always be the
    source operand) to the destination operand and then pops ST0\. The destination
    operand must be one of the other FPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: The last form above, `fadd` with a memory operand, adds a 32- or 64-bit floating-point
    variable to the value in ST0\. This instruction will convert the 32- or 64-bit
    operands to an 80-bit extended-precision value before performing the addition.
    Note that this instruction does *not* allow an 80-bit memory operand.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: Like `fld(` *`real_constant`*`)`, the `fadd(` *`real_constant`* `)` instruction
    is an HLA extension. Note that it creates a 64-bit variable holding the constant
    value and emits the `fadd(` *`mem64`* `)` instruction, specifying the read-only
    object it creates in the constants segment.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These four instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: With no operands, the `fsub` instruction subtracts ST0 from ST1 and leaves the
    result in ST1\. With no operands the `fsubp` instruction pops ST0 and ST1 from
    the register stack, computes `st1 - st0` and then pushes the difference back onto
    the stack. The `fsubr` and `fsubrp` instructions (reverse subtraction) operate
    in an almost identical fashion except they compute `st0 - st1`.
  prefs: []
  type: TYPE_NORMAL
- en: With two register operands (*`source`*, *`destination`*) the `fsub` instruction
    computes *`destination`* `:=` *`destination`* `-` *`source`*. One of the two registers
    must be ST0\. With two registers as operands, the `fsubp` also computes *`destination`*
    `:=` *`destination`* `-` *`source`*, and then it pops ST0 off the stack after
    computing the difference. For the `fsubp` instruction, the source operand must
    be ST0.
  prefs: []
  type: TYPE_NORMAL
- en: With two register operands, the `fsubr` and `fsubrp` instructions work in a
    similar fashion to `fsub` and `fsubp`, except they compute *`destination`* `:=`
    *`source`* `-` *`destination`*.
  prefs: []
  type: TYPE_NORMAL
- en: The `fsub(` *`mem`* `)` and `fsubr(` *`mem`* `)` instructions accept a 32- or
    64-bit memory operand. They convert the memory operand to an 80-bit extended-precision
    value and subtract this from ST0 (`fsub`) or subtract ST0 from this value (`fsubr`)
    and store the result back into ST0.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If a stack fault exception occurs,
    C[1] denotes stack overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instructions that have real constants as operands aren't true FPU instructions.
    These are extensions provided by HLA. HLA generates a constant segment memory
    object initialized with the constant's value.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.3 The fmul and fmulp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fmul` and `fmulp` instructions multiply two floating-point values. These
    instructions allow the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: With no operands, `fmul` will compute `st0 * st1` and store the product into
    ST1\. The `fmulp` instruction, with no operands, will pop ST0 and ST1, multiply
    these values, and push their product back onto the stack. The `fmul` instructions
    with two register operands compute *`destination`* `:=` *`destination`* `*` *`source`*.
    One of the registers (source or destination) must be ST0.
  prefs: []
  type: TYPE_NORMAL
- en: The `fmulp( st0, st`*`i`* `)` instruction computes `st`*`i`* `:= st`*`i`* `*
    st0` and then pops ST0\. This instruction uses the value for ST*i* before popping
    ST0\. The `fmul(` *`mem`* `)` instruction requires a 32- or 64-bit memory operand.
    It converts the specified memory variable to an 80-bit extended-precision value
    and then multiplies ST0 by this value.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    and illegal operation exceptions, as appropriate. If rounding occurs during the
    computation, these instructions set the C[1] condition code bit. If a stack fault
    exception occurs, C[1] denotes stack overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instruction that has a real constant as its operand isn't a true FPU instruction.
    It is an extension provided by HLA (see the note at the end of [6.5.6.2 The fsub,
    fsubp, fsubr, and fsurpb Instructions](ch06s05.html#the_fsub_comma_fsubp_comma_fsubr_comma_a
    "6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions") for details).
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.4 The fdiv, fdivp, fdivr, and fdivrp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These four instructions allow the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: With no operands, the `fdivp` instruction pops ST0 and ST1, computes `st1/st0`,
    and pushes the result back onto the stack. The `fdiv` instruction with no operands
    computes `st1 := st1/st0`. The `fdivr` and `fdivrp` instructions work in a similar
    fashion to `fdiv` and `fdivp` except that they compute `st0/st1` rather than `st1/st0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With two register operands, these instructions compute the following quotients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `fdivp` and `fdivrp` instructions also pop ST0 after performing the division
    operation. The value for *`i`* in these two instructions is computed before popping
    ST0.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions can raise the stack, precision, underflow, overflow, denormalized,
    zero divide, and illegal operation exceptions, as appropriate. If rounding occurs
    during the computation, these instructions set the C[1] condition code bit. If
    a stack fault exception occurs, C[1] denotes stack overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.5 The fsqrt Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fsqrt` routine does not allow any operands. It computes the square root
    of the value on top of stack (TOS) and replaces ST0 with this result. The value
    on TOS must be 0 or positive; otherwise `fsqrt` will generate an invalid operation
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: This instruction can raise the stack, precision, denormalized, and invalid operation
    exceptions, as appropriate. If rounding occurs during the computation, `fsqrt`
    sets the C[1] condition code bit. If a stack fault exception occurs, C[1] denotes
    stack overflow or underflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.6.6 The fprem and fprem1 Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fprem` and `fprem1` instructions compute a *partial remainder*. Intel designed
    the `fprem` instruction before the IEEE finalized its floating-point standard.
    In the final draft of the IEEE floating-point standard, the definition of `fprem`
    was a little different than Intel's original design. Unfortunately, Intel needed
    to maintain compatibility with the existing software that used the `fprem` instruction,
    so it designed a new version to handle the IEEE partial remainder operation, `fprem1`.
    You should always use `fprem1` in new software; therefore we will discuss only
    `fprem1` here, although you use `fprem` in an identical fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '`fprem1` computes the *partial* remainder of `st0/st1`. If the difference between
    the exponents of ST0 and ST1 is less than 64, `fprem1` can compute the exact remainder
    in one operation. Otherwise you will have to execute the `fprem1` two or more
    times to get the correct remainder value. The C[2] condition code bit determines
    when the computation is complete. Note that `fprem1` does *not* pop the two operands
    off the stack; it leaves the partial remainder in ST0 and the original divisor
    in ST1 in case you need to compute another partial product to complete the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fprem1` instruction sets the stack exception flag if there aren't two values
    on the top of stack. It sets the underflow and denormal exception bits if the
    result is too small. It sets the invalid operation bit if the values on TOS are
    inappropriate for this operation. It sets the C[2] condition code bit if the partial
    remainder operation is not complete. Finally, it loads C[3], C[1], and C[0] with
    bits 0, 1, and 2 of the quotient, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.6.7 The frndint Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `frndint` instruction rounds the value on the top of stack (TOS) to the
    nearest integer using the rounding algorithm specified in the control register.
  prefs: []
  type: TYPE_NORMAL
- en: This instruction sets the stack exception flag if there is no value on the TOS
    (it will also clear C[1] in this case). It sets the precision and denormal exception
    bits if there was a loss of precision. It sets the invalid operation flag if the
    value on the TOS is not a valid number. Note that the result on TOS is still a
    floating-point value; it simply does not have a fractional component.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.6.8 The fabs Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fabs` computes the absolute value of ST0 by clearing the mantissa sign bit
    of ST0\. It sets the stack exception bit and invalid operation bits if the stack
    is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.6.9 The fchs Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fchs` changes the sign of ST0''s value by inverting the mantissa sign bit
    (that is, this is the floating-point negation instruction). It sets the stack
    exception bit and invalid operation bits if the stack is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.7 Comparison Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU provides several instructions for comparing real values. The `fcom`,
    `fcomp`, and `fcompp` instructions compare the two values on the top of stack
    and set the condition codes appropriately. The `ftst` instruction compares the
    value on the top of stack with 0.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, most programs test the condition code bits immediately after a comparison.
    Unfortunately, there are no FPU instructions that test the FPU condition codes.
    Instead, you use the `fstsw` instruction to copy the floating-point status register
    into the AX register; then you can use the `sahf` instruction to copy the AH register
    into the 80x86's condition code bits. After doing this, you can test the standard
    80x86 flags to check for some condition. This technique copies C[0] into the carry
    flag, C[2] into the parity flag, and C[3] into the zero flag. The `sahf` instruction
    does not copy C[1] into any of the 80x86's flag bits.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `sahf` instruction does not copy any FPU status bits into the sign
    or overflow flags, you cannot use signed comparison instructions. Instead, use
    unsigned operations (e.g., `seta`, `setb`) when testing the results of a floating-point
    comparison. *Yes, these instructions normally test unsigned values, and floating-point
    numbers are signed values*. However, use the unsigned operations anyway; the `fstsw`
    and `sahf` instructions set the 80x86 flags register as though you had compared
    unsigned values with the `cmp` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The Pentium II and (upward) compatible processors provide an extra set of floating-point
    comparison instructions that directly affect the 80x86 condition code flags. These
    instructions circumvent having to use `fstsw` and `sahf` to copy the FPU status
    into the 80x86 condition codes. These instructions include `fcomi` and `fcomip`.
    You use them just like the `fcom` and `fcomp` instructions, except, of course,
    you do not have to manually copy the status bits to the FLAGS register.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.7.1 The fcom, fcomp, and fcompp Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fcom`, `fcomp`, and `fcompp` instructions compare ST0 to the specified
    operand and set the corresponding FPU condition code bits based on the result
    of the comparison. The legal forms for these instructions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: With no operands, `fcom`, `fcomp`, and `fcompp` compare ST0 against ST1 and
    set the FPU flags accordingly. In addition, `fcomp` pops ST0 off the stack and
    `fcompp` pops both ST0 and ST1 off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: With a single-register operand, `fcom` and `fcomp` compare `ST0` against the
    specified register. `fcomp` also pops ST0 after the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: With a 32- or 64-bit memory operand, the `fcom` and `fcomp` instructions convert
    the memory variable to an 80-bit extended-precision value and then compare ST0
    against this value, setting the condition code bits accordingly. `fcomp` also
    pops ST0 after the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set C[2] (which winds up in the parity flag) if the two operands
    are not comparable (e.g., `NaN`). If it is possible for an illegal floating-point
    value to wind up in a comparison, you should check the parity flag for an error
    before checking the desired condition (e.g., using HLA's `@p` and `@np` conditions,
    or by using the `setp`/`setnp` instructions).
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set the stack fault bit if there aren't two items on the
    top of the register stack. They set the denormalized exception bit if either or
    both operands are denormalized. They set the invalid operation flag if either
    or both operands are quiet `NaN`s. These instructions always clear the C[1] condition
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the instructions that have real constants as operands aren't true
    FPU instructions. These are extensions provided by HLA. When HLA encounters such
    an instruction, it creates a `real64` read-only variable in the constants segment
    and initializes this variable with the specified constant. Then HLA translates
    the instruction to one that specifies a `real64` memory operand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the precision differences (64 bits versus 80 bits), if you use a
    constant operand in a floating-point instruction you may not get results that
    are as precise as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a floating-point comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you cannot compare floating-point values in an HLA runtime boolean
    expression (e.g., within an `if` statement). You may, however, test the conditions
    in such statements after a floating-point comparison like the sequence above.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.7.2 The fcomi and fcomip Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fcomi` and `fcomip` instructions compare ST0 to the specified operand
    and set the corresponding EFLAG condition code bits based on the result of the
    comparison. You use these instructions in a similar manner to `fcom` and `fcomp`
    except you can test the CPU''s flag bits directly after the execution of these
    instructions without first moving the FPU status bits into the EFLAGS register.
    The legal forms for these instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.7.3 The ftst Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ftst` instruction compares the value in ST0 against 0.0\. It behaves just
    like the `fcom` instruction would if ST1 contained 0.0\. Note that this instruction
    does not differentiate −0.0 from +0.0\. If the value in ST0 is either of these
    values, `ftst` will set C[3] to denote equality. This instruction does *not* pop
    ST0 off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.8 Constant Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU provides several instructions that let you load commonly used constants
    onto the FPU''s register stack. These instructions set the stack fault, invalid
    operation, and C[1] flags if a stack overflow occurs; they do not otherwise affect
    the FPU flags. The specific instructions in this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 6.5.9 Transcendental Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU provides eight transcendental (logarithmic and trigonometric) instructions
    to compute sine, cosine, partial tangent, partial arctangent, 2*x* - 1, *y* *
    log[2](*x*), and *y* * log[2](*x* + 1). Using various algebraic identities, it
    is easy to compute most of the other common transcendental functions using these
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.1 The f2xm1 Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`f2xm1` computes 2^(ST0) - 1\. The value in ST0 must be in the range −1.0..ST0..+1.0\.
    If ST0 is out of range, `f2xm1` generates an undefined result but raises no exceptions.
    The computed value replaces the value in ST0.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example computing 10^(*x*) using the identity 10^(*x*) = 2^(*x* *log2(10)).
    This is only useful for a small range of *x* that doesn't put ST0 outside of the
    previously mentioned valid range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Note that `f2xm1` computes 2*x* - 1, which is why the code above adds 1.0 to
    the result at the end of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.2 The fsin, fcos, and fsincos Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These instructions pop the value off the top of the register stack and compute
    the sine, cosine, or both and push the result(s) back onto the stack. The `fsincos`
    instruction pushes the sine followed by the cosine of the original operand; hence
    it leaves cos(ST0) in ST0 and sin(ST0) in ST1.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions assume ST0 specifies an angle in radians and this angle must
    be in the range −2^(63) < ST0 < +2^(63). If the original operand is out of range,
    these instructions set the C[2] flag and leave ST0 unchanged. You can use the
    `fprem1` instruction, with a divisor of 2π, to reduce the operand to a reasonable
    range.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions set the stack fault/C[1], precision, underflow, denormalized,
    and invalid operation flags according to the result of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.3 The fptan Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fptan` computes the tangent of ST0 and pushes this value, and then it pushes
    1.0 onto the stack. Like the `fsin` and `fcos` instructions, the value of ST0
    must be in radians and in the range −2^(63) < ST0 < +2^(63). If the value is outside
    this range, `fptan` sets C[2] to indicate that the conversion did not take place.
    As with the `fsin`, `fcos`, and `fsincos` instructions, you can use the `fprem1`
    instruction to reduce this operand to a reasonable range using a divisor of 2π.'
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is invalid (i.e., zero or π radians, which causes a division
    by 0), the result is undefined and this instruction raises no exceptions. `fptan`
    will set the stack fault, precision, underflow, denormal, invalid operation, C[2],
    and C[1] bits as required by the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.4 The fpatan Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This instruction expects two values on the top of stack. It pops them and computes
    ST0 = tan^(−1)(ST1/ST0).
  prefs: []
  type: TYPE_NORMAL
- en: The resulting value is the arctangent of the ratio on the stack expressed in
    radians. If you have a value you wish to compute the tangent of, use `fld1` to
    create the appropriate ratio and then execute the `fpatan` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: This instruction affects the stack fault/C[1], precision, underflow, denormal,
    and invalid operation bits if a problem occurs during the computation. It sets
    the C[1] condition code bit if it has to round the result.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.5 The fyl2x Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction has no operands (to the instruction itself ). The instruction
    uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note that this instruction computes the base-2 logarithm. Of course, it is a
    trivial matter to compute the log of any other base by multiplying by the appropriate
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.9.6 The fyl2xp1 Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This instruction expects two operands on the FPU stack: `y` is found in ST1
    and `x` is found in ST0\. This function computes ST0 = ST1 * log[2](ST0 + 1.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this instruction is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the instruction is identical to `fyl2x`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10 Miscellaneous Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FPU includes several additional instructions that control the FPU, synchronize
    operations, and let you test or set various status bits. These instructions include
    `finit`/`fninit`, `fldcw`, `fstcw`, `fclex`/`fnclex`, and `fstsw`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.1 The finit and fninit Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `finit` instruction initializes the FPU for proper operation. Your applications
    should execute this instruction before executing any other FPU instructions. This
    instruction initializes the control register to $37F, the status register to 0,
    and the tag word to $FFFF. The other registers are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `finit` and `fninit` is that `finit` first checks for
    any pending floating-point exceptions before initializing the FPU; `fninit` does
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.2 The fldcw and fstcw Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fldcw` and `fstcw` instructions require a single 16-bit memory operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: These two instructions load the control register from a memory location (`fldcw`)
    or store the control word to a 16-bit memory location (`fstcw`).
  prefs: []
  type: TYPE_NORMAL
- en: When using the `fldcw` instruction to turn on one of the exceptions, if the
    corresponding exception flag is set when you enable that exception, the FPU will
    generate an immediate interrupt before the CPU executes the next instruction.
    Therefore, you should use the `fclex` instruction to clear any pending interrupts
    before changing the FPU exception enable bits.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.3 The fclex and fnclex Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fclex` and `fnclex` instructions clear all exception bits, the stack fault
    bit, and the busy flag in the FPU status register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The difference between these instructions is the same as between `finit` and
    `fninit`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.10.4 The fstsw and fnstsw Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These instructions store the FPU status register into a 16-bit memory location
    or the AX register.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: These instructions are unusual in the sense that they can copy an FPU value
    into one of the 80x86 general-purpose registers (specifically, AX). Of course,
    the whole purpose behind allowing the transfer of the status register into AX
    is to allow the CPU to easily test the condition code register with the `sahf`
    instruction. The difference between `fstsw` and `fnstsw` is the same as for `fclex`
    and `fnclex`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.11 Integer Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FPU provides special instructions that combine integer-to-extended-precision
    conversion with various arithmetic and comparison operations. These instructions
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: These instructions convert their 16- or 32-bit integer operands to an 80-bit
    extended-precision floating-point value and then use this value as the source
    operand for the specified operation. These instructions use ST0 as the destination
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[102](#CHP-6-FN-1)]) Intel has also referred to this device as the Numeric
    Data Processor (NDP), Numeric Processor Extension (NPX), and math coprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[103](#CHP-6-FN-2)]) Storing a denormalized value into a 32- or 64-bit memory
    variable will always set the underflow exception bit.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Converting Floating-Point Expressions to Assembly Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because the FPU register organization is different than the 80x86 integer register
    set, translating arithmetic expressions involving floating-point operands is a
    little different than the techniques for translating integer expressions. Therefore,
    it makes sense to spend some time discussing how to manually translate floating-point
    expressions into assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: In one respect, it's actually easier to translate floating-point expressions
    into assembly language. The stack architecture of the Intel FPU eases the translation
    of arithmetic expressions into assembly language. If you've ever used a Hewlett-Packard
    calculator, you'll be right at home on the FPU because, like the HP calculator,
    the FPU uses *postfix notation* (also called *Reverse Polish notation*, or *RPN*
    ), for arithmetic operations. Once you get used to using postfix notation, it's
    actually a bit more convenient for translating expressions because you don't have
    to worry about allocating temporary variables—they always wind up on the FPU stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Postfix notation, as opposed to standard *infix notation*, places the operands
    before the operator. The following examples give some simple examples of infix
    notation and the corresponding postfix notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'A postfix expression like `5 6 +` says, "push 5 onto the stack, push 6 onto
    the stack, and then pop the value off the top of stack (6) and add it to the new
    top of stack." Sound familiar? This is exactly what the `fld` and `fadd` instructions
    do. In fact, you can calculate this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, postfix is a convenient notation because it's very easy to translate
    this code into FPU instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage to postfix notation is that it doesn''t require any parentheses.
    The following examples demonstrate some slightly more complex infix-to-postfix
    conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The postfix expression `x y + 2 *` says, "Push `x`, then push `y`; next, add
    those values on the stack (producing `x + y` on the stack). Next, push 2 and then
    multiply the two values (2 and `x + y`) on the stack to produce two times the
    quantity `x + y`." Once again, we can translate these postfix expressions directly
    into assembly language. The following code demonstrates the conversion for each
    of the above expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 6.6.1 Converting Arithmetic Expressions to Postfix Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the process of translating arithmetic expressions into assembly language
    involves postfix notation (RPN), converting arithmetic expressions into postfix
    notation seems like a good place to begin our discussion of floating-point expression
    conversion. This section will concentrate on postfix conversion.
  prefs: []
  type: TYPE_NORMAL
- en: For simple expressions, those involving two operands and a single expression,
    the translation is trivial. Simply move the operator from the infix position to
    the postfix position (that is, move the operator from between the operands to
    after the second operand). For example, `5 + 6` becomes `5 6 +`. Other than separating
    your operands so you don't confuse them (i.e., is it 5 and 6 or 56?), converting
    simple infix expressions into postfix notation is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: For complex expressions, the idea is to convert the simple subexpressions into
    postfix notation and then treat each converted subexpression as a single operand
    in the remaining expression. The following discussion surrounds completed conversions
    with square brackets so it is easy to see which text needs to be treated as a
    single operand in the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for integer expression conversion, the best place to start is in the innermost
    parenthetical subexpression and then work your way outward considering precedence,
    associativity, and other parenthetical subexpressions. As a concrete working example,
    consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible first translation is to convert the subexpression `(y - z)` into
    postfix notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Square brackets surround the converted postfix code just to separate it from
    the infix code. These exist only to make the partial translations more readable.
    Remember, for the purposes of conversion we will treat the text inside the square
    brackets as a single operand. Therefore, you would treat `[y z -]` as though it
    were a single variable name or constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to translate the subexpression `([y z -] * a )` into postfix
    form. This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we work on the parenthetical expression `( a + b * c )`. Because multiplication
    has higher precedence than addition, we convert `b * c` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'After converting `b * c` we finish the parenthetical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves only two infix operators: subtraction and division. Because division
    has the higher precedence, we''ll convert that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we convert the entire expression into postfix notation by dealing
    with the last infix operation, subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the square brackets to give us true postfix notation yields the following
    postfix expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps demonstrate another infix-to-postfix conversion for the
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Work inside the parentheses. Because multiplication has the highest precedence,
    convert that first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still working inside the parentheses, we note that addition and subtraction
    have the same precedence, so we rely on associativity to determine what to do
    next. These operators are left associative, so we must translate the expressions
    in a left-to-right order. This means translate the subtraction operator first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now translate the addition operator inside the parentheses. Because this finishes
    the parenthetical operators, we can drop the parentheses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Translate the final infix operator (division). This yields the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Drop the square brackets and we''re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 6.6.2 Converting Postfix Notation to Assembly Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've translated an arithmetic expression into postfix notation, finishing
    the conversion to assembly language is easy. All you have to do is issue an `fld`
    instruction whenever you encounter an operand and issue an appropriate arithmetic
    instruction when you encounter an operator. This section uses the completed examples
    from the previous section to demonstrate how little there is to this process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Convert `y` to `fld(y)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `z` to `fld(z)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `-` to `fsub()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `a` to `fld(a)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `*` to `fmul()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continuing in a left-to-right fashion, generate the following code for the
    expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the translation for the second example in the previous section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the translation is fairly simple once you've converted the infix
    notation to postfix notation. Also note that, unlike integer expression conversion,
    you don't need any explicit temporaries. It turns out that the FPU stack provides
    the temporaries for you.^([[104](#ftn.CHP-6-FN-3)]) For these reasons, conversion
    of floating-point expressions into assembly language is actually easier than converting
    integer expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[104](#CHP-6-FN-3)]) This assumes, of course, that your calculations aren't
    so complex that you exceed the eight-element limitation of the FPU stack.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 HLA Standard Library Support for Floating-Point Arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") briefly mentioned the
    `stdin.getf` function. What it left out of that discussion is where `stdin.getf`
    returns the floating-point value is reads from the standard input. Now that you''ve
    seen the floating-point extensions to the 80x86, it''s possible to finish the
    discussion of that standard library function. The `stdin.getf` function reads
    a string of characters from the standard input, converts those characters to an
    80-bit floating-point number, and leaves the result sitting on the FPU stack (in
    ST0).'
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library also provides the `math.hhf` module that includes several
    mathematical functions that the FPU doesn't directly support as well as support
    for various functions (like sine and cosine) that the FPU partially supports.
    Some of the functions that the `math.hhf` module provides are `acos`, `acot`,
    `acsc`, `asec`, `asin`, `cot`, `csc`, `sec`, `2^x`, `10^x`, `y^x`, `e^x`, `log`,
    and `ln`. Please consult the HLA standard library documentation for more information
    about these functions and other mathematical functions the HLA standard library
    supports.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Intel/AMD processor manuals fully describe the operation of each of the
    integer and floating-point arithmetic instructions, including a detailed description
    of how these instructions affect the condition code bits and other flags in the
    EFLAGS and FPU status registers. To write the best possible assembly language
    code, you need to be intimately familiar with how the arithmetic instructions
    affect the execution environment, so spending time with the Intel/AMD manuals
    is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library provides a large number of floating-point functions
    for which there are no individual machine instructions. The HLA Standard Library
    also provides functions like `math.sin` and `math.cos` that overcome limitations
    of the native machine instructions. See the HLA Standard Library reference manual
    for more details. Also, the HLA Standard Library is available in source code form,
    so you can look at the implementation of these mathematical functions for more
    examples of floating-point coding.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") discusses multiprecision
    integer arithmetic. See that chapter for details on handling integer operands
    that are greater than 32 bits in size.'
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 SSE instruction set found on later members of the CPU provides support
    for floating-point arithmetic using the SSE register set. Consult [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or the Intel/AMD documentation for details concerning the SSE floating-point instruction
    set.
  prefs: []
  type: TYPE_NORMAL
