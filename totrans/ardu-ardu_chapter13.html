<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch13" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch13">
<span class="CN"><span aria-label=" Page 205. " epub:type="pagebreak" id="pg_205" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">INTERFACING WITH PS/2 KEYBOARDS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Some Arduino projects, such as motor controllers, lighting systems, or even games, need to accept text or numerical data via a familiar, user-friendly form of input. This chapter shows you how to accept such data with a standard PS/2-style PC keyboard and then display it with an I<sup>2</sup>C-interface LCD.</p>
<p class="TX">You’ll learn to:</p>
<ul class="ul">
<li class="BL">Receive data from a Personal System/2 (PS/2) keyboard through your Arduino</li>
<li class="BL">Set up I<sup>2</sup>C-interface LCDs for convenient data display</li>
<li class="BL">Capture text from a PS/2 keyboard and display on the LCD</li>
</ul>
<p class="TX">You’ll also build an RGB LED tester with keyboard input, as well as a distraction-free text file entry device.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-92"/><span aria-label=" Page 206. " epub:type="pagebreak" id="pg_206" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">The PS/2 Keyboard</samp></h2>
<p class="TNI">This chapter uses a keyboard with a PS/2-style interface, first introduced by IBM in 1987 along with its new PS/2 series of personal computers. This type of interface was prevalent until around 1997, when the USB standard increased in popularity. However, PS/2 keyboards are still available and used with various PCs and industrial devices due to the simplicity of the interface. The actual layout of the keys on a PS/2 keyboard is virtually identical to that of the keyboards you use today.</p>
<p class="TX">The PS/2 keyboard connector is in the six-pin mini-DIN format, as shown in <a href="chapter13.xhtml#fig13-1">Figure 13-1</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A PS/2 KEYBOARD PLUG" class="img8" id="fig13-1" src="../images/fig13-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: A PS/2 keyboard connector</samp></p></figcaption>
</figure>
<p class="TX">We’ll use a simple PS/2 socket breakout board (such as PMD Way part 694804) to interface the keyboard with our Arduino, as shown in <a href="chapter13.xhtml#fig13-2">Figure 13-2</a>. The socket breakout board uses four connections: 5V, GND, Clock, and Data.</p>
<figure class="IMG"><img alt="A PHOTO OF A PS/2 SOCKET BREAKOUT BOARD" class="img4" id="fig13-2" src="../images/fig13-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: A PS/2 socket breakout board</samp></p></figcaption>
</figure>
<p class="TX">Each key on the keyboard is represented by a numerical code. When a key is pressed on the keyboard, the keycode data is sent to the PC via a bidirectional half-duplex data line. This means data can travel in either direction between the PC and the keyboard but in only one direction at a time.</p>
<blockquote>
<p class="NOTE"><span aria-label=" Page 207. " epub:type="pagebreak" id="pg_207" role="doc-pagebreak"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>PS/2 keyboards are 5 V devices. If you’re using an Arduino or compatible with a 3.3 V operating voltage, you’ll need to use a bidirectional level converter board between the Arduino and PS/2 breakout.</i></p>
<p class="TX">For each keypress, the keyboard sends out a LOW start bit, followed by 8 bits that represent the key pressed, then a parity bit along the data line, with a matching Clock line to maintain timing and data accuracy. For example, <a href="chapter13.xhtml#fig13-3">Figure 13-3</a> shows the Clock (1) and Data (2) lines when P is pressed on the keyboard.</p>
<figure class="IMG"><img alt="A SCREEN CAPTURE OF PS/2 KEYBOARD DATA SHOWN ON A DIGITAL STORAGE OSCILLOSCOPE" class="img1" id="fig13-3" src="../images/fig13-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The timing diagram for PS/2 keypress shown on a digital storage oscilloscope</samp></p></figcaption>
</figure>
<p class="TX">The keycode for the letter P is 0x4D in hexadecimal, or 01001101 in binary—you can see the bits marked on the data line in <a href="chapter13.xhtml#fig13-3">Figure 13-3</a>. A complete list of the keycodes is available from <a href="https://wiki.osdev.org/PS/2_Keyboard"><i>https://<wbr/>wiki<wbr/>.osdev<wbr/>.org<wbr/>/PS<wbr/>/2<wbr/>_Keyboard</i></a>.</p>
<p class="TX">To use the keyboard with your Arduino, you’ll need to install a library. Open the IDE’s library manager and search for <b>ps/2</b>; then install the resulting library.</p>
<p class="TX">To test the keyboard, connect the PS/2 breakout board to the Arduino, as shown in the schematic in <a href="chapter13.xhtml#fig13-4">Figure 13-4</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR THE PS/2 KEYBOARD SOCKET BREAKOUT BOARD" class="img4" id="fig13-4" src="../images/fig13-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: The schematic for keyboard connection</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 208. " epub:type="pagebreak" id="pg_208" role="doc-pagebreak"/>Next, enter and upload the <a href="#LiT-13-1">Listing 13-1</a> sketch.</p>
<span id="LiT-13-1"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;PS2Keyboard.h&gt;
PS2Keyboard keyboard;

void setup()
{
    delay(1000);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> keyboard.begin(4, 3);
    Serial.begin(9600);
    Serial.println("Keyboard Test:");
}

void loop()
{
    if (keyboard.available())
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> {
        // Read the next key:
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> char c = keyboard.read();
        // Check for some of the special keys:
        switch (c)
        {
            case PS2_ENTER: Serial.println(); break;
            case PS2_TAB: Serial.print("[Tab]"); break;
            case PS2_ESC: Serial.print("[ESC]"); break;
            case PS2_PAGEDOWN: Serial.print("[PgDn]"); break;
            case PS2_PAGEUP: Serial.print("[PgUp]"); break;
            case PS2_LEFTARROW: Serial.print("[Left]"); break;
            case PS2_RIGHTARROW: Serial.print("[Right]"); break;
            case PS2_UPARROW: Serial.print("[Up]"); break;
            case PS2_DOWNARROW: Serial.print("[Down]"); break;
            case PS2_DELETE: Serial.print("[Del]"); break;
            // Otherwise, just print all normal characters
          <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> default: Serial.print(c); break;
      }
    }
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Testing the PS/2 keyboard</samp></p>
<p class="TX">A few moments after uploading, open the Serial Monitor and type anything you like on the PS/2 keyboard. <a href="chapter13.xhtml#fig13-5">Figure 13-5</a> shows an example of the project in operation with what I typed on the keyboard displayed in the Serial Monitor.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT ON THE SERIAL MONITOR FOR LISTING 13-1" class="img8" id="fig13-5" src="../images/fig13-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: Example output of the keyboard test sketch</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 209. " epub:type="pagebreak" id="pg_209" role="doc-pagebreak"/>The sketch initializes the library <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then activates the connection to the keyboard on digital pins 4 and 3 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>; the parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">keyboard.begin()</samp> are the digital pin numbers for the Clock and Data lines, respectively. The sketch checks if a button has been pressed <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and assigns the result to the character variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. After checking for function keys using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> statement, it sends the resulting key to the Serial Monitor <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">If you find the keyboard returns gibberish, check that the power to the keyboard is exactly or close to 5 V DC; the keyboard needs a straight 5 V to function correctly. Some Arduino boards can offer a voltage very close to 5 V, but some offer less, around 4.7 V or worse. If your voltage is too low, use an external 5 V supply for the circuit and future projects that use a PS/2 keyboard.</p>
<p class="TX">Now that you’ve seen how to integrate keyboard input into your projects, let’s set up an output display, using an I<sup>2</sup>C-bus-compatible LCD.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-93"/><samp class="SANS_Futura_Std_Bold_B_11">PCF8574 LCD Modules</samp></h2>
<p class="TNI">Using an LCD for display output is popular in the Arduino world. This generally involves using an LCD shield or wiring up an HD44780-compatible LCD with eight or so wires back to the Arduino. However, in recent years, a new method of using these LCDs has gained popularity: soldering a PCF8574 I<sup>2</sup>C backpack unit to the display, which allows you to connect the LCD to your project with only four wires.</p>
<p class="TX">The PCF8574 is an I<sup>2</sup>C-based port expander that can interface the LCD’s control pins to the popular serial data bus. This obviates the need to use digital I/O pins and helps simplify the overall wiring. You can either buy the modules separately or purchase LCDs with the pre-attached modules, as shown in <a href="chapter13.xhtml#fig13-6">Figure 13-6</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE REAR OF THE LCD WITH A FITTED PCF8574 I2C LCD INTERFACE MODULE" class="img6" id="fig13-6" src="../images/fig13-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: The rear of a PCF8574 I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C LCD module</samp></p></figcaption>
</figure>
<p class="TX">To connect the module to the Arduino, use the 5V/V<sub>CC</sub>, GND, Clock, and Data lines, as with any other I<sup>2</sup>C device. You can adjust the display contrast using the trimpot on the module. You can also bridge the three pairs of solder bridge pads under the trimpot (A0, A1, or A2) to change the I<sup>2</sup>C bus address from the default <samp class="SANS_TheSansMonoCd_W5Regular_11">0 x 27</samp> to one of seven other options. To use the LCD with your Arduino, you must install a library. Open the IDE’s library manager and search for <b>PCF8574</b>; then install the latest version of the library.</p>
<p class="TX"><span aria-label=" Page 210. " epub:type="pagebreak" id="pg_210" role="doc-pagebreak"/>To test the display, connect to the Arduino, as shown in the schematic in <a href="chapter13.xhtml#fig13-7">Figure 13-7</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR PCF8574-CONTROLLED LCD" class="img5" id="fig13-7" src="../images/fig13-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: The schematic for LCD connection</samp></p></figcaption>
</figure>
<p class="TX">Next, enter and upload the <a href="#LiT-13-2">Listing 13-2</a> sketch.</p>
<span id="LiT-13-2"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;LiquidCrystal_PCF8574.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);

void setup()
{
    Wire.begin();
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Wire.beginTransmission(0x27);
    lcd.begin(16, 2);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> lcd.setBacklight(255);
}

void loop()
{
    lcd.home();
    lcd.clear();
    lcd.setCursor(2, 0);
    lcd.print("Hello, world!");
    delay(1000);
    lcd.setCursor(2,1);
    lcd.print("* Arduino *");
    delay(1000);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Testing the PCF8574 LCD</samp></p>
<p class="TX">After the sketch uploads, you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">* Arduino *</samp> blinking on the LCD, as shown in <a href="chapter13.xhtml#fig13-8">Figure 13-8</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD DISPLAYING THE DEMONSTRATION TEXT, “HELLO WORLD! ARDUINO”" class="img8" id="fig13-8" src="../images/fig13-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: The I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C LCD in action</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 211. " epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/>Once the LCD is initialized, basic operation is the same as the usual Arduino LCD library. The sketch includes the Wire library for I<sup>2</sup>C and the I<sup>2</sup>C LCD library <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then creates an instance of the LCD using bus address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>. It starts communication on the I<sup>2</sup>C bus to address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp> (the LCD) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, then configures the LCD size (16 characters, 2 rows) with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.begin()</samp>, and finally turns on the backlight with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setBacklight()</samp>. You can control the backlight by using 255 to turn the backlight on, and 0 to turn it off; in this sketch, it’s set to on <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The sketch uses the usual LCD functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home()</samp> resets the cursor to the top-left character, <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.clear()</samp> clears the display, and so on. If you are using other I<sup>2</sup>C bus devices in the same project, don’t forget to restart the bus to the LCD with another <samp class="SANS_TheSansMonoCd_W5Regular_11">Wire.beginTransmission(0x27)</samp> before sending display commands.</p>
<p class="TX">If your display doesn’t work, the bus address for your display could be different from the one used in the sketch. You can use the <span class="Xref">Project #30</span> I<sup>2</sup>C scanner sketch described in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> to check the device bus address and substitute it into the sketch in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x27</samp>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-94"/><samp class="SANS_Futura_Std_Bold_B_11">Testing the I</samp><samp class="SANS_Futura_Std_Bold_B-SUP_11">2</samp><samp class="SANS_Futura_Std_Bold_B_11">C LCD and PS/2 Keyboard</samp></h2>
<p class="TNI">Now that you’ve experimented with the I<sup>2</sup>C LCD and the keyboard separately, this section shows how they can work together as a test of the combined hardware. I hope this helps inspire your own independent project ideas, such as a text editor using an LCD or perhaps your own text-based game.</p>
<p class="TX">Connect the keyboard and LCD as described in the previous sections and then enter and upload the <a href="#LiT-13-3">Listing 13-3</a> sketch.</p>
<span id="LiT-13-3"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;LiquidCrystal_PCF8574.h&gt;
#include &lt;Wire.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);
#include &lt;PS2Keyboard.h&gt;
PS2Keyboard keyboard;

int xPosition = 0;
int yPosition = 0;

void setup()
{
    Wire.begin();
    Wire.beginTransmission(0x27);
    lcd.begin(16, 2);
    lcd.setBacklight(255);
    lcd.blink();
    keyboard.begin(4, 3);
}

<span aria-label=" Page 212. " epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>void loop()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (keyboard.available())
    {
        // Read the next key:
        char c = keyboard.read();
        // Check for some of the special keys:
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if (c == PS2_ENTER)
        {
            xPosition = 0;
            if (yPosition == 0)
            {
                yPosition = 1;
            } else if (yPosition == 1)
            {
                yPosition = 0;
            }
            lcd.setCursor(xPosition, yPosition);
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> }
        else if (c == PS2_TAB)
        {
            lcd.print("[Tab]");
      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> }
        else if (c == PS2_ESC)
        {
            lcd.home();
            lcd.clear();
            xPosition = 0;
            yPosition = 0;
      <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> }
        else if (c == PS2_PAGEDOWN)
        {
            lcd.print("[PgDn]");
        }
        else if (c == PS2_PAGEUP)
        {
            lcd.print("[PgUp]");
        }
        else if (c == PS2_LEFTARROW)
        {
            lcd.print("[Left]");
        }
        else if (c == PS2_RIGHTARROW)
        {
            lcd.print("[Right]");
        }
        else if (c == PS2_UPARROW)
        {
            lcd.print("[Up]");
        }
        else if (c == PS2_DOWNARROW)
        {
            lcd.print("[Down]");
        }
<span aria-label=" Page 213. " epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>        else if (c == PS2_DELETE)
        {
            lcd.print("[Del]");
        }
        else
        {
            // Otherwise, just print all normal characters
          <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> lcd.print(c);
            xPosition++;
          <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> if (xPosition &gt; 15)
            {
                xPosition = 0;
              <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> if (yPosition == 0)
                {
                    yPosition = 1;
                }
                else if (yPosition == 1)
                {
                    yPosition = 0;
                }
              <span aria-label="annotation10" class="CodeAnnotationHang1">❿</span> lcd.setCursor(xPosition, yPosition);
            }
        }
    }
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The LCD and keyboard working together</samp></p>
<p class="TX">In a few moments, the LCD backlight should illuminate, and a block cursor should start blinking at the top left of the LCD. Now start typing. Whatever you type on the keyboard—including text, symbols, and most function keys—should appear and then wrap around the screen as if the LCD were a small text editor, as shown in <a href="chapter13.xhtml#fig13-9">Figure 13-9</a>. (I’ve turned off the backlight for a clearer photograph.)</p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD DISPLAYING TEXT ENTERED VIA THE PS/2 KEYBOARD, “THE QUICK BROWN FOX JUMPED OVER”" class="img1" id="fig13-9" src="../images/fig13-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: The LCD displaying text entered via the PS/2 keyboard</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 214. " epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/>You can press <small>ESC</small> to clear the screen and move the cursor back to the top left. The sketch simply takes input from the keyboard (apart from <small>ESC</small>) and sends each press to the display.</p>
<p class="TX">The sketch first initializes the required libraries for the LCD and keyboard and creates two variables to store the position of the cursor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It then starts the keyboard and LCD and turns on the LCD backlight and blinking cursor.</p>
<p class="TX">The main loop of the sketch starts <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> by checking for a press from the keyboard and deciding what to do based on the press <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. First the project checks to see whether the user has pressed <small>ENTER</small>. If so, the cursor on the LCD moves to the start of the second line or is sent back to the start of the first line if it’s already on the second line. The sketch similarly checks for a press of <small>TAB</small> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and displays this on the LCD if so. Or, if the user presses <small>ESC</small> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the screen is cleared and the cursor moves back to the top left of the LCD.</p>
<p class="TX">The sketch continues to check for other keypresses and displays the name of the appropriate keys on the LCD <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. This includes presses of any other keys that don’t belong in the previous checks, including letters, numbers, and symbols <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. After every keypress, the cursor position on the LCD is increased so it moves along one character for columns <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> and rows <span aria-label="annotation9" class="CodeAnnotationCode">❾</span> and moves to the next line or the top left of the LCD when necessary <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>.</p>
<p class="TX">Now that you know how to read the PS/2 keyboard and display the keys pressed, you’ll put these skills to use with the following project that reads integers from the keyboard and works with them to control the brightness and colors available with an RGB LED.</p>
<p class="HeadProject"><span id="h1-95"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #39: Creating an RGB LED Tester</samp></p>
<p class="TNI">In future projects, you may want to test the various colors that can be displayed using a red, green, and blue (RGB) LED to calibrate the settings to reach the desired LED brightness and color. In this project, you’ll build a device that accepts pulse-width modulation (PWM) values for each color and then controls each LED for a defined length of time. If you don’t have an RGB LED, you can still enjoy and understand this project using three separate LEDs.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>You can learn more about PWM in Chapter 19 of</i> <span class="note">Arduino Workshop</span><i>, 2nd edition (No Starch Press, 2021).</i></p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A PS/2 breakout board</li>
<li class="BL">A PS/2 keyboard</li>
<li class="BL">A PCF8574 LCD module</li>
<li class="BL">One common-cathode RGB LED or one each of RGB LEDs</li>
<li class="BL"><span aria-label=" Page 215. " epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/>Three 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter13.xhtml#fig13-10">Figure 13-10</a>. In this project, the breadboard is used as a bridge to help create more 5V and GND connections for the two modules to the Arduino.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #39" class="img1" id="fig13-10" src="../images/fig13-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: The schematic for Project #39</samp></p></figcaption>
</figure>
<p class="TX">Now enter and upload the Project #39 sketch. The LCD should display <samp class="SANS_TheSansMonoCd_W5Regular_11">R:</samp>. Using the PS/2 keyboard, enter a three-digit value between 000 and 255 to set the PWM value for the red LED. The greater the number, the stronger the color will be in the LED. Repeat this process for the green and blue LEDs in response to the <samp class="SANS_TheSansMonoCd_W5Regular_11">G:</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B:</samp> prompts. Finally, the LCD should display a <samp class="SANS_TheSansMonoCd_W5Regular_11">T:</samp> prompt. Key in your required duration for the LEDs to be activated, between 000 and 255 seconds. The LEDs should then activate according to your instructions.</p>
<p class="TX"><a href="chapter13.xhtml#fig13-11">Figure 13-11</a> shows the results of entering in the brightness values for all three LEDs and the duration of activation in seconds.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT ON THE LCD FROM PROJECT #39. “R = 255. G = 127. B = 090. T = 060”" class="img7" id="fig13-11" src="../images/fig13-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: The Project #39 user interface in operation</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-39"/>

<pre><code>// Project #39 - RGB LED tester

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;LiquidCrystal_PCF8574.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);
<span aria-label=" Page 216. " epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>#include &lt;PS2Keyboard.h&gt;
PS2Keyboard keyboard;

#define red 11
#define green 10
#define blue 9

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> int readDigit()
{
    int _digit=−1;
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> do
    {
        if (keyboard.available())
        {
            // Read the next key:
            char c = keyboard.read();
            switch (c)
            {
                case '1' : _digit=_digit+2; break;
                case '2' : _digit=_digit+3; break;
                case '3' : _digit=_digit+4; break;
                case '4' : _digit=_digit+5; break;
                case '5' : _digit=_digit+6; break;
                case '6' : _digit=_digit+7; break;
                case '7' : _digit=_digit+8; break;
                case '8' : _digit=_digit+9; break;
                case '9' : _digit=_digit+10; break;
                case '0' : _digit=0; break;
                default: _digit=0; break;
            }
          <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> lcd.print(c);
        }
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> }
    while(_digit==−1);
    return _digit;
}
<span aria-label="annotation6" class="CodeAnnotationCode">❻</span> int get3digit()
{
    int z;
    z = readDigit()*100;
    z = z + (readDigit()*10);
    z = z + readDigit();
    return z;
}

void setup()
{
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> Wire.begin();
    Wire.beginTransmission(0x27);
    lcd.begin(16, 2);
    lcd.setBacklight(255);
    keyboard.begin(4, 3);
    DDRB = B111111; // Set LED pins to output
}

<span aria-label=" Page 217. " epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>void loop()
{
  <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> int _red;
    int _green;
    int _blue;
    int _delay;
    lcd.home();
    lcd.clear();
    lcd.setCursor(1, 0);
    lcd.print("R:");
    lcd.setCursor(4, 0);
    _red = get3digit();

    lcd.setCursor(8, 0);
    lcd.print("G:");
    lcd.setCursor(11, 0);
    _green = get3digit();

    lcd.setCursor(1, 1);
    lcd.print("B:");
    lcd.setCursor(4, 1);
    _blue = get3digit();

    lcd.setCursor(8, 1);
    lcd.print("T:");
    lcd.setCursor(11, 1);
  <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> _delay = get3digit();
    analogWrite(red, _red);
    analogWrite(green, _green);
    analogWrite(blue, _blue);
    delay(_delay*1000);

    analogWrite(red, 0);
    analogWrite(green, 0);
    analogWrite(blue, 0);
}
</code></pre>

<p class="TX">The sketch first includes and configures the I<sup>2</sup>C LCD and keyboard libraries, as usual <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and then defines the LEDs’ Arduino digital pin numbers to color names for ease of reference. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> returns an integer that is used to return the press of a number on the PS/2 keyboard. This function uses a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>, which is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">–1</samp> upon initialization and stays at that value until a number key is pressed. It then returns the value of any button the user presses as the return value for the function.</p>
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">readDigit()</samp>function needs to wait until a number is pressed on the keyboard, a <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> continues to loop while awaiting a keypress by testing the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp>. When the sketch detects a keypress, however, the function interrogates the key’s value with a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> is then set to the value of the number key pressed, which is equal to the number plus 1. For example, if the user presses the 5 key, the sketch adds 6 to <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> to reflect this. If the user doesn’t press one of the numbers, it will return a 0 for _<samp class="SANS_TheSansMonoCd_W5Regular_11">digit</samp>.</p>
<p class="TX"><span aria-label=" Page 218. " epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/>Once the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">_digit</samp> has changed, the test in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> function <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> fails. The code can thus continue to display the appropriate number on the LCD <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and return the value of the number pressed.</p>
<p class="TX">The project needs three-digit values from the user for PWM and time values. Therefore, the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">get3digit()</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> creates a three-digit number by calling for a digit from the keyboard three times and then combining the number into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, which is returned as the result of this function.</p>
<p class="TX">The sketch starts the I<sup>2</sup>C bus, LCD, and keyboard <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> and then sets the digital pins for the LEDs to outputs using port manipulation (discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>). I’ve set variables to hold the PWM values for each LED and time on delay <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. The project then accepts the user’s value for red PWM, green PWM, blue PWM, and the number of seconds for the LEDs to stay on. These are actioned at <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>, and the delay is converted to milliseconds. Once the delay has finished, the LEDs are turned off, and the system starts again.</p>
<p class="TX">Now that you have an example of capturing and working with numerical input from a PS/2 keyboard, you’ll build a device to capture text as well, saving that input to an SD card for use with a PC.</p>
<p class="HeadProject"><span id="h1-96"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #40: Building a Text Capture Device</samp></p>
<p class="TNI">The text capture device described in this project lets you record notes or other writing for later reference, without the distractions of internet or cell phone notifications to lure you away from real work. Everything you type onto the project’s PS/2 keyboard is recorded to a text file on an SD memory card, which you can then open on your PC for final editing.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>You can learn more about using SD memory cards in Chapter 7 of</i> <span class="note">Arduino Workshop</span><i>, 2nd edition (No Starch Press, 2021).</i></p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A PS/2 breakout board</li>
<li class="BL">A PS/2 keyboard</li>
<li class="BL">A PCF8574 LCD module</li>
<li class="BL">An SD card module or SD card shield for Arduino</li>
<li class="BL">A blank SD memory card</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter13.xhtml#fig13-12">Figure 13-12</a>. If you’re using the SD card shield, insert it onto the Arduino and then connect the LCD and PS/2 modules. Again, this project uses the breadboard as a bridge to help create more 5V and GND connections for the two modules to the Arduino.<span aria-label=" Page 219. " epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #40" class="img1" id="fig13-12" src="../images/fig13-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: The schematic for Project #40</samp></p></figcaption>
</figure>
<p class="TX">Now enter and upload the Project #40 sketch and then insert the SD card into the module. Start typing when prompted by the LCD, as shown in <a href="chapter13.xhtml#fig13-13">Figure 13-13</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD. “START TYPING: THE QUICK BROWN”" class="img7" id="fig13-13" src="../images/fig13-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: The LCD from Project #40 displaying text captured from a keyboard</samp></p></figcaption>
</figure>
<p class="TX">As you continue typing, the cursor should scroll around to the second row and then back to the first, in the same manner as shown in <a href="chapter13.xhtml#fig13-14">Figure 13-14</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING TEXT CAPTURED FROM THE KEYBOARD SCROLLING ACROSS TWO LINES: “FOX JUMPED OVER THE LAZY BROWN DOG. N”" class="img7" id="fig13-14" src="../images/fig13-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Text scrolling across two lines in the LCD</samp></p></figcaption>
</figure>
<p class="TX">As you type, the Arduino should automatically save every 100 characters to a file on the SD card. When you’ve finished and want to take the SD card away, press <small>ESC</small> on the keyboard. The Arduino should save any remaining characters and then prompt you to remove the SD card, as shown in <a href="chapter13.xhtml#fig13-15">Figure 13-15</a>.<span aria-label=" Page 220. " epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE MESSAGE “OK TO REMOVE CARD”" class="img7" id="fig13-15" src="../images/fig13-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: The LCD displaying the message that it’s okay to remove the SD card</samp></p></figcaption>
</figure>
<p class="TX">If there’s an issue with the SD card anytime you attempt a save, the display should show the message <samp class="SANS_TheSansMonoCd_W5Regular_11">SD card fail</samp>, as shown in <a href="chapter13.xhtml#fig13-16">Figure 13-16</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE LCD FROM PROJECT #40 DISPLAYING THE “SD CARD FAIL” MESSAGE" class="img7" id="fig13-16" src="../images/fig13-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The LCD indicating a problem with the SD card</samp></p></figcaption>
</figure>
<p class="TX">In this case, your SD card may not be properly formatted, your write-protect switch may be set to ON, or your card may be missing from the module. Once you’ve fixed any problems and removed your SD card, you can view and edit the text file created with your PC by inserting the SD card into the PC.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-40"/>

<pre><code>// Project #40 - Text capture device

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> char _text[100];
int _counter = 0;
int xPosition = 0;
int yPosition = 1;

#include &lt;SD.h&gt;
#include &lt;LiquidCrystal_PCF8574.h&gt;
#include &lt;Wire.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);
#include &lt;PS2Keyboard.h&gt;
PS2Keyboard keyboard;

<span aria-label=" Page 221. " epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/><span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void halt()
{
    do {} while (1);
}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void saveText(boolean _halt)
{
    if (!SD.begin(10))
    {
        lcd.setCursor(1, 1);
        lcd.print("SD card fail");
        halt();
    }
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> File dataFile = SD.open("WRITING.TXT", FILE_WRITE);
    if (dataFile)
    {
        // Save and clear array
        for (int i = 0; i &lt; 100; i++)
        {
            dataFile.print(_text[i]);
            _text[i] = " ";
        }
        dataFile.close();
    }
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (_halt == true)
    {
        File dataFile = SD.open("WRITING.TXT", FILE_WRITE);
        if (dataFile)
        {
            dataFile.println();
            dataFile.println("-------------------------");
            dataFile.close();
        }
        lcd.setCursor(1, 1);
        lcd.print("OK remove card");
        halt();
    }
}

void setup()
{
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> Wire.begin();
    Wire.beginTransmission(0x27);
    lcd.begin(16, 2);
    lcd.setBacklight(255);
    lcd.blink();
    lcd.clear();
    lcd.home();
    lcd.print("Start typing:");
    lcd.setCursor(xPosition, yPosition);
    keyboard.begin(4, 3);
    pinMode(10, OUTPUT);
}

<span aria-label=" Page 222. " epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/>void loop()
{
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> if (keyboard.available())
    {
        char c = keyboard.read();
        if (c == PS2_ENTER)
        {
          <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> _text[_counter] = '\n';
            _counter = _counter + 1;
            xPosition = 0;
            if (yPosition == 0)
            {
                yPosition = 1;
            }
            else if (yPosition == 1)
            {
                yPosition = 0;
            }
            lcd.setCursor(xPosition, yPosition);
      }
        else if (c == PS2_ESC)
        {
            lcd.home();
            lcd.clear();
            saveText(true);
        }
        else
        {
            _text[_counter] = c;
          <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> lcd.print(_text[_counter]);
            _counter = _counter + 1;
            if (_counter &gt;= 99)
            {
              <span aria-label="annotation10" class="CodeAnnotationHang1">❿</span> saveText(false);
                _counter = 0;
            }
            xPosition++;
            if (xPosition &gt; 15)
            {
                xPosition = 0;
                if (yPosition == 0)
                {
                    yPosition = 1;
                }
                else if (yPosition == 1)
                {
                    yPosition = 0;
                }
                lcd.setCursor(xPosition, yPosition);
            }
        }
    }
}
</code></pre>

<p class="TX"><span aria-label=" Page 223. " epub:type="pagebreak" id="pg_223" role="doc-pagebreak"/>This sketch builds on <a href="#LiT-13-3">Listing 13-3</a> to include extra code for writing to the SD card. First, it declares the global variables <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">array_text[]</samp> buffer to hold the user input before writing to the SD card, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_counter</samp> variable used to track the number of characters that are stored in the buffer, and the cursor position on the LCD.</p>
<p class="TX">Next, the sketch includes and initializes the required libraries for the SD card module, LCD, and keyboard. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">halt()</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> is used to stop the sketch operation and is called after the text is saved to the SD card so the user can safely remove the card. It simply loops around forever in the <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> function, as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> is always true.</p>
<p class="TX">The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean _halt)</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> saves data to the SD card, either saving text and returning to user input or saving text and ending operation, as indicated by the Boolean parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, respectively. The function checks whether the SD card is okay to use, stopping and returning an error if there’s an issue, as shown in <a href="chapter13.xhtml#fig13-16">Figure 13-16</a>. If there are no errors, the sketch opens the file whose name is set in this function, to which it will write the data; it creates that file if none exists <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The sketch then writes the text buffer to the SD card and clears the buffer to prepare it for more data.</p>
<p class="TX">If the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> was passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(boolean _halt)</samp> function <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the code opens the file on the SD card, writes a line of dashes to end the text file, and then closes it and indicates this to the user, as shown in <a href="chapter13.xhtml#fig13-15">Figure 13-15</a>. From <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, the usual requirements for activating the I<sup>2</sup>C bus, LCD, and keyboard, as well as setting D10 to an output for the SD card module’s SPI interface, occur.</p>
<p class="TX">Next, the sketch sets up the project’s main operation: capturing text from the keyboard, displaying it on the LCD, and writing it to the SD card. At <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> the sketch is ready to receive a keystroke from the PS/2 keyboard. If the user presses <small>ENTER</small>, the sketch inserts a new line character | in the text array <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, increments the size counter of the array by 1, and moves the cursor along the LCD as required to the alternate line. If the user presses <small>ESC</small>, the sketch clears the LCD, saves the data to the SD card, and stops operation via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(true);</samp>. All other keypresses are inserted into the text array as normal text <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>, which is then displayed on the LCD, while the sketch increments the size counter by 1.</p>
<p class="TX">The sketch then checks the text array size. If it is greater than or equal to 99 characters in size, the text array is written to the text file by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">saveText(false);</samp> <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>, which returns to normal text capture after the write, followed by resetting the counter to 0. Finally, the sketch updates the cursor position, checking if the text runs over the margin and repositioning the cursor if necessary.</p>
<p class="TX">For a final challenge, you might add a real-time clock to Project #40, as well as a data timestamp when the file is closed.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-97"/><span aria-label=" Page 224. " epub:type="pagebreak" id="pg_224" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">Many projects suffer from a poor user interface; as you saw in this chapter, using a PS/2 keyboard simplifies the process of entering data into a project. In this chapter, you learned how to capture data from the keyboard into an Arduino and how to save data entered with the keyboard. I hope this chapter served as inspiration for improving the configuration or operation in your own work.</p>
<p class="TX">In the next chapter, I’ll show you how to harness Bluetooth modules to allow for wireless communication between smartphones and other devices with your Arduino projects.</p>
</section>
</section>
</body>
</html>