- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROCESS
    INJECTION, MANIPULATION, AND HOOKING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">进程注入、篡改和钩子</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To blend in with their target environment, modern evasive threats must remain
    hidden on the infected host. Two methods they use to do so are process injection
    and process image manipulation. *Process injection* involves injecting and executing
    nefarious code inside another process rather than executing it directly, while
    *process image manipulation* involves tampering with process images and abusing
    the way Windows handles processes. Malware can also use process injection techniques
    to inject hooks into a target process. Hooking allows the malware to intercept
    API function calls and monitor or manipulate them, helping it remain undetected.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了融入目标环境，现代的规避性威胁必须在感染的主机上保持隐藏。它们使用的两种方法是进程注入和进程镜像篡改。*进程注入*涉及将恶意代码注入并在另一个进程内执行，而不是直接执行该代码，而*进程镜像篡改*则涉及篡改进程镜像并滥用
    Windows 处理进程的方式。恶意软件还可以利用进程注入技术将钩子注入目标进程。钩子允许恶意软件拦截 API 函数调用并监控或修改它们，帮助它保持隐匿。
- en: We’ll begin this chapter by looking at different forms of process injection.
    Then, we’ll discuss two close cousins of the technique (process image manipulation
    and DLL and shim hijacking) along with various hooking methods. At the end of
    the chapter, we’ll briefly explore how to mitigate these types of attacks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过观察不同形式的进程注入开始本章内容。然后，我们将讨论该技术的两个近亲（进程镜像篡改和 DLL 及 shim 劫持）以及各种钩子方法。在本章末尾，我们将简要探讨如何缓解这些类型的攻击。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Injection</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程注入</samp>
- en: 'There are several reasons why malware might want to implement process injection
    techniques:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能想要实现进程注入技术的原因有很多：
- en: '**Hiding from defenses and investigators**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**躲避防御和调查者**'
- en: Injecting code into another process, particularly a well-known one like *notepad.exe*
    or *explorer.exe*, may help the malware persist on the infected host, hidden from
    endpoint defenses and investigators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码注入到另一个进程中，特别是像 *notepad.exe* 或 *explorer.exe* 这样的知名进程，可能有助于恶意软件在感染的主机上持久存在，且不被终端防御和调查者发现。
- en: '**Mimicking normal behavior**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模仿正常行为**'
- en: Malware might inject code into certain processes to disguise its behavior. For
    example, injecting code into a web browser and communicating with a C2 server
    from this process can help hide suspicious web traffic, as it’s normal and expected
    for web browsers to communicate with the internet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能会将代码注入到某些进程中，以伪装其行为。例如，将代码注入到一个网页浏览器中，并通过该进程与 C2 服务器进行通信，可以帮助隐藏可疑的网络流量，因为网页浏览器与互联网通信是正常且预期的。
- en: '**Thwarting debugging efforts**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻挠调试努力**'
- en: Injecting code into a remote process can help circumvent and evade tools like
    debuggers, causing the analyst to lose control of the malware’s code execution
    flow.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码注入到远程进程中，可以帮助规避和逃避调试工具，使分析师失去对恶意软件代码执行流程的控制。
- en: '**Elevating privileges**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升权限**'
- en: Specific types of process injection techniques can help malware elevate its
    privileges on the infected host, giving it a higher level of access within the
    system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的进程注入技术可以帮助恶意软件提升在感染主机上的权限，从而获得系统内更高级别的访问权限。
- en: '**Intercepting data via hooking**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过钩子拦截数据**'
- en: Injecting hooking code into a process can allow the malware to intercept and
    modify Windows API calls or intercept sensitive data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将钩子代码注入进程可以让恶意软件拦截并修改 Windows API 调用，或者拦截敏感数据。
- en: Let’s examine various process injection techniques in more detail, starting
    with how malware identifies a target process for injection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨各种进程注入技术，从恶意软件如何识别目标进程进行注入开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Random vs. Specific
    Target Processes</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">随机 vs. 特定目标进程</samp>
- en: Malware can inject code into either a random process or a specifically chosen
    target, depending on what it’s trying to achieve. For example, some malware injects
    malicious code into multiple arbitrary processes on the host to ensure its own
    survival. The malware could simply enumerate all processes on the host using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    and then attempt to open and get a handle to the target process using <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>.
    If it successfully opens the target process with its current privilege levels,
    the malware injects its code there. This approach isn’t very stealthy, however.
    A more covert approach is to inject code into specific target processes, such
    as well-known and common Windows processes, or into processes that allow the malware
    to achieve a certain objective. Certain variants of the malware family Formbook,
    for example, inject code into browser-related processes, attempting to sniff out
    sensitive data such as web logins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以将代码注入到一个随机进程中或一个特定选择的目标进程中，这取决于它试图实现的目标。例如，一些恶意软件将恶意代码注入到主机上的多个任意进程中，以确保自身的生存。恶意软件可以简单地使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    枚举主机上的所有进程，然后尝试使用<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    打开并获取目标进程的句柄。如果它成功以当前的权限级别打开目标进程，恶意软件将在其中注入其代码。然而，这种方法并不是非常隐蔽。一个更隐秘的方法是将代码注入到特定的目标进程中，例如一些著名和常见的
    Windows 进程，或者注入到允许恶意软件实现某个特定目标的进程中。例如，恶意软件家族 Formbook 的某些变种将代码注入到与浏览器相关的进程中，试图窃取敏感数据，如网页登录信息。
- en: 'Some malware might even inject code into its own process (a technique known
    as *self-injection*) or into a child process that it creates. These types of injection
    techniques often take place during the *unpacking* process, in which malware decrypts,
    or unpacks, its payload in memory and then injects it into a child process. [Chapter
    17](chapter17.xhtml) will discuss unpacking in more detail. For now, let’s look
    at one of the most basic and prevalent forms of process injection: shellcode injection.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件甚至可能将代码注入到其自身的进程中（这种技术称为*自我注入*），或者注入到它创建的子进程中。这些类型的注入技术通常发生在*解包*过程中，恶意软件在内存中解密或解包其有效负载，然后将其注入到子进程中。[第17章](chapter17.xhtml)将更详细地讨论解包过程。现在，让我们来看看最基本和最常见的进程注入形式之一：shellcode
    注入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode Injection</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode 注入</samp>
- en: '*Shellcode injection*, also known as *direct injection*, is one of the oldest
    injection techniques; as its name suggests, it involves injecting *shellcode*,
    a type of position-independent machine code. Once the shellcode has been injected,
    the malware can remain hidden while executing its malicious code directly from
    within the victim process’s memory. [Figure 12-1](chapter12.xhtml#fig12-1) illustrates
    how it works.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shellcode 注入*，也称为*直接注入*，是最古老的注入技术之一；顾名思义，它涉及将*shellcode*，一种位置无关的机器代码，注入到目标进程中。一旦
    shellcode 被注入，恶意软件就可以在受害者进程的内存中直接执行其恶意代码，同时保持隐蔽。[图12-1](chapter12.xhtml#fig12-1)展示了它的工作原理。'
- en: '![](../images/fig12-1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: The shellcode
    injection technique</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：Shellcode 注入技术</samp>
- en: 'To inject the shellcode, first the malware must open an object handle to the
    target process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (or by directly calling its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> function
    has a couple of important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> parameter represents
    the access rights requested by the calling process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>
    is the ID of the target process. You can reference the function prototype information
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入 shellcode，恶意软件首先必须通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>（或直接调用其本地
    API 等效函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>）打开目标进程的对象句柄。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> 函数有一些重要的参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    参数表示调用进程请求的访问权限，<samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>
    是目标进程的 ID。你可以参考 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    函数的原型信息，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the malware has obtained an object handle to the target process, it calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process for injecting its shellcode. (Alternatively, it could
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function.)
    The most relevant parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function are <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>, which represent the
    starting address and the size of the region of memory being allocated, respectively.
    The prototype information for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件获得了目标进程的对象句柄，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在目标进程中分配内存以注入其 shellcode。（或者，它可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。）<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 函数最相关的参数是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>，分别表示分配的内存区域的起始地址和大小。以下是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 函数的原型信息：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After allocation, the malware writes the malicious code into this fresh memory
    region using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    (or its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>).
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> takes
    some important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>,
    the handle of the process being written into; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>,
    a pointer to the base address where the data will be written; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>,
    a pointer to a memory location that contains the data to be written; and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>, the number of bytes to be
    written into the target process’s memory. Here is the prototype information for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分配内存后，恶意软件使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>（或其本地
    API 等效函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>）将恶意代码写入这一新分配的内存区域。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 接受一些重要参数：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>，表示被写入进程的句柄；<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>，指向将要写入数据的基地址的指针；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>，指向包含要写入数据的内存位置的指针；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>，表示要写入目标进程内存的字节数。以下是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 函数的原型信息：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, after writing the malicious code into its target process, the malware
    is ready to execute it within the process context. To do so, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    (alternatively, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>) to
    create a remote thread within the process context and execute it. The most important
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>, a handle to
    the target process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>,
    the starting address of the code to be executed. The function prototype for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在将恶意代码写入目标进程后，恶意软件准备在进程上下文中执行它。为此，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>（或者，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>）来在进程上下文中创建一个远程线程并执行代码。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 的最重要参数是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>，即目标进程的句柄，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>，即要执行代码的起始地址。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 的函数原型如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that this is only one of the many methods of shellcode injection and execution.
    The flow of this technique and the functions being called (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    and so on) are the basic building blocks of several techniques we’ll touch on
    in this chapter. Keep in mind as well that many of the functions listed in this
    chapter are interchangeable with other functions. For example, instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, malware might
    call the native API <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
    Instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    it could invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是众多Shellcode注入和执行方法中的一种。该技术的流程和被调用的函数（如<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>等）是我们在本章中讨论的几种技术的基本构建块。还需要记住，本章列出的许多函数可以与其他函数互换。例如，恶意软件可能会调用本地API
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>。它也可以调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>，而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>。
- en: To trace process injection, I like to use API Monitor, which allows you to quickly
    see the way the malware is injecting code and even extract the injected code.
    You can also use it to inspect the parameters of each function call in an easy-to-read
    format.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要追踪进程注入，我喜欢使用API Monitor，它可以让你快速查看恶意软件如何注入代码，甚至提取被注入的代码。你还可以使用它以易于阅读的格式检查每个函数调用的参数。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In the next section, I’ll be using a malware executable that you can download
    from VirusTotal or MalShare using the following file hash:*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*在下一节中，我将使用一个恶意软件可执行文件，你可以从VirusTotal或MalShare下载，文件哈希如下：*'
- en: 'SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625'
- en: '[Figure 12-2](chapter12.xhtml#fig12-2) shows the result of loading the malware
    sample in API Monitor and filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    functions.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-2](chapter12.xhtml#fig12-2) 显示了在API Monitor中加载恶意软件样本并过滤 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    函数的结果。'
- en: '![](../images/fig12-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Shellcode injection
    captured in API Monitor</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-2：在API Monitor中捕获的Shellcode注入</samp>
- en: As you can see, this sample begins by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (with the <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp>
    permission and several other access permissions), then makes multiple calls to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process. The malware then writes code into that process using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> and executes
    it by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该样本首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>（具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp> 权限及其他几个访问权限），然后多次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 在目标进程中分配内存。接着，恶意软件通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 将代码写入该进程，并通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 执行它。
- en: If you inspect the buffer for the third call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you can see that the malware is writing what looks like shellcode into the target
    process (see [Figure 12-3](chapter12.xhtml#fig12-3)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查第三次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    的缓冲区，你会看到恶意软件正在将看起来像是 shellcode 的内容写入目标进程（见 [图 12-3](chapter12.xhtml#fig12-3)）。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*It takes some practice, but you can identify shellcode by inspecting the data
    and looking for bytes that represent common assembly instructions such as <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b ec</samp> (which translates
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp, esp</samp>).
    Refer back to [Chapter 3](chapter3.xhtml) for additional assembly instructions.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*这需要一些练习，但你可以通过检查数据并寻找代表常见汇编指令的字节来识别 shellcode，例如 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b
    ec</samp>（它代表 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp,
    esp</samp>）。请回顾 [第 3 章](chapter3.xhtml) 中的其他汇编指令。*'
- en: '![](../images/fig12-3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: Shellcode injected
    into a target process</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3：注入目标进程的 shellcode</samp>
- en: 'To verify that it’s shellcode, save the data (click the Save icon in the upper-left
    corner of the hex buffer window) and then view it in a disassembler. You should
    see the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是 shellcode，保存数据（点击十六进制缓冲区窗口左上角的保存图标），然后在反汇编器中查看。你应该能看到以下内容：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because this data cleanly converts to assembly code, this indeed appears to
    be shellcode. I won’t go into this code in more detail here, but if I were analyzing
    this malware sample, I would try to understand this code’s purpose by investigating
    it further in the disassembler and then investigating it dynamically in a debugger.
    Note that in some circumstances, the disassembler may incorrectly recognize this
    as data instead of code. (Refer back to the “Disassembly” box on [page 51](chapter3.xhtml#pg_51)
    for a refresher on the code vs. data problem.) You might have to “force” the disassembler
    to read it as code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些数据可以干净地转换为汇编代码，所以这确实看起来像是 shellcode。我在这里不会详细讲解这段代码，但如果我要分析这个恶意软件样本，我会通过在反汇编器中进一步调查它，了解这段代码的目的，并在调试器中动态分析它。请注意，在某些情况下，反汇编器可能会错误地将它识别为数据，而不是代码。（参见
    [第 3 章](chapter3.xhtml) 中的“反汇编”框，以复习代码与数据的问题。）你可能需要“强制”反汇编器将其识别为代码。
- en: Before we move on, there’s something else injected into the target process worth
    noting. If you inspect the buffer for the first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you’ll see a reference to *kernel32.dll* (see [Figure 12-4](chapter12.xhtml#fig12-4)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还有一些其他内容被注入到目标进程中，值得注意。如果你检查第一次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    的缓冲区，你会看到一个指向 *kernel32.dll* 的引用（见 [图 12-4](chapter12.xhtml#fig12-4)）。
- en: '![](../images/fig12-4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The string KERNEL32.DLL
    written into memory</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：写入内存的字符串 KERNEL32.DLL</samp>
- en: 'This indicates that the sample could also be using another process injection
    technique, DLL injection, which we’ll take a look at now.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL
    Injection</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该样本可能还使用了另一种进程注入技术——DLL 注入，我们现在来看看这个技术。#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL
    注入</samp>
- en: While DLL injection is another common form of process injection, don’t be misled
    by its name. In this type of attack, the malware doesn’t physically inject a DLL
    into a target process; instead, it writes *the path* to a malicious DLL file located
    on disk into the target process and then forces the target process to load and
    execute that DLL on its behalf. [Figure 12-5](chapter12.xhtml#fig12-5) illustrates
    this technique.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DLL 注入是另一种常见的进程注入形式，但不要被它的名字误导。在这种攻击中，恶意软件并不会将一个 DLL 物理注入到目标进程中；相反，它会将恶意
    DLL 文件的*路径*写入目标进程，然后强制目标进程加载并执行该 DLL。图[12-5](chapter12.xhtml#fig12-5)展示了这种技术。
- en: '![](../images/fig12-5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The DLL injection
    technique</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5：DLL 注入技术</samp>
- en: 'The malware first drops a malicious DLL file to disk. Then, as in shellcode
    injection, it invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to get a handle to its chosen target process and uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    to allocate memory within that process. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the location of that DLL file into the process. Finally, to make the
    victim process load its DLL, the malware gets the procedural address of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and then calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> parameter set to
    that address. Once the remote thread executes, the target process calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and, in doing so, loads
    the malicious DLL. Here’s how this looks in pseudocode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将一个恶意 DLL 文件写入磁盘。然后，像 shellcode 注入一样，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    获取目标进程的句柄，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在该进程中分配内存。接下来，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    将该 DLL 文件的位置写入进程。最后，为了让目标进程加载 DLL，恶意软件获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    的过程地址，然后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>，并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> 参数设置为该地址。一旦远程线程执行，目标进程调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>，从而加载恶意 DLL。以下是伪代码示例：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the malicious DLL path, <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>,
    into the target process, <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>.
    Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    to get the procedural address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    function. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    passing the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    and the path to the malicious DLL as parameters. This forces the victim process
    to load the malicious DLL and execute the code within a new thread.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    将恶意 DLL 路径 <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>
    写入目标进程 <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>。然后，恶意软件调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>，接着调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>，以获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    函数的过程地址。最后，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> 的地址和恶意 DLL 的路径作为参数传入。这强制目标进程加载恶意
    DLL 并在新的线程中执行其中的代码。
- en: One problem with traditional DLL injection for malware authors is that the DLL
    must be loaded from disk, using the standard Windows library loading procedures.
    These standard loading procedures are monitored and easily spotted by endpoint
    defenses. A stealthier approach to DLL injection is reflective DLL injection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用传统的 DLL 注入时会遇到一个问题：DLL 必须通过标准的 Windows 库加载程序从磁盘加载。这些标准加载程序会被端点防御监控到并容易被发现。为了更隐蔽地进行
    DLL 注入，恶意软件使用反射式 DLL 注入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reflective DLL Injection</samp>
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反射式 DLL 注入</samp>
- en: In *reflective* DLL injection, the DLL is stored in memory rather than on disk,
    and the malware loads it without having to rely on the standard Windows loading
    mechanism. This makes reflective DLL injection a more covert alternative to the
    standard DLL injection method just described.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *反射式* DLL 注入中，DLL 被存储在内存中而不是磁盘上，恶意软件在加载 DLL 时不依赖于标准的 Windows 加载机制。这使得反射式 DLL
    注入成为比标准 DLL 注入方法更为隐蔽的替代方案。
- en: The initial steps of reflective DLL injection are fairly similar to the standard
    DLL injection. The malware obtains a handle to its victim process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> and allocates memory
    in that process using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>.
    However, instead of writing only the path to the DLL file, the malware copies
    the entire malicious DLL to the target process’s memory. Then, it transfers control
    flow to the newly injected DLL (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    for example), which executes the injected DLL’s “bootstrap” loader code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 反射式 DLL 注入的初步步骤与标准的 DLL 注入相似。恶意软件使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    获取受害者进程的句柄，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在该进程中分配内存。然而，恶意软件不仅仅写入 DLL 文件的路径，而是将整个恶意 DLL 复制到目标进程的内存中。然后，它将控制流转移到新注入的 DLL（例如，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>），该 DLL
    执行注入 DLL 的“引导”加载程序代码。
- en: 'This bootstrap code is custom code that must re-create the normal Windows DLL
    loading process. At a high level, these are the steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该引导代码是自定义代码，必须重新创建正常的 Windows DLL 加载过程。从高层次看，这些步骤如下：
- en: 1.  The bootstrap code calculates its own image location in memory and performs
    its own image base relocations, which means realigning the hardcoded addresses
    in the executable code to match its current location in memory. The loader also
    finds the location of the injected DLL’s PEB.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  引导代码计算其自身在内存中的镜像位置，并执行自身的镜像基址重定位，这意味着将可执行代码中的硬编码地址重新对齐，以匹配其当前在内存中的位置。加载程序还会找到注入的
    DLL 的 PEB 位置。
- en: 2.  The bootstrap code parses the exports table of *kernel32.dll* to locate
    the addresses of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    and other fundamental functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  引导代码解析 *kernel32.dll* 的导出表，以定位 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    和其他基础函数的地址。
- en: 3.  The malicious DLL has now been successfully loaded inside the victim process
    and is ready to run. To execute the DLL’s malicious code, malware typically invokes
    a function in the DLL’s exports table, such as the function shown in [Figure 12-6](chapter12.xhtml#fig12-6).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  恶意 DLL 现在已成功加载到受害者进程中，并准备运行。为了执行 DLL 的恶意代码，恶意软件通常会调用 DLL 导出表中的某个函数，例如在 [图
    12-6](chapter12.xhtml#fig12-6) 中显示的函数。
- en: '![](../images/fig12-6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The DLL export
    function</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：DLL 导出函数</samp>
- en: The malware shown here was generated with the popular penetration testing tool
    Cobalt Strike and has <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp>
    as the default export function. Once this export function is invoked, the malicious
    code is executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此处显示的恶意软件是使用流行的渗透测试工具 Cobalt Strike 生成的，默认导出函数为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp>。一旦调用此导出函数，恶意代码就会被执行。
- en: '[Figure 12-7](chapter12.xhtml#fig12-7) illustrates a typical reflective DLL
    injection attack.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-7](chapter12.xhtml#fig12-7) 展示了典型的反射式 DLL 注入攻击。'
- en: '![](../images/fig12-7.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The reflective
    DLL injection technique</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-7：反射式 DLL 注入技术</samp>
- en: In this figure, the running malware downloads its DLL payload from a staging
    server controlled by the attacker ❶, which is then temporarily stored in the malware’s
    process memory space ❷. (Note that this technique does not always rely on a remote
    staging server, but we’ll touch on that in a moment.) Next, the bootstrap code
    is injected into a target process along with the DLL ❸, then executed by the malware.
    The bootstrap code performs the manual DLL loading process and then calls the
    export function of the injected DLL, which executes the malicious code in the
    context of the target process ❹. You can read more about reflective DLL injection
    from the original author of the technique at [*https://<wbr>github<wbr>.com<wbr>/stephenfewer<wbr>/ReflectiveDLLInjection*](https://github.com/stephenfewer/ReflectiveDLLInjection).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，正在运行的恶意软件从攻击者控制的暂存服务器下载其DLL负载 ❶，然后暂时存储在恶意软件的进程内存空间中 ❷。（请注意，这种技术并不总是依赖于远程暂存服务器，但稍后我们会讨论这一点。）接下来，启动代码与DLL一起注入目标进程
    ❸，并由恶意软件执行。启动代码执行手动DLL加载过程，然后调用注入DLL的导出函数，在目标进程的上下文中执行恶意代码 ❹。你可以阅读关于反射式DLL注入的更多信息，原作者的资料可以在[*https://<wbr>github<wbr>.com<wbr>/stephenfewer<wbr>/ReflectiveDLLInjection*](https://github.com/stephenfewer/ReflectiveDLLInjection)中找到。
- en: Reflective DLL injection, as with many of the injection methods I discuss throughout
    this chapter, can be subdivided into so-called staged and stageless techniques.
    The technique just presented is considered *staged*, as the payload to be injected
    is hosted and downloaded from the attacker’s staging server. In *stageless* reflective
    DLL injection, the payload is already embedded in the original malware executable
    before being unpacked and injected into the target process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 反射式DLL注入，像本章中我讨论的许多注入方法一样，可以细分为所谓的分阶段（staged）和无阶段（stageless）技术。刚才介绍的技术被认为是*分阶段*的，因为要注入的负载是从攻击者的暂存服务器上托管并下载的。而在*无阶段*的反射式DLL注入中，负载已经嵌入到原始恶意软件可执行文件中，然后解压并注入到目标进程中。
- en: A similar technique, sometimes called *shellcode reflective injection*, involves
    converting a DLL into shellcode and then injecting it into a target process. I
    won’t cover this technique further since it combines techniques you’ve already
    seen, but you can read more about it at [*https://<wbr>github<wbr>.com<wbr>/monoxgas<wbr>/sRDI*](https://github.com/monoxgas/sRDI).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类似的技术，有时被称为*Shellcode反射注入*，涉及将DLL转换为Shellcode，然后将其注入目标进程。我不会进一步介绍这种技术，因为它结合了你已经看到的技术，但你可以在[*https://<wbr>github<wbr>.com<wbr>/monoxgas<wbr>/sRDI*](https://github.com/monoxgas/sRDI)中阅读更多信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Hollowing</samp>
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程空洞技术</samp>
- en: '*Process hollowing* (sometimes called *RunPE*, *process replacement*, or *hollowed
    process injection*) involves unmapping code from a target process’s memory and
    then remapping malicious code there. Process hollowing is a bit different from
    the other injection techniques we’ve seen so far, as it doesn’t usually involve
    an arbitrary remote process. Instead, the malware starts a new process (often
    a trusted executable, such as our beloved *Calculator.exe*), unmaps the legitimate
    code, and remaps malicious code in a suspended state, at which point the malware
    executes the malicious code. This hides the malicious code from the prying eyes
    of endpoint defenses and investigators, disguising it as a normal process. [Figure
    12-8](chapter12.xhtml#fig12-8) illustrates the technique.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程空洞技术*（有时被称为*RunPE*、*进程替换*或*空洞进程注入*）涉及从目标进程的内存中卸载代码，然后将恶意代码重新映射到那里。进程空洞与我们之前看到的其他注入技术有所不同，因为它通常不涉及任意的远程进程。相反，恶意软件启动一个新进程（通常是一个受信任的可执行文件，如我们熟悉的*Calculator.exe*），卸载合法代码，然后在挂起状态下重新映射恶意代码，此时恶意软件执行恶意代码。这种方式将恶意代码隐藏在端点防御和调查者的视线之外，伪装成一个正常的进程。[图12-8](chapter12.xhtml#fig12-8)展示了这一技术。'
- en: '![](../images/fig12-8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The process-hollowing
    technique</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-8：进程空洞技术</samp>
- en: This malware sample begins by creating a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    and then sets the process creation flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>
    (not shown); this starts the new process in a suspended state. Next, the malware
    “hollows out” the newly created process by unmapping its legitimate code with
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>.
    Then, the malware allocates a new region of memory for its malicious code using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and writes (maps)
    its payload here using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>.
    Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> to point
    the current thread to the newly injected code and resume thread execution, respectively,
    which runs the malicious code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本首先通过<ѕamp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>创建了一个新进程，并将进程创建标志设置为<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>（未显示）；这使得新进程在挂起状态下启动。接下来，恶意软件通过使用<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>卸载新创建进程中的合法代码，从而“清空”该进程。然后，恶意软件通过<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>为其恶意代码分配新的内存区域，并使用<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>将其有效载荷写入（映射）到这里。最后，恶意软件调用<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>和<ѕamp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>，分别将当前线程指向新注入的代码，并恢复线程执行，从而运行恶意代码。
- en: 'Let’s take a look at this in practice, using a variant of the ransomware family
    Satan (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: cbbd2bd6f98bd819f3860dea78f812d5c180fd19924cef32e94B
    d7f6929023779</samp>). The screen capture from API Monitor in [Figure 12-9](chapter12.xhtml#fig12-9)
    shows a malware sample (a variant of the Satan ransomware family) using the process-hollowing
    technique.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过实际操作来看看，使用一款变种的勒索软件家族Satan（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    cbbd2bd6f98bd819f3860dea78f812d5c180fd19924cef32e94B d7f6929023779</samp>）。[图12-9](chapter12.xhtml#fig12-9)中的API
    Monitor屏幕截图展示了一个恶意软件样本（Satan勒索软件家族的一个变种），它使用了进程劫持技术。'
- en: '![](../images/fig12-9.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: A malware sample
    using the process-hollowing technique</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-9：使用进程劫持技术的恶意软件样本</samp>
- en: Notice how this malware starts a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>
    from an executable on disk (*financialz.exe*) in a suspended state (<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>),
    as just discussed. Then, it makes multiple calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>
    to map data into the new target process. Inspecting this function call further
    in API Monitor reveals that this malware sample is writing a PE file into the
    target process, then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>
    to execute it (see [Figure 12-10](chapter12.xhtml#fig12-10)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如之前讨论的，这个恶意软件是如何通过从磁盘上的可执行文件（*financialz.exe*）以挂起状态（<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>）启动一个新进程，使用<ѕamp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>的。然后，它多次调用<ѕamp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>来将数据映射到新的目标进程中。在API
    Monitor中进一步检查这个函数调用，显示该恶意软件样本将PE文件写入目标进程，然后调用<ѕamp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>来执行该文件（见[图12-10](chapter12.xhtml#fig12-10)）。
- en: '![](../images/fig12-10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: The PE header
    in memory</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-10：内存中的PE头部</samp>
- en: Note that while process hollowing is typically classified as a process injection
    technique, it’s not a true injection technique, since it relies on the malware
    spawning a new process in a suspended state and then replacing the process’s preexisting
    code with malicious code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管进程劫持通常被归类为一种进程注入技术，但它并不是真正的注入技术，因为它依赖于恶意软件在挂起状态下生成新进程，然后用恶意代码替换进程原有的代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Hijacking</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">线程劫持</samp>
- en: '*Thread hijacking* involves opening a running thread in a victim process, writing
    malicious code into that thread, and forcing the victim process to execute the
    code. Thread hijacking shares many of the functions used in the process-hollowing
    technique, but there are a few notable differences. To execute thread hijacking,
    the malware invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>
    function, specifying a thread ID as a parameter, and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp> for
    64-bit processes) to suspend the victim thread. Once the thread is in a suspended
    state, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, respectively,
    to allocate memory in the target process and write its malicious code there. Finally,
    the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    to transfer control flow from the currently suspended thread to the newly injected
    malicious code, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>
    to execute the code.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程劫持*涉及在受害者进程中打开一个正在运行的线程，将恶意代码写入该线程，并强制受害者进程执行该代码。线程劫持与进程空洞技术使用的许多功能相同，但也有一些显著的区别。为了执行线程劫持，恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>函数，指定线程ID作为参数，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp>（对于64位进程，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp>）来挂起受害线程。一旦线程处于挂起状态，恶意软件使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>分别分配目标进程中的内存并将恶意代码写入其中。最后，恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>将控制流从当前挂起的线程转移到新注入的恶意代码，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>执行该代码。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC Injection</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC注入</samp>
- en: An *asynchronous procedure call (APC)* is a Windows feature that allows for
    various tasks to be queued and executed in the context of a running thread. A
    program might invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    function, passing both the handle to the thread and a pointer to the code that
    the program wishes to run, to add that task to the APC queue. *APC injection*
    abuses this functionality to stealthily execute code and, potentially, elevate
    privileges.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步过程调用（APC）*是Windows的一项功能，允许将各种任务排队并在运行线程的上下文中执行。程序可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>函数，传递线程的句柄和程序希望执行的代码的指针，将该任务添加到APC队列中。*APC注入*滥用此功能，悄悄执行代码，并可能提升权限。'
- en: For a program to be able to call functions in the APC queue, the thread must
    be in an *alertable* state, meaning the thread periodically checks for new items
    in the queue and runs the next queued task. Many processes running on the system,
    from web browsers to video players, have threads running in alertable states.
    Generally, such threads eventually receive an interrupt request from the operating
    system, at which point the process will inspect the APC queue and run the next
    queued task.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序能够调用APC队列中的函数，线程必须处于*可警觉*状态，这意味着线程会定期检查队列中的新项并执行下一个排队的任务。许多系统上运行的进程，从Web浏览器到视频播放器，都有在可警觉状态下运行的线程。通常，此类线程最终会收到操作系统的中断请求，此时进程会检查APC队列并运行下一个排队的任务。
- en: Malware takes advantage of APC functionality by attempting to inject malicious
    code into other processes via APC queuing. [Figure 12-11](chapter12.xhtml#fig12-11)
    illustrates this attack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过尝试通过APC排队将恶意代码注入到其他进程中，利用了APC功能。[图12-11](chapter12.xhtml#fig12-11)展示了这种攻击。
- en: '![](../images/fig12-11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: The APC injection
    technique</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-11：APC注入技术</samp>
- en: This malware first gets a handle to its target victim process in the usual way
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>) and writes
    the malicious code to be executed into the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>).
    Next, it opens a target thread by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) to
    queue a new APC task. Whenever the thread receives an interrupt request from the
    operating system, this malicious code will be executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件首先以常规方式获取目标受害进程的句柄（<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>），并将要执行的恶意代码写入该进程（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>）。接下来，它通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp> 打开目标线程，然后调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>（或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>）来排队一个新的
    APC 任务。每当线程接收到来自操作系统的中断请求时，这段恶意代码就会被执行。
- en: A variation of this technique creates a new process in a suspended state (similar
    to process hollowing) and writes the malicious code into it. Then, the malware
    queues its APC function and resumes the thread. Once the thread resumes, the malicious
    code will be executed. At this point, the malware can terminate its original process,
    as its payload is now running under a new process and may go unnoticed by endpoint
    defenses and unaware end users. [Figure 12-12](chapter12.xhtml#fig12-12) shows
    this attack, captured in API Monitor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的变种会在挂起状态下创建一个新进程（类似于进程空洞技术），并将恶意代码写入该进程。然后，恶意软件排队其 APC 函数并恢复该线程。一旦线程恢复，恶意代码就会执行。此时，恶意软件可以终止其原始进程，因为其有效载荷现在已在新进程下运行，并且可能不会被端点防护或不知情的终端用户察觉。[图
    12-12](chapter12.xhtml#fig12-12)展示了这一攻击，捕获自 API Monitor。
- en: '![](../images/fig12-12.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Malware using
    a variation of the APC injection technique</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-12：使用 APC 注入技术变种的恶意软件</samp>
- en: This malware sample uses APC injection to run malicious code in the context
    of the *iexplore.exe* process. In this case, the malware starts *iexplore.exe*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>) instead
    of hijacking another process (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件样本使用 APC 注入技术，在*iexplore.exe*进程的上下文中运行恶意代码。在这种情况下，恶意软件启动了*iexplore.exe*（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>），而不是劫持另一个进程（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>）。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Atom Bombing</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">原子炸弹</samp>'
- en: The last process injection technique we’ll cover in this chapter is *atom bombing*,
    which shares some features of APC injection but involves *atoms*, references to
    specific pieces of data such as strings. Atoms are stored in an OS structure known
    as the *atom table*, and each atom has a unique atom identifier. Atoms are often
    used in interprocess communication to coordinate actions between processes. For
    example, Process A might create an atom to indicate that a particular piece of
    data is available, and Process B can use that atom to access the data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍的最后一种进程注入技术是*原子炸弹*，它与 APC 注入有一些相似之处，但涉及到*原子*，即指向特定数据片段（如字符串）的引用。原子存储在操作系统中一个名为*原子表*的结构中，每个原子都有一个唯一的原子标识符。原子通常用于进程间通信，用以协调进程之间的操作。例如，进程
    A 可能会创建一个原子，表示某个特定的数据可用，进程 B 可以使用该原子来访问这些数据。
- en: Atom tables can be global (that is, accessible from any process running on the
    system) or local (accessible to only one specific process). To add data to the
    global atom table, an application invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>
    function; to add an atom to a local table, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddAtom</samp>
    function. Atom bombing abuses these atom tables to temporarily store malicious
    code. [Figure 12-13](chapter12.xhtml#fig12-13) illustrates this attack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 原子表可以是全局的（即系统中任何正在运行的进程都可以访问）或本地的（仅对特定进程可访问）。要将数据添加到全局原子表，应用程序会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>
    函数；要将原子添加到本地表中，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddAtom</samp>
    函数。原子炸弹利用这些原子表暂时存储恶意代码。[图 12-13](chapter12.xhtml#fig12-13)展示了这一攻击。
- en: '![](../images/fig12-13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: The atom bombing
    technique</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-13: 原子轰炸技术</samp>'
- en: At a high level, this technique creates a new global atom (<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>)
    in the global atom table, where it stores malicious shellcode ❶ and uses APC queuing
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) ❷ to force
    the victim process into executing <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp>
    ❸. Once the atom is retrieved by the victim process, the shellcode stored in the
    atom table can be run in that process’s context ❹.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这种技术在全局原子表中创建了一个新的全局原子（<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>），在其中存储恶意
    shellcode ❶，并使用 APC 排队（<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>）
    ❷ 强制受害者进程执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp>
    ❸。一旦受害者进程检索到该原子，存储在原子表中的 shellcode 就可以在该进程的上下文中运行 ❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection
    Wrap-up</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程注入总结</samp>
- en: As you’ve seen, many process injection techniques use the same API function
    calls and behave similarly. Nearly all process injection techniques create a process
    or open a handle to a target process, allocate memory and write or map code into
    the target process, and then force the injected code to execute in the context
    of the target process, as summarized in [Figure 12-14](chapter12.xhtml#fig12-14).
    (Special thanks to malware researcher Karsten Hahn, who inspired this image.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，许多进程注入技术使用相同的 API 函数调用，并且表现类似。几乎所有的进程注入技术都会创建一个进程或打开一个目标进程的句柄，分配内存并将代码写入或映射到目标进程中，然后强制注入的代码在目标进程的上下文中执行，正如
    [图 12-14](chapter12.xhtml#fig12-14) 中总结的那样。（特别感谢恶意软件研究员 Karsten Hahn，他为此图提供了灵感。）
- en: '![](../images/fig12-14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-14.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: A summary of
    process injection behaviors and API calls</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-14: 进程注入行为和 API 调用总结</samp>'
- en: 'Now that we’ve looked at various process injection techniques, let’s pivot
    to another method used for similar purposes: process image manipulation.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种进程注入技术，让我们转向另一种用于类似目的的方法：进程映像篡改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Image Manipulation</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程映像篡改</samp>
- en: '*Process image manipulation* abuses both the standard Windows process creation
    routine and the way endpoint defenses (specifically, anti-malware software) operate.
    To defend a system from malware attacks, anti-malware software needs to know when
    a new process is started in order to monitor it for suspect behaviors. This is
    where the API function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    comes in. When a new process is created, this function sends notification messages
    to endpoint defense software, which then inspects and scans the originating executable
    file that started the process. If the anti-malware software sees that the executable
    file contains malicious code, it can quarantine the file and terminate any associated
    processes. The problem is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    is invoked not at the exact moment of a process’s creation, but rather on the
    creation and execution of the first few threads running within the process context.
    This gives malware a nice window of opportunity to modify the original executable
    file before anti-malware solutions have time to scan it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程映像篡改* 滥用标准的 Windows 进程创建例程和端点防御（特别是反恶意软件软件）运作方式。为了防御恶意软件攻击，反恶意软件软件需要知道何时启动新进程，以便监视其可疑行为。这时
    API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    就派上了用场。当新进程被创建时，该函数会向端点防御软件发送通知消息，防御软件随后会检查并扫描启动该进程的原始可执行文件。如果反恶意软件软件发现可执行文件包含恶意代码，它可以将文件隔离并终止任何相关的进程。问题是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    不是在进程创建的确切时刻被调用，而是在进程上下文中运行的前几个线程被创建并执行时调用。这给了恶意软件一个机会，可以在反恶意软件解决方案扫描文件之前修改原始可执行文件。'
- en: 'Process manipulation also involves interfering with the way Windows creates
    processes (as described in [Chapter 1](chapter1.xhtml)). In essence, Windows usually
    calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>,
    a kernel function that handles the details of process creation and then maps processes
    into memory by executing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进程操作还涉及干扰 Windows 创建进程的方式（如[第 1 章](chapter1.xhtml)所述）。本质上，Windows 通常会调用一个函数，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>，这是一个内核函数，负责处理进程创建的细节，然后通过执行以下步骤将进程映射到内存中：
- en: 1.  Obtain a handle to an executable file (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>,
    for example).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  获取可执行文件的句柄（例如，通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>）。
- en: 2.  Create a section object for the file, typically by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    function. In this case, a *section* is simply an object that will be mapped into
    memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  为文件创建一个节对象，通常通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>函数。在这种情况下，*节*只是一个将被映射到内存中的对象。
- en: 3.  Create a process object by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    with a parameter referencing the newly created section object, mapping the process
    object into memory as a new process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>并传递一个引用新创建的节对象的参数，创建一个进程对象，将进程对象映射到内存中作为一个新进程。
- en: 4.  Execute the process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    to create and start a new thread.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>来执行该进程，创建并启动一个新线程。
- en: Let’s take a look at how different process manipulation techniques are used
    to interfere with these steps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用不同的进程操作技术来干扰这些步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Herpaderping</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程混淆</samp>
- en: '*Process herpaderping* has a funny name but packs a powerful punch. It confuses
    the operating system and anti-malware solutions by interfering with the way Windows
    creates processes. [Figure 12-15](chapter12.xhtml#fig12-15) illustrates how this
    technique works.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程混淆*这个名字听起来有趣，但它威力十足。通过干扰 Windows 创建进程的方式，它使操作系统和反恶意软件解决方案感到困惑。[图 12-15](chapter12.xhtml#fig12-15)展示了该技术是如何工作的。'
- en: '![](../images/fig12-15.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-15.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: The process-herpaderping
    technique</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-15：进程混淆技术</samp>
- en: This malware first creates a new file on disk and obtains a handle to it, keeping
    that handle open ❶. It writes malicious executable code into this empty file,
    then creates a section object for the file ❷. Next, it creates a process using
    the new section object ❸. The malicious code is now mapped into memory, but it
    isn’t executing yet. So far, this approach follows the standard Windows PE loading
    steps, but things are about to get interesting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件首先在磁盘上创建一个新文件并获取其句柄，保持该句柄打开 ❶。它将恶意可执行代码写入此空文件，然后为该文件创建一个节对象 ❷。接下来，它使用这个新创建的节对象来创建一个进程
    ❸。恶意代码现在已经映射到内存中，但还没有执行。到目前为止，这个方法遵循标准的 Windows PE 加载步骤，但接下来会变得有趣。
- en: The malware modifies or removes the malicious code within the file it created
    on disk ❹. It then starts a new thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>),
    which executes the malicious code in memory, and closes the handle to the open
    file. At this point, the aforementioned <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    callback will occur and endpoint defenses will kick in, inspecting the malicious
    file. However, since the malicious file in fact no longer contains malicious code,
    the anti-malware software is tricked into thinking all is well. Anti-malware software,
    as well as Windows itself, assumes that a file on disk can’t (or shouldn’t) be
    modified when it’s already mapped into memory and running inside a process. Process
    herpaderping takes advantage of such assumptions to execute malicious code. You
    can find out more about this technique from its author at [*https://<wbr>jxy<wbr>-s<wbr>.github<wbr>.io<wbr>/herpaderping<wbr>/*](https://jxy-s.github.io/herpaderping/).
    If you’d like to test it yourself, you can explore the proof of concept at [*https://<wbr>github<wbr>.com<wbr>/jxy<wbr>-s<wbr>/herpaderping*](https://github.com/jxy-s/herpaderping).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件修改或移除它在磁盘上创建的文件中的恶意代码❹。然后，它启动一个新线程（<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>），在内存中执行恶意代码，并关闭打开文件的句柄。此时，上述的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>回调会触发，端点防御机制将启动，检查恶意文件。然而，由于恶意文件实际上已经不再包含恶意代码，反恶意软件程序被欺骗，认为一切正常。反恶意软件程序以及Windows本身假设，当文件已经映射到内存并在进程中运行时，它不能（或不应）在磁盘上被修改。进程的herpaderping利用了这种假设来执行恶意代码。你可以通过其作者了解更多关于此技术的信息，访问[*https://<wbr>jxy<wbr>-s<wbr>.github<wbr>.io<wbr>/herpaderping<wbr>/*](https://jxy-s.github.io/herpaderping/)。如果你想亲自测试，你可以在[*https://<wbr>github<wbr>.com<wbr>/jxy<wbr>-s<wbr>/herpaderping*](https://github.com/jxy-s/herpaderping)上查看概念验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Doppelganging</samp>
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程双胞胎技术</samp>
- en: '*Process doppelganging*, first presented at Black Hat 2017 by security researchers
    Eugene Kogan and Tal Liberman, is a manipulation technique that uses Transactional
    NTFS to hide malicious code execution. The term *doppelganging* originates from
    the word *doppelganger*, which is commonly used to describe a person with an uncanny
    resemblance to someone else. *Transactional NTFS* was designed to add extra features
    and support (like file integrity preservation and better error handling) to NTFS,
    the default filesystem in Windows. It allows the use of *transactions*, which
    track changes to the filesystem that can be rolled back when necessary. Actions
    like file deletion first occur virtually. If the file deletion request succeeds,
    the transaction is committed and the file is actually deleted. If the file deletion
    request results in an error, however, the transaction is rolled back and no action
    occurs. Ultimately, transactions seek to prevent data inconsistency and corruption
    resulting from a system failure or other unexpected event.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程双胞胎技术*，由安全研究员尤金·科根（Eugene Kogan）和塔尔·利伯曼（Tal Liberman）在2017年Black Hat大会上首次提出，是一种利用事务性NTFS隐藏恶意代码执行的操作技术。术语*doppelganging*来源于*双胞胎*（doppelganger）一词，通常用来形容与他人有惊人相似的人。*事务性NTFS*是为了增强NTFS（Windows默认文件系统）的功能和支持（如文件完整性保护和更好的错误处理）而设计的。它允许使用*事务*，即跟踪对文件系统的更改，并在必要时回滚这些更改。诸如文件删除等操作首先是在虚拟状态下发生的。如果文件删除请求成功，事务就会提交，文件会被实际删除；然而，如果文件删除请求出现错误，事务会回滚，文件不会被删除。最终，事务旨在防止因系统故障或其他意外事件导致的数据不一致和损坏。'
- en: A new file created with transactions normally can’t be accessed from outside
    the process currently interacting with it; even certain anti-malware solutions
    can’t access it in this case. For this reason, transactions can provide a safe
    location for a malicious file to temporarily hide. And since transacted files
    can be “rolled back” to a previous state, endpoint defenses can easily become
    confused. This is exactly why process doppelganging is effective. [Figure 12-16](chapter12.xhtml#fig12-16)
    illustrates how this technique works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事务创建的新文件通常无法从当前与其交互的进程之外访问；即便某些反恶意软件解决方案在这种情况下也无法访问该文件。因此，事务可以为恶意文件提供一个临时隐藏的安全位置。而且，由于事务文件可以“回滚”到之前的状态，端点防御机制很容易被混淆。这正是进程双胞胎技术有效的原因。[图12-16](chapter12.xhtml#fig12-16)展示了这种技术的工作原理。
- en: '![](../images/fig12-16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-16.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: The process-doppelganging
    technique</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-16：进程伪冒技术</samp>
- en: This malware creates a new NTFS transaction using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateTransaction</samp>
    and opens an existing executable file using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFileTransacted</samp>
    ❶. (It could instead call lower-level functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateTransaction</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetCurrentTransaction</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateFile</samp> to achieve
    the same effect.) Next, the malware writes its malicious code into the existing
    PE file (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>), which
    will replace the original executable’s code ❷. The malware then executes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    to create a new process, passing the location of the new malicious PE file (the
    doppelganger) as a parameter ❸. Once the PE file is mapped into memory and the
    malicious process is running, the malware deliberately rolls back the original
    NTFS transaction (<samp class="SANS_TheSansMonoCd_W5Regular_11">RollbackTransaction</samp>),
    returning the file to its original, preinfected state ❹. When the anti-malware
    software is notified of the process creation and scans the process’s executable
    file on disk, it’s too late; the original executable file has already been rolled
    back to its nonmalicious state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件使用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateTransaction</samp>创建一个新的
    NTFS 事务，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFileTransacted</samp>打开一个现有的可执行文件❶。（它也可以调用更底层的函数，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateTransaction</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetCurrentTransaction</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateFile</samp>来实现相同的效果。）接下来，恶意软件将其恶意代码写入现有的
    PE 文件（<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>），这将替换原始可执行文件的代码❷。然后，恶意软件执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>来创建一个新进程，将新恶意
    PE 文件（伪冒文件）的路径作为参数传递❸。一旦 PE 文件被映射到内存中并且恶意进程正在运行，恶意软件故意回滚原始的 NTFS 事务（<samp class="SANS_TheSansMonoCd_W5Regular_11">RollbackTransaction</samp>），将文件恢复到其原始的、未感染的状态❹。当反恶意软件程序被通知到进程创建并扫描磁盘上的进程可执行文件时，已经太迟；原始的可执行文件已经被回滚到其未受感染的状态。
- en: A few variations of the process-doppelganging technique have emerged since it
    was first published in 2017\. One variant, dubbed *transacted hollowing* by researchers
    at Malwarebytes, combines process hollowing with process doppelganging (see the
    blog post “Process Doppelgänging Meets Process Hollowing in Osiris Dropper” at
    [*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2018<wbr>/08<wbr>/process<wbr>-doppelganging<wbr>-meets<wbr>-process<wbr>-hollowing<wbr>_osiris*](https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris)).
    As with doppelganging, the malware creates a new process for the injected payload.
    However, instead of directly injecting the payload, it creates the process in
    a suspended state and maps the malicious code into memory, as in process hollowing.
    This is a good example of how security research is often used later by malware
    authors as a jumping-off point for new techniques.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2017 年首次发布以来，进程伪冒技术出现了一些变种。一种变种被 Malwarebytes 的研究人员称为*事务性空洞注入*，它将进程空洞注入与进程伪冒结合起来（详见博客文章“进程伪冒与进程空洞注入在
    Osiris 投放器中的结合”[*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2018<wbr>/08<wbr>/process<wbr>-doppelganging<wbr>-meets<wbr>-process<wbr>-hollowing<wbr>_osiris*](https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris)）。与伪冒相似，恶意软件为注入的有效载荷创建一个新进程。然而，它不是直接注入载荷，而是将进程创建为挂起状态，并将恶意代码映射到内存中，就像在进程空洞注入中一样。这是安全研究如何被恶意软件作者作为新技术的起点的一个很好的例子。
- en: 'As you’ve seen, process image manipulation techniques rely on the exploitation
    of fundamental Windows behaviors, and they’re unlikely to go away anytime soon.
    It’s important for analysts to keep current on what’s cropping up in the wild.
    To close out this section, we’ll look at two newer process manipulation techniques.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Reimaging and
    Ghosting</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，进程图像操作技术依赖于利用Windows的基本行为，而且这些技术在短期内不太可能消失。对于分析人员来说，保持对新兴技术的关注非常重要。在本节的结尾，我们将介绍两种较新的进程操作技术。  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程重映像与幽灵化</samp>'
- en: '*Process reimaging* is similar to the previously described techniques in that
    it relies on manipulating a currently running process to circumvent security controls.
    To execute process reimaging, the malware modifies its <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    attribute, which contains the filepath of the malware’s executable on disk, to
    point instead to a benign, legitimate executable. This technique relies on the
    fact that there are inconsistencies in the way Windows handles <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE
    _OBJECT</samp>, and as a result, some anti-malware products put too much trust
    in what’s stored in a malicious process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    location. More information on this technique can be found in the blog post “In
    NTDLL I Trust” from McAfee ([*https://<wbr>www<wbr>.mcafee<wbr>.com<wbr>/blogs<wbr>/other<wbr>-blogs<wbr>/mcafee<wbr>-labs<wbr>/in<wbr>-ntdll<wbr>-i<wbr>-trust<wbr>-process<wbr>-reimaging<wbr>-and<wbr>-endpoint<wbr>-security<wbr>-solution<wbr>-bypass<wbr>/*](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/in-ntdll-i-trust-process-reimaging-and-endpoint-security-solution-bypass/))
    and on GitHub ([*https://<wbr>github<wbr>.com<wbr>/djhohnstein<wbr>/ProcessReimaging*](https://github.com/djhohnstein/ProcessReimaging)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程重映像*类似于之前描述的技术，因为它依赖于操控当前运行的进程来绕过安全控制。为了执行进程重映像，恶意软件修改其 <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    属性，该属性包含恶意软件在磁盘上的可执行文件路径，改为指向一个无害的合法可执行文件。此技术依赖于Windows处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    的方式存在不一致性，结果是一些反恶意软件产品过于信任恶意进程的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    位置中存储的信息。更多关于该技术的信息可以在McAfee的博客文章《In NTDLL I Trust》中找到（[*https://<wbr>www<wbr>.mcafee<wbr>.com<wbr>/blogs<wbr>/other<wbr>-blogs<wbr>/mcafee<wbr>-labs<wbr>/in<wbr>-ntdll<wbr>-i<wbr>-trust<wbr>-process<wbr>-reimaging<wbr>-and<wbr>-endpoint<wbr>-security<wbr>-solution<wbr>-bypass<wbr>/*](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/in-ntdll-i-trust-process-reimaging-and-endpoint-security-solution-bypass/))
    以及GitHub上的内容（[*https://<wbr>github<wbr>.com<wbr>/djhohnstein<wbr>/ProcessReimaging*](https://github.com/djhohnstein/ProcessReimaging)）。'
- en: '*Process ghosting* is most similar to process herpaderping. The malware creates
    a file and requests that Windows puts the file into a pending deletion state.
    Since there can be a delay between when the file is put into this state and when
    it’s actually deleted, the malware can write malicious executable code into the
    file and create an image object for it (copying the file content into memory)
    before Windows deletes it. Finally, the malware creates a process with the image
    object of the now-deleted file and executes it. Since Windows prevents endpoint
    defenses like anti-malware from reading and inspecting the file while it’s in
    a pending deletion state, these defenses are effectively blinded to the malicious
    code in the file. You can read more about this technique in the blog post “What
    You Need to Know About Process Ghosting” at [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/process<wbr>-ghosting<wbr>-a<wbr>-new<wbr>-executable<wbr>-image<wbr>-tampering<wbr>-attack*](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程幽灵化*与进程“伪装”最为相似。恶意软件创建一个文件并请求Windows将该文件置于待删除状态。由于文件进入此状态和实际删除之间可能会有延迟，恶意软件可以在文件中写入恶意可执行代码，并在Windows删除文件之前为其创建图像对象（将文件内容复制到内存中）。最后，恶意软件使用现在已删除文件的图像对象创建一个进程并执行它。由于Windows在文件处于待删除状态时防止终端防御软件（如反恶意软件）读取和检查该文件，这些防御机制实际上无法察觉文件中的恶意代码。你可以在博客文章《你需要了解的进程幽灵化》中阅读更多关于此技术的内容，网址为
    [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/process<wbr>-ghosting<wbr>-a<wbr>-new<wbr>-executable<wbr>-image<wbr>-tampering<wbr>-attack*](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack)。'
- en: Now we’ll turn to another pair of methods for injecting and covertly executing
    code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向另一对注入和隐蔽执行代码的方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">DLL and Shim Hijacking</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">DLL 和 Shim 劫持</samp>
- en: '*Hijacking* is a general term for techniques that involve interfering with
    the normal execution flow of a program or manipulating the way Windows runs programs,
    in order to execute unauthorized code. Specifically, *DLL hijacking* exploits
    the way legitimate executables load their required libraries, in order to inject
    a malicious DLL. *Shim hijacking* involves using Windows application *shims*,
    or small libraries that intercept API calls, to inject code into an executing
    process. Let’s dig a little deeper into each technique.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*劫持* 是指通过干扰程序的正常执行流程或操控 Windows 运行程序的方式，以执行未授权的代码。具体而言，*DLL 劫持* 利用合法可执行文件加载其所需库的方式来注入恶意
    DLL。*Shim 劫持* 则涉及使用 Windows 应用程序的 *Shim*（即拦截 API 调用的小型库）来将代码注入到执行中的进程中。让我们深入了解一下每种技术。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL Hijacking</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL 劫持</samp>
- en: All Windows applications must load DLL files at some point to function. Most
    applications have some sort of manifest that lists all the required DLLs and where
    they reside on disk. This manifest is part of the application’s DLL *search order.*
    Other possible search order locations include the application’s default install
    directory (such as *C:\Program Files\CoolApplication*), where its primary executable
    file is located, and Windows directories that house the standard Windows DLLs
    (such as *%SystemRoot%\system32*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Windows 应用程序在某个时刻必须加载 DLL 文件才能正常运行。大多数应用程序都有某种清单，列出了所有需要的 DLL 文件及其在磁盘上的位置。这个清单是应用程序
    DLL *搜索顺序*的一部分。其他可能的搜索顺序位置包括应用程序的默认安装目录（例如 *C:\Program Files\CoolApplication*），该目录包含其主可执行文件，以及存放标准
    Windows DLL 文件的 Windows 目录（例如 *%SystemRoot%\system32*）。
- en: 'This setup leaves open an interesting attack vector. Many poorly written applications
    don’t verify the contents or signature of the DLLs they’re loading; instead, they
    blindly load the required files based on their search order. Worse still, some
    poorly written applications simply load all DLLs in their install or running directory
    haphazardly. If a threat actor knows that a particular application is vulnerable
    to DLL hijacking, it could craft a specialized piece of malware that drops its
    payload in the form of a DLL to the directory from which the application is loading
    its DLLs. The actor can then simply wait for the application to start and autoload
    the DLL into memory, or it can execute the application directly and force the
    malicious DLL to load. Lastly, some malware will directly modify an application’s
    DLL search order or manifest to force a malicious DLL to load. There are several
    variations of this attack (DLL search order hijacking, sideloading, preloading,
    remote preloading, and so on), but they all have the same effect: deviously and
    silently loading a malicious DLL into the vulnerable application’s process memory
    space and executing unauthorized code.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置留下了一个有趣的攻击向量。许多编写不良的应用程序没有验证它们加载的 DLL 文件的内容或签名；相反，它们会根据搜索顺序盲目加载所需的文件。更糟糕的是，一些编写不良的应用程序干脆会在其安装或运行目录中随意加载所有
    DLL 文件。如果攻击者知道某个特定应用程序易受 DLL 劫持攻击，它可以制作一个特制的恶意软件，将其有效载荷以 DLL 文件的形式放入应用程序加载 DLL
    文件的目录中。攻击者随后可以等待应用程序启动并自动加载该 DLL 到内存中，或者直接执行该应用程序并强制加载恶意 DLL。最后，一些恶意软件会直接修改应用程序的
    DLL 搜索顺序或清单，强制加载恶意 DLL。这种攻击有几种变体（如 DLL 搜索顺序劫持、旁加载、预加载、远程预加载等），但它们的效果相同：巧妙且默默地将恶意
    DLL 加载到易受攻击的应用程序进程内存空间中并执行未授权的代码。
- en: An example of this attack comes from the Qbot malware family. One Qbot variant
    was delivered to a victim with a few files, most notably a malicious DLL file
    (*WindowsCodecs.dll*), a copy of an older but legitimate version of Windows Calculator
    (*calc.exe*), and a DLL called *7533.dll*. The *calc.exe* file had a curious import
    in its IAT, highlighted in [Figure 12-17](chapter12.xhtml#fig12-17).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的一个例子来自 Qbot 恶意软件家族。一个 Qbot 变种通过几个文件传送给受害者，其中最引人注目的是一个恶意的 DLL 文件 (*WindowsCodecs.dll*)、一个较旧但合法的
    Windows 计算器版本副本 (*calc.exe*) 和一个名为 *7533.dll* 的 DLL 文件。*calc.exe* 文件在其 IAT 中有一个有趣的导入，如
    [图 12-17](chapter12.xhtml#fig12-17) 所示。
- en: '![](../images/fig12-17.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-17.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-17: A curious import
    in the</samp> <samp class="SANS_Futura_Std_Book_11">calc.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    delivered from a Qbot variant</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-17：一个有趣的导入，来自一个Qbot变种的</samp>
    <samp class="SANS_Futura_Std_Book_11">calc.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: Upon execution, starting with its present location, this *calc.exe* application
    searches for *WindowsCodecs.dll*, the real version of which is a legitimate, benign
    Windows helper application. Since the malware author “helpfully” included *WindowsCodecs.dll*
    alongside the *calc.exe* file, the malicious version of the DLL is injected into
    *calc.exe* and its code is executed. [Figure 12-18](chapter12.xhtml#fig12-18)
    illustrates this attack in Procmon.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，从当前位置开始，这个*calc.exe*应用程序会搜索*WindowsCodecs.dll*，其真实版本是一个合法的、无害的Windows辅助应用程序。由于恶意软件作者“贴心地”将*WindowsCodecs.dll*与*calc.exe*文件一起提供，恶意版本的DLL就被注入到*calc.exe*中并执行。[图
    12-18](chapter12.xhtml#fig12-18)展示了Procmon中的这一攻击。
- en: '![](../images/fig12-18.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-18.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-18: The malicious</samp>
    <samp class="SANS_Futura_Std_Book_11">WindowsCodecs.dll</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    being sideloaded</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-18：恶意的</samp> <samp class="SANS_Futura_Std_Book_11">WindowsCodecs.dll</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件被旁加载</samp>
- en: This Procmon timeline export illustrates the victim executing the vulnerable
    *calc.exe* file (Process Start), which then loads the malicious *WindowsCodecs.dll*
    file (Load Image), which in turn executes another payload (*regsvr32.exe 7533.dll)*.
    The malware author knows that this particular older version of *calc.exe* is vulnerable
    to DLL hijacking because it blindly loads and executes any DLL named *WindowsCodecs.dll*
    in its running location. Very crafty indeed!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Procmon时间线导出展示了受害者执行易受攻击的*calc.exe*文件（进程启动），接着加载恶意的*WindowsCodecs.dll*文件（加载映像），然后执行另一个有效载荷（*regsvr32.exe
    7533.dll*）。恶意软件作者知道这个特定版本的*calc.exe*易受DLL劫持攻击，因为它会盲目加载并执行任何位于其运行位置的名为*WindowsCodecs.dll*的DLL。真是非常巧妙！
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shim Hijacking</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">修补程序劫持</samp>
- en: Microsoft’s Application Compatibility framework allows for application *shimming*,
    or adding compatibility for software designed for older versions of Windows so
    that it can run on more recent versions of the OS. Developers can use shims to
    apply patches to a program without having to rewrite or recompile code. Shims
    are not only great tools for developers, though; using them is also a powerful
    method of code injection for malware. Using shims, malware can intercept API calls
    and modify their parameters. When a user starts an application, Windows starts
    the shim engine and checks to see if that application has any installed shims.
    Malware can take advantage of this behavior by abusing the shim *InjectDLL*, which,
    as its name implies, injects a DLL module into the shimmed application. Once the
    application is started via its executable file, a malicious DLL file is also loaded
    into the image of the victim application and executed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的应用兼容性框架允许应用程序*修补*，即为设计用于较旧版本Windows的软件添加兼容性，以便它可以在更新版本的操作系统上运行。开发人员可以使用修补程序为程序应用补丁，而无需重写或重新编译代码。然而，修补程序不仅是开发人员的好工具；使用它们也是恶意软件注入代码的强大方法。通过修补程序，恶意软件可以拦截API调用并修改其参数。当用户启动应用程序时，Windows启动修补程序引擎并检查该应用程序是否安装了任何修补程序。恶意软件可以通过滥用修补程序*InjectDLL*来利用这一行为，正如其名称所示，它将DLL模块注入到被修补的应用程序中。一旦通过可执行文件启动应用程序，恶意DLL文件也会被加载到受害者应用程序的映像中并执行。
- en: 'A malicious actor can create a shim on the victim system by using the built-in
    Windows shim database installer tool *sdbinst.exe*. The malware invokes this tool
    and points it to the malicious shim database (*.sdb*) file like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意行为者可以通过使用内置的Windows修补程序数据库安装工具*sdbinst.exe*在受害者系统上创建修补程序。恶意软件调用这个工具并将其指向恶意修补程序数据库（*.sdb*）文件，如下所示：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the malware installs a shim on a victim host, the shim database is installed
    in *C:\Windows\AppPatch\Custom* or *C:\Windows\AppPatch\AppPatch64\Custom\Custom64*
    (for 64-bit applications) in the form of one or more *.sdb* files. [Figure 12-19](chapter12.xhtml#fig12-19)
    shows what such a file might look like.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件在受害者主机上安装了修补程序，修补程序数据库就会以*.sdb*文件的形式安装在*C:\Windows\AppPatch\Custom*或*C:\Windows\AppPatch\AppPatch64\Custom\Custom64*（针对64位应用程序）中。[图
    12-19](chapter12.xhtml#fig12-19)展示了这样的文件可能是什么样子的。
- en: '![](../images/fig12-19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-19.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-19: An</samp> <samp
    class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    installed on a Windows system</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-19：一个</samp> <samp class="SANS_Futura_Std_Book_11">.sdb</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件安装在 Windows 系统上</samp>
- en: Installed shims typically have a registry entry in either *HKLM\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AppCompatFlags\Custom* or *HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB*,
    as shown in [Figure 12-20](chapter12.xhtml#fig12-20).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 已安装的 shims 通常在 *HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom*
    或 *HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB*
    中有注册表条目，如 [图 12-20](chapter12.xhtml#fig12-20) 所示。
- en: '![](../images/fig12-20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-20.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-20: Shim database
    registry entries</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-20：Shim 数据库注册表条目</samp>
- en: During an investigation, you can explore suspicious *.sdb* files in more detail
    by using the aptly named SDB Explorer tool, available for free from [*https://<wbr>ericzimmerman<wbr>.github<wbr>.io<wbr>/*](https://ericzimmerman.github.io/)
    and shown in [Figure 12-21](chapter12.xhtml#fig12-21).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查过程中，你可以通过使用 SDB Explorer 工具，深入探索可疑的 *.sdb* 文件。该工具可以免费从 [*https://<wbr>ericzimmerman<wbr>.github<wbr>.io<wbr>/*](https://ericzimmerman.github.io/)
    获取，并显示在 [图 12-21](chapter12.xhtml#fig12-21) 中。
- en: '![](../images/fig12-21.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-21.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-21: Analyzing an</samp>
    <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    in SDB Explorer</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-21：在 SDB Explorer 中分析一个</samp>
    <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: As you can see in this output, the file seems to be shimming *chrome.exe*, *explorer.exe*,
    *firefox.exe*, and *iexplore.exe*. You can also tell that it’s using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InjectDll</samp> functionality and referencing
    a DLL file (*spvc32loader.dll*). Based on this information, we can suspect that
    this shim is targeting browser processes and attempting to inject a malicious
    DLL into their respective memory address space, which will occur when the browser
    process first executes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在此输出中看到的，文件似乎在进行 *chrome.exe*、*explorer.exe*、*firefox.exe* 和 *iexplore.exe*
    的 shim 操作。你还可以看出它正在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">InjectDll</samp>
    功能，并引用了一个 DLL 文件 (*spvc32loader.dll*)。根据这些信息，我们可以怀疑这个 shim 目标是浏览器进程，并试图将恶意的 DLL
    注入到它们各自的内存地址空间中，这将在浏览器进程首次执行时发生。
- en: A good example of shim hijacking is documented in a report from Mandiant on
    the threat group FIN7, which was able to install the Carbanak backdoor and persist
    on the infected endpoints by registering a new shim database and patching the
    legitimate Windows *services.exe* executable. *Services.exe* is a critical system
    process and always runs when Windows first boots up. Once *services.exe* executes,
    the shim executes and launches the malicious Carbanak payload. For full details
    on the attack, see [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/fin7<wbr>-shim<wbr>-databases<wbr>-persistence*](https://www.mandiant.com/resources/fin7-shim-databases-persistence).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于 shim 劫持的好例子可以在 Mandiant 关于威胁组织 FIN7 的报告中找到，该组织通过注册一个新的 shim 数据库并修补合法的 Windows
    *services.exe* 可执行文件，成功地安装了 Carbanak 后门并在受感染的终端上保持持久性。*Services.exe* 是一个关键的系统进程，并且每次
    Windows 启动时都会运行。一旦 *services.exe* 执行，shim 就会执行并启动恶意的 Carbanak 载荷。有关此攻击的详细信息，请参见
    [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/fin7<wbr>-shim<wbr>-databases<wbr>-persistence*](https://www.mandiant.com/resources/fin7-shim-databases-persistence)。
- en: Shims are a multipurpose evasive mechanism. They’re a means of covertly injecting
    code to fly under the radar of endpoint defenses and investigators, as well as
    a way to establish persistence (as demonstrated by the FIN7 attack). In addition
    to these purposes, shims can serve as a rudimentary method for hooking. Let’s
    look at how hooking works.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Shims 是一种多功能的规避机制。它们是一种通过隐藏在端点防御和调查者的雷达下悄悄注入代码的手段，也是建立持久性的方式（如 FIN7 攻击所示）。除了这些目的之外，shims
    还可以作为一种初步的钩子方法。让我们来看一下钩子是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hooking</samp>
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">钩子</samp>
- en: 'As described in [Chapter 8](chapter8.xhtml), hooking is a technique used to
    intercept, monitor, and possibly modify Windows function calls. It has both malicious
    and legitimate applications; for example, hooking can be used by the following
    applications:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第8章](chapter8.xhtml)所述，hooking是一种用于拦截、监控并可能修改Windows函数调用的技术。它既有恶意用途，也有合法应用；例如，以下应用程序可以使用hooking：
- en: Benign applications (such as shims), to modify or patch code or to monitor a
    system or other applications
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良性应用程序（如补丁程序），用于修改或修补代码，或监控系统或其他应用程序
- en: Sandboxes and other malware analysis tools, to monitor the malware’s behaviors
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙箱和其他恶意软件分析工具，用于监控恶意软件的行为
- en: Endpoint defense software, such as anti-malware and endpoint detection and response
    (EDR)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端防御软件，如反恶意软件和终端检测与响应（EDR）
- en: Keyloggers and other infostealer malware, to intercept keyboard events in order
    to capture keystrokes and steal sensitive data
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘记录器和其他信息窃取恶意软件，用于拦截键盘事件，以捕获击键并窃取敏感数据
- en: Evasive malware, to prevent its code from being detected by endpoint defenses
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规避检测的恶意软件，用于防止其代码被终端防御系统检测到
- en: In this section, first we’ll discuss how hooking works in Windows before looking
    at some common hooking techniques. To wrap up the section and the chapter, we’ll
    then look at how malware can implement and inject hooks into victim processes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先将讨论hook在Windows中的工作原理，然后再介绍一些常见的挂钩技术。为了总结本节内容和本章内容，我们将探讨恶意软件如何在受害者进程中实现并注入hook。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SetWindowsHookEx Hooking
    and Injection</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SetWindowsHookEx 挂钩与注入</samp>
- en: 'One of the simplest ways to implement a hook is to use a Windows function designed
    specifically for that purpose: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>.
    This function allows the caller to specify which system events to hook, such as
    mouse or keyboard events, and which code to execute when an event occurs. However,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> can also
    be abused for DLL injection, as it accepts a DLL file as a parameter. The following
    simplified pseudocode illustrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    can be used to hook and stealthily run malicious code within the context of a
    victim process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实现hook的最简单方法之一是使用专门为此目的设计的Windows函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>。该函数允许调用者指定要挂钩的系统事件，如鼠标或键盘事件，并指定事件发生时要执行的代码。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>也可能被滥用进行DLL注入，因为它接受一个DLL文件作为参数。以下简化的伪代码展示了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>来挂钩并悄无声息地在受害者进程的上下文中运行恶意代码：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, several variables are passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    as parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">idHook</samp>
    parameter can have a number of different values, each representing a system event
    to be monitored and hooked. For example, the values <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE_LL</samp> (the latter
    is shown here) will intercept mouse-related events such as clicks. Two other hooks
    commonly used by malware are <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD_LL</samp>, which
    intercept keyboard-related events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，几个变量作为参数传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idHook</samp>参数可以有多个不同的值，每个值表示一个要监控和挂钩的系统事件。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE_LL</samp>（后者在这里显示）将拦截与鼠标相关的事件，如点击。恶意软件常用的两个其他钩子是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD_LL</samp>，它们用于拦截与键盘相关的事件。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">hmod</samp> parameter represents
    the name of the loaded module containing the malicious code that will be executed
    once a mouse event occurs. In the current example, this malware is calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, which will load the
    malicious DLL (*evil.dll*) into the victim process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpfn</samp>
    parameter represents a pointer to code that will execute when a mouse event occurs.
    In this case, the malicious function to be executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">Function_1</samp>,
    which resides in *evil.dll*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hmod</samp> 参数表示加载模块的名称，该模块包含将在鼠标事件发生时执行的恶意代码。在当前示例中，这个恶意软件调用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>，该函数将恶意 DLL (*evil.dll*)
    加载到受害者进程中。<samp class="SANS_TheSansMonoCd_W5Regular_11">lpfn</samp> 参数表示一个指针，指向将在鼠标事件发生时执行的代码。在这种情况下，将执行的恶意函数是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Function_1</samp>，它位于 *evil.dll*
    中。
- en: Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwThreadId</samp>
    parameter represents a specific thread ID to be monitored. If the program calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> wishes to
    monitor only a single thread in a single application, it can set the thread ID
    here. If the calling program wishes to monitor all threads, it can set this parameter
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">dwThreadId</samp> 参数表示要监控的特定线程
    ID。如果调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    的程序希望仅监控单个应用程序中的单个线程，可以在此设置线程 ID。如果调用程序希望监控所有线程，则可以将此参数设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: In summary, the malicious *evil.dll* file will load and execute inside the victim
    process whenever a mouse event is detected. Since the malware could potentially
    hide and wait for a very specific event to occur, such as a certain number of
    mouse clicks or a particular key being pressed, this attack can be very stealthy.
    Note, however, that this technique is rather old, and modern versions of Windows
    can prevent such an attack, not to mention that this behavior is very suspicious
    and will likely trigger endpoint defenses. Furthermore, this specific example
    will almost certainly result in a very unstable system. (Loading a DLL every time
    there’s a mouse event isn’t a wise decision!) However, variations of this technique
    are still used in modern malware, so it’s important to be aware of it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，每当检测到鼠标事件时，恶意 *evil.dll* 文件将在受害者进程内加载并执行。由于恶意软件可能隐藏并等待非常特定的事件发生，比如某个特定数量的鼠标点击或按下某个特定的键，这种攻击可以非常隐蔽。然而需要注意的是，这种技术相对较老，现代版本的
    Windows 可以防止这种攻击，更不用说这种行为非常可疑，很可能触发终端防御机制。此外，这个具体示例几乎肯定会导致系统非常不稳定。（每次鼠标事件发生时加载
    DLL 不是明智的决定！）然而，这种技术的变种仍然在现代恶意软件中使用，因此需要对此保持警惕。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Hooking</samp>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内联钩子</samp>
- en: One of the most common forms of user-space hooking is *inline hooking*, which
    relies on injecting code into a target process and simultaneously modifying the
    legitimate function being hooked to force a jump to the injected code. First,
    the process that wishes to hook another process (the target process) must inject
    code into it by using one of the previously described methods; DLL injection is
    one of the most common. Next, the first process modifies the function it wishes
    to hook within the target process’s address space to point and jump to the injected
    hooking code. When the target process executes that function, control flow is
    transferred from the original code to the hooked code, which can then be used
    for monitoring, intercepting, or modifying calls to the original function. [Figure
    12-22](chapter12.xhtml#fig12-22) illustrates the inline hooking technique.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间钩子最常见的形式之一是*内联钩子*，它依赖于将代码注入到目标进程，并同时修改被钩住的合法函数，以强制跳转到注入的代码。首先，希望钩住另一个进程（目标进程）的进程必须通过之前描述的其中一种方法将代码注入目标进程；DLL
    注入是最常见的一种。接下来，第一个进程在目标进程的地址空间内修改它希望钩住的函数，指向并跳转到注入的钩子代码。当目标进程执行该函数时，控制流从原始代码转移到钩子代码，随后可以用于监视、拦截或修改对原始函数的调用。[图
    12-22](chapter12.xhtml#fig12-22)展示了内联钩子技术。
- en: '![](../images/fig12-22.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-22.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-22: The inline API
    hooking technique</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-22：内联 API 钩子技术</samp>
- en: This application calls the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    which is located inside *ntdll.dll*. Normally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code inside *ntdll.dll* would then execute. However, *ntdll.dll* has been tampered
    with and its legitimate code has been overwritten with a jump instruction, so
    now the program will jump to and execute the hooking code instead. Once the malicious
    code is run, control flow is transferred back to *ntdll.dll* and finally returns
    to the original application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序调用了位于 *ntdll.dll* 内的 WinAPI 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>。通常，*ntdll.dll*
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> 代码会执行。然而，*ntdll.dll*
    已被篡改，合法代码被跳转指令覆盖，因此现在程序会跳转并执行钩子代码。一旦恶意代码执行完毕，控制流将返回到 *ntdll.dll*，并最终返回到原始应用程序。
- en: 'Let’s say our system has been infected with a malware sample that wishes to
    intercept and monitor all calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    in a victim process (*firefox.exe*, for example). After injecting the malicious
    hooking DLL into *firefox.exe*, the malware must modify the *ntdll.dll* module
    in the victim process’s address space. The malware locates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function within *ntdll.dll* and overwrites the first 5 bytes to jump to the malicious
    injected DLL instead of executing the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. (Overwriting 5 bytes is common because that’s a typical size for jump instructions.)
    The first byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp> (the jump
    instruction), is followed by 4 bytes representing the memory location to jump
    to. To modify the function code in the target process, the first process can call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>. This code block shows the
    first bytes of the legitimate <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function (in x64 assembly):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的系统已经被一种恶意软件感染，该恶意软件希望拦截并监控对受害进程（例如 *firefox.exe*）中 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    的所有调用。在将恶意钩子 DLL 注入到 *firefox.exe* 后，恶意软件必须修改受害进程地址空间中的 *ntdll.dll* 模块。恶意软件定位到
    *ntdll.dll* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    函数，并将前 5 个字节覆盖为跳转到恶意注入的 DLL，而不是执行实际的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    代码。（覆盖 5 个字节是常见的做法，因为这是跳转指令的典型大小。）第一个字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>（跳转指令）后跟
    4 个字节，表示跳转的内存位置。为了修改目标进程中的函数代码，第一个进程可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>。此代码块展示了合法的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> 函数的前几个字节（以 x64 汇编表示）：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the malware modifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function, it might look like this; notice the jump to the malicious code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件修改了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp> 函数之后，它可能看起来像这样；注意跳转到了恶意代码：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement,
    the jump to the hooked code could be accomplished with a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction like
    so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到钩子代码可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> 指令来实现，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    语句，如下所示：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When installing an inline hook, the code author often will want the original
    function code to execute after the hooked code runs in order to avoid scrutiny
    from system users. Let’s say that in our <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    example, the author wants to intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    execute the hooked code, and then execute the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. This can be accomplished in the form of a *trampoline*, which is simply
    a jump back to the original function, as shown in [Figure 12-23](chapter12.xhtml#fig12-23).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装内联钩子时，代码作者通常希望在钩子代码运行后执行原始函数代码，以避免系统用户的审查。假设在我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    示例中，作者希望拦截对 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    的调用，执行钩子代码，然后执行原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    代码。这可以通过跳转回原始函数的 *跳板* 来实现，如 [图 12-23](chapter12.xhtml#fig12-23) 所示。
- en: '![](../images/fig12-23.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-23.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-23: An inline hook
    trampoline</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-23：内联钩子跳板</samp>
- en: Trampolines are often implemented with an instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">call
    NtCreateFile+5</samp>. After the hooking code executes (inside the injected DLL,
    in this case), this instruction will transfer control flow back to the real <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, skipping over the
    first 5 bytes where the inserted <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement resides in the modified *ntdll.dll* file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板通常通过类似 <samp class="SANS_TheSansMonoCd_W5Regular_11">call NtCreateFile+5</samp>
    的指令来实现。在钩子代码执行后（在注入的 DLL 中），此指令将控制流转回真实的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>，跳过前
    5 个字节，其中插入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> 语句位于修改后的
    *ntdll.dll* 文件中。
- en: When you’re analyzing malware, there are three function calls that can hint
    at inline hooking. First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to read the first bytes of code in the function it wishes to hook inside the target
    process. Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to modify the permissions of the target memory region and prepare for writing
    the jump instruction that will jump to the malicious code injected into the target
    process. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the jump statement into the target function’s code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析恶意软件时，有三个函数调用可以提示内联钩子。首先，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    读取它希望在目标进程中钩住的函数的前几个字节。接着，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    修改目标内存区域的权限，为写入跳转指令做准备，跳转到注入目标进程的恶意代码。最后，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    将跳转指令写入目标函数的代码中。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Another user-space hooking technique is* IAT hooking*, which involves altering
    the import address table of the target process to point to the hooking code rather
    than to the original function code. However, IAT hooking isn’t often used by modern
    malware since it’s easily detected by host-based defenses, so I won’t go into
    more detail on this method.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*另一种用户空间钩子技术是* IAT 钩子*，它通过修改目标进程的导入地址表，使其指向钩子代码而不是原始的函数代码。然而，现代恶意软件很少使用 IAT
    钩子，因为它容易被基于主机的防御检测到，因此我不会进一步详细介绍这种方法。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mitigations for Process and Hook Injection</samp>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程和钩子注入的缓解措施</samp>
- en: As new injection and hooking techniques are used in malware or discovered by
    researchers and published, Microsoft counters them with built-in protections as
    much as possible. For example, *data execution prevention*, introduced in Windows
    XP, seeks to prevent malware from executing injected malicious code by marking
    memory regions as nonexecutable. *AppLocker*, introduced in Windows 7, prevents
    unauthorized executables (which can include injected DLLs) from executing. *Control
    Flow Guard*, released in Windows 8.1, is designed to detect whether malware modifies
    the code control flow of another process, which often takes place during process
    injection. And *Arbitrary Code Guard (ACG)*, added in Windows 10, seeks to prevent
    malware from modifying the code of legitimate processes, thus preventing certain
    types of process and hook injection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的注入和钩取技术在恶意软件中使用或被研究人员发现并公布，微软会尽可能通过内置保护来应对这些技术。例如，*数据执行保护*，在 Windows XP
    中引入，旨在通过将内存区域标记为不可执行，防止恶意软件执行注入的恶意代码。*AppLocker*，在 Windows 7 中引入，防止未经授权的可执行文件（包括注入的
    DLL 文件）执行。*控制流保护*，在 Windows 8.1 中发布，旨在检测恶意软件是否修改了另一个进程的代码控制流，这通常发生在进程注入过程中。而 *任意代码保护（ACG）*，在
    Windows 10 中加入，旨在防止恶意软件修改合法进程的代码，从而防止某些类型的进程和钩取注入。
- en: 'In addition, complementary defenses such as EDR and anti-malware software can
    monitor suspicious processes and detect or prevent some of these injections. Keep
    in mind, however, that not all injection is malicious: plenty of benign, legitimate
    applications use injection for various reasons, so it can be difficult for endpoint
    defense products to determine the difference between good and evil. [Chapter 13](chapter13.xhtml)
    will explore some of these endpoint defenses and how malware attempts to bypass
    them.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像 EDR 和反恶意软件软件等补充防御措施可以监控可疑进程并检测或阻止其中的一些注入。然而，请记住，并非所有注入都是恶意的：许多良性、合法的应用程序因各种原因使用注入技术，因此终端防御产品可能很难区分良性和恶意的注入。[第13章](chapter13.xhtml)将探讨一些终端防御措施以及恶意软件如何尝试绕过这些防御。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, we discussed some of the common techniques malware uses to
    inject and run code within the context of other processes in order to evade endpoint
    defenses and blend in with the environment in which it’s running. We also covered
    some of the common hooks malware uses to hide its malicious behaviors or implement
    rootkit functionality. There are many types of injection and hooking techniques,
    and it’s impossible to cover them all in this book. I’ve tried to focus on those
    that you’re most likely to encounter in the wild, as well as some of the newer
    techniques that malware authors might add to their evasion toolboxes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了恶意软件常用的一些技术，它们通过将代码注入并在其他进程的上下文中运行来避开终端防御，并与其运行的环境融合。我们还介绍了一些恶意软件用来隐藏其恶意行为或实现
    rootkit 功能的常见钩子。注入和钩取技术有很多种，无法在本书中一一覆盖。我尽力聚焦于那些你最有可能在实际环境中遇到的技术，以及一些恶意软件作者可能加入到其规避工具箱中的新技术。
- en: In the next chapter, we’ll start looking at ways in which malware can circumvent
    endpoint and network defenses to execute and hide its malicious code in a well-protected
    environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将开始探讨恶意软件如何绕过终端和网络防御措施，以便在一个高度防护的环境中执行并隐藏其恶意代码。
