- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROCESS
    INJECTION, MANIPULATION, AND HOOKING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To blend in with their target environment, modern evasive threats must remain
    hidden on the infected host. Two methods they use to do so are process injection
    and process image manipulation. *Process injection* involves injecting and executing
    nefarious code inside another process rather than executing it directly, while
    *process image manipulation* involves tampering with process images and abusing
    the way Windows handles processes. Malware can also use process injection techniques
    to inject hooks into a target process. Hooking allows the malware to intercept
    API function calls and monitor or manipulate them, helping it remain undetected.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter by looking at different forms of process injection.
    Then, we’ll discuss two close cousins of the technique (process image manipulation
    and DLL and shim hijacking) along with various hooking methods. At the end of
    the chapter, we’ll briefly explore how to mitigate these types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Injection</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several reasons why malware might want to implement process injection
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding from defenses and investigators**'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting code into another process, particularly a well-known one like *notepad.exe*
    or *explorer.exe*, may help the malware persist on the infected host, hidden from
    endpoint defenses and investigators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mimicking normal behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: Malware might inject code into certain processes to disguise its behavior. For
    example, injecting code into a web browser and communicating with a C2 server
    from this process can help hide suspicious web traffic, as it’s normal and expected
    for web browsers to communicate with the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Thwarting debugging efforts**'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting code into a remote process can help circumvent and evade tools like
    debuggers, causing the analyst to lose control of the malware’s code execution
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elevating privileges**'
  prefs: []
  type: TYPE_NORMAL
- en: Specific types of process injection techniques can help malware elevate its
    privileges on the infected host, giving it a higher level of access within the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Intercepting data via hooking**'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting hooking code into a process can allow the malware to intercept and
    modify Windows API calls or intercept sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine various process injection techniques in more detail, starting
    with how malware identifies a target process for injection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Random vs. Specific
    Target Processes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware can inject code into either a random process or a specifically chosen
    target, depending on what it’s trying to achieve. For example, some malware injects
    malicious code into multiple arbitrary processes on the host to ensure its own
    survival. The malware could simply enumerate all processes on the host using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    and then attempt to open and get a handle to the target process using <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>.
    If it successfully opens the target process with its current privilege levels,
    the malware injects its code there. This approach isn’t very stealthy, however.
    A more covert approach is to inject code into specific target processes, such
    as well-known and common Windows processes, or into processes that allow the malware
    to achieve a certain objective. Certain variants of the malware family Formbook,
    for example, inject code into browser-related processes, attempting to sniff out
    sensitive data such as web logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some malware might even inject code into its own process (a technique known
    as *self-injection*) or into a child process that it creates. These types of injection
    techniques often take place during the *unpacking* process, in which malware decrypts,
    or unpacks, its payload in memory and then injects it into a child process. [Chapter
    17](chapter17.xhtml) will discuss unpacking in more detail. For now, let’s look
    at one of the most basic and prevalent forms of process injection: shellcode injection.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode Injection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Shellcode injection*, also known as *direct injection*, is one of the oldest
    injection techniques; as its name suggests, it involves injecting *shellcode*,
    a type of position-independent machine code. Once the shellcode has been injected,
    the malware can remain hidden while executing its malicious code directly from
    within the victim process’s memory. [Figure 12-1](chapter12.xhtml#fig12-1) illustrates
    how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: The shellcode
    injection technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To inject the shellcode, first the malware must open an object handle to the
    target process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (or by directly calling its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> function
    has a couple of important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> parameter represents
    the access rights requested by the calling process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>
    is the ID of the target process. You can reference the function prototype information
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the malware has obtained an object handle to the target process, it calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process for injecting its shellcode. (Alternatively, it could
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function.)
    The most relevant parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function are <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>, which represent the
    starting address and the size of the region of memory being allocated, respectively.
    The prototype information for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After allocation, the malware writes the malicious code into this fresh memory
    region using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    (or its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>).
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> takes
    some important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>,
    the handle of the process being written into; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>,
    a pointer to the base address where the data will be written; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>,
    a pointer to a memory location that contains the data to be written; and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>, the number of bytes to be
    written into the target process’s memory. Here is the prototype information for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after writing the malicious code into its target process, the malware
    is ready to execute it within the process context. To do so, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    (alternatively, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>) to
    create a remote thread within the process context and execute it. The most important
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>, a handle to
    the target process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>,
    the starting address of the code to be executed. The function prototype for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is only one of the many methods of shellcode injection and execution.
    The flow of this technique and the functions being called (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    and so on) are the basic building blocks of several techniques we’ll touch on
    in this chapter. Keep in mind as well that many of the functions listed in this
    chapter are interchangeable with other functions. For example, instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, malware might
    call the native API <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
    Instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    it could invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: To trace process injection, I like to use API Monitor, which allows you to quickly
    see the way the malware is injecting code and even extract the injected code.
    You can also use it to inspect the parameters of each function call in an easy-to-read
    format.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In the next section, I’ll be using a malware executable that you can download
    from VirusTotal or MalShare using the following file hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Figure 12-2](chapter12.xhtml#fig12-2) shows the result of loading the malware
    sample in API Monitor and filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Shellcode injection
    captured in API Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this sample begins by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (with the <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp>
    permission and several other access permissions), then makes multiple calls to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process. The malware then writes code into that process using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> and executes
    it by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the buffer for the third call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you can see that the malware is writing what looks like shellcode into the target
    process (see [Figure 12-3](chapter12.xhtml#fig12-3)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It takes some practice, but you can identify shellcode by inspecting the data
    and looking for bytes that represent common assembly instructions such as <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b ec</samp> (which translates
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp, esp</samp>).
    Refer back to [Chapter 3](chapter3.xhtml) for additional assembly instructions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: Shellcode injected
    into a target process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that it’s shellcode, save the data (click the Save icon in the upper-left
    corner of the hex buffer window) and then view it in a disassembler. You should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because this data cleanly converts to assembly code, this indeed appears to
    be shellcode. I won’t go into this code in more detail here, but if I were analyzing
    this malware sample, I would try to understand this code’s purpose by investigating
    it further in the disassembler and then investigating it dynamically in a debugger.
    Note that in some circumstances, the disassembler may incorrectly recognize this
    as data instead of code. (Refer back to the “Disassembly” box on [page 51](chapter3.xhtml#pg_51)
    for a refresher on the code vs. data problem.) You might have to “force” the disassembler
    to read it as code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, there’s something else injected into the target process worth
    noting. If you inspect the buffer for the first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you’ll see a reference to *kernel32.dll* (see [Figure 12-4](chapter12.xhtml#fig12-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The string KERNEL32.DLL
    written into memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This indicates that the sample could also be using another process injection
    technique, DLL injection, which we’ll take a look at now.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL
    Injection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While DLL injection is another common form of process injection, don’t be misled
    by its name. In this type of attack, the malware doesn’t physically inject a DLL
    into a target process; instead, it writes *the path* to a malicious DLL file located
    on disk into the target process and then forces the target process to load and
    execute that DLL on its behalf. [Figure 12-5](chapter12.xhtml#fig12-5) illustrates
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The DLL injection
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware first drops a malicious DLL file to disk. Then, as in shellcode
    injection, it invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to get a handle to its chosen target process and uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    to allocate memory within that process. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the location of that DLL file into the process. Finally, to make the
    victim process load its DLL, the malware gets the procedural address of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and then calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> parameter set to
    that address. Once the remote thread executes, the target process calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and, in doing so, loads
    the malicious DLL. Here’s how this looks in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the malicious DLL path, <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>,
    into the target process, <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>.
    Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    to get the procedural address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    function. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    passing the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    and the path to the malicious DLL as parameters. This forces the victim process
    to load the malicious DLL and execute the code within a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with traditional DLL injection for malware authors is that the DLL
    must be loaded from disk, using the standard Windows library loading procedures.
    These standard loading procedures are monitored and easily spotted by endpoint
    defenses. A stealthier approach to DLL injection is reflective DLL injection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reflective DLL Injection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In *reflective* DLL injection, the DLL is stored in memory rather than on disk,
    and the malware loads it without having to rely on the standard Windows loading
    mechanism. This makes reflective DLL injection a more covert alternative to the
    standard DLL injection method just described.
  prefs: []
  type: TYPE_NORMAL
- en: The initial steps of reflective DLL injection are fairly similar to the standard
    DLL injection. The malware obtains a handle to its victim process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> and allocates memory
    in that process using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>.
    However, instead of writing only the path to the DLL file, the malware copies
    the entire malicious DLL to the target process’s memory. Then, it transfers control
    flow to the newly injected DLL (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    for example), which executes the injected DLL’s “bootstrap” loader code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This bootstrap code is custom code that must re-create the normal Windows DLL
    loading process. At a high level, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The bootstrap code calculates its own image location in memory and performs
    its own image base relocations, which means realigning the hardcoded addresses
    in the executable code to match its current location in memory. The loader also
    finds the location of the injected DLL’s PEB.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The bootstrap code parses the exports table of *kernel32.dll* to locate
    the addresses of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    and other fundamental functions.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The malicious DLL has now been successfully loaded inside the victim process
    and is ready to run. To execute the DLL’s malicious code, malware typically invokes
    a function in the DLL’s exports table, such as the function shown in [Figure 12-6](chapter12.xhtml#fig12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The DLL export
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The malware shown here was generated with the popular penetration testing tool
    Cobalt Strike and has <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp>
    as the default export function. Once this export function is invoked, the malicious
    code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-7](chapter12.xhtml#fig12-7) illustrates a typical reflective DLL
    injection attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The reflective
    DLL injection technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the running malware downloads its DLL payload from a staging
    server controlled by the attacker ❶, which is then temporarily stored in the malware’s
    process memory space ❷. (Note that this technique does not always rely on a remote
    staging server, but we’ll touch on that in a moment.) Next, the bootstrap code
    is injected into a target process along with the DLL ❸, then executed by the malware.
    The bootstrap code performs the manual DLL loading process and then calls the
    export function of the injected DLL, which executes the malicious code in the
    context of the target process ❹. You can read more about reflective DLL injection
    from the original author of the technique at [*https://<wbr>github<wbr>.com<wbr>/stephenfewer<wbr>/ReflectiveDLLInjection*](https://github.com/stephenfewer/ReflectiveDLLInjection).
  prefs: []
  type: TYPE_NORMAL
- en: Reflective DLL injection, as with many of the injection methods I discuss throughout
    this chapter, can be subdivided into so-called staged and stageless techniques.
    The technique just presented is considered *staged*, as the payload to be injected
    is hosted and downloaded from the attacker’s staging server. In *stageless* reflective
    DLL injection, the payload is already embedded in the original malware executable
    before being unpacked and injected into the target process.
  prefs: []
  type: TYPE_NORMAL
- en: A similar technique, sometimes called *shellcode reflective injection*, involves
    converting a DLL into shellcode and then injecting it into a target process. I
    won’t cover this technique further since it combines techniques you’ve already
    seen, but you can read more about it at [*https://<wbr>github<wbr>.com<wbr>/monoxgas<wbr>/sRDI*](https://github.com/monoxgas/sRDI).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Hollowing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Process hollowing* (sometimes called *RunPE*, *process replacement*, or *hollowed
    process injection*) involves unmapping code from a target process’s memory and
    then remapping malicious code there. Process hollowing is a bit different from
    the other injection techniques we’ve seen so far, as it doesn’t usually involve
    an arbitrary remote process. Instead, the malware starts a new process (often
    a trusted executable, such as our beloved *Calculator.exe*), unmaps the legitimate
    code, and remaps malicious code in a suspended state, at which point the malware
    executes the malicious code. This hides the malicious code from the prying eyes
    of endpoint defenses and investigators, disguising it as a normal process. [Figure
    12-8](chapter12.xhtml#fig12-8) illustrates the technique.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The process-hollowing
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This malware sample begins by creating a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    and then sets the process creation flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>
    (not shown); this starts the new process in a suspended state. Next, the malware
    “hollows out” the newly created process by unmapping its legitimate code with
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>.
    Then, the malware allocates a new region of memory for its malicious code using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and writes (maps)
    its payload here using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>.
    Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> to point
    the current thread to the newly injected code and resume thread execution, respectively,
    which runs the malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this in practice, using a variant of the ransomware family
    Satan (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: cbbd2bd6f98bd819f3860dea78f812d5c180fd19924cef32e94B
    d7f6929023779</samp>). The screen capture from API Monitor in [Figure 12-9](chapter12.xhtml#fig12-9)
    shows a malware sample (a variant of the Satan ransomware family) using the process-hollowing
    technique.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: A malware sample
    using the process-hollowing technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this malware starts a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>
    from an executable on disk (*financialz.exe*) in a suspended state (<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>),
    as just discussed. Then, it makes multiple calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>
    to map data into the new target process. Inspecting this function call further
    in API Monitor reveals that this malware sample is writing a PE file into the
    target process, then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>
    to execute it (see [Figure 12-10](chapter12.xhtml#fig12-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: The PE header
    in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while process hollowing is typically classified as a process injection
    technique, it’s not a true injection technique, since it relies on the malware
    spawning a new process in a suspended state and then replacing the process’s preexisting
    code with malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Hijacking</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Thread hijacking* involves opening a running thread in a victim process, writing
    malicious code into that thread, and forcing the victim process to execute the
    code. Thread hijacking shares many of the functions used in the process-hollowing
    technique, but there are a few notable differences. To execute thread hijacking,
    the malware invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>
    function, specifying a thread ID as a parameter, and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp> for
    64-bit processes) to suspend the victim thread. Once the thread is in a suspended
    state, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, respectively,
    to allocate memory in the target process and write its malicious code there. Finally,
    the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    to transfer control flow from the currently suspended thread to the newly injected
    malicious code, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>
    to execute the code.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC Injection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *asynchronous procedure call (APC)* is a Windows feature that allows for
    various tasks to be queued and executed in the context of a running thread. A
    program might invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    function, passing both the handle to the thread and a pointer to the code that
    the program wishes to run, to add that task to the APC queue. *APC injection*
    abuses this functionality to stealthily execute code and, potentially, elevate
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: For a program to be able to call functions in the APC queue, the thread must
    be in an *alertable* state, meaning the thread periodically checks for new items
    in the queue and runs the next queued task. Many processes running on the system,
    from web browsers to video players, have threads running in alertable states.
    Generally, such threads eventually receive an interrupt request from the operating
    system, at which point the process will inspect the APC queue and run the next
    queued task.
  prefs: []
  type: TYPE_NORMAL
- en: Malware takes advantage of APC functionality by attempting to inject malicious
    code into other processes via APC queuing. [Figure 12-11](chapter12.xhtml#fig12-11)
    illustrates this attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: The APC injection
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This malware first gets a handle to its target victim process in the usual way
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>) and writes
    the malicious code to be executed into the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>).
    Next, it opens a target thread by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) to
    queue a new APC task. Whenever the thread receives an interrupt request from the
    operating system, this malicious code will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: A variation of this technique creates a new process in a suspended state (similar
    to process hollowing) and writes the malicious code into it. Then, the malware
    queues its APC function and resumes the thread. Once the thread resumes, the malicious
    code will be executed. At this point, the malware can terminate its original process,
    as its payload is now running under a new process and may go unnoticed by endpoint
    defenses and unaware end users. [Figure 12-12](chapter12.xhtml#fig12-12) shows
    this attack, captured in API Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Malware using
    a variation of the APC injection technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This malware sample uses APC injection to run malicious code in the context
    of the *iexplore.exe* process. In this case, the malware starts *iexplore.exe*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>) instead
    of hijacking another process (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Atom Bombing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The last process injection technique we’ll cover in this chapter is *atom bombing*,
    which shares some features of APC injection but involves *atoms*, references to
    specific pieces of data such as strings. Atoms are stored in an OS structure known
    as the *atom table*, and each atom has a unique atom identifier. Atoms are often
    used in interprocess communication to coordinate actions between processes. For
    example, Process A might create an atom to indicate that a particular piece of
    data is available, and Process B can use that atom to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: Atom tables can be global (that is, accessible from any process running on the
    system) or local (accessible to only one specific process). To add data to the
    global atom table, an application invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>
    function; to add an atom to a local table, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddAtom</samp>
    function. Atom bombing abuses these atom tables to temporarily store malicious
    code. [Figure 12-13](chapter12.xhtml#fig12-13) illustrates this attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: The atom bombing
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, this technique creates a new global atom (<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>)
    in the global atom table, where it stores malicious shellcode ❶ and uses APC queuing
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) ❷ to force
    the victim process into executing <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp>
    ❸. Once the atom is retrieved by the victim process, the shellcode stored in the
    atom table can be run in that process’s context ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection
    Wrap-up</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve seen, many process injection techniques use the same API function
    calls and behave similarly. Nearly all process injection techniques create a process
    or open a handle to a target process, allocate memory and write or map code into
    the target process, and then force the injected code to execute in the context
    of the target process, as summarized in [Figure 12-14](chapter12.xhtml#fig12-14).
    (Special thanks to malware researcher Karsten Hahn, who inspired this image.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: A summary of
    process injection behaviors and API calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve looked at various process injection techniques, let’s pivot
    to another method used for similar purposes: process image manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Image Manipulation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Process image manipulation* abuses both the standard Windows process creation
    routine and the way endpoint defenses (specifically, anti-malware software) operate.
    To defend a system from malware attacks, anti-malware software needs to know when
    a new process is started in order to monitor it for suspect behaviors. This is
    where the API function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    comes in. When a new process is created, this function sends notification messages
    to endpoint defense software, which then inspects and scans the originating executable
    file that started the process. If the anti-malware software sees that the executable
    file contains malicious code, it can quarantine the file and terminate any associated
    processes. The problem is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    is invoked not at the exact moment of a process’s creation, but rather on the
    creation and execution of the first few threads running within the process context.
    This gives malware a nice window of opportunity to modify the original executable
    file before anti-malware solutions have time to scan it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process manipulation also involves interfering with the way Windows creates
    processes (as described in [Chapter 1](chapter1.xhtml)). In essence, Windows usually
    calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>,
    a kernel function that handles the details of process creation and then maps processes
    into memory by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Obtain a handle to an executable file (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Create a section object for the file, typically by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    function. In this case, a *section* is simply an object that will be mapped into
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Create a process object by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    with a parameter referencing the newly created section object, mapping the process
    object into memory as a new process.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Execute the process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    to create and start a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how different process manipulation techniques are used
    to interfere with these steps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Herpaderping</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Process herpaderping* has a funny name but packs a powerful punch. It confuses
    the operating system and anti-malware solutions by interfering with the way Windows
    creates processes. [Figure 12-15](chapter12.xhtml#fig12-15) illustrates how this
    technique works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: The process-herpaderping
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This malware first creates a new file on disk and obtains a handle to it, keeping
    that handle open ❶. It writes malicious executable code into this empty file,
    then creates a section object for the file ❷. Next, it creates a process using
    the new section object ❸. The malicious code is now mapped into memory, but it
    isn’t executing yet. So far, this approach follows the standard Windows PE loading
    steps, but things are about to get interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The malware modifies or removes the malicious code within the file it created
    on disk ❹. It then starts a new thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>),
    which executes the malicious code in memory, and closes the handle to the open
    file. At this point, the aforementioned <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    callback will occur and endpoint defenses will kick in, inspecting the malicious
    file. However, since the malicious file in fact no longer contains malicious code,
    the anti-malware software is tricked into thinking all is well. Anti-malware software,
    as well as Windows itself, assumes that a file on disk can’t (or shouldn’t) be
    modified when it’s already mapped into memory and running inside a process. Process
    herpaderping takes advantage of such assumptions to execute malicious code. You
    can find out more about this technique from its author at [*https://<wbr>jxy<wbr>-s<wbr>.github<wbr>.io<wbr>/herpaderping<wbr>/*](https://jxy-s.github.io/herpaderping/).
    If you’d like to test it yourself, you can explore the proof of concept at [*https://<wbr>github<wbr>.com<wbr>/jxy<wbr>-s<wbr>/herpaderping*](https://github.com/jxy-s/herpaderping).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Doppelganging</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Process doppelganging*, first presented at Black Hat 2017 by security researchers
    Eugene Kogan and Tal Liberman, is a manipulation technique that uses Transactional
    NTFS to hide malicious code execution. The term *doppelganging* originates from
    the word *doppelganger*, which is commonly used to describe a person with an uncanny
    resemblance to someone else. *Transactional NTFS* was designed to add extra features
    and support (like file integrity preservation and better error handling) to NTFS,
    the default filesystem in Windows. It allows the use of *transactions*, which
    track changes to the filesystem that can be rolled back when necessary. Actions
    like file deletion first occur virtually. If the file deletion request succeeds,
    the transaction is committed and the file is actually deleted. If the file deletion
    request results in an error, however, the transaction is rolled back and no action
    occurs. Ultimately, transactions seek to prevent data inconsistency and corruption
    resulting from a system failure or other unexpected event.'
  prefs: []
  type: TYPE_NORMAL
- en: A new file created with transactions normally can’t be accessed from outside
    the process currently interacting with it; even certain anti-malware solutions
    can’t access it in this case. For this reason, transactions can provide a safe
    location for a malicious file to temporarily hide. And since transacted files
    can be “rolled back” to a previous state, endpoint defenses can easily become
    confused. This is exactly why process doppelganging is effective. [Figure 12-16](chapter12.xhtml#fig12-16)
    illustrates how this technique works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: The process-doppelganging
    technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This malware creates a new NTFS transaction using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateTransaction</samp>
    and opens an existing executable file using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFileTransacted</samp>
    ❶. (It could instead call lower-level functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateTransaction</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetCurrentTransaction</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateFile</samp> to achieve
    the same effect.) Next, the malware writes its malicious code into the existing
    PE file (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>), which
    will replace the original executable’s code ❷. The malware then executes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    to create a new process, passing the location of the new malicious PE file (the
    doppelganger) as a parameter ❸. Once the PE file is mapped into memory and the
    malicious process is running, the malware deliberately rolls back the original
    NTFS transaction (<samp class="SANS_TheSansMonoCd_W5Regular_11">RollbackTransaction</samp>),
    returning the file to its original, preinfected state ❹. When the anti-malware
    software is notified of the process creation and scans the process’s executable
    file on disk, it’s too late; the original executable file has already been rolled
    back to its nonmalicious state.
  prefs: []
  type: TYPE_NORMAL
- en: A few variations of the process-doppelganging technique have emerged since it
    was first published in 2017\. One variant, dubbed *transacted hollowing* by researchers
    at Malwarebytes, combines process hollowing with process doppelganging (see the
    blog post “Process Doppelgänging Meets Process Hollowing in Osiris Dropper” at
    [*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2018<wbr>/08<wbr>/process<wbr>-doppelganging<wbr>-meets<wbr>-process<wbr>-hollowing<wbr>_osiris*](https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris)).
    As with doppelganging, the malware creates a new process for the injected payload.
    However, instead of directly injecting the payload, it creates the process in
    a suspended state and maps the malicious code into memory, as in process hollowing.
    This is a good example of how security research is often used later by malware
    authors as a jumping-off point for new techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen, process image manipulation techniques rely on the exploitation
    of fundamental Windows behaviors, and they’re unlikely to go away anytime soon.
    It’s important for analysts to keep current on what’s cropping up in the wild.
    To close out this section, we’ll look at two newer process manipulation techniques.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Reimaging and
    Ghosting</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Process reimaging* is similar to the previously described techniques in that
    it relies on manipulating a currently running process to circumvent security controls.
    To execute process reimaging, the malware modifies its <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    attribute, which contains the filepath of the malware’s executable on disk, to
    point instead to a benign, legitimate executable. This technique relies on the
    fact that there are inconsistencies in the way Windows handles <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE
    _OBJECT</samp>, and as a result, some anti-malware products put too much trust
    in what’s stored in a malicious process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    location. More information on this technique can be found in the blog post “In
    NTDLL I Trust” from McAfee ([*https://<wbr>www<wbr>.mcafee<wbr>.com<wbr>/blogs<wbr>/other<wbr>-blogs<wbr>/mcafee<wbr>-labs<wbr>/in<wbr>-ntdll<wbr>-i<wbr>-trust<wbr>-process<wbr>-reimaging<wbr>-and<wbr>-endpoint<wbr>-security<wbr>-solution<wbr>-bypass<wbr>/*](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/in-ntdll-i-trust-process-reimaging-and-endpoint-security-solution-bypass/))
    and on GitHub ([*https://<wbr>github<wbr>.com<wbr>/djhohnstein<wbr>/ProcessReimaging*](https://github.com/djhohnstein/ProcessReimaging)).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Process ghosting* is most similar to process herpaderping. The malware creates
    a file and requests that Windows puts the file into a pending deletion state.
    Since there can be a delay between when the file is put into this state and when
    it’s actually deleted, the malware can write malicious executable code into the
    file and create an image object for it (copying the file content into memory)
    before Windows deletes it. Finally, the malware creates a process with the image
    object of the now-deleted file and executes it. Since Windows prevents endpoint
    defenses like anti-malware from reading and inspecting the file while it’s in
    a pending deletion state, these defenses are effectively blinded to the malicious
    code in the file. You can read more about this technique in the blog post “What
    You Need to Know About Process Ghosting” at [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/process<wbr>-ghosting<wbr>-a<wbr>-new<wbr>-executable<wbr>-image<wbr>-tampering<wbr>-attack*](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll turn to another pair of methods for injecting and covertly executing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">DLL and Shim Hijacking</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hijacking* is a general term for techniques that involve interfering with
    the normal execution flow of a program or manipulating the way Windows runs programs,
    in order to execute unauthorized code. Specifically, *DLL hijacking* exploits
    the way legitimate executables load their required libraries, in order to inject
    a malicious DLL. *Shim hijacking* involves using Windows application *shims*,
    or small libraries that intercept API calls, to inject code into an executing
    process. Let’s dig a little deeper into each technique.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL Hijacking</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All Windows applications must load DLL files at some point to function. Most
    applications have some sort of manifest that lists all the required DLLs and where
    they reside on disk. This manifest is part of the application’s DLL *search order.*
    Other possible search order locations include the application’s default install
    directory (such as *C:\Program Files\CoolApplication*), where its primary executable
    file is located, and Windows directories that house the standard Windows DLLs
    (such as *%SystemRoot%\system32*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup leaves open an interesting attack vector. Many poorly written applications
    don’t verify the contents or signature of the DLLs they’re loading; instead, they
    blindly load the required files based on their search order. Worse still, some
    poorly written applications simply load all DLLs in their install or running directory
    haphazardly. If a threat actor knows that a particular application is vulnerable
    to DLL hijacking, it could craft a specialized piece of malware that drops its
    payload in the form of a DLL to the directory from which the application is loading
    its DLLs. The actor can then simply wait for the application to start and autoload
    the DLL into memory, or it can execute the application directly and force the
    malicious DLL to load. Lastly, some malware will directly modify an application’s
    DLL search order or manifest to force a malicious DLL to load. There are several
    variations of this attack (DLL search order hijacking, sideloading, preloading,
    remote preloading, and so on), but they all have the same effect: deviously and
    silently loading a malicious DLL into the vulnerable application’s process memory
    space and executing unauthorized code.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of this attack comes from the Qbot malware family. One Qbot variant
    was delivered to a victim with a few files, most notably a malicious DLL file
    (*WindowsCodecs.dll*), a copy of an older but legitimate version of Windows Calculator
    (*calc.exe*), and a DLL called *7533.dll*. The *calc.exe* file had a curious import
    in its IAT, highlighted in [Figure 12-17](chapter12.xhtml#fig12-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-17: A curious import
    in the</samp> <samp class="SANS_Futura_Std_Book_11">calc.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    delivered from a Qbot variant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Upon execution, starting with its present location, this *calc.exe* application
    searches for *WindowsCodecs.dll*, the real version of which is a legitimate, benign
    Windows helper application. Since the malware author “helpfully” included *WindowsCodecs.dll*
    alongside the *calc.exe* file, the malicious version of the DLL is injected into
    *calc.exe* and its code is executed. [Figure 12-18](chapter12.xhtml#fig12-18)
    illustrates this attack in Procmon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-18: The malicious</samp>
    <samp class="SANS_Futura_Std_Book_11">WindowsCodecs.dll</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    being sideloaded</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This Procmon timeline export illustrates the victim executing the vulnerable
    *calc.exe* file (Process Start), which then loads the malicious *WindowsCodecs.dll*
    file (Load Image), which in turn executes another payload (*regsvr32.exe 7533.dll)*.
    The malware author knows that this particular older version of *calc.exe* is vulnerable
    to DLL hijacking because it blindly loads and executes any DLL named *WindowsCodecs.dll*
    in its running location. Very crafty indeed!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shim Hijacking</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft’s Application Compatibility framework allows for application *shimming*,
    or adding compatibility for software designed for older versions of Windows so
    that it can run on more recent versions of the OS. Developers can use shims to
    apply patches to a program without having to rewrite or recompile code. Shims
    are not only great tools for developers, though; using them is also a powerful
    method of code injection for malware. Using shims, malware can intercept API calls
    and modify their parameters. When a user starts an application, Windows starts
    the shim engine and checks to see if that application has any installed shims.
    Malware can take advantage of this behavior by abusing the shim *InjectDLL*, which,
    as its name implies, injects a DLL module into the shimmed application. Once the
    application is started via its executable file, a malicious DLL file is also loaded
    into the image of the victim application and executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A malicious actor can create a shim on the victim system by using the built-in
    Windows shim database installer tool *sdbinst.exe*. The malware invokes this tool
    and points it to the malicious shim database (*.sdb*) file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the malware installs a shim on a victim host, the shim database is installed
    in *C:\Windows\AppPatch\Custom* or *C:\Windows\AppPatch\AppPatch64\Custom\Custom64*
    (for 64-bit applications) in the form of one or more *.sdb* files. [Figure 12-19](chapter12.xhtml#fig12-19)
    shows what such a file might look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-19: An</samp> <samp
    class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    installed on a Windows system</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Installed shims typically have a registry entry in either *HKLM\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AppCompatFlags\Custom* or *HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB*,
    as shown in [Figure 12-20](chapter12.xhtml#fig12-20).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-20: Shim database
    registry entries</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: During an investigation, you can explore suspicious *.sdb* files in more detail
    by using the aptly named SDB Explorer tool, available for free from [*https://<wbr>ericzimmerman<wbr>.github<wbr>.io<wbr>/*](https://ericzimmerman.github.io/)
    and shown in [Figure 12-21](chapter12.xhtml#fig12-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-21: Analyzing an</samp>
    <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    in SDB Explorer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this output, the file seems to be shimming *chrome.exe*, *explorer.exe*,
    *firefox.exe*, and *iexplore.exe*. You can also tell that it’s using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InjectDll</samp> functionality and referencing
    a DLL file (*spvc32loader.dll*). Based on this information, we can suspect that
    this shim is targeting browser processes and attempting to inject a malicious
    DLL into their respective memory address space, which will occur when the browser
    process first executes.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of shim hijacking is documented in a report from Mandiant on
    the threat group FIN7, which was able to install the Carbanak backdoor and persist
    on the infected endpoints by registering a new shim database and patching the
    legitimate Windows *services.exe* executable. *Services.exe* is a critical system
    process and always runs when Windows first boots up. Once *services.exe* executes,
    the shim executes and launches the malicious Carbanak payload. For full details
    on the attack, see [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/fin7<wbr>-shim<wbr>-databases<wbr>-persistence*](https://www.mandiant.com/resources/fin7-shim-databases-persistence).
  prefs: []
  type: TYPE_NORMAL
- en: Shims are a multipurpose evasive mechanism. They’re a means of covertly injecting
    code to fly under the radar of endpoint defenses and investigators, as well as
    a way to establish persistence (as demonstrated by the FIN7 attack). In addition
    to these purposes, shims can serve as a rudimentary method for hooking. Let’s
    look at how hooking works.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hooking</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described in [Chapter 8](chapter8.xhtml), hooking is a technique used to
    intercept, monitor, and possibly modify Windows function calls. It has both malicious
    and legitimate applications; for example, hooking can be used by the following
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Benign applications (such as shims), to modify or patch code or to monitor a
    system or other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandboxes and other malware analysis tools, to monitor the malware’s behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint defense software, such as anti-malware and endpoint detection and response
    (EDR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyloggers and other infostealer malware, to intercept keyboard events in order
    to capture keystrokes and steal sensitive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evasive malware, to prevent its code from being detected by endpoint defenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, first we’ll discuss how hooking works in Windows before looking
    at some common hooking techniques. To wrap up the section and the chapter, we’ll
    then look at how malware can implement and inject hooks into victim processes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SetWindowsHookEx Hooking
    and Injection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the simplest ways to implement a hook is to use a Windows function designed
    specifically for that purpose: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>.
    This function allows the caller to specify which system events to hook, such as
    mouse or keyboard events, and which code to execute when an event occurs. However,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> can also
    be abused for DLL injection, as it accepts a DLL file as a parameter. The following
    simplified pseudocode illustrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    can be used to hook and stealthily run malicious code within the context of a
    victim process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, several variables are passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    as parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">idHook</samp>
    parameter can have a number of different values, each representing a system event
    to be monitored and hooked. For example, the values <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE_LL</samp> (the latter
    is shown here) will intercept mouse-related events such as clicks. Two other hooks
    commonly used by malware are <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD_LL</samp>, which
    intercept keyboard-related events.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">hmod</samp> parameter represents
    the name of the loaded module containing the malicious code that will be executed
    once a mouse event occurs. In the current example, this malware is calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, which will load the
    malicious DLL (*evil.dll*) into the victim process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpfn</samp>
    parameter represents a pointer to code that will execute when a mouse event occurs.
    In this case, the malicious function to be executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">Function_1</samp>,
    which resides in *evil.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwThreadId</samp>
    parameter represents a specific thread ID to be monitored. If the program calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> wishes to
    monitor only a single thread in a single application, it can set the thread ID
    here. If the calling program wishes to monitor all threads, it can set this parameter
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the malicious *evil.dll* file will load and execute inside the victim
    process whenever a mouse event is detected. Since the malware could potentially
    hide and wait for a very specific event to occur, such as a certain number of
    mouse clicks or a particular key being pressed, this attack can be very stealthy.
    Note, however, that this technique is rather old, and modern versions of Windows
    can prevent such an attack, not to mention that this behavior is very suspicious
    and will likely trigger endpoint defenses. Furthermore, this specific example
    will almost certainly result in a very unstable system. (Loading a DLL every time
    there’s a mouse event isn’t a wise decision!) However, variations of this technique
    are still used in modern malware, so it’s important to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Hooking</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most common forms of user-space hooking is *inline hooking*, which
    relies on injecting code into a target process and simultaneously modifying the
    legitimate function being hooked to force a jump to the injected code. First,
    the process that wishes to hook another process (the target process) must inject
    code into it by using one of the previously described methods; DLL injection is
    one of the most common. Next, the first process modifies the function it wishes
    to hook within the target process’s address space to point and jump to the injected
    hooking code. When the target process executes that function, control flow is
    transferred from the original code to the hooked code, which can then be used
    for monitoring, intercepting, or modifying calls to the original function. [Figure
    12-22](chapter12.xhtml#fig12-22) illustrates the inline hooking technique.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-22: The inline API
    hooking technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This application calls the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    which is located inside *ntdll.dll*. Normally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code inside *ntdll.dll* would then execute. However, *ntdll.dll* has been tampered
    with and its legitimate code has been overwritten with a jump instruction, so
    now the program will jump to and execute the hooking code instead. Once the malicious
    code is run, control flow is transferred back to *ntdll.dll* and finally returns
    to the original application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say our system has been infected with a malware sample that wishes to
    intercept and monitor all calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    in a victim process (*firefox.exe*, for example). After injecting the malicious
    hooking DLL into *firefox.exe*, the malware must modify the *ntdll.dll* module
    in the victim process’s address space. The malware locates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function within *ntdll.dll* and overwrites the first 5 bytes to jump to the malicious
    injected DLL instead of executing the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. (Overwriting 5 bytes is common because that’s a typical size for jump instructions.)
    The first byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp> (the jump
    instruction), is followed by 4 bytes representing the memory location to jump
    to. To modify the function code in the target process, the first process can call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>. This code block shows the
    first bytes of the legitimate <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function (in x64 assembly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the malware modifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function, it might look like this; notice the jump to the malicious code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement,
    the jump to the hooked code could be accomplished with a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When installing an inline hook, the code author often will want the original
    function code to execute after the hooked code runs in order to avoid scrutiny
    from system users. Let’s say that in our <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    example, the author wants to intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    execute the hooked code, and then execute the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. This can be accomplished in the form of a *trampoline*, which is simply
    a jump back to the original function, as shown in [Figure 12-23](chapter12.xhtml#fig12-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-23: An inline hook
    trampoline</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Trampolines are often implemented with an instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">call
    NtCreateFile+5</samp>. After the hooking code executes (inside the injected DLL,
    in this case), this instruction will transfer control flow back to the real <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, skipping over the
    first 5 bytes where the inserted <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement resides in the modified *ntdll.dll* file.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re analyzing malware, there are three function calls that can hint
    at inline hooking. First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to read the first bytes of code in the function it wishes to hook inside the target
    process. Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to modify the permissions of the target memory region and prepare for writing
    the jump instruction that will jump to the malicious code injected into the target
    process. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the jump statement into the target function’s code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Another user-space hooking technique is* IAT hooking*, which involves altering
    the import address table of the target process to point to the hooking code rather
    than to the original function code. However, IAT hooking isn’t often used by modern
    malware since it’s easily detected by host-based defenses, so I won’t go into
    more detail on this method.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mitigations for Process and Hook Injection</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As new injection and hooking techniques are used in malware or discovered by
    researchers and published, Microsoft counters them with built-in protections as
    much as possible. For example, *data execution prevention*, introduced in Windows
    XP, seeks to prevent malware from executing injected malicious code by marking
    memory regions as nonexecutable. *AppLocker*, introduced in Windows 7, prevents
    unauthorized executables (which can include injected DLLs) from executing. *Control
    Flow Guard*, released in Windows 8.1, is designed to detect whether malware modifies
    the code control flow of another process, which often takes place during process
    injection. And *Arbitrary Code Guard (ACG)*, added in Windows 10, seeks to prevent
    malware from modifying the code of legitimate processes, thus preventing certain
    types of process and hook injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, complementary defenses such as EDR and anti-malware software can
    monitor suspicious processes and detect or prevent some of these injections. Keep
    in mind, however, that not all injection is malicious: plenty of benign, legitimate
    applications use injection for various reasons, so it can be difficult for endpoint
    defense products to determine the difference between good and evil. [Chapter 13](chapter13.xhtml)
    will explore some of these endpoint defenses and how malware attempts to bypass
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed some of the common techniques malware uses to
    inject and run code within the context of other processes in order to evade endpoint
    defenses and blend in with the environment in which it’s running. We also covered
    some of the common hooks malware uses to hide its malicious behaviors or implement
    rootkit functionality. There are many types of injection and hooking techniques,
    and it’s impossible to cover them all in this book. I’ve tried to focus on those
    that you’re most likely to encounter in the wild, as well as some of the newer
    techniques that malware authors might add to their evasion toolboxes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start looking at ways in which malware can circumvent
    endpoint and network defenses to execute and hide its malicious code in a well-protected
    environment.
  prefs: []
  type: TYPE_NORMAL
