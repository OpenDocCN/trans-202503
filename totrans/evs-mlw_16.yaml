- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROCESS
    INJECTION, MANIPULATION, AND HOOKING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">进程注入、篡改和钩子</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To blend in with their target environment, modern evasive threats must remain
    hidden on the infected host. Two methods they use to do so are process injection
    and process image manipulation. *Process injection* involves injecting and executing
    nefarious code inside another process rather than executing it directly, while
    *process image manipulation* involves tampering with process images and abusing
    the way Windows handles processes. Malware can also use process injection techniques
    to inject hooks into a target process. Hooking allows the malware to intercept
    API function calls and monitor or manipulate them, helping it remain undetected.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了融入目标环境，现代的规避性威胁必须在感染的主机上保持隐藏。它们使用的两种方法是进程注入和进程镜像篡改。*进程注入*涉及将恶意代码注入并在另一个进程内执行，而不是直接执行该代码，而*进程镜像篡改*则涉及篡改进程镜像并滥用
    Windows 处理进程的方式。恶意软件还可以利用进程注入技术将钩子注入目标进程。钩子允许恶意软件拦截 API 函数调用并监控或修改它们，帮助它保持隐匿。
- en: We’ll begin this chapter by looking at different forms of process injection.
    Then, we’ll discuss two close cousins of the technique (process image manipulation
    and DLL and shim hijacking) along with various hooking methods. At the end of
    the chapter, we’ll briefly explore how to mitigate these types of attacks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过观察不同形式的进程注入开始本章内容。然后，我们将讨论该技术的两个近亲（进程镜像篡改和 DLL 及 shim 劫持）以及各种钩子方法。在本章末尾，我们将简要探讨如何缓解这些类型的攻击。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Injection</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程注入</samp>
- en: 'There are several reasons why malware might want to implement process injection
    techniques:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能想要实现进程注入技术的原因有很多：
- en: '**Hiding from defenses and investigators**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**躲避防御和调查者**'
- en: Injecting code into another process, particularly a well-known one like *notepad.exe*
    or *explorer.exe*, may help the malware persist on the infected host, hidden from
    endpoint defenses and investigators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码注入到另一个进程中，特别是像 *notepad.exe* 或 *explorer.exe* 这样的知名进程，可能有助于恶意软件在感染的主机上持久存在，且不被终端防御和调查者发现。
- en: '**Mimicking normal behavior**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模仿正常行为**'
- en: Malware might inject code into certain processes to disguise its behavior. For
    example, injecting code into a web browser and communicating with a C2 server
    from this process can help hide suspicious web traffic, as it’s normal and expected
    for web browsers to communicate with the internet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能会将代码注入到某些进程中，以伪装其行为。例如，将代码注入到一个网页浏览器中，并通过该进程与 C2 服务器进行通信，可以帮助隐藏可疑的网络流量，因为网页浏览器与互联网通信是正常且预期的。
- en: '**Thwarting debugging efforts**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻挠调试努力**'
- en: Injecting code into a remote process can help circumvent and evade tools like
    debuggers, causing the analyst to lose control of the malware’s code execution
    flow.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码注入到远程进程中，可以帮助规避和逃避调试工具，使分析师失去对恶意软件代码执行流程的控制。
- en: '**Elevating privileges**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升权限**'
- en: Specific types of process injection techniques can help malware elevate its
    privileges on the infected host, giving it a higher level of access within the
    system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的进程注入技术可以帮助恶意软件提升在感染主机上的权限，从而获得系统内更高级别的访问权限。
- en: '**Intercepting data via hooking**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过钩子拦截数据**'
- en: Injecting hooking code into a process can allow the malware to intercept and
    modify Windows API calls or intercept sensitive data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将钩子代码注入进程可以让恶意软件拦截并修改 Windows API 调用，或者拦截敏感数据。
- en: Let’s examine various process injection techniques in more detail, starting
    with how malware identifies a target process for injection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨各种进程注入技术，从恶意软件如何识别目标进程进行注入开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Random vs. Specific
    Target Processes</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">随机 vs. 特定目标进程</samp>
- en: Malware can inject code into either a random process or a specifically chosen
    target, depending on what it’s trying to achieve. For example, some malware injects
    malicious code into multiple arbitrary processes on the host to ensure its own
    survival. The malware could simply enumerate all processes on the host using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    and then attempt to open and get a handle to the target process using <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>.
    If it successfully opens the target process with its current privilege levels,
    the malware injects its code there. This approach isn’t very stealthy, however.
    A more covert approach is to inject code into specific target processes, such
    as well-known and common Windows processes, or into processes that allow the malware
    to achieve a certain objective. Certain variants of the malware family Formbook,
    for example, inject code into browser-related processes, attempting to sniff out
    sensitive data such as web logins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以将代码注入到一个随机进程中或一个特定选择的目标进程中，这取决于它试图实现的目标。例如，一些恶意软件将恶意代码注入到主机上的多个任意进程中，以确保自身的生存。恶意软件可以简单地使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    枚举主机上的所有进程，然后尝试使用<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    打开并获取目标进程的句柄。如果它成功以当前的权限级别打开目标进程，恶意软件将在其中注入其代码。然而，这种方法并不是非常隐蔽。一个更隐秘的方法是将代码注入到特定的目标进程中，例如一些著名和常见的
    Windows 进程，或者注入到允许恶意软件实现某个特定目标的进程中。例如，恶意软件家族 Formbook 的某些变种将代码注入到与浏览器相关的进程中，试图窃取敏感数据，如网页登录信息。
- en: 'Some malware might even inject code into its own process (a technique known
    as *self-injection*) or into a child process that it creates. These types of injection
    techniques often take place during the *unpacking* process, in which malware decrypts,
    or unpacks, its payload in memory and then injects it into a child process. [Chapter
    17](chapter17.xhtml) will discuss unpacking in more detail. For now, let’s look
    at one of the most basic and prevalent forms of process injection: shellcode injection.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件甚至可能将代码注入到其自身的进程中（这种技术称为*自我注入*），或者注入到它创建的子进程中。这些类型的注入技术通常发生在*解包*过程中，恶意软件在内存中解密或解包其有效负载，然后将其注入到子进程中。[第17章](chapter17.xhtml)将更详细地讨论解包过程。现在，让我们来看看最基本和最常见的进程注入形式之一：shellcode
    注入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode Injection</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shellcode 注入</samp>
- en: '*Shellcode injection*, also known as *direct injection*, is one of the oldest
    injection techniques; as its name suggests, it involves injecting *shellcode*,
    a type of position-independent machine code. Once the shellcode has been injected,
    the malware can remain hidden while executing its malicious code directly from
    within the victim process’s memory. [Figure 12-1](chapter12.xhtml#fig12-1) illustrates
    how it works.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shellcode 注入*，也称为*直接注入*，是最古老的注入技术之一；顾名思义，它涉及将*shellcode*，一种位置无关的机器代码，注入到目标进程中。一旦
    shellcode 被注入，恶意软件就可以在受害者进程的内存中直接执行其恶意代码，同时保持隐蔽。[图12-1](chapter12.xhtml#fig12-1)展示了它的工作原理。'
- en: '![](../images/fig12-1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: The shellcode
    injection technique</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：Shellcode 注入技术</samp>
- en: 'To inject the shellcode, first the malware must open an object handle to the
    target process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (or by directly calling its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> function
    has a couple of important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> parameter represents
    the access rights requested by the calling process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>
    is the ID of the target process. You can reference the function prototype information
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入 shellcode，恶意软件首先必须通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>（或直接调用其本地
    API 等效函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>）打开目标进程的对象句柄。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> 函数有一些重要的参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    参数表示调用进程请求的访问权限，<samp class="SANS_TheSansMonoCd_W5Regular_11">dwProcessId</samp>
    是目标进程的 ID。你可以参考 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    函数的原型信息，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the malware has obtained an object handle to the target process, it calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process for injecting its shellcode. (Alternatively, it could
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> function.)
    The most relevant parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function are <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>, which represent the
    starting address and the size of the region of memory being allocated, respectively.
    The prototype information for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件获得了目标进程的对象句柄，它会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在目标进程中分配内存以注入其 shellcode。（或者，它可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。）<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 函数最相关的参数是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp>，分别表示分配的内存区域的起始地址和大小。以下是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 函数的原型信息：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After allocation, the malware writes the malicious code into this fresh memory
    region using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    (or its native API equivalent, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>).
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> takes
    some important parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>,
    the handle of the process being written into; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>,
    a pointer to the base address where the data will be written; <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>,
    a pointer to a memory location that contains the data to be written; and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>, the number of bytes to be
    written into the target process’s memory. Here is the prototype information for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分配内存后，恶意软件使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>（或其本地
    API 等效函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>）将恶意代码写入这一新分配的内存区域。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 接受一些重要参数：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>，表示被写入进程的句柄；<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>，指向将要写入数据的基地址的指针；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>，指向包含要写入数据的内存位置的指针；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>，表示要写入目标进程内存的字节数。以下是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 函数的原型信息：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, after writing the malicious code into its target process, the malware
    is ready to execute it within the process context. To do so, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    (alternatively, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>) to
    create a remote thread within the process context and execute it. The most important
    parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>, a handle to
    the target process, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>,
    the starting address of the code to be executed. The function prototype for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在将恶意代码写入目标进程后，恶意软件准备在进程上下文中执行它。为此，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>（或者，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlCreateUserThread</samp>）来在进程上下文中创建一个远程线程并执行代码。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 的最重要参数是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>，即目标进程的句柄，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp>，即要执行代码的起始地址。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 的函数原型如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that this is only one of the many methods of shellcode injection and execution.
    The flow of this technique and the functions being called (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    and so on) are the basic building blocks of several techniques we’ll touch on
    in this chapter. Keep in mind as well that many of the functions listed in this
    chapter are interchangeable with other functions. For example, instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, malware might
    call the native API <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
    Instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    it could invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是众多Shellcode注入和执行方法中的一种。该技术的流程和被调用的函数（如<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>等）是我们在本章中讨论的几种技术的基本构建块。还需要记住，本章列出的许多函数可以与其他函数互换。例如，恶意软件可能会调用本地API
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>。它也可以调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>，而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>。
- en: To trace process injection, I like to use API Monitor, which allows you to quickly
    see the way the malware is injecting code and even extract the injected code.
    You can also use it to inspect the parameters of each function call in an easy-to-read
    format.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要追踪进程注入，我喜欢使用API Monitor，它可以让你快速查看恶意软件如何注入代码，甚至提取被注入的代码。你还可以使用它以易于阅读的格式检查每个函数调用的参数。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In the next section, I’ll be using a malware executable that you can download
    from VirusTotal or MalShare using the following file hash:*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*在下一节中，我将使用一个恶意软件可执行文件，你可以从VirusTotal或MalShare下载，文件哈希如下：*'
- en: 'SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: c39e675a899312f1e812d98038bb75b0c5159006e8df7a715f93f8b3ac23b625'
- en: '[Figure 12-2](chapter12.xhtml#fig12-2) shows the result of loading the malware
    sample in API Monitor and filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    functions.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-2](chapter12.xhtml#fig12-2) 显示了在API Monitor中加载恶意软件样本并过滤 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    函数的结果。'
- en: '![](../images/fig12-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Shellcode injection
    captured in API Monitor</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-2：在API Monitor中捕获的Shellcode注入</samp>
- en: As you can see, this sample begins by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    (with the <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp>
    permission and several other access permissions), then makes multiple calls to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> to allocate
    memory in the target process. The malware then writes code into that process using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> and executes
    it by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该样本首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>（具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STANDARD_RIGHTS_ALL</samp> 权限及其他几个访问权限），然后多次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 在目标进程中分配内存。接着，恶意软件通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> 将代码写入该进程，并通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> 执行它。
- en: If you inspect the buffer for the third call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you can see that the malware is writing what looks like shellcode into the target
    process (see [Figure 12-3](chapter12.xhtml#fig12-3)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查第三次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    的缓冲区，你会看到恶意软件正在将看起来像是 shellcode 的内容写入目标进程（见 [图 12-3](chapter12.xhtml#fig12-3)）。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*It takes some practice, but you can identify shellcode by inspecting the data
    and looking for bytes that represent common assembly instructions such as <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b ec</samp> (which translates
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp, esp</samp>).
    Refer back to [Chapter 3](chapter3.xhtml) for additional assembly instructions.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*这需要一些练习，但你可以通过检查数据并寻找代表常见汇编指令的字节来识别 shellcode，例如 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">8b
    ec</samp>（它代表 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov ebp,
    esp</samp>）。请回顾 [第 3 章](chapter3.xhtml) 中的其他汇编指令。*'
- en: '![](../images/fig12-3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: Shellcode injected
    into a target process</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3：注入目标进程的 shellcode</samp>
- en: 'To verify that it’s shellcode, save the data (click the Save icon in the upper-left
    corner of the hex buffer window) and then view it in a disassembler. You should
    see the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是 shellcode，保存数据（点击十六进制缓冲区窗口左上角的保存图标），然后在反汇编器中查看。你应该能看到以下内容：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because this data cleanly converts to assembly code, this indeed appears to
    be shellcode. I won’t go into this code in more detail here, but if I were analyzing
    this malware sample, I would try to understand this code’s purpose by investigating
    it further in the disassembler and then investigating it dynamically in a debugger.
    Note that in some circumstances, the disassembler may incorrectly recognize this
    as data instead of code. (Refer back to the “Disassembly” box on [page 51](chapter3.xhtml#pg_51)
    for a refresher on the code vs. data problem.) You might have to “force” the disassembler
    to read it as code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些数据可以干净地转换为汇编代码，所以这确实看起来像是 shellcode。我在这里不会详细讲解这段代码，但如果我要分析这个恶意软件样本，我会通过在反汇编器中进一步调查它，了解这段代码的目的，并在调试器中动态分析它。请注意，在某些情况下，反汇编器可能会错误地将它识别为数据，而不是代码。（参见
    [第 3 章](chapter3.xhtml) 中的“反汇编”框，以复习代码与数据的问题。）你可能需要“强制”反汇编器将其识别为代码。
- en: Before we move on, there’s something else injected into the target process worth
    noting. If you inspect the buffer for the first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>,
    you’ll see a reference to *kernel32.dll* (see [Figure 12-4](chapter12.xhtml#fig12-4)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还有一些其他内容被注入到目标进程中，值得注意。如果你检查第一次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    的缓冲区，你会看到一个指向 *kernel32.dll* 的引用（见 [图 12-4](chapter12.xhtml#fig12-4)）。
- en: '![](../images/fig12-4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The string KERNEL32.DLL
    written into memory</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：写入内存的字符串 KERNEL32.DLL</samp>
- en: 'This indicates that the sample could also be using another process injection
    technique, DLL injection, which we’ll take a look at now.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL
    Injection</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该样本可能还使用了另一种进程注入技术——DLL 注入，我们现在来看看这个技术。#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL
    注入</samp>
- en: While DLL injection is another common form of process injection, don’t be misled
    by its name. In this type of attack, the malware doesn’t physically inject a DLL
    into a target process; instead, it writes *the path* to a malicious DLL file located
    on disk into the target process and then forces the target process to load and
    execute that DLL on its behalf. [Figure 12-5](chapter12.xhtml#fig12-5) illustrates
    this technique.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DLL 注入是另一种常见的进程注入形式，但不要被它的名字误导。在这种攻击中，恶意软件并不会将一个 DLL 物理注入到目标进程中；相反，它会将恶意
    DLL 文件的*路径*写入目标进程，然后强制目标进程加载并执行该 DLL。图[12-5](chapter12.xhtml#fig12-5)展示了这种技术。
- en: '![](../images/fig12-5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The DLL injection
    technique</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5：DLL 注入技术</samp>
- en: 'The malware first drops a malicious DLL file to disk. Then, as in shellcode
    injection, it invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to get a handle to its chosen target process and uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    to allocate memory within that process. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the location of that DLL file into the process. Finally, to make the
    victim process load its DLL, the malware gets the procedural address of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and then calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> parameter set to
    that address. Once the remote thread executes, the target process calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and, in doing so, loads
    the malicious DLL. Here’s how this looks in pseudocode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将一个恶意 DLL 文件写入磁盘。然后，像 shellcode 注入一样，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    获取目标进程的句柄，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在该进程中分配内存。接下来，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    将该 DLL 文件的位置写入进程。最后，为了让目标进程加载 DLL，恶意软件获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    的过程地址，然后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>，并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lpStartAddress</samp> 参数设置为该地址。一旦远程线程执行，目标进程调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>，从而加载恶意 DLL。以下是伪代码示例：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the malicious DLL path, <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>,
    into the target process, <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>.
    Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    to get the procedural address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    function. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    passing the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    and the path to the malicious DLL as parameters. This forces the victim process
    to load the malicious DLL and execute the code within a new thread.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    将恶意 DLL 路径 <samp class="SANS_TheSansMonoCd_W5Regular_11">malicousDllName</samp>
    写入目标进程 <samp class="SANS_TheSansMonoCd_W5Regular_11">victimProcess</samp>。然后，恶意软件调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>，接着调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>，以获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp>
    函数的过程地址。最后，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> 的地址和恶意 DLL 的路径作为参数传入。这强制目标进程加载恶意
    DLL 并在新的线程中执行其中的代码。
- en: One problem with traditional DLL injection for malware authors is that the DLL
    must be loaded from disk, using the standard Windows library loading procedures.
    These standard loading procedures are monitored and easily spotted by endpoint
    defenses. A stealthier approach to DLL injection is reflective DLL injection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用传统的 DLL 注入时会遇到一个问题：DLL 必须通过标准的 Windows 库加载程序从磁盘加载。这些标准加载程序会被端点防御监控到并容易被发现。为了更隐蔽地进行
    DLL 注入，恶意软件使用反射式 DLL 注入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reflective DLL Injection</samp>
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反射式 DLL 注入</samp>
- en: In *reflective* DLL injection, the DLL is stored in memory rather than on disk,
    and the malware loads it without having to rely on the standard Windows loading
    mechanism. This makes reflective DLL injection a more covert alternative to the
    standard DLL injection method just described.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *反射式* DLL 注入中，DLL 被存储在内存中而不是磁盘上，恶意软件在加载 DLL 时不依赖于标准的 Windows 加载机制。这使得反射式 DLL
    注入成为比标准 DLL 注入方法更为隐蔽的替代方案。
- en: The initial steps of reflective DLL injection are fairly similar to the standard
    DLL injection. The malware obtains a handle to its victim process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> and allocates memory
    in that process using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>.
    However, instead of writing only the path to the DLL file, the malware copies
    the entire malicious DLL to the target process’s memory. Then, it transfers control
    flow to the newly injected DLL (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    for example), which executes the injected DLL’s “bootstrap” loader code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 反射式 DLL 注入的初步步骤与标准的 DLL 注入相似。恶意软件使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    获取受害者进程的句柄，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    在该进程中分配内存。然而，恶意软件不仅仅写入 DLL 文件的路径，而是将整个恶意 DLL 复制到目标进程的内存中。然后，它将控制流转移到新注入的 DLL（例如，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>），该 DLL
    执行注入 DLL 的“引导”加载程序代码。
- en: 'This bootstrap code is custom code that must re-create the normal Windows DLL
    loading process. At a high level, these are the steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该引导代码是自定义代码，必须重新创建正常的 Windows DLL 加载过程。从高层次看，这些步骤如下：
- en: 1.  The bootstrap code calculates its own image location in memory and performs
    its own image base relocations, which means realigning the hardcoded addresses
    in the executable code to match its current location in memory. The loader also
    finds the location of the injected DLL’s PEB.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  引导代码计算其自身在内存中的镜像位置，并执行自身的镜像基址重定位，这意味着将可执行代码中的硬编码地址重新对齐，以匹配其当前在内存中的位置。加载程序还会找到注入的
    DLL 的 PEB 位置。
- en: 2.  The bootstrap code parses the exports table of *kernel32.dll* to locate
    the addresses of <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    and other fundamental functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  引导代码解析 *kernel32.dll* 的导出表，以定位 <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    和其他基础函数的地址。
- en: 3.  The malicious DLL has now been successfully loaded inside the victim process
    and is ready to run. To execute the DLL’s malicious code, malware typically invokes
    a function in the DLL’s exports table, such as the function shown in [Figure 12-6](chapter12.xhtml#fig12-6).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  恶意 DLL 现在已成功加载到受害者进程中，并准备运行。为了执行 DLL 的恶意代码，恶意软件通常会调用 DLL 导出表中的某个函数，例如在 [图
    12-6](chapter12.xhtml#fig12-6) 中显示的函数。
- en: '![](../images/fig12-6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The DLL export
    function</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：DLL 导出函数</samp>
- en: The malware shown here was generated with the popular penetration testing tool
    Cobalt Strike and has <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp>
    as the default export function. Once this export function is invoked, the malicious
    code is executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此处显示的恶意软件是使用流行的渗透测试工具 Cobalt Strike 生成的，默认导出函数为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReflectiveLoader@4</samp>。一旦调用此导出函数，恶意代码就会被执行。
- en: '[Figure 12-7](chapter12.xhtml#fig12-7) illustrates a typical reflective DLL
    injection attack.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-7](chapter12.xhtml#fig12-7) 展示了典型的反射式 DLL 注入攻击。'
- en: '![](../images/fig12-7.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The reflective
    DLL injection technique</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-7：反射式 DLL 注入技术</samp>
- en: In this figure, the running malware downloads its DLL payload from a staging
    server controlled by the attacker ❶, which is then temporarily stored in the malware’s
    process memory space ❷. (Note that this technique does not always rely on a remote
    staging server, but we’ll touch on that in a moment.) Next, the bootstrap code
    is injected into a target process along with the DLL ❸, then executed by the malware.
    The bootstrap code performs the manual DLL loading process and then calls the
    export function of the injected DLL, which executes the malicious code in the
    context of the target process ❹. You can read more about reflective DLL injection
    from the original author of the technique at [*https://<wbr>github<wbr>.com<wbr>/stephenfewer<wbr>/ReflectiveDLLInjection*](https://github.com/stephenfewer/ReflectiveDLLInjection).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，正在运行的恶意软件从攻击者控制的暂存服务器下载其DLL负载 ❶，然后暂时存储在恶意软件的进程内存空间中 ❷。（请注意，这种技术并不总是依赖于远程暂存服务器，但稍后我们会讨论这一点。）接下来，启动代码与DLL一起注入目标进程
    ❸，并由恶意软件执行。启动代码执行手动DLL加载过程，然后调用注入DLL的导出函数，在目标进程的上下文中执行恶意代码 ❹。你可以阅读关于反射式DLL注入的更多信息，原作者的资料可以在[*https://<wbr>github<wbr>.com<wbr>/stephenfewer<wbr>/ReflectiveDLLInjection*](https://github.com/stephenfewer/ReflectiveDLLInjection)中找到。
- en: Reflective DLL injection, as with many of the injection methods I discuss throughout
    this chapter, can be subdivided into so-called staged and stageless techniques.
    The technique just presented is considered *staged*, as the payload to be injected
    is hosted and downloaded from the attacker’s staging server. In *stageless* reflective
    DLL injection, the payload is already embedded in the original malware executable
    before being unpacked and injected into the target process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 反射式DLL注入，像本章中我讨论的许多注入方法一样，可以细分为所谓的分阶段（staged）和无阶段（stageless）技术。刚才介绍的技术被认为是*分阶段*的，因为要注入的负载是从攻击者的暂存服务器上托管并下载的。而在*无阶段*的反射式DLL注入中，负载已经嵌入到原始恶意软件可执行文件中，然后解压并注入到目标进程中。
- en: A similar technique, sometimes called *shellcode reflective injection*, involves
    converting a DLL into shellcode and then injecting it into a target process. I
    won’t cover this technique further since it combines techniques you’ve already
    seen, but you can read more about it at [*https://<wbr>github<wbr>.com<wbr>/monoxgas<wbr>/sRDI*](https://github.com/monoxgas/sRDI).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类似的技术，有时被称为*Shellcode反射注入*，涉及将DLL转换为Shellcode，然后将其注入目标进程。我不会进一步介绍这种技术，因为它结合了你已经看到的技术，但你可以在[*https://<wbr>github<wbr>.com<wbr>/monoxgas<wbr>/sRDI*](https://github.com/monoxgas/sRDI)中阅读更多信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Hollowing</samp>
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程空洞技术</samp>
- en: '*Process hollowing* (sometimes called *RunPE*, *process replacement*, or *hollowed
    process injection*) involves unmapping code from a target process’s memory and
    then remapping malicious code there. Process hollowing is a bit different from
    the other injection techniques we’ve seen so far, as it doesn’t usually involve
    an arbitrary remote process. Instead, the malware starts a new process (often
    a trusted executable, such as our beloved *Calculator.exe*), unmaps the legitimate
    code, and remaps malicious code in a suspended state, at which point the malware
    executes the malicious code. This hides the malicious code from the prying eyes
    of endpoint defenses and investigators, disguising it as a normal process. [Figure
    12-8](chapter12.xhtml#fig12-8) illustrates the technique.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程空洞技术*（有时被称为*RunPE*、*进程替换*或*空洞进程注入*）涉及从目标进程的内存中卸载代码，然后将恶意代码重新映射到那里。进程空洞与我们之前看到的其他注入技术有所不同，因为它通常不涉及任意的远程进程。相反，恶意软件启动一个新进程（通常是一个受信任的可执行文件，如我们熟悉的*Calculator.exe*），卸载合法代码，然后在挂起状态下重新映射恶意代码，此时恶意软件执行恶意代码。这种方式将恶意代码隐藏在端点防御和调查者的视线之外，伪装成一个正常的进程。[图12-8](chapter12.xhtml#fig12-8)展示了这一技术。'
- en: '![](../images/fig12-8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The process-hollowing
    technique</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-8：进程空洞技术</samp>
- en: This malware sample begins by creating a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    and then sets the process creation flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>
    (not shown); this starts the new process in a suspended state. Next, the malware
    “hollows out” the newly created process by unmapping its legitimate code with
    the function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>.
    Then, the malware allocates a new region of memory for its malicious code using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and writes (maps)
    its payload here using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>.
    Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> to point
    the current thread to the newly injected code and resume thread execution, respectively,
    which runs the malicious code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this in practice, using a variant of the ransomware family
    Satan (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: cbbd2bd6f98bd819f3860dea78f812d5c180fd19924cef32e94B
    d7f6929023779</samp>). The screen capture from API Monitor in [Figure 12-9](chapter12.xhtml#fig12-9)
    shows a malware sample (a variant of the Satan ransomware family) using the process-hollowing
    technique.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-9.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: A malware sample
    using the process-hollowing technique</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this malware starts a new process with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp>
    from an executable on disk (*financialz.exe*) in a suspended state (<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>),
    as just discussed. Then, it makes multiple calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>
    to map data into the new target process. Inspecting this function call further
    in API Monitor reveals that this malware sample is writing a PE file into the
    target process, then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>
    to execute it (see [Figure 12-10](chapter12.xhtml#fig12-10)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: The PE header
    in memory</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Note that while process hollowing is typically classified as a process injection
    technique, it’s not a true injection technique, since it relies on the malware
    spawning a new process in a suspended state and then replacing the process’s preexisting
    code with malicious code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Hijacking</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Thread hijacking* involves opening a running thread in a victim process, writing
    malicious code into that thread, and forcing the victim process to execute the
    code. Thread hijacking shares many of the functions used in the process-hollowing
    technique, but there are a few notable differences. To execute thread hijacking,
    the malware invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>
    function, specifying a thread ID as a parameter, and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp> for
    64-bit processes) to suspend the victim thread. Once the thread is in a suspended
    state, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, respectively,
    to allocate memory in the target process and write its malicious code there. Finally,
    the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    to transfer control flow from the currently suspended thread to the newly injected
    malicious code, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>
    to execute the code.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程劫持*涉及在受害者进程中打开一个正在运行的线程，将恶意代码写入该线程，并强制受害者进程执行该代码。线程劫持与进程空洞技术使用的许多功能相同，但也有一些显著的区别。为了执行线程劫持，恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>函数，指定线程ID作为参数，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SuspendThread</samp>（对于64位进程，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SuspendThread</samp>）来挂起受害线程。一旦线程处于挂起状态，恶意软件使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>分别分配目标进程中的内存并将恶意代码写入其中。最后，恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>将控制流从当前挂起的线程转移到新注入的恶意代码，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>执行该代码。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC Injection</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">APC注入</samp>
- en: An *asynchronous procedure call (APC)* is a Windows feature that allows for
    various tasks to be queued and executed in the context of a running thread. A
    program might invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    function, passing both the handle to the thread and a pointer to the code that
    the program wishes to run, to add that task to the APC queue. *APC injection*
    abuses this functionality to stealthily execute code and, potentially, elevate
    privileges.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步过程调用（APC）*是Windows的一项功能，允许将各种任务排队并在运行线程的上下文中执行。程序可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>函数，传递线程的句柄和程序希望执行的代码的指针，将该任务添加到APC队列中。*APC注入*滥用此功能，悄悄执行代码，并可能提升权限。'
- en: For a program to be able to call functions in the APC queue, the thread must
    be in an *alertable* state, meaning the thread periodically checks for new items
    in the queue and runs the next queued task. Many processes running on the system,
    from web browsers to video players, have threads running in alertable states.
    Generally, such threads eventually receive an interrupt request from the operating
    system, at which point the process will inspect the APC queue and run the next
    queued task.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序能够调用APC队列中的函数，线程必须处于*可警觉*状态，这意味着线程会定期检查队列中的新项并执行下一个排队的任务。许多系统上运行的进程，从Web浏览器到视频播放器，都有在可警觉状态下运行的线程。通常，此类线程最终会收到操作系统的中断请求，此时进程会检查APC队列并运行下一个排队的任务。
- en: Malware takes advantage of APC functionality by attempting to inject malicious
    code into other processes via APC queuing. [Figure 12-11](chapter12.xhtml#fig12-11)
    illustrates this attack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过尝试通过APC排队将恶意代码注入到其他进程中，利用了APC功能。[图12-11](chapter12.xhtml#fig12-11)展示了这种攻击。
- en: '![](../images/fig12-11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: The APC injection
    technique</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-11：APC注入技术</samp>
- en: This malware first gets a handle to its target victim process in the usual way
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>) and writes
    the malicious code to be executed into the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>).
    Next, it opens a target thread by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenThread</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">QueueUserAPC</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) to
    queue a new APC task. Whenever the thread receives an interrupt request from the
    operating system, this malicious code will be executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: A variation of this technique creates a new process in a suspended state (similar
    to process hollowing) and writes the malicious code into it. Then, the malware
    queues its APC function and resumes the thread. Once the thread resumes, the malicious
    code will be executed. At this point, the malware can terminate its original process,
    as its payload is now running under a new process and may go unnoticed by endpoint
    defenses and unaware end users. [Figure 12-12](chapter12.xhtml#fig12-12) shows
    this attack, captured in API Monitor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-12.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Malware using
    a variation of the APC injection technique</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This malware sample uses APC injection to run malicious code in the context
    of the *iexplore.exe* process. In this case, the malware starts *iexplore.exe*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>) instead
    of hijacking another process (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Atom Bombing</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The last process injection technique we’ll cover in this chapter is *atom bombing*,
    which shares some features of APC injection but involves *atoms*, references to
    specific pieces of data such as strings. Atoms are stored in an OS structure known
    as the *atom table*, and each atom has a unique atom identifier. Atoms are often
    used in interprocess communication to coordinate actions between processes. For
    example, Process A might create an atom to indicate that a particular piece of
    data is available, and Process B can use that atom to access the data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Atom tables can be global (that is, accessible from any process running on the
    system) or local (accessible to only one specific process). To add data to the
    global atom table, an application invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>
    function; to add an atom to a local table, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddAtom</samp>
    function. Atom bombing abuses these atom tables to temporarily store malicious
    code. [Figure 12-13](chapter12.xhtml#fig12-13) illustrates this attack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: The atom bombing
    technique</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-13: 原子轰炸技术</samp>'
- en: At a high level, this technique creates a new global atom (<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>)
    in the global atom table, where it stores malicious shellcode ❶ and uses APC queuing
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>) ❷ to force
    the victim process into executing <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp>
    ❸. Once the atom is retrieved by the victim process, the shellcode stored in the
    atom table can be run in that process’s context ❹.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这种技术在全局原子表中创建了一个新的全局原子（<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalAddAtom</samp>），在其中存储恶意
    shellcode ❶，并使用 APC 排队（<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp>）
    ❷ 强制受害者进程执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalGetAtomName</samp>
    ❸。一旦受害者进程检索到该原子，存储在原子表中的 shellcode 就可以在该进程的上下文中运行 ❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection
    Wrap-up</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程注入总结</samp>
- en: As you’ve seen, many process injection techniques use the same API function
    calls and behave similarly. Nearly all process injection techniques create a process
    or open a handle to a target process, allocate memory and write or map code into
    the target process, and then force the injected code to execute in the context
    of the target process, as summarized in [Figure 12-14](chapter12.xhtml#fig12-14).
    (Special thanks to malware researcher Karsten Hahn, who inspired this image.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，许多进程注入技术使用相同的 API 函数调用，并且表现类似。几乎所有的进程注入技术都会创建一个进程或打开一个目标进程的句柄，分配内存并将代码写入或映射到目标进程中，然后强制注入的代码在目标进程的上下文中执行，正如
    [图 12-14](chapter12.xhtml#fig12-14) 中总结的那样。（特别感谢恶意软件研究员 Karsten Hahn，他为此图提供了灵感。）
- en: '![](../images/fig12-14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-14.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: A summary of
    process injection behaviors and API calls</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-14: 进程注入行为和 API 调用总结</samp>'
- en: 'Now that we’ve looked at various process injection techniques, let’s pivot
    to another method used for similar purposes: process image manipulation.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种进程注入技术，让我们转向另一种用于类似目的的方法：进程映像篡改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Image Manipulation</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程映像篡改</samp>
- en: '*Process image manipulation* abuses both the standard Windows process creation
    routine and the way endpoint defenses (specifically, anti-malware software) operate.
    To defend a system from malware attacks, anti-malware software needs to know when
    a new process is started in order to monitor it for suspect behaviors. This is
    where the API function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    comes in. When a new process is created, this function sends notification messages
    to endpoint defense software, which then inspects and scans the originating executable
    file that started the process. If the anti-malware software sees that the executable
    file contains malicious code, it can quarantine the file and terminate any associated
    processes. The problem is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    is invoked not at the exact moment of a process’s creation, but rather on the
    creation and execution of the first few threads running within the process context.
    This gives malware a nice window of opportunity to modify the original executable
    file before anti-malware solutions have time to scan it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程映像篡改* 滥用标准的 Windows 进程创建例程和端点防御（特别是反恶意软件软件）运作方式。为了防御恶意软件攻击，反恶意软件软件需要知道何时启动新进程，以便监视其可疑行为。这时
    API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    就派上了用场。当新进程被创建时，该函数会向端点防御软件发送通知消息，防御软件随后会检查并扫描启动该进程的原始可执行文件。如果反恶意软件软件发现可执行文件包含恶意代码，它可以将文件隔离并终止任何相关的进程。问题是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    不是在进程创建的确切时刻被调用，而是在进程上下文中运行的前几个线程被创建并执行时调用。这给了恶意软件一个机会，可以在反恶意软件解决方案扫描文件之前修改原始可执行文件。'
- en: 'Process manipulation also involves interfering with the way Windows creates
    processes (as described in [Chapter 1](chapter1.xhtml)). In essence, Windows usually
    calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>,
    a kernel function that handles the details of process creation and then maps processes
    into memory by executing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 进程操作还涉及干扰 Windows 创建进程的方式（如[第 1 章](chapter1.xhtml)所述）。本质上，Windows 通常会调用一个函数，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>，这是一个内核函数，负责处理进程创建的细节，然后通过执行以下步骤将进程映射到内存中：
- en: 1.  Obtain a handle to an executable file (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>,
    for example).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  获取可执行文件的句柄（例如，通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>）。
- en: 2.  Create a section object for the file, typically by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    function. In this case, a *section* is simply an object that will be mapped into
    memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  为文件创建一个节对象，通常通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>函数。在这种情况下，*节*只是一个将被映射到内存中的对象。
- en: 3.  Create a process object by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    with a parameter referencing the newly created section object, mapping the process
    object into memory as a new process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>并传递一个引用新创建的节对象的参数，创建一个进程对象，将进程对象映射到内存中作为一个新进程。
- en: 4.  Execute the process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>
    to create and start a new thread.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>来执行该进程，创建并启动一个新线程。
- en: Let’s take a look at how different process manipulation techniques are used
    to interfere with these steps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用不同的进程操作技术来干扰这些步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Herpaderping</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程混淆</samp>
- en: '*Process herpaderping* has a funny name but packs a powerful punch. It confuses
    the operating system and anti-malware solutions by interfering with the way Windows
    creates processes. [Figure 12-15](chapter12.xhtml#fig12-15) illustrates how this
    technique works.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程混淆*这个名字听起来有趣，但它威力十足。通过干扰 Windows 创建进程的方式，它使操作系统和反恶意软件解决方案感到困惑。[图 12-15](chapter12.xhtml#fig12-15)展示了该技术是如何工作的。'
- en: '![](../images/fig12-15.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-15.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: The process-herpaderping
    technique</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-15：进程混淆技术</samp>
- en: This malware first creates a new file on disk and obtains a handle to it, keeping
    that handle open ❶. It writes malicious executable code into this empty file,
    then creates a section object for the file ❷. Next, it creates a process using
    the new section object ❸. The malicious code is now mapped into memory, but it
    isn’t executing yet. So far, this approach follows the standard Windows PE loading
    steps, but things are about to get interesting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件首先在磁盘上创建一个新文件并获取其句柄，保持该句柄打开 ❶。它将恶意可执行代码写入此空文件，然后为该文件创建一个节对象 ❷。接下来，它使用这个新创建的节对象来创建一个进程
    ❸。恶意代码现在已经映射到内存中，但还没有执行。到目前为止，这个方法遵循标准的 Windows PE 加载步骤，但接下来会变得有趣。
- en: The malware modifies or removes the malicious code within the file it created
    on disk ❹. It then starts a new thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp>),
    which executes the malicious code in memory, and closes the handle to the open
    file. At this point, the aforementioned <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutineEx</samp>
    callback will occur and endpoint defenses will kick in, inspecting the malicious
    file. However, since the malicious file in fact no longer contains malicious code,
    the anti-malware software is tricked into thinking all is well. Anti-malware software,
    as well as Windows itself, assumes that a file on disk can’t (or shouldn’t) be
    modified when it’s already mapped into memory and running inside a process. Process
    herpaderping takes advantage of such assumptions to execute malicious code. You
    can find out more about this technique from its author at [*https://<wbr>jxy<wbr>-s<wbr>.github<wbr>.io<wbr>/herpaderping<wbr>/*](https://jxy-s.github.io/herpaderping/).
    If you’d like to test it yourself, you can explore the proof of concept at [*https://<wbr>github<wbr>.com<wbr>/jxy<wbr>-s<wbr>/herpaderping*](https://github.com/jxy-s/herpaderping).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Doppelganging</samp>
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Process doppelganging*, first presented at Black Hat 2017 by security researchers
    Eugene Kogan and Tal Liberman, is a manipulation technique that uses Transactional
    NTFS to hide malicious code execution. The term *doppelganging* originates from
    the word *doppelganger*, which is commonly used to describe a person with an uncanny
    resemblance to someone else. *Transactional NTFS* was designed to add extra features
    and support (like file integrity preservation and better error handling) to NTFS,
    the default filesystem in Windows. It allows the use of *transactions*, which
    track changes to the filesystem that can be rolled back when necessary. Actions
    like file deletion first occur virtually. If the file deletion request succeeds,
    the transaction is committed and the file is actually deleted. If the file deletion
    request results in an error, however, the transaction is rolled back and no action
    occurs. Ultimately, transactions seek to prevent data inconsistency and corruption
    resulting from a system failure or other unexpected event.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: A new file created with transactions normally can’t be accessed from outside
    the process currently interacting with it; even certain anti-malware solutions
    can’t access it in this case. For this reason, transactions can provide a safe
    location for a malicious file to temporarily hide. And since transacted files
    can be “rolled back” to a previous state, endpoint defenses can easily become
    confused. This is exactly why process doppelganging is effective. [Figure 12-16](chapter12.xhtml#fig12-16)
    illustrates how this technique works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: The process-doppelganging
    technique</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This malware creates a new NTFS transaction using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateTransaction</samp>
    and opens an existing executable file using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFileTransacted</samp>
    ❶. (It could instead call lower-level functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateTransaction</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetCurrentTransaction</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwCreateFile</samp> to achieve
    the same effect.) Next, the malware writes its malicious code into the existing
    PE file (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>), which
    will replace the original executable’s code ❷. The malware then executes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>
    to create a new process, passing the location of the new malicious PE file (the
    doppelganger) as a parameter ❸. Once the PE file is mapped into memory and the
    malicious process is running, the malware deliberately rolls back the original
    NTFS transaction (<samp class="SANS_TheSansMonoCd_W5Regular_11">RollbackTransaction</samp>),
    returning the file to its original, preinfected state ❹. When the anti-malware
    software is notified of the process creation and scans the process’s executable
    file on disk, it’s too late; the original executable file has already been rolled
    back to its nonmalicious state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A few variations of the process-doppelganging technique have emerged since it
    was first published in 2017\. One variant, dubbed *transacted hollowing* by researchers
    at Malwarebytes, combines process hollowing with process doppelganging (see the
    blog post “Process Doppelgänging Meets Process Hollowing in Osiris Dropper” at
    [*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2018<wbr>/08<wbr>/process<wbr>-doppelganging<wbr>-meets<wbr>-process<wbr>-hollowing<wbr>_osiris*](https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris)).
    As with doppelganging, the malware creates a new process for the injected payload.
    However, instead of directly injecting the payload, it creates the process in
    a suspended state and maps the malicious code into memory, as in process hollowing.
    This is a good example of how security research is often used later by malware
    authors as a jumping-off point for new techniques.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen, process image manipulation techniques rely on the exploitation
    of fundamental Windows behaviors, and they’re unlikely to go away anytime soon.
    It’s important for analysts to keep current on what’s cropping up in the wild.
    To close out this section, we’ll look at two newer process manipulation techniques.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Reimaging and
    Ghosting</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '*Process reimaging* is similar to the previously described techniques in that
    it relies on manipulating a currently running process to circumvent security controls.
    To execute process reimaging, the malware modifies its <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    attribute, which contains the filepath of the malware’s executable on disk, to
    point instead to a benign, legitimate executable. This technique relies on the
    fact that there are inconsistencies in the way Windows handles <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE
    _OBJECT</samp>, and as a result, some anti-malware products put too much trust
    in what’s stored in a malicious process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    location. More information on this technique can be found in the blog post “In
    NTDLL I Trust” from McAfee ([*https://<wbr>www<wbr>.mcafee<wbr>.com<wbr>/blogs<wbr>/other<wbr>-blogs<wbr>/mcafee<wbr>-labs<wbr>/in<wbr>-ntdll<wbr>-i<wbr>-trust<wbr>-process<wbr>-reimaging<wbr>-and<wbr>-endpoint<wbr>-security<wbr>-solution<wbr>-bypass<wbr>/*](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/in-ntdll-i-trust-process-reimaging-and-endpoint-security-solution-bypass/))
    and on GitHub ([*https://<wbr>github<wbr>.com<wbr>/djhohnstein<wbr>/ProcessReimaging*](https://github.com/djhohnstein/ProcessReimaging)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*Process ghosting* is most similar to process herpaderping. The malware creates
    a file and requests that Windows puts the file into a pending deletion state.
    Since there can be a delay between when the file is put into this state and when
    it’s actually deleted, the malware can write malicious executable code into the
    file and create an image object for it (copying the file content into memory)
    before Windows deletes it. Finally, the malware creates a process with the image
    object of the now-deleted file and executes it. Since Windows prevents endpoint
    defenses like anti-malware from reading and inspecting the file while it’s in
    a pending deletion state, these defenses are effectively blinded to the malicious
    code in the file. You can read more about this technique in the blog post “What
    You Need to Know About Process Ghosting” at [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/process<wbr>-ghosting<wbr>-a<wbr>-new<wbr>-executable<wbr>-image<wbr>-tampering<wbr>-attack*](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll turn to another pair of methods for injecting and covertly executing
    code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">DLL and Shim Hijacking</samp>
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hijacking* is a general term for techniques that involve interfering with
    the normal execution flow of a program or manipulating the way Windows runs programs,
    in order to execute unauthorized code. Specifically, *DLL hijacking* exploits
    the way legitimate executables load their required libraries, in order to inject
    a malicious DLL. *Shim hijacking* involves using Windows application *shims*,
    or small libraries that intercept API calls, to inject code into an executing
    process. Let’s dig a little deeper into each technique.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">DLL Hijacking</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All Windows applications must load DLL files at some point to function. Most
    applications have some sort of manifest that lists all the required DLLs and where
    they reside on disk. This manifest is part of the application’s DLL *search order.*
    Other possible search order locations include the application’s default install
    directory (such as *C:\Program Files\CoolApplication*), where its primary executable
    file is located, and Windows directories that house the standard Windows DLLs
    (such as *%SystemRoot%\system32*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup leaves open an interesting attack vector. Many poorly written applications
    don’t verify the contents or signature of the DLLs they’re loading; instead, they
    blindly load the required files based on their search order. Worse still, some
    poorly written applications simply load all DLLs in their install or running directory
    haphazardly. If a threat actor knows that a particular application is vulnerable
    to DLL hijacking, it could craft a specialized piece of malware that drops its
    payload in the form of a DLL to the directory from which the application is loading
    its DLLs. The actor can then simply wait for the application to start and autoload
    the DLL into memory, or it can execute the application directly and force the
    malicious DLL to load. Lastly, some malware will directly modify an application’s
    DLL search order or manifest to force a malicious DLL to load. There are several
    variations of this attack (DLL search order hijacking, sideloading, preloading,
    remote preloading, and so on), but they all have the same effect: deviously and
    silently loading a malicious DLL into the vulnerable application’s process memory
    space and executing unauthorized code.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: An example of this attack comes from the Qbot malware family. One Qbot variant
    was delivered to a victim with a few files, most notably a malicious DLL file
    (*WindowsCodecs.dll*), a copy of an older but legitimate version of Windows Calculator
    (*calc.exe*), and a DLL called *7533.dll*. The *calc.exe* file had a curious import
    in its IAT, highlighted in [Figure 12-17](chapter12.xhtml#fig12-17).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-17.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-17: A curious import
    in the</samp> <samp class="SANS_Futura_Std_Book_11">calc.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    delivered from a Qbot variant</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Upon execution, starting with its present location, this *calc.exe* application
    searches for *WindowsCodecs.dll*, the real version of which is a legitimate, benign
    Windows helper application. Since the malware author “helpfully” included *WindowsCodecs.dll*
    alongside the *calc.exe* file, the malicious version of the DLL is injected into
    *calc.exe* and its code is executed. [Figure 12-18](chapter12.xhtml#fig12-18)
    illustrates this attack in Procmon.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-18.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-18: The malicious</samp>
    <samp class="SANS_Futura_Std_Book_11">WindowsCodecs.dll</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    being sideloaded</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: This Procmon timeline export illustrates the victim executing the vulnerable
    *calc.exe* file (Process Start), which then loads the malicious *WindowsCodecs.dll*
    file (Load Image), which in turn executes another payload (*regsvr32.exe 7533.dll)*.
    The malware author knows that this particular older version of *calc.exe* is vulnerable
    to DLL hijacking because it blindly loads and executes any DLL named *WindowsCodecs.dll*
    in its running location. Very crafty indeed!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Shim Hijacking</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft’s Application Compatibility framework allows for application *shimming*,
    or adding compatibility for software designed for older versions of Windows so
    that it can run on more recent versions of the OS. Developers can use shims to
    apply patches to a program without having to rewrite or recompile code. Shims
    are not only great tools for developers, though; using them is also a powerful
    method of code injection for malware. Using shims, malware can intercept API calls
    and modify their parameters. When a user starts an application, Windows starts
    the shim engine and checks to see if that application has any installed shims.
    Malware can take advantage of this behavior by abusing the shim *InjectDLL*, which,
    as its name implies, injects a DLL module into the shimmed application. Once the
    application is started via its executable file, a malicious DLL file is also loaded
    into the image of the victim application and executed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'A malicious actor can create a shim on the victim system by using the built-in
    Windows shim database installer tool *sdbinst.exe*. The malware invokes this tool
    and points it to the malicious shim database (*.sdb*) file like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the malware installs a shim on a victim host, the shim database is installed
    in *C:\Windows\AppPatch\Custom* or *C:\Windows\AppPatch\AppPatch64\Custom\Custom64*
    (for 64-bit applications) in the form of one or more *.sdb* files. [Figure 12-19](chapter12.xhtml#fig12-19)
    shows what such a file might look like.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-19: An</samp> <samp
    class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    installed on a Windows system</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Installed shims typically have a registry entry in either *HKLM\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AppCompatFlags\Custom* or *HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB*,
    as shown in [Figure 12-20](chapter12.xhtml#fig12-20).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-20: Shim database
    registry entries</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: During an investigation, you can explore suspicious *.sdb* files in more detail
    by using the aptly named SDB Explorer tool, available for free from [*https://<wbr>ericzimmerman<wbr>.github<wbr>.io<wbr>/*](https://ericzimmerman.github.io/)
    and shown in [Figure 12-21](chapter12.xhtml#fig12-21).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-21.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-21: Analyzing an</samp>
    <samp class="SANS_Futura_Std_Book_11">.sdb</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    in SDB Explorer</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this output, the file seems to be shimming *chrome.exe*, *explorer.exe*,
    *firefox.exe*, and *iexplore.exe*. You can also tell that it’s using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InjectDll</samp> functionality and referencing
    a DLL file (*spvc32loader.dll*). Based on this information, we can suspect that
    this shim is targeting browser processes and attempting to inject a malicious
    DLL into their respective memory address space, which will occur when the browser
    process first executes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A good example of shim hijacking is documented in a report from Mandiant on
    the threat group FIN7, which was able to install the Carbanak backdoor and persist
    on the infected endpoints by registering a new shim database and patching the
    legitimate Windows *services.exe* executable. *Services.exe* is a critical system
    process and always runs when Windows first boots up. Once *services.exe* executes,
    the shim executes and launches the malicious Carbanak payload. For full details
    on the attack, see [*https://<wbr>www<wbr>.mandiant<wbr>.com<wbr>/resources<wbr>/fin7<wbr>-shim<wbr>-databases<wbr>-persistence*](https://www.mandiant.com/resources/fin7-shim-databases-persistence).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Shims are a multipurpose evasive mechanism. They’re a means of covertly injecting
    code to fly under the radar of endpoint defenses and investigators, as well as
    a way to establish persistence (as demonstrated by the FIN7 attack). In addition
    to these purposes, shims can serve as a rudimentary method for hooking. Let’s
    look at how hooking works.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hooking</samp>
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described in [Chapter 8](chapter8.xhtml), hooking is a technique used to
    intercept, monitor, and possibly modify Windows function calls. It has both malicious
    and legitimate applications; for example, hooking can be used by the following
    applications:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Benign applications (such as shims), to modify or patch code or to monitor a
    system or other applications
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandboxes and other malware analysis tools, to monitor the malware’s behaviors
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint defense software, such as anti-malware and endpoint detection and response
    (EDR)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyloggers and other infostealer malware, to intercept keyboard events in order
    to capture keystrokes and steal sensitive data
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evasive malware, to prevent its code from being detected by endpoint defenses
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, first we’ll discuss how hooking works in Windows before looking
    at some common hooking techniques. To wrap up the section and the chapter, we’ll
    then look at how malware can implement and inject hooks into victim processes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">SetWindowsHookEx Hooking
    and Injection</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the simplest ways to implement a hook is to use a Windows function designed
    specifically for that purpose: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>.
    This function allows the caller to specify which system events to hook, such as
    mouse or keyboard events, and which code to execute when an event occurs. However,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> can also
    be abused for DLL injection, as it accepts a DLL file as a parameter. The following
    simplified pseudocode illustrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    can be used to hook and stealthily run malicious code within the context of a
    victim process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, several variables are passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp>
    as parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">idHook</samp>
    parameter can have a number of different values, each representing a system event
    to be monitored and hooked. For example, the values <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_MOUSE_LL</samp> (the latter
    is shown here) will intercept mouse-related events such as clicks. Two other hooks
    commonly used by malware are <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WH_KEYBOARD_LL</samp>, which
    intercept keyboard-related events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">hmod</samp> parameter represents
    the name of the loaded module containing the malicious code that will be executed
    once a mouse event occurs. In the current example, this malware is calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, which will load the
    malicious DLL (*evil.dll*) into the victim process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpfn</samp>
    parameter represents a pointer to code that will execute when a mouse event occurs.
    In this case, the malicious function to be executed is <samp class="SANS_TheSansMonoCd_W5Regular_11">Function_1</samp>,
    which resides in *evil.dll*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwThreadId</samp>
    parameter represents a specific thread ID to be monitored. If the program calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> wishes to
    monitor only a single thread in a single application, it can set the thread ID
    here. If the calling program wishes to monitor all threads, it can set this parameter
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the malicious *evil.dll* file will load and execute inside the victim
    process whenever a mouse event is detected. Since the malware could potentially
    hide and wait for a very specific event to occur, such as a certain number of
    mouse clicks or a particular key being pressed, this attack can be very stealthy.
    Note, however, that this technique is rather old, and modern versions of Windows
    can prevent such an attack, not to mention that this behavior is very suspicious
    and will likely trigger endpoint defenses. Furthermore, this specific example
    will almost certainly result in a very unstable system. (Loading a DLL every time
    there’s a mouse event isn’t a wise decision!) However, variations of this technique
    are still used in modern malware, so it’s important to be aware of it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inline Hooking</samp>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most common forms of user-space hooking is *inline hooking*, which
    relies on injecting code into a target process and simultaneously modifying the
    legitimate function being hooked to force a jump to the injected code. First,
    the process that wishes to hook another process (the target process) must inject
    code into it by using one of the previously described methods; DLL injection is
    one of the most common. Next, the first process modifies the function it wishes
    to hook within the target process’s address space to point and jump to the injected
    hooking code. When the target process executes that function, control flow is
    transferred from the original code to the hooked code, which can then be used
    for monitoring, intercepting, or modifying calls to the original function. [Figure
    12-22](chapter12.xhtml#fig12-22) illustrates the inline hooking technique.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-22.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-22: The inline API
    hooking technique</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: This application calls the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    which is located inside *ntdll.dll*. Normally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code inside *ntdll.dll* would then execute. However, *ntdll.dll* has been tampered
    with and its legitimate code has been overwritten with a jump instruction, so
    now the program will jump to and execute the hooking code instead. Once the malicious
    code is run, control flow is transferred back to *ntdll.dll* and finally returns
    to the original application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say our system has been infected with a malware sample that wishes to
    intercept and monitor all calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    in a victim process (*firefox.exe*, for example). After injecting the malicious
    hooking DLL into *firefox.exe*, the malware must modify the *ntdll.dll* module
    in the victim process’s address space. The malware locates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function within *ntdll.dll* and overwrites the first 5 bytes to jump to the malicious
    injected DLL instead of executing the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. (Overwriting 5 bytes is common because that’s a typical size for jump instructions.)
    The first byte, <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp> (the jump
    instruction), is followed by 4 bytes representing the memory location to jump
    to. To modify the function code in the target process, the first process can call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>. This code block shows the
    first bytes of the legitimate <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function (in x64 assembly):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the malware modifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    function, it might look like this; notice the jump to the malicious code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> statement,
    the jump to the hooked code could be accomplished with a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction like
    so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When installing an inline hook, the code author often will want the original
    function code to execute after the hooked code runs in order to avoid scrutiny
    from system users. Let’s say that in our <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    example, the author wants to intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>,
    execute the hooked code, and then execute the original <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    code. This can be accomplished in the form of a *trampoline*, which is simply
    a jump back to the original function, as shown in [Figure 12-23](chapter12.xhtml#fig12-23).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-23.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-23: An inline hook
    trampoline</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Trampolines are often implemented with an instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">call
    NtCreateFile+5</samp>. After the hooking code executes (inside the injected DLL,
    in this case), this instruction will transfer control flow back to the real <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>, skipping over the
    first 5 bytes where the inserted <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement resides in the modified *ntdll.dll* file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: When you’re analyzing malware, there are three function calls that can hint
    at inline hooking. First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to read the first bytes of code in the function it wishes to hook inside the target
    process. Then, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to modify the permissions of the target memory region and prepare for writing
    the jump instruction that will jump to the malicious code injected into the target
    process. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the jump statement into the target function’s code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Another user-space hooking technique is* IAT hooking*, which involves altering
    the import address table of the target process to point to the hooking code rather
    than to the original function code. However, IAT hooking isn’t often used by modern
    malware since it’s easily detected by host-based defenses, so I won’t go into
    more detail on this method.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mitigations for Process and Hook Injection</samp>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As new injection and hooking techniques are used in malware or discovered by
    researchers and published, Microsoft counters them with built-in protections as
    much as possible. For example, *data execution prevention*, introduced in Windows
    XP, seeks to prevent malware from executing injected malicious code by marking
    memory regions as nonexecutable. *AppLocker*, introduced in Windows 7, prevents
    unauthorized executables (which can include injected DLLs) from executing. *Control
    Flow Guard*, released in Windows 8.1, is designed to detect whether malware modifies
    the code control flow of another process, which often takes place during process
    injection. And *Arbitrary Code Guard (ACG)*, added in Windows 10, seeks to prevent
    malware from modifying the code of legitimate processes, thus preventing certain
    types of process and hook injection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, complementary defenses such as EDR and anti-malware software can
    monitor suspicious processes and detect or prevent some of these injections. Keep
    in mind, however, that not all injection is malicious: plenty of benign, legitimate
    applications use injection for various reasons, so it can be difficult for endpoint
    defense products to determine the difference between good and evil. [Chapter 13](chapter13.xhtml)
    will explore some of these endpoint defenses and how malware attempts to bypass
    them.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed some of the common techniques malware uses to
    inject and run code within the context of other processes in order to evade endpoint
    defenses and blend in with the environment in which it’s running. We also covered
    some of the common hooks malware uses to hide its malicious behaviors or implement
    rootkit functionality. There are many types of injection and hooking techniques,
    and it’s impossible to cover them all in this book. I’ve tried to focus on those
    that you’re most likely to encounter in the wild, as well as some of the newer
    techniques that malware authors might add to their evasion toolboxes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start looking at ways in which malware can circumvent
    endpoint and network defenses to execute and hide its malicious code in a well-protected
    environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
