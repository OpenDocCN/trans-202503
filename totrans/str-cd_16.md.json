["```\n\"  Loop and decrement (ex1)\n{ main\n    set,10    \" set mem to 10\n    prt       \" print it\n    tmx       \" mem -> X\n    set,13    \" 13 -> mem\n    chr       \" newline\n    txm       \" X -> mem, restore count\n    dec       \" decrement mem\n    tst,n,-6  \" if mem != 0, go back six instructions\n    hlt       \" end\n}\n```", "```\n> python3 filska.py examples/ex1.filska\n```", "```\ndef f(x):\n    y = 2*x**2 + 3*x - 4\n    return y\n```", "```\nset,0\ninc\ngto,-1\n```", "```\nset,0 inc gto,-1\n```", "```\n{ main    \n    set,1 prt    \n    jmp,newline    \n    set,2 prt    \n    jmp,newline    \n    set,3 prt    \n    jmp,newline    \n    hlt    \n}       \n\n{ newline set,10 chr jmp,main }\n```", "```\nset,42\nset,-6502\nset,0.007\nset,6.62607015e-34\n```", "```\nswp,mx\nswp,yz\n```", "```\n{ main\n  ➊ set,123\n    tmx jmp,mem\n  ➋ set,1 prt\n    set,13 chr\n  ➌ jmp,mem txm\n    prt set,13 chr\n    jmp,mem txm\n    prt set,13 chr\n    jmp,mem txm\n    prt set,13 chr\n    hlt\n}\n\n{ mem\n    txm\n    inc\n    jmp,main\n    tmx\n    gto,-2\n}\n```", "```\n<op>,<dst> = <op1><op2>\n```", "```\nset,3\ncmp,x\n```", "```\nflags = [False, False, False, False]\nif (mem < n):\n    flags[2] = True  # L\nif (mem > n):\n    flags[3] = True  # G\nif (n == mem):\n    flags[1] = True  # E\nif (mem == 0):\n    flags[0] = True  # Z\n```", "```\nset,0\ncmp,5\n```", "```\nset,1\ntst,z,10\ndec\ntst,z,8\n```", "```\ncmp,x\ntst,l,-15\ntst,e,-16\n```", "```\n{ main\n    set,63\n    chr\n    ipt\n    tmx \n    set,2\n    mul,m=mx\n    prt \n    set,13\n    chr \n    hlt \n}\n```", "```\n{ main\n    ipt\n    tmx\n    set,2\n    mul,m=mx\n    prt\n    set,13\n    chr\n}\n```", "```\npython3 filska.py example_input_file.filska <input.txt\n```", "```\ndef main():\n    trace = False if (len(sys.argv) < 3) else True\n    app = Filska(open(sys.argv[1]).read(), trace=trace)\n    app.Run()\n\nif (__name__ == \"__main__\"):\n    main()\n```", "```\ndef Parse(self, src):\n    eoln = False\n    t = \"\"\n    for c in src:\n        if (eoln) and (c == '\\n'):\n            eoln = False\n        elif (c == '\"') and (not eoln):\n            eoln = True\n        elif (not eoln):\n            t += c\n    return \" \".join(t.split()).upper().split()\n```", "```\ndef InitializeProg(self, tokens):\n    idx = 0\n    k = 0\n    while (k < len(tokens)):\n        if (tokens[k] == \"{\"):\n            k = self.ExtractProg(tokens,k)\n        else:\n            k += 1\n\ndef ExtractProg(self, tokens, ks):\n    k = ks + 1\n    p = []\n    while (k < len(tokens)) and (tokens[k] != \"}\"):\n        p.append(tokens[k])\n        k += 1\n    self.prog[p[0]] = p[1:]\n    self.PC[p[0]] = 0\n    self.mem[p[0]] = 0.0\n    self.flags[p[0]] = [False, False, False, False]\n    return k\n```", "```\ndef Run(self):\n    if (self.trace):\n        self.Trace() while (True):\n        self.Execute()\n        if (self.trace):\n            self.Trace()\n        time.sleep(self.naptime)\n```", "```\ndef Execute(self):\n    prog = self.prog[self.CP]\n    pc = self.PC[self.CP]\n    flags = self.flags[self.CP]\n    mem = self.mem[self.CP]\n    inst = prog[pc]\n\n    cp, pc, mem, flags = self.Exec(inst, len(prog), mem, pc, flags)\n\n    self.mem[self.CP] = mem\n    self.PC[self.CP] = pc\n    self.flags[self.CP] = flags\n\n\tif (self.CP != cp):                                                       \n\t\tself.CP = cp\n\t\tself.flags[cp] = [False, False, False, False]\n```", "```\ndef Exec(self, inst, proglen, mem, pc, flags):\n    cp = self.CP\n    if (inst[:3] == \"JMP\"):\n        pc, cp = self.JMP(inst, pc, proglen)\n    elif (inst[:3] == \"JPR\"):\n        pc, cp = self.JPR(inst, pc)\n    elif (inst[:3] == \"GTO\"):\n        pc = self.GTO(inst, pc, proglen)\n    elif (inst[:3] == \"TST\"):\n        pc = self.TST(inst, pc, proglen, flags)\n    else:\n        if (inst[:3] not in self.exe):\n            raise ValueError(\"Illegal instruction: %s\" % inst)\n    ➊ rest = inst[4:]\n    ➋ mem, flags = self.exe[inst[:3]](rest, mem, flags)\n    ➌ pc = (pc+1) % proglen\n\n    return cp, pc, mem, flags\n```", "```\ndef COS(self, rest, mem, flags):\n    mem = cos(mem)\n    flags[0] = False if (mem == 0.0):\n        flags[0] = True\n    return mem, flags\n```", "```\ndef SET(self, rest, mem, flags):\n    try:\n        n = float(rest)\n    except:\n        n = 0.0\n    mem = n\n    flags[0] = False\n    if (mem == 0):\n        flags[0] = True\n    return mem, flags\n```", "```\ndef ADD(self, rest, mem, flags):\n    op0,op1,dst = self.ops(rest,mem)\n    ans = op0 + op1\n    return self.assign(ans, dst, mem, flags)\n```", "```\ndef JMP(self, inst, pc, proglen):\n    pc = (pc+1) % proglen\n    cp = inst[4:]\n    return pc, cp\n\ndef JPR(self, inst, pc):\n    pc = 0\n    cp = inst[4:]\n    return pc, cp\n```", "```\ndef GTO(self, inst, pc, proglen):\n    try:\n        offset = int(inst[4:])\n        if (offset == 0):\n            offset = 1\n    except:\n        offset = 1\n    pc += offset\n    if (pc < 0):\n        pc = 0\n    if (pc >= proglen):\n        pc = proglen-1\n    return pc\n```", "```\ndef TST(self, inst, pc, proglen, flags):\n ➊ if (inst[4] == \"Z\"):\n        v = flags[0]\n    elif (inst[4] == \"E\"):\n        v = flags[1]\n    elif (inst[4] == \"L\"):\n        v = flags[2]\n    elif (inst[4] == \"G\"):\n        v = flags[3]\n    elif (inst[4] == \"N\"):\n        v = (flags[0] == False)\n    if (v):\n     ➋ try:\n            offset = int(inst[6:])\n            if (offset == 0):\n                offset = 1\n        except:\n            offset = 1\n        pc += offset if (pc < 0):\n            pc = 0\n        if (pc >= proglen):\n            pc = proglen-1\n    else:\n     ➌ pc = (pc+1) % proglen\n    return pc\n```"]