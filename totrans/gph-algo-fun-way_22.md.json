["```\ndef is_clique(g: Graph, nodes: list) -> bool: \n    num_nodes: int = len(nodes)\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            if not g.is_edge(nodes[i], nodes[j]):\n                return False\n    return True \n```", "```\ndef clique_expansion_options(g: Graph, clique: list) -> list: \n    options: list = []\n    for i in range(g.num_nodes):\n      ❶ if i not in clique:\n            valid: bool = True\n            for j in clique:\n              ❷ valid = valid and g.is_edge(i, j)\n            if valid:\n                options.append(i)\n    return options \n```", "```\ndef clique_greedy(g: Graph) -> list: \n    clique: list = []\n    to_add: list = clique_expansion_options(g, clique)\n    while len(to_add) > 0:\n      ❶ clique.append(to_add[0])\n        to_add = clique_expansion_options(g, clique)\n    return clique \n```", "```\ndef maximum_clique_recursive(g: Graph, clique: list, index: int) -> list: \n  ❶ if index >= g.num_nodes:\n        return copy.copy(clique)\n\n  ❷ best: list = maximum_clique_recursive(g, clique, index + 1)\n\n  ❸ can_add: bool = True\n    for n in clique:\n        can_add = can_add and g.is_edge(n, index)\n\n    if can_add:\n        clique.append(index)\n        candidate: list = maximum_clique_recursive(g, clique, index + 1)\n      ❹ clique.pop()\n\n      ❺ if len(candidate) > len(best):\n            best = candidate\n\n    return best \n```", "```\ndef maximum_clique_backtracking(g: Graph) -> list: \n    return maximum_clique_recursive(g, [], 0) \n```", "```\ndef is_independent_set(g: Graph, nodes: list) -> bool: \n    num_nodes: int = len(nodes)\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            if g.is_edge(nodes[i], nodes[j]):\n                return False\n    return True \n```", "```\ndef independent_set_expansion_options(g: Graph, current: list) -> list: \n    options: list = []\n    for i in range(g.num_nodes):\n        if i not in current:\n            valid: bool = True\n            for j in current:\n              ❶ valid = valid and not g.is_edge(i, j) if valid:\n                options.append(i)\n    return options \n```", "```\ndef independent_set_lowest_expansion(g: Graph, current: list) -> int: \n  ❶ best_option: int = -1\n    best_num_edges: int = g.num_nodes + 1\n\n    for i in range(g.num_nodes):\n      ❷ if i not in current and g.nodes[i].num_edges() < best_num_edges:\n            valid: bool = True\n          ❸ for j in current:\n                valid = valid and not g.is_edge(i, j)\n            if valid:\n                best_num_edges = g.nodes[i].num_edges()\n                best_option = i\n    return best_option \n```", "```\ndef independent_set_greedy(g: Graph) -> list: \n    i_set: list = []\n    to_add: int = independent_set_lowest_expansion(g, i_set)\n    while to_add != -1:\n        i_set.append(to_add)\n        to_add = independent_set_lowest_expansion(g, i_set)\n    return i_set \n```", "```\ndef maximum_independent_set_rec(g: Graph, current: list, index: int) -> list: \n  ❶ if index >= g.num_nodes:\n        return copy.copy(current)\n\n  ❷ best: list = maximum_independent_set_rec(g, current, index + 1)\n\n  ❸ can_add: bool = True\n    for n in current:\n        can_add = can_add and not g.is_edge(n, index)\n\n    if can_add:\n        current.append(index)\n      ❹ candidate: list = maximum_independent_set_rec(g, current, index + 1)\n      ❺ current.pop()\n\n        if len(candidate) > len(best):\n            best = candidate\n\n    return best \n```", "```\ndef maximum_independent_set_backtracking(g: Graph) -> list: \n    return maximum_independent_set_rec(g, [], 0) \n```", "```\ndef is_vertex_cover(g: Graph, nodes: list) -> bool: \n  ❶ node_set: set = set(nodes) for edge in g.make_edge_list():\n      ❷ if edge.from_node not in node_set and edge.to_node not in node_set:\n            return False\n    return True \n```", "```\ndef vertex_cover_greedy_choice(g: Graph, nodes: list) -> int: \n  ❶ edges_covered: set = set([])\n    for index in nodes:\n        for edge in g.nodes[index].get_edge_list():\n            edges_covered.add((edge.from_node, edge.to_node))\n            edges_covered.add((edge.to_node, edge.from_node))\n\n    best_option: int = -1\n    best_num_edges: int = 0 for i in range(g.num_nodes):\n        new_covered: int = 0\n        for edge in g.nodes[i].get_edge_list():\n          ❷ if (edge.from_node, edge.to_node) not in edges_covered:\n                new_covered = new_covered + 1\n\n        if new_covered > best_num_edges:\n            best_num_edges = new_covered\n            best_option = i\n\n    return best_option \n```", "```\ndef vertex_cover_greedy(g: Graph) -> list: \n    nodes: list = []\n    to_add: int = vertex_cover_greedy_choice(g, nodes)\n    while to_add != -1:\n        nodes.append(to_add)\n        to_add = vertex_cover_greedy_choice(g, nodes)\n    return nodes \n```", "```\ndef minimum_vertex_cover_rec(g: Graph, current: set, index: int) -> set: \n  ❶ if index >= g.num_nodes:\n        return copy.copy(current) best: set = minimum_vertex_cover_rec(g, current, index + 1)\n\n    can_remove: bool = True\n    for edge in g.nodes[index].get_edge_list():\n      ❷ can_remove = can_remove and edge.to_node in current\n\n    if can_remove:\n        current.remove(index)\n        candidate: set = minimum_vertex_cover_rec(g, current, index + 1)\n      ❸ current.add(index)\n\n        if len(candidate) < len(best):\n            best = candidate\n\n    return best \n```", "```\ndef minimum_vertex_cover_backtracking(g: Graph) -> list: \n    current: set = set([i for i in range(g.num_nodes)])\n    best: set = minimum_vertex_cover_rec(g, current, 0)\n    return list(best) \n```", "```\ndef independent_set_random(g: Graph) -> list: \n    i_set: list = []\n    options: list = independent_set_expansion_options(g, i_set)\n    while len(options) > 0:\n      ❶ index: int = random.randint(0, len(options)-1)\n        i_set.append(options[index])\n      ❷ options = independent_set_expansion_options(g, i_set)\n    return i_set \n```", "```\ndef build_independent_set_random(g: Graph, iterations: int) -> list: \n    best_iset: list = []\n    for i in range(iterations):\n        current_iset: list = independent_set_random(g)\n        if len(current_iset) > len(best_iset):\n            best_iset = current_iset\n    return best_iset \n```"]