["```\n// Listing16-1.S\n//\n// Comments consist of all text from a //\n// sequence to the end of the line.\n// The .text directive tells MASM that the\n// statements following this directive go in\n// the section of memory reserved for machine\n// instructions (code).\n\n       .text\n\n// Here is the main function.\n// (This example assumes that the\n// assembly language program is a\n// stand-alone program with its own\n// main function.)\n//\n// Under macOS, the main program\n// must have the name _main\n// beginning with an underscore.\n// Linux systems generally don't\n// require the underscore.\n//\n// The .global _main statement\n// makes the _main procedure's name\n// visible outside this source file\n// (needed by the linker to produce\n// an executable).\n\n ❶ .global _main  // This is the macOS entry point.\n     ❷ .global main   // This is the Linux entry point name.\n\n// The .align 2 statement tells the\n// assembler to align the following code\n// on a 4-byte boundary (required by the\n// ARM CPU). The 2 operand specifies\n// 2 raised to this power (2), which\n// is 4.\n\n       .align 2\n\n// Here's the actual main program. It\n// consists of a single ret (return)\n// instruction that simply returns\n// control to the operating system.\n\n❶ _main:\n❷ main:\n    ❸ ret\n```", "```\n#if isMacOS\n\n    // Under macOS, the system call number\n    // goes into X16:\n\n    #define svcReg x16\n    #define OSint  0x80\n\n#else\n\n    // Under Linux, the system call number\n    // is passed in X8:\n\n    #define svcReg x8\n    #define OSint  0\n\n#endif\n```", "```\n// Listing16-2.S\n//\n// Simple shell program that calls exit()\n\n      ❶ #include    \"aoaa.inc\"\n\n        // Specify OS-dependent return code:\n\n      ❷ #ifdef      isMacOS\n        #define     exitCode 1\n        #else\n        #define     exitCode 93\n        #endif\n\n        .text\n        .global     _main\n        .global     main\n        .align      2\n\n_main:\nmain:\n      ❸ mov         x0, #0  // Return success.\n      ❹ mov         svcReg, exitCode\n      ❺ svc         #OSint\n```", "```\n# Listing16-2.mak\n#\n# makefile to build the Listing16-2 file\n\nunamestr=`uname`\n\nListing16-2:\n    g++ -D$(unamestr) Listing16-2.S -o Listing16-2\n\nclean:\n    rm -f Listing16-2.o\n    rm -f Listing16-2\n```", "```\n% make -f Listing16-2.mak\ng++ -D`uname` Listing16-2.S -o Listing16-2\n% ./Listing16-2\n```", "```\n#ifdef __APPLE_API_PRIVATE\n#define SYS_syscall        0\n#define SYS_exit           1\n#define SYS_fork           2\n#define SYS_read           3\n#define SYS_write          4\n#define SYS_open           5\n#define SYS_close          6\n#define SYS_wait4          7\n   .\n   .\n   .\n```", "```\n#define __NR_exit 93\n__SYSCALL(__NR_exit, sys_exit)\n#define __NR_read 63\n__SYSCALL(__NR_read, sys_read)\n#define __NR_write 64\n__SYSCALL(__NR_write, sys_write)\n#define __NR_openat 56\n__SYSCALL(__NR_openat, sys_openat)\n#define __NR_close 57\n__SYSCALL(__NR_close, sys_close)\n   .\n   .\n   .\n```", "```\nname  reference   x8    x0               x1 x2 x3 x4 x5\nexit  man/ cs/    5D    int error_code   -- -- -- -- --\n```", "```\nint openat(int dfd, const char *pathname, int flags, mode_t mode);\n```", "```\n #include \"aoaa.inc\"\n    #include <sys/syscall.h>\n\n#if isMacOS\n\n    #define  sys_openat SYS_openat\n    #define  sys_read SYS_read\n    #define  sys_close SYS_close\n\n#elif isLinux\n\n    #define  sys_openat __NR_openat\n    #define  sys_read __NR_read\n    #define  sys_close __NR_close\n\n#endif\n```", "```\n .macro  checkError\n\n            #if     isMacOS\n\n            // If macOS, convert the error code to be\n            // compatible with Linux (carry set is\n            // error flag and X0 is error code):\n\n          ❶ bcc     0f\n          ❷ neg     x0, x0\n\n            #elif   isLinux\n\n            // If Linux, fetch the errno error code\n            // (if return value is -1), negate it,\n            // and return that as the error code:\n\n          ❸ cmp     x0, #-1\n            bne     0f\n          ❹ getErrno\n            neg     x0, x0\n\n            #endif\n0:\n            .endm\n```", "```\n// Listing16-3.S\n//\n// A stand-alone \"Hello, world!\" program\n\n        #include    \"aoaa.inc\"\n      ❶ #include    <sys/syscall.h>\n\n        // Specify OS-dependent return code:\n\n        #if         isMacOS\n\n      ❷ #define     exitCode    SYS_exit\n        #define     sys_write   SYS_write\n\n        #else\n\n      ❸ #define     exitCode    __NR_exit\n        #define     sys_write   __NR_write\n\n        #endif\n\n        .data\nhwStr:  .asciz      \"Hello, world!\\n\"\nhwSize  =           .-hwStr\n\n .text\n       .global      _main\n       .global      main\n       .align       2\n\n_main:\nmain:\n\n      ❹ mov         x0, #1          // stdout file handle\n        lea         x1, hwStr       // String to print\n        mov         x2, #hwSize     // Num chars to print\n        mov         svcReg, #sys_write\n        svc         #OSint          // Call OS to print str.\n\n      ❺ mov         svcReg, #exitCode\n        mov         x0, #0\n        svc         #OSint          // Quit program.\n```", "```\n# Listing16-3.mak\n#\n# makefile to build the Listing16-3 file\n\nunamestr=`uname`\n\nListing16-3:\n    g++ -D$(unamestr) Listing16-3.S -o Listing16-3\n\nclean:\n    rm -f Listing16-3.o\n    rm -f Listing16-3\n```", "```\n% make -f Listing16-3.mak clean\nrm -f Listing16-3.o\nrm -f Listing16-3\n% make -f Listing16-3.mak\ng++ -D`uname` Listing16-3.S -o Listing16-3\n% ./Listing16-3\nHello, world!\n```", "```\n# files.mak\n#\n# makefile to build the files library\n\nunamestr=`uname`\n\nfiles.a:files.o stdio.o volatile.o\n    ar rcs files.a files.o stdio.o volatile.o\n  ❶ cp files.a ..\n\nfiles.o:files.S files.inc ../aoaa.inc\n    g++ -c -D$(unamestr) files.S\n\nstdio.o:stdio.S files.inc ../aoaa.inc\n    g++ -c -D$(unamestr) stdio.S\n\nvolatile.o:volatile.S files.inc ../aoaa.inc\n    g++ -c -D$(unamestr) volatile.S\n\nclean:\n    rm -f files.o\n    rm -f volatile.o\n    rm -f stdio.o\n    rm -f files.a\n```", "```\n// files.inc\n//\n// Header file that holds the files library\n// globals and constants\n\n            #include \"../aoaa.inc\"  // Get isMacOS and isLinux.\n❶ #if isMacOS\n#define __APPLE_API_PRIVATE\n#endif\n            #include        <sys/syscall.h>\n\n            #if     isMacOS\n\n❷ sys_Read    =       SYS_read\nsys_Write   =       SYS_write\nsys_Open    =       SYS_openat\nsys_Close   =       SYS_close\nAT_FDCWD    =       -2\n\n#define O_CREAT     00000200\n\n            #else\n\n❸ sys_Read    =       __NR_read\nsys_Write   =       __NR_write\nsys_Open    =       __NR_openat\nsys_Close   =       __NR_close\nAT_FDCWD    =       -100\n\n#define O_CREAT     00000100\n\n            #endif\n\n// Handles for the stdio files:\n\n❹ stdin       =       0\nstdout      =       1\nstderr      =       2\n\n// Other useful constants:\n\ncr          =       0xd     // Carriage return (ENTER)\nlf          =       0xa     // Line feed/newline char\nbs          =       0x8     // Backspace\n\n// Note the following are octal (base 8) constants!\n// (Leading 0 indicates octal in Gas.)\n//\n// These constants were copied from fcntl.h.\n\n❺ #define S_IRWXU  (00700)\n#define S_RDWR   (00666)\n#define S_IRUSR  (00400)\n#define S_IWUSR  (00200)\n#define S_IXUSR  (00100)\n#define S_IRWXG  (00070)\n#define S_IRGRP  (00040)\n#define S_IWGRP  (00020)\n#define S_IXGRP  (00010)\n#define S_IRWXO  (00007)\n#define S_IROTH  (00004)\n#define S_IWOTH  (00002)\n#define S_IXOTH  (00001)\n#define S_ISUID  (0004000)\n#define S_ISGID  (0002000)\n#define S_ISVTX  (0001000)\n\n#define O_RDONLY    00000000\n#define O_WRONLY    00000001\n#define O_RDWR      00000002\n#define O_EXCL      00000200\n#define O_NOCTTY    00000400\n#define O_TRUNC     00001000\n#define O_APPEND    00002000\n#define O_NONBLOCK  00004000\n#define O_DSYNC     00010000\n#define FASYNC      00020000\n#define O_DIRECT    00040000\n#define O_LARGEFILE 00100000\n#define O_DIRECTORY 00200000\n#define O_NOFOLLOW  00400000\n#define O_NOATIME   01000000\n#define O_CLOEXEC   02000000\n\n// Macro to test an error return\n// value from an OS API call:\n\n          ❻ .macro  file.checkError\n\n            #if     isMacOS\n\n // If macOS, convert the error code to be\n            // compatible with Linux (carry set is\n            // error flag, and X0 is error code):\n\n            bcc     0f\n            neg     x0, x0\n\n            #elif   isLinux\n\n            // If Linux, fetch the errno error code\n            // (if return value is -1), negate it,\n            // and return that as the error code:\n\n            cmp     x0, #-1\n            bne     0f\n            getErrno\n            neg     x0, x0\n\n            #endif\n0:\n            .endm\n\n          ❼ .extern saveVolatile\n            .extern restoreVolatile\n\n            .extern file.write\n            .extern file.read\n            .extern file.open\n            .extern file.openNew\n            .extern file.close\n\n            .extern stdout.puts\n            .extern stdout.newLn\n\n            .extern stdin.read\n            .extern stdin.getc\n            .extern stdin.readln\n```", "```\n// volatiles.S\n//\n// saveVolatile and restoreVolatile functions used\n// to preserve volatile registers\n\n            #include    \"../aoaa.inc\"\n            #include    \"files.inc\"\n\n            .code\n            .align  2\n\n// saveVolatile\n//\n// A procedure that will save all the volatile\n// registers at the location pointed at by FP\n\n            proc    saveVolatile, public\n            stp     x0,  x1,  [fp], #16\n            stp     x2,  x3,  [fp], #16\n            stp     x4,  x5,  [fp], #16\n            stp     x6,  x7,  [fp], #16\n            stp     x8,  x9,  [fp], #16\n            stp     x10, x11, [fp], #16\n            stp     x12, x13, [fp], #16\n            stp     x14, x15, [fp], #16\n            stp     q0,  q1,  [fp], #32\n            stp     q2,  q3,  [fp], #32\n            stp     q4,  q5,  [fp], #32\n            stp     q6,  q7,  [fp], #32\n            stp     q8,  q9,  [fp], #32\n            stp     q10, q11, [fp], #32\n            stp     q12, q13, [fp], #32\n            stp     q14, q15, [fp], #32\n ret\n            endp    saveVolatile\n\n// restoreVolatile\n//\n// A procedure that will restore all the volatile\n// registers from the location pointed at by FP\n\n            proc    restoreVolatile, public\n            ldp     x0,  x1,  [fp], #16\n            ldp     x2,  x3,  [fp], #16\n            ldp     x4,  x5,  [fp], #16\n            ldp     x6,  x7,  [fp], #16\n            ldp     x8,  x9,  [fp], #16\n            ldp     x10, x11, [fp], #16\n            ldp     x12, x13, [fp], #16\n            ldp     x14, x15, [fp], #16\n            ldp     q0,  q1,  [fp], #32\n            ldp     q2,  q3,  [fp], #32\n            ldp     q4,  q5,  [fp], #32\n            ldp     q6,  q7,  [fp], #32\n            ldp     q8,  q9,  [fp], #32\n            ldp     q10, q11, [fp], #32\n            ldp     q12, q13, [fp], #32\n            ldp     q14, q15, [fp], #32\n            ret\n            endp    restoreVolatile\n```", "```\nstruct  volatile_save\nqword   volatile_save.x0x1\nqword   volatile_save.x2x3\nqword   volatile_save.x4x5\nqword   volatile_save.x6x7\nqword   volatile_save.x8x9\nqword   volatile_save.x10x11\nqword   volatile_save.x12x13\nqword   volatile_save.x14x15\nqword   volatile_save.v0\nqword   volatile_save.v1\nqword   volatile_save.v2\nqword   volatile_save.v3\nqword   volatile_save.v4\nqword   volatile_save.v5\nqword   volatile_save.v6\nqword   volatile_save.v7\nqword   volatile_save.v8\nqword   volatile_save.v9\nqword   volatile_save.v10\nqword   volatile_save.v11\nqword   volatile_save.v12\nqword   volatile_save.v13\nqword   volatile_save.v14\nqword   volatile_save.v15\nends    volatile_save\n```", "```\n// files.S\n//\n// File I/O functions:\n\n            #include    \"../aoaa.inc\"\n            #include    \"files.inc\"\n\n            .code\n            .align  2\n\n// file.write\n//\n// Write data to a file handle.\n//\n// X0- File handle\n// X1- Pointer to buffer to write\n// X2- Length of buffer to write\n//\n// Returns:\n//\n// X0- Number of bytes actually written\n//     or -1 if there was an error\n\n            proc    file.write, public\n\n            locals  fw_locals\n            qword   fw_locals.saveX0\n          ❶ byte    fw_locals.volSave, volatile_save.size\n            byte    fw_locals.stkspace, 64\n          ❷ dword   fw_locals.fpSave\n            endl    fw_locals\n\n            enter   fw_locals.size\n\n            // Preserve all the volatile registers because\n            // the OS API write function might modify them.\n            //\n            // Note: Because fw_locals.volSave is at the\n            // bottom of the activation record, SP just\n            // happens to be pointing at it right now.\n            // Use it to temporarily save FP so you can\n            // pass the address of fw_locals.volSave to\n            // saveVolatile in the FP register.\n\n          ❸ str     fp, [sp]    // fw_locals.fpSave\n            add     fp, fp, #fw_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n            // Okay, now do the write operation (note that\n            // the sys_Write arguments are already sitting\n // in X0, X1, and X2 upon entry into this\n            // function):\n\n          ❹ mov     svcReg, #sys_Write\n            svc     #OSint\n\n            // Check for error return code:\n\n          ❺ file.checkError\n\n            // Restore the volatile registers, except\n            // X0 (because we return the function\n            // result in X0):\n\n          ❻ str     x0, [fp, #fw_locals.saveX0] // Return value.\n            str     fp, [sp]    // fw_locals.fpSave\n            add     fp, fp, #fw_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fw_locals.saveX0]\n            leave\n            endp    file.write\n```", "```\n// files.S (cont.)\n//\n// file.read\n//\n// Read data from a file handle.\n//\n// X0- File handle\n// X1- Pointer to buffer receive data\n// X2- Length of data to read\n//\n// Returns:\n//\n// X0- Number of bytes actually read\n//     or negative value if there was an error\n\n            proc    file.read, public\n\n            locals  fr_locals\n            qword   fr_locals.saveX0\n            byte    fr_locals.volSave, volatile_save.size\n            byte    fr_locals.stkspace, 64\n            dword   fr_locals.fpSave\n            endl    fr_locals\n\n            enter   fr_locals.size\n\n            // Preserve all the volatile registers because\n            // the OS API read function might modify them.\n            //\n            // Note: Because fr_locals.volSave is at the\n            // bottom of the activation record, SP just\n            // happens to be pointing at it right now.\n            // Use it to temporarily save FP so we can\n            // pass the address of fr_locals.volSave to\n            // saveVolatile in the FP register.\n\n            str     fp, [sp]    // fr_locals.fpSave\n            add     fp, fp, #fr_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n            // Okay, now do the read operation (note that\n            // the sys_Read arguments are already sitting\n // in X0, X1, and X2 upon entry into this\n            // function):\n\n            mov     svcReg, #sys_Read\n            svc     #OSint\n\n            // Check for error return code:\n\n            file.checkError\n\n            // Restore the volatile registers, except\n            // X0 (because we return the function\n            // result in X0):\n\n            str     x0, [fp, #fr_locals.saveX0] // Return value.\n            str     fp, [sp]    // fr_locals.fpSave\n            add     fp, fp, #fr_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fr_locals.saveX0]\n            leave\n            endp    file.read\n```", "```\n// files.S (cont.)\n//\n// file.open\n//\n// Open existing file for reading or writing.\n//\n// X0- Pointer to pathname string (zero-terminated)\n// X1- File access flags\n//     (O_RDONLY, O_WRONLY, or O_RDWR)\n//\n// Returns:\n//\n// X0- Handle of open file (or negative value if there\n//     was an error opening the file)\n\n            proc    file.open, public\n\n            locals  fo_locals\n            qword   fo_locals.saveX0\n            byte    fo_locals.volSave, volatile_save.size\n            byte    fo_locals.stkspace, 64\n            dword   fo_locals.fpSave\n            endl    fo_locals\n\n            enter   fo_locals.size\n\n // Preserve all the volatile registers because\n            // the OS API open function might modify them:\n\n            str     fp, [sp]    // fo_locals.fpSave\n            add     fp, fp, #fo_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n            // Call the OS API open function:\n\n          ❶ mov     svcReg, #sys_Open\n            mov     x2, x1\n            mov     x1, x0\n            mov     x0, #AT_FDCWD\n            mov     x3, #S_RDWR     // Mode, usually ignored\n            svc     #OSint\n\n            // Check for error return code:\n\n            file.checkError\n\n            // Restore the volatile registers, except\n            // X0 (because we return the function\n            // result in X0):\n\n            str     x0, [fp, #fo_locals.saveX0] // Return value.\n            str     fp, [sp]    // fo_locals.fpSave\n            add     fp, fp, #fo_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fo_locals.saveX0]\n            leave\n            endp    file.open\n```", "```\nint open(const char *pathname, int flags);\nint openat(int dirfd, const char *pathname, int flags);\n```", "```\n// files.S (cont.)\n//\n// file.openNew\n//\n// Creates a new file and opens it for writing\n//\n// X0- Pointer to filename string (zero-terminated)\n//\n// Returns:\n//\n// X0- Handle of open file (or negative if there\n//     was an error creating the file)\n\n            proc    file.openNew, public\n\n            locals  fon_locals\n            qword   fon_locals.saveX0\n            byte    fon_locals.volSave, volatile_save.size\n            byte    fon_locals.stkspace, 64\n            dword   fon_locals.fpSave\n            endl    fon_locals\n\n            enter   fon_locals.size\n\n            // Preserve all the volatile registers because\n            // the OS API open function might modify them:\n\n            str     fp, [sp]    // fon_locals.fpSave\n            add     fp, fp, #fon_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n            // Call the OS API open function:\n\n            mov     svcReg, #sys_Open\n            mov     x2, #O_CREAT+O_WRONLY+O_EXCL\n            mov     x1, x0\n            mov     x0, #AT_FDCWD\n            mov     x3, #S_RDWR // User/Group has RW perms.\n            svc     #OSint\n\n            // Check for error return code:\n\n            file.checkError\n\n            // Restore the volatile registers, except\n            // X0 (because we return the function\n // result in X0):\n\n            str     x0, [fp, #fon_locals.saveX0] // Return value.\n            str     fp, [sp]    // w_locals.fpSave\n            add     fp, fp, #fon_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fon_locals.saveX0]\n            leave\n            endp    file.openNew\n```", "```\n// files.S (cont.)\n//\n// file.close\n//\n// Closes a file specified by a file handle\n//\n// X0- Handle of file to close\n\n            proc    file.close, public\n\n            locals  fc_locals\n            qword   fc_locals.saveX0\n            byte    fc_locals.volSave, volatile_save.size\n            byte    fc_locals.stkspace, 64\n            dword   fc_locals.fpSave\n            endl    fc_locals\n\n            enter   fc_locals.size\n\n            // Preserve all the volatile registers because\n            // the OS API open function might modify them:\n\n            str     fp, [sp]    // fc_locals.fpSave\n            add     fp, fp, #fc_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n            // Call the OS API close function (handle is\n            // already in X0):\n\n            mov     svcReg, #sys_Close\n            svc     #OSint\n\n            // Check for error return code:\n\n            file.checkError\n\n // Restore the volatile registers, except\n            // X0 (because we return the function\n            // result in X0):\n\n            str     x0, [fp, #fc_locals.saveX0] // Return value.\n            str     fp, [sp]    // w_locals.fpSave\n            add     fp, fp, #fc_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fc_locals.saveX0]\n            leave\n            endp    file.close\n```", "```\n// stdio.S\n//\n// Standard input and standard output functions:\n\n            #include    \"../aoaa.inc\"\n            #include    \"files.inc\"\n            #include    <sys/syscall.h>\n\n            .code\n            .align  2\n\n// stdout.puts\n//\n// Outputs a zero-terminated string to standard output device\n//\n// X0- Address of string to print to standard output\n\n            proc    stdout.puts, public\n\n            locals  lcl_puts\n          ❶ qword   lcl_puts.saveX0X1\n            dword   lcl_puts.saveX2\n            byte    lcl_puts.stkSpace, 64\n            endl    lcl_puts\n\n            enter   lcl_puts.size\n\n stp     x0, x1, [fp, #lcl_puts.saveX0X1]\n            str     x2,     [fp, #lcl_puts.saveX2]\n\n            mov     x1, x0\n\n// Compute the length of the string:\n\n❷ lenLp:      ldrb    w2, [x1], #1\n            cbnz    w2, lenLp\n            sub     x2, x1, x0  // Compute length\n\n            // Call file_write to print the string:\n\n          ❸ mov     x1, x0\n            mov     x0, #stdout\n            bl      file.write\n\n            // Return to caller:\n\n            ldr     x2,     [fp, #lcl_puts.saveX2]\n            ldp     x0, x1, [fp, #lcl_puts.saveX0X1]\n            leave\n            endp    stdout.puts\n```", "```\n// stdio.S (cont.)\n//\n// stdout.newLn\n//\n// Outputs a newline sequence to the standard output device:\n\nstdout.nl:  .ascii  \"\\n\"\nnl.len      =       .-stdout.nl\n            .byte   0\n            .align  2\n\n            proc    stdout.newLn, public\n            locals  lcl_nl\n            qword   lcl_nl.saveX0X1\n            dword   lcl_nl.saveX2\n            byte    lcl_nl.stkSpace, 64\n            endl    lcl_nl\n\n            enter   lcl_nl.size\n            stp     x0, x1, [fp, #lcl_nl.saveX0X1]\n            str     x2,     [fp, #lcl_nl.saveX2]\n\n            lea     x1, stdout.nl\n            mov     x2, #nl.len\n            mov     x0, stdout\n            bl      file.write\n\n            ldr     x2,     [fp, #lcl_nl.saveX2]\n            ldp     x0, x1, [fp, #lcl_nl.saveX0X1]\n            leave\n            endp    stdout.newLn\n```", "```\n// stdio.S (cont.)\n//\n// stdin.read\n//\n// Reads data from the standard input\n//\n// X0- Buffer to receive data\n// X1- Buffer count (note that data input will\n//     stop on a newline character if that\n//     comes along before X1 characters have\n//     been read)\n//\n// Returns:\n//\n// X0- Negative value if error, bytes read if successful\n\n             proc    stdin.read, public\n             locals  sr_locals\n             qword   sr_locals.saveX1X2\n             byte    sr_locals.stkspace, 64\n             dword   sr_locals.fpSave\n             endl    sr_locals\n\n             enter   sr_locals.size\n             stp     x1, x2, [fp, #sr_locals.saveX1X2]\n\n             // Call the OS API read function:\n\n           ❶ mov     svcReg, #sys_Read\n             mov     x2, x1\n             mov     x1, x0\n             mov     x0, #stdin\n             svc     #OSint\n\n             file.checkError\n\n             ldp     x1, x2, [fp, #sr_locals.saveX1X2]\n             leave\n             endp    stdin.read\n```", "```\n// stdio.S (cont.)\n//\n// stdin_getc\n//\n// Read a single character from the standard input.\n// Returns character in X0 register\n\n            proc    stdin.getc, public\n            locals  sgc_locals\n            qword   sgc_locals.saveX1X2\n          ❶ byte    sgc_buf, 16\n            byte    sgc_locals.stkspace, 64\n            endl    sgc_locals\n\n enter   sgc_locals.size\n            stp     x1, x2, [fp, #sgc_locals.saveX1X2]\n\n            // Initialize return value to all 0s:\n\n          ❷ str     xzr, [fp, #sgc_buf]\n\n            // Call the OS API read function to read\n            // a single character:\n\n            mov     svcReg, #sys_Read\n            mov     x0, #stdin\n          ❸ add     x1, fp, #sgc_buf\n            mov     x2, #1\n            svc     #OSint\n\n          ❹ file.checkError\n            cmp     x0, #0\n            bpl     noError\n\n            // If there was an error, return the\n            // error code in X0 rather than a char:\n\n            str     x0, [fp, #sgc_buf]\n\nnoError:\n            ldp     x1, x2, [fp, #sgc_locals.saveX1X2]\n          ❺ ldr     x0, [fp, #sgc_buf]\n            leave\n\n            endp    stdin.getc\n```", "```\n// stdio.S (cont.)\n//\n// stdin.readln\n//\n// Reads a line of text from the user.\n// Automatically processes backspace characters\n// (deleting previous characters, as appropriate).\n// Line returned from function is zero-terminated\n// and does not include the ENTER key code (carriage\n// return) or line feed.\n//\n// X0- Buffer to place line of text read from user\n// X1- Maximum buffer length\n//\n// Returns:\n//\n// X0- Number of characters read from the user\n//     (does not include ENTER key)\n\n            proc    stdin.readln, public\n            locals  srl_locals\n            qword   srl_locals.saveX1X2\n            dword   srl_locals.saveX3\n            byte    srl_buf, 16\n            byte    srl_locals.stkspace, 64\n            endl    srl_locals\n\n            enter   srl_locals.size\n            stp     x1, x2, [fp, #srl_locals.saveX1X2]\n            str     x3,     [fp, #srl_locals.saveX3]\n\n            mov     x3, x0          // Buf ptr in X3\n            mov     x2, #0          // Character count\n            cbz     x1, exitRdLn    // Bail if zero chars.\n\n            sub     x1, x1, #1      // Leave room for 0 byte.\nreadLp:\n          ❶ bl      stdin.getc      // Read 1 char from stdin.\n\n            cmp     w0, wzr         // Check for error.\n            bmi     exitRdLn\n\n          ❷ cmp     w0, #cr         // Check for newline code.\n            beq     lineDone\n\n            cmp     w0, #lf         // Check for newline code.\n            beq     lineDone\n\n ❸ cmp     w0, #bs         // Handle backspace character.\n            bne     addChar\n\n// If a backspace character came along, remove the previous\n// character from the input buffer (assuming there is a\n// previous character):\n\n            cmp     x2, #0          // Ignore BS character if no\n            beq     readLp          // chars in the buffer.\n            sub     x2, x2, #1\n            b.al    readLp\n\n// If a normal character (that we return to the caller),\n// add the character to the buffer if there is room\n// for it (ignore the character if the buffer is full):\n\n❹ addChar:    cmp     x2, x1          // See if you're at the\n            bhs     readLp          // end of the buffer.\n            strb    w0, [x3, x2]    // Save char to buffer.\n            add     x2, x2, #1\n            b.al    readLp\n\n// When the user presses the ENTER key (or line feed)\n// during input, come down here and zero-terminate the string:\n\nlineDone:\n          ❺ strb    wzr, [x3, x2]\n\nexitRdLn:   mov     x0, x2          // Return char cnt in X0.\n            ldp     x1, x2, [fp, #srl_locals.saveX1X2]\n            ldr     x3,     [fp, #srl_locals.saveX3]\n            leave\n            endp    stdin.readln\n```", "```\n// Listing16-4.S\n//\n// File I/O demonstration:\n\n            #include    \"aoaa.inc\"\n            #include    \"files/files.inc\"\n            #include    <sys/syscall.h>\n\n            #if isMacOS\n\n// Map main to \"_main\" as macOS requires\n// underscores in front of global names\n// (inherited from C code, anyway).\n\n#define main _main\nsys_Exit    =   SYS_exit\n\n            #else\n\nsys_Exit    =   __NR_exit\n\n            #endif\n\n            .data\n\n// Buffer to hold line of text read from user:\n\ninputLn:    .space  256, (0)\ninputLn.len =       .-inputLn\n\n// Buffer to hold data read from a file:\n\nfileBuffer: .space  4096, (0)\nfileBuffer.len =    .-fileBuffer\n\n// Prompt the user for a filename:\n\nprompt:     .ascii  \"Enter (text) filename:\"\nprompt.len  =       .-prompt\n            .byte   0\n\n// Error message string:\n\nbadOpenMsg: wastr   \"Could not open file\\n\"\n\nOpenMsg:    wastr   \"Opening file: \"\n\n            .code\n\n// Here is the asmMain function:\n\n            proc    main, public\n            locals  am\n            dword   am.inHandle\n            byte    am_stkSpace, 64\n            endl    am\n\n            enter   am.size\n\n// Get a filename from the user:\n\n          ❶ lea     x0, prompt\n            bl      stdout.puts\n\n            lea     x0, inputLn\n            mov     x1, #inputLn.len\n            bl      stdin.readln\n            cmp     x0, #0\n            bmi     badOpen\n\n            lea     x0, OpenMsg\n            bl      stdout.puts\n            lea     x0, inputLn\n            bl      stdout.puts\n            bl      stdout.newLn\n\n// Open the file, read its contents, and display\n// the contents to the standard output device:\n\n          ❷ lea     x0, inputLn\n            mov     x1, #O_RDONLY\n            bl      file.open\n            cmp     x0, xzr\n            ble     badOpen\n\n            str     x0, [fp, #am.inHandle]\n\n// Read the file 4,096 bytes at a time:\n\nreadLoop:\n          ❸ ldr     x0, [fp, #am.inHandle]\n            lea     x1, fileBuffer\n            mov     x2, fileBuffer.len\n            bl      file.read\n\n // Quit if there was an error or\n            // file.read read 0 bytes:\n\n            cmp     x0, xzr\n            ble     allDone\n\n            // Write the data just read to the\n            // stdout device:\n\n          ❹ mov     x2, x0        // Bytes to write\n            lea     x1, fileBuffer\n            mov     x0, #stdout\n            bl      file.write\n            b.al    readLoop\n\nbadOpen:    lea     x0, badOpenMsg\n            bl      stdout.puts\n\nallDone:\n          ❺ ldr     x0, [fp, #am.inHandle]\n            bl      file.close\n\n            // Return error code 0 to the OS:\n\n            mov     svcReg, #sys_Exit\n            mov     x0, #0\n            svc     #OSint\n            endp    main\n```", "```\n# Listing16-4.mak\n#\n# makefile to build the Listing16-4.S file\n\nunamestr=`uname`\n\nListing16-4:Listing16-4.S aoaa.inc files/files.inc files.a\n    cd files; make -f files.mak; cd ..\n    g++ -D$(unamestr) -o Listing16-4 Listing16-4.S files.a\n\nclean:\n    rm -f Listing16-4.o\n    rm -f Listing16-4\n    rm -f file.a\n    cd files; make -f files.mak clean; cd ..\n```", "```\n% make -f Listing16-4.mak clean\nrm -f Listing16-4.o\nrm -f Listing16-4\nrm -f file.a\ncd files; make -f files.mak clean; cd ..\nrm -f files.o\nrm -f volatile.o\nrm -f stdio.o\nrm -f files.a\n% make -f Listing16-4.mak\ncd files; make -f files.mak; cd ..\ng++ -c -D`uname` files.S\ng++ -c -D`uname` stdio.S\ng++ -c -D`uname` volatile.S\nar rcs files.a files.o stdio.o volatile.o\ncp files.a ..\ng++ -D`uname` -o Listing16-4 Listing16-4.S files.a\n% ./Listing16-4\nEnter (text) filename:Listing16-4.mak\nOpening file: Listing16-4.mak\n# listing16-4.mak\n#\n# makefile to build the Listing16-4.S file.\n\nunamestr=`uname`\n\nListing16-4:Listing16-4.S aoaa.inc files/files.inc files.a\n    cd files; make -f files.mak; cd ..\n    g++ -D$(unamestr) -o Listing16-4 Listing16-4.S files.a\n\nclean:\n    rm -f Listing16-4.o\n    rm -f Listing16-4\n    rm -f file.a\n    cd files; make -f files.mak clean; cd ..\n```", "```\n// file.write\n//\n// Write data to a file handle.\n//\n// X0- File handle\n// X1- Pointer to buffer to write\n// X2- Length of buffer to write\n//\n// Returns:\n//\n// X0- Number of bytes actually written\n//     or -1 if there was an error\n\n            proc    file.write, public\n            locals  fw_locals\n            qword   fw_locals.saveX0\n            byte    fw_locals.volSave, volatile_save.size\n            byte    fw_locals.stkspace, 64\n            dword   fw_locals.fpSave\n            endl    fw_locals\n\n            enter   fw_locals.size\n\n            // Preserve all the volatile registers because\n            // the OS API write function might modify them.\n            //\n            // Note: because fw_locals.volSave is at the\n            // bottom of the activation record, SP just\n            // happens to be pointing at it right now.\n            // Use it to temporarily save FP so you can\n            // pass the address of w_locals.volSave to\n            // saveVolatile in the FP register.\n\n            str     fp, [sp]    // fw_locals.fpSave\n            add     fp, fp, #fw_locals.volSave\n            bl      saveVolatile\n            ldr     fp, [sp]    // Restore FP.\n\n // Okay, now do the write operation (note that\n            // the write arguments are already sitting\n            // in X0, X1, and X2 upon entry into this\n            // function):\n\n          ❶ bl      _write\n\n            // Check for error return code:\n\n            file.checkError\n\n            // Restore the volatile registers, except\n            // X0 (because we return the function\n            // result in X0):\n\n            str     x0, [fp, #fw_locals.saveX0] // Return value.\n            str     fp, [sp]    // w_locals.fpSave\n            add     fp, fp, #fw_locals.volSave\n            bl      restoreVolatile\n            ldr     fp, [sp]    // Restore FP.\n            ldr     x0, [fp, #fw_locals.saveX0]\n            leave\n            endp    file.write\n```", "```\n .macro  file.checkError\n\n            cmp     x0, #-1\n            bne     0f\n            getErrno\n            neg     x0, x0\n0:\n            .endm\n```", "```\n❶ // Listing16-5.s\n//\n// A truly stand-alone \"Hello, world!\" program\n// written for Linux\n\n        .text\n      ❷ .global     _start\n        .align      2\nhwStr:  .asciz      \"Hello, world!\\n\"\nhwSize  =           .-hwStr\n        .align      2\n\n❸ _start:\n\n        mov         x0, #1          // stdout file handle\n        adr         x1, hwStr       // String to print\n        mov         x2, #hwSize     // Num chars to print\n        mov         X8, #64         // __NR_write\n        svc         #0              // Call OS to print str.\n\n        mov         X8, #93         // __NR_exit\n        mov         x0, #0\n        svc         #0              // Quit program.\n```", "```\nas -o Listing16-5.o Listing16-5.s\nld -s -o Listing16-5 Listing16-5.o\n./Listing16-5\nHello, world!\n```", "```\n// Listing16-6.s\n//\n// A truly stand-alone \"Hello, world!\" program\n// written for macOS\n\n        .text\n        .global     _start\n        .global     _main    // Later versions of macOS require this name.\n        .align      2\nhwStr:  .asciz      \"Hello, world!\\n\"\nhwSize  =           .-hwStr\n        .align      2\n\n_start:\n_main:\n\n        mov         x0, #1          // stdout file handle\n        adr         x1, hwStr       // String to print\n        mov         x2, #hwSize     // Num chars to print\n        mov         X16, #4         // SYS_write\n        svc         #0x80           // Call OS to print str.\n\n        mov         X16, #1         // SYS_exit\n        mov         x0, #0\n        svc         #0x80           // Quit program.\n\n        svc         #0              // Quit program.\n```", "```\nas -arch arm64 -o Listing16-6.o Listing16-6.s\n```", "```\nld -macos_version_min 12.3.0 -o HelloWorld Listing16-6.o \\\n -lSystem -syslibroot `xcrun -sdk macosx --show-sdk-path` -arch arm64\n```"]