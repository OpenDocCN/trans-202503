- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STATEMENTS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Progress doesn’t come from early risers—progress is made by lazy men looking
    for easier ways to do things.'
  prefs: []
  type: TYPE_NORMAL
- en: —Robert A. Heinlein*, Time Enough for Love
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each C++ function comprises a sequence of *statements*, which are programming
    constructs that specify the order of execution. This chapter uses an understanding
    of the object life cycle, templates, and expressions to explore the nuances of
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *expression statement* is an expression followed by a semicolon (`;`). Expression
    statements comprise most of the statements in a program. You can turn any expression
    into a statement, which you should do whenever you need to evaluate an expression
    but want to discard the result. Of course, this is only useful if evaluating that
    expression causes a side effect, like printing to the console or modifying the
    program’s state.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](ch08.xhtml#ch08ex01) contains several expression statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: A simple program containing several expression statements*'
  prefs: []
  type: TYPE_NORMAL
- en: The expression statement at ➊ has a side effect (incrementing `x`), but the
    one at ➋ doesn’t. Both are valid (although the one at ➋ isn’t useful). The function
    call to `printf` ➌ is also an expression statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compound Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Compound statements*, also called *blocks*, are a sequence of statements enclosed
    by braces `{ }`. Blocks are useful in control structures like `if` statements,
    because you might want multiple statements to execute rather than one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each block declares a new scope, which is called a *block scope*. As you learned
    in [Chapter 4](ch04.xhtml#ch04), objects with automatic storage duration declared
    within a block scope have lifetimes bound by the block. Variables declared within
    a block get destroyed in a well-defined order: the reverse of the order in which
    they were declared.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.xhtml#ch08ex02) uses the trusty `Tracer` class from [Listing
    4-5](ch04.xhtml#ch04ex05) (on [page 97](ch04.xhtml#page_97)) to explore block
    scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: A program exploring compound statements with the `Tracer` class*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.xhtml#ch08ex02) begins by initializing a `Tracer` called
    `main` ➊. Next, you generate two compound statements. The first compound statement
    begins with a left brace `{` followed by the block’s first statement, which prints
    `Block a` ➋. You create two `Tracers`, `a1` ➌ and `a2` ➍, and then close the block
    with a right brace `}`. These two tracers get destructed once execution passes
    through `Block a`. Notice that these two tracers destruct in reverse order from
    their initialization: `a2` then `a1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice another compound statement following `Block a`, where you print
    `Block b` ➎ and then construct two tracers, `b1` ➏ and `b2` ➐. Its behavior is
    identical: `b2` destructs followed by `b1`. Once execution passes through `Block
    b`, the scope of `main` ends and `Tracer main` finally destructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaration Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Declaration statements* (or just *declarations*) introduce identifiers, such
    as functions, templates, and namespaces, into your programs. This section explores
    some new features of these familiar declarations, as well as type aliases, attributes,
    and structured bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The expression `static_assert`, which you learned about in [Chapter 6](ch06.xhtml#ch06),
    is also a declaration statement.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *function declaration*, also called the function’s *signature* or *prototype*,
    specifies a function’s inputs and outputs. The declaration doesn’t need to include
    parameter names, only their types. For example, the following line declares a
    function called `randomize` that takes a `uint32_t` reference and returns `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that aren’t member functions are called *non-member functions*, or
    sometimes *free functions*, and they’re always declared outside of `main()` at
    namespace scope. A *function definition* includes the function declaration as
    well as the function’s body. A function’s declaration defines a function’s interface,
    whereas a function’s definition defines its implementation. For example, the following
    definition is one possible implementation of the `ran``domize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This `randomize` implementation is a linear congruential generator, a primitive
    kind of random number generator. See “Further Reading” on [page 241](ch08.xhtml#page_241)
    for sources of more information on generating random numbers.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve probably noticed, function declarations are optional. So why do they
    exist?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that you can use declared functions throughout your code as long
    as they’re eventually defined somewhere. Your compiler tool chain can figure it
    out. (You’ll learn how this works in [Chapter 21](ch21.xhtml#ch21).)
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 8-3](ch08.xhtml#ch08ex03) determines how many iterations
    the random number generator takes to get from the number 0x4c4347 to the number
    0x474343.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: A program that uses a function in `main` that isn’t defined until
    later*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare `randomize` ➊. Within `main`, you initialize an `iterations`
    counter variable to zero ➋ and a `number` variable to 0x4c4347 ➌. A `while` loop
    checks whether `number` equals the target 0x4c4347 ➍. If it doesn’t, you invoke
    `randomize` ➎ and increment `iterations` ➏. Notice that you haven’t yet defined
    `randomize`. Once `number` equals the target, you print the number of `iterations`
    ➐ before returning from `main`. Finally, you define `randomize` ➑. The program’s
    output shows that it takes almost a billion iterations to randomly draw the target
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Try to delete the definition of `randomize` and recompile. You should get an
    error stating that the definition of `randomize` couldn’t be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can similarly separate method declarations from their definitions. As with
    non-member functions, you can declare a method by omitting its body. For example,
    the following `RandomNumberGenerator` class replaces the `ran``domize` function
    with `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can construct a `RandomNumberGenerator` with a `seed` value ➊, which it
    uses to initialize the `number` member variable ➋. You’ve declared the `next`
    function using the same rules as non-member functions ➌. To provide the definition
    of `next`, you must use the scope resolution operator and the class name to identify
    which method you want to define. Otherwise, defining a method is the same as defining
    a non-member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This definition shares the same return type as the declaration ➊. The `RandomNumberGenerator::`
    construct specifies that you’re defining a method ➋. The function details are
    essentially the same ➌, except you’re returning a copy of the random number generator’s
    state rather than writing into a parameter reference ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-4](ch08.xhtml#ch08ex04) illustrates how you can refactor [Listing
    8-3](ch08.xhtml#ch08ex03) to incorporate `RandomNumberGenerator`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: A refactor of [Listing 8-3](ch08.xhtml#ch08ex03) using a `RandomNumberGenerator`
    class*'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 8-3](ch08.xhtml#ch08ex03), you’ve separated declaration from
    definition. After declaring a constructor that initializes an `iterations` member
    to zero ➊ and sets its `number` member to a `seed` ➋, the `next` ➌ and `get_iterations`
    ➍ method declarations don’t contain implementations. Within `main`, you initialize
    the `RandomNumberGenerator` class with your seed value of 0x4c4347 ➎ and invoke
    the `next` method to extract new random numbers ➏. The results are the same ➐.
    As before, the definitions of `next` and `get_iterations` follow their use in
    `main` ➑➒.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The utility of separating definition and declaration might not be apparent
    because you’ve been dealing with single-source-file programs so far. [Chapter
    21](ch21.xhtml#ch21) explores multiple-source-file programs where separating declaration
    and definition provides major benefits.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Namespaces***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Namespaces prevent naming conflicts. In large projects or when importing libraries,
    namespaces are essential for disambiguating exactly the symbols you’re looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: '**Placing Symbols Within Namespaces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By default, all symbols you declare go into the *global namespace*. The global
    namespace contains all the symbols that you can access without adding any namespace
    qualifiers. Aside from several classes in the `std` namespace, you’ve been using
    objects living exclusively in the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To place a symbol within a namespace other than the global namespace, you declare
    the symbol within a *namespace block*. A namespace block has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Namespaces can be nested in one of two ways. First, you can simply nest namespace
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can use the scope-resolution operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The latter approach is more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Symbols in Namespaces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To use a symbol within a namespace, you can always use the scope-resolution
    operator to specify the fully qualified name of a symbol. This allows you to prevent
    naming conflicts in large projects or when you’re using a third-party library.
    If you and another programmer use the same symbol, you can avoid ambiguity by
    placing the symbol within a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.xhtml#ch08ex05) illustrates how you can use fully qualified
    symbol names to access a symbol within a namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Nested namespace blocks using the scope-resolution operator*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.xhtml#ch08ex05) uses nested namespaces ➊ and declares a
    `Color` type ➋. To use `Color`, you apply the scope-resolution operator to specify
    the full name of the symbol, `BroopKidron13::Shaltanac::Color`. Because `Color`
    is an `enum class`, you use the scope-resolution operator to access its values,
    as when you assign `shaltanac_grass` to `Russet` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Directives**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can employ a `using` *directive* to avoid a lot of typing. A `using` directive
    imports a symbol into a block or, if you declare a `using` directive at namespace
    scope, into the current namespace. Either way, you have to type the full namespace
    path only once. The usage has the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding my-type gets imported into the current namespace or block,
    meaning you no longer have to use its full name. [Listing 8-6](ch08.xhtml#ch08ex06)
    refactors [Listing 8-5](ch08.xhtml#ch08ex05) with a using directive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: A refactor of [Listing 8-5](ch08.xhtml#ch08ex05) employing a
    using directive*'
  prefs: []
  type: TYPE_NORMAL
- en: With a `using` directive ➊ within `main`, you no longer have to type the namespace
    `BroopKidron13::Shaltanac` to use `Color` ➋➌.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re careful, you can introduce all the symbols from a given namespace
    into the global namespace with the `using namespace` directive.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-7](ch08.xhtml#ch08ex07) elaborates [Listing 8-6](ch08.xhtml#ch08ex06):
    the namespace `BroopKidron13::Shaltanac` contains multiple symbols, which you
    want to import into the global namespace to avoid a lot of typing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: A refactor of [Listing 8-6](ch08.xhtml#ch08ex06) with multiple
    symbols imported into the global namespace*'
  prefs: []
  type: TYPE_NORMAL
- en: With a `using namespace` directive ➊, you can use classes ➋, enum classes ➌,
    functions ➍, and so on within your program without having to type fully qualified
    names. Of course, you need to be very careful about clobbering existing types
    in the global namespace. Usually, it’s a bad idea to have too many `using namespace`
    directives appear in a single translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should never put a using namespace directive within a header file. Every
    source file that includes your header will dump all the symbols from that using
    directive into the global namespace. This can cause issues that are very difficult
    to debug.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Type Aliasing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *type alias* defines a name that refers to a previously defined name. You
    can use a type alias as a synonym for the existing type name.
  prefs: []
  type: TYPE_NORMAL
- en: There is no difference between a type and any type aliases referring to it.
    Also, type aliases cannot change the meaning of an existing type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a type alias, you use the following format, where type-alias is
    the type alias name and type-id is the target type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 8-8](ch08.xhtml#ch08ex08) employs two type aliases, `String` and `ShaltanacColor`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: A refactor of [Listing 8-7](ch08.xhtml#ch08ex07) with a type
    alias*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-8](ch08.xhtml#ch08ex08) declares a type alias `String` that refers
    to a `const char[260]` ➊. This listing also declares a `ShaltanacColor` type alias,
    which refers to `BroopKidron13::Shaltanac::Color` ➋. You can use these type aliases
    as drop-in replacements to clean up code. Within `main`, you use `ShaltanacColor`
    to remove all the nested namespaces ➌ and `String` to make the declaration of
    `saying` cleaner ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Type aliases can appear in any scope—block, class, or namespace.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can introduce template parameters into type aliases. This enables two important
    usages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can perform partial application on template parameters. *Partial application*
    is the process of fixing some number of arguments to a template, producing another
    template with fewer template parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define a type alias for a template with a fully specified set of template
    parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template instantiations can be quite verbose, and type aliases help you avoid
    carpal tunnel syndrome.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-9](ch08.xhtml#ch08ex09) declares a `NarrowCaster` class with two
    template parameters. You then use a type alias to partially apply one of its parameters
    and produce a new type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: A partial application of the `NarrowCaster` class using a type
    alias*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you implement a `NarrowCaster` template class that has the same functionality
    as the `narrow_cast` function template in [Listing 6-6](ch06.xhtml#ch06ex06) (on
    [page 154](ch06.xhtml#page_154)): it will perform a `static_cast` and then check
    for narrowing ➊. Next, you declare a type alias `short_caster` that partially
    applies `short` as the `To` type to `NarrowCast`. Within `main`, you declare a
    `caster` object of type `short_caster<int>` ➌. The single template parameter in
    the `short_caster` type alias gets applied to the remaining type parameter from
    the type alias—`From` ➋. In other words, the type `short_cast<int>` is synonymous
    with `NarrowCaster<short, int>`. In the end, the result is the same: with a 2-byte
    short, you get a narrowing exception when trying to cast an `int` with the value
    142857 into a `short` ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Structured Bindings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Structured bindings* enable you to unpack objects into their constituent elements.
    Any type whose non-static data members are public can be unpacked this way—for
    example, the POD (plain-old-data class) types introduced in [Chapter 2](ch02.xhtml#ch02).
    The *structured binding syntax* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This line will initialize an arbitrary number of objects (object-1, object-2,
    and so on) by peeling them off a POD object one by one. The objects peel off the
    POD from top to bottom, and they fill in the structured binding from left to right.
    Consider a `read_text_file` function that takes a string argument corresponding
    to the file path. Such a function might fail, for example, if a file is locked
    or doesn’t exist. You have two options for handling errors:'
  prefs: []
  type: TYPE_NORMAL
- en: You can throw an exception within `read_text_file`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can return a success status code from the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the second option.
  prefs: []
  type: TYPE_NORMAL
- en: The POD type in [Listing 8-10](ch08.xhtml#ch08ex10) will serve as a fine return
    type from the `read_text_file` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: A `TextFile` type that will be returned by the `read_text_file`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: First, a flag communicates to the caller whether the function call was a `success`
    ➊. Next is the contents of the `file` ➋ and its size `n_bytes` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype of `read_text_file` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can use a structured binding declaration to unpack a `TextFile` into its
    parts within your program, as in [Listing 8-11](ch08.xhtml#ch08ex11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: A program simulating the reading of a text file that returns
    a POD that you use in a structured binding*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve declared the `TextFile` ➊ and then provided a dummy definition for `read_text_file`
    ➋. (It doesn’t actually read a file; more on that in [Part II](part02.xhtml#part02).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `main`, you invoke `read_text_file` ➍ and use a structured binding declaration
    to unpack the results into three distinct variables: `success`, `contents`, and
    `length` ➌. After structured binding, you can use all these variables as though
    you had declared them individually ➎➏➐.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The types within a structured binding declaration don’t have to match.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Attributes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Attributes apply implementation-defined features to an expression statement.
    You introduce attributes using double brackets `[[ ]]` containing a list of one
    or more comma-separated attribute elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](ch08.xhtml#ch08tab01) lists the standard attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** The Standard Attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `[[noreturn]]` | Indicates that a function doesn’t return. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[deprecated("`reason`")]]` | Indicates that this expression is deprecated;
    that is, its use is discouraged. The `"reason"` is optional and indicates the
    reason for deprecation. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[fallthrough]]` | Indicates that a switch case intends to fall through
    to the next switch case. This avoids compiler errors that will check for switch
    case fallthrough, because it’s uncommon. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[nodiscard]]` | Indicates that the following function or type declaration
    should be used. If code using this element discards the value, the compiler should
    emit a warning. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[maybe_unused]]` | Indicates that the following element might be unused
    and that the compiler shouldn’t warn about it. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[carries_dependency]]` | Used within the `<atomic>` header to help the
    compiler optimize certain memory operations. You’re unlikely to encounter this
    directly. |'
  prefs: []
  type: TYPE_TB
- en: '[Listing 8-12](ch08.xhtml#ch08ex12) demonstrates using the `[[noreturn]]` attribute
    by defining a function that never returns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: A program illustrating the use of the `[[noreturn]]` attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare the `pitcher` function with the `[[noreturn]]` attribute
    ➊. Within this function, you throw an exception ➋. Because you always throw an
    exception, `pitcher` never returns (hence the `[[noreturn]]` attribute). Within
    `main`, you invoke `pitcher` ➌ and handle the caught exception ➍. Of course, this
    listing works without the `[[noreturn]]` attribute. But giving this information
    to the compiler allows it to reason more completely on your code (and potentially
    to optimize your program).
  prefs: []
  type: TYPE_NORMAL
- en: The situations in which you’ll need to use an attribute are rare, but they convey
    useful information to the compiler nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Selection statements* express conditional control flow. The two varieties
    of selection statements are the `if` statement and the `switch` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '***if Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `if` statement has the familiar form shown in [Listing 8-13](ch08.xhtml#ch08ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: The syntax of the `if` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: Upon encountering an `if` statement, you evaluate the condition-1 expression
    first. If it’s `true`, the block at ➊ is executed and the `if` statement stops
    executing (none of the `else if` or `else` statements are considered). If it’s
    `false`, the `else if` statements’ conditions evaluate in order. These are optional,
    and you can supply as many as you like.
  prefs: []
  type: TYPE_NORMAL
- en: If condition-2 evaluates to `true`, for example, the block at ➋ will execute
    and none of the remaining `else if` or `else` statements are considered. Finally,
    the `else` block at ➌ executes if all of the preceding conditions evaluate to
    `false`. Like the `else if` blocks, the `else` block is optional.
  prefs: []
  type: TYPE_NORMAL
- en: The function template in [Listing 8-14](ch08.xhtml#ch08ex14) converts an `else`
    argument into `Positive`, `Negative`, or `Zero`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: An example usage of the `if` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: The `sign` function takes a single argument and determines if it’s equal to
    0 ➊, greater than 0 ➋, or less than 0 ➌. Depending on which condition matches,
    it sets the automatic variable result equal to one of three strings—`zero`, `positive`,
    or `negative`—and returns this value to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization Statements and if**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can bind an object’s scope to an `if` statement by adding an `init-state``ment`
    to `if` and `else if` declarations, as demonstrated in [Listing 8-15](ch08.xhtml#ch08ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15: An `if` statement with initializations*'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this pattern with structured bindings to produce elegant error handling.
    [Listing 8-16](ch08.xhtml#ch08ex16) refactors [Listing 8-11](ch08.xhtml#ch08ex11)
    using the initialization statement to scope a `TextFile` to the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16: An extension of [Listing 8-11](ch08.xhtml#ch08ex11) using structured
    binding and an `if` statement to handle errors*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve moved the structured binding declaration into the initialization statement
    portion of the `if` statement ➊. This scopes each of the unpacked objects—`success`,
    `txt`, and `len`—to the `if` block. You use `success` directly within the conditional
    expression of `if` to determine whether `read_text_file` was successful ➋. If
    it was, you print the contents of `REAMDE.txt` ➌. If it wasn’t, you print an error
    message ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**constexpr if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can make an `if` statement `constexpr`; such statements are known as `constexpr
    if` statements. A `constexpr if` statement is evaluated at compile time. Code
    blocks that correspond to `true` conditions get emitted, and the rest is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the `constexpr if` follows usage for a regular `if` statement, as demonstrated
    in [Listing 8-17](ch08.xhtml#ch08ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17: Usage of the `constexpr if` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: In combination with templates and the `<type_traits>` header, `constexpr` `if`
    statements are extremely powerful. A major use for `constexpr if` is to provide
    custom behavior in a function template depending on some attributes of type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The function template `value_of` in [Listing 8-18](ch08.xhtml#ch08ex18) accepts
    pointers, references, and values. Depending on which kind of object the argument
    is, `value_of` returns either the pointed-to value or the value itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18: An example function template, `value_of`, employing a `constexpr
    if` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: The `value_of` function template accepts a single argument `x` ➊. You determine
    whether the argument is a pointer type using the `std::is_pointer<T>` type trait
    as the conditional expression in a `constexpr if` statement ➋. In case `x` is
    a pointer type, you check for `nullptr` and throw an exception if one is encountered
    ➌. If `x` isn’t a `nullptr`, you dereference it and return the result ➍. Otherwise,
    `x` is not a pointer type, so you return it (because it is therefore a value)
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you instantiate `value_of` multiple times with an `unsigned long`
    pointer ➏, an `unsigned long` reference ➐, an `unsigned long` ➑, and a `nullptr`
    ➒ respectively.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, the `constexpr if` statement disappears; each instantiation of `value_of`
    contains one branch of the selection statement or the other. You might be wondering
    why such a facility is useful. After all, programs are meant to do something useful
    at runtime, not at compile time. Just flip back to [Listing 7-17](ch07.xhtml#ch07ex17)
    (on [page 206](ch07.xhtml#page_206)), and you’ll see that compile time evaluation
    can substantially simplify your programs by eliminating magic values.
  prefs: []
  type: TYPE_NORMAL
- en: There are other examples where compile time evaluation is popular, especially
    when creating libraries for others to use. Because library writers usually cannot
    know all the ways their users will utilize their library, they need to write generic
    code. Often, they’ll use techniques like those you learned in [Chapter 6](ch06.xhtml#ch06)
    so they can achieve compile-time polymorphism. Constructs like `constexpr` can
    help when writing this kind of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have a C background, you’ll immediately recognize the utility of compile
    time evaluation when considering that it almost entirely replaces the need for
    preprocessor macros.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***switch Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.xhtml) first introduced the venerable `switch` statement.
    This section delves into the addition of the initialization statement into the
    `switch` declaration. The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As with `if` statements, you can instantiate within `switch` statements ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-19](ch08.xhtml#ch08ex19) employs an initialization statement within
    a `switch` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-19: Using an initialization expression in a `switch` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare the familiar `Color` `enum class` ➊ and join it with a `char*` member
    to form the POD type `Result` ➋. The function `observe_shrub` returns a `Result`
    ➌. Within `main`, you call `observe_shrub` within the initialization expression
    and store the result in the `result` variable ➍. Within the conditional expression
    of `switch`, you extract the `color` element of this `result` ➎. This element
    determines the case that executes (and sets the `description` pointer) ➏.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `if`-statement-plus-initializer syntax, any object initialized in
    the initialization expression is bound to the scope of the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iteration Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Iteration statements* execute a statement repeatedly. The four kinds of iteration
    statements are the `while` loop, the `do`-`while` loop, the `for` loop, and the
    range-based `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '***while Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `while` loop is the basic iteration mechanism. The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before executing an iteration of the loop, the `while` loop evaluates the `condition`
    expression. If `true`, the loop continues. If `false`, the loop terminates, as
    demonstrated in [Listing 8-20](ch08.xhtml#ch08ex20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-20: A program that doubles a `uint8_t` and prints the new value
    on each iteration*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `double_return_overflow` function taking an 8-bit, unsigned integer
    by reference ➊. This function doubles the argument and checks whether this causes
    an overflow. If it does, it returns `true`. If no overflow occurs, it returns
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: You initialize the variable `x` to 1 before entering the `while` loop ➋. The
    conditional expression in the `while` loop evaluates `double_return_overflow(x)`
    ➌. This has the side effect of doubling `x`, because you’ve passed it by reference.
    It also returns a value telling you whether the doubling caused `x` to overflow.
    The loop will execute when the conditional expression evaluates to `true`, but
    `double_return_overflow` is written so it returns `true` when the loop should
    stop. You fix this problem by prepending the logical negation operator (`!`).
    (Recall from [Chapter 7](ch07.xhtml#ch07) that this turns `true` to `false` and
    `false` to `true`.) So the `while` loop is actually asking, “If it’s NOT true
    that `double_return_overflow` is true . . .”
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that you print the values 2, then 4, then 8, and so on to
    128 ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the value 1 never prints, because evaluating the conditional expression
    doubles `x`. You can modify this behavior by putting the conditional statement
    at the end of a loop, which yields a `do`-`while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***do-while Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `do`-`while` loop is identical to a `while` loop, except the conditional
    statement evaluates after a loop completes rather than before. Its usage is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because the condition evaluates at the end of a loop, you guarantee that the
    loop will execute at least once.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-21](ch08.xhtml#ch08ex21) refactors [Listing 8-20](ch08.xhtml#ch08ex20)
    into a `do`-`while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-21: A program that doubles a `uint8_t` and prints the new value
    on each iteration*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the output from [Listing 8-21](ch08.xhtml#ch08ex21) now begins with
    1 ➊. All you needed to do was reformat the `while` loop to put the condition at
    the end of the loop ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most situations involving iterations, you have three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize some object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the object before each iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the object’s value for some condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use a `while` or `do`-`while` loop to accomplish part of these tasks,
    but the `for` loop provides built-in facilities that make life easier.
  prefs: []
  type: TYPE_NORMAL
- en: '***for Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` loop is an iteration statement containing three special expressions:
    *initialization*, *conditional*, and *iteration*, as described in the sections
    that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Initialization Expression**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The initialization expression is like the initialization of `if`: it executes
    only once before the first iteration executes. Any objects declared within the
    initialization expression have lifetimes bound by the scope of the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Conditional Expression**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `for` loop conditional expression evaluates just before each iteration of
    the loop. If the conditional evaluates to `true`, the loop continues to execute.
    If the conditional evaluates to `false`, the loop terminates (this behavior is
    exactly like the conditional of the `while` and `do`-`while` loops).
  prefs: []
  type: TYPE_NORMAL
- en: Like `if` and `switch` statements, `for` permits you to initialize objects with
    scope equal to the statement’s.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Iteration Expression**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After each iteration of the `for` loop, the iteration expression evaluates.
    This happens before the conditional expression evaluates. Note that the iteration
    expression evaluates after a successful iteration, so the iteration expression
    won’t execute before the first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify, the following list outlines the typical execution order in a `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Loop body)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteration expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Loop body)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 4 through 6 repeat until a conditional expression returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Usage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 8-22](ch08.xhtml#ch08ex22) demonstrates the use of a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-22: Using a `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization ➊, conditional ➋, and iteration ➌ expressions reside in parentheses
    preceding the body of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterating with an Index**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `for` loops are excellent at iterating over an array-like object’s constituent
    elements. You use an auxiliary *index* variable to iterate over the range of valid
    indices for the array-like object. You can use this index to interact with each
    array element in sequence. [Listing 8-23](ch08.xhtml#ch08ex23) employs an index
    variable to print each element of an array along with its index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-23: A program iterating over an array of Fibonacci numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize an `int` array called `x` with the first six Fibonacci numbers
    ➊. After printing a header for the output ➋, you build a `for` loop containing
    your initialization ➌, conditional ➍, and iteration ➎ expressions. The initialization
    expression executes first, and it initializes the index variable `i` to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-23](ch08.xhtml#ch08ex23) shows a coding pattern that hasn’t changed
    since the 1950s. You can eliminate a lot of boilerplate code by using the more
    modern range-based `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Ranged-Based for Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The range-based `for` loop iterates over a *range* of values without needing
    an index variable. A range (or *range expression*) is an object that the range-based
    `for` loop knows how to iterate over. Many C++ objects are valid range expressions,
    including arrays. (All of the stdlib containers you’ll learn about in [Part II](part02.xhtml#part02)
    are also valid range expressions.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Usage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ranged-based `for` loop usage looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A *range declaration* declares a named variable. This variable must have the
    same type as implied by the range expression (you can use `auto`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-24](ch08.xhtml#ch08ex24) refactors [Listing 8-23](ch08.xhtml#ch08ex23)
    to use a range-based `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-24: A range-based `for` loop iterating over the first six Fibonacci
    numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: You still declare an array `x` containing six Fibonacci numbers ➊. The range-based
    `for` loop contains a range-declaration expression ➋ where you declare the `element`
    variable to hold each element of the range. It also contains the range expression
    `x` ➌, which contains the elements you want to iterate over to print ➍.
  prefs: []
  type: TYPE_NORMAL
- en: This code is a whole lot cleaner!
  prefs: []
  type: TYPE_NORMAL
- en: '**Range Expressions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can define your own types that are also valid range expressions. But you’ll
    need to specify several functions on your type.
  prefs: []
  type: TYPE_NORMAL
- en: Every range exposes a `begin` and an `end` method. These functions represent
    the common interface that a range-based `for` loop uses to interact with a range.
    Both methods return *iterators*. An iterator is an object that supports `operator!=`,
    `operator++`, and `operator*`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how all these pieces fit together. Under the hood, a range-based
    `for` loop looks just like the loop in [Listing 8-25](ch08.xhtml#ch08ex25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-25: A `for` loop simulating a range-based `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization expression stores two variables, `b` ➋ and `e` ➊, which you
    initialize to `range.begin()` and `range.end()` respectively. The conditional
    expression checks whether `b` equals `e`, in which case the loop has completed
    ➌ (this is by convention). The iteration expression increments `b` with the prefix
    operator ➍. Finally, the iterator supports the dereference operator `*`, so you
    can extract the pointed-to element ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The types returned by `begin` and `end` don’t need to be the same. The requirement
    is that `operator!=` on `begin` accepts an `end` argument to support the comparison
    `begin != end`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Fibonacci Range**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can implement a `FibonacciRange`, which will generate an arbitrarily long
    sequence of Fibonacci numbers. From the previous section, you know that this range
    must offer a `begin` and an `end` method that returns an iterator. This iterator,
    which is called `FibonacciIterator` in this example, must in turn offer `operator!=`,
    `operator++`, and `operator*`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-26](ch08.xhtml#ch08ex26) implements a `FibonacciIterator` and a
    `FibonacciRange`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-26: An implementation of `FibonacciIterator` and `FibonacciRange`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `FibonacciIterator` has two fields, `current` and `last`, which are initialized
    to 1\. These keep track of two values in the Fibonacci sequence. Its `operator!=`
    checks whether the argument is greater than or equal to `current` ➊. Recall that
    this argument is used within the range-based `for` loop in the conditional expression.
    It should return `true` if elements remain in the range; otherwise, it returns
    `false`. The `operator++` appears in the iteration expression and is responsible
    for setting up the iterator for the next iteration. You first save `current` value
    into the temporary variable `tmp` ➋. Next, you increment current by `last`, yielding
    the next Fibonacci number ➌. (This follows from the definition of a Fibonacci
    sequence.) Then you set `last` equal to `tmp` ➍ and return a reference to `this`
    ➎. Finally, you implement `operator*`, which returns `current` ➏ directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`FibonacciRange` is much simpler. Its constructor takes a max argument that
    defines an upper limit for the range ➐. The `begin` method returns a fresh `FibonacciIterator`
    ➑, and the `end` method returns `max` ➒.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should now be apparent why you need to implement `bool operator!=(int x)`
    on `FibonacciIterator` rather than, for example, `bool operator!=(const FibonacciIterator&
    x)`: a `FibonacciRange` returns an `int` from `end()`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `FibonacciRange` in a ranged-based `for` loop, as demonstrated
    in [Listing 8-27](ch08.xhtml#ch08ex27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-27: Using `FibonacciRange` in a program*'
  prefs: []
  type: TYPE_NORMAL
- en: It took a little work to implement `FibonacciIterator` and `FibonacciRange`
    in [Listing 8-26](ch08.xhtml#ch08ex26), but the payoff is substantial. Within
    `main`, you simply construct a `FibonacciRange` with the desired upper limit ➊,
    and the range-based `for` loop takes care of everything else for you. You simply
    use the resulting elements within the `for` loop ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-27](ch08.xhtml#ch08ex27) is functionally equivalent to [Listing
    8-28](ch08.xhtml#ch08ex28), which converts the range-based `for` loop to a traditional
    `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-28: A refactor of [Listing 8-27](ch08.xhtml#ch08ex27) using a traditional
    `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-28](ch08.xhtml#ch08ex28) demonstrates how all of the pieces fit
    together. Calling `range.begin()` ➋ yields a `FibonacciIterator`. When you call
    `range.end()` ➊, it yields an `int`. These types come straight from the method
    definitions of `begin()` and `end()` on `FibonacciRange`. The conditional statement
    ➌ uses `operator!=(int)` on `FibonacciIterator` to get the following behavior:
    if the iterator `x` has gone past the `int` argument to `operator!=`, the conditional
    evaluates to `false` and the loop ends. You’ve also implemented `operator++` on
    `FibonacciIterator` so `++x` ➍ increments the Fibonacci number within `FibonacciIterator`.'
  prefs: []
  type: TYPE_NORMAL
- en: When you compare [Listings 8-27](ch08.xhtml#ch08ex27) and [8-28](ch08.xhtml#ch08ex28),
    you can see just how much tedium range-based `for` loops hide.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might be thinking, “Sure, the range-based `for` loop looks a lot cleaner,
    but implementing `FibonacciIterator` and `FibonacciRange` is a lot of work.” That’s
    a great point, and for one-time-use code, you probably wouldn’t refactor code
    in this way. Ranges are mainly useful if you’re writing library code, writing
    code that you’ll reuse often, or simply consuming ranges that someone else has
    written.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jump Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Jump statements*, including the `break`, `continue`, and `goto` statements,
    transfer control flow. Unlike selection statements, jump statements are not conditional.
    You should avoid using them because they can almost always be replaced with higher-level
    control structures. They’re discussed here because you might see them in older
    C++ code and they still play a central role in a lot of C code.'
  prefs: []
  type: TYPE_NORMAL
- en: '***break Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `break` statement terminates execution of the enclosing iteration or `switch`
    statement. Once `break` completes, execution transfers to the statement immediately
    following the `for`, range-based `for`, `while`, `do`-`while`, or `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already used `break` within `switch` statements; once a case completes,
    the `break` statement terminates the `switch`. Recall that, without a `break`
    statement, the `switch` statement would continue executing all of the following
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-29](ch08.xhtml#ch08ex29) refactors [Listing 8-27](ch08.xhtml#ch08ex27)
    to break out of a range-based `for` loop if the iterator `i` equals 21.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-29: A refactor of [Listing 8-27](ch08.xhtml#ch08ex27) that breaks
    if the iterator equals 21*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `if` statement is added that checks whether `i` is 21 ➊. If it is, you print
    three asterisks `***` ➋ and `break` ➌. Notice the output: rather than printing
    21, the program prints three asterisks and the `for` loop terminates. Compare
    this to the output of [Listing 8-27](ch08.xhtml#ch08ex27).'
  prefs: []
  type: TYPE_NORMAL
- en: '***continue Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `continue` statement skips the remainder of an enclosing iteration statement
    and continues with the next iteration. [Listing 8-30](ch08.xhtml#ch08ex30) replaces
    the `break` in [Listing 8-29](ch08.xhtml#ch08ex29) with a `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-30: A refactor of [Listing 8-29](ch08.xhtml#ch08ex29) to use `continue`
    instead of `break`*'
  prefs: []
  type: TYPE_NORMAL
- en: You still print three asterisks ➊ when `i` is 21, but you use `continue` instead
    of `break` ➋. This causes 21 not to print, like [Listing 8-29](ch08.xhtml#ch08ex29);
    however, unlike [Listing 8-29](ch08.xhtml#ch08ex29), [Listing 8-30](ch08.xhtml#ch08ex30)
    continues iterating. (Compare the output.)
  prefs: []
  type: TYPE_NORMAL
- en: '***goto Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `goto` statement is an unconditional jump. The target of a `goto` statement
    is a label.
  prefs: []
  type: TYPE_NORMAL
- en: '**Labels**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Labels* are identifiers you can add to any statement. Labels give statements
    a name, and they have no direct impact on the program. To assign a label, prepend
    a statement with the desired name of the label followed by a colon.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-31](ch08.xhtml#ch08ex31) adds the labels `luke` and `yoda` to a
    simple program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-31: A simple program with labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The labels ➊➋ do nothing on their own.
  prefs: []
  type: TYPE_NORMAL
- en: '**goto Usage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `goto` statement’s usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For example, you can employ `goto` statements to needlessly obfuscate the simple
    program in [Listing 8-32](ch08.xhtml#ch08ex32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-32: Spaghetti code showcasing the `goto` statement*'
  prefs: []
  type: TYPE_NORMAL
- en: Control flow in [Listing 8-32](ch08.xhtml#ch08ex32) passes to `silent_bob` ➊,
    then to `luke` ➋, and then to `yoda` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Role of goto in Modern C++ Programs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In modern C++, there is no good role for `goto` statements. Don’t use them.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In poorly written C++ (and in most C code), you might see `goto` used as a
    primitive error-handling mechanism. A lot of system programming entails acquiring
    resources, checking for error conditions, and cleaning up resources. The RAII
    paradigm neatly abstracts all of these details, but C doesn’t have RAII available.
    See the Overture to C Programmers on [page xxxvii](anoverture.xhtml#page_xxxvii)
    for more information.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you worked through different kinds of statements you can employ
    in your programs. They included declarations and initializations, selection statements,
    and iteration statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep in mind that `try-catch` blocks are also statements, but they were already
    discussed in great detail in [Chapter 4](ch04.xhtml#ch04).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**8-1.** Refactor [Listing 8-27](ch08.xhtml#ch08ex27) into separate translation
    units: one for `main` and another for `FibonacciRange` and `FibonacciIterator`.
    Use a header file to share definitions between the two translation units.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8-2.** Implement a `PrimeNumberRange` class that can be used in a range expression
    to iterate over all prime numbers less than a given value. Again, use a separate
    header and source file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8-3.** Integrate `PrimeNumberRange` into [Listing 8-27](ch08.xhtml#ch08ex27),
    adding another loop that generates all prime numbers less than 5,000.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Random Number Generation and Monte Carlo Methods*, 2nd Edition, by James E.
    Gentle (Springer-Verlag, 2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Random Number Generation and Quasi-Monte Carlo Methods* by Harald Niederreiter
    (SIAM Vol. 63, 1992)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
