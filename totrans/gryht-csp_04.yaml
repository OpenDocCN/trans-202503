- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: AUTOMATING NESSUS
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nessus is a popular and powerful vulnerability scanner that uses a database
    of known vulnerabilities to assess whether a given system on a network is missing
    any patches or is vulnerable to known exploits. In this chapter, I’ll show you
    how to write classes to interact with the Nessus API to automate, configure, and
    run a vulnerability scan.
  prefs: []
  type: TYPE_NORMAL
- en: Nessus was first developed as an open source vulnerability scanner, but it became
    closed source in 2005 after being purchased by Tenable Network Security. As of
    this writing, Tenable offers a seven-day trial of Nessus Professional and a limited
    version called Nessus Home. The biggest difference between the two is that Nessus
    Home allows you to scan only 16 IP addresses at once, but Home should be sufficient
    for you to run the examples in this chapter and become familiar with the program.
    Nessus is particularly popular with professionals who help scan and manage other
    companies’ networks. Follow the instructions on the Tenable site [https://www.tenable.com/products/nessus-home/](https://www.tenable.com/products/nessus-home/)
    to install and configure Nessus Home.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations require regular vulnerability and patch scanning in order
    to manage and identify risks on their network, as well as for compliance purposes.
    We’ll use Nessus to accomplish these goals by building classes to help us perform
    unauthenticated vulnerability scans against hosts on a network.
  prefs: []
  type: TYPE_NORMAL
- en: REST and the Nessus API
  prefs: []
  type: TYPE_NORMAL
- en: The advent of web applications and APIs has given rise to an architecture of
    APIs called REST APIs. REST (representational state transfer) is a way of accessing
    and interacting with resources (such as user accounts or vulnerability scans)
    on the server, usually over HTTP, using a variety of HTTP methods (GET, POST,
    DELETE, and PUT). HTTP methods describe our intent in making the HTTP request
    (for example, do we want to create a resource or modify a resource?), kind of
    like CRUD (Create, Read, Update, Delete) operations in databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, take a look at the following simple GET HTTP request, which is
    like a read operation for a database (like SELECT * FROM users WHERE id = 1):
    GET /users/➊1 HTTP/1.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 192.168.0.11'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’re requesting information for the user with an ID of 1\.
    To get the information for another user’s ID, you could replace the 1 ➊ at the
    end of the URI with that user’s ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the information for the first user, the HTTP request might look like
    this: POST /users/1 HTTP/1.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 192.168.0.11'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 24'
  prefs: []
  type: TYPE_NORMAL
- en: '{"name": "Brandon Perry"}'
  prefs: []
  type: TYPE_NORMAL
- en: In our hypothetical RESTful API, the preceding POST request would update the
    first user’s name to Brandon Perry. Commonly, POST requests are used to update
    a resource on the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the account entirely, use DELETE, like so: DELETE /users/1 HTTP/1.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 192.168.0.11'
  prefs: []
  type: TYPE_NORMAL
- en: The Nessus API will behave similarly. When consuming the API, we’ll send JSON
    to and receive JSON from the server, as in these examples. The classes we’ll write
    in this chapter are designed to handle the ways that we communicate and interact
    with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Nessus installed, you can find the Nessus REST API documentation
    at https://<IP address>:8834/api. We’ll cover only a few of the core API calls
    used to drive Nessus to perform vulnerability scans.
  prefs: []
  type: TYPE_NORMAL
- en: The NessusSession Class
  prefs: []
  type: TYPE_NORMAL
- en: To automate sending commands and receiving responses from Nessus, we’ll create
    a session with the NessusSession class and execute API commands, as shown in [Listing
    5-1](#filepos426644).
  prefs: []
  type: TYPE_NORMAL
- en: 'public class NessusSession : ➊IDisposable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➋NessusSession(string host, string username, string password)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ServicePointManager.ServerCertificateValidationCallback =
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Host = ➌host;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➍!Authenticate(username, password))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: throw new Exception("Authentication failed");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool ➎Authenticate(string username, string password)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject obj = ➏new JObject();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: obj["username"] = username;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: obj["password"] = password;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject ret = ➐MakeRequest(WebRequestMethods.Http.Post, "/session", obj);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret ["token"] == null)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return false;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➑Token = ret["token"].Value<string>();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Authenticated = true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-1: The beginning of the  NessusSession  class showing the constructor
    and  Authenticate()  method'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Listing 5-1](#filepos426644), this class implements the IDisposable
    interface ➊ so that we can use the NessusSession class within a using statement.
    As you may recall from earlier chapters, the IDisposable interface allows us to
    automatically clean up our session with Nessus by calling Dispose(), which we’ll
    implement shortly, when the currently instantiated class in the using statement
    is disposed during garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: At ➌, we assign the Host property to the value of the host parameter passed
    to the NessusSession constructor ➋, and then we try to authenticate ➍ since any
    subsequent API calls will require an authenticated session. If authentication
    fails, we throw an exception and print the alert "Authentication failed". If authentication
    succeeds, we store the API key for later use.
  prefs: []
  type: TYPE_NORMAL
- en: In the Authenticate() method ➎, we create a JObject ➏ to hold the credentials
    passed in as arguments. We’ll use these to attempt to authenticate, and then we’ll
    call the MakeRequest() method ➐ (discussed next) and pass the HTTP method, the
    URI of the target host, and the JObject. If authentication succeeds, MakeRequest()
    should return a JObject with an authentication token; if authentication fails,
    it should return an empty JObject.
  prefs: []
  type: TYPE_NORMAL
- en: When we receive the authentication token, we assign its value to the Token property
    ➑, assign the Authenticated property to true, and return true to the caller method
    to tell the programmer that authentication succeeded. If authentication fails,
    we return false.
  prefs: []
  type: TYPE_NORMAL
- en: Making the HTTP Requests
  prefs: []
  type: TYPE_NORMAL
- en: The MakeRequest() method makes the actual HTTP requests and then returns the
    responses, as shown in [Listing 5-2](#filepos431563).
  prefs: []
  type: TYPE_NORMAL
- en: public JObject MakeRequest(string method, string uri, ➊JObject data = null,
    string token = null)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string url = ➋"https://" + this.Host + ":8834" + uri;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.➌Method = method;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (!string.IsNullOrEmpty(token))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.Headers ["X-Cookie"] = ➍"token=" + token;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.➎ContentType = "application/json";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (data != null)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] bytes = System.Text.Encoding.ASCII.➏GetBytes(data.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.ContentLength = bytes.Length;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream requestStream = request.GetRequestStream())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: requestStream.➐Write(bytes, 0, bytes.Length);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.ContentLength = 0;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = string.Empty;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try ➑
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader reader = new ➒StreamReader(request.GetResponse().GetResponseStream()))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: response = reader.ReadToEnd();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: catch
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return new JObject();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrEmpty(response))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return new JObject();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return JObject.➓Parse(response);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-2: The  MakeRequest()  method from the  NessusSession  class'
  prefs: []
  type: TYPE_NORMAL
- en: The MakeRequest() method has two required parameters (HTTP and URI) and two
    optional ones (the JObject and the authentication token). The default value for
    each is null.
  prefs: []
  type: TYPE_NORMAL
- en: To create MakeRequest(), we first create the base URL for the API calls ➋ by
    combining the host and URI parameters and passing in the result as the second
    argument; then we use HttpWebRequest to build the HTTP request and set the property
    of HttpWebRequest Method ➌ to the value of the method variable passed into MakeRequest()
    method. Next, we test whether the user supplied an authentication token in JObject.
    If so, we assign the HTTP request header X-Cookie to the value of the token parameter
    ➍, which Nessus will look for when we authenticate. We set the ContentType property
    ➎ of the HTTP request to application/json to ensure that the API server knows
    how to deal with the data we are sending in the body of the request (otherwise,
    it will refuse to accept the request).
  prefs: []
  type: TYPE_NORMAL
- en: If a JObject is passed to MakeRequest() in the third argument ➊, we convert
    it to a byte array using GetBytes() ➏, because the Write() method can only write
    bytes. We assign the ContentLength property to the size of the array and then
    use Write() ➐ to write the JSON to the request stream. If the JObject passed to
    MakeRequest() is null, we simply assign the value 0 to ContentLength and move
    on, since we will not be putting any data in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: Having declared an empty string to hold the response from the server, we begin
    a try/catch block at ➑ to receive the response. Within a using statement, we create
    a StreamReader ➒ to read the HTTP response by passing the server’s HTTP response
    stream to the StreamReader constructor; then we call ReadToEnd() to read the full
    response body into our empty string. If reading the response causes an exception,
    we can expect that the response body is empty, so we catch the exception and return
    an empty JObject to ReadToEnd(). Otherwise, we pass the response to Parse() ➓
    and return the resulting JObject.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Out and Cleaning Up
  prefs: []
  type: TYPE_NORMAL
- en: To finish the NessusSession class, we’ll create LogOut() to log us out of the
    server and Dispose() to implement the IDisposable interface, as shown in [Listing
    5-3](#filepos436162).
  prefs: []
  type: TYPE_NORMAL
- en: public void ➊LogOut()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.Authenticated)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MakeRequest("DELETE", "/session", null, this.Token);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Authenticated = false;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void ➋Dispose()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (this.Authenticated)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.LogOut();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Host { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool Authenticated { get; private set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Token { get; private set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-3: The last two methods of the  NessusSession  class, as well as
    the  Host, Authenticated, and  Token  properties'
  prefs: []
  type: TYPE_NORMAL
- en: The LogOut() method ➊ tests whether we’re authenticated with the Nessus server.
    If so, we call MakeRequest() by passing DELETE as the HTTP method; /session as
    the URI; and the authentication token, which sends a DELETE HTTP request to the
    Nessus server, effectively logging us out. Once the request is complete, we set
    the Authenticated property to false. In order to implement the IDisposable interface,
    we create Dispose() ➋ to log us out if we are authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the NessusSession Class
  prefs: []
  type: TYPE_NORMAL
- en: We can easily test the NessusSession class with a small Main() method, as shown
    in [Listing 5-4](#filepos438162).
  prefs: []
  type: TYPE_NORMAL
- en: public static void ➊Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋using (NessusSession session = new ➌NessusSession("192.168.1.14", "admin",
    "password"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.➍WriteLine("Your authentication token is: " + session.Token);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-4: Testing the  NessusSession  class to authenticate with  NessusManager'
  prefs: []
  type: TYPE_NORMAL
- en: In the Main() method ➊, we create a new NessusSession ➌ and pass the IP address
    of the Nessus host, the username, and the Nessus password as the arguments. With
    the authenticated session, we print the authentication token ➍ Nessus gave us
    on successful authentication and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: The NessusSession is created in the context of a using statement ➋, so the Dispose()
    method we implemented in the NessusSession class will be automatically called
    when the using block ends. This logs out the NessusSession, invalidating the authentication
    token we were given by Nessus.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Running this code should print an authentication token similar to the one in
    [Listing 5-5](#filepos440028).
  prefs: []
  type: TYPE_NORMAL
- en: $ mono ./ch5_automating_nessus.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Your authentication token is: 19daad2f2fca99b2a2d48febb2424966a99727c19252966a'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-5: Running the  NessusSession  test code to print the authentication
    token'
  prefs: []
  type: TYPE_NORMAL
- en: The NessusManager Class
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-6](#filepos442874) shows the methods we need to implement in the
    NessusManager class, which will wrap common API calls and functionality for Nessus
    in easy-to-use methods we can call later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'public class NessusManager : ➊IDisposable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NessusSession _session;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public NessusManager(NessusSession session)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = ➋session;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject GetScanPolicies()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.➌MakeRequest("GET", "/editor/policy/templates", null, _session.Token);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject CreateScan(string policyID, string cidr, string name, string
    description)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject data = ➍new JObject();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data["uuid"] = policyID;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data["settings"] = new JObject();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data["settings"]["name"] = name;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data["settings"]["text_targets"] = cidr;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data["settings"]["description"] = description;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.➎MakeRequest("POST", "/scans", data, _session.Token);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject StartScan(int scanID)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.MakeRequest("POST", "/scans/" + scanID + "/launch", null, _session.Token);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➏GetScan(int scanID)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.MakeRequest("GET", "/scans/" + scanID, null, _session.Token);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void Dispose()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (_session.Authenticated)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session.➐LogOut();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = null;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-6: The  NessusManager  class'
  prefs: []
  type: TYPE_NORMAL
- en: The NessusManager class implements IDisposable ➊ so that we can use NessusSession
    to interact with the Nessus API and log out automatically if necessary. The NessusManager
    constructor takes one argument, a NessusSession, and assigns it to the private
    _session variable ➋, which any method in NessusManager can access.
  prefs: []
  type: TYPE_NORMAL
- en: Nessus is preconfigured with a few different scan policies. We’ll sort through
    these policies using GetScanPolicies() and MakeRequest() ➌ to retrieve a list
    of policies and their IDs from the /editor/policy/templates URI. The first argument
    to CreateScan() is the scan policy ID, and the second is the CIDR range to scan.
    (You can also enter a newline-delimited string of IP addresses in this argument.)
    The third and fourth arguments can be used to hold a name and description of the
    scan, respectively. We’ll use a unique Guid (globally unique ID, long strings
    of unique letters and numbers) for each names since our scan is only for testing
    purposes, but as you build more sophisticated automation, you may want to adopt
    a system of naming scans in order to make them easier to track. We use the arguments
    passed to CreateScan() to create a new JObject ➍ containing the settings for the
    scan to create. We then pass this JObject to MakeRequest() ➎, which will send
    a POST request to the /scans URI and return all relevant information about the
    particular scan, showing that we successfully created (but did not start!) a scan.
    We can use the scan ID to report the status of a scan.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created the scan with CreateScan(), we’ll pass its ID to the StartScan()
    method, which will create a POST request to the /scans/<scanID>/launch URI and
    return the JSON response telling us whether the scan was launched. We can use
    GetScan() ➏ to monitor the scan.
  prefs: []
  type: TYPE_NORMAL
- en: To complete NessusManager, we implement Dispose() to log out of the session
    ➐ and then clean up by setting the _session variable to null.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Nessus Scan
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-7](#filepos447170) shows how to begin using NessusSession and NessusManager
    to run a scan and print the results.'
  prefs: []
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ServicePointManager.➊ServerCertificateValidationCallback =
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (NessusSession session = ➋new NessusSession("192.168.1.14", "admin", "password"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (NessusManager manager = new NessusManager(session))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject policies = manager.➌GetScanPolicies();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string discoveryPolicyID = string.Empty;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (JObject template in policies["templates"])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (template ["name"].Value<string>() == ➍"basic")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: discoveryPolicyID = template ["uuid"].Value<string>();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-7: Retrieving the list of scan policies so we can start a scan with
    the correct scan policy'
  prefs: []
  type: TYPE_NORMAL
- en: We begin our automation by first disabling SSL certificate verification (because
    the Nessus server’s SSL keys are self-signed, they will fail verification) by
    assigning an anonymous method that only returns true to the ServerCertificateValidationCallback
    ➊. This callback is used by the HTTP networking libraries to verify an SSL certificate.
    Simply returning true causes any SSL certificate to be accepted. Next, we create
    a NessusSession ➋ and pass it the IP address of the Nessus server as well as the
    username and password for the Nessus API. If authentication succeeds, we pass
    the new session to another NessusManager.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an authenticated session and a manager, we can begin interacting
    with the Nessus server. We first get a list of the scan policies available with
    GetScanPolicies() ➌ and then create an empty string with string.Empty to hold
    the scan policy ID for the basic scan policy and iterate over the scan policy
    templates. As we iterate over the scan policies, we check whether the name of
    the current scan policy equals the string basic ➍; this is a good starting point
    for a scan policy that allows us to perform a small set of unauthenticated checks
    against hosts on the network. We store the ID for the basic scan policy for later
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Now to create and start the scan with the basic scan policy ID, as shown in
    [Listing 5-8](#filepos450210).
  prefs: []
  type: TYPE_NORMAL
- en: JObject scan = manager.➊CreateScan(discoveryPolicyID, "192.168.1.31",
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"Network Scan", "A simple scan of a single IP address.");'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int scanID = ➋scan["scan"]["id"].Value<int>();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manager.➌StartScan(scanID);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject scanStatus = manager.GetScan(scanID);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (scanStatus["info"]["status"].Value<string>() != ➍"completed")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Scan status: " + scanStatus["info"]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '["status"].Value<string>());'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thread.Sleep(5000);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: scanStatus = manager.➎GetScan(scanID);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (JObject vuln in scanStatus["vulnerabilities"])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine(vuln.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-8: The second half of the Nessus automation  Main()  method'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we call CreateScan(), passing in a policy ID, IP address, name, and description
    of the method, and we store its response in a JObject. We then pull the scan ID
    out of the JObject ➋ so that we can pass the scan ID to StartScan() ➌ to start
    the scan.
  prefs: []
  type: TYPE_NORMAL
- en: We use GetScan() to monitor the scan by passing it the scan ID, storing the
    result in a JObject and using a while loop to continually check whether the current
    scan status has completed ➍. If the scan has not completed, we print its status,
    sleep for five seconds, and call GetScan() ➎ again. The loop repeats until the
    scan reports completed, at which point we iterate over and print each vulnerability
    returned by GetScan() in a foreach loop, which may look something like [Listing
    5-9](#filepos453341). A scan might take several minutes to complete, depending
    on your computer and network speed.
  prefs: []
  type: TYPE_NORMAL
- en: $ mono ch5_automating_nessus.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Scan status: running'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Scan status: running'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Scan status: running'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"count": 1,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_name": ➊"SSL Version 2 and 3 Protocol Detection",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"vuln_index": 62,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity": 2,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_id": 20007,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity_index": 30,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_family": "Service detection"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"count": 1,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_name": ➋"SSL Self-Signed Certificate",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"vuln_index": 61,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity": 2,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_id": 57582,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity_index": 31,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_family": "General"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"count": 1,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_name": "SSL Certificate Cannot Be Trusted",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"vuln_index": 56,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity": 2,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_id": 51192,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"severity_index": 32,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"plugin_family": "General"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 5-9: Partial output from an automated scan using the Nessus vulnerability
    scanner'
  prefs: []
  type: TYPE_NORMAL
- en: The scan results tell us that the target is using weak SSL modes (protocols
    2 and 3) ➊ and a self-signed SSL certificate on an open port ➋. We can now ensure
    that the server’s SSL configurations are using fully up-to-date SSL modes and
    then disable the weak modes (or disable the service altogether). Once finished,
    we can rerun our automated scan to ensure that Nessus no longer reports any weak
    SSL modes in use.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has shown you how to automate various aspects of the Nessus API
    in order to complete an unauthenticated scan of a network-attached device. In
    order to achieve this, we needed to be able to send API requests to the Nessus
    HTTP server. To do so, we created the NessusSession class; then, once we were
    able to authenticate with Nessus, we created the NessusManager class to create,
    run, and report the results of a scan. We wrapped everything with code that used
    these classes to drive the Nessus API automatically based on user-provided information.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t the extent of the features Nessus provides, and you’ll find more
    detail in the Nessus API documentation. Many organizations require performing
    authenticated scans against hosts on the network in order to get full patch listings
    to determine host health, and upgrading our automation to handle this would be
    a good exercise.
  prefs: []
  type: TYPE_NORMAL
