- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PIET
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Piet (pronounced “Pete”) is a visual esolang. It’s a perfect example of what
    an esolang aims to be: a novel way to embody the process of coding. Piet programs
    are executable pictures. The language is named after Dutch artist Piet Mondrian
    (1872–1944) because Piet programs often appear similar to his abstract, rectangular
    paintings. In Piet, art meets code. People talk about elegance in source code,
    and Piet takes this idea to an entirely new level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Piet is a stack-based language with a minimal instruction set. In Piet, blocks
    of the same color represent positive integers, and transitions from one color
    to another specify the executed instruction. Piet programs are 2D, with code running
    whichever way is desired: left, right, up, or down.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll first walk through the language to understand how to
    turn a picture into code. Next, we’ll go finger painting and get messy with some
    example programs. Along the way, we’ll learn how to use the interpreter and its
    visual tracing abilities.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll explore the `npiet` visual editor to create a simple tribute
    to Mondrian by turning one of his iconic paintings into code.
  prefs: []
  type: TYPE_NORMAL
- en: Piet’s popularity has created many implementations, associated tools, and even
    assemblers to generate Piet pictures from more traditional, text-based assembly
    code. We’ll take a quick look at the Piet universe to point you toward the resources
    you’ll need if you want to spend more time with Piet. Lastly, as always, we’ll
    conclude the chapter with a brief discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Piet’s creator, David Morgan-Mar, has a helpful page at *[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*.
    The page includes background information and an explanation of Piet’s operation.
    There’s also a nice collection of example programs and a link to third-party tools.
    Do take a look.
  prefs: []
  type: TYPE_NORMAL
- en: To work with Piet, we need an interpreter. We’ll use Erik Schoenfelder’s `npiet`.
    It’s written in C and is fast enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To install and build `npiet`, first go to *[http://www.bertnase.de/npiet/](http://www.bertnase.de/npiet/)*
    and download *npiet-1.3f.tar.gz* (or any later version you see). The site includes
    a compiled executable for Windows users. The command sequence below, if `libgd`
    is available, should be (largely) appropriate for macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have *npiet-1.3f.tar.gz* enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few warnings, there should be three executable files in the *npiet-1.3f*
    directory: `npiet`, `npietedit`, and `npiet-foogol`. The first is the interpreter.
    The second is a simple editor we’ll use to make our example programs. The third
    translates `foogol` programs into Piet. Foogol is an ALGOL-like language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to install additional packages like `groff` and `tk`. If so, this
    should be close to what you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The book’s GitHub repo includes a *Piet* directory with example programs. I
    suggest copying `npiet` to the *examples* directory, or one level up, to simplify
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: To test `npiet`, try
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you see our favorite greeting, `npiet` is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding Piet**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Piet is unlike any of the languages we’ve previously encountered. Of course,
    we should expect a language using pictures as programs to be unusual. This section
    seeks to understand Piet, meaning how Piet represents numbers, programs, commands,
    and program flow. As a language, Piet is relatively simple. There are only 17
    commands, four of which are solely for input and output. However, program flow
    in Piet is more complex than in traditional languages.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with colors, as Piet programs are all about colors. Then we’ll learn
    how to represent numbers and programs. Next, we’ll discuss the command set and
    the unique way Piet implies commands using transitions between colors. Color transitions
    lead naturally to program flow.
  prefs: []
  type: TYPE_NORMAL
- en: '***Piet Colors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have a problem at the start. Piet uses color images to represent programs,
    but this book is printed in grayscale. Therefore, referring to the GitHub examples
    is essential. That said, we’ll do what we can without color. For instance, [Figure
    9-1](ch09.xhtml#ch09fig1) presents the specific colors Piet uses as shades of
    gray along with HTML-style hex codes representing the color. A color version of
    this chart is in the file *piet_colors.png*. Lack of color won’t stop us, but
    be aware that color is critical to Piet and how it functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Piet color chart*'
  prefs: []
  type: TYPE_NORMAL
- en: Our Piet programs use only the colors in [Figure 9-1](ch09.xhtml#ch09fig1) along
    with black (`#000000`) and white (`#FFFFFF`). Some interpreters treat unknown
    colors as white, but we’ll restrict ourselves to only approved colors. The hex
    color codes specify the mix of red, green, and blue that make up the color.
  prefs: []
  type: TYPE_NORMAL
- en: '***Representing Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Piet is stack based, like Forth. Numbers are represented as blocks of the same
    color and the number of pixels in the block specifies the color. Therefore, a
    3×5 pixel block represents 3 × 5 = 15, whereas a square with 5 pixel sides is
    25\. Note that the blocks need not be rectangular or square, but only connected
    on the edges. A block may even contain holes. If that sounds very abstract, don’t
    worry. We’ll see examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '***Representing Programs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each pixel of the program is significant. However, if we attempt to look at
    the program at the pixel level, we’ll be hard-pressed to see anything. Therefore,
    we’ll present programs as magnified images. When images are magnified, each pixel
    becomes a square of pixels. The square of pixels mapping to the original pixel
    is called a *codel*. For example, if the image is magnified by a factor of 10,
    each pixel becomes a 10×10 square; therefore, the codels are each a 10×10 pixel
    region.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example program *add.png*, shown in grayscale in [Figure 9-2](ch09.xhtml#ch09fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Adding two numbers, 2 + 2 = 4*'
  prefs: []
  type: TYPE_NORMAL
- en: The original image is 9 pixels wide and 4 pixels high. The version shown in
    [Figure 9-2](ch09.xhtml#ch09fig2) is magnified by 200, so each pixel becomes a
    200×200 pixel square, a codel. For this example, I added grid lines to explicitly
    mark the codel boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Typesetting alters the codel to pixel mapping, but knowing that *add.png* is
    4 pixels high helps us look at [Figure 9-2](ch09.xhtml#ch09fig2) and understand
    the codels. For example, from bottom to top, the leftmost column is two black
    codels and two light red codels. Piet treats black as a wall, so the two light
    red codels form a 2×1 rectangle, that is, the number 2\. We’ll walk through *add.png*
    below. For now, just focus on the mapping between blocks, pixels, and codels.
  prefs: []
  type: TYPE_NORMAL
- en: '***Piet Commands***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look again at [Figure 9-1](ch09.xhtml#ch09fig1). Beginning with the upper-left
    corner and moving to the right transitions the colors from red to yellow to green
    to cyan to blue, and, wrapping around from the right to the left, back to red.
    Moving along the rows in [Figure 9-1](ch09.xhtml#ch09fig1), we see a change in
    the hue (that is, the color) without a change in lightness. Each move along the
    top row of [Figure 9-1](ch09.xhtml#ch09fig1) changes a single C0[16] to FF[16]
    or vice versa. Similarly, for the middle row, values change from 00[16] to FF[16],
    and for the bottom row, from 00[16] to C0[16].
  prefs: []
  type: TYPE_NORMAL
- en: Moving up and down the columns changes the lightness of the color while preserving
    the hue. From top to middle, C0[16] becomes 00[16], whereas from middle to bottom,
    FF[16] becomes C0[16]. As with rows, moving from the darkest color in a column
    to the lightest is also a single transition step. This all means that movement
    along the color table is cyclic.
  prefs: []
  type: TYPE_NORMAL
- en: Why all this concern about hue and lightness? It’s because Piet does not represent
    commands uniquely. There isn’t a single color that means “push a number” or “add.”
    Instead, it’s the number of hue or lightness steps taken between regions that
    specifies the command. The colors themselves do not matter. The color table is
    cyclic, so it’s possible to move from any initial color to any ending color. This
    means that any command can be specified from any starting color.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.xhtml#ch09tab1) lists Piet’s commands according to the hue
    and lightness change that causes the command to execute. Here, the rows represent
    a change in hue by that many steps and the columns a similar change in lightness.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Piet Commands as Specified by Transitions in Hue (Row) and Lightness
    (Column) Between Blocks'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | none | push | pop |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | + | *–* | × |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | ÷ | mod | not |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | > | pointer | switch |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | dup | roll | inN |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | inC | outN | outC |'
  prefs: []
  type: TYPE_TB
- en: For example, to push a number on the stack, the transition between blocks must
    involve a lightness change of one step but no change in hue. Therefore, any block
    transition from a particular row of [Figure 9-1](ch09.xhtml#ch09fig1) to the row
    below that keeps the column constant results in a `push` command. The number pushed
    on the stack is the number of codels (pixels) in the block just exited. Recall
    that moving from the darkest to the lightest for any color is also a lightness
    transition of one.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, to execute an `outC` instruction to output the top stack item as
    an ASCII character, the block transition must change lightness by two and hue
    by five. For example, moving from a block that is light red to one that is dark
    magenta will execute `outC`. Likewise, moving from a cyan block to a light green
    block will also execute `outC`. Count the hue and lightness changes necessary
    using [Figure 9-1](ch09.xhtml#ch09fig1) to convince yourself that moving from
    a cyan block to a light green block will indeed specify an `outC` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the commands in [Table 9-1](ch09.xhtml#ch09tab1) are familiar to us
    after our investigation of Forth in [Chapter 4](ch04.xhtml#ch04). This is especially
    true of the math operators, greater-than, and `dup`, which duplicates the top
    stack item. Also, `push` was described in the previous paragraph. Lastly, `pop`
    is intuitive: drop the top stack item (this is `DROP` in Forth).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Forth-style stack effect comments helps to illuminate this set of Piet
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0248-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The input and output commands, `inN`, `inC`, `outN`, and `outC`, are similarly
    straightforward. The `N` versions accept a number or output a number. The `C`
    versions accept a character or output the top stack item as an ASCII character.
    For example, `outC` prints `A` if the top stack item is 65—the ASCII code for
    capital *A*.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining instructions, `not`, `pointer`, `switch`, and `roll`, need some
    explanation. The simplest of these is `not`. In this instruction we pop the top
    stack item, and push a 1 on the stack if the item is not 0 and push 0 on the stack
    otherwise. The net effect is to toggle the truth value where 0 is false, and anything
    else is true, as in C. The `npiet` interpreter is written in C, so this behavior
    is natural.
  prefs: []
  type: TYPE_NORMAL
- en: The `pointer` command rotates the direction pointer (DP) clockwise the number
    of times specified by the top stack item. The `switch` command pops the stack
    and toggles the codel chooser (CC) that many times, ignoring the sign. We’ll cover
    the DP and CC in detail in the next section. For now, just know that `pointer`
    affects the DP and `switch` affects the CC.
  prefs: []
  type: TYPE_NORMAL
- en: Piet’s most complex command is `roll`, which is used to manipulate the stack
    by rolling a set number of items a given number of times. Let’s look at an example
    to see what this means.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *roll32.png* contains a program that places the numbers 1 through
    5 on the stack and sets up a call to `roll` to rotate the top three items two
    times. Visually, *roll32.png* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0248-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The program flows from left to right, column by column, to push 1, then 2, 3,
    4, and 5 on the stack. The following two columns push 3 and then 2\. The remainder
    of the code calls `roll` to rotate the top three stack items two times and dump
    the stack by repeated calls to `outN`.
  prefs: []
  type: TYPE_NORMAL
- en: Before the call to `roll`, the stack, from left to right, is
  prefs: []
  type: TYPE_NORMAL
- en: '`1 2 3 4 5 3 2`'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `roll` first pops 2, then 3\. The 2 is the number of times to roll
    the top 3 items. A roll rotates the items so that `3 4 5` becomes `5 3 4`. Therefore,
    two rolls are
  prefs: []
  type: TYPE_NORMAL
- en: '`3 4 5` → `5 3 4` → `4 5 3`'
  prefs: []
  type: TYPE_NORMAL
- en: and the final stack is
  prefs: []
  type: TYPE_NORMAL
- en: '`1 2 4 5 3`'
  prefs: []
  type: TYPE_NORMAL
- en: The stack being popped from right to left implies that the output of *roll32
    .png* should be `35421`, as no spaces are printed. Indeed, this is the output,
    so `roll` behaves as we think it should.
  prefs: []
  type: TYPE_NORMAL
- en: '***Program Flow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Program flow in most languages is straightforward. Unless a branch, goto, or
    equivalent happens, statements are executed sequentially. Thinking now of low-level
    machine code, there is a single program counter, something that points to the
    next instruction. In Piet, program flow is more complex. Flow moves from a block
    of the same color to the next block, beginning with the top leftmost block. The
    direction is controlled by the *direction pointer (DP*). When a Piet program begins,
    the DP is to the right.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we might think we need only a DP; however, there is a minor issue.
    Piet moves from block to block, but to determine the next block, it needs to know
    how far to move along which edge of the current block. This introduces the *codel
    chooser (CC)*. The CC is initially to the left, but it can also be to the right.
    Whose left or right? The DP’s left or right. Therefore, when a Piet program begins,
    the DP is to the right and the CC is to the left, meaning the next block is the
    one to the topmost right edge of the current block. In fact, it is to the furthest
    right extent of the block. Thus, Piet selects the next block by going as far as
    possible in the current block in the direction of the DP and then respecting the
    current value of CC.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the image below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0249-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The program is currently in the left block, 2×1 codels, and the DP is pointing
    to the right. Which block should be considered next? The top or the bottom of
    the second column? If the CC is to the left, Piet moves to the right from the
    top of the 2×1 block to select the top block of the right column, which is the
    darker block. If the CC were to the right, we would choose the lower block instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](ch09.xhtml#ch09fig3) presents the relationship between the DP
    and CC in two different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The relationship between the direction pointer (DP) and the codel
    chooser (CC)*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram on the right shows the DP as arrows leading up, down, left, or right,
    with the CC for each direction marked as *L* or *R*. The numbers correspond to
    the rows of the table on the left of the figure. The table shows DP and CC with
    arrows. The two complementary presentations should clarify how to use DP and CC
    to control program flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Piet moves from colored block to colored block based on DP and CC, but there
    are two special colors we must also consider: black and white. Black, as stated
    above, acts like a wall or the edge of the image. When Piet encounters black or
    an edge, it begins adjusting the DP and CC to try to find an escape, that is,
    a way out to continue the program. If it can’t find an escape, the program ends.
    Specifically, Piet uses the following steps to move through the image:'
  prefs: []
  type: TYPE_NORMAL
- en: From the current position, move as far as possible in the direction of the DP
    until you encounter either a color change or the edge of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the position found in Step 1, move as far as possible to the left or right
    depending on the CC direction. This selects the first codel of the next block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the steps above encounter a black block or image edge, we toggle the CC from
    left to right or right to left and repeat the steps above. If this process fails,
    the DP is rotated clockwise and CC toggling repeats. This process continues until
    a path is found to a new block or all moves fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all DP and CC adjustments fail, the program terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The steps above handle colored blocks, black blocks, and image edges. To further
    complicate matters, Piet also allows white blocks. White blocks are no-operation
    blocks called *no-ops.* The interpreter passes through white blocks like any other
    block, but the transition does not imply a command. This allows the programmer
    to change from one colored block to another without executing a command, and,
    as we’ll see below, the arrangement of black and white blocks can act as a control
    structure to enforce desired program flow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Piet in Action**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we’ll get our hands dirty and work through four examples:
    *add.png*, *hi.png*, *countdown.png*, and *random.png*. The first prints the sum
    of 2 + 2; the second, which we saw above, prints `Hi`; the third is a countdown
    loop; and the fourth is a simple pseudorandom number generator.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Proving 2 + 2 = 4***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our first example, *add.png* has a direct analog in the following Forth code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The number 2 is pushed on the stack, followed by another 2, then + pops the
    top two stack items, adds them, and pushes the sum onto the stack which is then
    printed as a number. Let’s walk through the execution of *add.png* to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: First, run *add.png* using `npiet`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If all `npiet` did was run the program given, we’d be hard-pressed to understand
    program flow, let alone debug it if necessary. Fortunately for us, `npiet` can
    dump an output image and show an execution trace. For example, the following command
    produces an output file, *npiet-trace.png*, as shown in [Figure 9-4](ch09.xhtml#ch09fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-tpic` option produces the trace and `-tpf 80` scales the output so the
    text is easier to read, at least in the output image file if not on the printed
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Tracing* add.png'
  prefs: []
  type: TYPE_NORMAL
- en: The top part of [Figure 9-4](ch09.xhtml#ch09fig4) is `npiet`’s output in grayscale.
    The bottom part of the figure traces the program flow to make it easier to follow
    in the book. The file *add.png* consists of five blocks, each 2×1 codels, corresponding
    to the first five circles marked 0 through 4\. Recall that Piet commands are specified
    by hue and lightness transitions, so the commands are printed above the arrows
    moving from block to block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Forth code above is duplicated by the Piet code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push(2)` → `push(2)` → `add` → `outN`'
  prefs: []
  type: TYPE_NORMAL
- en: After `outN` is a white region, which represents a no-op, so Piet flows through
    the white area following the flow rules above. First, as DP is to the right, Piet
    moves to the end of the first part of the block and encounters a black codel.
    The CC is right, and Piet can’t move further to the right because of the black
    block, so DP rotates to face downward and moves into the light colored block at
    the lower right. This block is surrounded by black or the edge of the image. As
    it moves to the edges of the current block, Piet can find no way out even after
    rotating DP all the way around, so the interpreter gives up and the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the *npiet-trace.png* image `npiet` created via the `-tpic` option,
    you’ll see color and small substeps showing how CC changes as DP changes. Please
    do look at the trace image, as it is too hard to read the substep indications
    in [Figure 9-4](ch09.xhtml#ch09fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '***Saying Hi***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We tested our Piet installation with *hi.png*. Now let’s walk through the code
    to learn more about how Piet applies flow control rules to select where to move
    next. Unlike *add.png*, *hi.png* doesn’t use simple blocks, so some thought is
    required to understand why the Piet interpreter does what it does.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-5](ch09.xhtml#ch09fig5) shows us a trace of *hi.png* with the program
    flow below it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: Tracing* hi.png'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the blocks have irregular shapes, and it might not be obvious
    why the interpreter selects the path it does. The irregular blocks in [Figure
    9-5](ch09.xhtml#ch09fig5) have been outlined in white to make them easier to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition from Step 0 to Step 1 is simple enough: Block 0 is a square,
    the DP begins to the right, and CC is to the left (top), so the only place to
    go is Block 1\. However, the transition from Step 1 to Step 2 isn’t immediately
    obvious. Inside Block 1 we expect the flow to move to the right along the top
    edge of the block. Although it is not clearly visible in [Figure 9-5](ch09.xhtml#ch09fig5),
    the top block is black and acts as a barrier. Therefore, according to Piet’s flow
    rules, CC is toggled to be to the right or bottom of the block as DP is to the
    right. This alone might imply rotating DP to face down and selecting the large,
    light-colored irregular block. However, Piet’s flow rules apply to the maximum
    extent of a block in the direction DP is facing. For Block 1, this means the bottom
    of the block, as it is furthest to the right and not stopped by the black square
    at the top. So, Piet moves from Block 1 to the small, light-colored square of
    Step 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Flow from Step 2 to Step 10 is straightforward. To go from Step 10 to Step 11,
    we use the same set of rules as going from Step 1 to Step 2, but this time DP
    is facing to the left, so we select the leftmost edge of Block 10 and flow moves
    to Block 12, the terminal block. Block 12 is a trap. DP is to the left and the
    leftmost part of the block is at the bottom, but once there, Piet will find no
    way to move to a new block, thereby ending the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the code implied by *hi.png*, it’s quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: with 9 × 8 = 72, the ASCII code for *H*, and 72 + 11 × 3 = 105, the code for
    *i*, followed by ASCII 10 for the final newline character.
  prefs: []
  type: TYPE_NORMAL
- en: '***Countdown***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The file *countdown.png* contains a program to count down from 10 to 1\. To
    make our lives easier, as far as tracing goes, we’ll work with the slightly edited
    version in *countdown3.png*, which counts down from 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running *countdown3.png* produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I admit the output of *countdown3.png* is not particularly interesting, but
    this example shows us how to work with loops in Piet, which is. The top part of
    [Figure 9-6](ch09.xhtml#ch09fig6) is a trace of *countdown3.png*. As printed,
    it won’t be possible to see the flow properly. So as with [Figure 9-4](ch09.xhtml#ch09fig4),
    refer instead to the flow diagram at the bottom of [Figure 9-6](ch09.xhtml#ch09fig6)
    and review the file *npiet-trace.png* that `npiet` made for us when executing
    *countdown3.png*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: Tracing* countdown3.png'
  prefs: []
  type: TYPE_NORMAL
- en: We might write *countdown3.png* as in [Listing 9-1](ch09.xhtml#ch09list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: countdown3.png as text*'
  prefs: []
  type: TYPE_NORMAL
- en: The code pushes the limit, 3, onto the stack, and then the loop begins by duplicating
    the top stack item so it can be printed as a number ➊. The next block of code
    pushes 10 on the stack and outputs it as a character. For Unix systems, ASCII
    10 is newline ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The counter value is still on the stack, so it’s decremented by 1 ➌. The final
    `dup` in this section of the code sets up for the comparison to see whether the
    countdown is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Piet uses the number of pixels in a block to represent numbers. Therefore,
    it isn’t possible to directly represent 0 and push it on the stack. However, ➍
    shows us a useful Piet idiom: get a 0 on the stack by pushing a 1 and calling
    `not`. The stack is now set up with two copies of the counter value and a 0\.
    The top two stack items are consumed by `>`, leaving a 0 or 1 on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s where things get interesting. Piet has no explicit branch instruction,
    that is, no direct analog of the `if` statement shown in [Listing 9-1](ch09.xhtml#ch09list1).
    Instead, Piet uses the `pointer` instruction to rotate the DP, which at this point
    in *countdown3.png* is facing left. The `pointer` instruction uses the top stack
    value to rotate DP clockwise by that many steps. The result from `>` is a 0 or
    1\. If 1, it means that the counter value is greater than 0, so we want the loop
    to continue. In that case, `pointer` will rotate DP one position clockwise so
    that it is now facing up. Moving directly up from this part of *countdown3.png*
    puts us right at the beginning of the loop, ➊ in [Listing 9-1](ch09.xhtml#ch09list1).
    The direction pointer is facing up, but there is nowhere to go, so Piet, following
    the flow rules, rotates DP clockwise, so it is now facing right, and the loop
    continues.
  prefs: []
  type: TYPE_NORMAL
- en: If `>` leaves 0 on the stack, the DP is unaffected by `pointer`, and flow continues
    to the left, ultimately landing in the trap where Piet is unable to find an exit,
    so the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Pseudorandom Number Generator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final example in this section is *random.png*, a simple pseudorandom number
    generator. The program implements a *linear congruential* pseudorandom number
    generator, which is a simple way to generate a sequence of integers that appears
    random. We’ll work with this type of generator again in [Chapter 13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: The generator itself is the single equation
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*i*+1] ← *a**s**[i]* mod *m*'
  prefs: []
  type: TYPE_NORMAL
- en: for some initial seed value, *s*[0]. Both *a* and *m* are integer constants.
    If *a* and *m* are properly selected, then the sequence of *s*[*i*] values generated
    by taking the output and using it as the new input will pass statistical tests
    for randomness, or so we hope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break the equation down into steps: first, multiply the current seed
    value (*s*[*i*]) by the multiplier, *a*. Then, calculate the remainder when dividing
    that product by *m* and set that as the new seed value (*s*[*i*+1]). The modulo
    operation (mod) gives the remainder and, fortunately for us, is one of the math
    operations Piet supports.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we need to select *a* and *m*. Good values are large, but we don’t
    want to work with large integers, as they correspond to large uniform blocks in
    the program image. Linear congruential generators have been studied for decades,
    and many sets of constants have been found. We’ll use *a* = 209 and *m* = 2^(12)
    *–* 3 = 4093 because they are small values.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we now need a program to take an initial seed value, apply the equation,
    output the new seed value, and repeat. Piet’s stack will hold the current seed
    value. The initial seed value will be pushed onto the stack, after which we’ll
    calculate the new seed, print it, and leave it on the stack for the next pass
    through the loop. We’ll want to capture the sequence of integers, so we’ll loop
    forever and use CTRL-C to stop the program when we’ve generated all the numbers
    we care to output.
  prefs: []
  type: TYPE_NORMAL
- en: In text, we might write the program as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: where `goto loop` will be achieved by arranging a sequence of white and black
    regions to force program flow back to the top of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: We could make an image like the program, but notice the `push(4093)`. That’s
    a rather large block by Piet standards, so let’s replace both `push(209)` and
    `push(4093)` with a set of calculations that end with the proper number on the
    stack. For example, `push(209)` is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: and `push(4093)` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It’s not pretty as text, but it is easy to implement as a picture. [Figure 9-7](ch09.xhtml#ch09fig7)
    shows the resulting program (see *random.png*). The program flow is below, where
    adjacent labeled circles are connected in a clockwise direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Tracing* random.png'
  prefs: []
  type: TYPE_NORMAL
- en: The transition from Step 0 to Step 1 pushes the initial seed (1) on the stack.
    Steps 2 through Step 24 generate the next seed value and display it as an integer.
    Steps 25 through 27 print the newline. The white region causes the program to
    flow back to Step 2 to generate the next seed. The loop runs until we press CTRL-C
    to quit the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run *random.png* and capture the output so we can analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let the code run for 10 to 20 seconds and then stop it with CTRL-C. My run produced
    2,333,347 values, which is quite sufficient for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence begins with the following numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This seems “random,” but how can we know? Of course, we know the sequence cannot
    possibly be random, as it was generated deterministically. However, suppose we
    didn’t know that. In that case, we could perform tests to help us decide if the
    sequence is or isn’t worth calling “random.” The entire point of developing high-quality
    pseudorandom number generators is to create deterministic sequences that pass
    all known randomness tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can apply randomness tests, we must convert the text file of integers
    into a binary file of double-precision floating-point numbers in the range [0,1),
    meaning from 0 up to, but not including, 1\. For that, we’ll use *random_double.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, *random_double.py* produces *random.dat* from *random.txt* by dividing
    each value by 4,093, which is one more than the largest possible integer the generator
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: One way to check for randomness is to build a *histogram*. A histogram partitions
    the range of possible integers—in this case, [1,4092]—into several equal-sized
    bins, say 10\. Then we locate the bin each number falls into and increment the
    count for the bin. When all the random values have been tallied, the histogram
    shows us how many have fallen into each bin. If we divide the count per bin by
    the number of values tallied, which in this case is 2,333,347, the counts become
    frequencies telling us the fraction of numbers we can expect in each bin. If we
    want, we can interpret the frequencies as the probability a random value will
    land in that bin.
  prefs: []
  type: TYPE_NORMAL
- en: If the values are randomly distributed, each bin is equally likely, so we expect
    the fraction in each bin to be roughly the same. So, for example, if we have 10
    bins, we expect about 10 percent of the values to fall into each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the tallies, we need a bit of Python code and access to the NumPy
    library. The actual code is in the file *random_histogram.py*, but you need not
    install NumPy to run it. The histogram gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here I’ve rounded the percentages to three decimals. The first number tells
    us the percent of samples in the range [0,0*.*1), the second the percent in [0*.*1,0*.*2),
    and so on. The percentages are virtually identical. So that’s a good sign that
    *random.png* is giving us well-distributed values.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean *random.png* is a good pseudorandom number generator? Not quite.
    If *random.png* were generating 1, 2, 3, 4, and so on modulo 4093, we’d still
    get the histogram above with enough samples. To be a good pseudorandom generator,
    the *i*th value and the *i* + 1th value must not be correlated. In other words,
    there should be no easy way to predict the next value generated from the previous.
  prefs: []
  type: TYPE_NORMAL
- en: To check if there is a correlation between one value and the next, we can use
    the code in *corr_test.c*. This program reads *random.dat* and calculates the
    *correlation coefficient*, a single number. If the values are not correlated one
    to the next, the correlation coefficient will be very close to 0 to indicate there
    is no relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile *corr_test.c* using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then run it on *random.dat*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `3` in the command line tells `corr_test` that *random.dat* is a binary
    file of double precision floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: The output has the word `PASSED` in it, in all caps to boot. So *corr_test*
    believes *random.dat* is not correlated. The correlation coefficient is close
    to 0\. The `CI` part of the output is a *confidence interval*. We can read the
    confidence interval as meaning there’s a 95 percent chance the true correlation
    coefficient is between the given limits. Notice that the range includes 0, another
    good sign.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, *random.png* is a good pseudorandom generator, right? Still, not
    quite. We only checked for correlations between one value and the next. There
    might be correlations between a value and some other, later value. You begin to
    see the issue with testing pseudorandom generators. Real generators are tested
    against large test suites that include many different kinds of tests, all of which
    only the best pseudorandom generators pass.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll do one more straightforward test of the output in *random.dat*. Let’s
    take successive pairs of values and plot them as a point. Then, we’ll look at
    the resulting plot to see if any pattern jumps out at us. For example, the first
    two values in *random.dat* are 0.05106279 and 0.67212314\. So we’ll plot a point
    at (0.05106279, 0.67212314), then do the same for the next pair. We’ll stop after
    plotting 1,000 points to avoid cluttering the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 9-8](ch09.xhtml#ch09fig8). Does anything jump out at
    you?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: Plotting pairs of pseudorandom values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The points often lie along a diagonal from upper left to lower right. This
    is a strong indication of longer-range correlations in the sequence. At last we
    can now make a statement about the output of *random.dat*: it’s a lousy pseudorandom
    generator. However, it does fill the space. There are no obvious regions in [Figure
    9-8](ch09.xhtml#ch09fig8) where there are no points. So the output of *random.png*
    is sufficient for a simple video game, but don’t make policy decisions related
    to climate change based on simulations using it.'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudorandom number generation will show up again later in the book. For now,
    let’s return to Piet’s artistic roots and create a small tribute to Piet Mondrian.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Tribute to Piet Mondrian**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Piet Mondrian was an important member of a group of Dutch artists and architects
    who developed what has come to be known as the *De Stijl* movement. De Stijl,
    literally “the style,” uses abstract forms with basic elements. One of Mondrian’s
    most widely recognized works is his unexpectedly satisfying *Composition II in
    Red, Blue, and Yellow*. The painting is an excellent example of the De Stijl movement.
    As a tribute to Mondrian, let’s make an executable copy of *Composition II*. In
    the process, we’ll learn how to use `npiet`’s editor, `npietedit`.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating the original painting with a modern graphics program is straightforward.
    [Figure 9-9](ch09.xhtml#ch09fig9) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: A re-creation of Mondrian’s* Composition II'
  prefs: []
  type: TYPE_NORMAL
- en: The largest block is red, the smaller block on the left is blue, and the smallest
    block on the right is yellow. The remainder of the painting is black and white.
  prefs: []
  type: TYPE_NORMAL
- en: The original painting is signed on the lower left with *P M 30* for Piet Mondrian,
    1930\. We’ll make the copy executable by embedding a simple program to output
    `PM30` in place of the signature. The code that we need isn’t particularly challenging,
    but it is helpful as an exercise in learning to use `npietedit`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the immediate challenges in writing code for Piet is working with colors
    and transitions to get the desired commands. Although we might work with pencil
    and paper, counting from color to new color to get the correct number of hue and
    lightness changes to cause the desired command to execute, we need not be so primitive.
    Instead, the clever `npietedit` program lets us color the program image as needed
    while also calculating the proper color transitions.
  prefs: []
  type: TYPE_NORMAL
- en: To output `PM30`, we need to push the ASCII values for each character on the
    stack before calling `outC`. We’ll add a final newline as well to put `PM30` on
    its own line. Therefore, we need a program to output five characters. However,
    we must embed the program in the larger *Composition II* image in a way that isn’t
    too conspicuous. Fortunately for us, the way Piet runs and the structure of *Composition
    II* match nicely. For example, Piet begins in the upper leftmost pixel of the
    image with the DP to the right and CC to the left. As that portion of the image
    is white, Piet will run across to the first black pixel, the beginning of the
    large vertical black bar. We’ll embed our code in this bar, knowing Piet will
    find it. Additionally, we’ll orient the program vertically, with DP moving down.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we must have a program to embed, so let’s use `npietedit` to create
    it. Launch `npietedit` with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The interface is in [Figure 9-10](ch09.xhtml#ch09fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: The* npietedit *editor*'
  prefs: []
  type: TYPE_NORMAL
- en: The interface consists of a color selector, a command selector, and a drawing
    area showing individual pixels. Select a color and click in the drawing area to
    set that pixel. The command selector is the most valuable part of the editor.
    For example, to push the number 5 on the stack, select any desired color, say
    light red, the top leftmost color. Then, fill in five pixels to make a block,
    say five rows tall and one column wide. Then, as DP will be to the right, select
    the topmost pixel of the block and then select **Push**. The editor, knowing the
    current color is light red, switches the color to red, one lightness level darker.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the lightness by 1 is how Piet specifies `push`, so this is the correct
    color. Click the top pixel to the immediate right of the light red block to place
    a single red pixel. Given how DP is pointed, Piet will correctly push 5 on the
    stack. In this way, it is possible to draw any sequence of commands, with a little
    practice and attention paid to selecting the proper color before clicking the
    command to arrive at the necessary hue and lightness change.
  prefs: []
  type: TYPE_NORMAL
- en: Use the buttons at the top of the interface to control `npietedit`. They are
    largely self explanatory. However, Save and Load will not bring up the usual file
    selection dialog. Instead, they write and read a fixed filename, `npietedit-filename.ppm`.
    So, use Save to dump the drawing and then rename `npietedit-filename.ppm` to something
    else to preserve the program. Likewise, copy a saved version of a program to the
    same filename to then load it into `npietedit`. The *.ppm* file format is a portable
    pixmap image. The `npiet` interpreter will use these files as they are. Most graphics
    programs will load and display portable pixmap images as well. If you wish to
    change to another filetype, use something like `gimp` or `convert`, a command
    line tool that is part of ImageMagick (*[https://imagemagick.org/index.php](https://imagemagick.org/index.php)*).
    ImageMagick is included in the base Ubuntu installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program needs to push ASCII values on the stack and then call `outC`. The
    Forth equivalent of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Forth word `emit` has the same effect as Piet’s `outC` command, and multiplication
    of smaller numbers is used to prevent large blocks of one color.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s translate the Forth code into Piet using `npietedit`. The only twist is
    that we want the code to run vertically so we can embed it in the black part of
    the larger *Composition II* image. To do this, we must rotate DP downward from
    the right. This is easily done by a white region with a 90-degree turn.
  prefs: []
  type: TYPE_NORMAL
- en: The file *composition.ppm* contains the necessary Piet code as a direct translation
    of the Forth above. If you run it, you’ll see that it produces the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To see the code in `npietedit`, copy *composition.ppm* to *npietedit-filename.ppm*
    in the same directory as `npietedit`, launch the editor, and click **Load**. The
    result is [Figure 9-11](ch09.xhtml#ch09fig11). The code runs from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/09fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: Code to output PM30*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost finished with our tribute. All that remains is to embed *composition.ppm*
    in the redrawn *Composition II*, which is in the file *mondrian* *.png*. To do
    the embedding, I use `gimp` to load both images, select the actual image portion
    of *composition.ppm*, copy it, and paste it into *mondrian.png*, moving it over
    to the central vertical black region.
  prefs: []
  type: TYPE_NORMAL
- en: The Piet interpreter will pass over the white region on the upper left, so we
    need to add a single white pixel after positioning the code so that the vertical
    bar is now
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0266-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with arrows showing how DP changes direction to execute the code vertically.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting combined image is in *compositionII_pm30.png*. If you run it with
    `npiet`, you get the expected `PM30` output. Take a look at the image itself.
    It looks like *Composition II* with a splash of color toward the top.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Piet Universe**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A successful esolang engenders a following. People use it, share it, modify
    it, build tools for it, and create websites about it. By this measure, Piet is
    successful. What follows are links to excellent Piet code examples, tools, and
    generally anything else worth noting about Piet. The list is by no means exhaustive,
    and worthy entries have doubtless been missed.
  prefs: []
  type: TYPE_NORMAL
- en: '***About Piet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Piet has generated a collection of blog posts and many online discussions. The
    short list here explores more about the language itself and includes some interesting
    (unusual) Piet experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main Piet site**  The main Piet page by creator David Morgan-Mar. Start here
    to learn more about the language. (*[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Piet tutorial**  This is a nice, basic tutorial to programming in Piet and
    works well as an adjunct to what we’ve discussed in this chapter. (*[https://www.youtube.com/watch?v=4kH4T8uwHMw/](https://www.youtube.com/watch?v=4kH4T8uwHMw/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Piet in the literature**  Piet is an example in this paper about code visualization.
    Alex McLean’s dissertation is also online and similarly mentions Piet. See “Visualisation
    of live code," Electronic Visualisation and the Arts (EVA 2010), 26–30.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running classic paintings as Piet programs**  This is an experiment in mixing
    Piet and classic works of art. Piet fans are nothing if not creative. (*[http://omnigatherum.ca/wp/?p=57/](http://omnigatherum.ca/wp/?p=57/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Piet meets poetry**  An experiment with Piet and poetry. The final product,
    *bark.png*, generates a haiku. (*[http://theorangeduck.com/page/making-poetry-piet/](http://theorangeduck.com/page/making-poetry-piet/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to learn a language is to review examples in that language. Therefore,
    should Piet draw you further in, the examples here will help you improve your
    Piet prowess.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main Piet examples page**  The best place for Piet examples is off the main
    Piet site. Not all of these examples work with `npiet`, but most do. The works
    of the great masters are here; check them out. (*[https://www.dangermouse.net/esoteric/piet/samples.html](https://www.dangermouse.net/esoteric/piet/samples.html)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**FizzBuzz**  Historically, a common programming interview question was to
    write code to generate the numbers from 1 to 100 but replace multiples of 3 with
    “Fizz,” multiples of 5 with “Buzz,” and multiples of 3 and 5 with “FizzBuzz.”
    FizzBuzz is a simple program and therefore a favorite target for esolangs. A Piet
    version of FizzBuzz is at *[http://www.toothycat.net/~sham/fizzbuzz.png](http://www.toothycat.net/~sham/fizzbuzz.png)*,
    and, should you feel like diving into far too much detail about FizzBuzz, you
    can read Tom Dalling’s blog post at *[https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/](https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tic-tac-toe**  A fully interactive, unbeatable Piet version of tic-tac-toe
    (naughts and crosses) is worth a bit of your time. (*[https://freesoft.dev/program/9705871/](https://freesoft.dev/program/9705871/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementations and Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computer people love to build things. The description of Piet on the main page
    mentioned earlier is begging to be written up in some language or another. The
    implementations here are in many different languages, like C++, Python, Rust,
    and even Haskell. Not every implementation can run every example program, but
    most perform reasonably well.
  prefs: []
  type: TYPE_NORMAL
- en: A Python interpreter, *[https://www.dangermouse.net/esoteric/piet/Piet_py.txt](https://www.dangermouse.net/esoteric/piet/Piet_py.txt)*
  prefs: []
  type: TYPE_NORMAL
- en: Another Python interpreter, *[https://github.com/JensBouman/Piet_interpreter/](https://github.com/JensBouman/Piet_interpreter/)*
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter in Haskell, *[https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html](https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html)*
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter in C++, *[https://www.matthias-ernst.eu/fpiet.html](https://www.matthias-ernst.eu/fpiet.html)*
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter in Rust, *[https://github.com/dfockler/rustpiet/](https://github.com/dfockler/rustpiet/)*
  prefs: []
  type: TYPE_NORMAL
- en: A browser-based interpreter and IDE in TypeScript, *[https://gitlab.hsrw.eu/thomas.richter/piet-ide/](https://gitlab.hsrw.eu/thomas.richter/piet-ide/)*
  prefs: []
  type: TYPE_NORMAL
- en: Several projects have gone the other way to produce assemblers or compilers
    from a text-based language to Piet. That is, the output is an image implementing
    the program in Piet. Again, computer people are a creative bunch.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub repositories devoted to Piet, *[https://github.com/topics/piet/](https://github.com/topics/piet/)*
  prefs: []
  type: TYPE_NORMAL
- en: An assembler and compiler producing Piet code, *[https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/](https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/)*
  prefs: []
  type: TYPE_NORMAL
- en: The PietC compiler, which produces Piet code as output, *[https://github.com/cjayross/pietc/](https://github.com/cjayross/pietc/)*
  prefs: []
  type: TYPE_NORMAL
- en: Another assembler generating Piet output, *[https://github.com/sl236/Piet/](https://github.com/sl236/Piet/)*
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Piet is a procedural language with arbitrary-sized programs. There are no variables,
    but the stack is unlimited. So we might suspect that Piet is Turing complete.
    In fact, Piet is definitely Turing complete because a clever individual has written
    a Brainfuck (BF) interpreter in Piet and BF is known to be Turing complete as
    we’ll see next in [Chapter 10](ch10.xhtml#ch10). The BF interpreter (*[https://lutter.cc/piet/](https://lutter.cc/piet/)*)
    is worth a look, perhaps after reading [Chapter 10](ch10.xhtml#ch10). To test
    it, don’t forget to add a pipe (`|`) at the end of the BF code even if the code
    itself does not accept any input. I tried it with “Hello, world!” and `npiet`
    and it works. Don’t forget to add the `-q` command line option to suppress the
    input prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, Piet is a Turing complete language. What else can we say about it? Programming
    in Piet is quite a challenge, perhaps because it is so alien to standard text-based
    programming or even standard visual programming languages that ty the drag-and-drop
    of components.
  prefs: []
  type: TYPE_NORMAL
- en: I find it fascinating that loops in Piet are, literally, loops—the image structure
    itself controls the flow of the program, so a loop really does find its way back
    to the starting point. For example, the loop in *random.png* is implemented by
    a long white block along the bottom of the program image followed by a 90-degree
    turn to force DP to point in the right direction to encounter the beginning of
    the loop. Also, Piet’s flow control rules make it such that the DP will rotate
    again to the right to be pointing in the proper direction to repeat the loop endlessly,
    all without a single bit of standard syntax. In a way, Piet has no syntax, just
    flow rules; the image itself becomes the syntax. In that sense, Piet programs
    are not unique, as multiple, nearly infinite, ways to draw the required flow exist.
  prefs: []
  type: TYPE_NORMAL
- en: Piet’s method for implying commands using hue and lightness changes, as opposed
    to assigning specific colors to the commands, is equally clever and again magnifies
    the number of possible Piet programs considerably. Even if we choose the same
    layout, sequence of blocks, and image size, we get many options simply by selecting
    a different starting color. Piet’s instruction set is small, so learning the necessary
    transitions for each command isn’t too difficult. If you experiment with Piet
    for any length of time, you’ll begin to pick up on these transitions. For example,
    changing lightness by 1 is `push`, which is a command you’ll learn quickly.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also interesting that Piet separates block size and commands. For example,
    if we want to execute `push(4)` and know that the next instruction is `push(3)`,
    we might make the first block 2×2 pixels, say light red, and make the second block
    three vertical pixels of red. The transition from light red to red implies `push`
    with the argument, 4, from the size of the light red block. The push command does
    not care about the size of the new block, only that it is red, one lightness level
    darker. The fact that the new block is of size 3 is useful to push 3 when transitioning
    to the next block, which must be dark red, so we combine a number with a color
    transition, thereby making the code more compact. Of course, color transitions
    are commands, so it might sometimes be necessary to use a white block to change
    color without executing a command.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, Piet is a fun esolang and an excellent example of a novel way to
    think about coding. Some forethought is necessary when designing a program, as
    it isn’t easy, even with tools like `npietedit`, to suddenly add new code by moving
    an existing block to make room, but editors capable of such actions are certainly
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Piet is Turing complete, but extensions to the language might be of interest.
    For example, the ability to access the stack as an array adds variables. Also,
    some kind of subroutine ability would make coding easier. All of these are exercises
    for the ambitious reader.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to Piet, the language where pictures are programs.
    First, we walked through the elements of the language to understand how it works
    and how to code with colors. Next, we went finger painting and got messy learning
    how specific programs worked, step by step. This led us to a simple tribute to
    Piet Mondrian, whose style and name inspired Piet’s creation. Piet has grown in
    popularity, at least as far as esolangs go, to the point where many program examples,
    implementations, and ancillary tools are now available. We cataloged several of
    them should you wish to explore further. Then, as always, we ended the chapter
    with some thoughts on the language and its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Our next esolang is perhaps the best known of all. We’re simply calling it *BF*.
    If Piet is a local celebrity, BF is a superstar.
  prefs: []
  type: TYPE_NORMAL
