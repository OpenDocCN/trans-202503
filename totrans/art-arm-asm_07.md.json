["```\n.text \n.align 2 \n```", "```\n{`Label`:}   {{`instruction`}     `operands`}  {// `Comment`}\n```", "```\nb.al   \\\n  targetLabel \n```", "```\nbl printf \n```", "```\n`procName`: \n `Procedure statements` \n    ret \n```", "```\nzeroBytes: \n          mov  x1, #256*4     // 1,024 bytes = 256 words \nrepeatlp: subs x1, x1, #4 \n          str  wzr, [x0, x1]  // Store *after* subtraction! \n          bne  repeatlp       // Repeat while X1 >= 0\\. \n          ret \n```", "```\n// Listing5-1.S \n//\n// Simple procedure call example \n\n#include \"aoaa.inc\"\n\nstackSpace  =       64 \nsaveLR      =       56 \n\n            .section .rodata, \"\"\nttlStr:     .asciz   \"Listing 5-1\"\n\n .data \nwArray:     .space   256 * (4), 0xff // Fill with 0xFF. \n\n            .text \n            .align   2 \n\n// getTitle \n//\n// Return program title to C++ program: \n\n            .global getTitle \ngetTitle: \n            lea     x0, ttlStr \n            ret \n\n// zeroBytes \n//\n// Here is the user-written procedure \n// that zeros out a 256-word buffer. \n// On entry, X0 contains the address \n// of the buffer. \n\nzeroBytes: \n            mov     x1, #256 * 4 \nrepeatlp:   subs    x1, x1, #4 \n            str     wzr, [x0, x1] // Store *after* subtraction! \n            bne     repeatlp      // Repeat while X1 != 0\\. \n            ret \n\n// Here is the asmMain function: \n\n            .global asmMain \nasmMain: \n            sub     sp, sp, #stackSpace // Reserve stack storage. \n            str     lr, [sp, #saveLR] \n\n            lea     x0, wArray \n            bl      zeroBytes \n\n            ldr     lr, [sp, #saveLR]   // Restore return address. \n            add     sp, sp, #stackSpace // Clean up stack. \n            ret     // Returns to caller \n```", "```\nzeroBytes: \n          mov  x1, #256 * 4 \nrepeatlp: subs x1, x1, #4 \n          str  wzr, [x0, x1] // Store *after* subtraction! \n          bge  repeatlp      // Repeat while X1 >= 0\\. \n          ret \n```", "```\nproc `procedureName` {, public}  // Braces denote optional item. \n\n     `Body of the procedure` \n\nendp `procedureName` \n```", "```\nproc    getTitle, public \nlea     x0, ttlStr \nret \nendp    getTitle \n```", "```\n .global     getTitle  // Generated by public \ngetTitle:    // Generated by proc \n             lea         x0, ttlStr \n             ret \n```", "```\n proc zeroBytes \n          mov  x1, #256 * 4 \n0:        subs x1, x1, #4 \n          str  wzr, [x0, x1] // Store *after* subtraction! \n          bne  0b            // Repeat while X1 != 0\\. \n          ret \n          endp zeroBytes \n```", "```\nret\nret `reg`64\n```", "```\nbr  `reg`64\n```", "```\nproc minimal\nret\nendp minimal\n```", "```\n// Listing5-2.S\n//\n// A procedure without a ret instruction\n\n#include \"aoaa.inc\"\n\nstackSpace  =           64\nsaveLR      =           56\n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 5-2\"\nfpMsg:      .asciz      \"followingProc was called\\n\"\n\n            .code\n            .extern     printf\n\n// Return program title to C++ program:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// noRet\n//\n// Demonstrates what happens when a procedure\n// does not have a return instruction\n\n            proc    noRet\n            endp    noRet\n\n            proc    followingProc\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]\n\n            lea     x0, fpMsg\n            bl      printf\n\n            ldr     lr, [sp, #saveLR]\n            add     sp, sp, #stackSpace\n            ret\n            endp    followingProc\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]\n\n bl      noRet\n\n            ldr     lr, [sp, #saveLR]\n            add     sp, sp, #stackSpace\n            ret\n            endp    asmMain\n```", "```\n$ ./build Listing5-2\n$ ./Listing5-2\nCalling Listing5-2:\nfollowingProc was called\nListing5-2 terminated\n```", "```\n// Listing5-3.S\n//\n// Preserving registers (failure) example\n\n#include \"aoaa.inc\"\n\nstackSpace  =           64\nsaveLR      =           56\nsaveX19     =           48\n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 5-3\"\nspace:      .asciz      \" \"\nasterisk:   .asciz      \"*, %d\\n\"\n\n            .data\nloopIndex:  .word       .-.     // Used to print loop index value\n\n            .code\n            .extern     printf\n\n// getTitle\n//\n// Return program title to C++ program:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n ret\n            endp    getTitle\n\n// print40Spaces\n//\n// Prints out a sequence of 40 spaces\n// to the console display\n\n            proc    print40Spaces\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]\n\n            mov     w19, #40\nprintLoop:  lea     x0, space\n            bl      printf\n            subs    w19, w19, #1\n            bne     printLoop // Until W19 == 0\n            ldr     lr, [sp, #saveLR]\n            add     sp, sp, #stackSpace\n            ret\n            endp    print40Spaces\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]   // Save return address.\n            str     x19, [sp, #saveX19] // Must preserve nonvolatile register.\n\n            mov     w19, #20\nastLp:      bl      print40Spaces\n            lea     x0, loopIndex\n            str     w19, [x0]\n            lea     x0, asterisk\n            vparm2  loopIndex\n            bl      printf\n            subs    w19, w19, #1\n            bne     astLp\n\n            ldr     x19, [sp, #saveX19]\n            ldr     lr, [sp, #saveLR]\n            add     sp, sp, #stackSpace\n            ret     // Returns to caller\n            endp    asmMain\n```", "```\n proc    print40Spaces\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]\n            str     x19, [sp, #saveX19]\n\n            mov     w19, #40\nprintLoop:  lea     x0, space\n            bl      printf\n            subs    w19, w19, #1\n            bne     printLoop // Until W19 == 0\n            ldr     lr, [sp, #saveLR]\n            ldr     x19, [sp, #saveX19]\n            add     sp, sp, #stackSpace\n            ret\n            endp    print40Spaces\n```", "```\n// Listing5-4.S\n//\n// Preserving registers (successful) example\n\n#include \"aoaa.inc\"\n\nstackSpace  =           64\nsaveLR      =           56\nsaveX19     =           48\n\n .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 5-4\"\nspace:      .asciz      \" \"\nasterisk:   .asciz      \"*, %d\\n\"\n\n            .data\nloopIndex:  .word       .-.     // Used to print loop index value\n\n            .code\n            .extern     printf\n\n// Return program title to C++ program:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// print40Spaces\n//\n// Prints out a sequence of 40 spaces\n// to the console display\n\n            proc    print40Spaces\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]\n            str     x19, [sp, #saveX19]\n\n            mov     w19, #40\nprintLoop:  lea     x0, space\n            bl      printf\n            subs    w19, w19, #1\n            bne     printLoop // Until W19 == 0\n            ldr     lr, [sp, #saveLR]\n            ldr     x19, [sp, #saveX19]\n            add     sp, sp, #stackSpace\n            ret\n            endp    print40Spaces\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n            sub     sp, sp, #stackSpace\n            str     lr, [sp, #saveLR]   // Save return address.\n            str     x19, [sp, #saveX19] // Must preserve nonvolatile register.\n\n            mov     w19, #20\nastLp:      bl      print40Spaces\n            lea     x0, loopIndex\n            str     w19, [x0]\n            lea     x0, asterisk\n            vparm2  loopIndex\n            bl      printf\n subs    w19, w19, #1\n            bne     astLp\n\n            ldr     lr, [sp, #saveLR]\n            ldr     x19, [sp, #saveX19]\n            add     sp, sp, #stackSpace\n            ret     // Returns to caller\n            endp    asmMain\n```", "```\n$ ./build Listing5-4\n$ ./Listing5-4\nCalling Listing5-4:\n                                        *, 20\n                                        *, 19\n                                        *, 18\n                                        *, 17\n                                        *, 16\n                                        *, 15\n                                        *, 14\n                                        *, 13\n                                        *, 12\n                                        *, 11\n                                        *, 10\n                                        *, 9\n                                        *, 8\n                                        *, 7\n                                        *, 6\n                                        *, 5\n                                        *, 4\n                                        *, 3\n                                        *, 2\n                                        *, 1\nListing5-4 terminated\n```", "```\nstr lr, [sp, #-16]!\n```", "```\nsub sp, sp, #`someAmount`   // Make room for LR on stack.\nstr lr, [sp, #`someOffset`] // Store LR into space allocated on stack.\n```", "```\nstp fp, lr, [sp, #-16]!\n```", "```\nsub sp, sp, #`someAmount`\nstp fp, lr, [sp, #`someOffset`]\n```", "```\nvoid ARDemo(unsigned i, int j, unsigned k) \n{\n     int a; \n     float r; \n     char c; \n     bool bb; \n short w; \n      . \n      . \n      . \n}\n```", "```\nstp fp, lr, [sp, #-16]!   // Save LR and FP values.\nmov fp, sp                // Get activation record ptr in FP.\nsub sp, sp, #`NumVars`      // Allocate local storage.\n```", "```\nsub sp, sp, #`NumVars`\n```", "```\nsub sp, sp, #`numVars` + 16   // Space for locals and SP/LR\nstp fp, lr, [sp, #`numVars`]\nadd fp, sp, #`numVars`\n```", "```\nenter `numVars`\n```", "```\nstp fp, lr, [sp, #-16]!\nmov fp, sp\nsub sp, sp, #(`numVars` + 15) & 0xFFFFFFFFFFFFFFF0\n```", "```\nmov sp, fp             // Deallocates storage for all the local vars\nldp fp, lr, [sp], #16  // Pop FP and return address.\nret                    // Return to caller.\n```", "```\n// Listing5-5.S\n//\n// Accessing local variables\n\n#include \"aoaa.inc\"\n\n               .text\n\n// local_vars\n//\n// Word a is at offset -4 from FP.\n// Word bb is at offset -8 from FP.\n//\n// On entry, W0 and W1 contain values to store\n// into the local variables a & bb (respectively).\n\n            proc    local_vars\n            enter   8\n\n            str     w0, [fp, #-4]   // a = W0\n            str     w1, [fp, #-8]   // bb = W1\n\n    // Additional code here that uses a & bb\n\n            leave\n            endp    local_vars\n```", "```\n// Listing5-6.S\n//\n// Accessing local variables #2\n\n#include \"aoaa.inc\"\n\n            .code\n\n// local_vars\n//\n// Demonstrates local variable access\n//\n// Word a is at offset -4 from FP.\n// Word bb is at offset -8 from FP.\n//\n// On entry, W0 and W1 contain values to store\n// into the local variables a & bb (respectively).\n\n#define a [fp, #-4]\n#define bb [fp, #-8]\n\n            proc    local_vars\n            enter   8\n\n str     w0, a\n            str     w1, bb\n\n    `Additional code here that uses a & bb.`\n\n            leave\n            endp    local_vars\n```", "```\nbl ProcA\nbl ProcB\nbl ProcC\n```", "```\nlocals `procName`\n  `declarations (same as for struct)`\nendl   `procName`\n```", "```\n proc   myProc\n\n    locals myProc\n    dword  mp.ptrVar\n    word   mp.counter\n    byte   mp.inputChar\n    salign 4\n    word   mp.endIndex\n    endl   myProc\n\n    enter  myProc.size\n\n`Insert procedure's body here.`\n\n    leave\n    endp   myProc\n```", "```\nldr w0, [fp, #mp.counter]\nldr x1, [fp, #mp.ptrVar]\nstr w0, [x1]\n```", "```\nCallProc(I);\n```", "```\n// Listing5-7.S\n//\n// Demonstrate obtaining the address\n// of a variable by using the lea instruction.\n\n#include \"aoaa.inc\"\n\n            .data\nstaticVar:  .word   .-.\n\n            .code\n            .extern someFunc\n\n            proc    get_address\n            enter   0\n            lea     x0, staticVar\n            bl      someFunc\n            leave\n            endp    get_address\n```", "```\nadd x0, fp, #`offset`\n```", "```\n// Listing5-8.S\n//\n// Demonstrate passing a local variable\n// by reference to another procedure.\n\n#include \"aoaa.inc\"\n\n            .data\nstaticVar:  .word   .-.\n\n            .code\n            .extern aSecondFunction\n\n            proc    demoPassLclByRef\n\n            locals  ga\n            word    ga.aLocalVariable\n            endl    ga\n\n            enter   ga.size\n            add     x0, fp, #ga.aLocalVariable // Pass parameter in X0.\n            bl      aSecondFunction\n\n            leave\n            endp    demoPassLclByRef\n```", "```\nbl      print\n.asciz \"This parameter is in the code stream...\"\n```", "```\n// Listing5-9.S\n//\n// Demonstrate passing parameters in the code stream\n\n#include \"aoaa.inc\"\n\n            .text\n            .pool\nttlStr:     .asciz      \"Listing 5-9\"\n            .align      2\n\n// getTitle\n//\n// Return program title to C++ program:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// print\n//\n// Here's the print procedure.\n// It expects a zero-terminated string\n// to follow the call to print:\n\nrtnAdrs     =       8           // Offset to rtn adrs from FP.\n\n            proc    print\n\n ❶ locals  print\n            qword   print.x0X1Save   // Register save area.\n            qword   print.x2X3Save\n            qword   print.x4X5Save\n            qword   print.x6X7Save\n            qword   print.x8X9Save\n            qword   print.x10X11Save\n            qword   print.x12X13Save\n            qword   print.x14X15Save\n            endl    print\n\n            enter   print.size\n\n// Assembly language convention--save all the registers\n// whose values we change. Spares caller from having to\n// preserve volatile registers.\n// Note: this code calls ABI function write, so you must\n// preserve all the volatile registers.\n\n            stp     x0, x1, [fp, #print.x0X1Save]\n            stp     x2, x3, [fp, #print.x2X3Save]\n            stp     x4, x5, [fp, #print.x4X5Save]\n            stp     x6, x7, [fp, #print.x6X7Save]\n            stp     x8, x9, [fp, #print.x8X9Save]\n            stp     x10, x11, [fp, #print.x10X11Save]\n            stp     x12, x13, [fp, #print.x12X13Save]\n            stp     x14, x15, [fp, #print.x14X15Save]\n\n// Compute the length of the string immediately following\n// the call to this procedure:\n\n          ❷ mov     x1, lr              // Get pointer to string.\nsearch4_0:  ldrb    w2, [x1], #1        // Get next char.\n            cmp     w2,  #0             // At end of string?\n            bne     search4_0           // If not, keep searching.\n            sub     x2, x1, lr          // Compute string length.\n\n// LR now points just beyond the 0 byte. We need to\n// make sure this address is 4-byte aligned:\n\n          ❸ add     x1, x1, #3\n            and     x1, x1, #-4         // 0xfff...fff0\n\n// X1 points just beyond the 0 byte and padding.\n// Save it as the new return address:\n\n          ❹ str     x1, [fp, #rtnAdrs]\n\n// Call write to print the string to the console.\n//\n// write(fd, bufAdrs, len);\n//\n// fd in X0 (this will be 1 for stdout)\n// bufAdrs in X1\n// len in X2\n\n          ❺ mov     x0, #1         // stdout = 1\n            mov     x1, lr         // Pointer to string\n            bl      write\n\n// Restore the registers we used:\n\n          ❻ ldp     x0, x1, [fp, #print.x0X1Save]\n            ldp     x2, x3, [fp, #print.x2X3Save]\n            ldp     x4, x5, [fp, #print.x4X5Save]\n            ldp     x6, x7, [fp, #print.x6X7Save]\n            ldp     x8, x9, [fp, #print.x8X9Save]\n            ldp     x10, x11, [fp, #print.x10X11Save]\n            ldp     x12, x13, [fp, #print.x12X13Save]\n            ldp     x14, x15, [fp, #print.x14X15Save]\n            leave                  // Return to caller.\n            endp    print\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n            enter   64\n\n// Demonstrate passing parameters in code stream\n// by calling the print procedure:\n\n            bl      print\n          ❼ .asciz  \"Hello, world!!\\n\"\n\n            leave   // Returns to caller\n            endp    asmMain\n```", "```\n.p2align 2\n```", "```\nbl        print\n.asciz    \"Hello, world!\\n\"\n.p2align  2\n```", "```\nbl       print\nwastr    \"Hello, world!\\n\"\n```", "```\nCallProc(i,j,k);\n```", "```\nsub sp, sp, #16   // Allocate space for parameters.\nstr w0, [sp]      // Assume i is in W0,\nstr w1, [sp, #4]  // j is in W1, and\nstr w2, [sp, #8]  // k is in W2.\nbl  CallProc\nadd sp, sp, #16   // Caller must clean up stack.\n```", "```\nproc  CallProc\nenter 0         // No local variables\n  .\n  .\n  .\nleave\nendp  CallProc\n```", "```\nldr w0, [fp, #16]\nldr w1, [fp, #20]\nldr w2, [fp, #24]\n```", "```\n// Listing5-10.S\n//\n// Accessing a parameter on the stack\n\n#include \"aoaa.inc\"\n\n            .data\nvalue1:     .word   20\nvalue2:     .word   30\npVar:       .word   .-.\n\nttlStr:     .asciz  \"Listing 5-10\"\nfmtStr1:    .asciz  \"Value of parameter: %d\\n\"\n\n            .code\n            .extern printf\n\n// getTitle\n//\n// Return program title to C++ program.\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n ret\n            endp    getTitle\n\n// valueParm\n//\n// Passed a single parameter (vp.theParm) by value\n\n            proc    valueParm\n\n            args    vp          // Declare the\n            word    vp.theParm  // parameter.\n            enda    vp\n\n            enter   64          // Alloc space for printf.\n\n// vparms macro accepts only global variables.\n// Must copy parameter to that global to print it:\n\n            lea     x0, fmtStr1\n            ldr     w1, [fp, #vp.theParm]\n            lea     x2, pVar\n            str     w1, [x2]\n            vparm2  pVar\n            bl      printf\n\n            leave\n            ret\n            endp    valueParm\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n            enter   64\n\n            lea     x0, value1\n            ldr     w1, [x0]\n            str     w1, [sp]        // Store parameter on stack.\n            bl      valueParm\n\n            lea     x0, value2\n            ldr     w1, [x0]\n            str     w1, [sp]        // Store parameter on stack.\n            bl      valueParm\n\n            leave\n            endp    asmMain\n```", "```\n% ./build Listing5-10\n% ./Listing5-10\nCalling Listing5-10:\nValue of parameter: 20\nValue of parameter: 30\nListing5-10 terminated\n```", "```\nargs procName, 0\n```", "```\nproc  myProc\nenter 64    // Allocate 64 bytes for parameter usage.\n  .\n  .\n  .\nleave       // Deallocate storage and returns.\nendp  myProc\n```", "```\nproc   myProc\n\nlocals mp\nword   mp.local1\ndword  mp.local2\nbyte   mp.local3\nbyte   mp.stack, 64 // Allocate 64 bytes for parms.\nendl   mp\n\nenter  mp.size      // Allocate locals and stack space.\n  .\n  .\n  .\nleave               // Deallocate storage and returns.\nendp   myProc\n```", "```\nlocals mp\nByte   mp.stack, 24\nendl   mp\n .\n .\n .\nenter mp.size\n .\n .\n .\nmov  x1, x0         // Put data in appropriate registers first.\nmov  x2, x5\nmov  x3, x7\nlea  x0, fmtStr\nstr  x1, [sp]       // For macOS, store the arguments\nstr  x2, [sp, #8]   // onto the stack in their\nstr  x3, [sp, #16]  // appropriate locations.\nbl   printf         // Then call printf.\n```", "```\nmstr register, memory\n```", "```\nlocals mp\nByte   mp.stack, 24\nendl   mp\n .\n .\n .\nenter mp.size\n .\n .\n .\nmov  x1, x0         // Put data in appropriate registers first.\nmov  x2, x5\nmov  x3, x7\nlea  x0, fmtStr\nmstr x1, [sp]       // For macOS, store the arguments\nmstr x2, [sp, #8]   // onto the stack in their\nmstr x3, [sp, #16]  // appropriate locations.\nbl   printf         // Then call printf.\n```", "```\n// Listing5-11.S\n//\n// Accessing a reference parameter on the stack\n\n#include \"aoaa.inc\"\n\n            .data\nvalue1:     .word   20\nvalue2:     .word   30\n\nttlStr:     .asciz  \"Listing 5-11\"\nfmtStr1:    .asciz  \"Value of reference parameter: %d\\n\"\n\n            .code\n            .extern printf\n\n// getTitle\n//\n// Return program title to C++ program.\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// refParm\n//\n// Expects a pass-by-reference parameter on the stack\n\n            proc    refParm\n\n            args    rp\n            dword   rp.theParm\n            enda    rp\n\n            enter   64              // Alloc space for printf.\n\n            lea     x0, fmtStr1\n          ❶ ldr     x1, [fp, #rp.theParm]\n            ldr     w1, [x1]\n ❷ mstr    x1, [sp]\n            bl      printf\n\n            leave\n            endp    refParm\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n            enter   64\n\n// Pass the address of the arguments on the\n// stack to the refParm procedure:\n\n          ❸ lea     x0, value1\n            str     x0, [sp]        // Store address on stack.\n            bl      refParm\n\n            lea     x0, value2\n            str     x0, [sp]        // Store address on stack.\n            bl      refParm\n\n            leave\n\n            endp    asmMain\n```", "```\n$ ./build Listing5-11\n$ ./Listing5-11\nCalling Listing5-11:\nValue of reference parameter: 20\nValue of reference parameter: 30\nListing5-11 terminated\n```", "```\n// Listing5-12.S\n//\n// Passing a large object by reference\n\n#include \"aoaa.inc\"\n\nNumElements =       24\n\n// Here's the structure type:\n\n            struct  Pt\n            byte    pt.x\n            byte    pt.y\n            ends    Pt\n\n            .data\n\nttlStr:     .asciz  \"Listing 5-12\"\nfmtStr1:    .asciz  \"refArrayParm[%d].x=%d\"\nfmtStr2:    .asciz  \"refArrayParm[%d].y=%d\\n\"\n\n            .code\n            .extern printf\n\n// getTitle\n//\n// Return program title to C++ program.\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// refAryParm\n//\n// Passed the address of an array of Pt structures\n// Initializes each element of that array\n\n            proc    refAryParm\n\n args    rap\n            dword   rap.ptArray     // Reference parameter\n            enda    rap\n\n            enter   0               // No stack space needed!\n\n// Get the base address of the array into X1:\n\n          ❶ ldr     x1, [fp, #rap.ptArray]\n\n// While X0 < NumElements, initialize each\n// array element. x = X0/8, y = X0 % 8:\n\n            mov     x0, xzr             // Index into array.\nForEachEl:  cmp     x0, #NumElements    // While we're not done\n            bhs     LoopDone\n\n// Compute address of ptArray[X0].\n// Element adrs = base address (X1) + index (X19) * size (2):\n\n          ❷ add     x3, x1, x0, lsl #1  // X3 = X1 + X0 * 2\n\n// Store index / 8 into x field:\n\n            lsr     x2, x0, #3          // X2 = X0 / 8\n            strb    w2, [x3, #pt.x]     // ptArray[X0].x = X0/8\n\n// Store index % 8 (mod) into y field:\n\n            and     x2, x0, #0b111      // X2 = X0 % 8\n            strb    w2, [x3, #pt.y]     // ptArray[X0].y = X0 % 8\n\n// Increment index and repeat:\n\n            add     x0, x0, #1\n            b.al    ForEachEl\n\nLoopDone:   leave\n            endp    refAryParm\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n// Easier to access local variables than globals, so let's\n// make everything a local variable:\n\n            locals  am\n            word    saveX19\n            byte    Pts, NumElements * (Pt.size)\n            byte    stackSpace, 64\n            endl    am\n\n            enter   am.size             // Reserve space.\n\n str     x19, [fp, #saveX19] // Save nonvolatile reg.\n\n// Initialize the array of points:\n\n          ❸ add     x0, fp, #Pts    // Compute address of Pts.\n            str     x0, [sp]        // Pass address on stack.\n            bl      refAryParm\n\n// Display the array:\n\n            mov     x19, xzr        // X19 is loop counter.\ndispLp:     cmp     x19, #NumElements\n            bhs     dispDone\n\n// Print the x field:\n\n            lea     x0, fmtStr1\n            mov     x1, x19\n            mstr    x1, [sp]\n            add     x3, fp, #Pts         // Get array base address.\n            add     x3, x3, x19, lsl #1  // Index into array.\n            ldrb    w2, [x3, #pt.x]      // Get ptArray[X0].x.\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Print the y field:\n\n            lea     x0, fmtStr2\n            mov     x1, x19\n            mstr    x1, [sp]\n            add     x3, fp, #Pts         // Get array base address.\n            add     x3, x3, x19, lsl #1  // Index into array.\n            ldrb    w2, [x3, #pt.y]      // Get ptArray[X0].x.\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Increment index and repeat:\n\n            add     x19, x19, #1\n            b.al    dispLp\n\ndispDone:\n            ldr     x19, [fp, #saveX19]  // Restore X19.\n            leave\n            endp    asmMain\n```", "```\n$ ./build Listing5-12\n$ ./Listing5-12\nCalling Listing5-12:\nrefArrayParm[0].x=0 refArrayParm[0].y=0\nrefArrayParm[1].x=0 refArrayParm[1].y=1\nrefArrayParm[2].x=0 refArrayParm[2].y=2\nrefArrayParm[3].x=0 refArrayParm[3].y=3\nrefArrayParm[4].x=0 refArrayParm[4].y=4\nrefArrayParm[5].x=0 refArrayParm[5].y=5\nrefArrayParm[6].x=0 refArrayParm[6].y=6\nrefArrayParm[7].x=0 refArrayParm[7].y=7\nrefArrayParm[8].x=1 refArrayParm[8].y=0\nrefArrayParm[9].x=1 refArrayParm[9].y=1\nrefArrayParm[10].x=1 refArrayParm[10].y=2\nrefArrayParm[11].x=1 refArrayParm[11].y=3\nrefArrayParm[12].x=1 refArrayParm[12].y=4\nrefArrayParm[13].x=1 refArrayParm[13].y=5\nrefArrayParm[14].x=1 refArrayParm[14].y=6\nrefArrayParm[15].x=1 refArrayParm[15].y=7\nrefArrayParm[16].x=2 refArrayParm[16].y=0\nrefArrayParm[17].x=2 refArrayParm[17].y=1\nrefArrayParm[18].x=2 refArrayParm[18].y=2\nrefArrayParm[19].x=2 refArrayParm[19].y=3\nrefArrayParm[20].x=2 refArrayParm[20].y=4\nrefArrayParm[21].x=2 refArrayParm[21].y=5\nrefArrayParm[22].x=2 refArrayParm[22].y=6\nrRefArrayParm[23].x=2 refArrayParm[23].y=7\nListing5-12 terminated\n```", "```\nproc  Recursive\nenter 0\nbl    Recursive\nleave\nendp  Recursive\n```", "```\n proc  Recursive\n          enter 0\n subs  x0, x0, #1\n          beq   allDone\n          bl    Recursive\nallDone:\n          leave\n          endp  Recursive\n```", "```\n proc  Recursive\n          enter 0\niterLp:\n          subs  x0, x0, #1\n          bne   iterLp\n          leave\n          endp  Recursive\n```", "```\n// Listing5-13.S\n//\n// Recursive quicksort\n\n#include \"aoaa.inc\"\n\nnumElements =       10\n\n            .data\nttlStr:     .asciz  \"Listing 5-13\"\nfmtStr1:    .asciz  \"Data before sorting: \\n\"\nfmtStr2:    .ascii  \"%d\"   // Use nl and 0 from fmtStr3\nfmtStr3:    .asciz  \"\\n\"\nfmtStr4:    .asciz  \"Data after sorting: \\n\"\nfmtStr5:    .asciz  \"ary=%p, low=%d, high=%d\\n\"\n\ntheArray:   .word   1,10,2,9,3,8,4,7,5,6\n\n .code\n            .extern printf\n\n// getTitle\n//\n// Return program title to C++ program.\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// quicksort\n//\n// Sorts an array using the quicksort algorithm\n//\n// Here's the algorithm in C, so you can follow along:\n//\n// void quicksort(int a[], int low, int high)\n// {\n//     int i,j,Middle;\n//     if(low < high)\n//     {\n//         Middle = a[(low + high)/2];\n//         i = low;\n//         j = high;\n//         do\n//         {\n//             while(a[i] <= Middle) i++;\n//             while(a[j] > Middle) j--;\n//             if(i <= j)\n//             {\n//                 swap(a[i],a[j]);\n//                 i++;\n//                 j--;\n//             }\n//         } while(i <= j);\n//\n//         // Recursively sort the two subarrays:\n//\n//         if(low < j) quicksort(a,low,j);\n//         if(i < high) quicksort(a,i,high);\n//     }\n//}\n//\n// Args:\n//    X19 (_a):       Pointer to array to sort\n//    X20 (_lowBnd):  Index to low bound of array to sort\n//    X21 (_highBnd): Index to high bound of array to sort\n//\n// Within the procedure body, these registers\n// have the following meanings:\n//\n// X19: Pointer to base address of array to sort\n// X20: Lower bound of array (32-bit index)\n// X21: Higher bound of array (32-bit index)\n//\n// X22: index (i) into array\n// X23: index (j) into array\n// X24: Middle element to compare against\n//\n// Create definitions for variable names as registers\n// to make the code more readable:\n\n#define array x19\n#define lowBnd x20\n#define highBnd x21\n#define i x22\n#define j x23\n#define middle w24\n\n            proc    quicksort\n\n            locals  qsl\n            dword   qsl.saveX19\n            dword   qsl.saveX20\n            dword   qsl.saveX21\n            dword   qsl.saveX22\n            dword   qsl.saveX23\n            dword   qsl.saveX24\n            dword   qsl.saveX0\n            byte    qsl.stackSpace, 32\n            endl    qsl\n\n            enter   qsl.size\n\n// Preserve the registers this code uses:\n\n            str     x0, [fp, #qsl.saveX0]\n            str     x19, [fp, #qsl.saveX19]\n            str     x22, [fp, #qsl.saveX22]\n            str     x23, [fp, #qsl.saveX23]\n            str     x24, [fp, #qsl.saveX24]\n\n            cmp     lowBnd, highBnd\n            bge     endif3\n\n            mov     i, lowBnd        // i = low\n            mov     j, highBnd       // j = high\n\n// Compute a pivotal element by selecting the\n// physical middle element of the array:\n//\n// Element address = ((i + j) / 2) * 4 (4 is element size)\n//                 = ((i + j) * 2)\n\n            add     x0, i, j\n            lsr     x0, x0, #1\n\n// Middle = ary[(i + j) / 2]:\n\n            ldr     middle, [array, x0, lsl #2]\n\n// Repeat until the i and j indices cross each\n// other (i works from the start toward the end\n// of the array, j works from the end toward the\n// start of the array):\n\nrptUntil:\n\n// Scan from the start of the array forward,\n// looking for the first element greater or equal\n// to the middle element:\n\n            sub     i, i, #1        // To counteract add, below\nwhile1:     add     i, i, #1        // i = i + 1\n            ldr     w1, [array, i, lsl #2]\n            cmp     middle, w1      // While middle <= ary[i]\n            bgt     while1\n\n// Scan from the end of the array backward, looking\n// for the first element that is less than or equal\n// to the middle element:\n\n            add     j, j, #1     // To counteract sub, below\nwhile2:     sub     j, j, #1     // j = j - 1\n            ldr     w1, [array, j, lsl #2]\n            cmp     middle, w1   // while middle >= a[j]\n            blt     while2\n\n// If you've stopped before the two pointers have\n// passed over each other, you have two\n// elements that are out of order with respect\n// to the middle element, so swap these two elements:\n\n            cmp     i, j        // If i <= j\n            bgt     endif1\n\n            ldr     w0, [array, i, lsl #2]\n            ldr     w1, [array, j, lsl #2]\n            str     w0, [array, j, lsl #2]\n            str     w1, [array, i, lsl #2]\n\n            add     i, i, #1\n            sub     j, j, #1\n\nendif1:     cmp     i, j        // Until i > j\n            ble     rptUntil\n\n// The code has just placed all elements in the array in\n// their correct positions with respect to the middle\n// element of the array. Unfortunately, the\n// two halves of the array on either side of the pivotal\n// element are not yet sorted. Call quicksort recursively\n// to sort these two halves if they have more than one\n// element in them (if they have zero or one elements,\n// they are already sorted).\n\n            cmp     lowBnd, j   // If lowBnd < j\n            bge     endif2\n\n            // Note: a is still in X19,\n            // Low is still in X20.\n\n            str     highBnd, [fp, #qsl.saveX21]\n            mov     highBnd, j\n            bl      quicksort   // (a, low, j)\n            ldr     highBnd, [fp, #qsl.saveX21]\n\nendif2:     cmp     i, highBnd  // If i < high\n            bge     endif3\n\n            // Note: a is still in X19,\n            // High is still in X21.\n\n            str     lowBnd, [fp, #qsl.saveX20]\n            mov     lowBnd, i\n            bl      quicksort   // (a, i + 1, high)\n            ldr     lowBnd, [fp, #qsl.saveX20]\n\n// Restore registers and leave:\n\nendif3:\n            ldr     x0,  [fp, #qsl.saveX0]\n            ldr     x19, [fp, #qsl.saveX19]\n            ldr     x22, [fp, #qsl.saveX22]\n            ldr     x23, [fp, #qsl.saveX23]\n            ldr     x24, [fp, #qsl.saveX24]\n            leave\n            endp    quicksort\n\n// printArray\n//\n// Little utility to print the array elements\n\n            proc    printArray\n\n            locals  pa\n            dword   pa.saveX19\n            dword   pa.saveX20\n            endl    pa\n\n            enter   pa.size\n            str     x19, [fp, #pa.saveX19]\n            str     x20, [fp, #pa.saveX20]\n\n            lea     x19, theArray\n            mov     x20, xzr\nwhileLT10:  cmp     x20, #numElements\n            bge     endwhile1\n\n            lea     x0, fmtStr2\n            ldr     w1, [x19, x20, lsl #2]\n            mstr    w1, [sp]\n            bl      printf\n\n            add     x20, x20, #1\n            b.al    whileLT10\n\nendwhile1:  lea     x0, fmtStr3\n            bl      printf\n\n            ldr     x19, [fp, #pa.saveX19]\n            ldr     x20, [fp, #pa.saveX20]\n            leave\n            endp    printArray\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n            locals  am\n            dword   am.savex19\n            dword   am.savex20\n            dword   am.savex21\n            byte    am.stackSpace, 64\n            endl    am\n\n            enter   am.size\n\n            str     array, [fp, #am.saveX19]\n            str     lowBnd, [fp, #am.saveX20]\n            str     highBnd, [fp, #am.saveX21]\n\n// Display unsorted array:\n\n            lea     x0, fmtStr1\n            bl      printf\n            bl      printArray\n\n// Sort the array:\n\n            lea     array, theArray\n            mov     lowBnd, xzr               // low = 0\n            mov     highBnd, #numElements - 1 // high = 9\n            bl      quicksort                 // (theArray, 0, 9)\n\n// Display sorted results:\n\n            lea     x0, fmtStr4\n            bl      printf\n            bl      printArray\n\n ldr     array, [fp, #am.saveX19]\n            ldr     lowBnd, [fp, #am.saveX20]\n            ldr     highBnd, [fp, #am.saveX21]\n            leave\n            endp    asmMain\n```", "```\n$ ./build Listing5-13\n$ ./Listing5-13\nCalling Listing5-13:\nData before sorting:\n1\n10\n2\n9\n3\n8\n4\n7\n5\n6\n\nData after sorting:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nListing5-13 terminated\n```", "```\nblr `reg`64  // Indirect call through `reg`64\n```", "```\nadd lr, pc, #4  // Set LR to return address (PC is pointing at mov).\nmov pc, `reg`64 // Transfer control to specified procedure.\n```", "```\nlea x0, procName\n```", "```\nlea x0, procName\nblr x0\n```", "```\n proc  p\n        .\n        .\n        .\n       endp  p\n        .\n        .\n        .\n       .data\nptrToP:\n       .dword  p\n        .\n        .\n        .\n       lea  x0, ptrToP\n       ldr  x0, [x0]\n       blr  x0    // Calls p if ptrToP has not changed\n```", "```\n .data\nProcPointer: .dword  p    // Initialize ProcPointer with\n                          // the address of p.\n .\n              .\n              .\n             lea  x0, ProcPointer\n             ldr  x0, [x0]\n             blr  x0  // First invocation calls p.\n\n// Reload ProcPointer with the address of q:\n\n             lea  x0, q\n             lea  x1, ProcPointer\n             str  x0, [x1]\n              .\n              .\n              .\n             lea  x0, ProcPointer\n             ldr  x0, [x0]\n             blr  x0  // This invocation calls q.\n```", "```\n .data\nsmallStk:    .fill  256\nendSmallStk:\n```", "```\n#define usp  x28   // Use a reasonable name for the user SP.\n         .\n         .\n         .\n        lea usp, endSmallStk\n```", "```\nstr lr, [usp, #-8]!  // Pre-decrement addressing mode\n .\n .\n .\nldr lr, [usp], #8    // Post-increment addressing mode\nret\n```", "```\n// Listing5-14.S\n//\n// Demonstrating a software stack\n\n#include \"aoaa.inc\"\n\n#define usp x28     // Program-defined stack pointer\n\nstackSpace  =           64  // Space on the HW stack\nsaveLRUSP   =           48  // 16 bytes to hold LR and USP\n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 5-14\"\nspace:      .asciz      \" \"\nasterisk:   .asciz      \"*, %ld\\n\"\n\n            .data\nloopIndex:  .dword       .-.     // Used to print loop index value\n\n// Here's the software-based stack this program will use\n// to store return addresses and the like:\n\n            .align      3\nsmallStk:   .fill       256, .-.\nendSmallStk:\n\n            .code\n            .extern     printf\n\n// getTitle\n//\n// Return program title to C++ program.\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// print40Spaces\n//\n// Prints out a sequence of 40 spaces\n// to the console display\n\n            proc    print40Spaces\n          ❶ stp     lr, x19, [usp, #-16]! // Preserve LR and X19.\n\n            mov     w19, #40\nprintLoop:  lea     x0, space\n            bl      printf\n subs    w19, w19, #1\n            bne     printLoop // Until w19 == 0\n\n          ❷ ldp     lr, x19, [usp], #16 // Restore LR and X19.\n            ret\n            endp    print40Spaces\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n          ❸ sub     sp, sp, #stackSpace       // HW stack space\n            stp     lr, usp, [sp, #saveLRUSP] // Save on HW stack.\n\n          ❹ lea     usp, endSmallStk   // Initialize USP.\n          ❺ str     x19, [usp, #-16]!  // Save X19 on SW stk.\n\n            mov     x19, #20\nastLp:      bl      print40Spaces\n            lea     x0, loopIndex\n            str     x19, [x0]\n            lea     x0, asterisk\n            vparm2  loopIndex\n            bl      printf\n            subs    x19, x19, #1\n            bne     astLp\n\n          ❻ ldr     x19, [usp], #16  // Restore from SW stack.\n          ❼ ldp     lr, usp, [sp, #saveLRUSP]\n            add     sp, sp, #stackSpace\n            ret     // Returns to caller\n            endp    asmMain\n```", "```\n$ ./build Listing5-14\n$ ./Listing5-14\nCalling Listing5-14:\n                                        *, 20\n                                        *, 19\n                                        *, 18\n                                        *, 17\n                                        *, 16\n                                        *, 15\n                                        *, 14\n                                        *, 13\n                                        *, 12\n                                        *, 11\n                                        *, 10\n                                        *, 9\n                                        *, 8\n                                        *, 7\n                                        *, 6\n                                        *, 5\n                                        *, 4\n                                        *, 3\n                                        *, 2\n                                        *, 1\nListing5-14 terminated\n```"]