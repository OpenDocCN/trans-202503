<html><head></head><body><section class="chapter" title="Chapter&#xA0;6.&#xA0;Text Conversion and Substitution" epub:type="chapter" id="text_conversion_and_substitution"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Text Conversion and Substitution</h2></div></div></div><p><a id="idx00469" class="indexterm"/><a id="idx00472" class="indexterm"/><a id="idx00544" class="indexterm"/><a id="idx00581" class="indexterm"/><a id="idx00606" class="indexterm"/><a id="idx00677" class="indexterm"/>In this chapter, we’ll look at various one-liners that change, convert, and substitute text, including base64 encoding and decoding, URL escaping and unescaping, HTML escaping and unescaping, converting text case, and reversing lines. You’ll also get to know the <code class="literal">y</code>, <code class="literal">tr</code>, <code class="literal">uc</code>, <code class="literal">lc</code>, and <code class="literal">reverse</code> operators and string-escape sequences.</p><div class="sect1" title="6.1 ROT13 a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_1_rot13_a_string">6.1 ROT13 a string</h2></div></div></div><a id="I_programlisting6_id309917"/><pre class="programlisting">perl -le '$string = "<span class="emphasis"><em>bananas</em></span>"; $string =~ y/A-Za-z/N-ZA-Mn-za-m/; print $string'</pre><p>This one-liner uses the <code class="literal">y</code> operator (also known as the <code class="literal">tr</code> operator) to do ROT13. The operators <code class="literal">y</code> and <code class="literal">tr</code> perform string transliteration. Given <code class="literal">y/search/replace/</code>, the <code class="literal">y</code> operator transliterates all occurrences of the characters found in the <code class="literal">search</code> list with the characters in the corresponding positions in the <code class="literal">replace</code> list. The <code class="literal">y</code> and <code class="literal">tr</code> operators are often mistaken for taking a regular expression, but they don’t. They transliterate things and take a list of characters in both the <code class="literal">search</code> and <code class="literal">replace</code> parts.</p><p><a id="idx00005" class="indexterm"/><a id="idx00076" class="indexterm"/><a id="idx00120" class="indexterm"/><a id="idx00129" class="indexterm"/><a id="idx00132" class="indexterm"/><a id="idx00200" class="indexterm"/><a id="idx00311" class="indexterm"/><a id="idx00314" class="indexterm"/><a id="idx00394" class="indexterm"/><a id="idx00406" class="indexterm"/><a id="idx00564" class="indexterm"/>In this one-liner, <code class="literal">A-Za-z</code> creates the following list of characters:</p><a id="I_programlisting6_id310067"/><pre class="programlisting">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</pre><p>And <code class="literal">N-ZA-Mn-za-m</code> creates this list:</p><a id="I_programlisting6_id310078"/><pre class="programlisting">NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm</pre><p>Notice that in the second list the uppercase and lowercase alphabets are offset by 13 characters. Now the <code class="literal">y</code> operator translates each character in the first list to a character in the second list, thus performing the ROT13 operation. (One fun fact about ROT13 is that applying it twice produces the same string; that is, ROT13(ROT13(<span class="emphasis"><em>string</em></span>)) equals <span class="emphasis"><em>string</em></span>.)</p><p>To ROT13 the whole file <span class="emphasis"><em>bananas.txt</em></span> and print it to the screen, just do this:</p><a id="I_programlisting6_id310107"/><pre class="programlisting">perl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' <span class="emphasis"><em>bananas</em></span>.txt</pre><p>You can also use Perl’s <code class="literal">-i</code> argument to do in-place replacement of the file. For example, to ROT13 <span class="emphasis"><em>oranges.txt</em></span> in-place, write this:</p><a id="I_programlisting6_id310126"/><pre class="programlisting">perl -pi.bak -e 'y/A-Za-z/N-ZA-Mn-za-m/' <span class="emphasis"><em>oranges</em></span>.txt</pre><p>This one-liner first creates a backup file called <span class="emphasis"><em>oranges.txt.bak</em></span> and then replaces the contents of <span class="emphasis"><em>oranges.txt</em></span> with ROT13-ed text. The <code class="literal">.bak</code> part of the <code class="literal">-i</code> command creates the backup file. You can omit the <code class="literal">.bak</code> part of the command if you’re sure about the result, but I recommend always using <code class="literal">-i.bak</code> because one day you might make a mistake and mess up an important file. (I speak from experience.)</p></div><div class="sect1" title="6.2 Base64-encode a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_2_base64-encode_a_string">6.2 Base64-encode a string</h2></div></div></div><a id="I_programlisting6_id310170"/><pre class="programlisting">perl -MMIME::Base64 -e 'print encode_base64("<span class="emphasis"><em>string</em></span>")'</pre><p>This one-liner uses the <code class="literal">MIME::Base64</code> module. It exports the <code class="literal">encode_base64</code> function, which takes a string and returns a base64-encoded version of it.</p><p>To base64-encode the whole file, use this:</p><a id="I_programlisting6_id310194"/><pre class="programlisting">perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' <span class="emphasis"><em>file</em></span></pre><p><a id="idx00170" class="indexterm"/><a id="idx00172" class="indexterm"/><a id="idx00202" class="indexterm"/><a id="idx00214" class="indexterm"/><a id="idx00410" class="indexterm"/><a id="idx00584" class="indexterm"/><a id="idx00611" class="indexterm"/><a id="idx00620" class="indexterm"/><a id="idx00621" class="indexterm"/>Here, the <code class="literal">-0777</code> argument together with <code class="literal">-n</code> causes Perl to slurp the whole file into the <code class="literal">$_</code> variable. Next, the file is base64-encoded and printed. (If Perl didn’t slurp the entire file, it would be encoded line by line, and you’d end up with a mess.)</p></div><div class="sect1" title="6.3 Base64-decode a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_3_base64-decode_a_string">6.3 Base64-decode a string</h2></div></div></div><a id="I_programlisting6_id310294"/><pre class="programlisting">perl -MMIME::Base64 -le 'print decode_base64("<span class="emphasis"><em>base64string</em></span>")'</pre><p>The <code class="literal">MIME::Base64</code> module also exports the <code class="literal">decode_base64</code> function, which takes a base64-encoded string and decodes it.</p><p>The entire file can be decoded similarly with</p><a id="I_programlisting6_id310318"/><pre class="programlisting">perl -MMIME::Base64 -0777 -ne 'print decode_base64($_)' <span class="emphasis"><em>file</em></span></pre></div><div class="sect1" title="6.4 URL-escape a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_4_url-escape_a_string">6.4 URL-escape a string</h2></div></div></div><a id="I_programlisting6_id310332"/><pre class="programlisting">perl -MURI::Escape -le 'print uri_escape("<span class="emphasis"><em><a class="ulink" href="http://example.com" target="_top">http://example.com</a></em></span>")'</pre><p>To use this one-liner, you need to install the <code class="literal">URI::Escape</code> module first by entering <code class="literal">cpan URI::Escape</code> in the shell. The module exports two functions: <code class="literal">uri_escape</code> and <code class="literal">uri_unescape</code>. The first function performs <span class="emphasis"><em>URL escaping</em></span> (sometimes referred to as <span class="emphasis"><em>URL encoding</em></span>), and the other does <span class="emphasis"><em>URL unescaping</em></span> (or <span class="emphasis"><em>URL decoding</em></span>). Now, to URL-escape a string, just call <code class="literal">uri_escape($string)</code> and you’re done!</p><p>The output of this one-liner is <code class="literal">http%3A%2F%2Fexample.com</code>.</p></div><div class="sect1" title="6.5 URL-unescape a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_5_url-unescape_a_string">6.5 URL-unescape a string</h2></div></div></div><a id="I_programlisting6_id310399"/><pre class="programlisting">perl -MURI::Escape -le 'print uri_unescape("<span class="emphasis"><em>http%3A%2F%2Fexample.com</em></span>")'</pre><p>This one-liner uses the <code class="literal">uri_unescape</code> function from the <code class="literal">URI::Escape</code> module to perform URL unescaping. It unescapes the output of the previous one-liner to reverse the operation.</p><p>The output of this one-liner is <code class="literal">http://example.com</code>.</p></div><div class="sect1" title="6.6 HTML-encode a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_6_html-encode_a_string">6.6 HTML-encode a string</h2></div></div></div><a id="I_programlisting6_id310437"/><pre class="programlisting">perl -MHTML::Entities -le 'print encode_entities("<span class="emphasis"><em>&lt;html&gt;</em></span>")'</pre><p><a id="idx00106" class="indexterm"/><a id="idx00108" class="indexterm"/><a id="idx00159" class="indexterm"/><a id="idx00171" class="indexterm"/><a id="idx00191" class="indexterm"/><a id="idx00201" class="indexterm"/><a id="idx00206" class="indexterm"/><a id="idx00210" class="indexterm"/><a id="idx00262" class="indexterm"/><a id="idx00279" class="indexterm"/><a id="idx00304" class="indexterm"/><a id="idx00307" class="indexterm"/><a id="idx00335" class="indexterm"/><a id="idx00347" class="indexterm"/><a id="idx00385" class="indexterm"/><a id="idx00400" class="indexterm"/><a id="idx00565" class="indexterm"/><a id="idx00574" class="indexterm"/><a id="idx00608" class="indexterm"/><a id="idx00609" class="indexterm"/><a id="idx00619" class="indexterm"/>This one-liner uses the <code class="literal">encode_entities</code> function from the <code class="literal">HTML::Entities</code> module to encode HTML entities. For example, you can turn <code class="literal">&lt;</code> and <code class="literal">&gt;</code> into <code class="literal">&amp;lt;</code> and <code class="literal">&amp;gt;</code>.</p></div><div class="sect1" title="6.7 HTML-decode a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_7_html-decode_a_string">6.7 HTML-decode a string</h2></div></div></div><a id="I_programlisting6_id310633"/><pre class="programlisting">perl -MHTML::Entities -le 'print decode_entities("<span class="emphasis"><em>&amp;lt;html&amp;gt;</em></span>")'</pre><p>This one-liner uses the <code class="literal">decode_entities</code> function from the <code class="literal">HTML::Entities</code> module. For example, you can turn <code class="literal">&amp;lt;</code> and <code class="literal">&amp;gt;</code> back into <code class="literal">&lt;</code> and <code class="literal">&gt;</code>.</p></div><div class="sect1" title="6.8 Convert all text to uppercase"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_8_convert_all_text_to_uppercase">6.8 Convert all text to uppercase</h2></div></div></div><a id="I_programlisting6_id310679"/><pre class="programlisting">perl -nle 'print uc'</pre><p>This one-liner uses the <code class="literal">uc</code> function, which, by default, operates on the <code class="literal">$_</code> variable and returns an uppercase version of the text it contains.</p><p>You could do the same thing with the <code class="literal">-p</code> command-line option, which enables the automatic printing of the <code class="literal">$_</code> variable and modifies it in-place:</p><a id="I_programlisting6_id310706"/><pre class="programlisting">perl -ple '$_ = uc'</pre><p>Or you can apply the <code class="literal">\U</code> escape sequence to string interpolation:</p><a id="I_programlisting6_id310718"/><pre class="programlisting">perl -nle 'print "\U$_"'</pre><p>This one-liner uppercases everything that follows it (or everything up to the first occurrence of <code class="literal">\E</code>).</p></div><div class="sect1" title="6.9 Convert all text to lowercase"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_9_convert_all_text_to_lowercase">6.9 Convert all text to lowercase</h2></div></div></div><a id="I_programlisting6_id310740"/><pre class="programlisting">perl -nle 'print lc'</pre><p>This one-liner is similar to the previous one. The <code class="literal">lc</code> function converts the contents of <code class="literal">$_</code> to lowercase.</p><p><a id="idx00164" class="indexterm"/><a id="idx00192" class="indexterm"/><a id="idx00207" class="indexterm"/><a id="idx00208" class="indexterm"/><a id="idx00209" class="indexterm"/><a id="idx00280" class="indexterm"/><a id="idx00320" class="indexterm"/><a id="idx00324" class="indexterm"/><a id="idx00334" class="indexterm"/><a id="idx00605" class="indexterm"/><a id="idx00607" class="indexterm"/><a id="idx00610" class="indexterm"/>You could also use the escape sequence <code class="literal">\L</code> and string interpolation:</p><a id="I_programlisting6_id310842"/><pre class="programlisting">perl -nle 'print "\L$_"'</pre><p>Here, <code class="literal">\L</code> lowercases everything after it (or until the first instance of <code class="literal">\E</code>).</p></div><div class="sect1" title="6.10 Uppercase only the first letter of each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_10_uppercase_only_the_first_letter_o">6.10 Uppercase only the first letter of each line</h2></div></div></div><a id="I_programlisting6_id310868"/><pre class="programlisting">perl -nle 'print ucfirst lc'</pre><p>This one-liner first lowercases the input with the <code class="literal">lc</code> function and then uses <code class="literal">ucfirst</code> to uppercase only the first character. For example, if you pass it a line that says <span class="emphasis"><em>foo bar baz</em></span>, it produces the text <span class="emphasis"><em>Foo bar baz</em></span>. Similarly, if you pass it a line <span class="emphasis"><em>FOO BAR BAZ</em></span>, it lowercases the line first and then uppercases the first letter, producing <span class="emphasis"><em>Foo bar baz</em></span> again.</p><p>You can do the same thing using escape codes and string interpolation:</p><a id="I_programlisting6_id310901"/><pre class="programlisting">perl -nle 'print "\u\L$_"'</pre><p>First <code class="literal">\L</code> lowercases the whole line and then <code class="literal">\u</code> uppercases the first character.</p></div><div class="sect1" title="6.11 Invert the letter case"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_11_invert_the_letter_case">6.11 Invert the letter case</h2></div></div></div><a id="I_programlisting6_id310926"/><pre class="programlisting">perl -ple 'y/A-Za-z/a-zA-Z/'</pre><p>This one-liner changes the case of the letters: The capital letters become lowercase letters, and the lowercase letters become capital letters. For example, the text <span class="emphasis"><em>Cows are COOL</em></span> becomes <span class="emphasis"><em>cOWS ARE cool</em></span>. The transliteration operator <code class="literal">y</code> (explained in one-liner 6.1 on page 59) creates a mapping from capital letters <code class="literal">A-Z</code> to lowercase letters <code class="literal">a-z</code> and a mapping from lowercase letters <code class="literal">a-z</code> to capital letters <code class="literal">A-Z</code>.</p></div><div class="sect1" title="6.12 Title-case each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_12_title-case_each_line">6.12 Title-case each line</h2></div></div></div><a id="I_programlisting6_id310972"/><pre class="programlisting">perl -ple 's/(\w+)/\u$1/g'</pre><p>This one-liner attempts to title-case a string, meaning the first letter of each word is uppercased; for example, <span class="emphasis"><em>This Text Is Written In Title Case</em></span>. This one-liner works by matching every word with <code class="literal">\w+</code> and replacing the matched word with <code class="literal">\u$1</code>, which uppercases the first letter of the word.</p></div><div class="sect1" title="6.13 Strip leading whitespace (spaces, tabs) from the beginning of each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_13_strip_leading_whitespace_spaces_t">6.13 Strip leading whitespace (spaces, tabs) from the beginning of each line</h2></div></div></div><a id="I_programlisting6_id311005"/><pre class="programlisting">perl -ple 's/^[ \t]+//'</pre><p><a id="idx00177" class="indexterm"/><a id="idx00586" class="indexterm"/><a id="idx00646" class="indexterm"/><a id="idx00648" class="indexterm"/>This one-liner deletes all whitespace from the beginning of every line with the help of the substitution operator <code class="literal">s</code>. Given <code class="literal">s/regex/replace/</code>, it replaces the matched <code class="literal">regex</code> with the <code class="literal">replace</code> string. In this case, the <code class="literal">regex</code> is <code class="literal">^[ \t]+</code>, which means “match one or more spaces or tabs at the beginning of the string,” and <code class="literal">replace</code> is empty, meaning “replace the matched part with an empty string.”</p><p>The regular expression class <code class="literal">[ \t]</code> can also be replaced by <code class="literal">\s+</code> to match any whitespace (including tabs and spaces):</p><a id="I_programlisting6_id311077"/><pre class="programlisting">perl -ple 's/^\s+//'</pre></div><div class="sect1" title="6.14 Strip trailing whitespace (spaces, tabs) from the end of each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_14_strip_trailing_whitespace_spaces">6.14 Strip trailing whitespace (spaces, tabs) from the end of each line</h2></div></div></div><a id="I_programlisting6_id311091"/><pre class="programlisting">perl -ple 's/[ \t]+$//'</pre><p>This one-liner deletes all whitespace from the end of each line. The <code class="literal">regex</code> of the <code class="literal">s</code> operator says “match one or more spaces or tabs at the end of the string.” The <code class="literal">replace</code> part is empty again, which means “erase the matched whitespace.”</p><p>You can also achieve the same by writing:</p><a id="I_programlisting6_id311116"/><pre class="programlisting">perl -ple 's/\s+$//'</pre><p>Here, you replace with <code class="literal">[ \t]+$</code> with <code class="literal">\s+</code>, as in one-liner 6.13.</p></div><div class="sect1" title="6.15 Strip whitespace (spaces, tabs) from the beginning and end of each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_15_strip_whitespace_spaces_tabs_from">6.15 Strip whitespace (spaces, tabs) from the beginning and end of each line</h2></div></div></div><a id="I_programlisting6_id311142"/><pre class="programlisting">perl -ple 's/^[ \t]+|[ \t]+$//g'</pre><p>This one-liner combines one-liners 6.13 and 6.14. It specifies the global <code class="literal">/g</code> flag to the <code class="literal">s</code> operator because you want it to delete whitespace at the beginning <span class="emphasis"><em>and</em></span> the end of the string. If you don’t specify this, it deletes whitespace only at the beginning (if there is whitespace) or only at the end (if there was no whitespace at the beginning).</p><p><a id="idx00161" class="indexterm"/><a id="idx00184" class="indexterm"/><a id="idx00388" class="indexterm"/><a id="idx00416" class="indexterm"/><a id="idx00436" class="indexterm"/><a id="idx00613" class="indexterm"/><a id="idx00659" class="indexterm"/>You can also replace <code class="literal">[ \t]+$</code> with <code class="literal">\s+</code> and get the same results:</p><a id="I_programlisting6_id311227"/><pre class="programlisting">perl -ple 's/^\s+|\s+$//g'</pre><p>Writing <code class="literal">\s+</code> is shorter than writing <code class="literal">[ \t]+</code>. And <code class="literal">s</code> stands for space, which makes it easier to remember.</p></div><div class="sect1" title="6.16 Convert UNIX newlines to DOS/Windows newlines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_16_convert_unix_newlines_to_dos_wind">6.16 Convert UNIX newlines to DOS/Windows newlines</h2></div></div></div><a id="I_programlisting6_id311255"/><pre class="programlisting">perl -pe 's|\012|\015\012|'</pre><p>This one-liner substitutes the UNIX newline character <code class="literal">\012</code> (<code class="literal">LF</code>) for the Windows/DOS newline character <code class="literal">\015\012</code> (<code class="literal">CRLF</code>) on each line. One nice feature of <code class="literal">s/regex/replace/</code> is that it can take characters other than forward slashes as delimiters. Here, it uses vertical pipes to delimit <code class="literal">regex</code> from <code class="literal">replace</code> to improve readability.</p><p>Newlines are usually represented as <code class="literal">\n</code> and carriage returns as <code class="literal">\r</code>, but across platforms, the meanings of the <code class="literal">\n</code> and <code class="literal">\r</code> sequences can vary. The UNIX newline character, however, is always available as <code class="literal">\012</code> (<code class="literal">LF</code>), and the carriage-return character represented by <code class="literal">\r</code> is always available as <code class="literal">\015</code> (<code class="literal">CR</code>). That’s why you use those numeric codes: Sometimes using the flexible sequence is preferable, but not here.</p></div><div class="sect1" title="6.17 Convert DOS/Windows newlines to UNIX newlines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_17_convert_dos_windows_newlines_to_u">6.17 Convert DOS/Windows newlines to UNIX newlines</h2></div></div></div><a id="I_programlisting6_id311340"/><pre class="programlisting">perl -pe 's|\015\012|\012|'</pre><p>This one-liner works in the opposite direction from one-liner 6.16. It takes Windows newlines (<code class="literal">CRLF</code>) and converts them to UNIX newlines (<code class="literal">LF</code>).</p></div><div class="sect1" title="6.18 Convert UNIX newlines to Mac newlines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_18_convert_unix_newlines_to_mac_newl">6.18 Convert UNIX newlines to Mac newlines</h2></div></div></div><a id="I_programlisting6_id311367"/><pre class="programlisting">perl -pe 's|\012|\015|'</pre><p>Mac OS previously used <code class="literal">\015</code> (<code class="literal">CR</code>) as newlines. This one-liner converts UNIX’s <code class="literal">\012</code> (<code class="literal">LF</code>) to Mac OS’s <code class="literal">\015</code> (<code class="literal">CR</code>).</p></div><div class="sect1" title="6.19 Substitute (find and replace) “foo” with “bar” on each line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_19_substitute_find_and_replace_foo_w">6.19 Substitute (find and replace) “foo” with “bar” on each line</h2></div></div></div><a id="I_programlisting6_id311409"/><pre class="programlisting">perl -pe 's/foo/bar/'</pre><p><a id="idx00004" class="indexterm"/><a id="idx00011" class="indexterm"/><a id="idx00119" class="indexterm"/><a id="idx00181" class="indexterm"/><a id="idx00246" class="indexterm"/><a id="idx00365" class="indexterm"/><a id="idx00440" class="indexterm"/><a id="idx00475" class="indexterm"/><a id="idx00481" class="indexterm"/><a id="idx00542" class="indexterm"/><a id="idx00580" class="indexterm"/><a id="idx00589" class="indexterm"/>This one-liner uses the <code class="literal">s/regex/replace/</code> command to substitute the first occurrence of <code class="literal">foo</code> with <code class="literal">bar</code> on each line.</p><p>To replace all <code class="literal">foo</code>s with <code class="literal">bar</code>s, add the global <code class="literal">/g</code> flag:</p><a id="I_programlisting6_id311536"/><pre class="programlisting">perl -pe 's/foo/bar/g'</pre></div><div class="sect1" title="6.20 Substitute (find and replace) “foo” with “bar” on lines that match “baz”"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_20_substitute_find_and_replace_foo_w">6.20 Substitute (find and replace) “foo” with “bar” on lines that match “baz”</h2></div></div></div><a id="I_programlisting6_id311551"/><pre class="programlisting">perl -pe '/baz/ &amp;&amp; s/foo/bar/'</pre><p>This one-liner is roughly equivalent to</p><a id="I_programlisting6_id311558"/><pre class="programlisting">while (defined($line = &lt;&gt;)) {
  if ($line =~ /baz/) {
    $line =~ s/foo/bar/
  }
}</pre><p>This expanded code puts each line into the variable <code class="literal">$line</code> and then checks to see if a line in that variable matches <code class="literal">baz</code>. If so, it replaces <code class="literal">foo</code> with <code class="literal">bar</code> in that line.</p><p>You could also write</p><a id="I_programlisting6_id311585"/><pre class="programlisting">perl -pe 's/foo/bar/ if /baz/'</pre></div><div class="sect1" title="6.21 Print paragraphs in reverse order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_21_print_paragraphs_in_reverse_order">6.21 Print paragraphs in reverse order</h2></div></div></div><a id="I_programlisting6_id311598"/><pre class="programlisting">perl -00 -e 'print reverse &lt;&gt;' <span class="emphasis"><em>file</em></span></pre><p>This one-liner uses the <code class="literal">-00</code> argument discussed in one-liner 2.7 (page 14) to turn paragraph slurp mode on, meaning that Perl reads text paragraph by paragraph, rather than line by line. Next, it uses the <code class="literal">&lt;&gt;</code> operator to make Perl read the input from either standard input or files specified as arguments. Here, I’ve specified <code class="literal">file</code> as the argument so Perl will read <code class="literal">file</code> paragraph by paragraph (thanks to <code class="literal">-00</code>). Once Perl finishes reading the file, it returns all paragraphs as a list and calls <code class="literal">reverse</code> to reverse the order of the paragraph list. Finally, <code class="literal">print</code> prints the list of reversed paragraphs.</p></div><div class="sect1" title="6.22 Print all lines in reverse order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_22_print_all_lines_in_reverse_order">6.22 Print all lines in reverse order</h2></div></div></div><a id="I_programlisting6_id311650"/><pre class="programlisting">perl -lne 'print scalar reverse $_'</pre><p><a id="idx00032" class="indexterm"/><a id="idx00114" class="indexterm"/><a id="idx00354" class="indexterm"/><a id="idx00462" class="indexterm"/><a id="idx00543" class="indexterm"/><a id="idx00643" class="indexterm"/>This one-liner evaluates the <code class="literal">reverse</code> operator in the scalar context. In the previous one-liner, you saw that evaluating <code class="literal">reverse</code> in the list context reverses the whole list, that is, the order of the elements. To do the same for scalar values such as <code class="literal">$_</code> that contain the whole line, you have to call <code class="literal">reverse</code> in the scalar context. Otherwise, it simply reverses a list with only one element, which is the same list! Once you’ve done that, you simply print the reversed line.</p><p>Often you can drop the <code class="literal">$_</code> variable when using operators and Perl will still apply the function on the <code class="literal">$_</code> variable. In other words, you can rewrite the same one-liner as</p><a id="I_programlisting6_id311732"/><pre class="programlisting">perl -lne 'print scalar reverse'</pre><p>Or you can substitute <code class="literal">-n</code> for <code class="literal">-p</code>, modify the <code class="literal">$_</code> variable, and set its value to reverse:</p><a id="I_programlisting6_id311751"/><pre class="programlisting">perl -lpe '$_ = reverse $_'</pre><p>You can also write this as</p><a id="I_programlisting6_id311759"/><pre class="programlisting">perl -lpe '$_ = reverse'</pre><p>Here, <code class="literal">$_</code> is dropped because most Perl operators default to <code class="literal">$_</code> when not given an argument.</p></div><div class="sect1" title="6.23 Print columns in reverse order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="six_23_print_columns_in_reverse_order">6.23 Print columns in reverse order</h2></div></div></div><a id="I_programlisting6_id311784"/><pre class="programlisting">perl -alne 'print "@{[reverse @F]}"'</pre><p>This one-liner reverses the order of columns in a file. The <code class="literal">-a</code> command-line argument splits each line into columns at spaces and puts them in the <code class="literal">@F</code> array, which is then reversed and printed. This one-liner is similar to one-liner 4.4 on page 32; I explained the <code class="literal">@{[ ... ]}</code> construct there. It simply lets you run code inside of double quotes. For example, given the following input file:</p><a id="I_programlisting6_id311806"/><pre class="programlisting">one two three four
five six seven eight</pre><p><a id="idx00026" class="indexterm"/><a id="idx00127" class="indexterm"/><a id="idx00224" class="indexterm"/><a id="idx00637" class="indexterm"/>the one-liner reverses the order of the columns, and the output is the following:</p><a id="I_programlisting6_id311842"/><pre class="programlisting">four three two one
eight seven six five</pre><p>If the columns in your input are separated by any character other than a space, you can use the <code class="literal">-F</code> command-line argument to set a different delimiter. For example, given the following input file:</p><a id="I_programlisting6_id311854"/><pre class="programlisting">one:two:three:four
five:six:seven:eight</pre><p>you can add the <code class="literal">-F:</code> command-line argument to the one-liner like this:</p><a id="I_programlisting6_id311866"/><pre class="programlisting">perl -F: -alne 'print "@{[reverse @F]}"'</pre><p>and it produces this output:</p><a id="I_programlisting6_id311874"/><pre class="programlisting">four three two one
eight seven six five</pre><p>Notice, however, that the <code class="literal">:</code> characters are missing in this output. To get them back, you need to modify the one-liner a bit and set the <code class="literal">$"</code> variable to <code class="literal">":"</code>, as shown here:</p><a id="I_programlisting6_id311893"/><pre class="programlisting">perl -F: -alne '$" = ":"; print "@{[reverse @F]}"'</pre><p>This produces the expected output:</p><a id="I_programlisting6_id311901"/><pre class="programlisting">four:three:two:one
eight:seven:six:five</pre><p>The <code class="literal">$"</code> variable changes the character that’s printed between array elements when an array is interpolated within a double-quoted string.</p></div></section></body></html>