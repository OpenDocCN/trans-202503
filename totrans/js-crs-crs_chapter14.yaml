- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCING
    THE D3 LIBRARY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">介绍D3库</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: Today’s world is full of data, but raw data is basically impossible to understand
    without visualizing it in some way. Data visualizations can be incredibly simple,
    such as a chart on Wikipedia showing the average temperature each month in a particular
    city, or highly intricate, such as an animated infographic from a news organization
    illustrating the income mobility of tens of thousands of Americans. No matter
    the level of complexity, however, data visualizations always have the potential
    to give us more insight into the data we’re exploring.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当今世界充满了数据，但没有以某种方式将数据可视化，原始数据基本上是无法理解的。数据可视化可以非常简单，比如维基百科上的一张图表，显示某个特定城市每个月的平均温度；也可以非常复杂，比如新闻机构制作的动画信息图，展示数万美国人的收入流动性。无论复杂程度如何，数据可视化总是有潜力为我们提供更深入的洞察。
- en: In this project you’ll learn to use a powerful JavaScript library called D3.js
    (or D3 for short), which will enable you to create a whole range of data visualizations
    in the browser. The great thing about using JavaScript to make data visualizations
    is that they can be dynamic and interactive. *Dynamic* means the visualization
    can change over time; for example, they can be updated as new data comes in. *Interactive*
    means the user can manipulate the visualization, for example, by clicking to reveal
    more detail about a particular aspect. Also, because you’re coding up the visualizations
    yourself, you’re free to customize them in any way you want.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习使用一个强大的JavaScript库，叫做D3.js（简称D3），它将使你能够在浏览器中创建各种数据可视化。使用JavaScript制作数据可视化的好处在于，它们可以是动态的和交互式的。*动态*意味着可视化可以随着时间变化；例如，当新数据到来时，可以更新。*交互式*意味着用户可以操作可视化，例如，通过点击显示某个特定方面的更多细节。此外，由于你是自己编写代码来制作可视化，因此可以自由地根据需要自定义它们。
- en: This chapter introduces you to the basics of working with D3, to prepare you
    for the next chapter, where you’ll create an interactive visualization by loading
    data from an external API. D3 primarily uses a web graphics technology called
    Scalable Vector Graphics (SVG), so we’ll start with a crash course in SVG before
    we dive into D3 itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍使用D3的基础知识，为下一章做准备，在下一章中，你将通过从外部API加载数据来创建一个交互式可视化。D3主要使用一种叫做可扩展矢量图形（SVG）的网页图形技术，因此在深入D3之前，我们将从SVG的速成课程开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SVG Graphics Format</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">SVG图形格式</samp>
- en: SVG is a way of defining images using points, lines, and curves, rather than
    pixels. These images are known as *vector graphics*. Because you’re defining the
    *shape* of the image rather than the individual pixels themselves, you can resize
    or zoom in on an SVG image without it becoming pixelated (hence the *scalable*
    part of the name).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SVG是一种使用点、线和曲线来定义图像的方式，而不是使用像素。这些图像被称为*矢量图形*。因为你定义的是图像的*形状*，而不是单独的像素，所以你可以自由缩放或放大SVG图像，而不会出现像素化现象（因此有了名称中的*可扩展*部分）。
- en: SVG is based on Extensible Markup Language (XML), a language for storing data
    that, like HTML, relies on a structure of nested elements with start and end tags.
    SVG XML looks similar to HTML, but it has its own set of tags that correspond
    directly to visual elements (in HTML, by contrast, the tags are used to define
    structure and content). SVG files can be standalone XML files, but SVG can also
    be embedded in an HTML file using the HTML svg element, making it easy to add
    SVG graphics to a web page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SVG基于可扩展标记语言（XML），这是一种用于存储数据的语言，类似于HTML，它依赖于带有开始和结束标签的嵌套元素结构。SVG的XML看起来类似于HTML，但它有自己的一套标签，直接对应于视觉元素（而HTML中的标签则用于定义结构和内容）。SVG文件可以是独立的XML文件，但也可以使用HTML的svg元素将SVG嵌入HTML文件中，从而便于将SVG图形添加到网页中。
- en: One advantage of SVG over the Canvas API for rendering interactive graphics
    on the web is that each element of an SVG drawing is represented by a DOM element
    on the web page, which means you can style it with CSS and use JavaScript to add
    event handlers to respond to mouse events like clicks or hovers. On the other
    hand, Canvas-based graphics are faster to render, so applications like games that
    need a high frame rate tend to use the Canvas API rather than SVG.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与Canvas API在Web上渲染互动图形相比，SVG的一个优势是，SVG图形的每个元素都由Web页面上的DOM元素表示，这意味着你可以使用CSS对其进行样式设置，并使用JavaScript添加事件处理程序来响应鼠标事件，如点击或悬停。另一方面，基于Canvas的图形渲染速度更快，因此需要高帧率的应用程序，如游戏，通常会使用Canvas
    API而非SVG。
- en: Let’s write our first SVG. Make a new directory called *svg* and create an *index.html*
    file in that directory containing the content of [Listing 14-1](#Lis14-1). We’ll
    embed our SVG in this HTML file. Also create two empty files in the same directory,
    called *style.css* and *script.js*—we’ll fill those in later when we’re ready
    to style the SVG and make it interactive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个SVG。创建一个名为*svg*的新目录，并在该目录中创建一个包含[列表14-1](#Lis14-1)内容的*index.html*文件。我们将在这个HTML文件中嵌入我们的SVG。同时，在相同目录下创建两个空文件，分别命名为*style.css*和*script.js*——我们稍后会在准备好为SVG添加样式并使其具互动性时填充这些文件。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring SVG</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表14-1：用于探索SVG的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: The code in [Listing 14-1](#Lis14-1) follows our standard HTML template, with
    an empty svg element added ❶. The svg element is given a width and height of 600
    pixels. When you load the page in your browser, it should be blank, because we
    haven’t added content to our SVG yet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-1](#Lis14-1)中的代码遵循我们的标准HTML模板，并添加了一个空的svg元素❶。该svg元素的宽度和高度被设置为600像素。当你在浏览器中加载该页面时，它应该是空白的，因为我们还没有在SVG中添加内容。'
- en: Now let’s add some graphics. We’ll add a rectangle and some text to the svg
    element, as shown in [Listing 14-2](#Lis14-2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些图形。我们将在svg元素中添加一个矩形和一些文本，如[列表14-2](#Lis14-2)所示。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Adding graphics
    to the svg</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">element</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表14-2：将图形添加到svg</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">元素</samp>
- en: Everything inside the <svg> and </svg> tags is SVG XML, which has its own set
    of tag names. In this example, we use the rect ❶ and text ❷ elements. The rect
    element draws a rectangle, according to the specifications set through the element’s
    attributes. We set the width and height to 95 pixels and 20 pixels, respectively,
    and its x- and y-coordinates (the location of the top-left corner of the rectangle)
    to (5, 5). We set the outline to red using the stroke attribute and give it no
    fill color (the default fill color is black). The rect element doesn’t contain
    any content, so the opening tag is immediately followed by the closing tag.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位于<svg>和</svg>标签之间的内容都是SVG XML，它有自己的一套标签名称。在这个示例中，我们使用了rect❶和text❷元素。rect元素根据通过元素属性设置的规范绘制矩形。我们将宽度和高度分别设置为95像素和20像素，并将其x和y坐标（矩形左上角的位置）设置为(5,
    5)。我们使用stroke属性将轮廓设置为红色，并将填充颜色设置为无（默认填充颜色为黑色）。rect元素不包含任何内容，因此起始标签后立即跟随结束标签。
- en: Similarly, we use the text element to insert text into the drawing. The text
    element also uses x and y attributes to set its position, but in this case they
    refer to the start of the *baseline* of the text. In typography, the baseline
    is the invisible line that runs along the bottom of most letters, excluding those
    with descenders like *p* or *g*. By default, the x attribute gives the horizontal
    position of the start of the text. We set the font of the text to the default
    sans-serif font using the font-family attribute. The content of the text element
    is the actual text that will be drawn, in this case “Hello, SVG!”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们使用文本元素将文本插入到图形中。文本元素也使用x和y属性来设置其位置，但在这种情况下，它们指的是文本的*基线*起始位置。在排版中，基线是沿大多数字母底部延伸的隐形线，排除像*p*或*g*这类有下行部分的字母。默认情况下，x属性给出文本起始位置的水平坐标。我们使用font-family属性将文本的字体设置为默认的无衬线字体。文本元素的内容是实际会被绘制的文本，在此案例中为“Hello,
    SVG!”。
- en: When you reload the page, you should see this text surrounded by a red-outlined
    rectangle, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面后，你应该看到这段文本被一个红色边框的矩形包围，如 [图 14-1](chapter14.xhtml#fig14-1) 所示。
- en: '![](../images/Figure_14-1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Our first SVG
    drawing</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-1: 我们的第一个 SVG 绘图</samp>'
- en: Try zooming in on the page (using CTRL-+ on Windows or Linux, or COMMAND-+ on
    macOS). The rectangle and text should remain sharp, even as you scale the image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试放大页面（在 Windows 或 Linux 上使用 CTRL-+，在 macOS 上使用 COMMAND-+）。即使你缩放图像，矩形和文本应该依然清晰。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grouping Elements</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分组元素</samp>
- en: You can group multiple SVG elements together by nesting them inside a g (for
    *group*) element. This is useful because any attributes set on the g element itself
    will apply to all its child elements. To demonstrate, update the contents of your
    svg element as shown in [Listing 14-3](#Lis14-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将多个 SVG 元素嵌套在 g（代表*组*）元素内，将它们组合在一起。这很有用，因为在 g 元素本身设置的任何属性都会应用到所有子元素上。为了演示，更新你的
    svg 元素内容，如 [清单 14-3](#Lis14-3) 所示。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Grouping elements
    with the g element</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-3: 使用 g 元素分组元素</samp>'
- en: In this example, we create a group with three child text elements, each containing
    a single word. The text elements have the same x-coordinate but different y-coordinates,
    so the words will be vertically stacked and left-aligned. The attributes of the
    parent g element (font-family and fill ❶) apply to all the child elements in the
    group. Reload the page and you should see that all three words are blue and in
    a sans-serif font.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含三个子文本元素的组，每个子元素包含一个单独的单词。文本元素的 x 坐标相同，但 y 坐标不同，因此这些单词会垂直堆叠并左对齐。父级
    g 元素的属性（字体和填充 ❶）会应用于组中的所有子元素。重新加载页面，你应该看到所有三个单词都变成蓝色并且使用无衬线字体。
- en: 'Creating groupings with g elements also lets you apply *transformations* to
    all the child elements in a group. SVG supports several kinds of transformations,
    including translation, rotation, scaling, and skewing. We’ll use translate to
    move all the elements by a fixed amount. Update *index.html* with the following
    change to the opening g element tag:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 g 元素创建分组还可以让你对组内的所有子元素应用*变换*。SVG 支持几种变换，包括平移、旋转、缩放和倾斜。我们将使用平移（translate）来将所有元素按固定的距离移动。通过以下更改更新
    *index.html* 中的开头 g 元素标签：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The transform attribute takes a list of transformations, separated by spaces.
    Here we’re passing a single transformation: translate(100, 50). This says to move
    all the elements in the group 100 pixels along the x-axis and 50 pixels down the
    y-axis.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: transform 属性接受一个由空格分隔的变换列表。在这里，我们传递了一个变换：translate(100, 50)。这表示将组内的所有元素沿 x 轴移动
    100 像素，并沿 y 轴向下移动 50 像素。
- en: 'We can also resize the group by adding a scale transformation after the translate
    transformation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在平移变换后添加缩放变换来调整分组的大小：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the translation, the elements are now scaled horizontally by a factor
    of 2 and vertically by a factor of 3, as shown in [Figure 14-2](chapter14.xhtml#fig14-2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在平移之后，元素将水平缩放 2 倍，垂直缩放 3 倍，如 [图 14-2](chapter14.xhtml#fig14-2) 所示。
- en: '![](../images/Figure_14-2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Transforming grouped
    elements</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-2: 变换后的分组元素</samp>'
- en: All the transformations are relative to the origin (0, 0), unless an earlier
    translation has moved the origin. This means the scaling affects the placement
    of elements, as well as their size. For example, when you scale a square with
    a top-left corner of (10, 10) and a bottom-right corner of (30, 30) by 2, the
    new corners will be at (20, 20) and (60, 60). The x- and y-coordinates relative
    to the origin are all doubled.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的变换都是相对于原点 (0, 0) 的，除非之前的平移操作已经移动了原点。这意味着缩放不仅影响元素的大小，还会影响元素的位置。例如，当你将一个左上角为
    (10, 10)，右下角为 (30, 30) 的正方形缩放 2 倍时，新的角落坐标将是 (20, 20) 和 (60, 60)。相对于原点的 x 和 y 坐标都会被放大两倍。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Circles</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">绘制圆形</samp>
- en: You can draw an SVG circle using the circle element. The attributes cx and cy
    set the coordinates for the center of the circle, and r sets the radius. To try
    it out, replace the content of the svg element with the code in [Listing 14-4](#Lis14-4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 circle 元素绘制一个 SVG 圆形。属性 cx 和 cy 设置圆形中心的坐标，r 设置半径。为了尝试，替换 svg 元素的内容为[列表
    14-4](#Lis14-4)中的代码。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Drawing circles</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-4：绘制圆形</samp>
- en: 'In this example we’re using the new circle element, as well as the g and rect
    elements. The first circle ❶ has a fill color of #faa0a0, or salmon pink, a radius
    of 100 pixels, and center coordinates (124, 130). Note that we’re using *hex colors*
    here—see the “Hex Colors” box on the following page to learn more. Next, we use
    a group ❷ to apply a standard stroke color (chestnut brown) and width (3 pixels)
    to a rectangle and three smaller circles, with fill colors green, yellow, and
    rose. The effect of all this is a cute illustration of some Japanese *hanami dango*
    (a sweet treat popular in Japan during cherry blossom season), as shown in [Figure
    14-3](chapter14.xhtml#fig14-3).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们使用了新的圆形元素，以及g和rect元素。第一个圆圈 ❶ 的填充颜色是 #faa0a0，即鲑鱼粉色，半径为100像素，中心坐标为（124，130）。请注意，我们在这里使用的是*十六进制颜色*——请查看下一页的“十六进制颜色”框以了解更多。接下来，我们使用一个组
    ❷ 为矩形和三个较小的圆圈应用标准的描边颜色（栗色）和宽度（3像素），填充颜色分别为绿色、黄色和玫瑰色。所有这些效果形成了一个可爱的插图，展示了日本的*花见团子*（在樱花季节非常流行的一种甜点），如[图
    14-3](chapter14.xhtml#fig14-3)所示。'
- en: '![](../images/Figure_14-3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: An illustration
    of hanami dango using SVG circles</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-3：使用 SVG 圆形绘制花见团子的插图</samp>
- en: Notice that the order in which elements are declared defines the order in which
    they’re drawn. The three small circles are declared from bottom to top, so in
    places where they overlap, the upper circle appears on top. Likewise, since the
    large circle is declared first, it’s treated as a background for the rest of the
    illustration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元素声明的顺序决定了它们绘制的顺序。这三个小圆圈是从下到上声明的，所以在重叠的地方，上面的圆圈会覆盖在下面的圆圈上。同样，由于大圆圈首先声明，它被视为其余插图的背景。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Paths</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义路径</samp>
- en: The path element is the most powerful SVG element of all, allowing you to create
    custom shapes by drawing straight or curved lines (“paths”) between different
    points. The d attribute of a path element (short for *data*) is a string containing
    the path definition, which is a list of path commands. The syntax of this string
    is optimized to be as compact as possible, so complex paths can be represented
    using relatively short strings. This is good for computers, but not good for humans;
    don’t expect these strings to be easily readable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: path 元素是所有 SVG 元素中最强大的，它允许你通过在不同的点之间绘制直线或曲线（“路径”）来创建自定义形状。path 元素的 d 属性（*数据*的缩写）是一个包含路径定义的字符串，路径定义是路径命令的列表。这个字符串的语法被优化为尽可能紧凑，因此复杂的路径可以用相对较短的字符串表示。这对计算机来说很好，但对人类来说不好；不要指望这些字符串容易阅读。
- en: In the next example we’re going to re-create the HTML5 logo with path elements,
    starting with the outer shield shape. Replace the content of the svg element in
    *index.html* with the code in [Listing 14-5](#Lis14-5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将使用 path 元素重新创建 HTML5 标志，从外部盾牌形状开始。将 *index.html* 中 svg 元素的内容替换为[列表
    14-5](#Lis14-5)中的代码。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: Drawing the HTML5
    logo shield</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-5：绘制 HTML5 标志盾牌</samp>
- en: Before we dive deep into the path definition, it’ll help to know what the result
    is supposed to look like. Reload the page, and you should see the shield design
    shown in [Figure 14-4](chapter14.xhtml#fig14-4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究路径定义之前，先了解一下结果应该是什么样子会有所帮助。重新加载页面，你应该能看到[图 14-4](chapter14.xhtml#fig14-4)所示的盾牌设计。
- en: '![](../images/Figure_14-4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The HTML5 logo
    shield</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-4：HTML5 标志盾牌</samp>
- en: 'This design is made of two paths, one for the darker main shield shape, and
    one for the lighter highlight on the right half of the shield shape. Let’s look
    at the path definition for the darker part:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计由两个路径组成，一个用于较深的主盾牌形状，另一个用于盾牌形状右半部分的亮部。让我们来看一下较暗部分的路径定义：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are six instructions here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有六个指令：
- en: M 0 0
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M 0 0
- en: H 182
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H 182
- en: L 165 185
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L 165 185
- en: L 90 206
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L 90 206
- en: L 17 185
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L 17 185
- en: Z
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z
- en: Think of these commands as moving an imaginary pen around the screen to draw
    lines. The M command takes a position as an (x, y) coordinate pair and moves the
    pen to that position without drawing anything. The H command takes an x-coordinate
    and draws a horizontal line from the current pen position to that value of x.
    The L command takes an (x, y) coordinate pair and draws a line from the current
    position to that position. Finally, the Z command closes the path, drawing a line
    from the current position back to the start of the path. In English, the commands
    in the path say, “Move to (0, 0), draw a horizontal line to (182, 0), draw a line
    to (165, 185), draw a line to (90, 206), draw a line to (17, 185), then draw a
    line back to (0, 0) to close the path.” The second path uses the same technique
    to draw the inner highlight on the shield, using a different fill color.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把这些命令看作是让一个虚拟的笔在屏幕上移动以绘制线条。M 命令接受一个位置作为 (x, y) 坐标对，并将笔移动到该位置，而不绘制任何内容。H 命令接受一个
    x 坐标，并从当前笔的位置绘制一条水平线到该 x 值。L 命令接受一个 (x, y) 坐标对，并从当前位置绘制一条线到那个位置。最后，Z 命令闭合路径，从当前的位置画一条线回到路径的起点。用英语来描述，路径中的命令是，“移动到
    (0, 0)，绘制一条水平线到 (182, 0)，绘制一条线到 (165, 185)，绘制一条线到 (90, 206)，绘制一条线到 (17, 185)，然后绘制一条线回到
    (0, 0) 来闭合路径。”第二条路径使用相同的技巧来绘制盾牌上的内侧高光，使用了不同的填充颜色。
- en: 'These commands define the points to move to using *absolute positions*, exact
    x- and y-coordinates. However, there’s an alternative version of each command
    that takes a relative position instead, meaning the next point is defined in relation
    to the current position of the pen. The absolute commands all use uppercase letters,
    and the relative ones use the same letters but lowercase. For example, the path
    definition we just looked at could be rewritten using relative path commands like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令使用 *绝对位置* 来定义要移动到的点，精确的 x 和 y 坐标。然而，每个命令都有一个替代版本，使用相对位置，这意味着下一个点是相对于当前笔的位置来定义的。绝对命令都使用大写字母，而相对命令则使用相同的字母，但小写。例如，我们刚才看到的路径定义可以用相对路径命令重写，像这样：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the move command is the same because there’s no previous position
    to be relative to. The command h 182 says to draw a horizontal line 182 units
    to the right of the current position. The command l -17 185 says to draw a line
    17 units to the left and 185 down from the current position, and so on. The Z
    and z commands do the same thing and are just included in the SVG spec for completeness.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，移动命令是相同的，因为没有之前的位置可以作为参考。命令 h 182 表示从当前的位置向右绘制 182 单位的水平线。命令 l -17 185
    表示从当前位置向左绘制 17 单位并向下 185 单位，依此类推。Z 和 z 命令做的是同样的事情，它们仅仅为了完整性而出现在 SVG 规范中。
- en: 'In fact, this relative path definition can be written even more compactly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个相对路径定义可以写得更紧凑：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spaces are needed only to avoid ambiguity between two numbers, but are otherwise
    optional in SVG paths. Thanks to all the negative numbers, we’re able to remove
    almost all the spaces here. Also, if the same command is used multiple times in
    a row, you can include it once and then just keep providing numbers. For example,
    l-17 185-75 21-73-21 is the compact version of l -17 185 l -75 21 l -73 -21.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 空格仅在避免两个数字之间的歧义时才需要，但在 SVG 路径中是可选的。由于有负数的存在，我们能够去除几乎所有的空格。此外，如果相同的命令连续多次使用，可以只写一次命令，然后继续提供数字。例如，l-17
    185-75 21-73-21 是 l -17 185 l -75 21 l -73 -21 的简写版本。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The SvgPathEditor (*[https://yqnn.github.io/svg-path-editor/](https://yqnn.github.io/svg-path-editor/)*)*
    *is a very helpful tool for experimenting with and manipulating paths, and for
    converting between absolute and relative commands (it’s what I used here to convert
    between the two forms). SVG has several additional path commands, mostly for drawing
    various types of curves. We won’t go into those here, but you can find a full
    list on MDN at* [https://developer.mozilla.org/SVG](https://developer.mozilla.org/SVG).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*SvgPathEditor (*[https://yqnn.github.io/svg-path-editor/](https://yqnn.github.io/svg-path-editor/)*)*
    *是一个非常有用的工具，用于实验和操作路径，并进行绝对和相对命令之间的转换（这也是我在这里用来转换这两种形式的工具）。SVG 有几个额外的路径命令，主要用于绘制各种类型的曲线。我们在这里不深入讨论这些内容，但你可以在
    MDN 上找到完整的列表，网址是* [https://developer.mozilla.org/SVG](https://developer.mozilla.org/SVG)。'
- en: Now that you understand how path definitions work, we can add more paths to
    fill in the rest of the HTML5 logo. Update the content of the svg element as shown
    in [Listing 14-6](#Lis14-6) (though I won’t think any less of you if you decide
    this is too much typing!).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了路径定义的工作原理，我们可以添加更多路径来填充完整的 HTML5 标志。按照[清单 14-6](#Lis14-6)中的内容更新 svg
    元素的内容（尽管如果你决定这太多打字了，我也不会因此看低你！）。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Completing the
    HTML5 logo</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-6：完成 HTML5 标志</samp>
- en: 'I used relative path commands here partly for variety, and partly because the
    relative numbers were smaller and made for shorter lines. When you reload the
    page, you should see the complete HTML5 logo, as shown in [Figure 14-5](chapter14.xhtml#fig14-5).
    The two paths with the fill color #ebebeb (light gray) draw the two parts of the
    left side of the 5, and the two paths with the fill color #fff (white) draw the
    two parts of the right side of the 5.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '我在这里使用了相对路径命令，部分是为了变化，部分是因为相对路径的数字更小，形成了更短的代码行。重新加载页面时，你应该能看到完整的 HTML5 标志，如[图
    14-5](chapter14.xhtml#fig14-5)所示。两个填充颜色为 #ebebeb（浅灰色）的路径绘制了数字 5 左侧的两部分，而两个填充颜色为
    #fff（白色）的路径绘制了数字 5 右侧的两部分。'
- en: '![](../images/Figure_14-5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: The complete HTML5
    logo</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-5：完整的 HTML5 标志</samp>
- en: In general, you won’t have to manually type out your own path definitions when
    you’re creating data visualizations. D3 will create them for you. Still, it’s
    helpful to understand the syntax so you can tell what’s going on when you’re debugging.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你创建数据可视化时，不需要手动输入路径定义。D3 会为你生成它们。不过，理解语法仍然有帮助，这样在调试时你能知道发生了什么。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling Elements
    with CSS</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 CSS 样式化元素</samp>
- en: When you embed SVG in your HTML file, each SVG element becomes part of the DOM,
    so it can be styled with CSS. To see how this works, we’ll draw some SVG shapes
    and give them all class names. Replace the content of the svg element with the
    code in [Listing 14-7](#Lis14-7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 SVG 嵌入到 HTML 文件中时，每个 SVG 元素都会成为 DOM 的一部分，因此可以使用 CSS 进行样式化。为了演示这个原理，我们将绘制一些
    SVG 形状并为它们都指定类名。将 svg 元素的内容替换为[清单 14-7](#Lis14-7)中的代码。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Some SVG elements
    with class names</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-7：带类名的一些 SVG 元素</samp>
- en: Here we’re drawing a circle, a square, and a triangle, and then another circle,
    square, and triangle. Notice that the triangles are drawn as paths—there’s no
    dedicated triangle element like rect or circle. The first three shapes have the
    class name boring, and the second three have the class name fun. When you reload
    the page you should see two rows of three shapes, all with the same default black
    fill, as shown in [Figure 14-6](chapter14.xhtml#fig14-6).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们绘制了一个圆形、一个方形和一个三角形，然后又绘制了一个圆形、方形和三角形。注意，三角形是通过路径绘制的——并没有像 rect 或 circle
    那样专门的三角形元素。前三个形状的类名为 boring，后面三个的类名为 fun。重新加载页面时，你应该能看到两行三种形状，所有形状都有相同的默认黑色填充，如[图
    14-6](chapter14.xhtml#fig14-6)所示。
- en: '![](../images/Figure_14-6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: SVG shapes, without
    style</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-6：未样式化的 SVG 形状</samp>
- en: Now we’ll style the shapes. Because they all have class names, we can select
    them in CSS, just like we’d select HTML elements. Add the code in [Listing 14-8](#Lis14-8)
    to your *style.css* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为形状添加样式。因为它们都有类名，所以我们可以像选择 HTML 元素一样在 CSS 中选择它们。将[清单 14-8](#Lis14-8)中的代码添加到你的*style.css*文件中。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Styles for the
    shapes</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-8：形状的样式</samp>
- en: 'In this listing, we’re giving different styles to the two classes: .boring
    gets a simple black outline, and .fun gets a pink fill and a thick dashed green-yellow
    outline. Note that the property names for styling SVG elements aren’t the same
    as for HTML elements. For example, HTML elements use background-color and border-color,
    while SVG elements use fill and stroke.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，我们为两个类指定了不同的样式：.boring 获得一个简单的黑色轮廓，.fun 获得粉色填充和一条粗的绿色-黄色虚线轮廓。请注意，样式化
    SVG 元素的属性名称与 HTML 元素不同。例如，HTML 元素使用 background-color 和 border-color，而 SVG 元素使用
    fill 和 stroke。
- en: 'It’s worth noting that you could also apply these styles directly to the SVG
    elements as attributes in the *index.html* file. The advantage of using CSS is
    twofold: first, it means that all your styling information is in one place, so
    it’s easily updatable, and second, to style several elements the same way you
    only need to add a class name to each element, as opposed to copying all the attributes
    from one element to another.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你也可以直接将这些样式作为属性应用到 *index.html* 文件中的 SVG 元素。使用 CSS 的优势有两个：首先，它意味着所有的样式信息都集中在一个地方，便于更新；其次，要以相同的方式样式化多个元素，你只需为每个元素添加一个类名，而不必将所有属性从一个元素复制到另一个元素。
- en: When you reload the page, you should notice that your shapes now have some style,
    as shown in [Figure 14-7](chapter14.xhtml#fig14-7).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面后，你应该注意到你的形状现在有了一些样式，如[图 14-7](chapter14.xhtml#fig14-7)所示。
- en: '![](../images/Figure_14-7.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: SVG shapes, with
    style</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-7：带样式的 SVG 形状</samp>
- en: It’s also possible to use pseudo-classes like :hover on SVG elements. Add the
    code in [Listing 14-9](#Lis14-9) to the end of *style.css* to try this out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在 SVG 元素上使用伪类，如 :hover。将[清单 14-9](#Lis14-9)中的代码添加到 *style.css* 文件的末尾以尝试此功能。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Adding a hover
    effect</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-9：添加悬停效果</samp>
- en: Here we’re swapping the fill and stroke color when the mouse hovers over one
    of the .fun elements. Reload the page and see for yourself!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当鼠标悬停在 .fun 元素上时，我们交换了填充和描边的颜色。重新加载页面，亲自查看吧！
- en: 'This is one of the great advantages of SVG over the Canvas API: the browser
    knows about the SVG elements, and it knows, for example, when the mouse is hovering
    over them. Compare this with the canvas, where the browser just knows that some
    colored pixels have been drawn, and any mouse hover effects have to be explicitly
    coded in JavaScript.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SVG 相对于 Canvas API 的一个重大优势：浏览器了解 SVG 元素，知道例如鼠标何时悬停在它们上面。与此相比，Canvas 中浏览器只知道某些颜色的像素已经被绘制出来，任何鼠标悬停效果都必须在
    JavaScript 中显式编码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Interactivity
    with JavaScript</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 JavaScript 添加交互性</samp>
- en: We can use JavaScript to add interactivity to our SVG elements, just as we can
    use CSS to style them. Again, this is possible because each SVG element embedded
    in the HTML becomes part of the DOM. To start with, we’ll just write a script
    that selects the elements and logs them to the console, as a refresher on JavaScript
    DOM methods. Add the code in [Listing 14-10](#Lis14-10) to the currently empty
    *script.js*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 为 SVG 元素添加交互性，就像使用 CSS 为它们设置样式一样。之所以可以实现这一点，是因为嵌入在 HTML 中的每个
    SVG 元素都会成为 DOM 的一部分。首先，我们将编写一个脚本来选择这些元素，并将它们打印到控制台，以便复习 JavaScript DOM 方法。将[清单
    14-10](#Lis14-10)中的代码添加到当前空白的 *script.js* 文件中。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Selecting the
    .fun elements</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-10：选择 .fun 元素</samp>
- en: In this listing, we’re using the querySelectorAll method to select all the elements
    with the class name fun. We then use the forEach method to iterate over the selected
    elements and log them to the console. When you run this code, you should see the
    three elements logged to the console on separate lines. If you hover over each
    element in the console, that element should also be highlighted on the web page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，我们使用 querySelectorAll 方法来选择所有具有类名 fun 的元素。然后我们使用 forEach 方法遍历这些选中的元素并将它们打印到控制台。运行此代码时，你应该会看到三个元素在控制台中分别打印出来。如果你将鼠标悬停在控制台中的每个元素上，该元素也会在网页上高亮显示。
- en: Now we can add some interactivity. The changes to *script.js* in [Listing 14-11](#Lis14-11)
    will make it so when you click one of the elements, that element will move to
    the right, and when you hold down SHIFT and click, the element will move to the
    left.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一些交互功能。[清单 14-11](#Lis14-11)中的 *script.js* 代码修改后，当你点击某个元素时，该元素将向右移动；而当你按住
    SHIFT 键并点击时，该元素将向左移动。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Moving SVG elements
    on click</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-11：点击时移动 SVG 元素</samp>
- en: Inside the forEach method call, we’re doing two things to each element. First,
    we set something called a *data attribute* on each element. Data attributes are
    HTML or SVG attributes that are just used for storing data in the DOM; their names
    all start with the string "data-". Specifically, we create the data-offset data
    attribute, which we’ll use to keep track of how to position each element, and
    set its value to 0 ❶. Note that DOM attributes are always stored as strings, so
    the number 0 will be converted to the string "0".
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在forEach方法调用内部，我们对每个元素做了两件事。首先，我们在每个元素上设置一个叫做*数据属性*的东西。数据属性是用于在DOM中存储数据的HTML或SVG属性，它们的名称都以"data-"字符串开头。具体来说，我们创建了data-offset数据属性，利用它来跟踪如何定位每个元素，并将其值设置为0
    ❶。请注意，DOM属性始终以字符串形式存储，因此数字0将被转换为字符串"0"。
- en: Next, we attach a click event handler to each element ❷. The first thing the
    handler does is extract the data-offset attribute from the clicked element, using
    getAttribute, and store its value in the variable offset ❸. The clicked element
    is available as the target property on the event object. Note that we use the
    Number function here to convert the string into a number. The first time this
    handler is called, the variable offset will be set to 0, as that is the initial
    value we stored in the data-offset attribute ❶.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个元素附加一个点击事件处理器 ❷。处理器的第一件事是使用getAttribute提取被点击元素的data-offset属性，并将其值存储在变量offset中
    ❸。被点击的元素可以通过事件对象上的target属性访问。请注意，我们在这里使用Number函数将字符串转换为数字。该处理器第一次被调用时，变量offset将被设置为0，因为那是我们在data-offset属性中存储的初始值
    ❶。
- en: We use the shiftKey property on the event to determine if the SHIFT key was
    pressed when the mouse was clicked. If it was, we subtract 5 from offset. Otherwise,
    we add 5 to offset. We then assign the updated value to the data-offset attribute
    using setAttribute ❹. Finally, we use the setAttribute method again, but this
    time to set the transform SVG attribute ❺. As you saw earlier in this chapter,
    we can use transform to translate an element by some distance, with the string
    translate(x, y). Here we’re setting the x value of the translation to the value
    of offset and the y value of the translation to 0\. This means that if offset
    is a positive value the element will move to the right, and if it’s a negative
    value the element will move to the left.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用事件的shiftKey属性来判断鼠标点击时是否按下了SHIFT键。如果按下了，我们从offset中减去5。否则，我们将offset加上5。然后，我们使用setAttribute将更新后的值赋给data-offset属性
    ❹。最后，我们再次使用setAttribute方法，但这一次是设置transform SVG属性 ❺。正如你在本章前面看到的，我们可以使用transform通过某个距离平移元素，使用字符串translate(x,
    y)。在这里，我们将平移的x值设置为offset的值，平移的y值设置为0。这意味着如果offset是正值，元素将向右移动，如果它是负值，元素将向左移动。
- en: When you reload the page, the colorful SVG elements should now move when you
    click them. If you right-click one of the elements and select Inspect, you’ll
    see that element in the Elements panel. As you click different elements in the
    browser viewport, you should see the data-offset and transform attributes update
    in the Elements panel.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面时，彩色的SVG元素应该会在你点击它们时移动。如果你右键点击其中一个元素并选择“检查”，你将看到该元素出现在元素面板中。随着你在浏览器视口中点击不同的元素，你应该会看到元素面板中的data-offset和transform属性更新。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The D3 Library</samp>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">D3库</samp>
- en: Now that you have an understanding of the basics of SVG, you can start to learn
    about the D3 library, which leverages SVG and JavaScript to create data visualizations.
    *D3*, short for *Data-Driven Documents*, gives you the ability to create documents
    whose contents are driven by data. It does this through a technique called *data
    binding*, where individual parts of the underlying data you want to visualize
    are linked to individual elements on the page. This way, if the data changes,
    the elements change as well. You’ll see how that works later in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了SVG的基础知识，可以开始学习D3库，它结合了SVG和JavaScript来创建数据可视化。*D3*，即*数据驱动文档*，让你能够创建内容由数据驱动的文档。它通过一种叫做*数据绑定*的技术实现这一点，在这种技术中，想要可视化的底层数据的各个部分与页面上的各个元素进行链接。这样，如果数据发生变化，元素也会随之变化。你将在本节后面看到它是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setup</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置</samp>
- en: We’ll create a new set of files to explore D3\. Make a new directory called
    *data*, containing an empty *script.js* file and an *index.html* file with the
    content in [Listing 14-12](#Lis14-12).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一组新的文件来探索 D3。创建一个名为 *data* 的新目录，包含一个空的 *script.js* 文件和一个包含 [清单 14-12](#Lis14-12)
    内容的 *index.html* 文件。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: A new</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    working with D3</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-12：一个新的</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">用于与 D3 一起使用</samp>
- en: First we create an svg element ❶ and draw three circles. Then we use a script
    element to link to a copy of the D3 library hosted on [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com)
    ❷, much like we did with Tone.js for the music project. Now you’ll be able to
    use code from D3 in your *script.js* file. When you load the page, you should
    see three black circles. Soon we’ll manipulate those circles with D3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们创建一个 svg 元素❶并绘制三个圆形。然后我们使用一个脚本元素链接到托管在 [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com)
    ❷ 上的 D3 库副本，和我们在音乐项目中使用 Tone.js 的方式类似。现在你就可以在你的 *script.js* 文件中使用 D3 的代码了。当你加载页面时，应该会看到三个黑色圆形。很快我们将使用
    D3 来操作这些圆形。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selections</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择</samp>
- en: One of D3’s basic building blocks is the *selection*, a way to pick out a group
    of elements so you can apply certain operations to those elements. Let’s use D3
    to select the three SVG circles and change their fill color to hot pink. Add the
    code in [Listing 14-13](#Lis14-13) to *script.js*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的基本构建块之一是 *选择*，它是一种选择一组元素的方法，以便可以对这些元素应用某些操作。让我们使用 D3 选择三个 SVG 圆形并将它们的填充颜色更改为热粉色。将
    [清单 14-13](#Lis14-13) 中的代码添加到 *script.js*。
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Selecting the
    circles</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-13：选择圆形</samp>
- en: The d3.selectAll method takes a CSS selector, in this case the element name
    circle, and returns a D3 selection, on which you can chain more method calls.
    Those chained method calls will apply to all the elements matching the selector.
    Here we’re setting the "fill" attribute of every element in the selection to "hotpink".
    When you reload the page, you should see that the black circles are now pink.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: d3.selectAll 方法接受一个 CSS 选择器，这里是元素名称 circle，并返回一个 D3 选择，你可以在其上链式调用更多方法。那些链式调用将应用于所有符合选择器的元素。在这里，我们将选择中的每个元素的
    "fill" 属性设置为 "hotpink"。当你重新加载页面时，你应该会看到黑色圆形现在变成了粉色。
- en: It’s also possible to use a function instead of a value when updating elements
    in a selection. When you do this, the function is called and its return value
    is used as the value for updating these elements. This gives you the ability to
    modify elements dynamically. Update the *script.js* code with the changes in [Listing
    14-14](#Lis14-14) to see how it works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新选择中的元素时，也可以使用函数而不是值。当你这样做时，函数会被调用并返回一个值，这个返回值将作为更新这些元素的值。这使你能够动态地修改元素。更新
    *script.js* 中的代码，应用 [清单 14-14](#Lis14-14) 中的更改，以查看它是如何工作的。
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Computing values
    with functions</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-14：使用函数计算值</samp>
- en: With long method chains like this, it’s common to split the code across multiple
    lines for readability. As before, we’re selecting all the circles and setting
    their fill color to hot pink, but this time we’re also updating each circle’s
    radius ❶. The function used for generating the value here has two parameters,
    d and i. We’ll cover the d parameter, short for *datum*, in the next section.
    i, short for *index*, is the index of the element in the selection (the first
    circle will have an index of 0, the second 1, and so on). We’re using the code
    10 + i * 5 to give each circle a different radius, based on their index numbers.
    Specifically, the circles will have radii of 10, 15, and 20\. When you reload
    the page, you should see the three circles are now all different sizes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的长方法链，通常会将代码拆分成多行以提高可读性。如前所述，我们选择了所有圆形并将其填充颜色设置为热粉色，但这一次我们还更新了每个圆形的半径❶。这里用于生成值的函数有两个参数，d
    和 i。我们将在下一节中介绍 d 参数，它是 *datum*（数据项）的缩写。i，作为 *index*（索引）的缩写，是选择中元素的索引（第一个圆形的索引为
    0，第二个为 1，依此类推）。我们使用代码 10 + i * 5 来根据索引编号为每个圆形设置不同的半径。具体来说，这些圆形的半径将是 10、15 和 20。当你重新加载页面时，你应该会看到这三个圆形的大小现在都不同了。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*D3 selection modification methods like .attr return the selection itself.
    This lets us keep chaining modification methods, as we do with the two .attr calls
    in [Listing 14-14](#Lis14-14).*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*像 .attr 这样的 D3 选择修改方法返回的是选择本身。这让我们可以继续链接修改方法，正如我们在 [清单 14-14](#Lis14-14) 中通过两个
    .attr 调用所做的那样。*'
- en: If you want to select a single element rather than a group, use the d3.select
    method instead of d3.selectAll. For example, to insert an h1 element into the
    body element of your HTML, you could add the code in [Listing 14-15](#Lis14-15)
    to the end of your *script.js* file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想选择单个元素而不是一组元素，请使用 d3.select 方法，而不是 d3.selectAll。例如，要将 h1 元素插入到 HTML 的 body
    元素中，你可以将 [清单 14-15](#Lis14-15) 中的代码添加到 *script.js* 文件的末尾。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Using select
    to select a single element</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-15：使用 select 选择单个元素</samp>
- en: In this example, we first select the body element. We then call insert on this
    selection, passing two arguments, "h1" and "svg". The first argument is the type
    of element to insert, and the second is the element before which to insert it.
    The insert method returns a new selection containing the inserted element, and
    the text method adds text content to elements in that selection (in this case,
    the single h1 element). When you reload the page, you should see a heading above
    the SVG element with the text “Hello, D3!” This example also illustrates the fact
    that D3 selections can apply to both HTML and SVG elements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先选择 body 元素。然后我们在此选择上调用 insert，传入两个参数，"h1" 和 "svg"。第一个参数是要插入的元素类型，第二个是要插入该元素之前的元素。insert
    方法返回一个新的选择，包含插入的元素，text 方法则向该选择中的元素（在这个案例中是单个 h1 元素）添加文本内容。当你重新加载页面时，你应该会看到在 SVG
    元素上方有一个标题，文本为 “Hello, D3!” 这个示例还说明了 D3 选择可以同时应用于 HTML 和 SVG 元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Binding</samp>
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据绑定</samp>
- en: Perhaps the most important feature of D3 is its concept of data binding. In
    a D3-based application, you’ll have some data that you’re attempting to visualize.
    Each individual piece of the data, called a datum, will be bound to an individual
    element on the page (usually an SVG element). You use the datum to set some attribute
    of the element it’s bound to, so the element visually reflects the datum.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或许 D3 最重要的特性是它的数据绑定概念。在基于 D3 的应用程序中，你将有一些数据需要可视化。每个数据单元，称为 datum，将绑定到页面上的一个元素（通常是
    SVG 元素）。你使用 datum 来设置绑定元素的某个属性，从而使元素在视觉上反映出该 datum。
- en: To start with, we’ll look at how to bind data to preexisting SVG elements. Keep
    the circles in *index.html*, but replace the content of *script.js* with the code
    in [Listing 14-16](#Lis14-16).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看如何将数据绑定到现有的 SVG 元素。保留 *index.html* 中的圆圈，但将 *script.js* 的内容替换为 [清单 14-16](#Lis14-16)
    中的代码。
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Binding data
    to our circles</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-16：将数据绑定到我们的圆圈</samp>
- en: We first create an array of numbers to use as data. Then we create a selection
    of all the circle elements. The data method ❶ binds the array of numbers to the
    selection of circles, one by one, so the first circle element has the value 3
    bound to it, the second 2, and the third 1. Finally, we use the attr method to
    set the radius of each circle to a computed value based on the bound data. As
    you saw in the previous section, if you use a function instead of a value to set
    an attribute, that function will be called to compute the value for each element
    in the selection. The d parameter of the function corresponds to the datum bound
    to the current element.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个数字数组用作数据。然后我们创建一个所有圆圈元素的选择。data 方法 ❶ 将数字数组一个个绑定到圆圈选择上，因此第一个圆圈元素绑定了值
    3，第二个绑定了 2，第三个绑定了 1。最后，我们使用 attr 方法根据绑定的数据设置每个圆圈的半径为计算值。如你在前一节中所见，如果你使用函数而不是值来设置属性，该函数将被调用，以便为选择中的每个元素计算该值。函数的
    d 参数对应于绑定到当前元素的 datum。
- en: When you reload the page, you should see three black circles that get smaller
    from left to right. To confirm that everything is working as expected, right-click
    the first circle and select **Inspect** to show the element in the Elements panel.
    You should see its r attribute set to 15, which is what we’d expect from d * 5
    where d is 3.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面时，你应该看到三个从左到右逐渐变小的黑色圆圈。为了确认一切按预期工作，右键单击第一个圆圈并选择**检查**，以在元素面板中显示该元素。你应该看到它的
    r 属性设置为 15，这正是我们从 d * 5 中期望的值，其中 d 为 3。
- en: It’s also possible to directly see the datum set on an element using the Inspect
    tool, which can be very helpful for debugging, especially when your data is more
    complex than simple numbers. All you need is a reference to the element, which
    is easy to get through the Chrome console. Again, right-click the first circle
    and select **Inspect**. You should see something like [Figure 14-8](chapter14.xhtml#fig14-8).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用检查工具直接查看元素上设置的数据，这对于调试非常有帮助，尤其是在你的数据比简单的数字更复杂时。你所需要的只是对该元素的引用，这可以通过Chrome控制台轻松获取。再次右键点击第一个圆形并选择**Inspect**。你应该能看到类似于[Figure
    14-8](chapter14.xhtml#fig14-8)的内容。
- en: '![](../images/Figure_14-8.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: Selecting a circle
    element in the Elements panel</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: 在元素面板中选择圆形元素</samp>'
- en: 'At the end of the selected line you should see the text == $0. This is an indication
    that a reference to the circle element is stored under the global variable named
    $0. To verify that this is the case, open the JavaScript console and enter $0:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在选中行的末尾，你应该看到文本== $0。这表明一个对圆形元素的引用存储在名为$0的全局变量下。为了验证这一点，打开JavaScript控制台并输入$0：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The console prints the circle element you selected, indicating that $0 is indeed
    a reference to that element. Now that you have that reference, you can see the
    datum bound to it using the __data__ property:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台打印了你选中的圆形元素，表明$0确实是该元素的引用。现在，你已经得到了这个引用，可以通过__data__属性查看绑定到它的数据：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells you the circle is bound to the value 3, the first number from our
    array, just as we’d expect. $0 always references the currently selected element,
    so if you right-click and inspect a different circle, entering $0.__data__ in
    the console again will give you the datum bound to that other circle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你，圆形绑定到了值3，这是我们数组中的第一个数字，正如我们预期的那样。$0始终引用当前选中的元素，因此如果你右键点击并检查另一个圆形，再次在控制台输入$0.__data__将会给出绑定到那个圆形的数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Joins</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据连接</samp>
- en: You don’t always know exactly how long your data is going to be, so it would
    be difficult to always have exactly the right number of SVG elements ready to
    bind to your data. D3 solves this problem with the concept of *joins*. In D3,
    you use a join to add or remove the necessary elements to match the data being
    bound.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是能准确知道数据的长度，因此始终准备好恰当数量的SVG元素来绑定到你的数据上是困难的。D3通过*join*的概念解决了这个问题。在D3中，你使用join来添加或移除必要的元素，以匹配绑定的数据。
- en: We can extend our example from [Listing 14-16](#Lis14-16) with a join so that
    SVG circle elements will be added or removed as needed, depending on the length
    of the numbers array. Update the *script.js* file as shown in [Listing 14-17](#Lis14-17).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在[Listing 14-16](#Lis14-16)的基础上添加一个join来扩展我们的示例，以便根据数字数组的长度，动态地添加或移除SVG圆形元素。请按照[Listing
    14-17](#Lis14-17)中的示例更新*script.js*文件。
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: Joining in extra
    elements</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: 加入额外的元素</samp>'
- en: Here we’ve create a longer array of numbers ❶. We’ve also added a line to select
    the svg element ❷ before selecting the circle elements within it. This is necessary
    because D3 will need to add new circle elements, and it needs to know which containing
    element to add them to. Finally, we’ve added a call to the join method ❸. This
    method takes the name of the element from the selection to add or remove to match
    the data. In this case, we’re saying that if there aren’t enough circle elements
    in the svg element for all the items in data, then D3 should add more (or conversely,
    if there are too many, D3 should remove some).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个更长的数字数组❶。我们还添加了一行代码来选择svg元素❷，然后再选择其中的圆形元素。这是必要的，因为D3需要添加新的圆形元素，它需要知道将它们添加到哪个包含元素中。最后，我们调用了join方法❸。这个方法接受从选择中添加或移除元素的名称，以匹配数据。在这种情况下，我们是在说，如果svg元素中没有足够的圆形元素来匹配数据中的所有项，那么D3应该添加更多的元素（或者如果元素太多，D3应该移除一些）。
- en: If you reload the page, you’ll see this doesn’t quite work as you probably expected.
    The new circles all end up in the top-left corner of the drawing area. That’s
    because these new circles don’t have their cx or cy attributes set, unlike the
    initial three circles that were defined in *index.html*. To fix this, we need
    to set these two attributes using D3, as shown in [Listing 14-18](#Lis14-18).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载页面，你会发现结果可能没有你预期的那样。所有新生成的圆形元素都出现在绘图区的左上角。这是因为这些新圆形元素没有设置 `cx` 或 `cy`
    属性，而最初在 *index.html* 中定义的三个圆形元素则有这些属性。为了解决这个问题，我们需要使用 D3 设置这两个属性，具体代码见 [Listing
    14-18](#Lis14-18)。
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Setting the
    cx and cy attributes</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: 设置 cx 和 cy 属性</samp>'
- en: The cx attribute is based on the index of the data. The first element should
    be at 50, the second at 100, and so on. The calculation (i + 1) * 50 gives us
    the right values. Because the circles are all in a line, the cy attribute is just
    a constant value. Now when you reload the page you should see five circles in
    a line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx` 属性是基于数据的索引计算的。第一个元素应位于 50，第二个元素应位于 100，以此类推。计算公式 `(i + 1) * 50` 给出了正确的值。由于所有圆形在一条直线上，`cy`
    属性只是一个常量值。现在当你重新加载页面时，你应该能看到五个圆形排成一行。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*As mentioned previously, you can use the same join technique to remove elements
    when you have too many. If you change the array of numbers to contain only two
    elements and reload the page, you’ll see only two circles.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*如前所述，当元素过多时，你可以使用相同的 `join` 技术来移除它们。如果你将数字数组更改为仅包含两个元素并重新加载页面，你会看到只有两个圆形。*'
- en: Now that we’re using D3’s join method to create new SVG elements as needed to
    suit the data, there’s no reason to create them in the HTML file. Modify *index.html*
    as shown in [Listing 14-19](#Lis14-19), removing all the circle elements, then
    reload the page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们使用 D3 的 `join` 方法根据数据需要动态创建 SVG 元素，就没有必要在 HTML 文件中创建它们了。请按 [Listing 14-19](#Lis14-19)
    所示修改 *index.html*，删除所有圆形元素，然后重新加载页面。
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: Removing the
    circle elements</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: 移除圆形元素</samp>'
- en: Everything should still work, because the join method adds in all the circle
    elements it needs. Note that the .selectAll("circle") line is still needed in
    *script.js* for the join to work correctly, even though the first time this is
    called there will be no circles to select.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一切仍然应该正常工作，因为 `join` 方法会添加所需的所有圆形元素。请注意，`script.js` 中的 `.selectAll("circle")`
    这一行仍然是必须的，尽管第一次调用时没有圆形元素可供选择，`join` 才能正确工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Real-Time Updates</samp>
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实时更新</samp>
- en: If the underlying data changes, we’ll need to perform the join again to update
    the visualization. To do this, we’ll move all the data binding and joining code
    into its own function, which we can call as needed. We can test this out by adding
    some buttons to the page that allow us to add random values to the start or end
    of our numbers array, or drop numbers from the array. Update *index.html* with
    the changes shown in [Listing 14-20](#Lis14-20).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基础数据发生变化，我们需要再次执行 `join` 来更新可视化效果。为此，我们将所有的数据绑定和 `join` 代码移到一个独立的函数中，这样就可以根据需要调用。我们可以通过向页面添加一些按钮来测试这个功能，这些按钮允许我们向数字数组的开头或末尾添加随机值，或从数组中删除数字。请按
    [Listing 14-20](#Lis14-20) 所示更新 *index.html*。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: Adding buttons
    to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: 向</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> 添加按钮'
- en: Reload the page and you should see the three new buttons at the top. Next, we’ll
    move the code that updates the visualization into its own function. Replace the
    code in *script.js* with the content of [Listing 14-21](#Lis14-21).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面后，你应该能看到页面顶部的三个新按钮。接下来，我们将把更新可视化效果的代码移到一个独立的函数中。请用 [Listing 14-21](#Lis14-21)
    中的内容替换 *script.js* 中的代码。
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Moving the update
    code into its own function</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: 将更新代码移入独立函数</samp>'
- en: There’s no functional change here—we’re just creating an update function to
    do the SVG updating for us ❶, and then calling it ❸. Notice that we’re passing
    data, the function’s parameter, to the .data method ❷, rather than passing the
    numbers array directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有功能上的变化——我们只是创建了一个更新函数来为我们执行SVG更新❶，然后调用它❸。请注意，我们将数据（函数的参数）传递给了`.data`方法❷，而不是直接传递数字数组。
- en: Next we’ll add the code for handling button clicks, which will insert a random
    floating-point number between 1 and 5 into the numbers array at the start or end,
    or drop the last element in the array. Add the code in [Listing 14-22](#Lis14-22)
    to the end of *script.js*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加处理按钮点击的代码，这些代码将会在数字数组的开头或末尾插入一个1到5之间的随机浮动数字，或者移除数组中的最后一个元素。将[Listing
    14-22](#Lis14-22)中的代码添加到*script.js*的末尾。
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Updating on
    button clicks</samp>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: 按钮点击时的更新</samp>'
- en: First we declare a helper function for generating a random number ❶, since there
    are two places where we need to do this. Then we declare the handlers for the
    three buttons. Notice that instead of using the regular DOM API methods for adding
    click handlers, as we’ve done previously in this book, we’re using d3.select to
    select the buttons and the on method to add an event handler. The regular DOM
    API methods would work as well, but using D3 methods is more concise and more
    consistent with the other D3 code in this file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个用于生成随机数的辅助函数❶，因为有两个地方需要这样做。然后我们声明三个按钮的事件处理器。请注意，我们没有像本书之前所做的那样使用常规的DOM
    API方法来添加点击事件处理器，而是使用`d3.select`来选择按钮，并使用`on`方法添加事件处理器。常规的DOM API方法也能工作，但使用D3方法更简洁，并且与此文件中的其他D3代码更加一致。
- en: 'The first handler is triggered by a click on the Append button ❷: it pushes
    a random number onto the end of the numbers array, then we call the update function
    to redraw the visualization with an extra circle. The second handler, triggered
    by a click on the Prepend button, causes a random number to be unshifted onto
    the front of the numbers array ❸. The third is triggered by a click on the Drop
    button; it pops the last number from the array ❹. After each of these actions
    we also call the update function.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事件处理器通过点击“Append”按钮触发❷：它将一个随机数推入数字数组的末尾，然后我们调用更新函数重新绘制可视化，添加一个额外的圆圈。第二个事件处理器通过点击“Prepend”按钮触发，它会将一个随机数插入到数字数组的开头❸。第三个事件处理器通过点击“Drop”按钮触发；它从数组中弹出最后一个数字❹。在每个操作之后，我们也会调用更新函数。
- en: Reload the page and try out the different buttons. You should see the elements
    being added and removed as needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并尝试不同的按钮。你应该会看到元素根据需要被添加和移除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transitions and Key
    Functions</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">过渡与关键函数</samp>
- en: Instead of updating a D3 visualization abruptly with each change in the data,
    you can use *transitions* to allow elements to animate their attributes as they
    change. Transitions are a useful feature in D3 because, if done right, they allow
    you to see how data evolves. Let’s add a transition to our update function to
    see how this works. Make the changes shown in [Listing 14-23](#Lis14-23).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于每次数据变化时突然更新D3可视化，你可以使用*过渡*来允许元素在变化时动画其属性。过渡是D3中的一个有用特性，因为如果做得正确，它们可以让你看到数据是如何演变的。让我们在更新函数中添加一个过渡，看看它是如何工作的。做出[Listing
    14-23](#Lis14-23)所示的更改。
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Adding transitions</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: 添加过渡</samp>'
- en: The transition method in a chain like this means that every following attribute
    change will animate from its current value to the new value. The duration method
    sets the length of the animation in milliseconds. This means that the position
    and radius of each circle will take half a second (500 ms) to animate from its
    current value to the new value. New circles start off with default values of 0
    for each attribute, so they will transition in from the top-left corner of the
    SVG.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的链式调用中，`transition`方法意味着每个后续的属性变化都会从当前值动画过渡到新值。`duration`方法设置动画的时长（以毫秒为单位）。这意味着每个圆圈的位置和半径将花费半秒（500毫秒）时间，从当前值过渡到新值。新的圆圈从每个属性的默认值0开始，因此它们会从SVG的左上角过渡进来。
- en: 'Unfortunately, the way we’ve coded our update function, the animation won’t
    be quite as satisfying as you might want. Reload the page and click **Prepend**
    a few times. You should see some odd behavior. You might have expected the existing
    circles to move over to the right, making room for a new circle being added on
    the left. Instead, the existing circles all appear to resize in place, while a
    new circle flies in from the top-left corner and takes its place to the right
    of the existing circles. With this animation, it’s actually very hard to see that
    an element is being *prepended* on the left. Rather, the animations suggest that
    an element is being *appended* on the right, and that all the elements are being
    resized. Clicking the Append button, on the other hand, does the correct thing:
    a new element animates in and appears at the end of the row, while the existing
    elements don’t change.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于我们编写的更新函数，动画的效果可能不会像你想要的那样令人满意。重新加载页面并点击**Prepend**几次。你应该会看到一些奇怪的行为。你可能期待现有的圆圈向右移动，为左侧添加的新圆圈腾出空间。但实际上，现有的圆圈似乎都在原地调整大小，而一个新的圆圈从左上角飞入，并出现在现有圆圈的右侧。通过这种动画，其实很难看出元素是被*插入到左边*的。相反，动画给人一种元素是被*附加到右边*的感觉，并且所有元素都在调整大小。而点击
    Append 按钮则会做正确的事情：一个新元素会动画显示并出现在行的末尾，而现有元素没有变化。
- en: The problem here is that when D3 updates an existing selection with a new array
    of data, it uses a default mode called *join-by-index*. This means that the first
    item in the array is joined with the first element in the selection (in this case,
    the leftmost circle), the second item in the array with the second element in
    the selection, and so on. If there are more items in the array than existing SVG
    elements, new elements are added at the end. Thus, when you click Prepend and
    add a new number to the start of the data array, every circle in the line is re-bound
    to a new datum. The first circle in the line is bound to the new number that’s
    been added to the start of the array, so it appears to resize. The second circle
    is bound to what used to be the first number in the array, so it appears to resize
    as well, and so on. Finally, since there’s now one more data item than there are
    SVG elements, a new circle is created and added at the end of the line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，当 D3 使用新的数据数组更新现有选择时，它使用一种称为*按索引连接*的默认模式。这意味着数组中的第一个项与选择中的第一个元素连接（在本例中是最左边的圆圈），数组中的第二个项与选择中的第二个元素连接，依此类推。如果数组中的项比现有的
    SVG 元素多，新的元素会被添加到末尾。因此，当你点击 Prepend 并将新数字添加到数据数组的开始时，行中的每个圆圈都会重新绑定到一个新的数据项。行中的第一个圆圈会绑定到添加到数组开头的新数字，因此它会看起来被调整大小。第二个圆圈会绑定到原来数组中的第一个数字，因此它也会看起来被调整大小，依此类推。最后，由于现在的数据项比
    SVG 元素多一个，新的圆圈会在行的末尾创建并添加。
- en: The solution to making the animation more intuitive is to help D3 understand
    the *identity* of each element in the array of data. Instead of assuming that
    every index in the array will always map to the same index in the selection, we
    provide what D3 calls a *key function*. The key function allows us to specify
    something about each datum that identifies it uniquely. This way, each existing
    datum stays bound to the same SVG element even as new data is added, regardless
    of the ordering of the data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使动画更加直观的解决方案是帮助 D3 理解数据数组中每个元素的*身份*。我们不再假设数组中的每个索引总是与选择中的相同索引对应，而是提供 D3 所称的*关键函数*。关键函数使我们能够指定每个数据项的某些特征，以唯一标识它。这样，即使新数据被添加，现有数据仍然绑定到相同的
    SVG 元素，而不管数据的顺序如何。
- en: The key function is passed as an optional second argument to the data method.
    [Listing 14-24](#Lis14-24) shows the necessary change to the update function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关键函数作为可选的第二个参数传递给数据方法。[列表 14-24](#Lis14-24)展示了更新函数所需的更改。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Adding a key
    function</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-24: 添加关键函数</samp>'
- en: The key function d => d here says that given a datum, the datum itself is the
    unique identifier. In this case, we’re just using raw numbers, so the value of
    the number is as good as we can get for a “unique” identifier. Usually you’ll
    be working with more complex data, and you can use the key function to expose
    an identifier that is actually unique. For example, if each datum were an object
    representing an employee with a unique employeeId property, then you could use
    a key function like d => d.employeeId.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键函数 d => d 表示给定一个数据项时，数据项本身就是唯一标识符。在这个例子中，我们只是使用原始数字，所以数字的值就相当于我们能得到的“唯一”标识符。通常，你会处理更复杂的数据，并且可以使用键函数来暴露一个实际上是唯一的标识符。例如，如果每个数据项都是一个表示员工的对象，并且每个员工有一个唯一的
    employeeId 属性，那么你可以使用像 d => d.employeeId 这样的键函数。
- en: Reload the page and click **Prepend**. You should now see all the circles slide
    to the right to accommodate the newly prepended element. This is because D3 now
    knows which item in the new array should map to which element in the selection
    when the array changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并点击 **Prepend**。你应该会看到所有圆形元素向右滑动，以容纳新加入的元素。这是因为 D3 现在知道当数组发生变化时，新的数组项应该映射到选择中的哪个元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Advanced Joins</samp>
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">高级连接</samp>
- en: D3’s join method has extra options that give you more control over how the visualization
    responds to changes in the data. When D3 joins new data to an existing selection,
    some elements may be updated, some may be added (for the case of a new datum with
    no existing element), and some elements may be removed. In our case, we’ve seen
    how clicking Prepend both adds a new element and updates all the other elements
    by shifting them to the right. Meanwhile, clicking Drop removes the last element.
    In D3 parlance, adding a new element is called an *enter*, removing an existing
    element is called an *exit*, and modifying an existing element is called an *update*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的 join 方法提供了额外的选项，让你可以更好地控制可视化在数据变化时的响应。当 D3 将新数据与现有选择进行连接时，一些元素可能会被更新，一些可能会被添加（对于没有现有元素的新数据项），而一些元素可能会被删除。在我们的案例中，我们看到点击
    **Prepend** 不仅会添加新元素，还会通过将其他元素向右移动来更新所有元素。与此同时，点击 Drop 会删除最后一个元素。在 D3 的术语中，添加新元素叫做
    *enter*，删除现有元素叫做 *exit*，而修改现有元素叫做 *update*。
- en: 'You can customize the join method by passing it three functions that will be
    called for each of these three possible element changes. This way you’re able
    to specify three different behaviors: one for entering elements, one for elements
    that are being updated, and one for exiting elements. To test this functionality,
    modify your update function as shown in [Listing 14-25](#Lis14-25). To start,
    these changes result in the same behavior we got from the simple join method in
    the previous listing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递三个函数来定制 join 方法，这些函数会针对这三种可能的元素变化进行调用。这样，你就能指定三种不同的行为：一种是进入元素时的行为，一种是更新元素时的行为，另一种是退出元素时的行为。要测试这个功能，请按照
    [清单 14-25](#Lis14-25) 中所示的方式修改你的 update 函数。开始时，这些变化会产生与前一个清单中的简单 join 方法相同的行为。
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: The join</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">method with enter, update, and
    exit functions</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-25：带有 enter、update 和 exit
    函数的 join 方法</samp>
- en: This more advanced version of the join method takes three functions. The first
    function has a single parameter called enter, which is a selection of temporary
    placeholders for each of the entering elements. To get the same behavior as the
    simple .join("circle") version, we just use the append method to add a circle
    to each enter placeholder. Note that the enter placeholders themselves aren’t
    elements in the DOM. They’re just a handle for D3 to give you a place to append
    your new entering elements, before they get added to the DOM. For example, if
    there were five new elements needing to be entered, then enter.append("circle")
    would create five new circle elements and place them inside the svg element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更高级的 join 方法版本需要传入三个函数。第一个函数有一个名为 enter 的参数，这是一个临时占位符的选择集，用于表示每个进入的元素。为了获得与简单的
    .join("circle") 版本相同的行为，我们只需使用 append 方法将一个圆形元素添加到每个 enter 占位符中。请注意，enter 占位符本身不是
    DOM 中的元素。它们只是 D3 给你提供一个位置来附加新进入的元素，直到它们被添加到 DOM 中。例如，如果有五个新的元素需要进入，那么 enter.append("circle")
    会创建五个新的圆形元素并将它们放入 svg 元素中。
- en: The second function has a single parameter called update, which is a selection
    containing all the existing elements that are already bound to a datum. To get
    the same behavior as before, we just return the selection unchanged.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数有一个名为update的单一参数，它是一个包含所有已绑定数据项的现有元素的选择集。为了得到与之前相同的行为，我们只需返回未更改的选择集。
- en: The third function has a single parameter called exit, which is a selection
    containing all the elements that should be removed because they no longer have
    a corresponding datum. To get the same behavior as before, we call the remove
    method on the selection, which removes each exiting element from the DOM.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数有一个名为exit的单一参数，它是一个包含所有应该被移除的元素的选择集，因为这些元素不再有对应的数据项。为了得到与之前相同的行为，我们在选择集上调用remove方法，它会将每个退出的元素从DOM中移除。
- en: When you reload the page, you should see the same behavior as before; so far,
    this change doesn’t have any functional impact. Now that we have it working, though,
    we can rework our animations to add some finesse. The current shift-right animation
    for elements in the updating selection is fine, but entering elements currently
    fly in from the top-left corner, and exiting elements just disappear. Let’s instead
    make it so entering elements grow into place from their correct position, and
    exiting elements shrink away to nothing at their current position. The changes
    to implement that behavior are shown in [Listing 14-26](#Lis14-26).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面时，你应该看到与之前相同的行为；到目前为止，这个变化不会对功能产生任何影响。不过，既然我们已经让它正常工作了，我们可以重新设计动画，增加一些细节。目前，更新选择中的元素的右移动画是可以的，但进入的元素现在是从左上角飞入，而退出的元素只是消失了。我们不妨改成这样：让进入的元素从正确的位置增长到位，而退出的元素则从当前位置缩小至消失。实现这种行为的更改可以参见[Listing
    14-26](#Lis14-26)。
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: Finessing the
    animations</samp>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: 细化动画</samp>'
- en: 'In this updated code, we’ve moved all the transitions into the individual enter,
    update, and exit functions, instead of having a single transition call for all
    the elements. The enter function appends a circle element ❶ and then immediately
    sets its position (the cx and cy attributes), but not its radius. Once the position
    is set, we use the transition method to animate the radius from zero (the default
    value) to the value calculated from the datum ❷. The order here is important:
    anything that comes in the chain *before* the call to transition will happen immediately,
    and anything *after* the call to transition will be animated. This means that
    any new circles will appear in the right position immediately, and the change
    in size (from zero to the desired radius) will animate. This will arguably look
    more natural than the previous version, where all three attributes animated in
    from zero, leading to the circles flying in from the corner.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段更新的代码中，我们将所有过渡都移到了各自的enter、update和exit函数中，而不是为所有元素调用一个单一的transition方法。enter函数首先添加一个圆形元素❶，然后立即设置它的位置（即cx和cy属性），但不设置半径。一旦位置设置好，我们使用transition方法将半径从零（默认值）动画过渡到根据数据项计算的值❷。这里的顺序非常重要：任何在调用transition之前的操作会立即发生，而在调用transition之后的操作会进行动画过渡。这意味着任何新的圆形元素会立即出现在正确的位置，且大小的变化（从零到期望的半径）会进行动画过渡。这比之前的版本看起来更自然，后者是所有三个属性从零动画过渡过来，导致圆形元素从角落飞入。
- en: The update function has to animate only the cx attribute of the circle ❸ to
    slide it to its updated position. All other attributes should be unchanged for
    existing elements. Finally, the exit function animates the radius of the circle
    back to zero ❹ before removing it ❺. If remove is called after a call to transition,
    as it is here, the actual element removal won’t take place until after the animations
    have completed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: update函数只需要对圆形元素❸的cx属性进行动画，以将其滑动到更新后的位置。其他属性对于现有元素应该保持不变。最后，exit函数将圆形的半径动画过渡回零❹，然后再将其移除❺。如果在调用transition后调用remove方法，如这里所示，那么实际的元素移除将在动画完成后进行。
- en: 'When you reload the page, you should see the new and improved animations: new
    elements expand in at the appropriate position and removed elements shrink away.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面时，你应该看到新的改进动画：新元素在合适的位置扩展，移除的元素则缩小消失。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Bar Graph</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建条形图</samp>
- en: 'Now that you’ve learned the basics of D3, let’s put them to use in a small
    project: creating a bar graph that visualizes the frequency of characters in a
    text box. The bar graph will update as new text is typed or pasted into the box.
    Creating this visualization will let you practice data joins, teach you some new
    techniques like drawing axes to contextualize the data, and prepare you for the
    more substantial project in the next chapter.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了 D3 的基础知识，让我们在一个小项目中应用它们：创建一个条形图，展示文本框中字符的频率。每当输入或粘贴新的文本时，条形图都会更新。创建这个可视化图表将帮助你练习数据连接，教你一些新技术，比如绘制坐标轴来为数据提供上下文，同时为下章的更大项目做好准备。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置</samp>
- en: To get started, make a new directory called *frequency* and add empty *script.js*
    and *style.css* files. Then create an *index.html* file and add the code in [Listing
    14-27](#Lis14-27).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 *frequency* 的新目录，并添加空的 *script.js* 和 *style.css* 文件。然后创建一个 *index.html*
    文件，并将 [清单 14-27](#Lis14-27) 中的代码添加进去。
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-27: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for the character frequency project</samp>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-27：字符频率项目的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: This HTML document follows the same pattern we’ve been using throughout the
    book. The only new addition is the textarea element ❶, which creates a multiline
    text input. The rows and cols attributes set the number of lines and the width
    (in fixed-width characters) of the text area.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 HTML 文档遵循了本书中一直使用的模式。唯一新增的元素是 textarea 元素 ❶，它创建了一个多行文本输入框。rows 和 cols 属性设置了文本区域的行数和宽度（以固定宽度字符为单位）。
- en: Notice that the document doesn’t contain an svg element. We’re going to create
    it using JavaScript. This is because we’ll need to refer to the svg element’s
    width and height multiple times to determine the placement of elements in the
    visualization, so it makes sense to define those parameters in the JavaScript
    rather than in the HTML file. And since we’ll be defining the width and height
    in the JavaScript, we may as well create the svg element itself in the JavaScript,
    too. We’ll do that right now. Add the code in [Listing 14-28](#Lis14-28) to *script.js*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文档中没有 svg 元素。我们将通过 JavaScript 来创建它。这是因为我们需要多次引用 svg 元素的宽度和高度来确定可视化中元素的位置，因此在
    JavaScript 中定义这些参数比在 HTML 文件中定义更为合理。由于我们将定义宽度和高度在 JavaScript 中，因此也可以直接在 JavaScript
    中创建 svg 元素。我们现在就来做这件事。将 [清单 14-28](#Lis14-28) 中的代码添加到 *script.js* 中。
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-28: Creating the
    svg element using JavaScript</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-28：使用 JavaScript 创建 svg
    元素</samp>
- en: We first declare constants for the width and height of the svg element. Then
    we use D3 to select the body element and append an svg element to it, setting
    the width and height attributes in the process. We save the result of creating
    the element into the variable svg because we’re going to need it later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明常量来表示 svg 元素的宽度和高度。然后，使用 D3 选择 body 元素，并将一个 svg 元素添加到其中，同时设置宽度和高度属性。我们将创建元素的结果保存到变量
    svg 中，因为之后我们还会用到它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating Character
    Frequencies</samp>
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算字符频率</samp>
- en: Next, we’ll add the code for reading the text from the text area and counting
    the number of occurrences of each character. This generates the underlying data
    for the visualization. Anytime the text changes, we’ll need to update the data
    and redraw the chart. For now, though, we’ll just read the text, figure out the
    character frequencies, and log the output to the console. Add the code in [Listing
    14-29](#Lis14-29) to the end of *script.js*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加读取文本区域中内容并计算每个字符出现次数的代码。这将生成可视化所需的底层数据。每次文本更改时，我们都需要更新数据并重新绘制图表。不过现在，我们只需要读取文本，计算字符频率，并将结果输出到控制台。将
    [清单 14-29](#Lis14-29) 中的代码添加到 *script.js* 的末尾。
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-29: Calculating
    character frequencies</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-29：计算字符频率</samp>
- en: The input event ❶ is triggered anytime the content of the text area changes,
    whether from typing, deleting, pasting, or some other action. The first thing
    we do in the event’s handler function is initialize a new object for keeping track
    of the character frequencies ❷. This frequencies object will use characters for
    its keys and the number of appearances of that character for its values. We then
    get the target of the event (the text area), get its value (the text), and split
    it into its individual characters ❸. For each character, we determine the current
    count for that character, defaulting to 0 if it hasn’t been seen yet. Then we
    add 1 to that count and store the new count back in the object. Once all the characters
    have been counted, we log the frequencies object to the console so we can check
    everything is working as expected. Note that we recalculate the frequencies object
    every time the text changes, rather than just trying to track added or deleted
    characters. This makes it much easier to handle cases where multiple characters
    are added or removed at once, for example, when text is pasted into the box.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输入事件 ❶ 在文本区域内容发生变化时触发，无论是打字、删除、粘贴，还是其他操作。在事件处理函数的第一步，我们初始化一个新对象来跟踪字符频率 ❷。这个频率对象将字符作为键，字符出现的次数作为值。接着，我们获取事件的目标（文本区域），获取其值（文本内容），并将其拆分为单独的字符
    ❸。对于每个字符，我们确定该字符的当前计数，如果该字符之前没有出现过，则默认为 0。然后我们将计数加 1，并将新的计数值存储回对象中。所有字符计数完成后，我们将频率对象记录到控制台，以便检查一切是否按预期工作。请注意，我们每次文本内容发生变化时都会重新计算频率对象，而不是仅仅尝试跟踪添加或删除的字符。这使得处理多个字符同时添加或删除的情况变得更加容易，例如当文本被粘贴到文本框中时。
- en: 'Load the page, and you should see the text area (the svg element is invisible,
    but you can see it in the Elements panel if you want to check it’s there). When
    you type text into the text area, you should see objects being logged to the console
    on every keystroke, each time containing the frequencies of the characters in
    the text area. For example, if you type in the word *hello*, you’ll get this object
    after typing the final *o*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 加载页面后，你应该能看到文本区域（svg 元素不可见，但如果想检查它是否存在，可以在“元素”面板中查看）。当你在文本区域中输入文字时，应该能看到每次键入时都会将对象记录到控制台，每次记录的对象都包含文本区域中字符的频率。例如，如果你输入单词*hello*，在键入最后一个*o*之后，你将得到如下对象：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A single object containing all the characters and their frequencies works well
    for logging to the console, but what we’re going to want for rendering with D3
    is an array of objects, each describing a single character and its associated
    frequency. This way, each entry in the array will be a datum bound to a bar in
    our bar chart. To make the chart easier to read, the array should be sorted alphabetically
    by character. Continuing with the word *hello*, instead of the object shown previously,
    we need something like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含所有字符及其频率的单一对象对于控制台日志输出非常有效，但我们要在 D3 渲染时使用的是一个对象数组，每个对象描述一个字符及其相关的频率。这样，数组中的每一项就会是绑定到柱状图中一根柱子的单一数据项。为了让图表更易于阅读，数组应该按字符字母顺序排序。继续使用单词*hello*，我们需要类似下面的内容，而不是之前显示的对象：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To put the data in this array format, change the end of *script.js* as shown
    in [Listing 14-30](#Lis14-30).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据转换为这种数组格式，请按照[列表 14-30](#Lis14-30)中所示修改*script.js*的结尾部分。
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-30: Converting the
    frequency data to an array</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-30：将频率数据转换为数组</samp>
- en: First, we use Object.entries to convert the frequencies object into an array
    of two-element arrays ❶, where the first element is the key and the second element
    is the value. We map this array into an array of objects, where the key is stored
    under the property char and the value is stored under the property count. Next,
    we want to sort the data by character. The sort method ❷ orders the elements in
    an array by applying a comparison function to every pair of elements a and b,
    to determine whether a should be sorted after b or vice versa. Here we use the
    d3.ascending comparison function, passing a.char and b.char, which means the array
    will be sorted into ascending alphabetical order based on the char property of
    each object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `Object.entries` 将频率对象转换为一个包含两个元素数组的数组 ❶，其中第一个元素是键，第二个元素是值。我们将这个数组映射为一个对象数组，其中键存储在
    `char` 属性下，值存储在 `count` 属性下。接下来，我们希望按字符排序数据。`sort` 方法 ❷ 通过对每一对元素 a 和 b 应用比较函数，确定
    a 是否应该排在 b 后面，反之亦然，从而对数组中的元素进行排序。在这里，我们使用 `d3.ascending` 比较函数，传入 `a.char` 和 `b.char`，意味着数组会根据每个对象的
    `char` 属性按字母升序排序。
- en: Reload the page, and you should now see this new data array being logged as
    text changes in the text area.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面后，您应该能看到文本区域中的文本变化时，这个新的数据数组作为日志被记录。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing the Bar Graph</samp>
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">绘制条形图</samp>
- en: Now that we have the data in the format we need, we can render it as a bar graph.
    We’re going to start out with a basic, naive rendering for now, where we simply
    create SVG rect elements with widths proportional to the character frequencies.
    We’ll gradually build from there to create a more informative visualization. Make
    the changes to *script.js* shown in [Listing 14-31](#Lis14-31).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据转换为所需的格式，可以将其渲染为条形图。我们暂时从一个基本的、简单的渲染开始，即简单地创建与字符频率成比例的宽度的 SVG `rect`
    元素。然后我们将逐步改进，创建一个更具信息量的可视化。请按照[清单 14-31](#Lis14-31)中的更改，修改 *script.js*。
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-31: Defining the
    update function</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-31：定义更新函数</samp>
- en: Here we declare an update function ❶, which gets called every time the text
    changes ❸. The function creates, updates, or deletes the SVG elements needed to
    render the data, according to the same pattern we learned earlier for binding
    data to a selection (using the data method) and joining in the necessary elements
    with the simple version of the join method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个更新函数 ❶，每当文本发生变化 ❸ 时，该函数都会被调用。该函数根据我们之前学到的模式创建、更新或删除渲染数据所需的 SVG 元素，使用
    `data` 方法将数据绑定到选择项，并使用简单版本的 `join` 方法连接必要的元素。
- en: The join method returns a selection containing all the current rect elements
    ❷, including any that were just added. Each rect is now bound to a single datum,
    which represents a single character and the number of occurrences of that character.
    We set the width, height, x, and y attributes as appropriate to create a horizontally
    oriented bar chart. The width attribute is set to 5 times the character count,
    so every new instance of a character makes the bar 5 pixels wider. The height
    attribute is a constant value of 10 (all bars are the same height), and the x
    attribute is a constant value of 20 (all bars start 20 pixels from the left of
    the SVG element). The y attribute is set to 20 times the index of the datum, meaning
    that there will be a bar every 20 pixels, giving 10 pixels of space between each
    bar.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 方法返回一个包含所有当前 `rect` 元素的选择集 ❷，包括刚刚添加的元素。现在，每个 `rect` 都与一个数据项绑定，该数据项表示单个字符及该字符的出现次数。我们设置了适当的
    `width`、`height`、`x` 和 `y` 属性，以创建一个水平的条形图。`width` 属性设置为字符计数的 5 倍，因此每新增一个字符，条形图的宽度就会增加
    5 像素。`height` 属性设置为常数值 10（所有条形图的高度相同），`x` 属性设置为常数值 20（所有条形图都从 SVG 元素左侧的 20 像素处开始）。`y`
    属性设置为数据项索引的 20 倍，这意味着每 20 像素就会出现一根条形图，条形图之间的间隔为 10 像素。'
- en: Reload the page and type the word *hello* into the text area. As you type each
    letter, you should see bars appear or update in the SVG element, ending with something
    like [Figure 14-9](chapter14.xhtml#fig14-9).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面并在文本区域输入单词 *hello*。当您输入每个字母时，您应该看到条形出现在 SVG 元素中，或在更新后显示类似于[图 14-9](chapter14.xhtml#fig14-9)的内容。
- en: '![](../images/Figure_14-9.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: A basic bar chart</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-9：基本条形图</samp>
- en: So far so good, but we still have a ways to go. There are two major issues here.
    First, there are no axes or labels, so we don’t know what character each bar represents
    or what the width of the bar corresponds to. Second, there’s no autoscaling of
    the bar widths and heights, meaning that we currently have a limit of 30 distinct
    characters and a count of 116 per character before the bars don’t fit in the 600×600-pixel
    SVG element. Luckily, both of these problems are easy to fix using D3.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但我们仍然有一些问题要解决。这里有两个主要问题。首先，没有坐标轴或标签，我们不知道每个条形代表什么字符，也不知道条形的宽度对应什么。其次，条形的宽度和高度没有自动缩放，这意味着目前我们最多只能有30个不同的字符，每个字符的计数是116，超过这个限制条形就无法在600×600像素的SVG元素中显示。幸运的是，这两个问题都可以通过使用D3轻松解决。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Scaling the Bars</samp>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">缩放条形</samp>
- en: A *scale* in D3 is a way of converting from some data value to a visual value.
    For example, earlier we set the width of the bars in our character frequency graph
    to be five times the data value, which is a simple form of scaling. In that case,
    we set the scale factor manually, but D3 can also determine the scaling automatically
    based on the minimum and maximum data values, known as the *domain*, and the minimum
    and maximum display values, known as the *range*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3中，*scale*（比例尺）是将某些数据值转换为视觉值的一种方式。例如，之前我们将字符频率图中条形的宽度设置为数据值的五倍，这是一种简单的缩放方式。在这种情况下，我们手动设置了缩放因子，但D3也可以根据数据值的最小值和最大值（即*domain*，区间）以及显示值的最小值和最大值（即*range*，范围）自动确定缩放。
- en: For example, say you’re plotting a graph of people’s ages. Your data values
    range from 0 to 105, and the space for rendering those values ranges from 30 to
    330 pixels from the left side of the SVG. Your domain is thus [0, 105], and your
    range is [30, 330]. A value of 0 in the data domain maps to 30 in the visual range,
    and a value of 105 maps to 330\. See [Figure 14-10](chapter14.xhtml#fig14-10)
    for a visual representation of this mapping.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在绘制一个人的年龄图表。你的数据值范围是从0到105，而渲染这些值的空间范围是从SVG的左侧起30到330像素。因此，你的区间是[0, 105]，你的范围是[30,
    330]。数据区间中的0值映射到视觉范围中的30，而105值映射到330。请参见[图14-10](chapter14.xhtml#fig14-10)以获取这种映射的视觉表示。
- en: '![](../images/Figure_14-10.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: Scaling values
    from a domain of [0, 105] to a range of [30, 330]</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-10：将[0, 105]区间的值缩放到[30,
    330]的范围</samp>
- en: 'The beauty of D3 scaling is that the scale factor can change dynamically based
    on changes in the domain. This way, the current maximum data value can always
    map to the full visual range, even as the maximum data value changes. To implement
    this dynamic scaling for our bar graph, we need to keep track of the maximum count
    value among all the data, and use that as the upper value of the domain. As a
    result, if the maximum count increases, the bars that aren’t at the maximum count
    will all scale down accordingly, while the bar at the maximum count will continue
    to occupy the full horizontal range. For example, say that our visual range for
    the bars is [0, 500], and we have the following data:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: D3缩放的美妙之处在于，缩放因子可以根据区间的变化动态变化。这样，当前的最大数据值总是能够映射到完整的视觉范围，即使最大数据值发生了变化。为了实现这种动态缩放，我们需要跟踪所有数据中的最大计数值，并使用它作为区间的上限。因此，如果最大计数值增加，未达到最大计数的条形会相应地缩小，而最大计数的条形将继续占据完整的水平范围。例如，假设我们条形的视觉范围是[0,
    500]，并且我们有以下数据：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The domain of our data would be [0, 2]. The "c" bar would be 500 units wide,
    and the "a" and "b" bars would each be 250 units wide. If we then added another
    two c’s, the "c" bar would still be 500 units wide, but now the "a" and "b" bars
    would each be 125 units wide.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据的区间是[0, 2]。 "c"条的宽度为500单位，"a"和"b"条的宽度各为250单位。如果我们再添加两个"c"条，"c"条的宽度仍为500单位，但现在"a"和"b"条的宽度将各自缩小为125单位。
- en: Let’s implement that dynamic horizontal scaling now. Modify your script with
    the code shown in [Listing 14-32](#Lis14-32).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现动态水平缩放。修改你的脚本，参考[清单14-32](#Lis14-32)中的代码。
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-32: Creating a scale
    for the bar widths</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-32：为条形宽度创建比例尺</samp>
- en: First, immediately before the update function definition, we create an object
    describing the margins of our bar chart diagram. These values indicate how far
    from the edges of the SVG element the main body of the diagram will be. As [Figure
    14-11](chapter14.xhtml#fig14-11) shows, when the time comes we’ll use these margins
    to determine where to draw the bars and the axes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在更新函数定义之前，我们创建一个对象，描述我们的条形图图表的边距。这些值表示图表主体距离SVG元素边缘的距离。如[图 14-11](chapter14.xhtml#fig14-11)所示，当时机到来时，我们将使用这些边距来确定绘制条形图和坐标轴的位置。
- en: '![](../images/Figure_14-11.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: How margins can
    be used to position a diagram in an SVG element (the dotted line)</samp>'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-11: 边距如何用来定位SVG元素中的图表（虚线）</samp>'
- en: Inside the update function, we use the d3.scaleLinear method to create a scale
    ❶. This means that input values map linearly to output values (as opposed to logarithmically,
    for example). We set the domain from zero to the max count, using the D3 max helper.
    This helper takes an array of data and a function that returns a value from the
    datum, and returns the maximum value. In this case, it’s returning the maximum
    count value. The range is set from margin.left to width - margin.right and gives
    us the position of the right side of the longest bar.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新函数内部，我们使用d3.scaleLinear方法创建一个比例尺❶。这意味着输入值线性映射到输出值（例如，不是对数映射）。我们将数据领域设置为从0到最大计数，使用D3的max助手。这个助手接受一个数据数组和一个返回数据项值的函数，然后返回最大值。在这里，它返回的是最大计数值。范围设置为从margin.left到width
    - margin.right，给出最长条形图右侧的位置。
- en: The scaleLinear helper gives us a function that maps from the data domain to
    the visual range, which we assign to the variable xScale. (As discussed in [Chapter
    5](chapter5.xhtml), it’s possible for a higher-order function to return another
    function, as scaleLinear is doing here.) We modify our width attribute setting
    to call that xScale function, passing the count from each datum ❷. Here, xScale(0)
    gives the horizontal position of the left side of the bar, which corresponds to
    the domain value 0, and xScale(d.count) gives the horizontal position of the right
    side of the bar. To get the width of the bar, we need to subtract xScale(0) from
    xScale(d.count), because the width is just the distance between the left side
    of the bar and the right side of the bar. This will give an appropriately scaled
    bar width based on the count of each datum and the maximum count. We set the x
    attribute of the bar to xScale(0) to enforce the left margin ❸.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: scaleLinear助手提供了一个函数，它将数据领域映射到视觉范围，我们将其分配给变量xScale。（如[第5章](chapter5.xhtml)所讨论，高阶函数可以返回另一个函数，scaleLinear就是这样做的。）我们修改宽度属性设置，调用xScale函数，并传入每个数据项的计数值❷。在这里，xScale(0)给出条形图左侧的水平位置，对应于数据领域值0，xScale(d.count)给出条形图右侧的水平位置。为了得到条形图的宽度，我们需要从xScale(d.count)中减去xScale(0)，因为宽度只是条形图左侧和右侧之间的距离。这将根据每个数据项的计数值和最大计数值，给出适当的条形图宽度。我们将条形图的x属性设置为xScale(0)，以确保左边距❸。
- en: Reload the page and start typing into the text area. The first time you enter
    a character, a single bar will appear, at the maximum width. Try typing *abccc*
    into the text area; you’ll see that as you add more c’s, the first two bars (for
    a and b) get smaller.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并开始在文本区域输入内容。当你第一次输入字符时，单个条形图会出现，宽度最大。试着在文本区域输入*abccc*；你会看到，随着更多c的添加，第一个和第二个条形图（对应a和b）会变小。
- en: Now let’s create a scale for the height of the bars, to make full use of the
    vertical space of the svg element. The bars will start out tall but get shorter
    to accommodate more bars as new characters are added to the text field. Make the
    changes shown in [Listing 14-33](#Lis14-33).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为条形图的高度创建一个比例尺，以充分利用svg元素的垂直空间。条形图一开始会很高，但随着新字符的添加，它会变得越来越矮，以容纳更多的条形图。请根据[清单
    14-33](#Lis14-33)进行更改。
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-33: Scaling the
    bar heights</samp>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-33: 缩放条形图的高度</samp>'
- en: To create a scale for the heights of the bars, we use the d3.scaleBand helper
    ❶. This lets us create a set of evenly spaced bands. The domain here is slightly
    different, because instead of an array giving the minimum and maximum values,
    it contains the full set of values. For example, if the content of the text area
    were the word *hello*, the domain of the y scale would be ["e", "h", "l", "o"]
    (remember that we sort the data alphabetically). This would map to four evenly
    spaced bars.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建条形的高度刻度，我们使用d3.scaleBand辅助函数❶。这让我们能够创建一组均匀分布的带状区域。此处的域略有不同，因为它不再是给定最小值和最大值的数组，而是包含了所有值的完整集合。例如，如果文本区域的内容是单词*hello*，那么y轴刻度的域将是["e",
    "h", "l", "o"]（记住我们按照字母顺序对数据进行排序）。这将映射到四个均匀分布的条形。
- en: 'The range here is from margin.top to height - margin.bottom, which gives the
    range of y values the bars will exist in (the first bar will be at the top and
    the last at the bottom). The padding value defines how much space there is between
    bars based on the space available: 0 means that they are as tall as possible and
    will be touching, while 0.5 means that the bars will take up half of the space
    available.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的范围从margin.top到height - margin.bottom，这给出了条形将存在的y值范围（第一个条形会在顶部，最后一个条形会在底部）。padding值定义了条形之间的间隔大小，基于可用空间：0意味着它们尽可能高并且会接触在一起，而0.5意味着条形将占据一半的可用空间。
- en: Scales created using scaleBand also have a bandwidth method that returns the
    scaled size of the bands, which we can use to set the height of the bars ❷. (The
    method is called bandwidth on the assumption that the bars are oriented vertically,
    whereas ours are oriented horizontally.) To get the y attribute of the bar, we
    pass d.char to the yScale function ❸, because the domain of this scale is all
    the characters present in the data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scaleBand创建的刻度还具有一个bandwidth方法，它返回带状区域的缩放大小，我们可以用它来设置条形的高度❷。（该方法称为bandwidth，假设条形是垂直方向的，而我们的条形是水平方向的。）为了获取条形的y属性，我们将d.char传递给yScale函数❸，因为该刻度的域是数据中存在的所有字符。
- en: Reload the page and type some text into the text area. The first character you
    enter will cause a single tall black bar to appear, but for every unique character
    you type a new bar will be added, and the heights of the existing bars will decrease
    to make space. [Figure 14-12](chapter14.xhtml#fig14-12) shows how the visualization
    should look.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并在文本区域中输入一些文本。你输入的第一个字符会导致一个高大的黑色条形出现，但对于每个唯一字符，你输入的新条形会被添加，现有条形的高度将减少以腾出空间。[图14-12](chapter14.xhtml#fig14-12)展示了这个可视化效果应该是什么样的。
- en: '![](../images/Figure_14-12.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: Our bar graph
    scaled in both dimensions</samp>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-12：我们的条形图在两个维度上进行了缩放</samp>
- en: Try typing in different text to get a feel for how the bars update as the data
    changes. Next we’ll add axes with labels, which will update along with the scaling
    to show the actual range of data. This will make it much easier to understand
    the graph.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入不同的文本，感受数据变化时条形如何更新。接下来，我们将添加带标签的坐标轴，随着缩放的变化，这些标签也会更新，以显示数据的实际范围。这样会更容易理解图表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Labeled Axes</samp>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">添加带标签的坐标轴</samp>
- en: The D3 axis helpers allow you to draw axes along the sides of your diagrams.
    An axis in D3 includes a horizontal or vertical line, with small tick marks drawn
    perpendicular to this line and the value for each tick, as shown in [Figure 14-13](chapter14.xhtml#fig14-13).
    The axis allows you to see the values in the data domain.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: D3的坐标轴辅助工具可以让你在图表的边缘绘制坐标轴。D3中的坐标轴包括一条水平或垂直的线，并且在线的垂直方向上绘制小的刻度线和每个刻度的值，正如[图14-13](chapter14.xhtml#fig14-13)所示。坐标轴让你能够看到数据域中的值。
- en: '![](../images/Figure_14-13.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: An axis for the
    numbers 0 to 8</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-13：数字0到8的坐标轴</samp>
- en: Axes are closely linked to scales, and indeed you need a scale to create an
    axis. For example, the axis in [Figure 14-13](chapter14.xhtml#fig14-13) is 540
    pixels wide and contains the numbers from 0 to 8\. This axis was created using
    a scale with a domain of [0, 8] and a range of [0, 540].
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴与刻度紧密相关，实际上你需要一个刻度来创建一个坐标轴。例如，[图14-13](chapter14.xhtml#fig14-13)中的坐标轴宽度为540像素，包含从0到8的数字。这个坐标轴是通过一个范围为[0,
    8]、值域为[0, 540]的刻度创建的。
- en: To draw an axis, you first have to define a g element that will contain the
    axis elements. You then create an axis generator object using one of the D3 axis
    helpers, and finally use the generator object to draw the axis elements into the
    g element.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制坐标轴，首先需要定义一个g元素来容纳坐标轴元素。然后，使用D3的坐标轴辅助函数之一创建一个坐标轴生成器对象，最后使用生成器对象将坐标轴元素绘制到g元素中。
- en: 'Our diagram is going to have two axes: a top axis for showing the count values,
    and a left axis for showing the character values. First, we’ll add the g elements,
    as shown in [Listing 14-34](#Lis14-34).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表将有两个坐标轴：顶部坐标轴用于显示计数值，左侧坐标轴用于显示字符值。首先，我们将添加g元素，如[Listing 14-34](#Lis14-34)所示。
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-34: Adding g elements
    for containing the top and left axes</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-34: 添加g元素来容纳顶部和左侧坐标轴</samp>'
- en: We create the top axis container ❶ by appending a g element to the svg element
    and giving it an id of "top". Because we defined the range for xScale to be [margin.left,
    width - margin.right], that will also define the visual range of the axis. xScale
    doesn’t have any knowledge of vertical positioning, however, which is why we have
    to translate it down by margin.top ❷. We store the element selection in a variable
    called topContainer so we have a reference to it for later when drawing the axis
    into the container. The left axis container is created similarly ❸, but this time
    we have to translate it to the right by margin.left ❹, since yScale has no knowledge
    of horizontal positioning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将g元素附加到svg元素并给它一个id为"top"来创建顶部坐标轴容器❶。因为我们将xScale的范围定义为[margin.left, width
    - margin.right]，这也会定义坐标轴的视觉范围。然而，xScale并不知道垂直定位，因此我们需要将其平移到margin.top ❷的位置。我们将元素选择存储在一个名为topContainer的变量中，以便在稍后绘制坐标轴时引用它。左侧坐标轴容器的创建类似❸，但这次我们需要将其平移到右边，即margin.left
    ❹，因为yScale并不知道水平定位。
- en: Now that we have the containers, we can draw the axes. Make the changes shown
    in [Listing 14-35](#Lis14-35) to the update function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了容器，可以开始绘制坐标轴。请根据[Listing 14-35](#Lis14-35)中所示的更改更新函数。
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-35: Drawing the
    axes</samp>'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-35: 绘制坐标轴</samp>'
- en: Here we call d3.axisTop, passing xScale, and d3.axisLeft, passing yScale. This
    gives us two axis generators, topAxis and leftAxis. Axis generators take a selection
    of an element and draw an axis into that element. Instead of passing a selection
    to the axis generators, however, we instead pass the generators themselves to
    a D3 method called call. This method, when chained to a selection (such as topContainer
    or leftContainer, in this case), calls the provided function on the current selection.
    Thus, writing topContainer .call(topAxis); is equivalent to writing topAxis(topContainer);,
    with either statement drawing the top axis of the bar graph. It’s considered more
    idiomatic to use call, and this makes it easier to chain other methods to the
    statement.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用d3.axisTop，传递xScale，以及d3.axisLeft，传递yScale。这为我们提供了两个坐标轴生成器，topAxis和leftAxis。坐标轴生成器接受元素的选择并将坐标轴绘制到该元素中。然而，我们并没有将选择传递给坐标轴生成器，而是将生成器本身传递给一个名为call的D3方法。当此方法与选择链式调用时（如此处的topContainer或leftContainer），它会在当前选择上调用提供的函数。因此，编写topContainer
    .call(topAxis);等同于编写topAxis(topContainer);，两者都绘制条形图的顶部坐标轴。使用call更为惯用，这使得可以更容易地将其他方法链式调用到该语句中。
- en: Reload the page and type some text in the text area. You’ll see the axes, as
    shown in [Figure 14-14](chapter14.xhtml#fig14-14).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并在文本区域输入一些文本。你将看到坐标轴，如[Figure 14-14](chapter14.xhtml#fig14-14)所示。
- en: '![](../images/Figure_14-14.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: Our bar chart,
    now with axes</samp>'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: 带有坐标轴的条形图</samp>'
- en: If you inspect the axes in the web inspector, you’ll see that they’re made up
    of g, path, text, and line elements. A line element is like a path, but it just
    defines the start and end points with the x1, x2, y1, and y2 attributes. These
    attributes default to 0 in the SVG specification, which often works just fine
    for the purposes of drawing these axes, so you’ll notice in the inspector that
    many of the line attributes aren’t set explicitly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网页检查器中检查坐标轴，你会发现它们由g、path、text和line元素组成。line元素类似于path元素，但它仅定义起始和结束点，通过x1、x2、y1和y2属性。这些属性在SVG规范中默认为0，这通常可以很好地满足绘制坐标轴的需求，因此你会注意到在检查器中许多line属性并未显式设置。
- en: There are two things that are a bit off about the top axis right now. First,
    as you can see in [Figure 14-14](chapter14.xhtml#fig14-14), the labels include
    numbers with decimal points, like 2.5, but we care only about whole numbers (you
    can’t have half a character). So, we need to find a way to render only whole numbers,
    also known as integers. Second, if you enter a string of 15 of the same character
    (for example, *aaaaaaaaaaaaaaa*), then the labels will show only even numbers
    from 0 to 14, and there won’t be a label for 15, as shown in [Figure 14-15](chapter14.xhtml#fig14-15).
    You’ll continue to see this problem as the maximum count increases, especially
    beyond 30, where the ticks switch to multiples of 5.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，顶部轴有两个地方有点问题。首先，正如你在[Figure 14-14](chapter14.xhtml#fig14-14)中看到的，标签包括带有小数点的数字，比如2.5，但我们只关心整数（你不能有半个字符）。所以，我们需要找到一种方法，仅渲染整数，也就是整数值。第二，如果你输入15个相同字符的字符串（例如，*aaaaaaaaaaaaaaa*），那么标签将只显示从0到14的偶数，并且不会有15的标签，如[Figure
    14-15](chapter14.xhtml#fig14-15)所示。随着最大计数的增加，尤其是超过30时，你会继续看到这个问题，因为刻度会切换到5的倍数。
- en: '![](../images/Figure_14-15.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: The top axis
    when the maximum count is 15</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: 最大计数为15时的顶部轴</samp>'
- en: What we’d prefer here is for the domain to extend to 16, to give a nicer-looking
    axis. Luckily, this second problem is easy to fix. D3 scales have a nice method
    that extends their domain to the next “round” number, which in this case means
    the next number for which a tick would be drawn. [Listing 14-36](#Lis14-36) shows
    how to incorporate this method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里更希望的是，让领域扩展到16，以便使轴看起来更美观。幸运的是，第二个问题很容易解决。D3比例尺有一个很好的方法，可以将它们的领域扩展到下一个“圆整”数字，这在这种情况下意味着下一个会绘制刻度的数字。[Listing
    14-36](#Lis14-36)展示了如何实现这个方法。
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-36: Making our x
    scale “nice”</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-36: 使我们的x比例尺变得“美观”</samp>'
- en: When you reload the page and again type in 15 of the same character, you’ll
    see that the axis now extends to 16\. Rendering only integers requires a little
    more effort. The basic approach here is to get the tick values, filter them to
    only integers, and then set those tick values on the axis. Additionally, we want
    to change the number rendering to exclude the decimal point, so we render 1 and
    not 1.0\. These changes are shown in [Listing 14-37](#Lis14-37).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面并再次输入15个相同的字符时，你会看到轴现在扩展到了16。仅渲染整数需要稍微多一些的努力。这里的基本方法是获取刻度值，将它们过滤为仅整数，然后将这些刻度值设置到轴上。此外，我们还希望更改数字渲染方式，排除小数点，因此我们渲染的是1，而不是1.0。
    这些变化在[Listing 14-37](#Lis14-37)中显示。
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-37: Rendering integer
    ticks on the top axis</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-37: 渲染顶部轴上的整数刻度</samp>'
- en: First we have to get the ticks, which are available using the ticks method on
    the xScale generator ❶. We then filter the ticks to integer values using Number.isInteger.
    This will convert an array like [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4] to [0, 1,
    2, 3, 4]. Next, we set the filtered tick values on the top axis using the tickValues
    method ❷. Finally, we use the tickFormat method to set a rendering format for
    the numbers ❸. This method takes a formatting function that will be used to format
    each tick value. In this case, d3.format("d") returns a function that formats
    numbers without the decimal point.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取刻度值，它们可以通过xScale生成器上的ticks方法获取❶。然后，我们使用Number.isInteger过滤刻度，得到整数值。这样可以将类似[0,
    0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4]的数组转换为[0, 1, 2, 3, 4]。接下来，我们使用tickValues方法将过滤后的刻度值设置到顶部轴上❷。最后，我们使用tickFormat方法设置数字的渲染格式❸。该方法接受一个格式化函数，用来格式化每个刻度值。在这种情况下，d3.format("d")返回一个格式化函数，格式化时不会带小数点。
- en: Reload the page and enter some text again; you should see whole numbers rendered
    without the decimal point.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并再次输入一些文本，你应该看到渲染的整数不带小数点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling with CSS
    and Regular Expressions</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用CSS和正则表达式进行样式设置</samp>
- en: Next we’re going to improve the appearance of our graph with some CSS styles.
    In order to better differentiate the types of characters, we’ll give different
    colors to the bars depending on whether they’re lowercase letters, uppercase letters,
    numbers, or any other character. To do this, we’ll need a function that can distinguish
    between these types of characters. The function will use *regular expressions*,
    which are a way of specifying patterns in strings of text and then determining
    if other strings match those patterns.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一些 CSS 样式改善图表的外观。为了更好地区分字符类型，我们将根据字符是小写字母、大写字母、数字还是其他字符来为条形图赋予不同的颜色。为此，我们需要一个能够区分这些字符类型的函数。该函数将使用*正则表达式*，它是一种在文本字符串中指定模式并判断其他字符串是否匹配这些模式的方式。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*JavaScript’s regular expression capabilities are very powerful, but we’ll
    be considering only the features we need for this project. To learn more, check
    out the website* [https://www.regular-expressions.info](https://www.regular-expressions.info),
    *or search MDN for “regular expressions.”*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 的正则表达式功能非常强大，但我们仅会考虑本项目所需的功能。想要了解更多，可以访问网站* [https://www.regular-expressions.info](https://www.regular-expressions.info)，*或在
    MDN 上搜索 “regular expressions”。*'
- en: JavaScript has a regular expression literal syntax that is delimited by forward
    slashes. For example, /hi/ is a regular expression literal that matches any string
    containing the sequence of characters *hi*. The *hi* can occur anywhere in the
    string. For example, the regular expression /hi/ would match the words *hither*,
    *Chicken*, and *sushi*. You can more narrowly define a regular expression’s pattern
    by adding special characters. For example, a caret (^) at the start of an expression
    indicates the character sequence should occur at the start of a string, so /^hi/
    matches any string that starts with *hi*. Similarly, a dollar sign ($) at the
    end of an expression indicates the character sequence should occur at the end
    of a string, so /hi$/ matches any string that ends with *hi*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有一种正则表达式字面量语法，由斜杠分隔。例如，/hi/ 是一个正则表达式字面量，匹配任何包含字符序列 *hi* 的字符串。*hi*
    可以出现在字符串的任何位置。例如，正则表达式 /hi/ 会匹配单词 *hither*、*Chicken* 和 *sushi*。你可以通过添加特殊字符来更精确地定义正则表达式的模式。例如，插入一个插入符号
    (^) 表示字符序列应出现在字符串的开头，因此 /^hi/ 匹配任何以 *hi* 开头的字符串。类似地，插入一个美元符号 ($) 表示字符序列应出现在字符串的末尾，因此
    /hi$/ 匹配任何以 *hi* 结尾的字符串。
- en: 'You can use the test method on a regular expression to see if a particular
    string matches it. Here are some examples in the JavaScript console:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用正则表达式的 test 方法来查看某个特定的字符串是否与其匹配。以下是一些 JavaScript 控制台中的示例：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The string "hi there" passes the test, because *hi* appears at the beginning
    of the string, whereas "Chicken" fails.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 "hi there" 通过了测试，因为 *hi* 出现在字符串的开头，而 "Chicken" 没有通过。
- en: 'You can use ^ and $ together to create a regular expression where the full
    string must match. For example, /^hi$/ will match only the string "hi" and nothing
    else, as you can see here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时使用 ^ 和 $ 来创建一个必须完全匹配字符串的正则表达式。例如，/^hi$/ 只会匹配字符串 "hi" 而不会匹配其他任何内容，如下所示：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To match a range of characters instead of a single character, use square brackets
    and a hyphen to describe the range. For example, /[a-z]/ matches any lowercase
    character from *a* to *z*. The regular expression /^[A-Z][a-z]$/ matches a string
    containing an uppercase letter followed by a lowercase letter, and no other characters.
    Try it out in your console:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一系列字符而不是单个字符，可以使用方括号和连字符来描述范围。例如，/[a-z]/ 匹配任何从 *a* 到 *z* 的小写字符。正则表达式/^[A-Z][a-z]$/
    匹配一个包含大写字母后跟小写字母的字符串，并且不包含其他字符。在控制台中尝试一下：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For this project, we need three regular expressions: /^[a-z]$/ (matching a
    single lowercase letter), /^[A-Z]$/ (matching a single uppercase letter), and
    /^[0-9]$/ (matching a single digit). If a character doesn’t match any of those
    expressions, we’ll know it’s some other kind of character, like a space or a punctuation
    mark. See [Listing 14-38](#Lis14-38) for the new getClass function, which uses
    those regular expressions to choose a CSS class name for a given character’s bar.
    Add this function to *script.js* immediately before the update function.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要三个正则表达式：/^[a-z]$/（匹配单个小写字母），/^[A-Z]$/（匹配单个大写字母），和/^[0-9]$/（匹配单个数字）。如果一个字符不匹配任何一个表达式，我们就知道它是其他类型的字符，比如空格或标点符号。请参见[清单14-38](#Lis14-38)，它展示了新的getClass函数，该函数使用这些正则表达式为给定字符的条形图选择CSS类名。将这个函数添加到*script.js*文件中，放在更新函数之前。
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-38: The getClass
    function</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-38：getClass函数</samp>
- en: 'This function tests a character against the provided regular expressions and
    returns the appropriate class name: "lower", "upper", "number", or "other". Next,
    we’ll update the rendering code to use this function to set a class name on each
    rect element, as shown in [Listing 14-39](#Lis14-39).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将字符与提供的正则表达式进行匹配，并返回相应的类名："lower"（小写字母）、"upper"（大写字母）、"number"（数字）或"other"（其他）。接下来，我们将更新渲染代码，使用这个函数为每个rect元素设置类名，如[清单14-39](#Lis14-39)所示。
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-39: Applying the
    class name based on the character</samp>'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-39：根据字符应用类名</samp>
- en: Now every rect element will have a class name based on the character from that
    element’s datum. The last step is to write the CSS that will give each class name
    a different fill color. Add the CSS code in [Listing 14-40](#Lis14-40) to *style.css*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个rect元素都会根据该元素数据中的字符来设置类名。最后一步是编写CSS，为每个类名分配不同的填充颜色。将[清单14-40](#Lis14-40)中的CSS代码添加到*style.css*文件中。
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-40: Defining styles
    for the different classes</samp>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-40：为不同类别定义样式</samp>
- en: Now when you reload the page and type in some different characters, you should
    see something like [Figure 14-16](chapter14.xhtml#fig14-16).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你重新加载页面并输入一些不同的字符时，你应该会看到类似于[图14-16](chapter14.xhtml#fig14-16)的效果。
- en: '![](../images/Figure_14-16.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_14-16.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-16: Color-coded bars</samp>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-16：颜色编码条形图</samp>
- en: The bars should be assigned different colors based on the kind of character
    entered.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图应根据输入的字符类型分配不同的颜色。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cleaning the Data</samp>
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">清理数据</samp>
- en: Often it’s necessary to clean a dataset by fixing any mistakes or irregularities
    it contains before visualizing it. For example, one problem with the current approach
    to our bar graph is that different whitespace characters show up as different
    bars, each with an invisible label (because the text of the label is just whitespace).
    These whitespace characters include spaces, newlines, tabs, and various other
    kinds of spaces that you can type with different key combinations (for example,
    a non-breaking space, which you can enter with OPTION-spacebar on macOS or CTRL-SHIFT-spacebar
    on Windows). To fix this, we’ll convert all whitespace characters to the same
    "<space>" string before the character counting, so all whitespace will be visualized
    by a single bar with a readable label. Update your *script.js* file as shown in
    [Listing 14-41](#Lis14-41). These updates come near the end of the file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在将数据集可视化之前，需要通过修正其中的错误或不规则性来清理数据。例如，目前条形图方法的一个问题是，不同的空白字符显示为不同的条形图，每个条形图都有一个不可见的标签（因为标签文本只是空白）。这些空白字符包括空格、换行符、制表符和其他可以通过不同键盘组合输入的空格字符（例如，在macOS上可以通过OPTION+空格键输入不间断空格，Windows上则是CTRL-SHIFT+空格键）。为了解决这个问题，我们将在字符计数之前将所有空白字符转换为相同的"<space>"字符串，这样所有空白字符将通过一个带有可读标签的条形图进行可视化。按照[清单14-41](#Lis14-41)中所示更新你的*script.js*文件。这些更新出现在文件的末尾。
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-41: Standardizing
    whitespace characters</samp>'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-41：标准化空白字符</samp>
- en: We first declare a standardizeSpace function that takes a character and calls
    the trim method on it ❶. The trim method removes whitespace at the start or end
    of a string, so if it returns an empty string, we know the character is whitespace.
    In this case, we return the string "<space>". Otherwise, we return the character
    unchanged. We then have to modify the text processing code to call our function
    and standardize the whitespace characters ❷ before using them as keys in the frequencies
    object.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个standardizeSpace函数，该函数接受一个字符并调用其trim方法❶。trim方法会移除字符串开头或结尾的空白字符，因此，如果返回一个空字符串，我们知道该字符是空白字符。在这种情况下，我们返回字符串"<space>"。否则，我们返回未改变的字符。然后，我们需要修改文本处理代码，在将空白字符作为频率对象中的键使用之前调用我们的函数来标准化它们❷。
- en: Now when you enter various kinds of whitespace characters in the text area,
    you should see a single bar labeled <space> instead of multiple bars with empty
    labels.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在文本区域中输入各种类型的空白字符时，你应该会看到一个标签为<space>的单一条形图，而不是多个带有空标签的条形图。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Animating the Changes</samp>
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">动画化变化</samp>
- en: Our final task is to add animations to the axes and bars. This will make it
    easier to see when new elements are added and when the counts for existing elements
    change. To animate the axes, all we need to do is add a call to transition to
    the topContainer and leftContainer selections inside the update function, as shown
    in [Listing 14-42](#Lis14-42).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是为坐标轴和条形图添加动画。这将使我们更容易看到何时添加新元素，以及现有元素的计数何时变化。为了动画化坐标轴，我们只需在更新函数内对topContainer和leftContainer选择添加一个过渡调用，如[Listing
    14-42](#Lis14-42)所示。
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-42: Adding animations
    to the axes</samp>'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-42: 为坐标轴添加动画</samp>'
- en: Now when the domains for the axes update to accommodate new data, the existing
    ticks will animate to their updated positions, and new ticks will fade in.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当坐标轴的域更新以适应新数据时，现有的刻度将动画化到其更新后的位置，新的刻度会逐渐显现。
- en: 'We have two options for adding transitions to the bars: we could keep the existing
    join code and just add a single call to transition, or we could use the advanced
    join technique described earlier, which would let us customize the transitions
    depending on whether the elements are entering, updating, or exiting. As you might
    guess, we’re going to go with the advanced version! You can find the updated update
    code in [Listing 14-43](#Lis14-43).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以为条形图添加过渡效果：我们可以保留现有的连接代码，只需添加一个过渡调用，或者我们可以使用前面提到的高级连接技术，这样我们就可以根据元素是进入、更新还是退出来定制过渡效果。正如你可能猜到的，我们将选择高级版本！你可以在[Listing
    14-43](#Lis14-43)中找到更新后的更新代码。
- en: '[PRE55]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-43: Animating the
    bars</samp>'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-43: 动画化条形图</samp>'
- en: The first thing we have to do is set a key function ❶ to tell D3 that the datum’s
    char property should be used as its identifier. Next, we switch to the advanced
    join technique, similar to [Listing 14-25](#Lis14-25). The enter function ❷ first
    adds the rect element and sets its x, y, and class attributes before the call
    to transition, meaning that these attributes won’t be animated. The width and
    height attributes come after the call to transition, so these attributes *will*
    be animated. This way, new elements will grow in place from the left axis.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是设置一个关键函数❶，告诉D3数据项的char属性应该作为标识符来使用。接下来，我们切换到类似于[Listing 14-25](#Lis14-25)的高级连接技术。enter函数❷首先添加rect元素，并在调用过渡之前设置其x、y和class属性，这意味着这些属性不会被动画化。宽度和高度属性是在过渡调用之后设置的，所以这些属性*会*被动画化。这样，新元素将在左侧坐标轴处从当前位置生长出来。
- en: The update function ❸ animates the width and height again, but also animates
    the y attribute. This means that existing elements will slide up or down to their
    new position when new elements are added.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: update函数❸再次动画化宽度和高度，同时还会动画化y属性。这意味着当新元素添加时，现有元素会向上或向下滑动到它们的新位置。
- en: Finally, the exit function ❹ animates the width and height to 0 before the element
    is removed, causing elements to shrink away to nothing at their previous position.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出函数❹在元素被移除之前将宽度和高度动画化到0，导致元素在原位置缩小消失。
- en: Reload the page and try adding and removing characters in the text area. Enjoy
    watching how the elements animate in, out, or update.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面，尝试在文本区域中添加和删除字符。享受观察元素是如何进入、退出或更新的动画效果。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned the basics of SVG, and how to use D3 to create,
    update, and remove SVG elements based on real-time changes in a dataset. By now,
    you should have a pretty good understanding of how to build a data-based application
    in D3\. In the next chapter, we’ll put this knowledge to work by building an application
    that reads data from an API and renders it into an interactive diagram.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了SVG的基础知识，以及如何使用D3根据数据集中的实时变化来创建、更新和移除SVG元素。到现在为止，你应该已经对如何在D3中构建基于数据的应用程序有了相当清晰的了解。在下一章，我们将通过构建一个从API读取数据并将其渲染成交互式图表的应用程序，将这些知识付诸实践。
