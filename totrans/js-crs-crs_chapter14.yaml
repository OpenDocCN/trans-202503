- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCING
    THE D3 LIBRARY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: Today’s world is full of data, but raw data is basically impossible to understand
    without visualizing it in some way. Data visualizations can be incredibly simple,
    such as a chart on Wikipedia showing the average temperature each month in a particular
    city, or highly intricate, such as an animated infographic from a news organization
    illustrating the income mobility of tens of thousands of Americans. No matter
    the level of complexity, however, data visualizations always have the potential
    to give us more insight into the data we’re exploring.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll learn to use a powerful JavaScript library called D3.js
    (or D3 for short), which will enable you to create a whole range of data visualizations
    in the browser. The great thing about using JavaScript to make data visualizations
    is that they can be dynamic and interactive. *Dynamic* means the visualization
    can change over time; for example, they can be updated as new data comes in. *Interactive*
    means the user can manipulate the visualization, for example, by clicking to reveal
    more detail about a particular aspect. Also, because you’re coding up the visualizations
    yourself, you’re free to customize them in any way you want.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the basics of working with D3, to prepare you
    for the next chapter, where you’ll create an interactive visualization by loading
    data from an external API. D3 primarily uses a web graphics technology called
    Scalable Vector Graphics (SVG), so we’ll start with a crash course in SVG before
    we dive into D3 itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SVG Graphics Format</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SVG is a way of defining images using points, lines, and curves, rather than
    pixels. These images are known as *vector graphics*. Because you’re defining the
    *shape* of the image rather than the individual pixels themselves, you can resize
    or zoom in on an SVG image without it becoming pixelated (hence the *scalable*
    part of the name).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: SVG is based on Extensible Markup Language (XML), a language for storing data
    that, like HTML, relies on a structure of nested elements with start and end tags.
    SVG XML looks similar to HTML, but it has its own set of tags that correspond
    directly to visual elements (in HTML, by contrast, the tags are used to define
    structure and content). SVG files can be standalone XML files, but SVG can also
    be embedded in an HTML file using the HTML svg element, making it easy to add
    SVG graphics to a web page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of SVG over the Canvas API for rendering interactive graphics
    on the web is that each element of an SVG drawing is represented by a DOM element
    on the web page, which means you can style it with CSS and use JavaScript to add
    event handlers to respond to mouse events like clicks or hovers. On the other
    hand, Canvas-based graphics are faster to render, so applications like games that
    need a high frame rate tend to use the Canvas API rather than SVG.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与Canvas API在Web上渲染互动图形相比，SVG的一个优势是，SVG图形的每个元素都由Web页面上的DOM元素表示，这意味着你可以使用CSS对其进行样式设置，并使用JavaScript添加事件处理程序来响应鼠标事件，如点击或悬停。另一方面，基于Canvas的图形渲染速度更快，因此需要高帧率的应用程序，如游戏，通常会使用Canvas
    API而非SVG。
- en: Let’s write our first SVG. Make a new directory called *svg* and create an *index.html*
    file in that directory containing the content of [Listing 14-1](#Lis14-1). We’ll
    embed our SVG in this HTML file. Also create two empty files in the same directory,
    called *style.css* and *script.js*—we’ll fill those in later when we’re ready
    to style the SVG and make it interactive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个SVG。创建一个名为*svg*的新目录，并在该目录中创建一个包含[列表14-1](#Lis14-1)内容的*index.html*文件。我们将在这个HTML文件中嵌入我们的SVG。同时，在相同目录下创建两个空文件，分别命名为*style.css*和*script.js*——我们稍后会在准备好为SVG添加样式并使其具互动性时填充这些文件。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring SVG</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表14-1：用于探索SVG的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: The code in [Listing 14-1](#Lis14-1) follows our standard HTML template, with
    an empty svg element added ❶. The svg element is given a width and height of 600
    pixels. When you load the page in your browser, it should be blank, because we
    haven’t added content to our SVG yet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-1](#Lis14-1)中的代码遵循我们的标准HTML模板，并添加了一个空的svg元素❶。该svg元素的宽度和高度被设置为600像素。当你在浏览器中加载该页面时，它应该是空白的，因为我们还没有在SVG中添加内容。'
- en: Now let’s add some graphics. We’ll add a rectangle and some text to the svg
    element, as shown in [Listing 14-2](#Lis14-2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些图形。我们将在svg元素中添加一个矩形和一些文本，如[列表14-2](#Lis14-2)所示。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Adding graphics
    to the svg</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">element</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表14-2：将图形添加到svg</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">元素</samp>
- en: Everything inside the <svg> and </svg> tags is SVG XML, which has its own set
    of tag names. In this example, we use the rect ❶ and text ❷ elements. The rect
    element draws a rectangle, according to the specifications set through the element’s
    attributes. We set the width and height to 95 pixels and 20 pixels, respectively,
    and its x- and y-coordinates (the location of the top-left corner of the rectangle)
    to (5, 5). We set the outline to red using the stroke attribute and give it no
    fill color (the default fill color is black). The rect element doesn’t contain
    any content, so the opening tag is immediately followed by the closing tag.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位于<svg>和</svg>标签之间的内容都是SVG XML，它有自己的一套标签名称。在这个示例中，我们使用了rect❶和text❷元素。rect元素根据通过元素属性设置的规范绘制矩形。我们将宽度和高度分别设置为95像素和20像素，并将其x和y坐标（矩形左上角的位置）设置为(5,
    5)。我们使用stroke属性将轮廓设置为红色，并将填充颜色设置为无（默认填充颜色为黑色）。rect元素不包含任何内容，因此起始标签后立即跟随结束标签。
- en: Similarly, we use the text element to insert text into the drawing. The text
    element also uses x and y attributes to set its position, but in this case they
    refer to the start of the *baseline* of the text. In typography, the baseline
    is the invisible line that runs along the bottom of most letters, excluding those
    with descenders like *p* or *g*. By default, the x attribute gives the horizontal
    position of the start of the text. We set the font of the text to the default
    sans-serif font using the font-family attribute. The content of the text element
    is the actual text that will be drawn, in this case “Hello, SVG!”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们使用文本元素将文本插入到图形中。文本元素也使用x和y属性来设置其位置，但在这种情况下，它们指的是文本的*基线*起始位置。在排版中，基线是沿大多数字母底部延伸的隐形线，排除像*p*或*g*这类有下行部分的字母。默认情况下，x属性给出文本起始位置的水平坐标。我们使用font-family属性将文本的字体设置为默认的无衬线字体。文本元素的内容是实际会被绘制的文本，在此案例中为“Hello,
    SVG!”。
- en: When you reload the page, you should see this text surrounded by a red-outlined
    rectangle, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Our first SVG
    drawing</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Try zooming in on the page (using CTRL-+ on Windows or Linux, or COMMAND-+ on
    macOS). The rectangle and text should remain sharp, even as you scale the image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grouping Elements</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can group multiple SVG elements together by nesting them inside a g (for
    *group*) element. This is useful because any attributes set on the g element itself
    will apply to all its child elements. To demonstrate, update the contents of your
    svg element as shown in [Listing 14-3](#Lis14-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Grouping elements
    with the g element</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a group with three child text elements, each containing
    a single word. The text elements have the same x-coordinate but different y-coordinates,
    so the words will be vertically stacked and left-aligned. The attributes of the
    parent g element (font-family and fill ❶) apply to all the child elements in the
    group. Reload the page and you should see that all three words are blue and in
    a sans-serif font.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating groupings with g elements also lets you apply *transformations* to
    all the child elements in a group. SVG supports several kinds of transformations,
    including translation, rotation, scaling, and skewing. We’ll use translate to
    move all the elements by a fixed amount. Update *index.html* with the following
    change to the opening g element tag:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The transform attribute takes a list of transformations, separated by spaces.
    Here we’re passing a single transformation: translate(100, 50). This says to move
    all the elements in the group 100 pixels along the x-axis and 50 pixels down the
    y-axis.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also resize the group by adding a scale transformation after the translate
    transformation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the translation, the elements are now scaled horizontally by a factor
    of 2 and vertically by a factor of 3, as shown in [Figure 14-2](chapter14.xhtml#fig14-2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Transforming grouped
    elements</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: All the transformations are relative to the origin (0, 0), unless an earlier
    translation has moved the origin. This means the scaling affects the placement
    of elements, as well as their size. For example, when you scale a square with
    a top-left corner of (10, 10) and a bottom-right corner of (30, 30) by 2, the
    new corners will be at (20, 20) and (60, 60). The x- and y-coordinates relative
    to the origin are all doubled.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Circles</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can draw an SVG circle using the circle element. The attributes cx and cy
    set the coordinates for the center of the circle, and r sets the radius. To try
    it out, replace the content of the svg element with the code in [Listing 14-4](#Lis14-4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Drawing circles</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we’re using the new circle element, as well as the g and rect
    elements. The first circle ❶ has a fill color of #faa0a0, or salmon pink, a radius
    of 100 pixels, and center coordinates (124, 130). Note that we’re using *hex colors*
    here—see the “Hex Colors” box on the following page to learn more. Next, we use
    a group ❷ to apply a standard stroke color (chestnut brown) and width (3 pixels)
    to a rectangle and three smaller circles, with fill colors green, yellow, and
    rose. The effect of all this is a cute illustration of some Japanese *hanami dango*
    (a sweet treat popular in Japan during cherry blossom season), as shown in [Figure
    14-3](chapter14.xhtml#fig14-3).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: An illustration
    of hanami dango using SVG circles</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the order in which elements are declared defines the order in which
    they’re drawn. The three small circles are declared from bottom to top, so in
    places where they overlap, the upper circle appears on top. Likewise, since the
    large circle is declared first, it’s treated as a background for the rest of the
    illustration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Paths</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The path element is the most powerful SVG element of all, allowing you to create
    custom shapes by drawing straight or curved lines (“paths”) between different
    points. The d attribute of a path element (short for *data*) is a string containing
    the path definition, which is a list of path commands. The syntax of this string
    is optimized to be as compact as possible, so complex paths can be represented
    using relatively short strings. This is good for computers, but not good for humans;
    don’t expect these strings to be easily readable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the next example we’re going to re-create the HTML5 logo with path elements,
    starting with the outer shield shape. Replace the content of the svg element in
    *index.html* with the code in [Listing 14-5](#Lis14-5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: Drawing the HTML5
    logo shield</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive deep into the path definition, it’ll help to know what the result
    is supposed to look like. Reload the page, and you should see the shield design
    shown in [Figure 14-4](chapter14.xhtml#fig14-4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The HTML5 logo
    shield</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'This design is made of two paths, one for the darker main shield shape, and
    one for the lighter highlight on the right half of the shield shape. Let’s look
    at the path definition for the darker part:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are six instructions here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: M 0 0
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H 182
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L 165 185
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L 90 206
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L 17 185
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of these commands as moving an imaginary pen around the screen to draw
    lines. The M command takes a position as an (x, y) coordinate pair and moves the
    pen to that position without drawing anything. The H command takes an x-coordinate
    and draws a horizontal line from the current pen position to that value of x.
    The L command takes an (x, y) coordinate pair and draws a line from the current
    position to that position. Finally, the Z command closes the path, drawing a line
    from the current position back to the start of the path. In English, the commands
    in the path say, “Move to (0, 0), draw a horizontal line to (182, 0), draw a line
    to (165, 185), draw a line to (90, 206), draw a line to (17, 185), then draw a
    line back to (0, 0) to close the path.” The second path uses the same technique
    to draw the inner highlight on the shield, using a different fill color.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'These commands define the points to move to using *absolute positions*, exact
    x- and y-coordinates. However, there’s an alternative version of each command
    that takes a relative position instead, meaning the next point is defined in relation
    to the current position of the pen. The absolute commands all use uppercase letters,
    and the relative ones use the same letters but lowercase. For example, the path
    definition we just looked at could be rewritten using relative path commands like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the move command is the same because there’s no previous position
    to be relative to. The command h 182 says to draw a horizontal line 182 units
    to the right of the current position. The command l -17 185 says to draw a line
    17 units to the left and 185 down from the current position, and so on. The Z
    and z commands do the same thing and are just included in the SVG spec for completeness.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, this relative path definition can be written even more compactly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spaces are needed only to avoid ambiguity between two numbers, but are otherwise
    optional in SVG paths. Thanks to all the negative numbers, we’re able to remove
    almost all the spaces here. Also, if the same command is used multiple times in
    a row, you can include it once and then just keep providing numbers. For example,
    l-17 185-75 21-73-21 is the compact version of l -17 185 l -75 21 l -73 -21.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The SvgPathEditor (*[https://yqnn.github.io/svg-path-editor/](https://yqnn.github.io/svg-path-editor/)*)*
    *is a very helpful tool for experimenting with and manipulating paths, and for
    converting between absolute and relative commands (it’s what I used here to convert
    between the two forms). SVG has several additional path commands, mostly for drawing
    various types of curves. We won’t go into those here, but you can find a full
    list on MDN at* [https://developer.mozilla.org/SVG](https://developer.mozilla.org/SVG).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how path definitions work, we can add more paths to
    fill in the rest of the HTML5 logo. Update the content of the svg element as shown
    in [Listing 14-6](#Lis14-6) (though I won’t think any less of you if you decide
    this is too much typing!).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Completing the
    HTML5 logo</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'I used relative path commands here partly for variety, and partly because the
    relative numbers were smaller and made for shorter lines. When you reload the
    page, you should see the complete HTML5 logo, as shown in [Figure 14-5](chapter14.xhtml#fig14-5).
    The two paths with the fill color #ebebeb (light gray) draw the two parts of the
    left side of the 5, and the two paths with the fill color #fff (white) draw the
    two parts of the right side of the 5.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: The complete HTML5
    logo</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In general, you won’t have to manually type out your own path definitions when
    you’re creating data visualizations. D3 will create them for you. Still, it’s
    helpful to understand the syntax so you can tell what’s going on when you’re debugging.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling Elements
    with CSS</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you embed SVG in your HTML file, each SVG element becomes part of the DOM,
    so it can be styled with CSS. To see how this works, we’ll draw some SVG shapes
    and give them all class names. Replace the content of the svg element with the
    code in [Listing 14-7](#Lis14-7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Some SVG elements
    with class names</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re drawing a circle, a square, and a triangle, and then another circle,
    square, and triangle. Notice that the triangles are drawn as paths—there’s no
    dedicated triangle element like rect or circle. The first three shapes have the
    class name boring, and the second three have the class name fun. When you reload
    the page you should see two rows of three shapes, all with the same default black
    fill, as shown in [Figure 14-6](chapter14.xhtml#fig14-6).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: SVG shapes, without
    style</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll style the shapes. Because they all have class names, we can select
    them in CSS, just like we’d select HTML elements. Add the code in [Listing 14-8](#Lis14-8)
    to your *style.css* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Styles for the
    shapes</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In this listing, we’re giving different styles to the two classes: .boring
    gets a simple black outline, and .fun gets a pink fill and a thick dashed green-yellow
    outline. Note that the property names for styling SVG elements aren’t the same
    as for HTML elements. For example, HTML elements use background-color and border-color,
    while SVG elements use fill and stroke.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that you could also apply these styles directly to the SVG
    elements as attributes in the *index.html* file. The advantage of using CSS is
    twofold: first, it means that all your styling information is in one place, so
    it’s easily updatable, and second, to style several elements the same way you
    only need to add a class name to each element, as opposed to copying all the attributes
    from one element to another.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page, you should notice that your shapes now have some style,
    as shown in [Figure 14-7](chapter14.xhtml#fig14-7).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-7.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: SVG shapes, with
    style</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to use pseudo-classes like :hover on SVG elements. Add the
    code in [Listing 14-9](#Lis14-9) to the end of *style.css* to try this out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Adding a hover
    effect</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re swapping the fill and stroke color when the mouse hovers over one
    of the .fun elements. Reload the page and see for yourself!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the great advantages of SVG over the Canvas API: the browser
    knows about the SVG elements, and it knows, for example, when the mouse is hovering
    over them. Compare this with the canvas, where the browser just knows that some
    colored pixels have been drawn, and any mouse hover effects have to be explicitly
    coded in JavaScript.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Interactivity
    with JavaScript</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use JavaScript to add interactivity to our SVG elements, just as we can
    use CSS to style them. Again, this is possible because each SVG element embedded
    in the HTML becomes part of the DOM. To start with, we’ll just write a script
    that selects the elements and logs them to the console, as a refresher on JavaScript
    DOM methods. Add the code in [Listing 14-10](#Lis14-10) to the currently empty
    *script.js*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Selecting the
    .fun elements</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we’re using the querySelectorAll method to select all the elements
    with the class name fun. We then use the forEach method to iterate over the selected
    elements and log them to the console. When you run this code, you should see the
    three elements logged to the console on separate lines. If you hover over each
    element in the console, that element should also be highlighted on the web page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add some interactivity. The changes to *script.js* in [Listing 14-11](#Lis14-11)
    will make it so when you click one of the elements, that element will move to
    the right, and when you hold down SHIFT and click, the element will move to the
    left.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Moving SVG elements
    on click</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Inside the forEach method call, we’re doing two things to each element. First,
    we set something called a *data attribute* on each element. Data attributes are
    HTML or SVG attributes that are just used for storing data in the DOM; their names
    all start with the string "data-". Specifically, we create the data-offset data
    attribute, which we’ll use to keep track of how to position each element, and
    set its value to 0 ❶. Note that DOM attributes are always stored as strings, so
    the number 0 will be converted to the string "0".
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Next, we attach a click event handler to each element ❷. The first thing the
    handler does is extract the data-offset attribute from the clicked element, using
    getAttribute, and store its value in the variable offset ❸. The clicked element
    is available as the target property on the event object. Note that we use the
    Number function here to convert the string into a number. The first time this
    handler is called, the variable offset will be set to 0, as that is the initial
    value we stored in the data-offset attribute ❶.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We use the shiftKey property on the event to determine if the SHIFT key was
    pressed when the mouse was clicked. If it was, we subtract 5 from offset. Otherwise,
    we add 5 to offset. We then assign the updated value to the data-offset attribute
    using setAttribute ❹. Finally, we use the setAttribute method again, but this
    time to set the transform SVG attribute ❺. As you saw earlier in this chapter,
    we can use transform to translate an element by some distance, with the string
    translate(x, y). Here we’re setting the x value of the translation to the value
    of offset and the y value of the translation to 0\. This means that if offset
    is a positive value the element will move to the right, and if it’s a negative
    value the element will move to the left.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page, the colorful SVG elements should now move when you
    click them. If you right-click one of the elements and select Inspect, you’ll
    see that element in the Elements panel. As you click different elements in the
    browser viewport, you should see the data-offset and transform attributes update
    in the Elements panel.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The D3 Library</samp>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have an understanding of the basics of SVG, you can start to learn
    about the D3 library, which leverages SVG and JavaScript to create data visualizations.
    *D3*, short for *Data-Driven Documents*, gives you the ability to create documents
    whose contents are driven by data. It does this through a technique called *data
    binding*, where individual parts of the underlying data you want to visualize
    are linked to individual elements on the page. This way, if the data changes,
    the elements change as well. You’ll see how that works later in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setup</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll create a new set of files to explore D3\. Make a new directory called
    *data*, containing an empty *script.js* file and an *index.html* file with the
    content in [Listing 14-12](#Lis14-12).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: A new</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    working with D3</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: First we create an svg element ❶ and draw three circles. Then we use a script
    element to link to a copy of the D3 library hosted on [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com)
    ❷, much like we did with Tone.js for the music project. Now you’ll be able to
    use code from D3 in your *script.js* file. When you load the page, you should
    see three black circles. Soon we’ll manipulate those circles with D3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selections</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of D3’s basic building blocks is the *selection*, a way to pick out a group
    of elements so you can apply certain operations to those elements. Let’s use D3
    to select the three SVG circles and change their fill color to hot pink. Add the
    code in [Listing 14-13](#Lis14-13) to *script.js*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Selecting the
    circles</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The d3.selectAll method takes a CSS selector, in this case the element name
    circle, and returns a D3 selection, on which you can chain more method calls.
    Those chained method calls will apply to all the elements matching the selector.
    Here we’re setting the "fill" attribute of every element in the selection to "hotpink".
    When you reload the page, you should see that the black circles are now pink.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to use a function instead of a value when updating elements
    in a selection. When you do this, the function is called and its return value
    is used as the value for updating these elements. This gives you the ability to
    modify elements dynamically. Update the *script.js* code with the changes in [Listing
    14-14](#Lis14-14) to see how it works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Computing values
    with functions</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: With long method chains like this, it’s common to split the code across multiple
    lines for readability. As before, we’re selecting all the circles and setting
    their fill color to hot pink, but this time we’re also updating each circle’s
    radius ❶. The function used for generating the value here has two parameters,
    d and i. We’ll cover the d parameter, short for *datum*, in the next section.
    i, short for *index*, is the index of the element in the selection (the first
    circle will have an index of 0, the second 1, and so on). We’re using the code
    10 + i * 5 to give each circle a different radius, based on their index numbers.
    Specifically, the circles will have radii of 10, 15, and 20\. When you reload
    the page, you should see the three circles are now all different sizes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*D3 selection modification methods like .attr return the selection itself.
    This lets us keep chaining modification methods, as we do with the two .attr calls
    in [Listing 14-14](#Lis14-14).*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: If you want to select a single element rather than a group, use the d3.select
    method instead of d3.selectAll. For example, to insert an h1 element into the
    body element of your HTML, you could add the code in [Listing 14-15](#Lis14-15)
    to the end of your *script.js* file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Using select
    to select a single element</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we first select the body element. We then call insert on this
    selection, passing two arguments, "h1" and "svg". The first argument is the type
    of element to insert, and the second is the element before which to insert it.
    The insert method returns a new selection containing the inserted element, and
    the text method adds text content to elements in that selection (in this case,
    the single h1 element). When you reload the page, you should see a heading above
    the SVG element with the text “Hello, D3!” This example also illustrates the fact
    that D3 selections can apply to both HTML and SVG elements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Binding</samp>
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps the most important feature of D3 is its concept of data binding. In
    a D3-based application, you’ll have some data that you’re attempting to visualize.
    Each individual piece of the data, called a datum, will be bound to an individual
    element on the page (usually an SVG element). You use the datum to set some attribute
    of the element it’s bound to, so the element visually reflects the datum.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we’ll look at how to bind data to preexisting SVG elements. Keep
    the circles in *index.html*, but replace the content of *script.js* with the code
    in [Listing 14-16](#Lis14-16).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Binding data
    to our circles</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We first create an array of numbers to use as data. Then we create a selection
    of all the circle elements. The data method ❶ binds the array of numbers to the
    selection of circles, one by one, so the first circle element has the value 3
    bound to it, the second 2, and the third 1. Finally, we use the attr method to
    set the radius of each circle to a computed value based on the bound data. As
    you saw in the previous section, if you use a function instead of a value to set
    an attribute, that function will be called to compute the value for each element
    in the selection. The d parameter of the function corresponds to the datum bound
    to the current element.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page, you should see three black circles that get smaller
    from left to right. To confirm that everything is working as expected, right-click
    the first circle and select **Inspect** to show the element in the Elements panel.
    You should see its r attribute set to 15, which is what we’d expect from d * 5
    where d is 3.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to directly see the datum set on an element using the Inspect
    tool, which can be very helpful for debugging, especially when your data is more
    complex than simple numbers. All you need is a reference to the element, which
    is easy to get through the Chrome console. Again, right-click the first circle
    and select **Inspect**. You should see something like [Figure 14-8](chapter14.xhtml#fig14-8).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-8.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: Selecting a circle
    element in the Elements panel</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the selected line you should see the text == $0. This is an indication
    that a reference to the circle element is stored under the global variable named
    $0. To verify that this is the case, open the JavaScript console and enter $0:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The console prints the circle element you selected, indicating that $0 is indeed
    a reference to that element. Now that you have that reference, you can see the
    datum bound to it using the __data__ property:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells you the circle is bound to the value 3, the first number from our
    array, just as we’d expect. $0 always references the currently selected element,
    so if you right-click and inspect a different circle, entering $0.__data__ in
    the console again will give you the datum bound to that other circle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Joins</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You don’t always know exactly how long your data is going to be, so it would
    be difficult to always have exactly the right number of SVG elements ready to
    bind to your data. D3 solves this problem with the concept of *joins*. In D3,
    you use a join to add or remove the necessary elements to match the data being
    bound.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We can extend our example from [Listing 14-16](#Lis14-16) with a join so that
    SVG circle elements will be added or removed as needed, depending on the length
    of the numbers array. Update the *script.js* file as shown in [Listing 14-17](#Lis14-17).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: Joining in extra
    elements</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve create a longer array of numbers ❶. We’ve also added a line to select
    the svg element ❷ before selecting the circle elements within it. This is necessary
    because D3 will need to add new circle elements, and it needs to know which containing
    element to add them to. Finally, we’ve added a call to the join method ❸. This
    method takes the name of the element from the selection to add or remove to match
    the data. In this case, we’re saying that if there aren’t enough circle elements
    in the svg element for all the items in data, then D3 should add more (or conversely,
    if there are too many, D3 should remove some).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the page, you’ll see this doesn’t quite work as you probably expected.
    The new circles all end up in the top-left corner of the drawing area. That’s
    because these new circles don’t have their cx or cy attributes set, unlike the
    initial three circles that were defined in *index.html*. To fix this, we need
    to set these two attributes using D3, as shown in [Listing 14-18](#Lis14-18).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Setting the
    cx and cy attributes</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The cx attribute is based on the index of the data. The first element should
    be at 50, the second at 100, and so on. The calculation (i + 1) * 50 gives us
    the right values. Because the circles are all in a line, the cy attribute is just
    a constant value. Now when you reload the page you should see five circles in
    a line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As mentioned previously, you can use the same join technique to remove elements
    when you have too many. If you change the array of numbers to contain only two
    elements and reload the page, you’ll see only two circles.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re using D3’s join method to create new SVG elements as needed to
    suit the data, there’s no reason to create them in the HTML file. Modify *index.html*
    as shown in [Listing 14-19](#Lis14-19), removing all the circle elements, then
    reload the page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: Removing the
    circle elements</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Everything should still work, because the join method adds in all the circle
    elements it needs. Note that the .selectAll("circle") line is still needed in
    *script.js* for the join to work correctly, even though the first time this is
    called there will be no circles to select.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Real-Time Updates</samp>
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the underlying data changes, we’ll need to perform the join again to update
    the visualization. To do this, we’ll move all the data binding and joining code
    into its own function, which we can call as needed. We can test this out by adding
    some buttons to the page that allow us to add random values to the start or end
    of our numbers array, or drop numbers from the array. Update *index.html* with
    the changes shown in [Listing 14-20](#Lis14-20).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: Adding buttons
    to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and you should see the three new buttons at the top. Next, we’ll
    move the code that updates the visualization into its own function. Replace the
    code in *script.js* with the content of [Listing 14-21](#Lis14-21).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Moving the update
    code into its own function</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: There’s no functional change here—we’re just creating an update function to
    do the SVG updating for us ❶, and then calling it ❸. Notice that we’re passing
    data, the function’s parameter, to the .data method ❷, rather than passing the
    numbers array directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll add the code for handling button clicks, which will insert a random
    floating-point number between 1 and 5 into the numbers array at the start or end,
    or drop the last element in the array. Add the code in [Listing 14-22](#Lis14-22)
    to the end of *script.js*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Updating on
    button clicks</samp>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: First we declare a helper function for generating a random number ❶, since there
    are two places where we need to do this. Then we declare the handlers for the
    three buttons. Notice that instead of using the regular DOM API methods for adding
    click handlers, as we’ve done previously in this book, we’re using d3.select to
    select the buttons and the on method to add an event handler. The regular DOM
    API methods would work as well, but using D3 methods is more concise and more
    consistent with the other D3 code in this file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The first handler is triggered by a click on the Append button ❷: it pushes
    a random number onto the end of the numbers array, then we call the update function
    to redraw the visualization with an extra circle. The second handler, triggered
    by a click on the Prepend button, causes a random number to be unshifted onto
    the front of the numbers array ❸. The third is triggered by a click on the Drop
    button; it pops the last number from the array ❹. After each of these actions
    we also call the update function.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and try out the different buttons. You should see the elements
    being added and removed as needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transitions and Key
    Functions</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of updating a D3 visualization abruptly with each change in the data,
    you can use *transitions* to allow elements to animate their attributes as they
    change. Transitions are a useful feature in D3 because, if done right, they allow
    you to see how data evolves. Let’s add a transition to our update function to
    see how this works. Make the changes shown in [Listing 14-23](#Lis14-23).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Adding transitions</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The transition method in a chain like this means that every following attribute
    change will animate from its current value to the new value. The duration method
    sets the length of the animation in milliseconds. This means that the position
    and radius of each circle will take half a second (500 ms) to animate from its
    current value to the new value. New circles start off with default values of 0
    for each attribute, so they will transition in from the top-left corner of the
    SVG.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the way we’ve coded our update function, the animation won’t
    be quite as satisfying as you might want. Reload the page and click **Prepend**
    a few times. You should see some odd behavior. You might have expected the existing
    circles to move over to the right, making room for a new circle being added on
    the left. Instead, the existing circles all appear to resize in place, while a
    new circle flies in from the top-left corner and takes its place to the right
    of the existing circles. With this animation, it’s actually very hard to see that
    an element is being *prepended* on the left. Rather, the animations suggest that
    an element is being *appended* on the right, and that all the elements are being
    resized. Clicking the Append button, on the other hand, does the correct thing:
    a new element animates in and appears at the end of the row, while the existing
    elements don’t change.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that when D3 updates an existing selection with a new array
    of data, it uses a default mode called *join-by-index*. This means that the first
    item in the array is joined with the first element in the selection (in this case,
    the leftmost circle), the second item in the array with the second element in
    the selection, and so on. If there are more items in the array than existing SVG
    elements, new elements are added at the end. Thus, when you click Prepend and
    add a new number to the start of the data array, every circle in the line is re-bound
    to a new datum. The first circle in the line is bound to the new number that’s
    been added to the start of the array, so it appears to resize. The second circle
    is bound to what used to be the first number in the array, so it appears to resize
    as well, and so on. Finally, since there’s now one more data item than there are
    SVG elements, a new circle is created and added at the end of the line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The solution to making the animation more intuitive is to help D3 understand
    the *identity* of each element in the array of data. Instead of assuming that
    every index in the array will always map to the same index in the selection, we
    provide what D3 calls a *key function*. The key function allows us to specify
    something about each datum that identifies it uniquely. This way, each existing
    datum stays bound to the same SVG element even as new data is added, regardless
    of the ordering of the data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The key function is passed as an optional second argument to the data method.
    [Listing 14-24](#Lis14-24) shows the necessary change to the update function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Adding a key
    function</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The key function d => d here says that given a datum, the datum itself is the
    unique identifier. In this case, we’re just using raw numbers, so the value of
    the number is as good as we can get for a “unique” identifier. Usually you’ll
    be working with more complex data, and you can use the key function to expose
    an identifier that is actually unique. For example, if each datum were an object
    representing an employee with a unique employeeId property, then you could use
    a key function like d => d.employeeId.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and click **Prepend**. You should now see all the circles slide
    to the right to accommodate the newly prepended element. This is because D3 now
    knows which item in the new array should map to which element in the selection
    when the array changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Advanced Joins</samp>
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: D3’s join method has extra options that give you more control over how the visualization
    responds to changes in the data. When D3 joins new data to an existing selection,
    some elements may be updated, some may be added (for the case of a new datum with
    no existing element), and some elements may be removed. In our case, we’ve seen
    how clicking Prepend both adds a new element and updates all the other elements
    by shifting them to the right. Meanwhile, clicking Drop removes the last element.
    In D3 parlance, adding a new element is called an *enter*, removing an existing
    element is called an *exit*, and modifying an existing element is called an *update*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize the join method by passing it three functions that will be
    called for each of these three possible element changes. This way you’re able
    to specify three different behaviors: one for entering elements, one for elements
    that are being updated, and one for exiting elements. To test this functionality,
    modify your update function as shown in [Listing 14-25](#Lis14-25). To start,
    these changes result in the same behavior we got from the simple join method in
    the previous listing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: The join</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">method with enter, update, and
    exit functions</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This more advanced version of the join method takes three functions. The first
    function has a single parameter called enter, which is a selection of temporary
    placeholders for each of the entering elements. To get the same behavior as the
    simple .join("circle") version, we just use the append method to add a circle
    to each enter placeholder. Note that the enter placeholders themselves aren’t
    elements in the DOM. They’re just a handle for D3 to give you a place to append
    your new entering elements, before they get added to the DOM. For example, if
    there were five new elements needing to be entered, then enter.append("circle")
    would create five new circle elements and place them inside the svg element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The second function has a single parameter called update, which is a selection
    containing all the existing elements that are already bound to a datum. To get
    the same behavior as before, we just return the selection unchanged.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The third function has a single parameter called exit, which is a selection
    containing all the elements that should be removed because they no longer have
    a corresponding datum. To get the same behavior as before, we call the remove
    method on the selection, which removes each exiting element from the DOM.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page, you should see the same behavior as before; so far,
    this change doesn’t have any functional impact. Now that we have it working, though,
    we can rework our animations to add some finesse. The current shift-right animation
    for elements in the updating selection is fine, but entering elements currently
    fly in from the top-left corner, and exiting elements just disappear. Let’s instead
    make it so entering elements grow into place from their correct position, and
    exiting elements shrink away to nothing at their current position. The changes
    to implement that behavior are shown in [Listing 14-26](#Lis14-26).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: Finessing the
    animations</samp>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'In this updated code, we’ve moved all the transitions into the individual enter,
    update, and exit functions, instead of having a single transition call for all
    the elements. The enter function appends a circle element ❶ and then immediately
    sets its position (the cx and cy attributes), but not its radius. Once the position
    is set, we use the transition method to animate the radius from zero (the default
    value) to the value calculated from the datum ❷. The order here is important:
    anything that comes in the chain *before* the call to transition will happen immediately,
    and anything *after* the call to transition will be animated. This means that
    any new circles will appear in the right position immediately, and the change
    in size (from zero to the desired radius) will animate. This will arguably look
    more natural than the previous version, where all three attributes animated in
    from zero, leading to the circles flying in from the corner.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The update function has to animate only the cx attribute of the circle ❸ to
    slide it to its updated position. All other attributes should be unchanged for
    existing elements. Finally, the exit function animates the radius of the circle
    back to zero ❹ before removing it ❺. If remove is called after a call to transition,
    as it is here, the actual element removal won’t take place until after the animations
    have completed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'When you reload the page, you should see the new and improved animations: new
    elements expand in at the appropriate position and removed elements shrink away.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Bar Graph</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve learned the basics of D3, let’s put them to use in a small
    project: creating a bar graph that visualizes the frequency of characters in a
    text box. The bar graph will update as new text is typed or pasted into the box.
    Creating this visualization will let you practice data joins, teach you some new
    techniques like drawing axes to contextualize the data, and prepare you for the
    more substantial project in the next chapter.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get started, make a new directory called *frequency* and add empty *script.js*
    and *style.css* files. Then create an *index.html* file and add the code in [Listing
    14-27](#Lis14-27).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-27: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for the character frequency project</samp>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This HTML document follows the same pattern we’ve been using throughout the
    book. The only new addition is the textarea element ❶, which creates a multiline
    text input. The rows and cols attributes set the number of lines and the width
    (in fixed-width characters) of the text area.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the document doesn’t contain an svg element. We’re going to create
    it using JavaScript. This is because we’ll need to refer to the svg element’s
    width and height multiple times to determine the placement of elements in the
    visualization, so it makes sense to define those parameters in the JavaScript
    rather than in the HTML file. And since we’ll be defining the width and height
    in the JavaScript, we may as well create the svg element itself in the JavaScript,
    too. We’ll do that right now. Add the code in [Listing 14-28](#Lis14-28) to *script.js*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-28: Creating the
    svg element using JavaScript</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We first declare constants for the width and height of the svg element. Then
    we use D3 to select the body element and append an svg element to it, setting
    the width and height attributes in the process. We save the result of creating
    the element into the variable svg because we’re going to need it later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating Character
    Frequencies</samp>
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll add the code for reading the text from the text area and counting
    the number of occurrences of each character. This generates the underlying data
    for the visualization. Anytime the text changes, we’ll need to update the data
    and redraw the chart. For now, though, we’ll just read the text, figure out the
    character frequencies, and log the output to the console. Add the code in [Listing
    14-29](#Lis14-29) to the end of *script.js*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-29: Calculating
    character frequencies</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The input event ❶ is triggered anytime the content of the text area changes,
    whether from typing, deleting, pasting, or some other action. The first thing
    we do in the event’s handler function is initialize a new object for keeping track
    of the character frequencies ❷. This frequencies object will use characters for
    its keys and the number of appearances of that character for its values. We then
    get the target of the event (the text area), get its value (the text), and split
    it into its individual characters ❸. For each character, we determine the current
    count for that character, defaulting to 0 if it hasn’t been seen yet. Then we
    add 1 to that count and store the new count back in the object. Once all the characters
    have been counted, we log the frequencies object to the console so we can check
    everything is working as expected. Note that we recalculate the frequencies object
    every time the text changes, rather than just trying to track added or deleted
    characters. This makes it much easier to handle cases where multiple characters
    are added or removed at once, for example, when text is pasted into the box.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the page, and you should see the text area (the svg element is invisible,
    but you can see it in the Elements panel if you want to check it’s there). When
    you type text into the text area, you should see objects being logged to the console
    on every keystroke, each time containing the frequencies of the characters in
    the text area. For example, if you type in the word *hello*, you’ll get this object
    after typing the final *o*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A single object containing all the characters and their frequencies works well
    for logging to the console, but what we’re going to want for rendering with D3
    is an array of objects, each describing a single character and its associated
    frequency. This way, each entry in the array will be a datum bound to a bar in
    our bar chart. To make the chart easier to read, the array should be sorted alphabetically
    by character. Continuing with the word *hello*, instead of the object shown previously,
    we need something like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To put the data in this array format, change the end of *script.js* as shown
    in [Listing 14-30](#Lis14-30).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-30: Converting the
    frequency data to an array</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: First, we use Object.entries to convert the frequencies object into an array
    of two-element arrays ❶, where the first element is the key and the second element
    is the value. We map this array into an array of objects, where the key is stored
    under the property char and the value is stored under the property count. Next,
    we want to sort the data by character. The sort method ❷ orders the elements in
    an array by applying a comparison function to every pair of elements a and b,
    to determine whether a should be sorted after b or vice versa. Here we use the
    d3.ascending comparison function, passing a.char and b.char, which means the array
    will be sorted into ascending alphabetical order based on the char property of
    each object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page, and you should now see this new data array being logged as
    text changes in the text area.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing the Bar Graph</samp>
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the data in the format we need, we can render it as a bar graph.
    We’re going to start out with a basic, naive rendering for now, where we simply
    create SVG rect elements with widths proportional to the character frequencies.
    We’ll gradually build from there to create a more informative visualization. Make
    the changes to *script.js* shown in [Listing 14-31](#Lis14-31).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-31: Defining the
    update function</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare an update function ❶, which gets called every time the text
    changes ❸. The function creates, updates, or deletes the SVG elements needed to
    render the data, according to the same pattern we learned earlier for binding
    data to a selection (using the data method) and joining in the necessary elements
    with the simple version of the join method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The join method returns a selection containing all the current rect elements
    ❷, including any that were just added. Each rect is now bound to a single datum,
    which represents a single character and the number of occurrences of that character.
    We set the width, height, x, and y attributes as appropriate to create a horizontally
    oriented bar chart. The width attribute is set to 5 times the character count,
    so every new instance of a character makes the bar 5 pixels wider. The height
    attribute is a constant value of 10 (all bars are the same height), and the x
    attribute is a constant value of 20 (all bars start 20 pixels from the left of
    the SVG element). The y attribute is set to 20 times the index of the datum, meaning
    that there will be a bar every 20 pixels, giving 10 pixels of space between each
    bar.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and type the word *hello* into the text area. As you type each
    letter, you should see bars appear or update in the SVG element, ending with something
    like [Figure 14-9](chapter14.xhtml#fig14-9).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-9.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: A basic bar chart</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: So far so good, but we still have a ways to go. There are two major issues here.
    First, there are no axes or labels, so we don’t know what character each bar represents
    or what the width of the bar corresponds to. Second, there’s no autoscaling of
    the bar widths and heights, meaning that we currently have a limit of 30 distinct
    characters and a count of 116 per character before the bars don’t fit in the 600×600-pixel
    SVG element. Luckily, both of these problems are easy to fix using D3.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Scaling the Bars</samp>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: A *scale* in D3 is a way of converting from some data value to a visual value.
    For example, earlier we set the width of the bars in our character frequency graph
    to be five times the data value, which is a simple form of scaling. In that case,
    we set the scale factor manually, but D3 can also determine the scaling automatically
    based on the minimum and maximum data values, known as the *domain*, and the minimum
    and maximum display values, known as the *range*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you’re plotting a graph of people’s ages. Your data values
    range from 0 to 105, and the space for rendering those values ranges from 30 to
    330 pixels from the left side of the SVG. Your domain is thus [0, 105], and your
    range is [30, 330]. A value of 0 in the data domain maps to 30 in the visual range,
    and a value of 105 maps to 330\. See [Figure 14-10](chapter14.xhtml#fig14-10)
    for a visual representation of this mapping.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-10.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: Scaling values
    from a domain of [0, 105] to a range of [30, 330]</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of D3 scaling is that the scale factor can change dynamically based
    on changes in the domain. This way, the current maximum data value can always
    map to the full visual range, even as the maximum data value changes. To implement
    this dynamic scaling for our bar graph, we need to keep track of the maximum count
    value among all the data, and use that as the upper value of the domain. As a
    result, if the maximum count increases, the bars that aren’t at the maximum count
    will all scale down accordingly, while the bar at the maximum count will continue
    to occupy the full horizontal range. For example, say that our visual range for
    the bars is [0, 500], and we have the following data:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The domain of our data would be [0, 2]. The "c" bar would be 500 units wide,
    and the "a" and "b" bars would each be 250 units wide. If we then added another
    two c’s, the "c" bar would still be 500 units wide, but now the "a" and "b" bars
    would each be 125 units wide.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement that dynamic horizontal scaling now. Modify your script with
    the code shown in [Listing 14-32](#Lis14-32).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-32: Creating a scale
    for the bar widths</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: First, immediately before the update function definition, we create an object
    describing the margins of our bar chart diagram. These values indicate how far
    from the edges of the SVG element the main body of the diagram will be. As [Figure
    14-11](chapter14.xhtml#fig14-11) shows, when the time comes we’ll use these margins
    to determine where to draw the bars and the axes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-11.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: How margins can
    be used to position a diagram in an SVG element (the dotted line)</samp>'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Inside the update function, we use the d3.scaleLinear method to create a scale
    ❶. This means that input values map linearly to output values (as opposed to logarithmically,
    for example). We set the domain from zero to the max count, using the D3 max helper.
    This helper takes an array of data and a function that returns a value from the
    datum, and returns the maximum value. In this case, it’s returning the maximum
    count value. The range is set from margin.left to width - margin.right and gives
    us the position of the right side of the longest bar.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The scaleLinear helper gives us a function that maps from the data domain to
    the visual range, which we assign to the variable xScale. (As discussed in [Chapter
    5](chapter5.xhtml), it’s possible for a higher-order function to return another
    function, as scaleLinear is doing here.) We modify our width attribute setting
    to call that xScale function, passing the count from each datum ❷. Here, xScale(0)
    gives the horizontal position of the left side of the bar, which corresponds to
    the domain value 0, and xScale(d.count) gives the horizontal position of the right
    side of the bar. To get the width of the bar, we need to subtract xScale(0) from
    xScale(d.count), because the width is just the distance between the left side
    of the bar and the right side of the bar. This will give an appropriately scaled
    bar width based on the count of each datum and the maximum count. We set the x
    attribute of the bar to xScale(0) to enforce the left margin ❸.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and start typing into the text area. The first time you enter
    a character, a single bar will appear, at the maximum width. Try typing *abccc*
    into the text area; you’ll see that as you add more c’s, the first two bars (for
    a and b) get smaller.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s create a scale for the height of the bars, to make full use of the
    vertical space of the svg element. The bars will start out tall but get shorter
    to accommodate more bars as new characters are added to the text field. Make the
    changes shown in [Listing 14-33](#Lis14-33).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-33: Scaling the
    bar heights</samp>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: To create a scale for the heights of the bars, we use the d3.scaleBand helper
    ❶. This lets us create a set of evenly spaced bands. The domain here is slightly
    different, because instead of an array giving the minimum and maximum values,
    it contains the full set of values. For example, if the content of the text area
    were the word *hello*, the domain of the y scale would be ["e", "h", "l", "o"]
    (remember that we sort the data alphabetically). This would map to four evenly
    spaced bars.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The range here is from margin.top to height - margin.bottom, which gives the
    range of y values the bars will exist in (the first bar will be at the top and
    the last at the bottom). The padding value defines how much space there is between
    bars based on the space available: 0 means that they are as tall as possible and
    will be touching, while 0.5 means that the bars will take up half of the space
    available.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Scales created using scaleBand also have a bandwidth method that returns the
    scaled size of the bands, which we can use to set the height of the bars ❷. (The
    method is called bandwidth on the assumption that the bars are oriented vertically,
    whereas ours are oriented horizontally.) To get the y attribute of the bar, we
    pass d.char to the yScale function ❸, because the domain of this scale is all
    the characters present in the data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and type some text into the text area. The first character you
    enter will cause a single tall black bar to appear, but for every unique character
    you type a new bar will be added, and the heights of the existing bars will decrease
    to make space. [Figure 14-12](chapter14.xhtml#fig14-12) shows how the visualization
    should look.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-12.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: Our bar graph
    scaled in both dimensions</samp>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Try typing in different text to get a feel for how the bars update as the data
    changes. Next we’ll add axes with labels, which will update along with the scaling
    to show the actual range of data. This will make it much easier to understand
    the graph.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Labeled Axes</samp>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The D3 axis helpers allow you to draw axes along the sides of your diagrams.
    An axis in D3 includes a horizontal or vertical line, with small tick marks drawn
    perpendicular to this line and the value for each tick, as shown in [Figure 14-13](chapter14.xhtml#fig14-13).
    The axis allows you to see the values in the data domain.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-13.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: An axis for the
    numbers 0 to 8</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Axes are closely linked to scales, and indeed you need a scale to create an
    axis. For example, the axis in [Figure 14-13](chapter14.xhtml#fig14-13) is 540
    pixels wide and contains the numbers from 0 to 8\. This axis was created using
    a scale with a domain of [0, 8] and a range of [0, 540].
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To draw an axis, you first have to define a g element that will contain the
    axis elements. You then create an axis generator object using one of the D3 axis
    helpers, and finally use the generator object to draw the axis elements into the
    g element.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Our diagram is going to have two axes: a top axis for showing the count values,
    and a left axis for showing the character values. First, we’ll add the g elements,
    as shown in [Listing 14-34](#Lis14-34).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-34: Adding g elements
    for containing the top and left axes</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We create the top axis container ❶ by appending a g element to the svg element
    and giving it an id of "top". Because we defined the range for xScale to be [margin.left,
    width - margin.right], that will also define the visual range of the axis. xScale
    doesn’t have any knowledge of vertical positioning, however, which is why we have
    to translate it down by margin.top ❷. We store the element selection in a variable
    called topContainer so we have a reference to it for later when drawing the axis
    into the container. The left axis container is created similarly ❸, but this time
    we have to translate it to the right by margin.left ❹, since yScale has no knowledge
    of horizontal positioning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the containers, we can draw the axes. Make the changes shown
    in [Listing 14-35](#Lis14-35) to the update function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-35: Drawing the
    axes</samp>'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Here we call d3.axisTop, passing xScale, and d3.axisLeft, passing yScale. This
    gives us two axis generators, topAxis and leftAxis. Axis generators take a selection
    of an element and draw an axis into that element. Instead of passing a selection
    to the axis generators, however, we instead pass the generators themselves to
    a D3 method called call. This method, when chained to a selection (such as topContainer
    or leftContainer, in this case), calls the provided function on the current selection.
    Thus, writing topContainer .call(topAxis); is equivalent to writing topAxis(topContainer);,
    with either statement drawing the top axis of the bar graph. It’s considered more
    idiomatic to use call, and this makes it easier to chain other methods to the
    statement.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and type some text in the text area. You’ll see the axes, as
    shown in [Figure 14-14](chapter14.xhtml#fig14-14).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-14.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: Our bar chart,
    now with axes</samp>'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the axes in the web inspector, you’ll see that they’re made up
    of g, path, text, and line elements. A line element is like a path, but it just
    defines the start and end points with the x1, x2, y1, and y2 attributes. These
    attributes default to 0 in the SVG specification, which often works just fine
    for the purposes of drawing these axes, so you’ll notice in the inspector that
    many of the line attributes aren’t set explicitly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: There are two things that are a bit off about the top axis right now. First,
    as you can see in [Figure 14-14](chapter14.xhtml#fig14-14), the labels include
    numbers with decimal points, like 2.5, but we care only about whole numbers (you
    can’t have half a character). So, we need to find a way to render only whole numbers,
    also known as integers. Second, if you enter a string of 15 of the same character
    (for example, *aaaaaaaaaaaaaaa*), then the labels will show only even numbers
    from 0 to 14, and there won’t be a label for 15, as shown in [Figure 14-15](chapter14.xhtml#fig14-15).
    You’ll continue to see this problem as the maximum count increases, especially
    beyond 30, where the ticks switch to multiples of 5.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-15.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: The top axis
    when the maximum count is 15</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: What we’d prefer here is for the domain to extend to 16, to give a nicer-looking
    axis. Luckily, this second problem is easy to fix. D3 scales have a nice method
    that extends their domain to the next “round” number, which in this case means
    the next number for which a tick would be drawn. [Listing 14-36](#Lis14-36) shows
    how to incorporate this method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-36: Making our x
    scale “nice”</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page and again type in 15 of the same character, you’ll
    see that the axis now extends to 16\. Rendering only integers requires a little
    more effort. The basic approach here is to get the tick values, filter them to
    only integers, and then set those tick values on the axis. Additionally, we want
    to change the number rendering to exclude the decimal point, so we render 1 and
    not 1.0\. These changes are shown in [Listing 14-37](#Lis14-37).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-37: Rendering integer
    ticks on the top axis</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: First we have to get the ticks, which are available using the ticks method on
    the xScale generator ❶. We then filter the ticks to integer values using Number.isInteger.
    This will convert an array like [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4] to [0, 1,
    2, 3, 4]. Next, we set the filtered tick values on the top axis using the tickValues
    method ❷. Finally, we use the tickFormat method to set a rendering format for
    the numbers ❸. This method takes a formatting function that will be used to format
    each tick value. In this case, d3.format("d") returns a function that formats
    numbers without the decimal point.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and enter some text again; you should see whole numbers rendered
    without the decimal point.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling with CSS
    and Regular Expressions</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next we’re going to improve the appearance of our graph with some CSS styles.
    In order to better differentiate the types of characters, we’ll give different
    colors to the bars depending on whether they’re lowercase letters, uppercase letters,
    numbers, or any other character. To do this, we’ll need a function that can distinguish
    between these types of characters. The function will use *regular expressions*,
    which are a way of specifying patterns in strings of text and then determining
    if other strings match those patterns.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*JavaScript’s regular expression capabilities are very powerful, but we’ll
    be considering only the features we need for this project. To learn more, check
    out the website* [https://www.regular-expressions.info](https://www.regular-expressions.info),
    *or search MDN for “regular expressions.”*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has a regular expression literal syntax that is delimited by forward
    slashes. For example, /hi/ is a regular expression literal that matches any string
    containing the sequence of characters *hi*. The *hi* can occur anywhere in the
    string. For example, the regular expression /hi/ would match the words *hither*,
    *Chicken*, and *sushi*. You can more narrowly define a regular expression’s pattern
    by adding special characters. For example, a caret (^) at the start of an expression
    indicates the character sequence should occur at the start of a string, so /^hi/
    matches any string that starts with *hi*. Similarly, a dollar sign ($) at the
    end of an expression indicates the character sequence should occur at the end
    of a string, so /hi$/ matches any string that ends with *hi*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the test method on a regular expression to see if a particular
    string matches it. Here are some examples in the JavaScript console:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The string "hi there" passes the test, because *hi* appears at the beginning
    of the string, whereas "Chicken" fails.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use ^ and $ together to create a regular expression where the full
    string must match. For example, /^hi$/ will match only the string "hi" and nothing
    else, as you can see here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To match a range of characters instead of a single character, use square brackets
    and a hyphen to describe the range. For example, /[a-z]/ matches any lowercase
    character from *a* to *z*. The regular expression /^[A-Z][a-z]$/ matches a string
    containing an uppercase letter followed by a lowercase letter, and no other characters.
    Try it out in your console:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For this project, we need three regular expressions: /^[a-z]$/ (matching a
    single lowercase letter), /^[A-Z]$/ (matching a single uppercase letter), and
    /^[0-9]$/ (matching a single digit). If a character doesn’t match any of those
    expressions, we’ll know it’s some other kind of character, like a space or a punctuation
    mark. See [Listing 14-38](#Lis14-38) for the new getClass function, which uses
    those regular expressions to choose a CSS class name for a given character’s bar.
    Add this function to *script.js* immediately before the update function.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-38: The getClass
    function</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'This function tests a character against the provided regular expressions and
    returns the appropriate class name: "lower", "upper", "number", or "other". Next,
    we’ll update the rendering code to use this function to set a class name on each
    rect element, as shown in [Listing 14-39](#Lis14-39).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-39: Applying the
    class name based on the character</samp>'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Now every rect element will have a class name based on the character from that
    element’s datum. The last step is to write the CSS that will give each class name
    a different fill color. Add the CSS code in [Listing 14-40](#Lis14-40) to *style.css*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-40: Defining styles
    for the different classes</samp>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Now when you reload the page and type in some different characters, you should
    see something like [Figure 14-16](chapter14.xhtml#fig14-16).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_14-16.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-16: Color-coded bars</samp>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The bars should be assigned different colors based on the kind of character
    entered.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cleaning the Data</samp>
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often it’s necessary to clean a dataset by fixing any mistakes or irregularities
    it contains before visualizing it. For example, one problem with the current approach
    to our bar graph is that different whitespace characters show up as different
    bars, each with an invisible label (because the text of the label is just whitespace).
    These whitespace characters include spaces, newlines, tabs, and various other
    kinds of spaces that you can type with different key combinations (for example,
    a non-breaking space, which you can enter with OPTION-spacebar on macOS or CTRL-SHIFT-spacebar
    on Windows). To fix this, we’ll convert all whitespace characters to the same
    "<space>" string before the character counting, so all whitespace will be visualized
    by a single bar with a readable label. Update your *script.js* file as shown in
    [Listing 14-41](#Lis14-41). These updates come near the end of the file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-41: Standardizing
    whitespace characters</samp>'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We first declare a standardizeSpace function that takes a character and calls
    the trim method on it ❶. The trim method removes whitespace at the start or end
    of a string, so if it returns an empty string, we know the character is whitespace.
    In this case, we return the string "<space>". Otherwise, we return the character
    unchanged. We then have to modify the text processing code to call our function
    and standardize the whitespace characters ❷ before using them as keys in the frequencies
    object.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Now when you enter various kinds of whitespace characters in the text area,
    you should see a single bar labeled <space> instead of multiple bars with empty
    labels.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Animating the Changes</samp>
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our final task is to add animations to the axes and bars. This will make it
    easier to see when new elements are added and when the counts for existing elements
    change. To animate the axes, all we need to do is add a call to transition to
    the topContainer and leftContainer selections inside the update function, as shown
    in [Listing 14-42](#Lis14-42).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-42: Adding animations
    to the axes</samp>'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Now when the domains for the axes update to accommodate new data, the existing
    ticks will animate to their updated positions, and new ticks will fade in.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options for adding transitions to the bars: we could keep the existing
    join code and just add a single call to transition, or we could use the advanced
    join technique described earlier, which would let us customize the transitions
    depending on whether the elements are entering, updating, or exiting. As you might
    guess, we’re going to go with the advanced version! You can find the updated update
    code in [Listing 14-43](#Lis14-43).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-43: Animating the
    bars</samp>'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have to do is set a key function ❶ to tell D3 that the datum’s
    char property should be used as its identifier. Next, we switch to the advanced
    join technique, similar to [Listing 14-25](#Lis14-25). The enter function ❷ first
    adds the rect element and sets its x, y, and class attributes before the call
    to transition, meaning that these attributes won’t be animated. The width and
    height attributes come after the call to transition, so these attributes *will*
    be animated. This way, new elements will grow in place from the left axis.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The update function ❸ animates the width and height again, but also animates
    the y attribute. This means that existing elements will slide up or down to their
    new position when new elements are added.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the exit function ❹ animates the width and height to 0 before the element
    is removed, causing elements to shrink away to nothing at their previous position.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and try adding and removing characters in the text area. Enjoy
    watching how the elements animate in, out, or update.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned the basics of SVG, and how to use D3 to create,
    update, and remove SVG elements based on real-time changes in a dataset. By now,
    you should have a pretty good understanding of how to build a data-based application
    in D3\. In the next chapter, we’ll put this knowledge to work by building an application
    that reads data from an API and renders it into an interactive diagram.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
