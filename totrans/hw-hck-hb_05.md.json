["```\n//Use digital pin D0 – D7 with this code. We cannot use the digitalWrite()\n//function as it is VERY slow. Instead we will be directly accessing the registers.\n#define GLITCH_PIN 0\n\nvoid setup(){\n    DDRD |= 1<<GLITCH_PIN;\n}\n\nvoid loop(){\n    //Create 2000 ns pulse – in practice NOT very accurate, actual pulse is\n    //about 1720 ns.\n    PORTD |= (1<<GLITCH_PIN);\n    delayMicroseconds(2);\n    PORTD &= ~(1<<GLITCH_PIN);\n\n    //Create very short pulse, 2 cycles (125ns, assuming a 16MHz Arduino)\n    //We no longer use digitalWrite() as it's slower, but directly access AVR\n    //registers.\n    PORTD |= (1<<GLITCH_PIN);\n    PORTD &= ~(1<<GLITCH_PIN);\n\n    //Create 500ns pulse (2 cycles + 6 nops = 8 cycles, 8 * 62.5 = 500ns)\n    PORTD |= (1<<GLITCH_PIN);\n    __asm__ __volatile__ (\"nop\\n\\t\");\n    __asm__ __volatile__ (\"nop\\n\\t\");\n __asm__ __volatile__ (\"nop\\n\\t\");\n    __asm__ __volatile__ (\"nop\\n\\t\");\n    __asm__ __volatile__ (\"nop\\n\\t\");\n    __asm__ __volatile__ (\"nop\\n\\t\");\n    PORTD &= ~(1<<GLITCH_PIN);\n}\n```", "```\n#include <stdio.h>\nint main(){\n        volatile int i, j, k, cnt;\n        k = 0;\n while(1) {\n                cnt = 0;\n                for(i = 0; i < 10000; i++)\n                        for(j = 0; j < 10000; j++)\n                                cnt++;\n                printf(\"%d %d %d %d\\n\", cnt, i, j, k++);\n        }\n}\n```", "```\n[PART] load \"tee1\" from 0x0000000000E00200 (dev) to 0x43001000 (mem) [SUCCESS]\n[PART] load speed: 9583KB/s, 58880 bytes, 6ms\n[BLDR_MTEE] sha256 takes 1 (ms) for 58304 bytes\n[BLDR_MTEE] rsa2048 takes 87 (ms)\n[BLDR_MTEE] verify pkcs#1 pss takes 2 (ms)\n[BLDR_MTEE] aes128cbc takes 1 (ms) for 58304\nNAND INFO:nand_bread 245: blknr:0xE0E,  blks:0x1\n```"]