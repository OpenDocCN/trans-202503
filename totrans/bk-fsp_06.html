<html><head></head><body><section class="chapter" title="Chapter&#xA0;6.&#xA0;Going to Collections" epub:type="chapter" id="going_to_collections"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Going to Collections</h2></div></div></div><p><a id="iddle1134" class="indexterm"/><a id="iddle1145" class="indexterm"/>Programming tasks often require working with collections of data. The .NET Framework has always supported this scenario with constructs such as <span class="emphasis"><em>arrays</em></span>and the <code class="literal">ArrayList</code> class, but it wasn’t until generics were introduced in .NET 2.0 that collection support really matured.</p><p>F# builds upon .NET’s legacy by not only supporting all of the existing collection types but also bringing a few of its own to the party. In this chapter, we’ll see the role a few of the classic collection types play in F# and then explore the F#-specific types. Along the way, we’ll see how the built-in collection modules add some functional flair and make working with both the traditional and F#-specific types a breeze.</p><div class="sect1" title="Sequences"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sequences">Sequences</h2></div></div></div><p><a id="iddle1239" class="indexterm"/><a id="iddle1335" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1501" class="indexterm"/><a id="iddle1514" class="indexterm"/><a id="iddle1516" class="indexterm"/><a id="iddle1572" class="indexterm"/><a id="iddle1591" class="indexterm"/><a id="iddle1884" class="indexterm"/><a id="iddle1885" class="indexterm"/><a id="iddle1886" class="indexterm"/><a id="iddle1889" class="indexterm"/><a id="iddle1891" class="indexterm"/>In .NET, <span class="emphasis"><em>sequence</em></span> is an all-encompassing term for a collection of values that share a common type. More specifically, a sequence is any type that implements <code class="literal">IEnumerable&lt;'T&gt;</code>.</p><p>Nearly all of the major collection types in .NET are sequences. For instance, the generic collection types (like <code class="literal">Dictionary&lt;'TKey, 'TValue&gt;</code> and<code class="literal">List&lt;'T&gt;</code>) and even some types (like <code class="literal">String</code>) that aren’t typically thought of as collections implement <code class="literal">IEnumerable&lt;'T&gt;</code>. Conversely, the legacy collection types (like <code class="literal">ArrayList</code> and <code class="literal">Hashtable</code>) predate generics, so they implement only the nongeneric <code class="literal">IEnumerable</code> interface. Accordingly, they don’t enforce a single, common type, and they’re generally regarded as enumerable collections rather than sequences.</p><p>In F#, <code class="literal">IEnumerable&lt;'T&gt;</code> is often expressed as <code class="literal">seq&lt;'T&gt;</code> or <code class="literal">'T seq</code>. Type annotations like <code class="literal">values : 'A seq</code> compile to <code class="literal">IEnumerable&lt;'A&gt;</code>, and any type that implements <code class="literal">IEnumerable&lt;'T&gt;</code> can be used wherever a sequence is expected. Because <code class="literal">I Enumerable&lt;'T&gt;</code> defines only the overloaded <code class="literal">GetEnumerator</code> method, sequences are inherently immutable. Be careful when using the specific collection types directly, however, because underlying implementations may be mutable.</p><div class="sect2" title="Creating Sequences"><div class="titlepage"><div><div><h3 class="title" id="creating_sequences">Creating Sequences</h3></div></div></div><p>Today’s .NET developers take working with sequences for granted, but before LINQ’s introduction, programming directly against <code class="literal">IEnumerable&lt;'T&gt;</code> was relatively rare. Instead, developers typically coded against specific collection types. LINQ’s <code class="literal">IEnumerable&lt;'T&gt;</code> extension methods brought the abstraction to the forefront, though, and taught developers that they didn’t always need to know anything about a collection other than that it implements the <code class="literal">GetEnumerator</code> method. Even with all of the goodness that LINQ gives us, it provides only a framework for working with <code class="literal">IEnumerable&lt;'T&gt;</code>; creating arbitrary sequences in LINQ still requires a method to create an instance of a specific sequence type.</p><p>F# takes the abstraction even further than LINQ by codifying sequence creation into the language through concepts like sequence and range expressions. While each sequence is ultimately still an implementation of <code class="literal">IEnumerable&lt;'T&gt;</code>, the compiler is free to provide its own implementations. The <code class="literal">Seq</code> module also includes several functions for creating new sequences.</p><div class="sect3" title="Sequence Expressions"><div class="titlepage"><div><div><h4 class="title" id="sequence_expressions">Sequence Expressions</h4></div></div></div><p><span class="emphasis"><em>Sequence expressions</em></span> allow you to create new sequences by iteratively applying other F# expressions and <span class="emphasis"><em>yielding</em></span> (returning) the results into a new sequence. In some situations, particularly when you are working with large or computationally expensive collections, the sequence types used internally by sequence expressions are preferable to other collection types <a id="iddle1055" class="indexterm"/><a id="iddle1060" class="indexterm"/><a id="iddle1823" class="indexterm"/><a id="iddle1825" class="indexterm"/><a id="iddle1887" class="indexterm"/><a id="iddle2130" class="indexterm"/>because they create values only as needed. These sequence types typically also hold only one value in memory at a time, making them ideal for large data sets.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><span class="emphasis"><em>Sequence expressions are technically a built-in workflow called a</em></span> computation expression<span class="emphasis"><em>. We’ll cover these constructs in detail in <a class="xref" href="ch12.html" title="Chapter 12. Computation Expressions">Chapter 12</a>.</em></span></p></div><p>You create a sequence expression by enclosing one or more expressions within a sequence builder and using a <code class="literal">do</code> binding in conjunction with the <code class="literal">yield</code> keyword. For example, say you have a file named <span class="emphasis"><em>ArnoldMovies.txt</em></span> that contains the following data:</p><a id="pro_id00309"/><pre class="programlisting">The Terminator,1984
Predator,1987
Commando,1985
The Running Man,1987
True Lies,1994
Last Action Hero,1993
Total Recall,1990
Conan the Barbarian,1982
Conan the Destroyer,1984
Hercules in New York,1969</pre><p>You can read each line of the text file into a sequence with a sequence expression like this:</p><a id="pro_id00310"/><pre class="programlisting">let lines = <span class="strong"><strong>seq {</strong></span> use r = new System.IO.StreamReader("ArnoldMovies.txt")
                  while not r.EndOfStream <span class="strong"><strong>do yield</strong></span> r.ReadLine() <span class="strong"><strong>}</strong></span></pre><p>Here, a <code class="literal">while</code> loop is used to iteratively read lines from a <code class="literal">StreamReader</code>, yielding a line for each iteration. (In some simpler sequence expressions—such as those using an enumerable <code class="literal">for</code> loop—<code class="literal">do yield</code> can be replaced with the <code class="literal">-&gt;</code> operator, but for consistency I usually stick with <code class="literal">do yield</code>.)</p><p>If you wanted to write this sequence to the console, you could send it to the <code class="literal">printfn</code> function and use the default formatter (via the <code class="literal">%A</code> token), but only the first four values are included in the output, as shown here:</p><a id="pro_id00311"/><pre class="programlisting">&gt; <span class="strong"><strong>lines |&gt; printfn "%A";;</strong></span>
seq ["The Terminator,1984"; "Predator,1987"; "Commando,1985"; "The Running Man,1987"; ...]
val it : unit = ()</pre><p>To print every value in the sequence, you need to force enumeration over the entire construct.</p></div><div class="sect3" title="Range Expressions"><div class="titlepage"><div><div><h4 class="title" id="range_expressions">Range Expressions</h4></div></div></div><p>Although <span class="emphasis"><em>range expressions</em></span> resemble the slice expressions you learned about in <a class="xref" href="ch04.html" title="Chapter 4. Staying Objective">Chapter 4</a> in that they use the <code class="literal">..</code> operator, they’re actually specialized sequence expressions that allow you to create sequences over a range of <a id="iddle1336" class="indexterm"/><a id="iddle1824" class="indexterm"/><a id="iddle1872" class="indexterm"/><a id="iddle1892" class="indexterm"/>values. Range expressions are similar to the <code class="literal">Enumerable.Range</code> method but are a bit more powerful because they’re not restricted to integers. For instance, you can easily create a sequence containing the integers 0 through 10 like this:</p><a id="pro_id00312"/><pre class="programlisting">seq { 0..10 }</pre><p>Or you could create a sequence containing 0 through 10 as floats this way:</p><a id="pro_id00313"/><pre class="programlisting">seq { 0.0..10.0 }</pre><p>Likewise, you could create a sequence containing the characters <span class="emphasis"><em>a</em></span> through <span class="emphasis"><em>z</em></span> like this:</p><a id="pro_id00314"/><pre class="programlisting">seq { 'a'..'z' }</pre><p>In most cases, you can also include a value that identifies how many items to skip between values when generating the sequence. Creating a sequence containing the integral multiples of 10 from 0 through 100 is easy with the following expression:</p><a id="pro_id00315"/><pre class="programlisting">seq { 0..10..100 }</pre><p>This range expression form works only with numeric types, so you can’t use it with character data. For example, the following expression results in an error.</p><a id="pro_id00316"/><pre class="programlisting">seq { 'a'..2..'z' }</pre><p>Finally, you can create sequences with declining values by using a negative step value like this:</p><a id="pro_id00317"/><pre class="programlisting">seq { 99..-1..0 }</pre></div><div class="sect3" title="Empty Sequences"><div class="titlepage"><div><div><h4 class="title" id="empty_sequences">Empty Sequences</h4></div></div></div><p>When you need a sequence without any elements, you can turn to the <code class="literal">Seq</code>module’s generic <code class="literal">empty</code> function to create one for you. For instance, to create an empty string sequence, you could call <code class="literal">Seq.empty</code> like this:</p><a id="pro_id00318"/><pre class="programlisting">&gt; <span class="strong"><strong>let emptySequence = Seq.empty&lt;string&gt;;;</strong></span>

val emptySequence : seq&lt;string&gt;</pre><p><a id="iddle1894" class="indexterm"/><a id="iddle2047" class="indexterm"/>Alternatively, if you don’t need any particular type, you can let the compiler automatically generalize the sequence by omitting the type argument:</p><a id="pro_id00319"/><pre class="programlisting">&gt; <span class="strong"><strong>let emptySequence = Seq.empty;;</strong></span>

val emptySequence : seq&lt;'a&gt;</pre></div><div class="sect3" title="Initializing a Sequence"><div class="titlepage"><div><div><h4 class="title" id="initializing_a_sequence">Initializing a Sequence</h4></div></div></div><p>Another module function, <code class="literal">Seq.init</code>, creates a sequence with up to a specified number of elements. For example, to create a sequence containing 10 random numbers, you could write:</p><a id="pro_id00320"/><pre class="programlisting">&gt; <span class="strong"><strong>let rand = System.Random();;</strong></span>

val rand : System.Random

&gt; <span class="strong"><strong>Seq.init 10 (fun _ -&gt; rand.Next(100));;</strong></span>
val it : seq&lt;int&gt; = seq [22; 34; 73; 42; ...]</pre></div></div><div class="sect2" title="Working with Sequences"><div class="titlepage"><div><div><h3 class="title" id="working_with_sequences">Working with Sequences</h3></div></div></div><p>The <code class="literal">Seq</code> module provides a number of functions for working with any sequence. The list of functions covered next is a sampling of the most useful functions in the <code class="literal">Seq</code> module, but it is by no means comprehensive.</p><p>While each of the functions discussed in the coming sections belongs to the <code class="literal">Seq</code> module, many have specialized counterparts in the other collection modules. In the interest of space, I’ll cover the common functions only once, but I strongly encourage you to explore the other modules and discover the right tools for your task.</p><div class="sidebar"><a id="when_is_a_function_not_a_functionquestio"/><div class="sidebar-title">When is a Function Not a Function?</div><p>You may have noticed in both of the empty sequence examples that <code class="literal">Seq.empty</code> was invoked without any arguments. <code class="literal">Seq.empty</code> differs from every function we’ve encountered so far in that it behaves more like a basic value binding than a function. In fact, if you were to call <code class="literal">Seq.empty</code> with an argument, you’d get a compiler error telling you that the value (<code class="literal">Seq.empty</code>) is not a function and cannot be applied.</p><p>Why is <code class="literal">Seq.empty</code> called a function when the compiler claims otherwise? Because it, along with some other functions (such as <code class="literal">Operators.typeof</code> and <code class="literal">Operators.typedefof</code>), is a special-case value called a <span class="emphasis"><em>type function</em></span>. Type functions are generally reserved for pure functions that compute values based on their type arguments, and therefore—despite being represented as methods in the compiled assemblies—they are treated as values within F# code.</p></div><div class="sect3" title="Finding Sequence Length"><div class="titlepage"><div><div><h4 class="title" id="finding_sequence_length">Finding Sequence Length</h4></div></div></div><p><a id="iddle1875" class="indexterm"/><a id="iddle1877" class="indexterm"/><a id="iddle1896" class="indexterm"/>You use <code class="literal">Seq.length</code> to determine how many elements a sequence contains like this:</p><a id="pro_id00321"/><pre class="programlisting">seq { 0..99 } |&gt; Seq.length</pre><p>Be careful with <code class="literal">Seq.length</code>, though, because, depending on the underlying collection type, it can force enumeration of the entire sequence or otherwise impair performance. Consider the following code, which checks if a sequence is empty using <code class="literal">Seq.length = 0</code>:</p><a id="pro_id00322"/><pre class="programlisting">seq { for i in 1..10 do
      printfn "Evaluating %i" i
      yield i }
|&gt; Seq.length = 0</pre><p>To determine the sequence’s length, the system must iterate over the sequence by calling the enumerator’s <code class="literal">MoveNext</code> method until it returns <code class="literal">false</code>. Each invocation of <code class="literal">MoveNext</code> involves doing whatever work is necessary to obtain the next value. In this case, getting the next value involves writing a string to the console, as shown here:</p><a id="pro_id00323"/><pre class="programlisting">Evaluating 1
Evaluating 2
Evaluating 3
-- <span class="emphasis"><em>snip</em></span> --
Evaluating 10
val it : bool = false</pre><p>Writing some text to the console is trivial, but even so, it is unnecessary work since the result isn’t actually being used for anything. Going beyond this simple example, you can easily imagine each call to <code class="literal">MoveNext</code> triggering an expensive computation or database call. If you just need to determine whether the sequence has any elements, you should use the <code class="literal">Seq.isEmpty</code> function instead.</p><p><code class="literal">Seq.isEmpty</code> checks whether a sequence contains any elements without forcing enumeration of the entire sequence. Consider the following code, which replaces <code class="literal">Seq.length = 0</code> with <code class="literal">Seq.isEmpty</code>:</p><a id="pro_id00324"/><pre class="programlisting">seq { for i in 1..10 do
      printfn "Evaluating %i" i
      yield i }
|&gt; Seq.isEmpty</pre><p>Because <code class="literal">Seq.isEmpty</code> returns <code class="literal">false</code> as soon as it finds an element, <code class="literal">MoveNext</code> is called only once, resulting in:</p><a id="pro_id00325"/><pre class="programlisting">Evaluating 1
val it : bool = false</pre><p><a id="iddle1505" class="indexterm"/><a id="iddle1876" class="indexterm"/><a id="iddle1878" class="indexterm"/><a id="iddle1881" class="indexterm"/><a id="iddle1895" class="indexterm"/><a id="iddle1897" class="indexterm"/><a id="iddle1898" class="indexterm"/>As you can see, although the sequence expression defines 10 elements, only the first one was printed because evaluation stopped as soon as the function found a value.</p></div><div class="sect3" title="Iterating over Sequences"><div class="titlepage"><div><div><h4 class="title" id="iterating_over_sequences">Iterating over Sequences</h4></div></div></div><p>The <code class="literal">Seq.iter</code> function is the functional equivalent of the enumerable <code class="literal">for</code> loop in that it iterates over a sequence, applying a function to each element. For example, to print each element of a sequence containing the values 0 through 99, you could write:</p><a id="pro_id00326"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 0..99 } |&gt; Seq.iter (printfn "%i");;</strong></span>
0
1
2
-- <span class="emphasis"><em>snip</em></span> --
97
98
99
val it : unit = ()</pre></div><div class="sect3" title="Transforming Sequences"><div class="titlepage"><div><div><h4 class="title" id="transforming_sequences">Transforming Sequences</h4></div></div></div><p><code class="literal">Seq.map</code> is similar to <code class="literal">Seq.iter</code> in that it applies a function to every element in a sequence, but unlike <code class="literal">Seq.iter</code>, it builds a new sequence with the results. For instance, to create a new sequence containing the squares of elements from a sequence, you could write:</p><a id="pro_id00327"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 0..99 } |&gt; Seq.map (fun i -&gt; i * i);;</strong></span>
val it : seq&lt;int&gt; = seq [0; 1; 4; 9; ...]</pre></div><div class="sect3" title="Sorting Sequences"><div class="titlepage"><div><div><h4 class="title" id="sorting_sequences">Sorting Sequences</h4></div></div></div><p>The <code class="literal">Seq</code> module defines several functions for sorting sequences. Each sorting function creates a new sequence, leaving the original unchanged.</p><p>The simplest sorting function, <code class="literal">Seq.sort</code>, orders the elements using a default comparison based on the <code class="literal">IComparable&lt;'T&gt;</code> interface. For instance, you can apply <code class="literal">Seq.sort</code> to a sequence of random integer values like this:</p><a id="pro_id00328"/><pre class="programlisting">&gt; <span class="strong"><strong>let rand = System.Random();;</strong></span>

val rand : System.Random

&gt; <span class="strong"><strong>Seq.init 10 (fun _ -&gt; rand.Next 100) |&gt; Seq.sort;;</strong></span>
val it : seq&lt;int&gt; = seq [0; 11; 16; 19; ...]</pre><p>For more complex sorting needs, you can use the <code class="literal">Seq.sortBy</code> function. In addition to the sequence to be sorted, it accepts a function that returns the value to sort upon for each element in the sequence.</p><p><a id="iddle1873" class="indexterm"/><a id="iddle1874" class="indexterm"/><a id="iddle1880" class="indexterm"/><a id="iddle1890" class="indexterm"/><a id="iddle1893" class="indexterm"/>For example, each movie listed in <span class="emphasis"><em>ArnoldMovies.txt</em></span> in <a class="xref" href="ch06.html#sequence_expressions" title="Sequence Expressions">Sequence Expressions</a> included the release year. If you wanted to sort the movies by their release years, you could revise the sequence expression to isolate the individual values as follows:</p><a id="pro_id00329"/><pre class="programlisting">let movies =
  seq { use r = new System.IO.StreamReader("ArnoldMovies.txt")
        while not r.EndOfStream do
          let l = r.ReadLine().Split(',')
          yield ① l.[0], int l.[1] }</pre><p>At ① the sequence expression now yields <span class="emphasis"><em>tuples</em></span> containing each movie title and release year. We can send the sequence to <code class="literal">Seq.sortBy</code> along with the <code class="literal">snd</code> function (to get the year) like this:</p><a id="pro_id00330"/><pre class="programlisting">&gt; <span class="strong"><strong>movies |&gt; Seq.sortBy snd;;</strong></span>
val it : seq&lt;string * int&gt; =
  seq
    [("Hercules in New York", 1969); ("Conan the Barbarian", 1982);
     ("The Terminator", 1984); ("Conan the Destroyer", 1984); ...]</pre><p>Alternatively, to sort the movies by title, you can replace <code class="literal">snd</code> with <code class="literal">fst</code>.</p><a id="pro_id00331"/><pre class="programlisting">&gt; seq { use r = new System.IO.StreamReader(fileName)
      while not r.EndOfStream do
        let l = r.ReadLine().Split(',')
        yield l.[0], int l.[1] }
|&gt; <span class="strong"><strong>Seq.sortBy fst</strong></span>;;
val it : seq&lt;string * int&gt; =
  seq
    [("Commando", 1985); ("Conan the Barbarian", 1982);
     ("Conan the Destroyer", 1984); ("Hercules in New York", 1969); ...]</pre></div><div class="sect3" title="Filtering Sequences"><div class="titlepage"><div><div><h4 class="title" id="filtering_sequences">Filtering Sequences</h4></div></div></div><p>When you want to work only with elements that meet certain criteria, you can use the <code class="literal">Seq.filter</code> function to create a new sequence containing only those elements. For example, continuing with the movie theme, you can get the movies released prior to 1984 like this:</p><a id="pro_id00332"/><pre class="programlisting">&gt; <span class="strong"><strong>movies |&gt; Seq.filter (fun (_, year) -&gt; year &lt; 1985);;</strong></span>
val it : seq&lt;string * int&gt; =
  seq
    [("The Terminator", 1984); ("Conan the Barbarian", 1982);
     ("Conan the Destroyer", 1984); ("Hercules in New York", 1969)]</pre></div><div class="sect3" title="Aggregating Sequences"><div class="titlepage"><div><div><h4 class="title" id="aggregating_sequences">Aggregating Sequences</h4></div></div></div><p>The <code class="literal">Seq</code> module provides a number of functions for aggregating the elements in a sequence. The most flexible (and complex) of the aggregation functions is <code class="literal">Seq.fold</code>, which iterates over a sequence, applying a function <a id="iddle1871" class="indexterm"/><a id="iddle1879" class="indexterm"/><a id="iddle1883" class="indexterm"/>to each element and returning the result as an accumulator value. For example, <code class="literal">Seq.fold</code> makes it easy to compute the sum of a sequence’s elements:</p><a id="pro_id00333"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 1 .. 10 } |&gt; Seq.fold</strong></span> ① <span class="strong"><strong>(fun s c -&gt; s + c)</strong></span> ② <span class="strong"><strong>0;;</strong></span>
val it : int = 55</pre><p>This example shows just one way to add the values 1 through 10. The function that <code class="literal">Seq.fold</code> uses for aggregation ① accepts two values: an aggregation value (essentially a running total), and the current element. We also need to give the <code class="literal">fold</code> function an initial aggregation value ②, which we do with <code class="literal">0</code>. As <code class="literal">fold</code> executes, it applies the aggregation function to each element in the sequence and returns the new aggregation value for use in the next iteration.</p><p>Because the addition operator function itself satisfies the requirements for the aggregation function, we can simplify the previous expression like this:</p><a id="pro_id00334"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 1..10 } |&gt; Seq.fold (+) 0;;</strong></span>
val it : int = 55</pre><p>A slightly more specialized aggregation function is <code class="literal">Seq.reduce</code>. The <code class="literal">reduce</code> function is very much like the <code class="literal">fold</code> function except that the aggregation value that’s passed through the computation is always the same type as the sequence’s elements, whereas <code class="literal">fold</code> can transform the data to another type. The <code class="literal">reduce</code> function also differs from <code class="literal">fold</code> in that it doesn’t accept an initial aggregation value. Instead, <code class="literal">reduce</code> initializes the aggregation value to the first value in the sequence. To see <code class="literal">Seq.reduce</code> in action, we can rewrite the previous expression as follows:</p><a id="pro_id00335"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 1 .. 10 } |&gt; Seq.reduce (+);;</strong></span>
val it : int = 55</pre><p>As expected, the result of adding the items in the sequence is the same regardless of whether we use <code class="literal">Seq.fold</code> or <code class="literal">Seq.reduce</code>.</p><p><code class="literal">Seq.fold</code> and <code class="literal">Seq.reduce</code> aren’t the only ways to calculate aggregate values from a sequence; some common aggregations like summations and averages have functions of their own. For example, rather than using <code class="literal">Seq.reduce</code> to calculate the sum of the elements like we did previously, we can use <code class="literal">Seq.sum</code>:</p><a id="pro_id00336"/><pre class="programlisting">&gt; seq { 1..10 } |&gt; <span class="strong"><strong>Seq.sum;;</strong></span>
val it : int = 55</pre><p>Similarly, to compute the average, you can use <code class="literal">Seq.average</code> like this:</p><a id="pro_id00337"/><pre class="programlisting">&gt; seq { 1.0..10.0 } |&gt; <span class="strong"><strong>Seq.average;;</strong></span>
val it : float = 5.5</pre><p><a id="iddle1002" class="indexterm"/><a id="iddle1128" class="indexterm"/><a id="iddle1146" class="indexterm"/><a id="iddle1149" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle1882" class="indexterm"/>One thing to note about <code class="literal">Seq.average</code> is that it works only with types that support division by an integer. If you try to use it with a sequence of integers, you’ll receive the following error:</p><a id="pro_id00338"/><pre class="programlisting">&gt; seq { 1..10 } |&gt; Seq.average;;

  seq { 1..10 } |&gt; Seq.average;;
  -----------------^^^^^^^^^^^

stdin(2,18): error FS0001: The type 'int' does not support the operator 'DivideByInt'</pre><p>Like <code class="literal">Seq.sort</code>, the <code class="literal">Seq.sum</code> and <code class="literal">Seq.average</code> functions have the <code class="literal">Seq.sumBy</code> and <code class="literal">Seq.averageBy</code> counterparts that accept a function that lets you identify which value should be used in the calculation. The syntax for these functions is the same as <code class="literal">Seq.sortBy</code>, so I’ll leave it to you to experiment a bit more with the <code class="literal">Seq</code> module.</p></div></div></div><div class="sect1" title="Arrays"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="arrays">Arrays</h2></div></div></div><p>F# arrays are the same construct as traditional .NET arrays. They contain a fixed number of values (each of the same type) and are zero-based. Although an array binding itself is immutable, individual array elements are mutable, so you need to be careful that you don’t introduce unwanted side effects. That said, the mutable nature of arrays makes them more desirable in some situations than other collection constructs because no further allocations are required to change element values.</p><div class="sect2" title="Creating Arrays"><div class="titlepage"><div><div><h3 class="title" id="creating_arrays">Creating Arrays</h3></div></div></div><p>F# provides a number of ways to create new arrays and control each element’s initial value, using both native syntax and module functions.</p><div class="sect3" title="Array Expressions"><div class="titlepage"><div><div><h4 class="title" id="array_expressions">Array Expressions</h4></div></div></div><p>One of the most common ways to create an array is with an <span class="emphasis"><em>array expression</em></span>. Array expressions consist of a semicolon-delimited list of values enclosed between the <code class="literal">[|</code> and <code class="literal">|]</code> tokens. For instance, you can create an array of strings like this (if you place each value on a separate line, you can omit the semicolons):</p><a id="pro_id00339"/><pre class="programlisting">&gt; <span class="strong"><strong>let names = [| "Rose"; "Martha"; "Donna"; "Amy"; "Clara" |];;</strong></span>

val names : string [] = [|"Rose"; "Martha"; "Donna"; "Amy"; "Clara"|]</pre><p><a id="iddle1129" class="indexterm"/><a id="iddle1136" class="indexterm"/><a id="iddle1150" class="indexterm"/>Finally, you can generate an array by enclosing a sequence expression between <code class="literal">[|</code> and <code class="literal">|]</code>. Unlike with the sequence builder, however, the array will be fully constructed when the array expression is evaluated. Compare this example with the corresponding one from the sequence expression discussion:</p><a id="pro_id00340"/><pre class="programlisting">&gt; <span class="strong"><strong>let lines = [| use r = new System.IO.StreamReader("ArnoldMovies.txt")</strong></span>
                  <span class="strong"><strong>while not r.EndOfStream do yield r.ReadLine() |];;</strong></span>

val lines : string [] =
  [|"The Terminator,1984"; "Predator,1987"; "Commando,1985";
    "The Running Man,1987"; "True Lies,1994"; "Last Action Hero,1993";
    "Total Recall,1990"; "Conan the Barbarian,1982";
    "Conan the Destroyer,1984"; "Hercules in New York,1969"|]</pre><p>As you can see, the default array print formatter prints every element (it caps the output at 100 elements) rather than printing only the first four.</p></div><div class="sect3" title="Empty Arrays"><div class="titlepage"><div><div><h4 class="title" id="empty_arrays">Empty Arrays</h4></div></div></div><p>Should you need to create an empty array, you can use an empty pair of square brackets:</p><a id="pro_id00341"/><pre class="programlisting">let emptyArray = [| |]</pre><p>The downside of this approach is that, depending on context, you may need to include a type annotation to ensure that the compiler doesn’t automatically generalize the array. Such a definition would look something like this:</p><a id="pro_id00342"/><pre class="programlisting">let emptyArray : int array = [| |];;</pre><p>In the preceding example, the type annotation, <code class="literal">int array</code>, is an English-like syntax. If you prefer a more traditional form, you could use <code class="literal">int[]</code> instead. Without the type annotation, the compiler would define the array as <code class="literal">'a []</code>.</p><p>Another way to create an empty array is with the <code class="literal">Array.empty</code> function. Just like its counterpart in the <code class="literal">Seq</code> module, <code class="literal">Array.empty</code> is a type function, so you invoke it without any arguments to create a zero-length array. To create an empty string array with this function, you simply write:</p><a id="pro_id00343"/><pre class="programlisting">Array.empty&lt;string&gt;</pre><p>If you prefer to let the compiler infer the underlying type or automatically generalize it, you can omit the type parameter.</p></div><div class="sect3" title="Initializing Arrays"><div class="titlepage"><div><div><h4 class="title" id="initializing_arrays">Initializing Arrays</h4></div></div></div><p><a id="iddle1138" class="indexterm"/><a id="iddle1143" class="indexterm"/><a id="iddle1147" class="indexterm"/><a id="iddle1151" class="indexterm"/>To quickly create an array where all elements are initialized to the underlying type’s default value, you can use <code class="literal">Array.zeroCreate</code>. Suppose you know that you need an array of five strings, but you don’t yet know what values will be stored in each element. You could create the array like this:</p><a id="pro_id00344"/><pre class="programlisting">&gt; <span class="strong"><strong>let stringArray = Array.zeroCreate&lt;string&gt; 5;;</strong></span>

val stringArray : string [] = [|null; null; null; null; null|]</pre><p>Because <code class="literal">Array.zeroCreate</code> uses the underlying type’s default value, it’s possible that the elements will be initialized to <code class="literal">null</code> like they were here. If <code class="literal">null</code> is valid for the type and you’re creating arrays like this, you’ll need to code against <code class="literal">NullReferenceException</code>s.</p><p>Alternatively, <code class="literal">Array.init</code> lets you initialize each element to a specific value. <code class="literal">Array.init</code> is the array-specific equivalent of <code class="literal">Seq.init</code>. Its syntax is the same, but it creates and returns an array instead. For instance, to create a new array where the elements are initialized to the empty string, you could write:</p><a id="pro_id00345"/><pre class="programlisting">&gt; <span class="strong"><strong>let stringArray = Array.init 5 (fun _ -&gt; "");;</strong></span>

val stringArray : string [] = [|""; ""; ""; ""; ""|]</pre><p>Here, the supplied function only returns the empty string, but your initialization function could easily have more complicated logic, allowing you to compute a different value for each element.</p></div></div><div class="sect2" title="Working with Arrays"><div class="titlepage"><div><div><h3 class="title" id="working_with_arrays">Working with Arrays</h3></div></div></div><p>Working with arrays in F# is similar to working with them in other .NET languages, but F# extends their usefulness with constructs like slice expressions and the <code class="literal">Array</code> module.</p><div class="sect3" title="Accessing Elements"><div class="titlepage"><div><div><h4 class="title" id="accessing_elements">Accessing Elements</h4></div></div></div><p>Individual array elements are accessible through an indexed property. For instance, to retrieve the fourth element from the <code class="literal">lines</code> array defined previously, you’d write:</p><a id="pro_id00346"/><pre class="programlisting">&gt; <span class="strong"><strong>lines.[3];;</strong></span>
val it : string = "The Running Man,1987"</pre><p>You can combine the indexer syntax with the assignment operator to change individual elements of an array. For instance, to replace <span class="emphasis"><em>Last Action Hero</em></span>, you could write:</p><a id="pro_id00347"/><pre class="programlisting">lines.[5] &lt;- "Batman &amp; Robin,1997"</pre><p><a id="iddle1135" class="indexterm"/><a id="iddle1137" class="indexterm"/><a id="iddle1139" class="indexterm"/><a id="iddle1141" class="indexterm"/><a id="iddle1148" class="indexterm"/><a id="iddle1154" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1930" class="indexterm"/>If you prefer a more functional approach to retrieving and mutating array elements, the <code class="literal">Array</code> module has you covered with the <code class="literal">get</code> and <code class="literal">set</code> functions. In the following example we’ll create an array, change the second element’s value, retrieve the new value, and write it to the console.</p><a id="pro_id00348"/><pre class="programlisting">&gt; <span class="strong"><strong>let movies = [| "The Terminator"; "Predator"; "Commando" |];;</strong></span>

val movies : string [] = [|"The Terminator"; "Predator"; "Commando"|]

&gt; <span class="strong"><strong>Array.set movies 1 "Batman &amp; Robin"</strong></span>
<span class="strong"><strong>Array.get movies 1 |&gt; printfn "%s";;</strong></span>
Batman &amp; Robin

val it : unit = ()</pre><p>Finally, arrays also support slice expressions. As noted in <a class="xref" href="ch04.html" title="Chapter 4. Staying Objective">Chapter 4</a>, slice expressions let you easily retrieve a range of values from a collection like this:</p><a id="pro_id00349"/><pre class="programlisting">&gt; <span class="strong"><strong>lines.[1..3];;</strong></span>
val it : string [] =
  [|"Predator,1987"; "Commando,1985"; "The Running Man,1987"|]</pre></div><div class="sect3" title="Copying Arrays"><div class="titlepage"><div><div><h4 class="title" id="copying_arrays">Copying Arrays</h4></div></div></div><p>You can easily copy the elements from one array to a new array with <code class="literal">Array.copy</code>. Here, we create an array containing the numbers 1 through 10 and immediately copy them to another.</p><a id="pro_id00350"/><pre class="programlisting">[| 1..10 |] |&gt; Array.copy</pre><p>Behind the scenes, <code class="literal">Array.copy</code> is a wrapper around the CLR’s <code class="literal">Array.Clone</code> method, which creates a shallow copy of the source array. <code class="literal">Array.copy</code> offers the added benefit of automatically downcasting the object instance returned by <code class="literal">Clone</code> to the appropriate array type; that is, passing an integer array directly to <code class="literal">Array.Clone</code> will give you an <code class="literal">obj</code> instance, whereas passing that same array to <code class="literal">Array.copy</code> will give you an instance of <code class="literal">int array</code>.</p></div><div class="sect3" title="Sorting Arrays"><div class="titlepage"><div><div><h4 class="title" id="sorting_arrays">Sorting Arrays</h4></div></div></div><p>Arrays can be sorted like any other sequence, but the <code class="literal">Array</code> module provides a few specialized sorting functions to take advantage of the fact that individual array elements are mutable. Unfortunately, each of these functions returns <code class="literal">unit</code> instead of the sorted array, so they’re not particularly effective in pipelining or composition chains.</p><p>The first in-place sorting function, <code class="literal">sortInPlace</code>, sorts an array with the default comparison mechanism. The following snippet shows how to sort an array of random integers.</p><a id="pro_id00351"/><pre class="programlisting">&gt; <span class="strong"><strong>let r = System.Random()</strong></span>
<span class="strong"><strong>let ints = Array.init 5 (fun _ -&gt; r.Next(-100, 100));;</strong></span>

val r : System.Random
val ints : int [] = [|-94; 20; 13; -99; 0|]

&gt; <span class="strong"><strong>ints |&gt; Array.sortInPlace;;</strong></span>
val it : unit = ()
&gt; <span class="strong"><strong>ints;;</strong></span>
val it : int [] = [|-99; -94; 0; 13; 20|]</pre><p><a id="iddle1140" class="indexterm"/><a id="iddle1142" class="indexterm"/>If you need more control over how sorting is performed, you can turn to the <code class="literal">sortInPlaceBy</code> or <code class="literal">sortInPlaceWith</code> functions. The <code class="literal">sortInPlaceBy</code> function lets you provide a transformation function that’s used in the sorting process. The <code class="literal">sortInPlaceWith</code> function accepts a comparison function that returns an integer where less than zero means the first value is greater than the second, greater than zero means that the first value is less than the second value, and zero means the first and second values are equal.</p><p>To better understand both approaches, consider the following array containing some movies and their release years as tuples.</p><a id="pro_id00352"/><pre class="programlisting">let movies = [| ("The Terminator", "1984")
                ("Predator", "1987")
                ("Commando", "1985")
                ("Total Recall", "1990")
                ("Conan the Destroyer", "1984") |]</pre><p>The easiest way to sort by year is to just project the year value via <code class="literal">sortInPlaceBy</code> like this:</p><a id="pro_id00353"/><pre class="programlisting">&gt; <span class="strong"><strong>movies |&gt; Array.sortInPlaceBy (fun (_, y) -&gt; y)</strong></span>
<span class="strong"><strong>movies;;</strong></span>

val it : (string * string) [] =
  [|("The Terminator", "1984"); ("Conan the Destroyer", "1984");
    ("Commando", "1985"); ("Predator", "1987"); ("Total Recall", "1990")|]</pre><p>Alternatively, we can directly compare two elements with <code class="literal">sortInPlaceWith</code>:</p><a id="pro_id00354"/><pre class="programlisting">&gt; <span class="strong"><strong>movies |&gt; Array.sortInPlaceWith (fun (_, y1) (_, y2) -&gt; if y1 &lt; y2 then -1</strong></span>
                                                        <span class="strong"><strong>elif y1 &gt; y2 then 1</strong></span>
                                                        <span class="strong"><strong>else 0)</strong></span>
<span class="strong"><strong>movies;;</strong></span>

val it : (string * string) [] =
  [|("The Terminator", "1984"); ("Conan the Destroyer", "1984");
    ("Commando", "1985"); ("Predator", "1987"); ("Total Recall", "1990")|]</pre><p><a id="iddle1130" class="indexterm"/><a id="iddle1131" class="indexterm"/><a id="iddle1132" class="indexterm"/><a id="iddle1153" class="indexterm"/><a id="iddle1931" class="indexterm"/>As you can see, <code class="literal">sortInPlaceBy</code> allows you to sort according to the default equality semantics for a particular element’s underlying type, whereas <code class="literal">sortInPlaceWith</code> allows you to essentially define your own equality semantics for each element in the array.</p></div></div><div class="sect2" title="Multidimensional Arrays"><div class="titlepage"><div><div><h3 class="title" id="multidimensional_arrays">Multidimensional Arrays</h3></div></div></div><p>All of the arrays we’ve looked at so far have been one-dimensional. While it’s also possible to create multidimensional arrays, it’s a bit more complicated because there’s no direct syntactic support. For two-dimensional arrays, you can pass a sequence of sequences (typically either arrays or lists) to the <code class="literal">array2D</code> operator. To create arrays with more than two dimensions, you need to use either the <code class="literal">Array3D.init</code> or <code class="literal">Array4D.init</code> functions. Multidimensional arrays have modules (like <code class="literal">Array2D</code> and <code class="literal">Array3D</code>) that contain specialized subsets of those defined in the <code class="literal">Array</code> module.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note02"/>Note</h3><p><span class="emphasis"><em>The maximum number of dimensions F# supports is four.</em></span></p></div><p>Suppose you wanted to represent the movies from the previous sections as a two-dimensional array instead of as an array of tuples. You could write something like the following, which passes an array of arrays to the <code class="literal">array2D</code> operator:</p><a id="pro_id00355"/><pre class="programlisting">let movies = array2D [| [| "The Terminator"; "1984" |]
                        [| "Predator"; "1987" |]
                        [| "Commando"; "1985" |]
                        [| "The Running Man"; "1987" |]
                        [| "True Lies"; "1994" |]
                        [| "Last Action Hero"; "1993" |]
                        [| "Total Recall"; "1990" |]
                        [| "Conan the Barbarian"; "1982" |]
                        [| "Conan the Destroyer"; "1984" |]
                        [| "Hercules in New York"; "1969" |] |]</pre><p>You can access any value in the two-dimensional array with the familiar indexer syntax. For instance, to get <span class="emphasis"><em>Commando</em></span>’s release year you’d write <span class="strong"><strong><code class="literal">movies.[2, 1]</code></strong></span>, which would return <code class="literal">1985</code>. Much more interesting, though, is what you can do with slice expressions.</p><p>Slice expressions make it easy to create new arrays containing subsets of data from the source. For instance, you can slice the <code class="literal">movies</code> array vertically to create new arrays containing only the movie titles or release years like this:</p><a id="pro_id00356"/><pre class="programlisting">&gt; <span class="strong"><strong>movies.[0..,0..0];;</strong></span>
val it : string [,] = [["The Terminator"]
                       ["Predator"]
                       ["Commando"]
                       ["The Running Man"]
                       -- <span class="emphasis"><em>snip</em></span> --]

&gt; <span class="strong"><strong>movies.[0..,1..1];;</strong></span>
val it : string [,] = [["1984"]
                       ["1987"]
                       ["1985"]
                       ["1987"]
                       -- <span class="emphasis"><em>snip</em></span> --]</pre><p><a id="iddle1152" class="indexterm"/>You can also slice arrays horizontally to create new arrays containing only a few rows:</p><a id="pro_id00357"/><pre class="programlisting">&gt; <span class="strong"><strong>movies.[1..3,0..];;</strong></span>
val it : string [,] = [["Predator"; "1987"]
                       ["Commando"; "1985"]
                       ["The Running Man"; "1987"]]</pre><p>Multidimensional arrays are useful when the data has a nice, rectangular shape, but they don’t work when even a single row has a different number of items. Consider what happens if we try to include a director name in the two-dimensional <code class="literal">movies</code> array (for brevity, we’ll just work with three titles here).</p><a id="pro_id00358"/><pre class="programlisting">&gt; <span class="strong"><strong>let movies = array2D [| [| "The Terminator"; "1984"; "James Cameron" |]</strong></span>
                        <span class="strong"><strong>[| "Predator"; "1987"; "John McTiernan" |]</strong></span>
                        <span class="strong"><strong>[| "Commando"; "1985" |] |];;</strong></span>
System.ArgumentException: The arrays have different lengths.
Parameter name: vals
-- <span class="emphasis"><em>snip</em></span> --
Stopped due to error</pre><p>Of course, one possible solution would be to provide an empty string as the third element in the row that’s missing the director name. Alternatively, you can use a jagged array.</p></div><div class="sect2" title="Jagged Arrays"><div class="titlepage"><div><div><h3 class="title" id="jagged_arrays">Jagged Arrays</h3></div></div></div><p><span class="emphasis"><em>Jagged arrays</em></span> are arrays of arrays. Unlike multidimensional arrays, jagged arrays don’t require a rectangular structure. To convert the preceding failing example, we just need to remove the call to the <code class="literal">array2D</code> function.</p><a id="pro_id00359"/><pre class="programlisting">&gt; <span class="strong"><strong>let movies = [| [| "The Terminator"; "1984"; "James Cameron" |]</strong></span>
                <span class="strong"><strong>[| "Predator"; "1987"; "John McTiernan" |]</strong></span>
                <span class="strong"><strong>[| "Commando"; "1985" |] |];;</strong></span>

val movies : string [] [] =
  [|[|"The Terminator"; "1984"; "James Cameron"|];
    [|"Predator"; "1987"; "John McTiernan"|]; [|"Commando"; "1985"|]|]</pre><p>As you might expect, since <code class="literal">movies</code> is now a jagged array, you need to use a different syntax to access each element. You also need to code a bit more <a id="iddle1063" class="indexterm"/><a id="iddle1155" class="indexterm"/><a id="iddle1456" class="indexterm"/><a id="iddle1517" class="indexterm"/><a id="iddle1583" class="indexterm"/><a id="iddle1586" class="indexterm"/><a id="iddle1587" class="indexterm"/><a id="iddle1592" class="indexterm"/><a id="iddle1852" class="indexterm"/>defensively when using jagged arrays because there’s no guarantee that a particular index will be valid for any given row. That said, you can get the director name from the second row like this:</p><a id="pro_id00360"/><pre class="programlisting">&gt; <span class="strong"><strong>movies.[1].[2];;</strong></span>
val it : string = "John McTiernan"</pre><div class="sidebar"><a id="any_way_you_slice_it"/><div class="sidebar-title">Any Way You Slice it</div><p>F# 3.1 features a few extensions to array slicing that aren’t covered here but do prove useful. Array slicing in F# 3.0 requires slices to have the same dimensions as the source array. Under F# 3.1 this restriction has been removed, so you can create a one-dimensional slice from a two-dimensional array, and so on.</p></div></div></div><div class="sect1" title="Lists"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="lists">Lists</h2></div></div></div><p><span class="emphasis"><em>Lists</em></span> are used extensively in F# development. When .NET developers discuss lists, they typically mean the generic <code class="literal">List&lt;'T&gt;</code> class. Although it’s possible (and sometimes even desirable) to use the generic list in F#, the language defines another immutable construct based on singly linked lists. In F#, lists created with the list syntax compile to instances of the <code class="literal">FSharpList&lt;'T&gt;</code> class found in the <code class="literal">Microsoft.FSharp.Collections</code> namespace, and that’s the kind of list we’ll be covering in this section.</p><p>Aside from both <code class="literal">List&lt;'T&gt;</code> and <code class="literal">FSharpList&lt;'T&gt;</code> being generic sequence types (they both implement <code class="literal">IEnumerable&lt;'T&gt;)</code>, they have little in common and cannot be used interchangeably. You need to be careful to not mix list types when working in multilanguage solutions.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note03"/>Note</h3><p><span class="emphasis"><em>You can use the generic <code class="literal">List&lt;'T&gt;</code> class directly by opening the <code class="literal">System.Collections.Generic</code> namespace or through the built-in <code class="literal">ResizeArray&lt;'T&gt;</code> type abbreviation.</em></span></p></div><div class="sect2" title="Creating Lists"><div class="titlepage"><div><div><h3 class="title" id="creating_lists">Creating Lists</h3></div></div></div><p>Creating lists in F# is so similar to creating arrays that I won’t spend much time explaining the various forms here. The only notable syntactic difference between creating arrays and lists is the brace style. To create a new list, you enclose semicolon-delimited values, range expressions, or list sequence expressions between square brackets (<code class="literal">[]</code>) like this:</p><a id="pro_id00361"/><pre class="programlisting">&gt; <span class="strong"><strong>let names = [ "Rose"; "Martha"; "Donna"; "Amy"; "Clara" ];;</strong></span>

val names : string list = ["Rose"; "Martha"; "Donna"; "Amy"; "Clara"]

&gt; <span class="strong"><strong>let numbers = [ 1..11 ];;</strong></span>

val numbers : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11]</pre><p><a id="iddle1577" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1581" class="indexterm"/><a id="iddle1584" class="indexterm"/><a id="iddle1588" class="indexterm"/><a id="iddle1589" class="indexterm"/>To create an empty list, you can use either <code class="literal">List.empty</code> or a pair of empty brackets.</p></div><div class="sect2" title="Working with Lists"><div class="titlepage"><div><div><h3 class="title" id="working_with_lists">Working with Lists</h3></div></div></div><p>Although there are some similarities between working with F# lists and <code class="literal">List&lt;'T&gt;</code>, they’re mostly syntactic and deal with accessing individual known elements. Beyond that, F# lists are quite unique, especially because of their head and tail structure, which lends itself well to functional programming and to recursive techniques in particular.</p><div class="sect3" title="Accessing Elements"><div class="titlepage"><div><div><h4 class="title" id="accessing_elements-id00010">Accessing Elements</h4></div></div></div><p>When you want to get the element at a particular position, you can use the familiar indexer syntax just like you would with an array. Alternatively, you can use <code class="literal">List.nth</code> to get the same result:</p><a id="pro_id00362"/><pre class="programlisting">&gt; <span class="strong"><strong>List.nth [ 'A'..'Z' ] 3;;</strong></span>
val it : char = 'D'</pre><p>What’s more interesting (and often more useful) than accessing a particular element by index is a list’s <span class="emphasis"><em>head</em></span> and <span class="emphasis"><em>tail</em></span>. A list’s head is simply its first element, whereas its tail is all elements except the head. You can get a list’s head and tail through the <code class="literal">Head</code> or <code class="literal">Tail</code> properties or the <code class="literal">List.head</code> or <code class="literal">List.tail</code> module functions. Here’s an example using the module functions:</p><a id="pro_id00363"/><pre class="programlisting">&gt; <span class="strong"><strong>let names = [ "Rose"; "Martha"; "Donna"; "Amy"; "Clara" ];;</strong></span>

val names : string list = ["Rose"; "Martha"; "Donna"; "Amy"; "Clara"]

&gt; <span class="strong"><strong>List.head names;;</strong></span>
val it : string = "Rose"
&gt; <span class="strong"><strong>List.tail names;;</strong></span>
val it : string list = ["Martha"; "Donna"; "Amy"; "Clara"]</pre><div class="note" title="Note"><h3 class="title"><a id="ch06note04"/>Note</h3><p><span class="emphasis"><em>Pattern matching is another way to get the head and tail, but we’ll save that discussion for <a class="xref" href="ch07.html" title="Chapter 7. Patterns, Patterns, Everywhere">Chapter 7</a>.</em></span></p></div><p>Why would you want to get only the first element or everything else? Recursion. If you had to iterate over a list using indexes, you’d need to track both the list and the current position. By separating a list into head and tail components, you’re free to operate against the head and then iterate with the tail.</p><p><a id="iddle1008" class="indexterm"/><a id="iddle1022" class="indexterm"/><a id="iddle1260" class="indexterm"/><a id="iddle1573" class="indexterm"/><a id="iddle1576" class="indexterm"/><a id="iddle1578" class="indexterm"/><a id="iddle1585" class="indexterm"/>Consider this function, which returns a Boolean value indicating whether a list contains a particular value (much like the <code class="literal">List.exists</code> module function).</p><a id="pro_id00364"/><pre class="programlisting">let rec contains fn l =
  if l = [] then false
  else fn(List.head l) || contains fn (List.tail l)</pre><p>The <code class="literal">contains</code> function accepts both a function for testing the elements and a list to scan. The first thing <code class="literal">contains</code> does is check whether the supplied list is empty. If the list is empty, <code class="literal">contains</code> immediately returns <code class="literal">false</code>; otherwise, it tests the list’s head with the provided function or recursively calls <code class="literal">contains</code> with both the function and the list’s tail.</p><p>Now let’s test for a few values, starting with an empty list:</p><a id="pro_id00365"/><pre class="programlisting">&gt; <span class="strong"><strong>[] |&gt; contains (fun n -&gt; n = "Rose");;</strong></span>
val it : bool = false</pre><p>You can see that <code class="literal">contains</code> correctly returns <code class="literal">false</code> when the list is empty, but what about a populated list?</p><a id="pro_id00366"/><pre class="programlisting">&gt; <span class="strong"><strong>let names = [ "Rose"; "Martha"; "Donna"; "Amy"; "Clara" ];;</strong></span>

val names : string list = ["Rose"; "Martha"; "Donna"; "Amy"; "Clara"]

&gt; <span class="strong"><strong>names |&gt; contains (fun n -&gt; n = "Amy");;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>names |&gt; contains (fun n -&gt; n = "Rory");;</strong></span>
val it : bool = false</pre><p>The <code class="literal">contains</code> function recursively walked the list, examining each element with the supplied function and passing the tail to <code class="literal">contains</code> if the element didn’t match.</p></div><div class="sect3" title="Combining Lists"><div class="titlepage"><div><div><h4 class="title" id="combining_lists">Combining Lists</h4></div></div></div><p>Even though F# lists are immutable, we can still construct new lists from existing ones. F# provides two primary mechanisms: the <code class="literal">cons</code> operator (<code class="literal">::</code>) and list concatenation with the <code class="literal">@</code> operator.</p><p>The <code class="literal">cons</code> operator (so named because it <span class="emphasis"><em>cons</em></span>tructs a new list) essentially prepends an item to an existing list like this:</p><a id="pro_id00367"/><pre class="programlisting">&gt; <span class="strong"><strong>let names = [ "Rose"; "Martha"; "Donna"; "Amy"; "Clara" ]</strong></span>
<span class="strong"><strong>let newNames = "Ace" :: names;;</strong></span>

val names : string list = ["Rose"; "Martha"; "Donna"; "Amy"; "Clara"]
val newNames : string list =
  ["Ace"; "Rose"; "Martha"; "Donna"; "Amy"; "Clara"]</pre><p><a id="iddle1574" class="indexterm"/><a id="iddle1575" class="indexterm"/><a id="iddle1907" class="indexterm"/><a id="iddle1908" class="indexterm"/><a id="iddle1909" class="indexterm"/>The <code class="literal">cons</code> operator doesn’t make any changes to the existing list. Instead, it simply creates a new list with its head set to the new value and tail set to the existing list. The <code class="literal">cons</code> operator can add only a single item to the list, but since it’s at the beginning of the list it’s a quick operation. If you want to combine two lists, you’ll need to turn to list concatenation.</p><p>To concatenate two lists, you can use either the list concatenation operator (<code class="literal">@</code>) or the <code class="literal">List.append</code> module function, as follows:</p><a id="pro_id00368"/><pre class="programlisting">&gt; <span class="strong"><strong>let classicNames = [ "Susan"; "Barbara"; "Sarah Jane" ]</strong></span>
<span class="strong"><strong>let modernNames = [ "Rose"; "Martha"; "Donna"; "Amy"; "Clara" ];;</strong></span>

val classicNames : string list = ["Susan"; "Barbara"; "Sarah Jane"]
val modernNames : string list = ["Rose"; "Martha"; "Donna"; "Amy"; "Clara"]

&gt; <span class="strong"><strong>classicNames @ modernNames;;</strong></span>
val it : string list =
  ["Susan"; "Barbara"; "Sarah Jane"; "Rose"; "Martha"; "Donna"; "Amy"; "Clara"]
&gt; <span class="strong"><strong>List.append classicNames modernNames;;</strong></span>
val it : string list =
  ["Susan"; "Barbara"; "Sarah Jane"; "Rose"; "Martha"; "Donna"; "Amy"; "Clara"]</pre><p>There’s no difference between the list created with the concatenation operator and the list created by <code class="literal">List.append</code>. Internally, <code class="literal">List.append</code> wraps the append operator so they’re functionally equivalent.</p><p>To combine more than two lists at once, you can pass a sequence of lists to <code class="literal">List.concat</code> like this:</p><a id="pro_id00369"/><pre class="programlisting">&gt; <span class="strong"><strong>List.concat [[ "Susan"; "Sarah Jane" ]</strong></span>
             <span class="strong"><strong>[ "Rose"; "Martha" ]</strong></span>
             <span class="strong"><strong>["Donna"; "Amy"; "Clara"]];;</strong></span>
val it : string list =
  ["Susan"; "Sarah Jane"; "Rose"; "Martha"; "Donna"; "Amy"; "Clara"]</pre><p>Now, what started as three independent lists was combined into a single list containing each item.</p></div></div></div><div class="sect1" title="Sets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sets">Sets</h2></div></div></div><p>In F#, a <span class="emphasis"><em>set</em></span> is an immutable collection of unique values whose order is not preserved. F# sets closely correlate to mathematical sets (think Venn diagrams) and provide a number of operations useful for comparing sets.</p><div class="sect2" title="Creating Sets"><div class="titlepage"><div><div><h3 class="title" id="creating_sets">Creating Sets</h3></div></div></div><p>There are no syntactic niceties like special bracket formats for creating sets, so if you want to use one, you’ll need to rely on either the type constructor or some of the <code class="literal">Set</code> module functions (like <code class="literal">Set.ofList</code>, which creates a set <a id="iddle1050" class="indexterm"/><a id="iddle1906" class="indexterm"/><a id="iddle1913" class="indexterm"/><a id="iddle1914" class="indexterm"/><a id="iddle1915" class="indexterm"/>from an F# list). For instance, to create a set containing the letters of the alphabet, you could write:</p><a id="pro_id00370"/><pre class="programlisting">&gt; <span class="strong"><strong>let alphabet = [ 'A'..'Z' ] |&gt; Set.ofList;;</strong></span>

val alphabet : Set&lt;char&gt; =
  set ['A'; 'B'; 'C'; 'D'; 'E'; 'F'; 'G'; 'H'; 'I'; ...]</pre><p>The <code class="literal">Set&lt;'T&gt;</code> class defines methods to add and remove values from a set, but because F# sets are immutable, both of these methods return new sets and leave the original intact. The <code class="literal">Add</code> method can be useful for populating a new set from an empty one, like so:</p><a id="pro_id00371"/><pre class="programlisting">&gt; <span class="strong"><strong>let vowels = Set.empty.Add('A').Add('E').Add('I').Add('O').Add('U');;</strong></span>

val vowels : Set&lt;char&gt; = set ['A'; 'E'; 'I'; 'O'; 'U']</pre><p>Of course, creating sets in this manner is a more object-oriented approach than is typical in F#.</p></div><div class="sect2" title="Working with Sets"><div class="titlepage"><div><div><h3 class="title" id="working_with_sets">Working with Sets</h3></div></div></div><p>Because sets are so closely related to mathematical sets, the <code class="literal">Set</code> module provides several functions for performing a variety of set operations like finding unions, intersections, and differences, and even determining if two sets are related as subsets or supersets.</p><div class="sect3" title="Unions"><div class="titlepage"><div><div><h4 class="title" id="unions">Unions</h4></div></div></div><p>To find the union of two sets—that is, those elements contained within either the first or second set—you use the <code class="literal">Set.union</code> function as follows:</p><a id="pro_id00372"/><pre class="programlisting">&gt; <span class="strong"><strong>let set1 = [ 1..5 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>let set2 = [ 3..7 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>Set.union set1 set2;;</strong></span>

val set1 : Set&lt;int&gt; = set [1; 2; 3; 4; 5]
val set2 : Set&lt;int&gt; = set [3; 4; 5; 6; 7]
val it : Set&lt;int&gt; = set [1; 2; 3; 4; 5; 6; 7]</pre><p>Here, <code class="literal">set1</code> contains the integers one through five, while <code class="literal">set2</code> contains the integers three through seven. Because the union of two sets contains each distinct value found in either set, the union of <code class="literal">set1</code> and <code class="literal">set2</code> is the range of integers from one through seven.</p><p>The <code class="literal">Set&lt;'T&gt;</code> class also defines a custom <code class="literal">+</code> operator you can use to find the union of two sets:</p><a id="pro_id00373"/><pre class="programlisting">&gt; <span class="strong"><strong>set1 + set2;;</strong></span>
val it : Set&lt;int&gt; = set [1; 2; 3; 4; 5; 6; 7]</pre></div><div class="sect3" title="Intersections"><div class="titlepage"><div><div><h4 class="title" id="intersections">Intersections</h4></div></div></div><p><a id="iddle1023" class="indexterm"/><a id="iddle1061" class="indexterm"/><a id="iddle1899" class="indexterm"/><a id="iddle1900" class="indexterm"/><a id="iddle1901" class="indexterm"/><a id="iddle1902" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle1904" class="indexterm"/><a id="iddle1905" class="indexterm"/><a id="iddle1910" class="indexterm"/><a id="iddle1911" class="indexterm"/><a id="iddle1912" class="indexterm"/>The <code class="literal">Set.intersect</code> function returns a new set containing only the elements found in both sets. For example, if you have a set containing the values one through five, and another set containing the values three through seven, you’d find the intersection like this:</p><a id="pro_id00374"/><pre class="programlisting">&gt; <span class="strong"><strong>let set1 = [ 1..5 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>let set2 = [ 3..7 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>Set.intersect set1 set2;;</strong></span>

val set1 : Set&lt;int&gt; = set [1; 2; 3; 4; 5]
val set2 : Set&lt;int&gt; = set [3; 4; 5; 6; 7]
val it : Set&lt;int&gt; = set [3; 4; 5]</pre><p>The resulting intersection set contains only the three values common to both <code class="literal">set1</code> and <code class="literal">set2</code>—in this case, 3, 4, and 5.</p></div><div class="sect3" title="Differences"><div class="titlepage"><div><div><h4 class="title" id="differences">Differences</h4></div></div></div><p>While the intersection contains all elements common to both sets, the difference contains those elements found only in the first set. You can find the difference between two sets with the <code class="literal">Set.difference</code> function.</p><a id="pro_id00375"/><pre class="programlisting">&gt; <span class="strong"><strong>let set1 = [ 1..5 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>let set2 = [ 3..7 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>Set.difference set1 set2;;</strong></span>

val set1 : Set&lt;int&gt; = set [1; 2; 3; 4; 5]
val set2 : Set&lt;int&gt; = set [3; 4; 5; 6; 7]
val it : Set&lt;int&gt; = set [1; 2]</pre><p>Here, the first set contains two elements not found in the second, <code class="literal">1</code> and <code class="literal">2</code>; therefore, the difference set contains only those values.</p><p>Just as with intersections, the <code class="literal">Set&lt;'T&gt;</code> class defines a custom <code class="literal">–</code> operator that returns a set containing the difference between two sets.</p><a id="pro_id00376"/><pre class="programlisting">&gt; <span class="strong"><strong>set1 - set2;;</strong></span>
val it : Set&lt;int&gt; = set [1; 2]</pre></div><div class="sect3" title="Subsets and Supersets"><div class="titlepage"><div><div><h4 class="title" id="subsets_and_supersets">Subsets and Supersets</h4></div></div></div><p>The <code class="literal">Set</code> module makes it easy to determine whether two sets are related as subsets or supersets through four functions: <code class="literal">isSubset</code>, <code class="literal">isProperSubset</code>, <code class="literal">isSuperset</code>, and <code class="literal">isProperSuperset</code>. The difference between basic subset/superset and proper subset/supersets is that proper subsets/supersets require at least one additional element not present in the opposite set. The following sets illustrate:</p><a id="pro_id00377"/><pre class="programlisting">&gt; <span class="strong"><strong>let set1 = [ 1..5 ] |&gt; Set.ofList</strong></span>
<span class="strong"><strong>let set2 = [ 1..5 ] |&gt; Set.ofList;;</strong></span>

val set1 : Set&lt;int&gt; = set [1; 2; 3; 4; 5]
val set2 : Set&lt;int&gt; = set [1; 2; 3; 4; 5]</pre><p><a id="iddle1615" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle1623" class="indexterm"/>Because both <code class="literal">set1</code> and <code class="literal">set2</code> contain the same values, <code class="literal">set1</code> can be considered a superset of <code class="literal">set2</code>. Conversely, <code class="literal">set2</code> can be considered a subset of <code class="literal">set1</code>. For the same reason, however, <code class="literal">set2</code> cannot be a proper subset of <code class="literal">set1</code>, as shown in the following snippet.</p><a id="pro_id00378"/><pre class="programlisting">&gt; <span class="strong"><strong>Set.isSuperset set1 set2;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>Set.isProperSuperset set1 set2;;</strong></span>
val it : bool = false
&gt; <span class="strong"><strong>Set.isSubset set2 set1;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>Set.isProperSubset set2 set1;;</strong></span>
val it : bool = false</pre><p>To make <code class="literal">set2</code> a proper subset of <code class="literal">set1</code>, we need to redefine <code class="literal">set1</code> to include at least one more value.</p><a id="pro_id00379"/><pre class="programlisting">&gt; <span class="strong"><strong>let set1 = [ 0..5 ] |&gt; Set.ofList;;</strong></span>

val set1 : Set&lt;int&gt; = set [0; 1; 2; 3; 4; 5]</pre><p>Now, if we test for subsets and supersets again, we should see that <code class="literal">set2</code> is both a subset and proper subset of <code class="literal">set1</code>.</p><a id="pro_id00380"/><pre class="programlisting">&gt; <span class="strong"><strong>Set.isSuperset set1 set2;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>Set.isProperSuperset set1 set2;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>Set.isSubset set2 set1;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>Set.isProperSubset set2 set1;;</strong></span>
val it : bool = true</pre></div></div></div><div class="sect1" title="Maps"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="maps">Maps</h2></div></div></div><p>The <code class="literal">Map</code> type represents an unordered, immutable dictionary (a map of keys to values) and provides many of the same capabilities as the generic <code class="literal">Dictionary&lt;'TKey, 'TValue&gt;</code> class.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note05"/>Note</h3><p><span class="emphasis"><em>Although the <code class="literal">Map&lt;'Key</code>, <code class="literal">'Value&gt;</code> class and the associated <code class="literal">Map</code> module provide methods for adding and removing entries, as an immutable construct, maps make sense only when the underlying entries won’t change. Adding and removing entries from a map requires creating a new map instance and copying the data from the source instance, so it is significantly slower than modifying a mutable dictionary.</em></span></p></div><div class="sect2" title="Creating Maps"><div class="titlepage"><div><div><h3 class="title" id="creating_maps">Creating Maps</h3></div></div></div><p><a id="iddle1616" class="indexterm"/><a id="iddle1617" class="indexterm"/><a id="iddle1622" class="indexterm"/><a id="iddle1625" class="indexterm"/>As with sets, F# doesn’t provide any direct syntactic support for creating maps, so the type constructor or <code class="literal">Map</code> module functions are required to create them, too. Regardless of the approach you choose, maps are always based on a sequence of tuples consisting of both the key and the mapped value. Here, a list of states and their respective capitals is passed to the type’s constructor:</p><a id="pro_id00381"/><pre class="programlisting">&gt; <span class="strong"><strong>let stateCapitals =</strong></span>
  <span class="strong"><strong>Map [("Indiana", "Indianapolis")</strong></span>
       <span class="strong"><strong>("Michigan", "Lansing")</strong></span>
       <span class="strong"><strong>("Ohio", "Columbus")</strong></span>
       <span class="strong"><strong>("Kentucky", "Frankfort")</strong></span>
       <span class="strong"><strong>("Illinois", "Springfield")];;</strong></span>

val stateCapitals : Map&lt;string, string&gt; =
  map
    [("Illinois", "Springfield"); ("Indiana", "Indianapolis");
     ("Kentucky", "Frankfort"); ("Michigan", "Lansing"); ("Ohio", "Columbus")]</pre></div><div class="sect2" title="Working with Maps"><div class="titlepage"><div><div><h3 class="title" id="working_with_maps">Working with Maps</h3></div></div></div><p>Because maps are like immutable dictionaries, interacting with them is similar to <code class="literal">Dictionary&lt;'TKey, 'TValue&gt;</code>.</p><div class="sect3" title="Finding Values"><div class="titlepage"><div><div><h4 class="title" id="finding_values">Finding Values</h4></div></div></div><p>Like the generic dictionary, the <code class="literal">Map</code> type provides an indexed property for accessing a value via a known key. For instance, using the <code class="literal">stateCapitals</code> map, we can find Indiana’s capital like this:</p><a id="pro_id00382"/><pre class="programlisting">&gt; <span class="strong"><strong>stateCapitals.["Indiana"];;</strong></span>
val it : string = "Indianapolis"</pre><p>The <code class="literal">Map.find</code> function lets us do the same thing functionally.</p><a id="pro_id00383"/><pre class="programlisting">&gt; <span class="strong"><strong>stateCapitals |&gt; Map.find "Indiana";;</strong></span>
val it : string = "Indianapolis"</pre><p>The biggest problem with both of the preceding approaches is that they’ll throw a <code class="literal">KeyNotFoundException</code> when the key isn’t present in the map. To avoid the exception, you can see if the map contains a particular key with the <code class="literal">Map.containsKey</code> function. If you wanted to test whether <code class="literal">stateCapitals</code> included Washington, you could write this:</p><a id="pro_id00384"/><pre class="programlisting">&gt; <span class="strong"><strong>stateCapitals |&gt; Map.containsKey "Washington";;</strong></span>
val it : bool = false</pre><p><a id="iddle1240" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1624" class="indexterm"/>Finally, if you prefer to test for the key and get the mapped value in a single operation you can turn to the <code class="literal">Map.tryFind</code> function, which returns an <code class="literal">option</code> indicating whether the key was found and the associated value, as shown here:</p><a id="pro_id00385"/><pre class="programlisting">&gt; <span class="strong"><strong>stateCapitals |&gt; Map.tryFind "Washington";;</strong></span>
val it : string option = None
&gt; <span class="strong"><strong>stateCapitals |&gt; Map.tryFind "Indiana";;</strong></span>
val it : string option = Some "Indianapolis"</pre></div><div class="sect3" title="Finding Keys"><div class="titlepage"><div><div><h4 class="title" id="finding_keys">Finding Keys</h4></div></div></div><p>Occasionally, you may need to find a key based on its mapped value. The <code class="literal">Map</code> module provides two functions for this: <code class="literal">findKey</code> and <code class="literal">tryFindKey</code>. Like their value-finding counterparts, the difference between <code class="literal">findKey</code> and <code class="literal">tryFindKey</code> is that <code class="literal">findKey</code> throws <code class="literal">KeyNotFoundException</code> when it can’t find a value that satisfies the criteria, whereas <code class="literal">tryFindKey</code> does not.</p><p>To look up a key, you pass a function that accepts both the key and its mapped value and returns a Boolean indicating whether the value matches your criteria. For instance, to find a state by its capital using <code class="literal">Map.tryFindKey</code>, you could write:</p><a id="pro_id00386"/><pre class="programlisting">&gt; <span class="strong"><strong>stateCapitals |&gt; Map.tryFindKey (fun k v -&gt; v = "Indianapolis");;</strong></span>
val it : string option = Some "Indiana"
&gt; <span class="strong"><strong>stateCapitals |&gt; Map.tryFindKey (fun k v -&gt; v = "Olympia");;</strong></span>
val it : string option = None</pre><p>As you can see, <code class="literal">tryFindKey</code> returns an option, so you’ll need to test for <code class="literal">Some</code> and <code class="literal">None</code> accordingly.</p></div></div></div><div class="sect1" title="Converting Between Collection Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="converting_between_collection_types">Converting Between Collection Types</h2></div></div></div><p>Sometimes you’ll have an instance of one collection type but you really need a different one. For instance, you might be working with an F# list but want to apply a function that works only with arrays. Each of the collection modules includes several functions that make converting between many of the other collection types easy.</p><p>In each module, the conversion functions are named according to the conversion direction and target type. For instance, to convert a sequence to an array, you could pass the sequence to either <code class="literal">Seq.toArray</code> or <code class="literal">Array.ofSeq</code> like this:</p><a id="pro_id00387"/><pre class="programlisting">&gt; <span class="strong"><strong>seq { 1..10 } |&gt; Seq.toArray;;</strong></span>
val it : int [] = [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|]
&gt; <span class="strong"><strong>seq { 1..10 } |&gt; Array.ofSeq;;</strong></span>
val it : int [] = [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|]</pre><p>Similarly, to convert from a list to a sequence, you could pass the list to either <code class="literal">List.toSeq</code> or <code class="literal">Seq.ofList</code>. The <code class="literal">Set</code> and <code class="literal">Map</code> modules let you convert to and from sequences, arrays, and maps according to the same conventions.</p><p>Although most of the conversion functions create a new collection, some of them work by casting. For example, <code class="literal">Seq.ofList</code> simply casts the source list to <code class="literal">seq&lt;'t&gt;</code> (remember, <code class="literal">FSharpList&lt;'T&gt;</code> implements <code class="literal">IEnumerable&lt;'T&gt;</code>, so it’s a valid conversion), whereas <code class="literal">List.ofArray</code> creates a new array and populates it with the list’s values. If there’s ever a question as to whether the resulting collection is a type conversion or a new object, you can inspect them with the static <code class="literal">obj.ReferenceEquals</code> method as shown here:</p><a id="pro_id00388"/><pre class="programlisting">&gt; <span class="strong"><strong>let l = [ 1..10 ]</strong></span>
<span class="strong"><strong>obj.ReferenceEquals(l, Seq.ofList l);;</strong></span>

val l : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
val it : bool = ① true

&gt; <span class="strong"><strong>let a = [| 1..10 |]</strong></span>
<span class="strong"><strong>obj.ReferenceEquals(a, List.ofArray a);;</strong></span>

val a : int [] = [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|]
val it : bool = ② false</pre><p>The preceding snippet shows the result of calling both <code class="literal">Seq.ofList</code> and <code class="literal">List.ofArray</code>. You can see that ① <code class="literal">Seq.ofList</code> returns the same object, whereas <code class="literal">List.ofArray</code> ② returns a new object.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00011">Summary</h2></div></div></div><p>Working with data collections is something virtually every nontrivial application must do. F# lets you work with all of the traditional .NET collections like arrays and generic lists but also adds several other types like the F# list, sets, and maps, which are more suitable for functional programming.</p><p>In many regards, working with data collections in F# is more streamlined than in traditional .NET development because language features like sequence expressions, range expressions, and slice expressions make it easier to not only create collections, but also get at individual elements.</p><p>Finally, the various collection modules like <code class="literal">Seq</code>, <code class="literal">Array</code>, and <code class="literal">List</code> provide an easy mechanism for performing many common tasks with their respective collection types.</p></div></section></body></html>