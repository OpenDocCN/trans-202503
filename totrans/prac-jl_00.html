<html><head></head><body>
<h2 class="h"><span epub:type="pagebreak" id="page_xxi" class="calibre1"/><strong class="calibre2">INTRODUCTION</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">I often feel that the American programmer would profit more from learning, say, Latin than from learning yet another programming language.</em></p>
<p class="center1">—Edsger Dijkstra</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Julia is a fairly new programming language. It emerged into the public sphere in 2012 after two and a half years of research by four computer scientists at MIT. Julia’s creators explained why they needed to create a new language: they were “greedy.”</p>
<p class="indent">There were already languages that were fast, such as C and Fortran. They were well suited to writing programs that ran on giant supercomputers to simulate the weather or design airplanes. But their syntax was not the friendliest; programs in these languages demanded a certain amount of ceremony. And they didn’t provide an interactive experience; one could not improvise and explore at the terminal, but had to submit to an edit-compile-run discipline.</p>
<p class="indent">Other languages existed that dispensed with ceremony and that one could use as interactive calculators, such as Python and MATLAB. However, <span epub:type="pagebreak" id="page_xxii"/>programs written in these languages were slow. Also, such languages often were not well suited to keeping large programs organized.</p>
<p class="indent">Julia’s creators were greedy because they wanted it all: a language that was as easy to use as Python but was also as fast as Fortran. The solutions that people bolted on to Python (for example) to make it faster often involved rewriting the time-consuming parts of their programs in a faster language, such as C. The resulting chimera meant maintaining code in two languages, with the resulting organizational, personnel, and mental overhead issues. This is called the “two language problem,” and one of the motivations behind Julia was to eliminate it.</p>
<p class="indent">Julia is now widely acclaimed as a real solution to the two-language problem. In fact, it’s one of only three languages that belong to the “petaflop club,” reaching the very top rank of performance on giant number-crunching problems (the other two are Fortran and C++). Uniquely, Julia combines this high level of performance with the ability to serve as an interactive calculator, whether with its highly polished read-eval-print loop (REPL), in development environments of various kinds, or in browser-based notebooks.</p>
<p class="indent">For those who have worked with Python, Octave, MATLAB, JavaScript using Node, or other REPL-based language systems, the Julia experience will be familiar. You can simply type <span class="literal">julia</span> in a terminal, and you’ll see a brief startup message and a welcoming interactive prompt. Now you can type expressions and get immediate results printed back out on the terminal. You can define variables and functions, operate on arrays, import libraries of functions, read data from the disk or the network, and generally use the language as a sophisticated calculator. You never have to declare the types of variables nor spin any other boilerplate that comes between you and your work.</p>
<p class="indent">Those are the similarities to other interpreted languages. You’ll also encounter some differences. You might notice occasional delays of a few seconds that usually don’t occur with languages like Python. This happens because Julia isn’t really an interpreted language, but it is doing both pre-compilation of code and just-in-time (JIT) compilation behind the scenes.</p>
<p class="indent">As you’ll discover, this trade-off is worthwhile when your calculations get big. Your experience with other interactive languages may cause you to expect things to grind to a halt, but you will find, instead, that your code will execute with the speed of a compiled language like Fortran.</p>
<p class="indent">As you explore further, you’ll discover that Julia is not like other languages you may be familiar with. At first, it seems superficially the same. You can type <span class="literal">1 + 1</span> and get <span class="literal">2</span> back. But you’ll learn that Julia is neither object oriented like Python, nor traditionally functional like Haskell, nor is it like whatever JavaScript is. The language is organized around a different principle, and that’s the source of much of its power.</p>
<h3 class="h2" id="ch00lev1"><strong class="calibre2">Why Is Julia Popular with Scientists?</strong></h3>
<p class="noindent">Julia is organized around something called multiple dispatch, which is enabled by a powerful and flexible type system. Later, you’ll learn more about <span epub:type="pagebreak" id="page_xxiii"/>what these things mean and how to take advantage of them in your programs. For now, file this idea away for future reference: the multiple dispatch system is as important a reason as Julia’s famous interactivity and speed for its success in the scientific world. While Julia is not the first language to incorporate this feature, it’s the first one to combine it with the other virtues that make it genuinely useful for the research community.</p>
<p class="indent">It is this design feature that enables an unprecedented level and ease of code reuse and recombination. This, as much as any benchmark, is what delights the researchers who have adopted Julia as their computational tool. Julia is taking off with scientists largely because it allows them to use each other’s code and recombine libraries to create new functionalities in ways not envisioned by the library’s authors. You’ll see many examples of this in later chapters, especially in <a href="part2.xhtml" class="calibre10">Part II</a>. You’ll also see how the type system and Julia’s metaprogramming abilities allow you to bend the language to fit your problem perfectly, with no compromise in performance.</p>
<h3 class="h2" id="ch00lev2"><strong class="calibre2">What Will This Book Do for You?</strong></h3>
<p class="noindent">After reading <a href="part1.xhtml" class="calibre10">Part I</a>, and whatever interests you in <a href="part2.xhtml" class="calibre10">Part II</a>, you’ll be able to take full advantage of Julia to solve any computational problem that confronts you. You will know how to explore and visualize data, solve equations, write simulations, and use and create libraries. The emphasis here is on applying Julia to research problems. The approach is direct and practical, with a minimum of theoretical computer science. I’ll teach you how to write efficient code that runs on a laptop or on large distributed systems. Whether your interest is in scientific research, mathematics, statistics, or just fun, you’ll learn how to make intelligent use of this tool and how to enjoy doing so.</p>
<p class="indent">This book starts at the beginning, assuming that you have never touched Julia. I don’t assume any particular knowledge of numerical methods or computational techniques, explaining everything of this sort as needed. I assume only that you’ve had some contact with basic programming concepts. In other words, when I describe how to write an <span class="literal">if</span> statement in Julia, I’ll expect that you’re familiar, in a general sense, with the concept of using conditions.</p>
<h3 class="h2" id="ch00lev3"><strong class="calibre2">How to Use This Book</strong></h3>
<p class="noindent">The material in <a href="part1.xhtml" class="calibre10">Part I</a> builds sequentially, so, ideally, you’ll read those chapters in order. The chapters in <a href="part2.xhtml" class="calibre10">Part II</a>, by contrast, depend only on the material in <a href="part1.xhtml" class="calibre10">Part I</a>, not on each other. You can successfully read the biology chapter without looking at the physics chapter. Of course, I encourage everyone to read every chapter! Here’s why: some particular techniques are developed in application chapters in which they are most likely to be relevant. However, due to the nature of scientific research, any bit of computational knowledge can potentially find application in any discipline. For example, a biologist may find the material in the physics chapter about <span epub:type="pagebreak" id="page_xxiv"/>differential equation solvers to be useful in modeling population dynamics. Since the chapters in <a href="part2.xhtml" class="calibre10">Part II</a> are not in any particular order, however, it will probably be most natural to read the chapter of immediate interest to you first, and return to the others at your leisure.</p>
<p class="indent">The book has an extensive index, which should make it easy to root out any subject, no matter where it is hiding.</p>
<p class="indent">In order to get the most out of a book such as this, read it with a Julia prompt open, so you can try things out as you encounter them in the text. The hands-on approach cements ideas far more effectively than simply reading. As you follow along, you’ll find that you want to try out variations of my sample code and learn how the language behaves through trial and error. You won’t break anything. If you get into a weird state that you don’t know how to fix, you can simply exit the REPL and start it up again. In addition, the Julia REPL has a well-implemented documentation mode, where you can access all the gruesome details about any particular function to supplement what’s in the text.</p>
<p class="indent">This book has a companion website at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a> where you can find runnable versions of all the major code listings in the text, datafiles used by the programs, color versions of the illustrations, example animations, and videos of simulations.</p>
<h3 class="h2" id="ch00lev4"><strong class="calibre2">Book Overview</strong></h3>
<p class="noindent">In <a href="part1.xhtml" class="calibre10">Part I</a>, after the preliminaries dealing with installation and the coding environment, we focus on learning Julia: the syntax, data types, concepts, and best practices. This part also contains chapters about the module and package system and visualization.</p>
<div class="bqparan">
<p class="noindentin"><strong class="calibre7"><a href="ch01.xhtml" class="calibre10">Chapter 1: Getting Started</a></strong> Introduces the hardware and experience needed for running Julia and benefiting from this book, and provides a guide to installation on various operating systems. We also review the most common coding environments and end with some recommendations.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch02.xhtml" class="calibre10">Chapter 2: Language Basics</a></strong> Provides an introduction to the concepts, syntax, and data types of Julia that will equip you with a solid, basic understanding of the language.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch03.xhtml" class="calibre10">Chapter 3: Modules and Packages</a></strong> Describes how to organize your Julia programs, how to incorporate code from others into your work, and how you can be a part of the Julia community.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch04.xhtml" class="calibre10">Chapter 4: The Plotting System</a></strong> Concentrates on Julia’s powerful <span class="literal">Plots</span> package. You’ll learn how to make and customize every common type of 2D and 3D plot and how to create interactive graphics and finished illustrations for publication.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch05.xhtml" class="calibre10">Chapter 5: Collections</a></strong> Introduces data types such as sets, strings, arrays, dictionaries, structs, and tuples. This chapter covers comprehensions and generators, operators over collections, array initialization and manipulation, and Julia’s various types of strings.</p>
<p class="noindentin"><span epub:type="pagebreak" id="page_xxv"/><strong class="calibre7"><a href="ch06.xhtml" class="calibre10">Chapter 6: Functions, Metaprogramming, and Errors</a></strong> Delves further into functions, treating different ways to define and supply arguments, and higher-order functions. It includes an introduction to metaprogramming, involving the use of symbols, expression objects, and macros to write code that manipulates code.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch07.xhtml" class="calibre10">Chapter 7: Diagrams and Animations</a></strong> Shows how to use a flexible and powerful package for mathematical and other diagrams, and a more specialized tool for drawing node-and-edge graphs. We’ll explore two packages providing different approaches for creating animations, and we’ll use several of these packages in later chapters to create illustrations and videos.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch08.xhtml" class="calibre10">Chapter 8: The Type System</a></strong> Covers more details about Julia’s different kinds of numbers and other objects, the type hierarchy, type assertions and declarations, and how to create our own types. It explains how to use the type system in concert with multiple dispatch to organize our programs and the connection between types and performance. In addition, a section on plotting recipes reveals the unique power of Julia’s plotting system.</p>
</div>
<p class="indent"><a href="part2.xhtml" class="calibre10">Part II</a> contains chapters devoted to particular fields of research, plus a final chapter on parallel processing. Each chapter uses one or more specialized packages widely used in an area of application, and tackles at least one interesting problem in its specialty.</p>
<div class="bqparan">
<p class="noindentin"><strong class="calibre7"><a href="ch09.xhtml" class="calibre10">Chapter 9: Physics</a></strong> Shows how to enrich numbers with units and uncertainties, a subject of potential interest to scientists in many fields. A detailed example of thermal convection demonstrates how to use a powerful fluid dynamics package. The chapter ends with an introduction to a state-of-the-art package for solving differential equations.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch10.xhtml" class="calibre10">Chapter 10: Statistics</a></strong> Discusses concepts in statistics and probability theory, such as distributions, and relates them to functions and types provided by relevant Julia packages. It applies these ideas to the simulation of the spread of an infection, and it introduces dataframes by slicing and dicing real data about COVID cases.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch11.xhtml" class="calibre10">Chapter 11: Biology</a></strong> Explores agent-based modeling and shows how to use Julia’s <span class="literal">Agents</span> package to simulate the evolution of creatures who learn how to avoid being captured by predators. It builds on some ideas from the statistics chapter to analyze the results.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch12.xhtml" class="calibre10">Chapter 12: Mathematics</a></strong> Focuses on symbolic mathematics (computer algebra) and linear algebra. It describes two main approaches to the first topic, including hybrid numerical-symbolic techniques. It covers the basic use of linear algebra packages to solve equations and efficiently perform matrix operations by taking advantage of the type system.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch13.xhtml" class="calibre10">Chapter 13: Scientific Machine Learning</a></strong> Explores concepts and techniques in a relatively new area that exploits ideas from machine learning <span epub:type="pagebreak" id="page_xxvi"/>to infer properties of models. It shows how to use automatic differentiation in several contexts, and introduces probabilistic programming through Julia’s <span class="literal">Turing</span> package.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch14.xhtml" class="calibre10">Chapter 14: Signal and Image Processing</a></strong> Focuses on signals and images. The signal section covers Fourier analysis, filtering, and related topics, using a bird call as the working example. The image section uses feature recognition in the problem of counting blood cells and examines several techniques for image resizing, smoothing, and other manipulations. In this context it delves further into advanced array concepts.</p>
<p class="noindentin"><strong class="calibre7"><a href="ch15.xhtml" class="calibre10">Chapter 15: Parallel Processing</a></strong> Explains how to run our programs on more than one CPU core or computer. The chapter discusses the different concurrency paradigms and how to take advantage of multithreading and multiprocessing. We’ll see how to run our programs on a network with machines all over the world, with no change to the code.</p>
</div>
<div class="box">
<p class="boxtitle-d"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">For details on the inspiration for the Julia language, see “Why We Created Julia”: <a href="https://julialang.org/blog/2012/02/why-we-created-julia/" class="calibre10"><em class="calibre11">https://julialang.org/blog/2012/02/why-we-created-julia/</em></a>.</li>
<li class="noindent1">My article in <em class="calibre11">Ars Technica</em>, “The Unreasonable Effectiveness of the Julia Programming Language,” explains the underlying reasons for Julia’s wide adoption among scientists: <a href="https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/" class="calibre10"><em class="calibre11">https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/</em></a>.</li>
<li class="noindent1">If you’re a Python programmer and want a very brief rundown of the differences in syntax, see “Julia for Python Programmers” by Dr. John D. Cook, at <a href="http://www.johndcook.com/blog/2015/09/15/julia-for-python-programmers/" class="calibre10"><em class="calibre11">http://www.johndcook.com/blog/2015/09/15/julia-for-python-programmers/</em></a>.</li>
<li class="noindent1">If, instead, you come from Lisp, take a look at “A Lisper’s First Impression of Julia” by Pascal Costanza at <a href="https://p-cos.blogspot.com/search?q=first+impression+of+Julia" class="calibre10"><em class="calibre11">https://p-cos.blogspot.com/search?q=first+impression+of+Julia</em></a>. It’s from 2014, but still of interest.</li>
<li class="noindent1">For the original theoretical justification explaining the need of a new language and how Julia’s design decisions meet that need, see “Julia: A Fresh Approach to Numerical Computing,” authored by Julia creators Jeff Bezanson, Alan Edelman, Stefan Karpinski, and Viral B. Shah (<a href="http://arxiv.org/abs/1411.1607" class="calibre10"><em class="calibre11">http://arxiv.org/abs/1411.1607</em></a>).</li>
<li class="noindent1">For another version of Julia’s creation story, see Klint Finley’s “Out in the Open: Man Creates One Programming Language to Rule Them All” (<a href="https://www.wired.com/2014/02/julia/" class="calibre10"><em class="calibre11">https://www.wired.com/2014/02/julia/</em></a>).</li>
<li class="noindent1">“Julia Joins Petaflop Club” from Julia Computing is an astronomical (in both senses) application of Julia (<a href="https://cacm.acm.org/news/221003-julia-joins-petaflop-club/fulltext" class="calibre10"><em class="calibre11">https://cacm.acm.org/news/221003-julia-joins-petaflop-club/fulltext</em></a>).</li>
<li class="noindent1"><span epub:type="pagebreak" id="page_xxvii"/>“Julia Update: Adoption Keeps Climbing; Is It a Python Challenger?” by John Russell (<a href="https://www.hpcwire.com/2021/01/13/julia-update-adoption-keeps-climbing-is-it-a-python-challenger/" class="calibre10"><em class="calibre11">https://www.hpcwire.com/2021/01/13/julia-update-adoption-keeps-climbing-is-it-a-python-challenger/</em></a>) provides some interesting historical perspective.</li>
<li class="noindent1">“Why I Switched to Julia” by Bradley Setzler is a case study of Julia used in econometrics that shows a 100-fold speed increase over Python with NumPy: <a href="https://juliaeconomics.com/2014/06/15/why-i-started-a-blog-about-programming-julia-for-economics/" class="calibre10"><em class="calibre11">https://juliaeconomics.com/2014/06/15/why-i-started-a-blog-about-programming-julia-for-economics/</em></a>.</li>
</ul>
</div>
</body></html>