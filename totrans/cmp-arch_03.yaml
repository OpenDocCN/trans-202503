- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**DATA REPRESENTATION**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数据表示**'
- en: '![Image](../images/f0045-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0045-01.jpg)'
- en: A computer is a device that represents things in the real world and performs
    manipulations on these representations. Entities that we might want to represent
    and make computations about include physical objects, numbers, words, sounds,
    and pictures. This chapter examines systems for representing each of these types
    of entities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一种表示现实世界中的事物并对这些表示进行操作的设备。我们可能希望表示并进行计算的实体包括物理对象、数字、词语、声音和图片。本章将研究每种实体的表示系统。
- en: We’ll begin by exploring the history of how representations of objects, numbers,
    and text have evolved. We’ll then look at the modern symbol systems used to represent
    numbers—including decimal, binary, and hex—and use number representations to construct
    representations of further entities, such as text, audio, and video.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索物体、数字和文本表示的发展历史开始。然后，我们将研究现代符号系统如何用于表示数字——包括十进制、二进制和十六进制——并利用数字表示法构建进一步的实体表示，例如文本、音频和视频。
- en: In this chapter, the modern representations are built from 0s and 1s, which
    are left as symbols themselves. In later chapters, we’ll consider how to instantiate
    these zero and one symbols in digital electronics and make use of them in computations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，现代表示法是由0和1构建的，这些0和1本身作为符号保留。在后续章节中，我们将讨论如何在数字电子学中实例化这些零和一的符号，并在计算中加以利用。
- en: A Brief History of Data Representations
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据表示的简史
- en: The concepts of representation and computation are closely linked. Humans often
    need to represent the state of part of their world, as an aid to their own memories
    or as proof to other humans that something has happened or is going to happen.
    Once you have a representation, you can also use it to perform computations, to
    simulate what would happen if certain actions were done, or to deduce conclusions
    from what is known.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表示和计算的概念密切相关。人类常常需要表示世界某一部分的状态，作为自己记忆的辅助工具，或者作为向其他人证明某事已经发生或即将发生的证据。一旦有了表示，你也可以利用它进行计算，模拟如果执行某些操作会发生什么，或者从已知信息中推导出结论。
- en: For example, we often need to keep track of who owns what and who has debts
    to be paid. Static representations are useful for these purposes, and once these
    exist we can use them in computations to answer questions such as what would happen
    if we bought something, or how long it will take to repay a debt. Representation
    thus comes before computation, both conceptually and historically. Let’s trace
    how it evolved, from humanity’s first efforts to the symbol systems that we use
    today.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们常常需要追踪谁拥有什么以及谁欠债。静态表示对于这些目的非常有用，一旦有了这些表示，我们就可以利用它们进行计算，回答例如如果我们买了某样东西，或者还债需要多长时间等问题。因此，表示在计算之前，不论是在概念上还是在历史上，都是先行的。让我们追溯它的发展，从人类的第一次尝试到我们今天使用的符号系统。
- en: '*Tally Sticks and Trading Tokens*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*刻痕棒和交易代币*'
- en: The oldest-known data representation is the use of *tally sticks*, such as the
    Lebombo bone shown in [Chapter 1](ch01.xhtml). These are simple sticks with several
    marks, where each mark represents one object. For example, the number 13 is represented
    by 13 marks, usually made in a row, as in [Figure 2-1](ch02.xhtml#ch02fig1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最古老的已知数据表示法是使用*刻痕棒*，例如在[第1章](ch01.xhtml)中展示的Lebombo骨。刻痕棒是简单的棍子，上面有若干标记，每个标记代表一个物体。例如，数字13用13个标记表示，通常是按顺序排列的，如[图2-1](ch02.xhtml#ch02fig1)所示。
- en: '![Image](../images/f0046-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0046-01.jpg)'
- en: '*Figure 2-1: A simple tally*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：一个简单的计数*'
- en: By Sumerian times (4000 BCE), physical tokens were used to represent objects,
    as in [Figure 2-2](ch02.xhtml#ch02fig2). A small clay model of an animal, for
    example, represented the actual animal and could probably have been exchanged
    for it. This would have simplified trading, as you could travel from the city
    of Ur to the city of Uruk with 10 animal tokens and make a deal by swapping them
    for, say, 20 beer tokens, with the actual objects only being moved around later,
    after a successful deal. These tokens could also have been divided between groups
    of people or given as tax to the king.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到了苏美尔时代（公元前4000年），人们开始使用物理代币来表示物体，如[图2-2](ch02.xhtml#ch02fig2)所示。例如，一只小型的泥土动物模型代表了实际的动物，并且可能可以用它交换。这样可以简化交易，你可以从城市乌尔（Ur）带着10个动物代币到城市乌鲁克（Uruk），然后用这些代币交换20个啤酒代币，实际物品的转移可能会在交易成功后再进行。这些代币也可以在不同的群体间分配，或者作为税收交给国王。
- en: '![Image](../images/f0046-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0046-02.jpg)'
- en: '*Figure 2-2: Sumerian trading tokens*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：苏美尔贸易代币*'
- en: Computing with tally sticks and tokens is, however, quite slow. To add *m* tallies
    or tokens to *n*, you have to go through the process of adding each of the *m*
    into the *n*, one at a time. If you’ve studied complexity theory, this means that
    addition is order O(*m*) in the size of the numbers being added.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用计数棒和代币进行计算是非常缓慢的。要将*m*个计数或代币加到*n*上，你必须逐一地将每个*m*加入到*n*中。如果你研究过复杂性理论，这意味着加法的时间复杂度是O(*m*)，与被加数字的大小有关。
- en: By 3000 BCE—still before the abacus—the Sumerians sped up their calculations
    by sealing many tokens in a clay “envelope” called a *bulla*, shown in [Figure
    2-3](ch02.xhtml#ch02fig3). The bulla was sealed both physically, by joining its
    clay to encapsulate the contents, and informationally, by stamping a complex,
    unforgeable mark onto it. (This is the origin of ceremonial seals still used today
    on royal and governmental documents, such as the Great Seal of the USA. It’s also
    the origin of later digital signatures.) The seal guaranteed, probably in the
    name of the king or another powerful and trustworthy person, that a certain number
    of tokens were contained within it. This way, instead of counting out 12 animal
    tokens, you could hand over a bulla of 12 animals at a time. The bulla would function
    like a 12-token coin or banknote, but one that physically contained the 12 tokens
    inside.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到公元前3000年——仍在算盘之前——苏美尔人通过将多个代币密封在一个称为*bulla*的泥土“信封”中，加速了他们的计算过程，如[图 2-3](ch02.xhtml#ch02fig3)所示。bulla既在物理上封闭，通过将泥土粘合在一起以封存内容，也在信息上通过在其上印上复杂且难以伪造的印记来封存。（这就是今天仍在王室和政府文件上使用的仪式印章的起源，比如美国的大印。这也是后来的数字签名的起源。）印章保证，可能是以国王或其他有权威且可信之人的名义，bulla内部包含了特定数量的代币。这样，你不必再逐个计数12个动物代币，而是可以一次性交付包含12个动物代币的bulla。bulla就像一枚包含12个代币的硬币或纸币，但其内部实际包含着12个代币。
- en: '![Image](../images/f0047-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-01.jpg)'
- en: '*Figure 2-3: A bulla*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：一枚封印*'
- en: A similar development to the bulla is found in tally sticks from this period,
    where tally marks started to be grouped together, as shown in [Figure 2-4](ch02.xhtml#ch02fig4).
    Counting out *n* scratches usually requires *n* operations, but if we replace,
    say, every fifth vertical stroke with a diagonal one going through the previous
    four, we can quickly count how many groups of five we have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与bulla的类似发展可以在这一时期的计数棒中找到，那里计数标记开始被分组在一起，如[图 2-4](ch02.xhtml#ch02fig4)所示。逐个数出*n*个刻痕通常需要*n*次操作，但如果我们将每第五个竖直划线替换为一条穿过前四个的斜线，我们就能快速地数出有多少组五个。
- en: '![Image](../images/f0047-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-02.jpg)'
- en: '*Figure 2-4: A grouped tally*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：分组计数*'
- en: '*Roman Numerals*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*罗马数字*'
- en: In a closely related notation to grouped tallies, we can replace the fifth stroke
    with two shorter diagonal strokes to make a V, and the tenth with an X, as in
    [Figure 2-5](ch02.xhtml#ch02fig5), forming the beginnings of the *Roman numerals*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在与分组计数密切相关的符号中，我们可以将第五条划线替换为两条较短的斜线，形成V，第十条则替换为X，如[图 2-5](ch02.xhtml#ch02fig5)所示，这标志着*罗马数字*的开始。
- en: '![Image](../images/f0047-03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-03.jpg)'
- en: '*Figure 2-5: Early Roman numerals*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：早期罗马数字*'
- en: Roman numerals developed further to closely represent the human perception of
    numbers. Humans appear to perceive the sizes of sets of 1, 2, 3, and 4 objects
    directly and immediately. Beyond this, our immediate perception is of *numerosity*
    or approximate size rather than exact number, based on sizes roughly around 5,
    10, 20, 50, 100, and 1,000\. Most number symbol alphabets reflect this, with Egyptian,
    Chinese, and Arabic numbers having special symbols for 1, 2, 3, and 4 that feature
    the corresponding number of strokes, and more abstract symbols for 5 and above.
    The Roman numeral system also uses symbols to represent the “landmark” numbers,
    such as V = 5, X = 10, L = 50, C = 100, and M = 1,000, with smaller-valued symbols
    positioned before or after to indicate adjustments to the landmark, such as VI
    = 6 and IX = 9.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字进一步发展，以更准确地反映人类对数字的感知。人类似乎能够直接并立刻感知1、2、3和4个物体的大小。超过这个范围，我们的即时感知是*数量感*或近似大小，而非确切数字，这些数字大致围绕着5、10、20、50、100和1,000。大多数数字符号字母表反映了这一点，埃及、中文和阿拉伯数字都有1、2、3和4的特殊符号，这些符号显示了相应的笔画数，而对于5及以上则使用更抽象的符号。罗马数字系统也使用符号来表示这些“标志性”数字，例如V
    = 5，X = 10，L = 50，C = 100，以及M = 1,000，较小的符号则位于标志性符号之前或之后，以表示对标志性数字的调整，例如VI = 6和IX
    = 9。
- en: Roman numerals have the advantage of being a close model of how humans actually
    think about numbers, but if you try to do large-scale arithmetic such as adding
    and multiplying with them, you’ll quickly run into difficulty. This is a classic
    example of how the choice of representation can heavily affect your ability to
    do certain types of computation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字的优点在于，它们与人类实际思考数字的方式非常接近，但如果你尝试进行大规模的算术运算，如加法和乘法，你很快就会遇到困难。这是一个经典的例子，说明了表示方法的选择如何显著影响你进行某些类型计算的能力。
- en: '*Split Tallies*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分裂记账符号*'
- en: A *split tally* was a variation of the tally stick, in which the stick was marked
    up, then split into two pieces down its length, as in [Figure 2-6](ch02.xhtml#ch02fig6).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*分裂记账符号*是记账棍的一种变体，记账棍上做标记后沿其长度将其分裂成两部分，如[图2-6](ch02.xhtml#ch02fig6)所示。'
- en: '![Image](../images/f0048-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0048-01.jpg)'
- en: '*Figure 2-6: A split tally*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：分裂记账符号*'
- en: Both halves contain parts of the same notches, and both halves could be reunited
    to show they were genuine and fitted together. They were used to record loans,
    with the long and short halves (the *stock* and *foil*) given to the lender and
    borrower, the origin of our modern financial *long* and *short* positions in stocks.
    The British government continued to use split tally sticks until it burned its
    last wooden tallies to modernize its IT systems around 1836, the time of Babbage’s
    Analytical Engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两个部分包含相同的刻痕，且可以重新结合，证明它们是真正匹配的。它们被用于记录贷款，长短两部分（*原件*和*副本*）分别交给借款人和贷款人，这也成为我们现代金融中*多头*和*空头*头寸的起源。英国政府直到1836年左右，现代化其信息技术系统时，才停止使用分裂记账棍，并烧毁了最后一批木制记账符号，那时正是巴贝奇的分析机时期。
- en: '*Arabic and Other Numerals*'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*阿拉伯数字及其他数字*'
- en: Other civilizations developed number representations using copies of symbols
    for large numbers, as shown in [Figure 2-7](ch02.xhtml#ch02fig7).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文明发展了使用符号副本表示大数字的系统，如[图2-7](ch02.xhtml#ch02fig7)所示。
- en: For example, the ancient Egyptians had symbols for 10, 100, 1,000, and 10,000\.
    The number 23 would be shown using two copies of the 10 symbol (a heel) and three
    copies of the 1 symbol (a tally stroke). The number 354,000 would be shown using
    three copies of the 100,000 symbol (a tadpole), five copies of the 10,000 symbol
    (a finger), and four copies of the 1,000 symbol (a lotus flower).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，古埃及人有10、100、1,000和10,000的符号。数字23会用两个10的符号（一个脚跟）和三个1的符号（一个记账符）表示。数字354,000会用三个100,000的符号（一个蝌蚪）、五个10,000的符号（一个手指）和四个1,000的符号（一个莲花）表示。
- en: Eastern Arabic numbers appeared in the Islamic Golden Age, based on an earlier
    Indian system from around 500 CE. This system introduced the base-exponent method
    that we use today, with fixed columns containing symbols for numbers of 1s, 10s,
    100s, 1,000s, and so on. Importantly, this introduced the need for a concept and
    symbol of zero to fill in columns having no counts, which is missing from ancient
    Egyptian and similar systems. These symbols evolved into the Arabic numerals (1,
    2, 3, and so on) used in the West today.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 东方阿拉伯数字出现在伊斯兰黄金时代，基于公元500年左右的早期印度数字系统。该系统引入了我们今天使用的基数方法，并且有固定的列，用于表示1、10、100、1,000等数字。重要的是，这一系统引入了“零”的概念和符号，用来填补没有计数的列，这在古埃及和类似的系统中是没有的。这些符号演变成了今天西方使用的阿拉伯数字（1、2、3等）。
- en: '![Image](../images/f0049-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-01.jpg)'
- en: '*Figure 2-7: Modern Arabic, Ancient Egyptian, Suzhou Chinese, and Eastern Arabic
    numerals*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：现代阿拉伯数字、古埃及数字、苏州汉字数字和东阿拉伯数字*'
- en: Suzhou Chinese numerals evolved from ancient Chinese symbols relating to the
    base 10 abacus seen previously in [Figure 1-4](ch01.xhtml#ch01fig4), and are occasionally
    still in use today. You can see the symbols for 1 to 4 are based on tally strokes,
    while those from 5 to 9 are similar symbols placed under a “bead” for 5\. For
    a few significant digits, Suzhou uses a column system similar to Arabic numerals.
    For larger numbers, however, it uses a more advanced representation that shows
    the first few significant digits, followed by a separate symbol denoting what
    power of 10 they are multiplied by. In English we sometimes do this by writing
    *354 thousand* or *354k* rather than *354,000*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 苏州的汉字数字源自与前面在[图 1-4](ch01.xhtml#ch01fig4)中看到的十进制算盘相关的古代汉字符号，并且至今偶尔仍在使用。你可以看到1到4的符号基于记数的划痕，而5到9的符号则是类似的符号放置在一个“珠子”下方，表示5。对于一些重要的数字，苏州使用一种类似阿拉伯数字的列表示法。然而，对于较大的数字，它采用更先进的表示方式，显示前几个有效数字，然后是一个单独的符号，表示它们乘以的是10的多少次方。在英语中，我们有时会写成
    *354 thousand* 或 *354k*，而不是 *354,000*。
- en: This history of number *representation* belongs more properly to computer science
    than to mathematics. We can see that, historically, *typed* quantities such as
    “five cows plus three cows” were represented and computed with before more abstract
    mathematical number concepts such as “five plus three.” Mathematics takes numbers
    for granted and performs proofs about their properties. By contrast, the business
    of representation, both of actual objects and of abstract number concepts derived
    from them, is computer science, as is the question of how to build algorithms
    and machines based on these representations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的 *表示* 历史更适合归属于计算机科学，而非数学。我们可以看到，历史上，像“5头牛加3头牛”这样的 *有形* 数量曾被表示和计算，而不是像“5加3”这样的抽象数学数字概念。数学通常将数字视为理所当然，并对它们的性质进行证明。相比之下，数字表示的事务，无论是实际物体还是从中推导出来的抽象数字概念，属于计算机科学范畴，如何基于这些表示构建算法和机器也是计算机科学的内容。
- en: Modern Number Systems
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代数字系统
- en: We’ve seen how our modern concept of numbers evolved from tallies into the symbolic,
    Arabic system used in everyday life today. The key innovation of the Arabic system
    is the use of columns to represent digits in a base. This (as we’ll see when we
    start computing) makes algorithmic arithmetic easier, and also reduces the size
    of representations. For example, you only need four symbols to represent the number
    2,021, rather than 2,021 clay tokens.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，现代数字概念是如何从记号演变为今天日常生活中使用的符号性阿拉伯数字系统的。阿拉伯系统的关键创新在于使用列来表示基数中的数字。正如我们在开始计算时会看到的，这使得算法运算更加简便，也减少了表示的大小。例如，你只需要四个符号就可以表示数字
    2,021，而不需要2,021个粘土代币。
- en: Our everyday Arabic numbers are decimal, using base 10, but this isn’t necessarily
    the base for computers. This section generalizes the idea of bases and exponents
    and presents several related systems that are useful in computers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常使用的阿拉伯数字是十进制的，使用基数10，但这并不一定是计算机使用的基数。本节将概括基数和指数的概念，并介绍一些在计算机中有用的相关系统。
- en: '*Bases and Exponents*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数和指数*'
- en: 'We will make heavy use of exponentiation in representing numbers. *Exponentiation*
    is the repeated multiplication of a *base*, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示数字时，我们将大量使用指数运算。*指数运算* 是基数的重复乘法，例如：
- en: 2³ = 2 × 2 × 2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2³ = 2 × 2 × 2
- en: Here, 2 is the base and 3 is the exponent. This may also be written as 2^3\.
    In some computer languages, it appears as `2**3`, or is written via a power function,
    such as `pow(2,3)`. Exponentiation is sometimes called “raising to the power,”
    as in “two to the power of three.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，2是基数，3是指数。它也可以写作 2^3。在某些计算机语言中，它以 `2**3` 的形式出现，或者通过幂函数表示，如 `pow(2,3)`。指数运算有时被称为“提升到某次幂”，例如“2的三次幂”。
- en: More generally, we write a base *b* to the power of an exponent *n* as
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们将基数 *b* 的 *n* 次幂写作
- en: '*b^n* = *b* × *b* × *b* × . . . × *b*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*b^n* = *b* × *b* × *b* × . . . × *b*'
- en: 'meaning there are *n* copies of *b*. Zero and negative exponentiation are defined
    as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有 *n* 个 *b*。零和负指数定义如下：
- en: '![Image](../images/f0050-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0050-01.jpg)'
- en: If we choose a base *b*, we may then define a *number system* as a mapping from
    a list of *numeral symbols* to a *number*. Symbols are marks on a piece of paper
    or entries in some other type of storage system; numbers are the actual mathematical
    objects being represented.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个基数 *b*，那么可以定义一个 *数字系统*，它是从一组 *数字符号* 到一个 *数字* 的映射。符号是写在纸上的标记或存储系统中的条目；数字是实际的数学对象。
- en: To write base *b* numbers, we need an alphabet containing *b* symbols. Strings
    of *N* of these symbols can have *b^N* different states, which are used to represent
    numbers from 0 to *b^N* – 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示*b*进制的数字，我们需要一个包含*b*个符号的字母表。由*N*个符号组成的字符串可以有*b^N*种不同的状态，用来表示从0到*b^N* – 1的数字。
- en: When we work with symbols in different bases, we will sometimes use a subscript
    to indicate what base the symbols are written in. For example, 123[10] means one
    hundred and twenty-three in base 10, while 1001[2] means one 8, no 4s, no 2s,
    and one 1 in base 2 (which equals 9[10]). In other cases, we’ll omit the subscript
    where the base is clear from the context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理不同进制的符号时，有时会使用下标来表示符号的进制。例如，123[10]表示十进制的123，而1001[2]表示在二进制中一个8，一个1，没有4和2（即9[10]）。在其他情况下，如果上下文中已经清楚进制，可能会省略下标。
- en: '*Base 10: Decimal*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*十进制：Decimal*'
- en: 'Everyday arithmetic uses base 10, in which, for example, the string of symbols
    7, 4, 3, written as 743, is interpreted as representing the number seven hundred
    and forty-three. We can see this mathematically using exponents of 10:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日常算术使用的是十进制，其中例如符号串7、4、3，写作743，表示数字七百四十三。我们可以通过10的指数来数学地理解这一点：
- en: 743 = 7 × 10² + 4 × 10¹ + 3 × 10⁰
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 743 = 7 × 10² + 4 × 10¹ + 3 × 10⁰
- en: 'Using a point notation and negative exponents, we can represent fractional
    numbers. For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小数点表示法和负指数，我们可以表示分数。例如：
- en: 743.29 = 7 × 10² + 4 × 10¹ + 3 × 10⁰ + 2 × 10^(–1) + 9 × 10^(–2)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 743.29 = 7 × 10² + 4 × 10¹ + 3 × 10⁰ + 2 × 10^(–1) + 9 × 10^(–2)
- en: 'For base 10 we have an alphabet of 10 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, and
    9\. Strings of *n* symbols from this alphabet can specify one of 10^(*n*) numbers;
    for example, with *n* = 4, there are 10,000 numbers, 0 to 9,999 inclusive.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于十进制，我们有一个包含10个符号的字母表：0、1、2、3、4、5、6、7、8和9。由*n*个符号组成的字符串可以指定10^(*n*)个数字；例如，当*n*
    = 4时，总共有10,000个数字，从0到9,999（包含）。
- en: '*Base 2: Binary*'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*二进制：Binary*'
- en: Base 2 is known as *binary* and is used in almost all modern computers. It has
    an alphabet of two symbols, usually written as 0 and 1, but sometimes as T and
    F for *true* and *false*. In electronic computers, the two symbols are represented
    using high and low voltages. *High* is usually the system’s positive voltage,
    such as 5 V or 3.3 V, while *low* is usually ground or 0 V. Binary is useful for
    electrical machines because real voltages are noisy, and attempts to include extra
    symbols such as *medium* have been doomed to failure. But *high* and *low* can
    more easily and cheaply be separated into two clear classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制（Base 2）被称为*二进制*，几乎所有现代计算机都使用它。它的字母表由两个符号组成，通常写作0和1，有时也用T和F分别表示*真*和*假*。在电子计算机中，这两个符号通过高电压和低电压来表示。*高*电压通常是系统的正电压，例如5
    V或3.3 V，而*低*电压通常是地电压或0 V。二进制对电气机器很有用，因为真实的电压信号有噪声，而尝试加入像*中*电压这样的额外符号通常会失败。但*高*和*低*可以更容易、更便宜地分成两个清晰的类别。
- en: 'A single symbol in base 2 is called a *bit*, short for *bi*nary dig*it*. A
    string of *N* bits can represent one of 2^(*N*) numbers, such as ranging from
    0 to 2^(*N*) – 1\. The columns of the string represent powers of 2\. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制中，一个符号叫做*比特*，是*二*进制数位（*bi*nary dig*it*）的缩写。一串*N*个比特可以表示2^(*N*)个数字，例如从0到2^(*N*)
    – 1。该字符串的列代表2的幂。例如：
- en: '![Image](../images/f0051-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0051-01.jpg)'
- en: The powers of two that appear in this calculation (0, 1, 2, 4, 8, 16, 32, 64,
    128, 256, 512, 1,024, 2,048, and so on) should be instantly recognizable to anyone
    used to computing. They often appear as sizes of memory capacity and as sizes
    in bits or bytes of data structures used at the hardware level. If you plan to
    work at or near the hardware level, you’ll need to memorize these powers of two
    for everyday use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此计算中出现的2的幂（0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1,024, 2,048等等）对于任何习惯于计算的人来说都是非常容易识别的。它们常常作为内存容量的大小出现，也常出现在硬件级别数据结构的比特或字节大小中。如果你计划从事或接触硬件工作，你需要记住这些2的幂以供日常使用。
- en: To convert from binary to decimal, add up the powers of two for each column
    that has a 1 in it. To convert from decimal to binary, at each step, try to subtract
    the highest power of two from the decimal, and make a note of which powers of
    two have been subtracted. Write 1s in those columns and 0s in the others.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制转换为十进制，计算每一列为1的二进制位所对应的2的幂之和。要将十进制转换为二进制，每一步尝试从十进制中减去最大的2的幂，并记录已减去的2的幂。把这些列标记为1，其他列标记为0。
- en: Some mathematical operations are faster or slower in different bases. In base
    10, you can quickly multiply or divide by 10 by shifting the decimal (radix) point
    one place to the left or right. Where numbers are represented in binary, you can
    use a similar trick to quickly multiply or divide by 2\. This is known as *binary
    shift* and is implemented in hardware by most CPUs. In the C language, for example,
    a fast multiplication by 8 (2³) can be done by writing `y=x>>3;`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同进制下，一些数学操作的速度可能会有所不同。在10进制中，你可以通过将小数点（基数）向左或向右移动一位来快速乘以或除以10。在二进制中，你可以使用类似的技巧来快速乘以或除以2。这被称为*二进制移位*，大多数CPU都通过硬件实现了它。例如，在C语言中，快速乘以8（2³）可以通过写成`y=x>>3;`来完成。
- en: Alternate notations used in some books and programming languages for binary
    include 1110[2], 0b1110, and 1110b.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些书籍和编程语言中，二进制的替代表示法包括1110[2]、0b1110和1110b。
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A famous computer science joke says, “There are 10 kinds of computer scientists:
    those who know nothing, and those who know binary.”*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一个著名的计算机科学笑话说：“有10种计算机科学家：那些一无所知的和那些懂二进制的。”*'
- en: '*Base 1,000*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*1,000进制*'
- en: As a means of introducing other notations—hex and byte codes—let’s look at decimal
    notation in a different way, which we’ll call *compound notation*. It’s common
    to write large numbers by grouping them into chunks of three digits separated
    by commas, to make them easier to read. For example, the number 123,374,743,125
    symbolizes the value one hundred and twenty-three *billion*, three hundred and
    seventy-four *million*, seven hundred and forty-three *thousand*, one hundred
    and twenty-five. (The “one hundred and twenty-five” at the end refers to the number
    of *ones*.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为引入其他符号表示法（如十六进制和字节码）的方式，让我们从不同的角度来看十进制表示法，我们将其称为*复合表示法*。通常会通过将大数字分成每三位一组并用逗号分隔来使其更易于阅读。例如，数字123,374,743,125表示一百二十三*十亿*，三百七十四*百万*，七百四十三*千*，一百二十五。（这里的“一百二十五”指的是*个位*的数目。）
- en: 'Imagine for a moment that these chunks are individual symbols, from an alphabet
    containing 1,000 symbols from 0 to 999\. Don’t think of 999 as three 9s, but as
    a single symbol. Under this view, we can consider the comma-separated string as
    a string of 4 symbols in base 1,000, rather than 12 symbols in base 10:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这些块是由包含从0到999共1,000个符号的字母表中的个别符号组成。不要把999看作三个9，而是看作一个符号。在这种观点下，我们可以把用逗号分隔的字符串看作是一个由4个符号组成的1,000进制字符串，而不是12个10进制符号：
- en: 123,374,743,125 = 123 × 1,000³ + 374 × 1,000² + 743 × 1,000¹ + 125 × 1,000⁰
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 123,374,743,125 = 123 × 1,000³ + 374 × 1,000² + 743 × 1,000¹ + 125 × 1,000⁰
- en: 'This reflects our spoken language more accurately than thinking in base 10:
    we have names for powers of 1,000 (thousand, million, billion, trillion), but
    we don’t have names for 10,000 or 100,000 or 10,000,000\. Scientific units also
    follow this base 1,000 convention: kilo, mega, giga, and so on.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这比将数字想成10进制更能准确地反映我们的口语语言：我们有1,000的幂次的名称（千、百万、十亿、万亿），但我们没有10,000、100,000或10,000,000的名称。科学单位也遵循这一1,000进制的惯例：千、兆、吉等。
- en: What’s interesting about base 1,000 is the special relationship it has to base
    10\. Usually when we change bases, we expect the symbols to have a completely
    different appearance in the two bases. But when we switch between base 10 and
    base 1,000, the written symbols don’t change at all. We’ve simply gone from thinking
    of, say, 123 as three symbols in base 10 to thinking of it as a single symbol
    in base 1,000\. This makes it very easy and convenient to convert between the
    bases, as we do in our heads whenever we see or hear large numbers in everyday
    life.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，1,000进制与10进制之间有一种特殊的关系。通常，当我们改变进制时，我们会预期在两个进制中符号的外观完全不同。但是，当我们在10进制和1,000进制之间切换时，书写符号是完全不变的。我们只是从把123看作是10进制中的三个符号，转变为把它看作是1,000进制中的一个符号。这使得在这两个进制之间转换非常简单方便，就像我们在日常生活中看到或听到大数字时会在脑中进行的转换一样。
- en: '*Base 60: Sexagesimal*'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*60进制：六十进制*'
- en: 'Let’s talk about *sexagesimal*, also known as *base 60*. This system is relevant
    to modern computing for two reasons: first, like base 1,000, it’s another example
    of the sort of compound notation we’ll explore later; and second, it’s still in
    heavy computational use today.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈*六十进制*，也叫做*60进制*。这个系统与现代计算相关的原因有两个：首先，像1,000进制一样，它是我们稍后将要探讨的一种复合符号表示的例子；其次，它今天仍在广泛使用于计算中。
- en: We believe that some prehistoric human groups counted in base 12\. When we reach
    the time of the first cities (4000 BCE), the Sumerians switched to base 60 for
    their scientific studies, which included astronomy and the invention of an algorithmic
    version of the Pythagorean theorem. This may have arisen through a fusion, collision,
    or compromise between people using bases 10 and 12, as 60 is readily divisible
    by both.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信一些史前人类群体使用的是12为基数的计数方法。当我们进入第一个城市的时代（公元前4000年）时，苏美尔人为了科学研究（包括天文学和毕达哥拉斯定理的算法版本的发明）改用了60为基数的系统。这可能是通过使用10和12为基数的不同人群之间的融合、碰撞或妥协而形成的，因为60可以被10和12都整除。
- en: 'Rather than invent an alphabet of 60 distinct symbols, which would have required
    a large effort to learn, the Sumerians used a hybrid notation. They wrote the
    numbers from 0 to 59 (inclusive) in the existing base 10, but they treated these
    compound symbols as individual numerals in a base 60 system. For example, the
    symbols (using modern Arabic digits with compounds separated by colons) 11:23:13
    would represent the following number:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 苏美尔人并没有发明60个不同符号的字母表，这样做将需要大量的学习努力，他们使用了一种混合符号表示法。他们在现有的十进制系统中写下0到59（包括59）的数字，但将这些复合符号视为60进制系统中的独立数字。例如，符号（使用现代阿拉伯数字，复合符号用冒号分隔）11:23:13表示以下数字：
- en: 11 × 60² + 23 × 60¹ + 13 × 10⁰ = 39,889[10]
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 11 × 60² + 23 × 60¹ + 13 × 10⁰ = 39,889[10]
- en: 'We still use a sexagesimal system today to represent time: the number above
    means 23 minutes and 13 seconds past 11, which is equal to 39,889 seconds into
    the day. Modern databases, data science systems, and date-time libraries therefore
    need to be carefully designed to handle conversions between sexagesimal, binary,
    and decimal.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天仍然使用性别进制系统来表示时间：上面的数字意味着11点23分13秒，即一天中39,889秒的时间。因此，现代数据库、数据科学系统和日期时间库需要仔细设计，以处理性别进制、二进制和十进制之间的转换。
- en: '*Base 16: Hexadecimal*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数16：十六进制*'
- en: Let’s talk about hex! Short for *hexadecimal* or *hex code*, *hex* is a base
    16 system. Its symbols are a mix of the digits 0 through 9 and the letters a through
    `f` (for the decimal numbers 10 through 15), often prefixed by 0x to indicate
    they are hex.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈十六进制吧！十六进制是*十六进制*或*十六进制代码*的缩写，是一种以16为基数的系统。它的符号是0到9的数字和字母a到`f`（代表十进制的数字10到15）的混合，通常以0x为前缀来表示它们是十六进制数。
- en: 'You’ve probably seen hex numbers around in any computer programs in languages
    that allow direct access to and use of memory, including C and assembly. They
    also appear in higher-level languages as a way to differentiate copies of objects
    that otherwise have the same properties. For example, if you copy a `Cat` object
    (in an object-oriented language) with properties `numberOfLegs = 4` and `age =
    6,` you’ll get a second `Cat` object with those same properties, but the two copies
    are distinct because they have different names and are stored in different locations
    in memory. Some debugging tools will show these memory locations to allow you
    to see which object is which. For example, when you ask Python to print an object,
    you’ll see a hex address, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在任何允许直接访问和使用内存的计算机程序中见过十六进制数，包括C语言和汇编语言。它们也出现在高级语言中，作为区分具有相同属性的对象副本的一种方式。例如，如果你复制一个`Cat`对象（在面向对象的语言中），它的属性是`numberOfLegs
    = 4`和`age = 6`，你将得到一个具有相同属性的第二个`Cat`对象，但这两个副本是不同的，因为它们有不同的名称，并且存储在内存中的位置不同。一些调试工具会显示这些内存位置，以便你看到哪个对象是哪个。例如，当你要求Python打印一个对象时，你会看到一个十六进制地址，像这样：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Human interfaces to low-level computer architecture, such as memory locations,
    often use hex as an alternative, more human-readable way to display what is binary
    information. The address in the output above is really a long string of 0s and
    1s in binary, but this would be hard for a human to recognize, for example, when
    comparing two addresses to see if they’re the same or different. Comparing hex
    numbers is much easier.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 人类与低级计算机架构的接口，例如内存位置，通常使用十六进制作为一种替代、更易于人类阅读的方式来显示二进制信息。上面输出的地址实际上是一串长长的0和1的二进制数，但人类很难识别它们，例如，在比较两个地址时是否相同。比较十六进制数则要容易得多。
- en: 'Hex is used for displaying binary, rather than some other system, because it
    has a similar relationship to binary as base 1,000 has to base 10\. Because 16
    is a power of 2, just as 1,000 is a power of 10, there’s a one-to-one relationship
    between groups of columns in binary and columns in hex. This allows for fast,
    easy conversion between the two systems. Consider a binary number with its digits
    organized into groups of four: 0010,1111,0100,1101\. We can view this as'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制用于显示二进制，而不是其他系统，因为它与二进制的关系类似于1,000与10的关系。因为16是2的幂次，就像1,000是10的幂次一样，二进制中的列组和16进制中的列之间存在一一对应关系。这使得两者之间的转换非常快速和简便。考虑一个将二进制数字按四位一组排列的例子：0010,1111,0100,1101。我们可以将其视为
- en: 0010[2] × 2^(12) + 1111[2] × 2⁸ + 0100[2] × 2⁴ + 1101[2] × 2⁰
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 0010[2] × 2^(12) + 1111[2] × 2⁸ + 0100[2] × 2⁴ + 1101[2] × 2⁰
- en: 'which is the same as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下表达式相同：
- en: 2[10] × 16³ + 15[10] × 16² + 4[10] × 16¹ + 13[10] × 16⁰
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2[10] × 16³ + 15[10] × 16² + 4[10] × 16¹ + 13[10] × 16⁰
- en: 'Each of these powers of 16 has a number from 0 to 15 inclusive, so if we use
    the letters a[16] to f[16] to denote 10[10] to 15[10], then we can write the number
    in hex as 2f4d[16]. Every 4 bits in the binary number (a quantity sometimes called
    a *nybble*) corresponds to one hex digit: the 2 in hex corresponds exactly to
    the first 4 bits, 0010; the `f` to 1111; the 4 to 0100; and the d to 1101\. This
    four-to-one correspondence makes it easy to convert back and forth between hex
    and binary—much easier than, say, converting between decimal and binary.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个16的幂次都对应一个从0到15的数字，所以如果我们用字母a[16]到f[16]表示10[10]到15[10]，那么我们可以将数字写成16进制的2f4d[16]。二进制数中的每4个比特（有时称为*nybble*）对应一个16进制数字：16进制中的2正好对应二进制中的前4个比特，即0010；f对应1111；4对应0100；d对应1101。这种四比特对一位的对应关系使得16进制和二进制之间的转换变得容易——比起十进制和二进制之间的转换要简单得多。
- en: '**HEX EDITORS**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**16进制编辑器**'
- en: Hex editors (for example, in Vim, %!xxd, as shown in the following image) display
    the contents of files or memory in byte notation, sometimes together with other
    translations such as ASCII characters. They allow you to edit the corresponding
    binary data directly. This is useful for editing binary data and executable (compiled
    program) files on disk, or poking (overwriting programs and data) in the computer’s
    memory, such as programs currently running. These editors have many interesting
    security-related applications. For example, you might use one to try to find and
    circumvent parts of a proprietary program that check for verified purchases, or
    to overwrite your number of lives in a computer game to get 255 instead of 3.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制编辑器（例如，在Vim中使用%！xxd，如下图所示）以字节表示法显示文件或内存的内容，有时还会显示其他翻译内容，如ASCII字符。它们允许你直接编辑相应的二进制数据。这对于编辑磁盘上的二进制数据和可执行文件（已编译的程序文件），或在计算机内存中进行“修改”（覆盖程序和数据）非常有用，比如当前运行的程序。这些编辑器有许多与安全相关的有趣应用。例如，你可能会用它来尝试寻找并绕过某个专有程序中检查验证购买的部分，或者覆盖你在计算机游戏中的生命数，将其从3改为255。
- en: '![Image](../images/f0054-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0054-01.jpg)'
- en: Hex is a convenient tool for humans to think about binary numbers in a computer,
    but it’s important to recognize that hex isn’t a tool the computers themselves
    use. We don’t build physical computers using hex as a base; we build them using
    binary. Then we chunk the computers’ binary numbers into fours and translate them
    into hex to make them more human-friendly. After all, 16 is just a bit more than
    10, and so is the kind of number that humans can get used to thinking in, rather
    than binary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制是人类用来理解计算机中二进制数字的方便工具，但重要的是要认识到，计算机本身并不使用16进制作为工具。我们并不是用16进制作为基数来构建物理计算机；我们是使用二进制来构建它们的。然后我们将计算机的二进制数字分成四位一组，并将它们转化为16进制，这样更适合人类理解。毕竟，16比10稍大，正是人类更容易习惯思考的数字，而不是二进制。
- en: Alternate notations used in some books and programming languages for hex include
    2F4D[16], 0x2f4d, 2F4Dh, &2F4D, and $2F4D.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些书籍和编程语言中用于表示16进制的替代符号包括2F4D[16]、0x2f4d、2F4Dh、&2F4D和$2F4D。
- en: '*Base 256: Bytes*'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数256：字节*'
- en: Using the base 1,000 trick again, it’s common to see hex code grouped into *pairs*
    of hex digits, such as 2D 4F 13 A7\. Here, each pair can be viewed as a single
    symbol from an alphabet of 256 symbols, with each symbol representing 8 bits,
    known as a *byte*. Bytes were the main unit of computation in the 8-bit era. The
    nybble is so-called because it’s half a byte. Remember that a nybble is one hex
    digit; a byte is a pair of hex digits.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用千进制技巧，常见的做法是将十六进制代码分为*一对*十六进制数字，例如 2D 4F 13 A7。在这里，每对十六进制数字可以视为256个符号字母表中的一个符号，每个符号表示8位，称为*字节*。字节是8位时代的主要计算单位。四位半字节（nybble）之所以得名，是因为它是一个字节的一半。记住，一个nybble是一个十六进制数字；一个字节是两个十六进制数字。
- en: '*How to Convert Between Bases*'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*如何在进制之间转换*'
- en: 'To convert from any base *b* representation to decimal, sum the decimal values
    of each of the base *b* columns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何基数*b*表示转换为十进制，可以将每个基数*b*列的十进制值相加：
- en: '*x*[*n*]*b*^(*n*) + *x*[*n* – 1]*b*^(*n* – 1) + . . . + *x*[0]*b*⁰'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[*n*]*b*^(*n*) + *x*[*n* – 1]*b*^(*n* – 1) + . . . + *x*[0]*b*⁰'
- en: 'For example, here’s how to convert a number from base 19 to decimal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何将一个数字从19进制转换为十进制：
- en: '![Image](../images/f0055-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0055-01.jpg)'
- en: To convert from decimal to base *b*, use repeated integer division by *b* with
    remainders. [Table 2-1](ch02.xhtml#ch02tab1) shows the steps of converting 186[10]
    to binary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十进制转换为基数*b*，可以通过对*b*进行反复的整数除法，并记录余数。[表2-1](ch02.xhtml#ch02tab1)显示了将186[10]转换为二进制的步骤。
- en: '**Table 2-1:** Converting 186 to Base 2'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 将186转换为二进制'
- en: '| **Step** | **Result** | **Remainder** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **结果** | **余数** |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 186/2 | 93 | 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 186/2 | 93 | 0 |'
- en: '| 93/2 | 46 | 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 93/2 | 46 | 1 |'
- en: '| 46/2 | 23 | 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 46/2 | 23 | 0 |'
- en: '| 23/2 | 11 | 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 23/2 | 11 | 1 |'
- en: '| 11/2 | 5 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 11/2 | 5 | 1 |'
- en: '| 5/2 | 2 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 5/2 | 2 | 1 |'
- en: '| 2/2 | 1 | 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 2/2 | 1 | 0 |'
- en: '| 1/2 | 0 | 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1/2 | 0 | 1 |'
- en: 'Here, the binary form of 186[10] is obtained by reading up the remainder column:
    10111010[2].'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，186[10]的二进制形式是通过读取余数列得到的：10111010[2]。
- en: Most programming languages provide functions that automatically carry out common
    conversions, with names like `bin2hex` and `hex2dec`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言提供了自动执行常见转换的函数，如`bin2hex`和`hex2dec`。
- en: Representing Data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据表示
- en: 'Once you have a basic representation for whole numbers, such as any of the
    base systems we’ve discussed, you can use it as a first building block to construct
    representations of other things: more complicated types of numbers, text, multimedia,
    and any general hierarchical data structure. Here we’ll see such representations,
    often using systems we’ve already defined as components of other higher-level
    systems. This can be as simple as using a pair of whole numbers to represent a
    fractional number or as complex as using billions of floating-point numbers grouped
    into spatiotemporal hierarchies to represent a multimedia stream of video, multilingual
    audio, and text subtitles, as found in your movie player.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为整数建立了基本表示方法，比如我们讨论的任何一种进制系统，你就可以用它作为构建其他事物表示的基础：更复杂的数字类型、文本、多媒体以及任何通用的层次数据结构。这里我们将看到这种表示方法，通常使用我们已定义的系统作为其他更高级系统的组成部分。这可以简单到用一对整数表示一个分数，或者复杂到使用数十亿个浮点数组成时空层次结构，来表示你的视频播放器中的多媒体流，包括视频、多语言音频和字幕。
- en: '*Natural Numbers*'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*自然数*'
- en: The *natural numbers* (traditionally denoted by the set symbol N) are the numbers
    0, 1, 2, 3, 4, and so on. They’re often used to represent numbers of *physical*
    things in the world, such as rocks or cows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*自然数*（传统上用符号N表示）是0、1、2、3、4等等的数字。它们通常用来表示世界上物理事物的数量，比如石头或牛。'
- en: Natural numbers can be represented in many ways, including tallies and Roman
    numerals. In computer architecture, the most obvious way is to use one of the
    base-exponent systems we’ve discussed. Some computers have used the decimal base
    (see the “Decimal Computers” box), while most modern machines use binary. For
    example, using light bulbs that can be either on or off, we can represent the
    binary columns of the number 74 (one 64, one 8, one 2), as in [Figure 2-8](ch02.xhtml#ch02fig8).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数可以通过多种方式表示，包括计数法和罗马数字。在计算机架构中，最明显的方式是使用我们讨论过的某种基数指数系统。一些计算机使用十进制系统（见“十进制计算机”框），而大多数现代机器使用二进制。例如，通过使用可以开关的灯泡，我们可以表示数字74的二进制列（一组64、8、2），如[图2-8](ch02.xhtml#ch02fig8)所示。
- en: '![Image](../images/f0056-01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0056-01.jpg)'
- en: '*Figure 2-8: A representation of the number 74 in binary*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：数字74的二进制表示*'
- en: There’s some subtlety to this, which will become important in more complex representations.
    First, you need to choose a convention for how to read the bulbs. In this case,
    we’ve chosen to put the highest power on the left, as with human-readable decimal
    numbers. We could equally have chosen the other way around, however, with the
    highest power on the right. Second, we’ve assumed in our example that eight bulbs
    are available and are being used. This means we can only represent the numbers
    0 through 255\. If we want to represent larger numbers, or even communicate the
    fact that we’ve run out of bulbs to represent a larger number, we’ll need a new
    plan.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙之处，随着更复杂的表示方法的出现，这一点将变得很重要。首先，您需要选择一个读取灯泡的约定。在这种情况下，我们选择将最高位放在左侧，就像人类可读的十进制数字一样。我们本来也可以选择反过来，将最高位放在右侧。其次，我们在示例中假设有八个灯泡可用并正在使用。这意味着我们只能表示0到255之间的数字。如果我们想表示更大的数字，或者甚至传达我们已经没有足够的灯泡来表示更大的数字，我们就需要一个新方案。
- en: '**DECIMAL COMPUTERS**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**十进制计算机**'
- en: Decimal computers have a long history, spanning the mechanical and electronic
    ages. Here are some details of how they worked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制计算机有着悠久的历史，跨越了机械时代和电子时代。以下是它们工作原理的一些细节。
- en: '**Babbage’s Analytical Engine**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**巴贝奇的分析引擎**'
- en: Like Babbage’s Difference Engine, his Analytical Engine uses a decimal representation,
    with gear wheels containing the digits 0 through 9\. A gear’s orientation represents
    a particular decimal digit, *d*, when that digit is oriented toward a fixed marker,
    as shown in the following figure. As in Pascal’s calculator (and unlike da Vinci’s),
    the gear never stops at continuous angles in between digits; it has only 10 discrete
    states.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 和巴贝奇的差分机一样，他的分析引擎也采用了十进制表示法，齿轮上包含数字0到9。齿轮的朝向表示特定的十进制数字*d*，当该数字朝向固定标记时，如下图所示。与帕斯卡尔的计算器类似（不同于达芬奇的计算器），齿轮不会在数字之间的连续角度上停下；它只有10个离散的状态。
- en: '![Image](../images/f0057-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0057-01.jpg)'
- en: The gear is hollow, and there’s a shaft inside it. The gear and this shaft may
    connect via two tappets, one attached to each of their circumferences. These tappets
    are arranged so that if the shaft is rotated by a full circle, the tappets will
    connect for part of the circle, with the effect of rotating the gear by the value
    of its digit rather than the full circle. To read the represented number, you
    rotate the shaft by a full circle. For the first part of this rotation, the tappets
    aren’t in contact and the gear doesn’t move. For the second part of this rotation,
    the tappets come into contact and the rotating shaft makes the gear rotate along
    with it for *n*-tenths of a rotation, where *n* is the number represented. This
    rotation of the gear is what gives you access to the number. For example, if you
    first connect the gear to a second gear, it will have the effect of advancing
    that second gear’s digit by *n*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 齿轮是空心的，内部有一个轴。这齿轮和轴通过两个凸轮连接，分别附着在它们的圆周上。这些凸轮的排列方式是，如果轴旋转一整圈，凸轮将在圆的一部分区域接触，从而使齿轮旋转的角度等于它的数字值，而不是旋转完整的一圈。要读取表示的数字，您需要将轴旋转一整圈。在旋转的第一部分，凸轮不接触，齿轮不动。在旋转的第二部分，凸轮接触并使旋转的轴带动齿轮旋转，旋转的角度为*n*分之一圈，其中*n*是表示的数字。齿轮的旋转使您能够访问该数字。例如，如果您先将齿轮连接到第二个齿轮，它将使第二个齿轮的数字按*n*的值向前移动。
- en: Importantly, the data is lost from the first gear when it’s read, as the tappet
    always moves the gear into its zero position during the second part of the rotation.
    The act of reading the data is thus a *move* rather than a *copy*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，数据在被读取时会从第一个齿轮中丢失，因为凸轮在旋转的第二部分总是将齿轮移动到零位置。因此，读取数据的过程是一个*移动*，而不是*复制*。
- en: Many gears can be stacked vertically to represent digits of larger decimal numbers.
    Likewise, many of these vertical stacks are arranged horizontally in the Analytical
    Engine to represent many numbers together.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 许多齿轮可以垂直堆叠起来表示更大的十进制数字。同样，这些垂直堆叠的齿轮会在分析引擎中水平排列，以同时表示多个数字。
- en: '**Electronic Decimal Machines**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子十进制机器**'
- en: Less well known in history are decimal machines of the early electronic age.
    The first commercial computer, UNIVAC (1951), discussed in the previous chapter,
    was one of them. Its main console (see the following figure) is characterized
    by many groups of 10 lights, used for displaying various decimals.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上较不为人知的是早期电子时代的十进制机器。上一章讨论的第一台商业计算机UNIVAC（1951年）就是其中之一。它的主控制台（见下图）以许多10个灯泡的组合为特点，用于显示各种十进制数。
- en: '![Image](../images/f0058-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0058-01.jpg)'
- en: The IBM 650 in the following figure, dating from 1953, was notable for its use
    of a “bi-quinary” representation. Exactly as in the abacus, this involved a mixture
    of units and fives making up decimal columns.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图所示的IBM 650计算机，诞生于1953年，以其使用“二五制”表示法而闻名。与算盘一样，这种表示法涉及将单位和五个组成十进制列。
- en: '![Image](../images/f0058-02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0058-02.jpg)'
- en: Binary isn’t the only way for digital systems, such as light bulbs, to represent
    natural numbers. Sometimes a one-of-*N* representation is more useful, as in [Figure
    2-9](ch02.xhtml#ch02fig9).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制并不是数字系统（如灯泡）表示自然数的唯一方式。有时，一对*N*的表示法更加实用，正如[图2-9](ch02.xhtml#ch02fig9)所示。
- en: '![Image](../images/f0059-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0059-01.jpg)'
- en: '*Figure 2-9: A representation of the number 5 in a one-of*-N *system (the leftmost
    bulb represents 0)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：在一个一对*N*系统中表示数字5（最左边的灯泡表示0）*'
- en: 'Here, we assume that *N* bulbs are available and being used, and that exactly
    one of them will be on at any time. This can be wasteful, because we don’t use
    most of the possible states of the set of bulbs. But it can also be useful: for
    example, if we want to actually shine a light on some object in the real world,
    such as the fifth car in a row, we now have a single physical light bulb dedicated
    to that purpose. This will be very useful in computer architecture, as we very
    often want to switch on and off one of *N* physical circuits in a similar way.
    As with binary, we need to agree on a left-to-right or opposite convention, and
    there’s no way to indicate that we’ve run out of bulbs if a number is too large.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设有*N*个灯泡可用并正在使用，并且任何时候只有一个灯泡亮起。这种方法可能很浪费，因为我们并没有使用灯泡组的绝大多数可能状态。但它也可能很有用：例如，如果我们想在现实世界中为某个物体照明，比如排队中的第五辆车，我们现在有一个专门用于该目的的物理灯泡。这在计算机架构中会非常有用，因为我们经常希望以类似的方式开关*N*个物理电路。与二进制一样，我们需要约定一个从左到右或相反的约定，并且如果数字太大，无法指示灯泡用尽，也没有办法解决。
- en: '*Integers*'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*整数*'
- en: The *integers* (set symbol Z) are the numbers . . . , –3, 2, –1, 0, 1, 2, 3,
    and so on. They can be defined as pairing natural numbers with positive or negative
    signs (apart from zero, where +0 = –0). [Table 2-2](ch02.xhtml#ch02tab2) shows
    three different options for encoding them in binary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*（集合符号Z）是这些数字：. . . , –3, 2, –1, 0, 1, 2, 3，依此类推。它们可以定义为将自然数与正负符号配对（除了零，+0
    = –0）。[表2-2](ch02.xhtml#ch02tab2)展示了三种不同的二进制编码方式。'
- en: '**Table 2-2:** Three Possible Binary Encodings for Integers'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** 三种可能的整数二进制编码方式'
- en: '| **Integer** | **Signed** | **One’s complement** | **Two’s complement** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **整数** | **带符号** | **一的补码** | **二的补码** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  3 | 011 | 011 | 011 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  3 | 011 | 011 | 011 |'
- en: '|  2 | 010 | 010 | 010 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  2 | 010 | 010 | 010 |'
- en: '|  1 | 001 | 001 | 001 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  1 | 001 | 001 | 001 |'
- en: '|  0 | 000 and 100 | 000 and 111 | 000 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  0 | 000 和 100 | 000 和 111 | 000 |'
- en: '| –1 | 101 | 110 | 111 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| –1 | 101 | 110 | 111 |'
- en: '| –2 | 110 | 101 | 110 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| –2 | 110 | 101 | 110 |'
- en: '| –3 | 111 | 100 | 101 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| –3 | 111 | 100 | 101 |'
- en: '| –4 | n/a | n/a | 100 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| –4 | 不适用 | 不适用 | 100 |'
- en: A naive way to represent integers is to use binary codes for the natural numbers
    corresponding to their absolute values, together with an extra bit for their sign,
    as in the signed column of [Table 2-2](ch02.xhtml#ch02tab2) (the leftmost bit
    indicates the sign). It’s difficult to build machinery to correctly process these
    representations, however, as the sign has to be handled separately and used to
    select what should be done with the rest of the number. Having two different representations
    of the number 0 may also be a problem, requiring extra machinery to sort out.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表示整数的一种简单方法是使用与其绝对值对应的自然数的二进制编码，再加上一个额外的位来表示符号，就像[表2-2](ch02.xhtml#ch02tab2)中的带符号列（最左边的位表示符号）。然而，构建能够正确处理这些表示方式的机器是困难的，因为符号必须单独处理，并且用于选择如何处理剩余的数字。拥有两个不同的0表示方式也可能成为一个问题，需要额外的设备来解决。
- en: Consider for a moment the alternative one’s complement representation of the
    same integers given in the table. (Few people actually use this, but it will help
    you understand the next one.) In this representation, the codes for the positive
    integers are the same as for natural numbers, but the codes for negatives are
    obtained by inverting all of the bits for their corresponding naturals. For example,
    to get the code for –2, we start with the code for +2, which is 010, and invert
    all the bits to get 101.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想表中给出的同一整数的反码表示法（虽然很少有人使用，但它能帮助你理解下一个方法）。在这种表示法中，正整数的编码与自然数的编码相同，但负数的编码是通过反转其对应自然数的所有位得到的。例如，要得到
    -2 的编码，我们从 +2 的编码 010 开始，将所有位反转得到 101。
- en: Now consider the two’s complement representation of integers in the table. This
    is formed by taking the one’s complement codes and adding 1 to them for negative
    numbers only. For example, –2 becomes 110, which is 101 + 1\. This may seem like
    a random thing to do, but as you’ll see later, the two’s complement approach turns
    out to be very useful. It simplifies the required arithmetic machinery, which
    is why today’s computers typically use it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑表格中的二补码表示法。这是通过对负数使用反码并加 1 得到的。例如，-2 变为 110，即 101 + 1。看起来这可能是随机的做法，但正如你稍后会看到的，二补码方法非常有用。它简化了所需的算术操作，这是今天的计算机普遍使用它的原因。
- en: '*Rationals*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*有理数*'
- en: The *rationals* (set symbol ℚ) are defined as, and may be represented by, pairs
    of integers *a*/*b*, with *b* ≠ 0\. Examples include 1/2, –3/4, 50/2, –150/2,
    and 0/2\. Many rationals are equivalent to one another, such as 4/2 and 2/1\.
    Detecting and simplifying equivalences requires dedicated computational work,
    and without this work rationals tend to expand to silly scales such as the representation
    1,000,000,000/2,000,000,000 representing the number 1/2.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*有理数*（集合符号 ℚ）被定义为并可以由整数对 *a*/*b* 表示，其中 *b* ≠ 0。例子包括 1/2、-3/4、50/2、-150/2 和
    0/2。许多有理数是等价的，例如 4/2 和 2/1。检测和简化等价关系需要专门的计算工作，如果没有这项工作，有理数往往会扩展到荒谬的规模，比如 1,000,000,000/2,000,000,000
    表示的是数字 1/2。'
- en: 'Representing rationals is our first example of combining multiple existing
    representations: we need to use a pair of integers. For example, consider [Figure
    2-8](ch02.xhtml#ch02fig8), which we previously interpreted as a single natural
    number; this figure could instead be viewed as representing the rational 4/10
    = 2/5 by assuming that the first and second groups of four bulbs represent 4 and
    10.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表示有理数是我们首次结合多种现有表示法的例子：我们需要使用一对整数。例如，考虑 [图 2-8](ch02.xhtml#ch02fig8)，我们之前将其解释为一个单一的自然数；这个图像也可以视为表示有理数
    4/10 = 2/5，假设前后两组四个灯泡分别表示 4 和 10。
- en: 'There’s some subtlety in this: we need to agree that the first four of the
    eight bulbs are to represent the first integer, and the second four the second
    integer, plus we need to agree on conventions for the integers themselves (how
    to convey positive versus negative values), as discussed earlier. We will end
    up with multiple representations for many rationals, such as 4/10 and 2/5, which
    may initially confuse us if we want to ask whether two rationals are equal.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙之处：我们需要达成一致，前四个灯泡代表第一个整数，后四个灯泡代表第二个整数，并且我们还需要就整数本身的表示方式达成一致（如何表示正负值），正如之前讨论的那样。如果我们想要检查两个有理数是否相等，我们会遇到许多不同的表示方式，例如
    4/10 和 2/5，这可能最初会让我们困惑。
- en: '*Fixed Point*'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*定点*'
- en: '*Fixed-point numbers*, such as 4.56, 136.78, and –14.23, are numbers with a
    limited number of digits before and after the point. In these examples there are
    always two digits after the point. Formally, fixed-point numbers are a subset
    of the rationals, as they can always be written as an integer divided by some
    power of 10\. They can be easily represented in computers as pairs of integers,
    corresponding to the two parts of the number before and after the decimal point,
    provided we agree on a convention for their ordering and size, as well as a convention
    for the integers themselves.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*定点数*，如 4.56、136.78 和 -14.23，是具有有限位数的小数点前后数字的数字。在这些例子中，点后始终有两个数字。严格来说，定点数是有理数的一个子集，因为它们总是可以表示为整数除以
    10 的某个幂。只要我们就它们的顺序和大小达成一致，并且就整数本身的表示达成一致，它们就可以很容易地在计算机中表示为一对整数，分别对应小数点前后的两部分数字。'
- en: For example, the bulbs in [Figure 2-8](ch02.xhtml#ch02fig8) could now represent
    the fixed-point binary number ![Image](../images/f0061-01.jpg) if we agree that
    the point is fixed after the fourth bulb. Note that these are exactly the same
    bulbs that we previously used to represent the rational 4/10 and the integer 74;
    to interpret data as a representation, we need to agree on which representation
    system is being used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图2-8](ch02.xhtml#ch02fig8)中的灯泡现在可以代表定点二进制数![Image](../images/f0061-01.jpg)，如果我们同意在第四个灯泡后固定小数点。注意，这些灯泡与我们之前用来表示有理数4/10和整数74的灯泡完全相同；要将数据解释为某种表示方式，我们需要约定使用的是哪种表示系统。
- en: '*Floating Point*'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*浮动点数*'
- en: '*Floating-point numbers*, such as 4.56 × 10^(34) and –1.23 × 10^(–2), are a
    computational version of the Suzhou place notation system seen previously in [Figure
    2-7](ch02.xhtml#ch02fig7), and are composed of a fixed-point mantissa (here, 4.56)
    and an integer exponent (here, 34). They are easily represented in computers by
    pairing together an integer representation and a fixed-point representation.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动点数*，例如4.56 × 10^(34)和–1.23 × 10^(–2)，是之前在[图2-7](ch02.xhtml#ch02fig7)中看到的苏州位值计数法系统的计算版本，由定点尾数（这里是4.56）和整数指数（这里是34）组成。它们通过将整数表示和定点表示配对，能够轻松在计算机中表示。'
- en: To do this in practice, you need to choose specific representations for the
    fixed-point and integer parts, with specific bit lengths and a specific ordering
    for how to pack them together into a pair. It’s also useful to reserve a few bit
    strings for special codes, such as plus and minus infinity (which can be used
    to code results for 1/0 and –1/0) and “not a number” (*NaN*, used to code exceptions
    such as when trying to compute 0/0.0). *IEEE 754* is a commonly used standard
    for making these choices. It includes a set of bit orderings to best make use
    of 8, 16, 32, 64, 128, or 256 bits as floating-point representations. For example,
    IEEE 754’s 64-bit standard specifies that the first 53 bits should be used as
    the fixed-point mantissa in a signed encoding, with the first bit holding the
    sign; the remaining 11 bits should serve as a two’s complement integer exponent.
    Some bit patterns are reserved for infinities and NaNs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，为了实现这一点，你需要选择特定的表示方式来表示定点和整数部分，设定具体的比特长度，并指定如何将它们按特定顺序打包成一个对。预留一些比特串用于特殊编码也是很有用的，比如正负无穷（可以用来编码1/0和-1/0的结果）和“非数字”（*NaN*，用于编码诸如计算0/0.0时的异常）。*IEEE
    754*是一个常用的标准，用于做出这些选择。它包括一组比特顺序，旨在最有效地利用8、16、32、64、128或256位作为浮动点表示。例如，IEEE 754的64位标准规定，前53位应作为带符号编码的定点尾数，其中第一位表示符号；其余11位应作为二进制补码整数指数。一些比特模式被保留用于无穷大和NaN。
- en: '**COMPUTABLE REALS**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**可计算实数**'
- en: Beyond floating points, computer science has its own concept of *computable
    real numbers*, sometimes written as 𝕋, which are different from—and better than—the
    *real numbers* used in mathematics, denoted with ℝ. Computable reals are all the
    numbers that can be defined by programs. In contrast, the much larger set of mathematicians’
    real numbers are useless as they can’t be individually defined or used in computation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浮动点数，计算机科学还拥有自己对*可计算实数*的定义，有时写作𝕋，它们不同于——并且优于——数学中使用的*实数*，后者用ℝ表示。可计算实数是所有可以通过程序定义的数字。与此相比，数学家们使用的更大的实数集合是无用的，因为它们不能单独定义或用于计算。
- en: Imagine a physical turtle robot controlled by a language like Scratch, moving
    left and right along a number line. The computable reals are all the locations
    on the number line that you can write a program for the turtle to stop at. Specifically,
    they’re all the numbers whose *n*th digit can be specified by some finitelength
    computer program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个物理乌龟机器人，使用类似Scratch的语言控制，沿着数轴左右移动。可计算实数就是你可以为乌龟编写程序使其停在的所有数轴上的位置。具体来说，它们是所有能通过某些有限长度的计算机程序来指定其*n*位数字的数字。
- en: For example, we can write a function `pi(n)` that takes an integer n as input
    and returns the *n*th digit of *π*. Likewise, we can add two computable reals,
    `a(n)` + `b(n)`, by forming a new program from the programs `a(n)` and `b(n)`.
    The new program will take `n` as an input and call `a()` and `b()` one or more
    times to generate the *n*th digit of the output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个函数`pi(n)`，它以整数n为输入并返回*π*的第*n*位数字。同样，我们可以通过从程序`a(n)`和`b(n)`形成一个新程序来将两个可计算实数`a(n)`
    + `b(n)`相加。新程序将以`n`作为输入，并调用`a()`和`b()`一次或多次来生成输出的*n*位数字。
- en: Computable reals have many fascinating and almost paradoxical properties, which
    have deep implications for both computer and human arithmetic. For example, it’s
    generally impossible (uncomputable) to know whether two computable reals are equal
    or different! The programs formed from performing just a few basic arithmetic
    operations on computable reals can quickly get quite large and unwieldy. It would
    be nice if we could optimize them by replacing them with shorter (or shortest)
    programs that give the same outputs, but it’s impossible to do this. There is
    a “countable” number of computable reals, which is the same “size” of infinity
    as the integers. This is different from the mathematicians’ reals, which have
    a larger “size” that’s “uncountable.”
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可计算实数具有许多迷人且几乎是自相矛盾的特性，这对计算机和人类算术都有深远的影响。例如，通常无法（不可计算地）知道两个可计算实数是否相等或不同！通过对可计算实数进行一些基本的算术运算形成的程序，很快就会变得庞大且笨拙。如果我们能够通过用更短（或最短）的程序替代它们并得到相同的输出，那将是很好的，但这在理论上是不可能的。可计算实数的数量是“可数”的，这与整数的“大小”相同。这与数学家定义的实数不同，后者具有更大的“大小”，被称为“不可数”。
- en: Alan Turing defined the computable reals in his great paper “On Computable Numbers,”
    hence the letter 𝕋. They are his true genius contribution to computer science,
    rather than “inventing the computer” (the title of this paper is a clue that it’s
    about computable numbers, rather than about computers). Turing’s theory is still
    underappreciated. If it were more widely developed and used, we might one day
    get rid of the errors caused by floating-point approximations and be able to make
    perfectly accurate computations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 艾伦·图灵在他的伟大论文《可计算数的论述》中定义了可计算实数，因此使用了字母𝕋。可计算实数是他对计算机科学的真正天才贡献，而不是“发明计算机”（该论文的标题提示它是关于可计算数的，而非计算机）。图灵的理论仍然被低估。如果这一理论得到更广泛的发展和应用，我们可能有一天能够摆脱浮点近似带来的误差，进行完全准确的计算。
- en: '*Arrays*'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*数组*'
- en: 'A *one-dimensional array* is a sequence of *R* values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*一维数组*是*R*个值的序列：'
- en: '{*a*[*r*]}[*r*=0:*R*–1]'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '{*a*[*r*]}[*r*=0:*R*–1]'
- en: 'A *two-dimensional array* is a collection of *R* × *C* values (standing for
    numbers of rows and columns), where:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*二维数组*是一个*R* × *C*个值的集合（表示行数和列数），其中：'
- en: '{*a*[*r,c*]}[*r*=0:*R*–1,*c*=0:*C*–1]'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '{*a*[*r,c*]}[*r*=0:*R*–1,*c*=0:*C*–1]'
- en: 'A *D-dimensional array* is a collection of values with *D* indices, such as
    the 3D *R* × *C* × *D* array with the following elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*维数组是一个具有*D*个索引的值集合，例如具有以下元素的三维*R* × *C* × *D*数组：'
- en: '{*t[r,c,d]*}[*r*=0:*R*–1,*c*=0:*C*–1,*d*=0:*D*–1]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '{*t[r,c,d]*}[*r*=0:*R*–1,*c*=0:*C*–1,*d*=0:*D*–1]'
- en: The values in arrays may be numbers (of any of the types of numbers we’ve discussed)
    or other types of data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的值可以是数字（任何我们讨论过的数字类型）或其他类型的数据。
- en: Often numerical arrays are used to represent vectors, matrices, and tensors.
    These are mathematical concepts that *extend* the data structure with specific,
    defined, mathematical operations. For example, a *vector* is a 1D array with specific
    rules for addition, multiplication by a scalar, and computing dot products and
    norms. A *matrix* is a 2D array with specific rules such as for multiplication
    and inversion. A *tensor* is an *N*-dimensional array with specific rules for
    covariant and contravariant coordinate transforms, in addition to multiplication
    and inversion. Vectors and matrices are special cases of tensors. (Many computer
    scientists use the term *tensor* incorrectly to refer only to the *N*-dimensional
    data structure, forgetting the other mathematical requirements of true tensors.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数组通常用于表示向量、矩阵和张量。这些是扩展数据结构的数学概念，带有特定的数学操作。例如，*向量*是一个一维数组，具有特定的加法规则、标量乘法规则以及计算点积和范数的规则。*矩阵*是一个二维数组，具有特定的规则，例如乘法和求逆。*张量*是一个*N*维数组，具有特定的协变和逆变坐标变换规则，除了乘法和求逆外。向量和矩阵是张量的特例。（许多计算机科学家错误地使用*张量*一词来仅指*N*维数据结构，而忽略了真正张量的其他数学要求。）
- en: 'A basic data representation for all types of arrays is to “pack” them into
    a series of individual numbers in contiguous areas of computer memory. For example,
    [Figure 2-8](ch02.xhtml#ch02fig8) might represent the 1D array of integers [1,0,2,2]
    if we agree on a convention that each integer is represented by two bulbs. Similarly,
    it might represent this 2D array of integers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型数组的基本数据表示方法是将它们“打包”成一系列在计算机内存中连续区域中的单个数字。例如，[图 2-8](ch02.xhtml#ch02fig8)可能表示一个由整数[1,0,2,2]组成的一维数组，如果我们同意一个约定，即每个整数由两个灯泡表示。同样，它也可以表示这个二维整数数组：
- en: '![Image](../images/f0063-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0063-01.jpg)'
- en: 'In this case we’re considering each of the 2D array’s rows as a 1D array, [1,0]
    and [2,2]. We encode each 1D array using two bulbs per integer and store the series
    of encodings for the rows in order. By extension, for a general *N*-dimension
    array, we may do the same: split it into a series of (*N* – 1)-dimension arrays,
    encode each of them, and store the series of encodings in order.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将每个二维数组的行视为一维数组，[1,0] 和 [2,2]。我们使用每个整数两颗灯泡进行编码，并按顺序存储行的编码序列。通过扩展，对于一般的*N*维数组，我们可以做同样的事情：将其分割成一系列的（*N*
    – 1）维数组，对每个数组进行编码，并按顺序存储编码序列。
- en: Optimizing data representation and computation architectures for vectors, matrices,
    and tensors has become a major driver of the tech industry. GPUs were first built
    to perform fast 3D vector-matrix operations for realtime 3D games, and have more
    recently been generalized for fast tensor computations, which have found important
    applications in neural network acceleration. Google’s tensor processing units
    (TPUs) are designed specifically for this task.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 优化数据表示和计算架构以处理向量、矩阵和张量已经成为技术行业的主要驱动力。GPU最初是为实时3D游戏中的快速3D向量矩阵运算而设计的，最近它们已经被广泛应用于快速张量计算，这在神经网络加速中发挥了重要作用。谷歌的张量处理单元（TPU）就是专为这个任务设计的。
- en: '*Text*'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*文本*'
- en: Let’s talk about text. Once you have a finite, discrete alphabet of symbols,
    such as the characters we use to write human-readable text, you can assign a natural
    number to represent each one. You can then use a bunch of natural numbers in an
    array to represent *strings* of text. This idea has evolved from the long-standard-but-now-outdated
    ASCII to modern Unicode.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈文本。一旦你有了有限的、离散的符号字母表，比如我们用来书写人类可读文本的字符，你可以为每个符号分配一个自然数来表示它。然后，你可以使用一组自然数按顺序表示*文本串*。这个思想已经从长期标准但现在过时的ASCII发展到了现代的Unicode。
- en: '**A HISTORY OF TEXT**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本的历史**'
- en: 'Numbers aren’t very useful by themselves: we need to know *what* is being counted.
    Sumerian trading tokens were “typed”—three cow tokens to represent three cows.
    But when we moved from tokens to more abstract numerals, we lost the information
    about what the numbers were supposed to represent. The numbers needed to be accompanied
    by extra symbols describing the type, as in “3 cows.” Writing thus emerged from
    the same trading tokens as numbers, but it forked to become pictograms and then
    text.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 数字本身并不太有用：我们需要知道*是什么*在被计数。苏美尔的交易代币是“打字的”——三枚牛代币代表三头牛。但当我们从代币转向更抽象的数字时，我们失去了数字所代表的内容。数字需要附加额外的符号来描述类型，比如“3头牛”。因此，书写是从与数字相同的交易代币中发展出来的，但它分化成了象形符号，然后成为了文本。
- en: The first writing appeared in Sumeria around 4000 BCE. It used pictures of objects
    (pictograms) to represent them. Pictograms appeared in many cultures, then gradually
    transformed into phonetic symbols. The phonetic and semantic uses may coexist
    for a while—as in modern Chinese—but the phonetic use usually becomes dominant.
    Text symbols also evolved over time to become simplified and easier to write,
    losing the original pictorial similarities to their objects. Where writing was
    carved on stone, the symbols evolved to be made from straight lines that are easier
    to carve. The most common symbols evolved fastest into quick-to-write shapes.
    They thus became the handiest to use in phonetic transcriptions, so the phonetic
    letters that survived the transition from pictures to sounds tended to come from
    the most common words.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种书写出现在公元前4000年左右的苏美尔。它使用物体的图像（象形符号）来代表这些物体。象形符号在许多文化中出现过，后来逐渐转化为表音符号。表音和语义用途可能会共存一段时间——比如现代汉语——但表音用途通常会变得占主导地位。文本符号也随着时间的推移逐渐简化，变得更容易书写，失去了最初与其物体的图像相似性。在刻写石头上的文字时，符号逐渐演变为由直线构成，这样更容易刻画。最常见的符号最快地演变成了易于书写的形状。因此，它们成了音标转录中最方便使用的符号，经过从图像到声音的转变后，幸存下来的表音字母往往来自最常用的单词。
- en: Text isn’t always written from left to right. Arabic and Hebrew go right to
    left, and many East Asian languages can be written from top to bottom.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 文本并不总是从左到右书写。阿拉伯语和希伯来语是从右到左书写的，许多东亚语言可以从上到下书写。
- en: Morse code was developed around the great computing year, 1836, to enable operators
    of the Victorian internet—the telegraph—to communicate quickly. Samuel Morse studied
    the frequency of letter usage in English to give the common ones the shortest
    representations. Morse is *almost* a binary code, as it uses sequences of two
    symbols to represent letters, but they’re usually used together with a third symbol,
    empty space, to show breaks between words.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔斯电码是在1836年左右开发的，旨在让维多利亚时代的互联网——电报的操作员能够快速通讯。塞缪尔·摩尔斯研究了英语中字母的使用频率，以便给常用字母分配最短的表示方式。摩尔斯几乎是二进制代码，因为它使用两个符号的序列来表示字母，但通常与第三个符号——空格一起使用，以表示单词之间的间隔。
- en: Braille was also developed around 1836 by Louis Braille. It’s a true binary
    code, with each letter represented by binary states of a 2×3 grid. It was originally
    developed for secret use by soldiers but became popular for its present-day use
    by blind readers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱叶盲文也是在1836年左右由路易·布莱叶开发的。它是一个真正的二进制代码，每个字母由2×3网格的二进制状态表示。它最初是为士兵的秘密用途开发的，但后来因其在盲人读者中的广泛使用而流行开来。
- en: '**ASCII**'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**ASCII**'
- en: The *American Standard Code for Information Interchange (ASCII)*, shown in [Figure
    2-10](ch02.xhtml#ch02fig10), represents each character as a unique 7-bit code,
    meaning it can represent 128 characters in total. This allows for uppercase and
    lowercase letters, digits, symbols, and punctuation, as well as historical *controls*
    such as delete, carriage return, line feed, and ring a bell.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*美国信息交换标准代码（ASCII）*，如[图2-10](ch02.xhtml#ch02fig10)所示，将每个字符表示为一个独特的7位代码，这意味着它可以表示总共128个字符。这可以表示大写和小写字母、数字、符号和标点符号，以及历史上的*控制符*，如删除、回车、换行符和响铃。'
- en: 'In old email systems, ASCII control codes would sometimes be transmitted and
    displayed as part of the email message rather than actually being executed. The
    backspace control code was particularly prone to this effect, so you would get
    emails such as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版电子邮件系统中，ASCII控制代码有时会作为电子邮件消息的一部分传输和显示，而不是实际执行。尤其是退格控制符容易出现这种效果，因此你会收到类似以下的电子邮件：
- en: The team has identified several fuckups^H^H^H^H^H^H^Hchallenges in the plan.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 团队已识别出计划中几个错误^H^H^H^H^H^H^H挑战。
- en: Today, old-timers sometimes type out similar “backspace fails” on purpose for
    humor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，老一辈人有时故意打出类似的“退格失败”作为幽默。
- en: Some operating systems use different conventions to represent the ends of lines,
    involving line feeds (code 10) and carriage returns (code 13) in text files, which
    may need to be fixed if you move text files between systems. In the days of typewriters
    and then teletype machines, these were two different physical controls, one to
    advance the paper in the machine by a row, and the other to return the print head
    carriage back to the left side of the paper.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统使用不同的约定来表示行末，涉及文本文件中的换行符（代码10）和回车符（代码13），如果你在系统之间移动文本文件，可能需要修复这些问题。在打字机和电传打字机的时代，这两个符号是两种不同的物理控制，一个用于将纸张向机器中推进一行，另一个用于将打印头的打印架返回到纸张的左侧。
- en: ASCII code 0 is commonly used to represent the end of a string. If a string
    is laid out in memory, programs need a way to work their way through it one character
    at a time. The convention is that when they reach a zero, they know to stop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII代码0通常用于表示字符串的结束。如果字符串以某种方式在内存中布局，程序需要一种逐个字符处理字符串的方法。约定是，当程序遇到零时，它就知道该停止了。
- en: As a 1960s American standard, ASCII is a product of a time before globalization
    and the internet, and it has come to show its age. It can only represent characters
    from the Latin alphabet, so it can’t directly represent characters needed by languages
    other than English. Many European languages require multiple versions of Latin
    characters containing accents, for example, while languages such as Chinese and
    Arabic use completely different alphabets.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为1960年代的美国标准，ASCII是全球化和互联网之前的产物，现在已经显示出它的年代感。它只能表示拉丁字母中的字符，因此无法直接表示非英语语言所需的字符。例如，许多欧洲语言需要带有重音符号的拉丁字符，而像中文和阿拉伯语这样的语言使用完全不同的字母表。
- en: However, in one of the most foresighted design decisions ever made in computing,
    coupled with coincidence, the designers of ASCII were aware of this potential
    future issue and planned for it. The coincidence was that the machines of the
    time used groups of 8 bits, while the size of the set of characters needed for
    English was just under 7 bits. The design decision was to thus use 8-bit representations
    for ASCII characters but to always make the first bit a 0\. In the future, if
    additional characters were needed, this first bit could be used for other purposes.
    This has now happened, giving rise to the modern Unicode Standard.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机史上最具前瞻性的设计决策之一，结合偶然性，ASCII的设计者们意识到了这一潜在的未来问题，并为此做了规划。偶然性在于，当时的计算机使用的是8位组，而英语所需的字符集大小仅略低于7位。设计决策是使用8位表示ASCII字符，但始终将第一个位设为0。将来，如果需要更多字符，可以将这个第一个位用于其他目的。现在，这一设计已实现，促成了现代Unicode标准的出现。
- en: '![Image](../images/f0065-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0065-01.jpg)'
- en: '*Figure 2-10: The ASCII character representations*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-10：ASCII字符表示*'
- en: '**ASCII AS BASE 256**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASCII作为256进制**'
- en: 'Suppose you’ve written a program in your favorite language, such as the following
    in BASIC:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你用你最喜欢的语言写了一个程序，比如下面这个BASIC程序：
- en: '[PRE1]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then suppose you encode the characters of this program as ASCII characters
    and save them in a text file. Each one of these characters is a byte. If you open
    your program in a hex editor rather than a normal text editor, you’ll see your
    program represented as a list of byte codes, such as:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后假设你将这个程序的字符编码为ASCII字符并保存在文本文件中。每一个字符都是一个字节。如果你在十六进制编辑器中打开你的程序，而不是普通的文本编辑器，你将看到程序被表示为一系列字节码，例如：
- en: '[PRE2]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Think about the compound notation concept we’ve previously used in base 1,000,
    sexagesimal, and byte codes themselves, and apply it to this whole list of byte
    codes. Consider each byte code as a base 256 digit, and form the *entire program*
    into a single very large number, such as:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们之前在千进制、六十进制和字节码中使用的复合表示法概念，并将其应用于这整组字节码。将每个字节码视为一个256进制数字，将*整个程序*形成一个非常大的单一数字，例如：
- en: 31[256] × 256^(27) + 30[256] × 256^(26) + 20[256] × 256^(25) + 50[256] × 256^(24)
    . . . + 30[256] × 256⁰
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 31[256] × 256^(27) + 30[256] × 256^(26) + 20[256] × 256^(25) + 50[256] × 256^(24)
    . . . + 30[256] × 256⁰
- en: 'This calculation would give a single astronomically sized integer. This means
    we have a mapping between programs and integers: we can represent any program
    with a single integer. When you write a program, you’re just choosing which integer
    to apply. This view can be used in computational theory, because it allows math
    about numbers to talk about programs.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算将得到一个单一的天文数字大小的整数。这意味着我们在程序与整数之间建立了映射关系：我们可以用一个整数来表示任何程序。当你编写程序时，你只是选择要应用的整数。这个视角在计算理论中是有用的，因为它允许通过数字的数学运算来讨论程序。
- en: '**Unicode**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Unicode**'
- en: 'What we collectively know as *Unicode* actually refers to three different but
    related standards defined in 1991: UTF-8, UTF-16, and UTF-32\. *UTF-8* extends
    ASCII by making use of the previously unused eighth bit. If it’s a 1, then a second
    byte follows to enlarge the space of symbols. If the second byte starts with a
    1, then a third byte follows as well. If the third byte starts with a 1, then
    a final, fourth byte is also used. UTF-8 thus allows for more than one million
    different characters. Its standard doesn’t use all of them, but it includes mappings
    to symbols needed for all major world languages. So many character encodings are
    available that international communities have been able to add to the standard,
    including symbols for less widely spoken languages, ancient languages such as
    Cuneiform, fictional languages such as Klingon, other symbols such as from mathematics
    and music, and a large number of emoji (see [Figure 2-11](ch02.xhtml#ch02fig11)).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常所说的*Unicode*实际上指的是1991年定义的三种不同但相关的标准：UTF-8、UTF-16和UTF-32。*UTF-8*通过利用之前未使用的第八位来扩展ASCII。如果它是1，则跟随一个第二个字节来扩大符号空间。如果第二个字节以1开头，那么接着还有一个第三个字节。如果第三个字节以1开头，则使用最后一个第四个字节。因此，UTF-8支持超过一百万个不同的字符。其标准并未使用全部字符，但包含了所有主要语言所需的符号映射。现在有这么多字符编码可用，以至于国际社区能够将符号添加到标准中，包括一些使用较少的语言符号、古老语言（如楔形文字）、虚构语言（如克林贡语）、数学和音乐符号，以及大量的表情符号（见[图2-11](ch02.xhtml#ch02fig11)）。
- en: '![Image](../images/f0067-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0067-01.jpg)'
- en: '*Figure 2-11: Unicode Thai, math, emoji, and Cuneiform sectors*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-11：Unicode泰语、数学符号、表情符号和楔形文字领域*'
- en: For efficiency, the most widely used languages are given the symbols that require
    only 2 bytes, with the rarer ones requiring 3 bytes and the comedy ones requiring
    4 bytes. There are sometimes lively debates about which of these sectors a newly
    proposed character set should be assigned to. The next time you send a text with
    just the right emojum to express your feelings, you can thank the ASCII designers
    for their foresight.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，最广泛使用的语言被分配到只需要 2 个字节的符号，而较少使用的符号需要 3 个字节，稀有的符号则需要 4 个字节。有时会进行激烈的辩论，讨论一个新提议的字符集应当分配到哪个类别。下次你发送一条恰到好处的表情符号来表达你的感情时，可以感谢
    ASCII 设计者的远见。
- en: '*UTF-32* is a fixed-width encoding that uses all four available bytes in *every*
    character. From a storage standpoint, this is obviously inefficient, but for some
    applications it may speed up the process of looking up symbols. For example, if
    you want to read the 123rd symbol, then you can find it right away in bytes 123×4
    to 123×5.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-32* 是一种固定宽度编码，它在*每个*字符中使用所有四个可用字节。从存储的角度来看，这显然是低效的，但对于某些应用程序，它可能加速符号查找的过程。例如，如果你想读取第
    123 个符号，你可以直接在字节 123×4 到 123×5 中找到它。'
- en: '*UTF-16* is like UTF-8, but at least 2 bytes are always used, even for ASCII
    characters. This covers a large set of symbols in common use around the world,
    so it can often act as if it were a fixed-width coding, to enable fast look-ups
    as in UTF-32\. It’s a compromise encoding.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-16* 类似于 UTF-8，但即使是 ASCII 字符也始终使用至少 2 个字节。这覆盖了全球范围内常用的符号集，因此它通常可以像固定宽度编码一样工作，从而实现快速查找，类似于
    UTF-32。它是一种折衷的编码方式。'
- en: Converting files between the different UTF formats is a modern version of the
    pain we used to have with carriage returns and line feeds in ASCII. Especially
    with CSV spreadsheet files, using the wrong UTF import can make good files look
    like garbage.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的 UTF 格式之间转换文件是我们曾经在 ASCII 中遇到的回车和换行问题的现代版。特别是在 CSV 表格文件中，使用错误的 UTF 导入可能会导致本应良好的文件看起来像垃圾。
- en: '*Multimedia Data Representation*'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*多媒体数据表示*'
- en: Data representation gets more fun as we move to images, video, and audio to
    bring our computers to life. These representations are all built on the arrays
    of numbers we’ve previously constructed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表示变得更加有趣，当我们处理图像、视频和音频时，可以让我们的计算机“栩栩如生”。这些表示都是建立在我们先前构建的数字数组之上的。
- en: '**Image Data**'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**图像数据**'
- en: 'Grayscale images can be represented by 2D arrays of numbers, with each element
    representing a pixel, and its value representing the shade of gray. The type of
    integer representation within this array affects the quality of the image: if
    1-bit integers are used, then each pixel can only be black (0) or white (1), whereas
    if 8-bit integers are used, then 256 shades of gray are available between black
    (0) and white (255).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像可以通过二维数字数组表示，每个元素代表一个像素，其值表示灰度。这个数组中使用的整数表示类型会影响图像的质量：如果使用 1 位整数，那么每个像素只能是黑色（0）或白色（1），而如果使用
    8 位整数，则可以在黑色（0）和白色（255）之间获得 256 种灰度。
- en: 'Human eyes are receptive to three main frequencies of light: red, green, and
    blue. This means the experience of seeing an image in color can be reproduced
    by shining lights at each of these frequencies from each pixel. To represent a
    color image, we can therefore take three grayscale image representations; use
    them to represent the red, green, and blue channels of the image; and somehow
    store them together. Different systems may use different approaches to this storage.
    For example, we might store the complete red image first, then the green after
    it, then the blue. But some computations may run faster if we *interleave* the
    channels, with the red, green, and blue values for the top-left pixel stored first,
    one after the other, then the red, green, and blue values for the pixel next to
    it, and so on.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 人眼对三种主要的光频率有反应：红色、绿色和蓝色。这意味着看到彩色图像的体验可以通过从每个像素处发出这些频率的光来再现。为了表示彩色图像，我们可以因此采用三种灰度图像表示；将它们分别表示图像的红色、绿色和蓝色通道；并以某种方式将它们存储在一起。不同的系统可能采用不同的方法来存储这些数据。例如，我们可能先存储完整的红色图像，然后存储绿色图像，再存储蓝色图像。但如果我们*交错*存储通道，某些计算可能会更快，即首先存储左上角像素的红色、绿色和蓝色值，依次存储接下来像素的红色、绿色和蓝色值，依此类推。
- en: For some applications, it’s useful to add a fourth channel, called *alpha*,
    to represent the transparency of each pixel. This representation is known as RGBA.
    For example, in sprite-based games this tells the graphics code how to mask each
    sprite, leaving the background intact behind its shape. Non-binary alphas can
    also be used to blend images together by making them partially transparent to
    various degrees. Including an alpha channel is especially convenient because having
    four channels makes a power of two, which plays nicely with binary architectures.
    For example, it is common to use 32-bit colors with four 8-bit channels, rather
    than 24-bit colors with three 8-bit channels, on a 32-bit machine. Of course,
    this requires more storage, so pixel values might be stored as 24 bits and converted
    to 32 bits when loaded into memory. (Since 24-bit RGB is usually considered the
    maximum color depth that humans can distinguish, there’s little point in going
    to 64-bit color, even on 64-bit machines.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，添加一个名为*alpha*的第四通道来表示每个像素的透明度是很有用的。这种表示方式被称为RGBA。例如，在基于精灵的游戏中，这告诉图形代码如何遮罩每个精灵，保持其形状后面的背景不变。非二进制的alpha值也可以用来将图像混合在一起，使它们在不同程度上部分透明。包括alpha通道尤其方便，因为拥有四个通道是2的幂次方，这与二进制架构兼容。例如，在32位机器上，通常使用具有四个8位通道的32位颜色，而不是使用三个8位通道的24位颜色。当然，这需要更多的存储，因此像素值可能以24位存储，并在加载到内存时转换为32位。（由于24位RGB通常被认为是人类可分辨的最大色深，即使在64位机器上，也没有太大意义使用64位颜色。）
- en: Video can be represented (most basically) as a sequence of still images packed
    in temporal sequence.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 视频可以最基本地表示为一系列按时间顺序排列的静态图像。
- en: '**Audio Data**'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**音频数据**'
- en: Continuous sound waves can be represented as a series of discrete samples. The
    samples need to be taken at a rate of double the highest frequency present in
    the signal. Human hearing ranges from around 20 to 20,000 Hz, so common audio
    sample rates are around 40,000 Hz. Each sample is a number, and as with color
    depth, the choice of the number of bits to devote to each sample affects the sound
    quality. Consumer media such as Blu-ray uses a depth of 24 bits, around the maximum
    distinguishable to humans, while 32 bits may be used internally and by audio producers,
    as it’s a power of two and gives more robustness to editing manipulations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 连续的声波可以表示为一系列离散的样本。这些样本需要以信号中最高频率的两倍速率进行采样。人类的听力范围大约是20到20,000赫兹，因此常见的音频采样率约为40,000赫兹。每个样本是一个数字，与色深一样，分配给每个样本的位数选择会影响音质。消费者媒体如蓝光使用24位深度，这是人类可区分的最大值，而32位深度则可能在内部或音频制作人中使用，因为它是2的幂次方，且在编辑操作中提供了更强的鲁棒性。
- en: Stereo or multichannel audio can be thought of as a collection of sound waves
    meant to be played together. These might be stored as one whole wave at a time
    in memory, or interleaved over time, with one sample from each channel stored
    contiguously for each sample time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 立体声或多声道音频可以看作是一起播放的声波集合。这些可以在内存中作为一个完整的波形一次性存储，或者随着时间的推移交错存储，每个采样时间从每个通道存储一个样本。
- en: Almost all sound representations use either integer or fixed-point representations
    for the individual samples. A consequence of this is that there are clear minimum
    and maximum values that samples can take. If the signal goes out of this “headroom”
    range it will *clip*, losing information and sounding distorted. Musicians and
    voice actors often curse these data representations if they have just performed
    a perfect take but it got clipped and they have to do it again. A recent trend
    in professional audio systems is a move to all floating-point representations,
    which are much more computationally intensive but free the artists from the clipping
    problem.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的声音表示方式都使用整数或定点表示法来处理每个样本。其结果是，样本有明确的最小值和最大值。如果信号超出了这个“头部空间”范围，它将*被削波*，丢失信息并产生失真。音乐家和配音演员常常抱怨这种数据表示方式，如果他们刚完成完美的录音，但却被削波了，只好重新录制。最近，专业音频系统的一个趋势是转向全浮动点表示，这虽然计算密集，但能够解放艺术家免于削波问题。
- en: When dealing with *multi*media, such as movies that include video and audio
    together, the interleaving representation concept is often extended so that data
    from each medium for a point in time is coded together in a contiguous area of
    memory—for example, all the data for one video frame, plus an audio segment for
    the duration of that frame. The interleaving schemes are known as *containers*.
    *Ogg* and *MP4* are two well-known container data representations used for movies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 处理*多*媒体时，例如包含视频和音频的电影，交错表示的概念通常会被扩展，使得每个时刻的各类媒体数据被一起编码到内存中的一个连续区域——例如，某一视频帧的所有数据，再加上该帧时长的音频段。这些交错方案被称为*容器*。*Ogg*和*MP4*是用于电影的两种知名容器数据表示格式。
- en: '**Compression**'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**压缩**'
- en: The simple media representations for images, video, and audio that we’ve just
    discussed are good during computation, but they aren’t usually ideal in terms
    of storage. For efficiency, we often look for ways to *compress* the data without
    changing the human experience of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的关于图像、视频和音频的简单媒体表示在计算过程中是有效的，但通常在存储方面并不理想。为了提高效率，我们通常会寻找方法来*压缩*数据，同时不改变人类对其的体验。
- en: The natural world tends to contain a lot of redundancy—that is, it has regions
    of space and time that are composed of similar stuff. For example, in a video
    of a thrown red ball, if you see one red pixel belonging to the ball, then it’s
    very likely that the pixels around it are also red, and that this pixel or nearby
    pixels will be red in the next frame as well. Also, the human senses have particular
    focuses and blind spots, for example being sensitive to the amplitude but not
    the phase of audio frequencies, and not hearing some frequencies in the background
    when others are present.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自然界通常包含大量冗余——即，某些空间和时间区域由相似的内容组成。例如，在一段投掷红色球的视频中，如果你看到一个属于球的红色像素，那么周围的像素也很可能是红色的，而且这个像素或附近的像素在下一帧中也会是红色的。此外，人类的感官有特定的关注点和盲区，例如对音频频率的振幅敏感，而对其相位不敏感，以及在某些频率存在时，无法听到背景中的其他频率。
- en: 'Information theory explains how to compress media data by exploiting and removing
    these redundancies and perceptual blind spots. This way, a smaller number of bits
    can be used in a more complex way to represent the same or perceptually similar
    media data. This is useful both to reduce physical storage needs, such as the
    size of a Blu-ray disc, and also to reduce network use when streaming media. However,
    it comes at a cost of additional computation: we usually need to convert the compressed
    representations back to the raw ones, which can be quite complex, depending on
    the compression scheme used. Most schemes rely on mathematical operations like
    Fourier transforms to find spatial or temporal frequencies. These can be costly
    for conventional CPUs to compute and have been a major driver of specialized signal
    processing architectures to accelerate them. Implementations of compression algorithms
    are known as *codecs*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 信息理论解释了如何通过利用和去除冗余数据以及感知盲点来压缩媒体数据。这样，使用更少的位可以以更复杂的方式表示相同或感知上相似的媒体数据。这对于减少物理存储需求（如蓝光光盘的大小）以及减少流媒体传输时的网络使用非常有用。然而，这也带来了额外的计算成本：我们通常需要将压缩后的表示恢复为原始数据，这可能相当复杂，具体取决于使用的压缩方案。大多数方案依赖于像傅里叶变换这样的数学操作来寻找空间或时间频率。这些操作对传统的CPU来说计算成本较高，且已成为推动专用信号处理架构加速计算的主要因素。压缩算法的实现被称为*编解码器*。
- en: '*Data Structures*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*数据结构*'
- en: 'Any data structure, such as the structs and objects found in most programming
    languages, can be represented through *serialization*, whereby the data is transformed
    into a *series* of bits to store in memory. Serialization can be performed hierarchically:
    if a complex structure is composed of several smaller structures, we serialize
    it by first serializing each of these components, then joining their representations
    together in series to make the total representation. If the component structures
    are themselves complex, the process becomes recursive, but eventually we always
    reach a level of simple elements such as numbers or text, and we’ve already discussed
    how to represent these as a series of bits (that is, serialize them).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据结构，例如大多数编程语言中的结构体和对象，都可以通过*序列化*来表示，序列化是将数据转化为一系列的比特以存储在内存中。序列化可以分层进行：如果一个复杂的结构由多个较小的结构组成，我们首先序列化每个组件，然后将它们的表示按顺序连接起来，形成整体的表示。如果这些组件本身也是复杂的结构，过程会变成递归的，但最终我们总会到达一些简单的元素层级，比如数字或文本，而我们已经讨论过如何将这些表示为一系列比特（也就是对其进行序列化）。
- en: 'To give an example, say we have the following data structure:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们有以下数据结构：
- en: '[PRE3]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will be serialized as a bit sequence beginning with the encoding for integer
    `age`, followed by the encoding for integer `legs`, and then perhaps a Unicode
    sequence for the string `name`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被序列化为一个比特序列，首先是整数`age`的编码，接着是整数`legs`的编码，然后可能是字符串`name`的Unicode序列。
- en: 'Now say a `Cat` object is included in another structure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个`Cat`对象被包含在另一个结构中：
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Game` object will be serialized with its first bits being the encoding
    of the `Cat` object (itself a serialization of various components), followed by
    the encodings of the `lives` and `score` integers. We can continue to build higher
    and higher levels of structure in this way, which is how real-world large-scale
    programs work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`对象将被序列化，其第一个比特将是`Cat`对象的编码（它本身是多个组件的序列化），接着是`lives`和`score`整数的编码。我们可以继续以这种方式构建更高层次的结构，这也是现实世界大型程序的工作方式。'
- en: Measuring Data
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量数据
- en: The basic unit of data is the *bit (b)*, which can take one of two possible
    states, usually written as 0 and 1\. When studying data, we’ll often be working
    with very large numbers of bits, however, so we need notations and visualizations
    to handle these.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的基本单位是*比特（b）*，它可以有两种可能的状态，通常表示为0和1。我们在研究数据时，通常会处理大量的比特，因此我们需要符号和可视化工具来处理这些。
- en: '*SI (Système Internationale)* is an international organization of scientists
    and engineers that sets generally accepted standards for scientific measurement
    units. This includes defining standard prefixes for powers of 1,000, as shown
    in [Table 2-3](ch02.xhtml#ch02tab3).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*SI (国际单位制)* 是一个国际科学家和工程师组织，负责设定科学计量单位的通用标准。这包括为千的幂定义标准前缀，如[表2-3](ch02.xhtml#ch02tab3)所示。'
- en: '**Table 2-3:** Large SI Prefixes'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-3：** 大型SI前缀'
- en: '| **Name** | **Symbol** | **Value** |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **符号** | **数值** |'
- en: '| --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| kilo | k | 10³ =1,000 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| kilo | k | 10³ = 1,000 |'
- en: '| mega | M | 10⁶ = 1,000,000 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| mega | M | 10⁶ = 1,000,000 |'
- en: '| giga | G | 10⁹ = 1,000,000,000 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| giga | G | 10⁹ = 1,000,000,000 |'
- en: '| tera | T | 10^(12) = 1,000,000,000,000 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| tera | T | 10^(12) = 1,000,000,000,000 |'
- en: '| peta | P | 10^(15) = 1,000,000,000,000,000 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| peta | P | 10^(15) = 1,000,000,000,000,000 |'
- en: '| exa | E | 10^(18) = 1,000,000,000,000,000,000 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| exa | E | 10^(18) = 1,000,000,000,000,000,000 |'
- en: '| zetta | Z | 10^(21) = 1,000,000,000,000,000,000,000 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| zetta | Z | 10^(21) = 1,000,000,000,000,000,000,000 |'
- en: To visualize the large scales represented by SI prefixes, it can be useful to
    imagine 3D cubes, based on a cubic meter. Perhaps the reason we give special names
    and prefixes to powers of 1,000 is that 1,000 is three scalings of 10, which in
    3D means scaling an object by 10 in all three of its dimensions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象化SI前缀所表示的大规模数据，可以想象基于立方米的三维立方体。也许我们给千的幂特别命名并添加前缀的原因是，1,000是10的三次幂，在三维空间中意味着将物体在三个维度上都按10的比例放大。
- en: Using SI prefixes with bits should be the preferred standard for describing
    quantities of data, according to SI—for example, 5 megabits means 5,000 bits.
    In fact, network speeds are often measured in megabits per second. However, at
    the architectural level we more commonly need to work with numbers that are exact
    powers of 2, not 10\. For example, a 10-bit address space provides 2^(10) = 1,024
    addresses, while a 16-bit address space provides 2^(16) = 65,536 addresses. Before
    architects adopted the SI standards—during the 8-bit era, for example—it was common
    for architects to abuse the prefix “kilo” to refer to 1,024 instead of 1,000.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 根据国际单位制（SI）的规定，使用位的SI前缀应该是描述数据量的首选标准——例如，5兆比特表示5000位。实际上，网络速度通常以每秒5兆比特来衡量。然而，在体系结构层面上，我们更常需要处理的是精确的2的幂，而不是10的幂。例如，10位地址空间提供2^(10)
    = 1,024个地址，而16位地址空间提供2^(16) = 65,536个地址。在架构师采用SI标准之前——例如，在8位时代——架构师通常滥用“千”这个前缀来表示1,024而不是1,000。
- en: This naturally led to much confusion. Data sizes have gotten larger, and most
    computer people operate at a higher level, where working in proper SI units makes
    more sense. As a compromise, in 1998 the International Electrotechnical Commission
    defined an alternate set of prefixes to distinguish the powers of two from the
    SI prefixes. These have the morpheme *bi* in them, from the word *binary*. For
    example, 2^(10) has become kibi, 2^(20) has become mebi, and so on, as in [Table
    2-4](ch02.xhtml#ch02tab4).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然导致了许多混乱。数据大小变得更大，大多数计算机人员在更高的层次上工作，在那里使用正确的SI单位更有意义。作为折衷方案，国际电工委员会在1998年定义了一套替代前缀，用以区分二的幂和SI前缀。这些前缀包含了词根*bi*，源自*binary*一词。例如，2^(10)已变为kibi，2^(20)已变为mebi，以此类推，如[表2-4](ch02.xhtml#ch02tab4)所示。
- en: '**Table 2-4:** Large Binary Prefixes'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-4：** 大型二进制前缀'
- en: '| **Name** | **Symbols** | **Value** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **符号** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| kibi | k[2], ki | 2^(10) = 1,024 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| kibi | k[2], ki | 2^(10) = 1,024 |'
- en: '| mebi | M[2], Mi | 2^(20) = 1,048,576 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| mebi | M[2], Mi | 2^(20) = 1,048,576 |'
- en: '| gibi | G[2], Gi | 2^(30) = 1,073,741,824 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| gibi | G[2], Gi | 2^(30) = 1,073,741,824 |'
- en: '| tebi | T[2], Ti | 2^(40) = 1,099,511,627,776 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| tebi | T[2], Ti | 2^(40) = 1,099,511,627,776 |'
- en: '| pebi | P[2], Pi | 2^(50) = 1,125,899,906,842,624 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| pebi | P[2], Pi | 2^(50) = 1,125,899,906,842,624 |'
- en: '| exbi | E[2], Ei | 2^(60) = 1,152,921,504,606,846,976 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| exbi | E[2], Ei | 2^(60) = 1,152,921,504,606,846,976 |'
- en: '| zebi | Z[2], Zi | 2^(70) = 1,180,591,620,717,411,303,424 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| zebi | Z[2], Zi | 2^(70) = 1,180,591,620,717,411,303,424 |'
- en: Binary prefixes are slightly larger than their SI counterparts. Not everyone
    is using them yet, and many older people and machines still use SI names to refer
    to binary units. Unscrupulous hardware manufacturers often exploit this ambiguity
    by picking whichever interpretation of the SI names will give them the best-looking
    numbers on their products.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制前缀稍微大于它们的SI对应前缀。并不是所有人都在使用它们，许多老旧的设备和用户仍然使用SI单位来表示二进制单位。不道德的硬件制造商经常利用这种模糊性，选择那些能使他们产品上显示出最漂亮数字的SI名称解释。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Computers usually need to represent various types of numbers, text, and media
    data. It’s convenient for modern machines to do this using binary. Hex representations
    chunk binary together to appear more readable to humans. Different representations
    make different computations easier to perform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通常需要表示各种类型的数字、文本和媒体数据。现代计算机使用二进制来进行这些表示非常方便。十六进制表示将二进制数据组织在一起，使其对人类更具可读性。不同的表示方式使得不同的计算变得更容易进行。
- en: Once we have methods for representing data, we can begin to build up methods
    for computing with the data. In the next chapter, we’ll preview a simple but complete
    computer that does this. We’ll then build up a more detailed modern electronic
    computer to do similar.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了表示数据的方法，就可以开始构建使用数据进行计算的方法。在下一章，我们将预览一个简单但完整的计算机，它能够完成这个过程。然后，我们将构建一个更详细的现代电子计算机来执行类似的操作。
- en: Exercises
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Base System Conversions**'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**进制系统转换**'
- en: Convert your phone number to binary.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的电话号码转换为二进制。
- en: Convert your phone number to hex. Making use of the binary from before might
    be helpful. Convert it again to byte codes, and convert the bytes to ASCII characters.
    What do they spell out?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的电话号码转换为十六进制。使用之前得到的二进制可能会有所帮助。然后再将其转换为字节码，并将字节转换为ASCII字符。它们拼写出来的是什么？
- en: Negate your phone number and convert this negative number to its two’s complement.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取你的电话号码的负数，并将这个负数转换为其二补数。
- en: Place a decimal point halfway through your phone number to make a floating-point
    number. Write it in IEEE 754 standard binary.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电话号码中间放置一个小数点，将其转化为浮动点数。按照IEEE 754标准以二进制表示。
- en: '**Text and Media**'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**文本和媒体**'
- en: Find out how to type in Unicode on your computer. On many Linuxes, for example,
    you can press and release SHIFT-CTRL-U, then type a series of hex numbers such
    as 131bc to enter an ancient Egyptian digit at your command line or in your editor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 找出如何在您的计算机上输入Unicode。例如，在许多Linux系统上，您可以按下并释放SHIFT-CTRL-U，然后键入一系列十六进制数字，如131bc，在命令行或编辑器中输入一个古埃及数字。
- en: '**Measuring Data**'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**测量数据**'
- en: Obtain street, aerial, and satellite photos of an area you know, and draw a
    kilocube, megacube, gigacube, teracube, petacube, exacube, and zettacube on them,
    where, for example, each side of a kilocube is 10 m long.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 获取你熟悉区域的街道、航空和卫星照片，并在上面绘制一个立方米、兆立方米、吉立方米、太立方米、拍立方米、艾克立方米和泽塔立方米，例如，一个立方米的每边长为10米。
- en: '**More Challenging**'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: Use a hex editor and the internet to reverse engineer and modify some of your
    favorite media files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制编辑器和互联网来逆向工程和修改一些你喜欢的媒体文件。
- en: Further Reading
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For discussions and psychological models of numerosity, see Stanislas Dehaene,
    *The Number Sense* (Oxford: Oxford University Press, 2011), and the “Numbo” chapter
    in Douglas R. Hofstadter, *Fluid Concepts and Creative Analogies* (New York: Basic
    Books, 1995).'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关数字心理学模型和讨论，请参阅Stanislas Dehaene的*数字感*（牛津：牛津大学出版社，2011年）以及Douglas R. Hofstadter的*流体概念与创造性类比*（纽约：基础书籍，1995年）中的“Numbo”章节。
- en: 'For an advanced but classic paper full of details on floating points, see D.
    Goldberg, “What Every Programmer Should Know About Floating Point Arithmetic,”
    *ACM Computing Surveys (CSUR)* 23, no. 1 (1991): 5–48.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个充满浮点数细节的先进但经典的论文，请参阅D. Goldberg的“每位程序员应知的浮点数算术” (*ACM计算调查* 23卷1期（1991年）：5-48)。
- en: 'For an extremely advanced but blindingly beautiful book on Turing reals, see
    Oliver Aberth, *Computable Calculus* (San Diego: Academic Press, 2001).'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图灵实数的一个极其先进但令人眼花缭乱的美丽书籍，请参阅Oliver Aberth的*可计算微积分*（圣地亚哥：学术出版社，2001年）。
