- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**DATA REPRESENTATION**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数据表示**'
- en: '![Image](../images/f0045-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0045-01.jpg)'
- en: A computer is a device that represents things in the real world and performs
    manipulations on these representations. Entities that we might want to represent
    and make computations about include physical objects, numbers, words, sounds,
    and pictures. This chapter examines systems for representing each of these types
    of entities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一种表示现实世界中的事物并对这些表示进行操作的设备。我们可能希望表示并进行计算的实体包括物理对象、数字、词语、声音和图片。本章将研究每种实体的表示系统。
- en: We’ll begin by exploring the history of how representations of objects, numbers,
    and text have evolved. We’ll then look at the modern symbol systems used to represent
    numbers—including decimal, binary, and hex—and use number representations to construct
    representations of further entities, such as text, audio, and video.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索物体、数字和文本表示的发展历史开始。然后，我们将研究现代符号系统如何用于表示数字——包括十进制、二进制和十六进制——并利用数字表示法构建进一步的实体表示，例如文本、音频和视频。
- en: In this chapter, the modern representations are built from 0s and 1s, which
    are left as symbols themselves. In later chapters, we’ll consider how to instantiate
    these zero and one symbols in digital electronics and make use of them in computations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，现代表示法是由0和1构建的，这些0和1本身作为符号保留。在后续章节中，我们将讨论如何在数字电子学中实例化这些零和一的符号，并在计算中加以利用。
- en: A Brief History of Data Representations
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据表示的简史
- en: The concepts of representation and computation are closely linked. Humans often
    need to represent the state of part of their world, as an aid to their own memories
    or as proof to other humans that something has happened or is going to happen.
    Once you have a representation, you can also use it to perform computations, to
    simulate what would happen if certain actions were done, or to deduce conclusions
    from what is known.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表示和计算的概念密切相关。人类常常需要表示世界某一部分的状态，作为自己记忆的辅助工具，或者作为向其他人证明某事已经发生或即将发生的证据。一旦有了表示，你也可以利用它进行计算，模拟如果执行某些操作会发生什么，或者从已知信息中推导出结论。
- en: For example, we often need to keep track of who owns what and who has debts
    to be paid. Static representations are useful for these purposes, and once these
    exist we can use them in computations to answer questions such as what would happen
    if we bought something, or how long it will take to repay a debt. Representation
    thus comes before computation, both conceptually and historically. Let’s trace
    how it evolved, from humanity’s first efforts to the symbol systems that we use
    today.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们常常需要追踪谁拥有什么以及谁欠债。静态表示对于这些目的非常有用，一旦有了这些表示，我们就可以利用它们进行计算，回答例如如果我们买了某样东西，或者还债需要多长时间等问题。因此，表示在计算之前，不论是在概念上还是在历史上，都是先行的。让我们追溯它的发展，从人类的第一次尝试到我们今天使用的符号系统。
- en: '*Tally Sticks and Trading Tokens*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*刻痕棒和交易代币*'
- en: The oldest-known data representation is the use of *tally sticks*, such as the
    Lebombo bone shown in [Chapter 1](ch01.xhtml). These are simple sticks with several
    marks, where each mark represents one object. For example, the number 13 is represented
    by 13 marks, usually made in a row, as in [Figure 2-1](ch02.xhtml#ch02fig1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最古老的已知数据表示法是使用*刻痕棒*，例如在[第1章](ch01.xhtml)中展示的Lebombo骨。刻痕棒是简单的棍子，上面有若干标记，每个标记代表一个物体。例如，数字13用13个标记表示，通常是按顺序排列的，如[图2-1](ch02.xhtml#ch02fig1)所示。
- en: '![Image](../images/f0046-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0046-01.jpg)'
- en: '*Figure 2-1: A simple tally*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：一个简单的计数*'
- en: By Sumerian times (4000 BCE), physical tokens were used to represent objects,
    as in [Figure 2-2](ch02.xhtml#ch02fig2). A small clay model of an animal, for
    example, represented the actual animal and could probably have been exchanged
    for it. This would have simplified trading, as you could travel from the city
    of Ur to the city of Uruk with 10 animal tokens and make a deal by swapping them
    for, say, 20 beer tokens, with the actual objects only being moved around later,
    after a successful deal. These tokens could also have been divided between groups
    of people or given as tax to the king.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到了苏美尔时代（公元前4000年），人们开始使用物理代币来表示物体，如[图2-2](ch02.xhtml#ch02fig2)所示。例如，一只小型的泥土动物模型代表了实际的动物，并且可能可以用它交换。这样可以简化交易，你可以从城市乌尔（Ur）带着10个动物代币到城市乌鲁克（Uruk），然后用这些代币交换20个啤酒代币，实际物品的转移可能会在交易成功后再进行。这些代币也可以在不同的群体间分配，或者作为税收交给国王。
- en: '![Image](../images/f0046-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0046-02.jpg)'
- en: '*Figure 2-2: Sumerian trading tokens*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：苏美尔贸易代币*'
- en: Computing with tally sticks and tokens is, however, quite slow. To add *m* tallies
    or tokens to *n*, you have to go through the process of adding each of the *m*
    into the *n*, one at a time. If you’ve studied complexity theory, this means that
    addition is order O(*m*) in the size of the numbers being added.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用计数棒和代币进行计算是非常缓慢的。要将*m*个计数或代币加到*n*上，你必须逐一地将每个*m*加入到*n*中。如果你研究过复杂性理论，这意味着加法的时间复杂度是O(*m*)，与被加数字的大小有关。
- en: By 3000 BCE—still before the abacus—the Sumerians sped up their calculations
    by sealing many tokens in a clay “envelope” called a *bulla*, shown in [Figure
    2-3](ch02.xhtml#ch02fig3). The bulla was sealed both physically, by joining its
    clay to encapsulate the contents, and informationally, by stamping a complex,
    unforgeable mark onto it. (This is the origin of ceremonial seals still used today
    on royal and governmental documents, such as the Great Seal of the USA. It’s also
    the origin of later digital signatures.) The seal guaranteed, probably in the
    name of the king or another powerful and trustworthy person, that a certain number
    of tokens were contained within it. This way, instead of counting out 12 animal
    tokens, you could hand over a bulla of 12 animals at a time. The bulla would function
    like a 12-token coin or banknote, but one that physically contained the 12 tokens
    inside.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到公元前3000年——仍在算盘之前——苏美尔人通过将多个代币密封在一个称为*bulla*的泥土“信封”中，加速了他们的计算过程，如[图 2-3](ch02.xhtml#ch02fig3)所示。bulla既在物理上封闭，通过将泥土粘合在一起以封存内容，也在信息上通过在其上印上复杂且难以伪造的印记来封存。（这就是今天仍在王室和政府文件上使用的仪式印章的起源，比如美国的大印。这也是后来的数字签名的起源。）印章保证，可能是以国王或其他有权威且可信之人的名义，bulla内部包含了特定数量的代币。这样，你不必再逐个计数12个动物代币，而是可以一次性交付包含12个动物代币的bulla。bulla就像一枚包含12个代币的硬币或纸币，但其内部实际包含着12个代币。
- en: '![Image](../images/f0047-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-01.jpg)'
- en: '*Figure 2-3: A bulla*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：一枚封印*'
- en: A similar development to the bulla is found in tally sticks from this period,
    where tally marks started to be grouped together, as shown in [Figure 2-4](ch02.xhtml#ch02fig4).
    Counting out *n* scratches usually requires *n* operations, but if we replace,
    say, every fifth vertical stroke with a diagonal one going through the previous
    four, we can quickly count how many groups of five we have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与bulla的类似发展可以在这一时期的计数棒中找到，那里计数标记开始被分组在一起，如[图 2-4](ch02.xhtml#ch02fig4)所示。逐个数出*n*个刻痕通常需要*n*次操作，但如果我们将每第五个竖直划线替换为一条穿过前四个的斜线，我们就能快速地数出有多少组五个。
- en: '![Image](../images/f0047-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-02.jpg)'
- en: '*Figure 2-4: A grouped tally*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：分组计数*'
- en: '*Roman Numerals*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*罗马数字*'
- en: In a closely related notation to grouped tallies, we can replace the fifth stroke
    with two shorter diagonal strokes to make a V, and the tenth with an X, as in
    [Figure 2-5](ch02.xhtml#ch02fig5), forming the beginnings of the *Roman numerals*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在与分组计数密切相关的符号中，我们可以将第五条划线替换为两条较短的斜线，形成V，第十条则替换为X，如[图 2-5](ch02.xhtml#ch02fig5)所示，这标志着*罗马数字*的开始。
- en: '![Image](../images/f0047-03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-03.jpg)'
- en: '*Figure 2-5: Early Roman numerals*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：早期罗马数字*'
- en: Roman numerals developed further to closely represent the human perception of
    numbers. Humans appear to perceive the sizes of sets of 1, 2, 3, and 4 objects
    directly and immediately. Beyond this, our immediate perception is of *numerosity*
    or approximate size rather than exact number, based on sizes roughly around 5,
    10, 20, 50, 100, and 1,000\. Most number symbol alphabets reflect this, with Egyptian,
    Chinese, and Arabic numbers having special symbols for 1, 2, 3, and 4 that feature
    the corresponding number of strokes, and more abstract symbols for 5 and above.
    The Roman numeral system also uses symbols to represent the “landmark” numbers,
    such as V = 5, X = 10, L = 50, C = 100, and M = 1,000, with smaller-valued symbols
    positioned before or after to indicate adjustments to the landmark, such as VI
    = 6 and IX = 9.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字进一步发展，以更准确地反映人类对数字的感知。人类似乎能够直接并立刻感知1、2、3和4个物体的大小。超过这个范围，我们的即时感知是*数量感*或近似大小，而非确切数字，这些数字大致围绕着5、10、20、50、100和1,000。大多数数字符号字母表反映了这一点，埃及、中文和阿拉伯数字都有1、2、3和4的特殊符号，这些符号显示了相应的笔画数，而对于5及以上则使用更抽象的符号。罗马数字系统也使用符号来表示这些“标志性”数字，例如V
    = 5，X = 10，L = 50，C = 100，以及M = 1,000，较小的符号则位于标志性符号之前或之后，以表示对标志性数字的调整，例如VI = 6和IX
    = 9。
- en: Roman numerals have the advantage of being a close model of how humans actually
    think about numbers, but if you try to do large-scale arithmetic such as adding
    and multiplying with them, you’ll quickly run into difficulty. This is a classic
    example of how the choice of representation can heavily affect your ability to
    do certain types of computation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字的优点在于，它们与人类实际思考数字的方式非常接近，但如果你尝试进行大规模的算术运算，如加法和乘法，你很快就会遇到困难。这是一个经典的例子，说明了表示方法的选择如何显著影响你进行某些类型计算的能力。
- en: '*Split Tallies*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分裂记账符号*'
- en: A *split tally* was a variation of the tally stick, in which the stick was marked
    up, then split into two pieces down its length, as in [Figure 2-6](ch02.xhtml#ch02fig6).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*分裂记账符号*是记账棍的一种变体，记账棍上做标记后沿其长度将其分裂成两部分，如[图2-6](ch02.xhtml#ch02fig6)所示。'
- en: '![Image](../images/f0048-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0048-01.jpg)'
- en: '*Figure 2-6: A split tally*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：分裂记账符号*'
- en: Both halves contain parts of the same notches, and both halves could be reunited
    to show they were genuine and fitted together. They were used to record loans,
    with the long and short halves (the *stock* and *foil*) given to the lender and
    borrower, the origin of our modern financial *long* and *short* positions in stocks.
    The British government continued to use split tally sticks until it burned its
    last wooden tallies to modernize its IT systems around 1836, the time of Babbage’s
    Analytical Engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两个部分包含相同的刻痕，且可以重新结合，证明它们是真正匹配的。它们被用于记录贷款，长短两部分（*原件*和*副本*）分别交给借款人和贷款人，这也成为我们现代金融中*多头*和*空头*头寸的起源。英国政府直到1836年左右，现代化其信息技术系统时，才停止使用分裂记账棍，并烧毁了最后一批木制记账符号，那时正是巴贝奇的分析机时期。
- en: '*Arabic and Other Numerals*'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*阿拉伯数字及其他数字*'
- en: Other civilizations developed number representations using copies of symbols
    for large numbers, as shown in [Figure 2-7](ch02.xhtml#ch02fig7).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文明发展了使用符号副本表示大数字的系统，如[图2-7](ch02.xhtml#ch02fig7)所示。
- en: For example, the ancient Egyptians had symbols for 10, 100, 1,000, and 10,000\.
    The number 23 would be shown using two copies of the 10 symbol (a heel) and three
    copies of the 1 symbol (a tally stroke). The number 354,000 would be shown using
    three copies of the 100,000 symbol (a tadpole), five copies of the 10,000 symbol
    (a finger), and four copies of the 1,000 symbol (a lotus flower).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，古埃及人有10、100、1,000和10,000的符号。数字23会用两个10的符号（一个脚跟）和三个1的符号（一个记账符）表示。数字354,000会用三个100,000的符号（一个蝌蚪）、五个10,000的符号（一个手指）和四个1,000的符号（一个莲花）表示。
- en: Eastern Arabic numbers appeared in the Islamic Golden Age, based on an earlier
    Indian system from around 500 CE. This system introduced the base-exponent method
    that we use today, with fixed columns containing symbols for numbers of 1s, 10s,
    100s, 1,000s, and so on. Importantly, this introduced the need for a concept and
    symbol of zero to fill in columns having no counts, which is missing from ancient
    Egyptian and similar systems. These symbols evolved into the Arabic numerals (1,
    2, 3, and so on) used in the West today.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 东方阿拉伯数字出现在伊斯兰黄金时代，基于公元500年左右的早期印度数字系统。该系统引入了我们今天使用的基数方法，并且有固定的列，用于表示1、10、100、1,000等数字。重要的是，这一系统引入了“零”的概念和符号，用来填补没有计数的列，这在古埃及和类似的系统中是没有的。这些符号演变成了今天西方使用的阿拉伯数字（1、2、3等）。
- en: '![Image](../images/f0049-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-01.jpg)'
- en: '*Figure 2-7: Modern Arabic, Ancient Egyptian, Suzhou Chinese, and Eastern Arabic
    numerals*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：现代阿拉伯数字、古埃及数字、苏州汉字数字和东阿拉伯数字*'
- en: Suzhou Chinese numerals evolved from ancient Chinese symbols relating to the
    base 10 abacus seen previously in [Figure 1-4](ch01.xhtml#ch01fig4), and are occasionally
    still in use today. You can see the symbols for 1 to 4 are based on tally strokes,
    while those from 5 to 9 are similar symbols placed under a “bead” for 5\. For
    a few significant digits, Suzhou uses a column system similar to Arabic numerals.
    For larger numbers, however, it uses a more advanced representation that shows
    the first few significant digits, followed by a separate symbol denoting what
    power of 10 they are multiplied by. In English we sometimes do this by writing
    *354 thousand* or *354k* rather than *354,000*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 苏州的汉字数字源自与前面在[图 1-4](ch01.xhtml#ch01fig4)中看到的十进制算盘相关的古代汉字符号，并且至今偶尔仍在使用。你可以看到1到4的符号基于记数的划痕，而5到9的符号则是类似的符号放置在一个“珠子”下方，表示5。对于一些重要的数字，苏州使用一种类似阿拉伯数字的列表示法。然而，对于较大的数字，它采用更先进的表示方式，显示前几个有效数字，然后是一个单独的符号，表示它们乘以的是10的多少次方。在英语中，我们有时会写成
    *354 thousand* 或 *354k*，而不是 *354,000*。
- en: This history of number *representation* belongs more properly to computer science
    than to mathematics. We can see that, historically, *typed* quantities such as
    “five cows plus three cows” were represented and computed with before more abstract
    mathematical number concepts such as “five plus three.” Mathematics takes numbers
    for granted and performs proofs about their properties. By contrast, the business
    of representation, both of actual objects and of abstract number concepts derived
    from them, is computer science, as is the question of how to build algorithms
    and machines based on these representations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的 *表示* 历史更适合归属于计算机科学，而非数学。我们可以看到，历史上，像“5头牛加3头牛”这样的 *有形* 数量曾被表示和计算，而不是像“5加3”这样的抽象数学数字概念。数学通常将数字视为理所当然，并对它们的性质进行证明。相比之下，数字表示的事务，无论是实际物体还是从中推导出来的抽象数字概念，属于计算机科学范畴，如何基于这些表示构建算法和机器也是计算机科学的内容。
- en: Modern Number Systems
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代数字系统
- en: We’ve seen how our modern concept of numbers evolved from tallies into the symbolic,
    Arabic system used in everyday life today. The key innovation of the Arabic system
    is the use of columns to represent digits in a base. This (as we’ll see when we
    start computing) makes algorithmic arithmetic easier, and also reduces the size
    of representations. For example, you only need four symbols to represent the number
    2,021, rather than 2,021 clay tokens.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，现代数字概念是如何从记号演变为今天日常生活中使用的符号性阿拉伯数字系统的。阿拉伯系统的关键创新在于使用列来表示基数中的数字。正如我们在开始计算时会看到的，这使得算法运算更加简便，也减少了表示的大小。例如，你只需要四个符号就可以表示数字
    2,021，而不需要2,021个粘土代币。
- en: Our everyday Arabic numbers are decimal, using base 10, but this isn’t necessarily
    the base for computers. This section generalizes the idea of bases and exponents
    and presents several related systems that are useful in computers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常使用的阿拉伯数字是十进制的，使用基数10，但这并不一定是计算机使用的基数。本节将概括基数和指数的概念，并介绍一些在计算机中有用的相关系统。
- en: '*Bases and Exponents*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数和指数*'
- en: 'We will make heavy use of exponentiation in representing numbers. *Exponentiation*
    is the repeated multiplication of a *base*, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示数字时，我们将大量使用指数运算。*指数运算* 是基数的重复乘法，例如：
- en: 2³ = 2 × 2 × 2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2³ = 2 × 2 × 2
- en: Here, 2 is the base and 3 is the exponent. This may also be written as 2^3\.
    In some computer languages, it appears as `2**3`, or is written via a power function,
    such as `pow(2,3)`. Exponentiation is sometimes called “raising to the power,”
    as in “two to the power of three.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，2是基数，3是指数。它也可以写作 2^3。在某些计算机语言中，它以 `2**3` 的形式出现，或者通过幂函数表示，如 `pow(2,3)`。指数运算有时被称为“提升到某次幂”，例如“2的三次幂”。
- en: More generally, we write a base *b* to the power of an exponent *n* as
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们将基数 *b* 的 *n* 次幂写作
- en: '*b^n* = *b* × *b* × *b* × . . . × *b*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*b^n* = *b* × *b* × *b* × . . . × *b*'
- en: 'meaning there are *n* copies of *b*. Zero and negative exponentiation are defined
    as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有 *n* 个 *b*。零和负指数定义如下：
- en: '![Image](../images/f0050-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0050-01.jpg)'
- en: If we choose a base *b*, we may then define a *number system* as a mapping from
    a list of *numeral symbols* to a *number*. Symbols are marks on a piece of paper
    or entries in some other type of storage system; numbers are the actual mathematical
    objects being represented.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个基数 *b*，那么可以定义一个 *数字系统*，它是从一组 *数字符号* 到一个 *数字* 的映射。符号是写在纸上的标记或存储系统中的条目；数字是实际的数学对象。
- en: To write base *b* numbers, we need an alphabet containing *b* symbols. Strings
    of *N* of these symbols can have *b^N* different states, which are used to represent
    numbers from 0 to *b^N* – 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: When we work with symbols in different bases, we will sometimes use a subscript
    to indicate what base the symbols are written in. For example, 123[10] means one
    hundred and twenty-three in base 10, while 1001[2] means one 8, no 4s, no 2s,
    and one 1 in base 2 (which equals 9[10]). In other cases, we’ll omit the subscript
    where the base is clear from the context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 10: Decimal*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Everyday arithmetic uses base 10, in which, for example, the string of symbols
    7, 4, 3, written as 743, is interpreted as representing the number seven hundred
    and forty-three. We can see this mathematically using exponents of 10:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 743 = 7 × 10² + 4 × 10¹ + 3 × 10⁰
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a point notation and negative exponents, we can represent fractional
    numbers. For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 743.29 = 7 × 10² + 4 × 10¹ + 3 × 10⁰ + 2 × 10^(–1) + 9 × 10^(–2)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'For base 10 we have an alphabet of 10 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, and
    9\. Strings of *n* symbols from this alphabet can specify one of 10^(*n*) numbers;
    for example, with *n* = 4, there are 10,000 numbers, 0 to 9,999 inclusive.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 2: Binary*'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Base 2 is known as *binary* and is used in almost all modern computers. It has
    an alphabet of two symbols, usually written as 0 and 1, but sometimes as T and
    F for *true* and *false*. In electronic computers, the two symbols are represented
    using high and low voltages. *High* is usually the system’s positive voltage,
    such as 5 V or 3.3 V, while *low* is usually ground or 0 V. Binary is useful for
    electrical machines because real voltages are noisy, and attempts to include extra
    symbols such as *medium* have been doomed to failure. But *high* and *low* can
    more easily and cheaply be separated into two clear classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'A single symbol in base 2 is called a *bit*, short for *bi*nary dig*it*. A
    string of *N* bits can represent one of 2^(*N*) numbers, such as ranging from
    0 to 2^(*N*) – 1\. The columns of the string represent powers of 2\. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0051-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: The powers of two that appear in this calculation (0, 1, 2, 4, 8, 16, 32, 64,
    128, 256, 512, 1,024, 2,048, and so on) should be instantly recognizable to anyone
    used to computing. They often appear as sizes of memory capacity and as sizes
    in bits or bytes of data structures used at the hardware level. If you plan to
    work at or near the hardware level, you’ll need to memorize these powers of two
    for everyday use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To convert from binary to decimal, add up the powers of two for each column
    that has a 1 in it. To convert from decimal to binary, at each step, try to subtract
    the highest power of two from the decimal, and make a note of which powers of
    two have been subtracted. Write 1s in those columns and 0s in the others.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Some mathematical operations are faster or slower in different bases. In base
    10, you can quickly multiply or divide by 10 by shifting the decimal (radix) point
    one place to the left or right. Where numbers are represented in binary, you can
    use a similar trick to quickly multiply or divide by 2\. This is known as *binary
    shift* and is implemented in hardware by most CPUs. In the C language, for example,
    a fast multiplication by 8 (2³) can be done by writing `y=x>>3;`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Alternate notations used in some books and programming languages for binary
    include 1110[2], 0b1110, and 1110b.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '*A famous computer science joke says, “There are 10 kinds of computer scientists:
    those who know nothing, and those who know binary.”*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 1,000*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a means of introducing other notations—hex and byte codes—let’s look at decimal
    notation in a different way, which we’ll call *compound notation*. It’s common
    to write large numbers by grouping them into chunks of three digits separated
    by commas, to make them easier to read. For example, the number 123,374,743,125
    symbolizes the value one hundred and twenty-three *billion*, three hundred and
    seventy-four *million*, seven hundred and forty-three *thousand*, one hundred
    and twenty-five. (The “one hundred and twenty-five” at the end refers to the number
    of *ones*.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine for a moment that these chunks are individual symbols, from an alphabet
    containing 1,000 symbols from 0 to 999\. Don’t think of 999 as three 9s, but as
    a single symbol. Under this view, we can consider the comma-separated string as
    a string of 4 symbols in base 1,000, rather than 12 symbols in base 10:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 123,374,743,125 = 123 × 1,000³ + 374 × 1,000² + 743 × 1,000¹ + 125 × 1,000⁰
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'This reflects our spoken language more accurately than thinking in base 10:
    we have names for powers of 1,000 (thousand, million, billion, trillion), but
    we don’t have names for 10,000 or 100,000 or 10,000,000\. Scientific units also
    follow this base 1,000 convention: kilo, mega, giga, and so on.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting about base 1,000 is the special relationship it has to base
    10\. Usually when we change bases, we expect the symbols to have a completely
    different appearance in the two bases. But when we switch between base 10 and
    base 1,000, the written symbols don’t change at all. We’ve simply gone from thinking
    of, say, 123 as three symbols in base 10 to thinking of it as a single symbol
    in base 1,000\. This makes it very easy and convenient to convert between the
    bases, as we do in our heads whenever we see or hear large numbers in everyday
    life.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 60: Sexagesimal*'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s talk about *sexagesimal*, also known as *base 60*. This system is relevant
    to modern computing for two reasons: first, like base 1,000, it’s another example
    of the sort of compound notation we’ll explore later; and second, it’s still in
    heavy computational use today.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We believe that some prehistoric human groups counted in base 12\. When we reach
    the time of the first cities (4000 BCE), the Sumerians switched to base 60 for
    their scientific studies, which included astronomy and the invention of an algorithmic
    version of the Pythagorean theorem. This may have arisen through a fusion, collision,
    or compromise between people using bases 10 and 12, as 60 is readily divisible
    by both.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信一些史前人类群体使用的是12为基数的计数方法。当我们进入第一个城市的时代（公元前4000年）时，苏美尔人为了科学研究（包括天文学和毕达哥拉斯定理的算法版本的发明）改用了60为基数的系统。这可能是通过使用10和12为基数的不同人群之间的融合、碰撞或妥协而形成的，因为60可以被10和12都整除。
- en: 'Rather than invent an alphabet of 60 distinct symbols, which would have required
    a large effort to learn, the Sumerians used a hybrid notation. They wrote the
    numbers from 0 to 59 (inclusive) in the existing base 10, but they treated these
    compound symbols as individual numerals in a base 60 system. For example, the
    symbols (using modern Arabic digits with compounds separated by colons) 11:23:13
    would represent the following number:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 苏美尔人并没有发明60个不同符号的字母表，这样做将需要大量的学习努力，他们使用了一种混合符号表示法。他们在现有的十进制系统中写下0到59（包括59）的数字，但将这些复合符号视为60进制系统中的独立数字。例如，符号（使用现代阿拉伯数字，复合符号用冒号分隔）11:23:13表示以下数字：
- en: 11 × 60² + 23 × 60¹ + 13 × 10⁰ = 39,889[10]
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 11 × 60² + 23 × 60¹ + 13 × 10⁰ = 39,889[10]
- en: 'We still use a sexagesimal system today to represent time: the number above
    means 23 minutes and 13 seconds past 11, which is equal to 39,889 seconds into
    the day. Modern databases, data science systems, and date-time libraries therefore
    need to be carefully designed to handle conversions between sexagesimal, binary,
    and decimal.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天仍然使用性别进制系统来表示时间：上面的数字意味着11点23分13秒，即一天中39,889秒的时间。因此，现代数据库、数据科学系统和日期时间库需要仔细设计，以处理性别进制、二进制和十进制之间的转换。
- en: '*Base 16: Hexadecimal*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数16：十六进制*'
- en: Let’s talk about hex! Short for *hexadecimal* or *hex code*, *hex* is a base
    16 system. Its symbols are a mix of the digits 0 through 9 and the letters a through
    `f` (for the decimal numbers 10 through 15), often prefixed by 0x to indicate
    they are hex.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈十六进制吧！十六进制是*十六进制*或*十六进制代码*的缩写，是一种以16为基数的系统。它的符号是0到9的数字和字母a到`f`（代表十进制的数字10到15）的混合，通常以0x为前缀来表示它们是十六进制数。
- en: 'You’ve probably seen hex numbers around in any computer programs in languages
    that allow direct access to and use of memory, including C and assembly. They
    also appear in higher-level languages as a way to differentiate copies of objects
    that otherwise have the same properties. For example, if you copy a `Cat` object
    (in an object-oriented language) with properties `numberOfLegs = 4` and `age =
    6,` you’ll get a second `Cat` object with those same properties, but the two copies
    are distinct because they have different names and are stored in different locations
    in memory. Some debugging tools will show these memory locations to allow you
    to see which object is which. For example, when you ask Python to print an object,
    you’ll see a hex address, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在任何允许直接访问和使用内存的计算机程序中见过十六进制数，包括C语言和汇编语言。它们也出现在高级语言中，作为区分具有相同属性的对象副本的一种方式。例如，如果你复制一个`Cat`对象（在面向对象的语言中），它的属性是`numberOfLegs
    = 4`和`age = 6`，你将得到一个具有相同属性的第二个`Cat`对象，但这两个副本是不同的，因为它们有不同的名称，并且存储在内存中的位置不同。一些调试工具会显示这些内存位置，以便你看到哪个对象是哪个。例如，当你要求Python打印一个对象时，你会看到一个十六进制地址，像这样：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Human interfaces to low-level computer architecture, such as memory locations,
    often use hex as an alternative, more human-readable way to display what is binary
    information. The address in the output above is really a long string of 0s and
    1s in binary, but this would be hard for a human to recognize, for example, when
    comparing two addresses to see if they’re the same or different. Comparing hex
    numbers is much easier.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 人类与低级计算机架构的接口，例如内存位置，通常使用十六进制作为一种替代、更易于人类阅读的方式来显示二进制信息。上面输出的地址实际上是一串长长的0和1的二进制数，但人类很难识别它们，例如，在比较两个地址时是否相同。比较十六进制数则要容易得多。
- en: 'Hex is used for displaying binary, rather than some other system, because it
    has a similar relationship to binary as base 1,000 has to base 10\. Because 16
    is a power of 2, just as 1,000 is a power of 10, there’s a one-to-one relationship
    between groups of columns in binary and columns in hex. This allows for fast,
    easy conversion between the two systems. Consider a binary number with its digits
    organized into groups of four: 0010,1111,0100,1101\. We can view this as'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制用于显示二进制，而不是其他系统，因为它与二进制的关系类似于1,000与10的关系。因为16是2的幂次，就像1,000是10的幂次一样，二进制中的列组和16进制中的列之间存在一一对应关系。这使得两者之间的转换非常快速和简便。考虑一个将二进制数字按四位一组排列的例子：0010,1111,0100,1101。我们可以将其视为
- en: 0010[2] × 2^(12) + 1111[2] × 2⁸ + 0100[2] × 2⁴ + 1101[2] × 2⁰
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 0010[2] × 2^(12) + 1111[2] × 2⁸ + 0100[2] × 2⁴ + 1101[2] × 2⁰
- en: 'which is the same as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下表达式相同：
- en: 2[10] × 16³ + 15[10] × 16² + 4[10] × 16¹ + 13[10] × 16⁰
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2[10] × 16³ + 15[10] × 16² + 4[10] × 16¹ + 13[10] × 16⁰
- en: 'Each of these powers of 16 has a number from 0 to 15 inclusive, so if we use
    the letters a[16] to f[16] to denote 10[10] to 15[10], then we can write the number
    in hex as 2f4d[16]. Every 4 bits in the binary number (a quantity sometimes called
    a *nybble*) corresponds to one hex digit: the 2 in hex corresponds exactly to
    the first 4 bits, 0010; the `f` to 1111; the 4 to 0100; and the d to 1101\. This
    four-to-one correspondence makes it easy to convert back and forth between hex
    and binary—much easier than, say, converting between decimal and binary.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个16的幂次都对应一个从0到15的数字，所以如果我们用字母a[16]到f[16]表示10[10]到15[10]，那么我们可以将数字写成16进制的2f4d[16]。二进制数中的每4个比特（有时称为*nybble*）对应一个16进制数字：16进制中的2正好对应二进制中的前4个比特，即0010；f对应1111；4对应0100；d对应1101。这种四比特对一位的对应关系使得16进制和二进制之间的转换变得容易——比起十进制和二进制之间的转换要简单得多。
- en: '**HEX EDITORS**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**16进制编辑器**'
- en: Hex editors (for example, in Vim, %!xxd, as shown in the following image) display
    the contents of files or memory in byte notation, sometimes together with other
    translations such as ASCII characters. They allow you to edit the corresponding
    binary data directly. This is useful for editing binary data and executable (compiled
    program) files on disk, or poking (overwriting programs and data) in the computer’s
    memory, such as programs currently running. These editors have many interesting
    security-related applications. For example, you might use one to try to find and
    circumvent parts of a proprietary program that check for verified purchases, or
    to overwrite your number of lives in a computer game to get 255 instead of 3.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制编辑器（例如，在Vim中使用%！xxd，如下图所示）以字节表示法显示文件或内存的内容，有时还会显示其他翻译内容，如ASCII字符。它们允许你直接编辑相应的二进制数据。这对于编辑磁盘上的二进制数据和可执行文件（已编译的程序文件），或在计算机内存中进行“修改”（覆盖程序和数据）非常有用，比如当前运行的程序。这些编辑器有许多与安全相关的有趣应用。例如，你可能会用它来尝试寻找并绕过某个专有程序中检查验证购买的部分，或者覆盖你在计算机游戏中的生命数，将其从3改为255。
- en: '![Image](../images/f0054-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0054-01.jpg)'
- en: Hex is a convenient tool for humans to think about binary numbers in a computer,
    but it’s important to recognize that hex isn’t a tool the computers themselves
    use. We don’t build physical computers using hex as a base; we build them using
    binary. Then we chunk the computers’ binary numbers into fours and translate them
    into hex to make them more human-friendly. After all, 16 is just a bit more than
    10, and so is the kind of number that humans can get used to thinking in, rather
    than binary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 16进制是人类用来理解计算机中二进制数字的方便工具，但重要的是要认识到，计算机本身并不使用16进制作为工具。我们并不是用16进制作为基数来构建物理计算机；我们是使用二进制来构建它们的。然后我们将计算机的二进制数字分成四位一组，并将它们转化为16进制，这样更适合人类理解。毕竟，16比10稍大，正是人类更容易习惯思考的数字，而不是二进制。
- en: Alternate notations used in some books and programming languages for hex include
    2F4D[16], 0x2f4d, 2F4Dh, &2F4D, and $2F4D.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些书籍和编程语言中用于表示16进制的替代符号包括2F4D[16]、0x2f4d、2F4Dh、&2F4D和$2F4D。
- en: '*Base 256: Bytes*'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基数256：字节*'
- en: Using the base 1,000 trick again, it’s common to see hex code grouped into *pairs*
    of hex digits, such as 2D 4F 13 A7\. Here, each pair can be viewed as a single
    symbol from an alphabet of 256 symbols, with each symbol representing 8 bits,
    known as a *byte*. Bytes were the main unit of computation in the 8-bit era. The
    nybble is so-called because it’s half a byte. Remember that a nybble is one hex
    digit; a byte is a pair of hex digits.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*How to Convert Between Bases*'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert from any base *b* representation to decimal, sum the decimal values
    of each of the base *b* columns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*x*[*n*]*b*^(*n*) + *x*[*n* – 1]*b*^(*n* – 1) + . . . + *x*[0]*b*⁰'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how to convert a number from base 19 to decimal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0055-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: To convert from decimal to base *b*, use repeated integer division by *b* with
    remainders. [Table 2-1](ch02.xhtml#ch02tab1) shows the steps of converting 186[10]
    to binary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Converting 186 to Base 2'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '| **Step** | **Result** | **Remainder** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| 186/2 | 93 | 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| 93/2 | 46 | 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 46/2 | 23 | 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 23/2 | 11 | 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 11/2 | 5 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 5/2 | 2 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| 2/2 | 1 | 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| 1/2 | 0 | 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: 'Here, the binary form of 186[10] is obtained by reading up the remainder column:
    10111010[2].'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages provide functions that automatically carry out common
    conversions, with names like `bin2hex` and `hex2dec`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Representing Data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have a basic representation for whole numbers, such as any of the
    base systems we’ve discussed, you can use it as a first building block to construct
    representations of other things: more complicated types of numbers, text, multimedia,
    and any general hierarchical data structure. Here we’ll see such representations,
    often using systems we’ve already defined as components of other higher-level
    systems. This can be as simple as using a pair of whole numbers to represent a
    fractional number or as complex as using billions of floating-point numbers grouped
    into spatiotemporal hierarchies to represent a multimedia stream of video, multilingual
    audio, and text subtitles, as found in your movie player.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '*Natural Numbers*'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *natural numbers* (traditionally denoted by the set symbol N) are the numbers
    0, 1, 2, 3, 4, and so on. They’re often used to represent numbers of *physical*
    things in the world, such as rocks or cows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Natural numbers can be represented in many ways, including tallies and Roman
    numerals. In computer architecture, the most obvious way is to use one of the
    base-exponent systems we’ve discussed. Some computers have used the decimal base
    (see the “Decimal Computers” box), while most modern machines use binary. For
    example, using light bulbs that can be either on or off, we can represent the
    binary columns of the number 74 (one 64, one 8, one 2), as in [Figure 2-8](ch02.xhtml#ch02fig8).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0056-01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: A representation of the number 74 in binary*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: There’s some subtlety to this, which will become important in more complex representations.
    First, you need to choose a convention for how to read the bulbs. In this case,
    we’ve chosen to put the highest power on the left, as with human-readable decimal
    numbers. We could equally have chosen the other way around, however, with the
    highest power on the right. Second, we’ve assumed in our example that eight bulbs
    are available and are being used. This means we can only represent the numbers
    0 through 255\. If we want to represent larger numbers, or even communicate the
    fact that we’ve run out of bulbs to represent a larger number, we’ll need a new
    plan.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIMAL COMPUTERS**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Decimal computers have a long history, spanning the mechanical and electronic
    ages. Here are some details of how they worked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Babbage’s Analytical Engine**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Like Babbage’s Difference Engine, his Analytical Engine uses a decimal representation,
    with gear wheels containing the digits 0 through 9\. A gear’s orientation represents
    a particular decimal digit, *d*, when that digit is oriented toward a fixed marker,
    as shown in the following figure. As in Pascal’s calculator (and unlike da Vinci’s),
    the gear never stops at continuous angles in between digits; it has only 10 discrete
    states.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0057-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: The gear is hollow, and there’s a shaft inside it. The gear and this shaft may
    connect via two tappets, one attached to each of their circumferences. These tappets
    are arranged so that if the shaft is rotated by a full circle, the tappets will
    connect for part of the circle, with the effect of rotating the gear by the value
    of its digit rather than the full circle. To read the represented number, you
    rotate the shaft by a full circle. For the first part of this rotation, the tappets
    aren’t in contact and the gear doesn’t move. For the second part of this rotation,
    the tappets come into contact and the rotating shaft makes the gear rotate along
    with it for *n*-tenths of a rotation, where *n* is the number represented. This
    rotation of the gear is what gives you access to the number. For example, if you
    first connect the gear to a second gear, it will have the effect of advancing
    that second gear’s digit by *n*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the data is lost from the first gear when it’s read, as the tappet
    always moves the gear into its zero position during the second part of the rotation.
    The act of reading the data is thus a *move* rather than a *copy*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Many gears can be stacked vertically to represent digits of larger decimal numbers.
    Likewise, many of these vertical stacks are arranged horizontally in the Analytical
    Engine to represent many numbers together.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Decimal Machines**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Less well known in history are decimal machines of the early electronic age.
    The first commercial computer, UNIVAC (1951), discussed in the previous chapter,
    was one of them. Its main console (see the following figure) is characterized
    by many groups of 10 lights, used for displaying various decimals.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0058-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: The IBM 650 in the following figure, dating from 1953, was notable for its use
    of a “bi-quinary” representation. Exactly as in the abacus, this involved a mixture
    of units and fives making up decimal columns.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0058-02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Binary isn’t the only way for digital systems, such as light bulbs, to represent
    natural numbers. Sometimes a one-of-*N* representation is more useful, as in [Figure
    2-9](ch02.xhtml#ch02fig9).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0059-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: A representation of the number 5 in a one-of*-N *system (the leftmost
    bulb represents 0)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assume that *N* bulbs are available and being used, and that exactly
    one of them will be on at any time. This can be wasteful, because we don’t use
    most of the possible states of the set of bulbs. But it can also be useful: for
    example, if we want to actually shine a light on some object in the real world,
    such as the fifth car in a row, we now have a single physical light bulb dedicated
    to that purpose. This will be very useful in computer architecture, as we very
    often want to switch on and off one of *N* physical circuits in a similar way.
    As with binary, we need to agree on a left-to-right or opposite convention, and
    there’s no way to indicate that we’ve run out of bulbs if a number is too large.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*Integers*'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *integers* (set symbol Z) are the numbers . . . , –3, 2, –1, 0, 1, 2, 3,
    and so on. They can be defined as pairing natural numbers with positive or negative
    signs (apart from zero, where +0 = –0). [Table 2-2](ch02.xhtml#ch02tab2) shows
    three different options for encoding them in binary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Three Possible Binary Encodings for Integers'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| **Integer** | **Signed** | **One’s complement** | **Two’s complement** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '|  3 | 011 | 011 | 011 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '|  2 | 010 | 010 | 010 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '|  1 | 001 | 001 | 001 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '|  0 | 000 and 100 | 000 and 111 | 000 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| –1 | 101 | 110 | 111 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| –2 | 110 | 101 | 110 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| –3 | 111 | 100 | 101 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| –4 | n/a | n/a | 100 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: A naive way to represent integers is to use binary codes for the natural numbers
    corresponding to their absolute values, together with an extra bit for their sign,
    as in the signed column of [Table 2-2](ch02.xhtml#ch02tab2) (the leftmost bit
    indicates the sign). It’s difficult to build machinery to correctly process these
    representations, however, as the sign has to be handled separately and used to
    select what should be done with the rest of the number. Having two different representations
    of the number 0 may also be a problem, requiring extra machinery to sort out.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Consider for a moment the alternative one’s complement representation of the
    same integers given in the table. (Few people actually use this, but it will help
    you understand the next one.) In this representation, the codes for the positive
    integers are the same as for natural numbers, but the codes for negatives are
    obtained by inverting all of the bits for their corresponding naturals. For example,
    to get the code for –2, we start with the code for +2, which is 010, and invert
    all the bits to get 101.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the two’s complement representation of integers in the table. This
    is formed by taking the one’s complement codes and adding 1 to them for negative
    numbers only. For example, –2 becomes 110, which is 101 + 1\. This may seem like
    a random thing to do, but as you’ll see later, the two’s complement approach turns
    out to be very useful. It simplifies the required arithmetic machinery, which
    is why today’s computers typically use it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*Rationals*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *rationals* (set symbol ℚ) are defined as, and may be represented by, pairs
    of integers *a*/*b*, with *b* ≠ 0\. Examples include 1/2, –3/4, 50/2, –150/2,
    and 0/2\. Many rationals are equivalent to one another, such as 4/2 and 2/1\.
    Detecting and simplifying equivalences requires dedicated computational work,
    and without this work rationals tend to expand to silly scales such as the representation
    1,000,000,000/2,000,000,000 representing the number 1/2.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing rationals is our first example of combining multiple existing
    representations: we need to use a pair of integers. For example, consider [Figure
    2-8](ch02.xhtml#ch02fig8), which we previously interpreted as a single natural
    number; this figure could instead be viewed as representing the rational 4/10
    = 2/5 by assuming that the first and second groups of four bulbs represent 4 and
    10.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s some subtlety in this: we need to agree that the first four of the
    eight bulbs are to represent the first integer, and the second four the second
    integer, plus we need to agree on conventions for the integers themselves (how
    to convey positive versus negative values), as discussed earlier. We will end
    up with multiple representations for many rationals, such as 4/10 and 2/5, which
    may initially confuse us if we want to ask whether two rationals are equal.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixed Point*'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fixed-point numbers*, such as 4.56, 136.78, and –14.23, are numbers with a
    limited number of digits before and after the point. In these examples there are
    always two digits after the point. Formally, fixed-point numbers are a subset
    of the rationals, as they can always be written as an integer divided by some
    power of 10\. They can be easily represented in computers as pairs of integers,
    corresponding to the two parts of the number before and after the decimal point,
    provided we agree on a convention for their ordering and size, as well as a convention
    for the integers themselves.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: For example, the bulbs in [Figure 2-8](ch02.xhtml#ch02fig8) could now represent
    the fixed-point binary number ![Image](../images/f0061-01.jpg) if we agree that
    the point is fixed after the fourth bulb. Note that these are exactly the same
    bulbs that we previously used to represent the rational 4/10 and the integer 74;
    to interpret data as a representation, we need to agree on which representation
    system is being used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating Point*'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Floating-point numbers*, such as 4.56 × 10^(34) and –1.23 × 10^(–2), are a
    computational version of the Suzhou place notation system seen previously in [Figure
    2-7](ch02.xhtml#ch02fig7), and are composed of a fixed-point mantissa (here, 4.56)
    and an integer exponent (here, 34). They are easily represented in computers by
    pairing together an integer representation and a fixed-point representation.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: To do this in practice, you need to choose specific representations for the
    fixed-point and integer parts, with specific bit lengths and a specific ordering
    for how to pack them together into a pair. It’s also useful to reserve a few bit
    strings for special codes, such as plus and minus infinity (which can be used
    to code results for 1/0 and –1/0) and “not a number” (*NaN*, used to code exceptions
    such as when trying to compute 0/0.0). *IEEE 754* is a commonly used standard
    for making these choices. It includes a set of bit orderings to best make use
    of 8, 16, 32, 64, 128, or 256 bits as floating-point representations. For example,
    IEEE 754’s 64-bit standard specifies that the first 53 bits should be used as
    the fixed-point mantissa in a signed encoding, with the first bit holding the
    sign; the remaining 11 bits should serve as a two’s complement integer exponent.
    Some bit patterns are reserved for infinities and NaNs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPUTABLE REALS**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Beyond floating points, computer science has its own concept of *computable
    real numbers*, sometimes written as 𝕋, which are different from—and better than—the
    *real numbers* used in mathematics, denoted with ℝ. Computable reals are all the
    numbers that can be defined by programs. In contrast, the much larger set of mathematicians’
    real numbers are useless as they can’t be individually defined or used in computation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a physical turtle robot controlled by a language like Scratch, moving
    left and right along a number line. The computable reals are all the locations
    on the number line that you can write a program for the turtle to stop at. Specifically,
    they’re all the numbers whose *n*th digit can be specified by some finitelength
    computer program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write a function `pi(n)` that takes an integer n as input
    and returns the *n*th digit of *π*. Likewise, we can add two computable reals,
    `a(n)` + `b(n)`, by forming a new program from the programs `a(n)` and `b(n)`.
    The new program will take `n` as an input and call `a()` and `b()` one or more
    times to generate the *n*th digit of the output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Computable reals have many fascinating and almost paradoxical properties, which
    have deep implications for both computer and human arithmetic. For example, it’s
    generally impossible (uncomputable) to know whether two computable reals are equal
    or different! The programs formed from performing just a few basic arithmetic
    operations on computable reals can quickly get quite large and unwieldy. It would
    be nice if we could optimize them by replacing them with shorter (or shortest)
    programs that give the same outputs, but it’s impossible to do this. There is
    a “countable” number of computable reals, which is the same “size” of infinity
    as the integers. This is different from the mathematicians’ reals, which have
    a larger “size” that’s “uncountable.”
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing defined the computable reals in his great paper “On Computable Numbers,”
    hence the letter 𝕋. They are his true genius contribution to computer science,
    rather than “inventing the computer” (the title of this paper is a clue that it’s
    about computable numbers, rather than about computers). Turing’s theory is still
    underappreciated. If it were more widely developed and used, we might one day
    get rid of the errors caused by floating-point approximations and be able to make
    perfectly accurate computations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrays*'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *one-dimensional array* is a sequence of *R* values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '{*a*[*r*]}[*r*=0:*R*–1]'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'A *two-dimensional array* is a collection of *R* × *C* values (standing for
    numbers of rows and columns), where:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '{*a*[*r,c*]}[*r*=0:*R*–1,*c*=0:*C*–1]'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'A *D-dimensional array* is a collection of values with *D* indices, such as
    the 3D *R* × *C* × *D* array with the following elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '{*t[r,c,d]*}[*r*=0:*R*–1,*c*=0:*C*–1,*d*=0:*D*–1]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The values in arrays may be numbers (of any of the types of numbers we’ve discussed)
    or other types of data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Often numerical arrays are used to represent vectors, matrices, and tensors.
    These are mathematical concepts that *extend* the data structure with specific,
    defined, mathematical operations. For example, a *vector* is a 1D array with specific
    rules for addition, multiplication by a scalar, and computing dot products and
    norms. A *matrix* is a 2D array with specific rules such as for multiplication
    and inversion. A *tensor* is an *N*-dimensional array with specific rules for
    covariant and contravariant coordinate transforms, in addition to multiplication
    and inversion. Vectors and matrices are special cases of tensors. (Many computer
    scientists use the term *tensor* incorrectly to refer only to the *N*-dimensional
    data structure, forgetting the other mathematical requirements of true tensors.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic data representation for all types of arrays is to “pack” them into
    a series of individual numbers in contiguous areas of computer memory. For example,
    [Figure 2-8](ch02.xhtml#ch02fig8) might represent the 1D array of integers [1,0,2,2]
    if we agree on a convention that each integer is represented by two bulbs. Similarly,
    it might represent this 2D array of integers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0063-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'In this case we’re considering each of the 2D array’s rows as a 1D array, [1,0]
    and [2,2]. We encode each 1D array using two bulbs per integer and store the series
    of encodings for the rows in order. By extension, for a general *N*-dimension
    array, we may do the same: split it into a series of (*N* – 1)-dimension arrays,
    encode each of them, and store the series of encodings in order.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data representation and computation architectures for vectors, matrices,
    and tensors has become a major driver of the tech industry. GPUs were first built
    to perform fast 3D vector-matrix operations for realtime 3D games, and have more
    recently been generalized for fast tensor computations, which have found important
    applications in neural network acceleration. Google’s tensor processing units
    (TPUs) are designed specifically for this task.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*Text*'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s talk about text. Once you have a finite, discrete alphabet of symbols,
    such as the characters we use to write human-readable text, you can assign a natural
    number to represent each one. You can then use a bunch of natural numbers in an
    array to represent *strings* of text. This idea has evolved from the long-standard-but-now-outdated
    ASCII to modern Unicode.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**A HISTORY OF TEXT**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbers aren’t very useful by themselves: we need to know *what* is being counted.
    Sumerian trading tokens were “typed”—three cow tokens to represent three cows.
    But when we moved from tokens to more abstract numerals, we lost the information
    about what the numbers were supposed to represent. The numbers needed to be accompanied
    by extra symbols describing the type, as in “3 cows.” Writing thus emerged from
    the same trading tokens as numbers, but it forked to become pictograms and then
    text.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The first writing appeared in Sumeria around 4000 BCE. It used pictures of objects
    (pictograms) to represent them. Pictograms appeared in many cultures, then gradually
    transformed into phonetic symbols. The phonetic and semantic uses may coexist
    for a while—as in modern Chinese—but the phonetic use usually becomes dominant.
    Text symbols also evolved over time to become simplified and easier to write,
    losing the original pictorial similarities to their objects. Where writing was
    carved on stone, the symbols evolved to be made from straight lines that are easier
    to carve. The most common symbols evolved fastest into quick-to-write shapes.
    They thus became the handiest to use in phonetic transcriptions, so the phonetic
    letters that survived the transition from pictures to sounds tended to come from
    the most common words.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Text isn’t always written from left to right. Arabic and Hebrew go right to
    left, and many East Asian languages can be written from top to bottom.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Morse code was developed around the great computing year, 1836, to enable operators
    of the Victorian internet—the telegraph—to communicate quickly. Samuel Morse studied
    the frequency of letter usage in English to give the common ones the shortest
    representations. Morse is *almost* a binary code, as it uses sequences of two
    symbols to represent letters, but they’re usually used together with a third symbol,
    empty space, to show breaks between words.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Braille was also developed around 1836 by Louis Braille. It’s a true binary
    code, with each letter represented by binary states of a 2×3 grid. It was originally
    developed for secret use by soldiers but became popular for its present-day use
    by blind readers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII**'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *American Standard Code for Information Interchange (ASCII)*, shown in [Figure
    2-10](ch02.xhtml#ch02fig10), represents each character as a unique 7-bit code,
    meaning it can represent 128 characters in total. This allows for uppercase and
    lowercase letters, digits, symbols, and punctuation, as well as historical *controls*
    such as delete, carriage return, line feed, and ring a bell.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'In old email systems, ASCII control codes would sometimes be transmitted and
    displayed as part of the email message rather than actually being executed. The
    backspace control code was particularly prone to this effect, so you would get
    emails such as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The team has identified several fuckups^H^H^H^H^H^H^Hchallenges in the plan.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Today, old-timers sometimes type out similar “backspace fails” on purpose for
    humor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Some operating systems use different conventions to represent the ends of lines,
    involving line feeds (code 10) and carriage returns (code 13) in text files, which
    may need to be fixed if you move text files between systems. In the days of typewriters
    and then teletype machines, these were two different physical controls, one to
    advance the paper in the machine by a row, and the other to return the print head
    carriage back to the left side of the paper.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: ASCII code 0 is commonly used to represent the end of a string. If a string
    is laid out in memory, programs need a way to work their way through it one character
    at a time. The convention is that when they reach a zero, they know to stop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As a 1960s American standard, ASCII is a product of a time before globalization
    and the internet, and it has come to show its age. It can only represent characters
    from the Latin alphabet, so it can’t directly represent characters needed by languages
    other than English. Many European languages require multiple versions of Latin
    characters containing accents, for example, while languages such as Chinese and
    Arabic use completely different alphabets.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: However, in one of the most foresighted design decisions ever made in computing,
    coupled with coincidence, the designers of ASCII were aware of this potential
    future issue and planned for it. The coincidence was that the machines of the
    time used groups of 8 bits, while the size of the set of characters needed for
    English was just under 7 bits. The design decision was to thus use 8-bit representations
    for ASCII characters but to always make the first bit a 0\. In the future, if
    additional characters were needed, this first bit could be used for other purposes.
    This has now happened, giving rise to the modern Unicode Standard.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0065-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: The ASCII character representations*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII AS BASE 256**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’ve written a program in your favorite language, such as the following
    in BASIC:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then suppose you encode the characters of this program as ASCII characters
    and save them in a text file. Each one of these characters is a byte. If you open
    your program in a hex editor rather than a normal text editor, you’ll see your
    program represented as a list of byte codes, such as:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Think about the compound notation concept we’ve previously used in base 1,000,
    sexagesimal, and byte codes themselves, and apply it to this whole list of byte
    codes. Consider each byte code as a base 256 digit, and form the *entire program*
    into a single very large number, such as:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 31[256] × 256^(27) + 30[256] × 256^(26) + 20[256] × 256^(25) + 50[256] × 256^(24)
    . . . + 30[256] × 256⁰
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'This calculation would give a single astronomically sized integer. This means
    we have a mapping between programs and integers: we can represent any program
    with a single integer. When you write a program, you’re just choosing which integer
    to apply. This view can be used in computational theory, because it allows math
    about numbers to talk about programs.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What we collectively know as *Unicode* actually refers to three different but
    related standards defined in 1991: UTF-8, UTF-16, and UTF-32\. *UTF-8* extends
    ASCII by making use of the previously unused eighth bit. If it’s a 1, then a second
    byte follows to enlarge the space of symbols. If the second byte starts with a
    1, then a third byte follows as well. If the third byte starts with a 1, then
    a final, fourth byte is also used. UTF-8 thus allows for more than one million
    different characters. Its standard doesn’t use all of them, but it includes mappings
    to symbols needed for all major world languages. So many character encodings are
    available that international communities have been able to add to the standard,
    including symbols for less widely spoken languages, ancient languages such as
    Cuneiform, fictional languages such as Klingon, other symbols such as from mathematics
    and music, and a large number of emoji (see [Figure 2-11](ch02.xhtml#ch02fig11)).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0067-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: Unicode Thai, math, emoji, and Cuneiform sectors*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency, the most widely used languages are given the symbols that require
    only 2 bytes, with the rarer ones requiring 3 bytes and the comedy ones requiring
    4 bytes. There are sometimes lively debates about which of these sectors a newly
    proposed character set should be assigned to. The next time you send a text with
    just the right emojum to express your feelings, you can thank the ASCII designers
    for their foresight.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-32* is a fixed-width encoding that uses all four available bytes in *every*
    character. From a storage standpoint, this is obviously inefficient, but for some
    applications it may speed up the process of looking up symbols. For example, if
    you want to read the 123rd symbol, then you can find it right away in bytes 123×4
    to 123×5.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-16* is like UTF-8, but at least 2 bytes are always used, even for ASCII
    characters. This covers a large set of symbols in common use around the world,
    so it can often act as if it were a fixed-width coding, to enable fast look-ups
    as in UTF-32\. It’s a compromise encoding.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Converting files between the different UTF formats is a modern version of the
    pain we used to have with carriage returns and line feeds in ASCII. Especially
    with CSV spreadsheet files, using the wrong UTF import can make good files look
    like garbage.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*Multimedia Data Representation*'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data representation gets more fun as we move to images, video, and audio to
    bring our computers to life. These representations are all built on the arrays
    of numbers we’ve previously constructed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Image Data**'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grayscale images can be represented by 2D arrays of numbers, with each element
    representing a pixel, and its value representing the shade of gray. The type of
    integer representation within this array affects the quality of the image: if
    1-bit integers are used, then each pixel can only be black (0) or white (1), whereas
    if 8-bit integers are used, then 256 shades of gray are available between black
    (0) and white (255).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Human eyes are receptive to three main frequencies of light: red, green, and
    blue. This means the experience of seeing an image in color can be reproduced
    by shining lights at each of these frequencies from each pixel. To represent a
    color image, we can therefore take three grayscale image representations; use
    them to represent the red, green, and blue channels of the image; and somehow
    store them together. Different systems may use different approaches to this storage.
    For example, we might store the complete red image first, then the green after
    it, then the blue. But some computations may run faster if we *interleave* the
    channels, with the red, green, and blue values for the top-left pixel stored first,
    one after the other, then the red, green, and blue values for the pixel next to
    it, and so on.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: For some applications, it’s useful to add a fourth channel, called *alpha*,
    to represent the transparency of each pixel. This representation is known as RGBA.
    For example, in sprite-based games this tells the graphics code how to mask each
    sprite, leaving the background intact behind its shape. Non-binary alphas can
    also be used to blend images together by making them partially transparent to
    various degrees. Including an alpha channel is especially convenient because having
    four channels makes a power of two, which plays nicely with binary architectures.
    For example, it is common to use 32-bit colors with four 8-bit channels, rather
    than 24-bit colors with three 8-bit channels, on a 32-bit machine. Of course,
    this requires more storage, so pixel values might be stored as 24 bits and converted
    to 32 bits when loaded into memory. (Since 24-bit RGB is usually considered the
    maximum color depth that humans can distinguish, there’s little point in going
    to 64-bit color, even on 64-bit machines.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Video can be represented (most basically) as a sequence of still images packed
    in temporal sequence.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Data**'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Continuous sound waves can be represented as a series of discrete samples. The
    samples need to be taken at a rate of double the highest frequency present in
    the signal. Human hearing ranges from around 20 to 20,000 Hz, so common audio
    sample rates are around 40,000 Hz. Each sample is a number, and as with color
    depth, the choice of the number of bits to devote to each sample affects the sound
    quality. Consumer media such as Blu-ray uses a depth of 24 bits, around the maximum
    distinguishable to humans, while 32 bits may be used internally and by audio producers,
    as it’s a power of two and gives more robustness to editing manipulations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Stereo or multichannel audio can be thought of as a collection of sound waves
    meant to be played together. These might be stored as one whole wave at a time
    in memory, or interleaved over time, with one sample from each channel stored
    contiguously for each sample time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Almost all sound representations use either integer or fixed-point representations
    for the individual samples. A consequence of this is that there are clear minimum
    and maximum values that samples can take. If the signal goes out of this “headroom”
    range it will *clip*, losing information and sounding distorted. Musicians and
    voice actors often curse these data representations if they have just performed
    a perfect take but it got clipped and they have to do it again. A recent trend
    in professional audio systems is a move to all floating-point representations,
    which are much more computationally intensive but free the artists from the clipping
    problem.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with *multi*media, such as movies that include video and audio
    together, the interleaving representation concept is often extended so that data
    from each medium for a point in time is coded together in a contiguous area of
    memory—for example, all the data for one video frame, plus an audio segment for
    the duration of that frame. The interleaving schemes are known as *containers*.
    *Ogg* and *MP4* are two well-known container data representations used for movies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Compression**'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simple media representations for images, video, and audio that we’ve just
    discussed are good during computation, but they aren’t usually ideal in terms
    of storage. For efficiency, we often look for ways to *compress* the data without
    changing the human experience of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The natural world tends to contain a lot of redundancy—that is, it has regions
    of space and time that are composed of similar stuff. For example, in a video
    of a thrown red ball, if you see one red pixel belonging to the ball, then it’s
    very likely that the pixels around it are also red, and that this pixel or nearby
    pixels will be red in the next frame as well. Also, the human senses have particular
    focuses and blind spots, for example being sensitive to the amplitude but not
    the phase of audio frequencies, and not hearing some frequencies in the background
    when others are present.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Information theory explains how to compress media data by exploiting and removing
    these redundancies and perceptual blind spots. This way, a smaller number of bits
    can be used in a more complex way to represent the same or perceptually similar
    media data. This is useful both to reduce physical storage needs, such as the
    size of a Blu-ray disc, and also to reduce network use when streaming media. However,
    it comes at a cost of additional computation: we usually need to convert the compressed
    representations back to the raw ones, which can be quite complex, depending on
    the compression scheme used. Most schemes rely on mathematical operations like
    Fourier transforms to find spatial or temporal frequencies. These can be costly
    for conventional CPUs to compute and have been a major driver of specialized signal
    processing architectures to accelerate them. Implementations of compression algorithms
    are known as *codecs*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*Data Structures*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any data structure, such as the structs and objects found in most programming
    languages, can be represented through *serialization*, whereby the data is transformed
    into a *series* of bits to store in memory. Serialization can be performed hierarchically:
    if a complex structure is composed of several smaller structures, we serialize
    it by first serializing each of these components, then joining their representations
    together in series to make the total representation. If the component structures
    are themselves complex, the process becomes recursive, but eventually we always
    reach a level of simple elements such as numbers or text, and we’ve already discussed
    how to represent these as a series of bits (that is, serialize them).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, say we have the following data structure:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will be serialized as a bit sequence beginning with the encoding for integer
    `age`, followed by the encoding for integer `legs`, and then perhaps a Unicode
    sequence for the string `name`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Now say a `Cat` object is included in another structure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Game` object will be serialized with its first bits being the encoding
    of the `Cat` object (itself a serialization of various components), followed by
    the encodings of the `lives` and `score` integers. We can continue to build higher
    and higher levels of structure in this way, which is how real-world large-scale
    programs work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Data
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic unit of data is the *bit (b)*, which can take one of two possible
    states, usually written as 0 and 1\. When studying data, we’ll often be working
    with very large numbers of bits, however, so we need notations and visualizations
    to handle these.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*SI (Système Internationale)* is an international organization of scientists
    and engineers that sets generally accepted standards for scientific measurement
    units. This includes defining standard prefixes for powers of 1,000, as shown
    in [Table 2-3](ch02.xhtml#ch02tab3).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Large SI Prefixes'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Symbol** | **Value** |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| kilo | k | 10³ =1,000 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| mega | M | 10⁶ = 1,000,000 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| giga | G | 10⁹ = 1,000,000,000 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| tera | T | 10^(12) = 1,000,000,000,000 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| peta | P | 10^(15) = 1,000,000,000,000,000 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| exa | E | 10^(18) = 1,000,000,000,000,000,000 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| zetta | Z | 10^(21) = 1,000,000,000,000,000,000,000 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: To visualize the large scales represented by SI prefixes, it can be useful to
    imagine 3D cubes, based on a cubic meter. Perhaps the reason we give special names
    and prefixes to powers of 1,000 is that 1,000 is three scalings of 10, which in
    3D means scaling an object by 10 in all three of its dimensions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Using SI prefixes with bits should be the preferred standard for describing
    quantities of data, according to SI—for example, 5 megabits means 5,000 bits.
    In fact, network speeds are often measured in megabits per second. However, at
    the architectural level we more commonly need to work with numbers that are exact
    powers of 2, not 10\. For example, a 10-bit address space provides 2^(10) = 1,024
    addresses, while a 16-bit address space provides 2^(16) = 65,536 addresses. Before
    architects adopted the SI standards—during the 8-bit era, for example—it was common
    for architects to abuse the prefix “kilo” to refer to 1,024 instead of 1,000.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: This naturally led to much confusion. Data sizes have gotten larger, and most
    computer people operate at a higher level, where working in proper SI units makes
    more sense. As a compromise, in 1998 the International Electrotechnical Commission
    defined an alternate set of prefixes to distinguish the powers of two from the
    SI prefixes. These have the morpheme *bi* in them, from the word *binary*. For
    example, 2^(10) has become kibi, 2^(20) has become mebi, and so on, as in [Table
    2-4](ch02.xhtml#ch02tab4).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** Large Binary Prefixes'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Symbols** | **Value** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| kibi | k[2], ki | 2^(10) = 1,024 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| mebi | M[2], Mi | 2^(20) = 1,048,576 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| gibi | G[2], Gi | 2^(30) = 1,073,741,824 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| tebi | T[2], Ti | 2^(40) = 1,099,511,627,776 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| pebi | P[2], Pi | 2^(50) = 1,125,899,906,842,624 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| exbi | E[2], Ei | 2^(60) = 1,152,921,504,606,846,976 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| zebi | Z[2], Zi | 2^(70) = 1,180,591,620,717,411,303,424 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: Binary prefixes are slightly larger than their SI counterparts. Not everyone
    is using them yet, and many older people and machines still use SI names to refer
    to binary units. Unscrupulous hardware manufacturers often exploit this ambiguity
    by picking whichever interpretation of the SI names will give them the best-looking
    numbers on their products.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers usually need to represent various types of numbers, text, and media
    data. It’s convenient for modern machines to do this using binary. Hex representations
    chunk binary together to appear more readable to humans. Different representations
    make different computations easier to perform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Once we have methods for representing data, we can begin to build up methods
    for computing with the data. In the next chapter, we’ll preview a simple but complete
    computer that does this. We’ll then build up a more detailed modern electronic
    computer to do similar.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Base System Conversions**'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Convert your phone number to binary.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert your phone number to hex. Making use of the binary from before might
    be helpful. Convert it again to byte codes, and convert the bytes to ASCII characters.
    What do they spell out?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Negate your phone number and convert this negative number to its two’s complement.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a decimal point halfway through your phone number to make a floating-point
    number. Write it in IEEE 754 standard binary.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text and Media**'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Find out how to type in Unicode on your computer. On many Linuxes, for example,
    you can press and release SHIFT-CTRL-U, then type a series of hex numbers such
    as 131bc to enter an ancient Egyptian digit at your command line or in your editor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring Data**'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Obtain street, aerial, and satellite photos of an area you know, and draw a
    kilocube, megacube, gigacube, teracube, petacube, exacube, and zettacube on them,
    where, for example, each side of a kilocube is 10 m long.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**More Challenging**'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use a hex editor and the internet to reverse engineer and modify some of your
    favorite media files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For discussions and psychological models of numerosity, see Stanislas Dehaene,
    *The Number Sense* (Oxford: Oxford University Press, 2011), and the “Numbo” chapter
    in Douglas R. Hofstadter, *Fluid Concepts and Creative Analogies* (New York: Basic
    Books, 1995).'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an advanced but classic paper full of details on floating points, see D.
    Goldberg, “What Every Programmer Should Know About Floating Point Arithmetic,”
    *ACM Computing Surveys (CSUR)* 23, no. 1 (1991): 5–48.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an extremely advanced but blindingly beautiful book on Turing reals, see
    Oliver Aberth, *Computable Calculus* (San Diego: Academic Press, 2001).'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
