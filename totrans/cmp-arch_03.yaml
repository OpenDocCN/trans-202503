- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DATA REPRESENTATION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0045-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A computer is a device that represents things in the real world and performs
    manipulations on these representations. Entities that we might want to represent
    and make computations about include physical objects, numbers, words, sounds,
    and pictures. This chapter examines systems for representing each of these types
    of entities.
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôll begin by exploring the history of how representations of objects, numbers,
    and text have evolved. We‚Äôll then look at the modern symbol systems used to represent
    numbers‚Äîincluding decimal, binary, and hex‚Äîand use number representations to construct
    representations of further entities, such as text, audio, and video.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the modern representations are built from 0s and 1s, which
    are left as symbols themselves. In later chapters, we‚Äôll consider how to instantiate
    these zero and one symbols in digital electronics and make use of them in computations.
  prefs: []
  type: TYPE_NORMAL
- en: A Brief History of Data Representations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concepts of representation and computation are closely linked. Humans often
    need to represent the state of part of their world, as an aid to their own memories
    or as proof to other humans that something has happened or is going to happen.
    Once you have a representation, you can also use it to perform computations, to
    simulate what would happen if certain actions were done, or to deduce conclusions
    from what is known.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we often need to keep track of who owns what and who has debts
    to be paid. Static representations are useful for these purposes, and once these
    exist we can use them in computations to answer questions such as what would happen
    if we bought something, or how long it will take to repay a debt. Representation
    thus comes before computation, both conceptually and historically. Let‚Äôs trace
    how it evolved, from humanity‚Äôs first efforts to the symbol systems that we use
    today.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tally Sticks and Trading Tokens*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The oldest-known data representation is the use of *tally sticks*, such as the
    Lebombo bone shown in [Chapter 1](ch01.xhtml). These are simple sticks with several
    marks, where each mark represents one object. For example, the number 13 is represented
    by 13 marks, usually made in a row, as in [Figure 2-1](ch02.xhtml#ch02fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0046-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: A simple tally*'
  prefs: []
  type: TYPE_NORMAL
- en: By Sumerian times (4000 BCE), physical tokens were used to represent objects,
    as in [Figure 2-2](ch02.xhtml#ch02fig2). A small clay model of an animal, for
    example, represented the actual animal and could probably have been exchanged
    for it. This would have simplified trading, as you could travel from the city
    of Ur to the city of Uruk with 10 animal tokens and make a deal by swapping them
    for, say, 20 beer tokens, with the actual objects only being moved around later,
    after a successful deal. These tokens could also have been divided between groups
    of people or given as tax to the king.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0046-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Sumerian trading tokens*'
  prefs: []
  type: TYPE_NORMAL
- en: Computing with tally sticks and tokens is, however, quite slow. To add *m* tallies
    or tokens to *n*, you have to go through the process of adding each of the *m*
    into the *n*, one at a time. If you‚Äôve studied complexity theory, this means that
    addition is order O(*m*) in the size of the numbers being added.
  prefs: []
  type: TYPE_NORMAL
- en: By 3000 BCE‚Äîstill before the abacus‚Äîthe Sumerians sped up their calculations
    by sealing many tokens in a clay ‚Äúenvelope‚Äù called a *bulla*, shown in [Figure
    2-3](ch02.xhtml#ch02fig3). The bulla was sealed both physically, by joining its
    clay to encapsulate the contents, and informationally, by stamping a complex,
    unforgeable mark onto it. (This is the origin of ceremonial seals still used today
    on royal and governmental documents, such as the Great Seal of the USA. It‚Äôs also
    the origin of later digital signatures.) The seal guaranteed, probably in the
    name of the king or another powerful and trustworthy person, that a certain number
    of tokens were contained within it. This way, instead of counting out 12 animal
    tokens, you could hand over a bulla of 12 animals at a time. The bulla would function
    like a 12-token coin or banknote, but one that physically contained the 12 tokens
    inside.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0047-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: A bulla*'
  prefs: []
  type: TYPE_NORMAL
- en: A similar development to the bulla is found in tally sticks from this period,
    where tally marks started to be grouped together, as shown in [Figure 2-4](ch02.xhtml#ch02fig4).
    Counting out *n* scratches usually requires *n* operations, but if we replace,
    say, every fifth vertical stroke with a diagonal one going through the previous
    four, we can quickly count how many groups of five we have.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0047-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: A grouped tally*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Roman Numerals*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a closely related notation to grouped tallies, we can replace the fifth stroke
    with two shorter diagonal strokes to make a V, and the tenth with an X, as in
    [Figure 2-5](ch02.xhtml#ch02fig5), forming the beginnings of the *Roman numerals*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0047-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Early Roman numerals*'
  prefs: []
  type: TYPE_NORMAL
- en: Roman numerals developed further to closely represent the human perception of
    numbers. Humans appear to perceive the sizes of sets of 1, 2, 3, and 4 objects
    directly and immediately. Beyond this, our immediate perception is of *numerosity*
    or approximate size rather than exact number, based on sizes roughly around 5,
    10, 20, 50, 100, and 1,000\. Most number symbol alphabets reflect this, with Egyptian,
    Chinese, and Arabic numbers having special symbols for 1, 2, 3, and 4 that feature
    the corresponding number of strokes, and more abstract symbols for 5 and above.
    The Roman numeral system also uses symbols to represent the ‚Äúlandmark‚Äù numbers,
    such as V = 5, X = 10, L = 50, C = 100, and M = 1,000, with smaller-valued symbols
    positioned before or after to indicate adjustments to the landmark, such as VI
    = 6 and IX = 9.
  prefs: []
  type: TYPE_NORMAL
- en: Roman numerals have the advantage of being a close model of how humans actually
    think about numbers, but if you try to do large-scale arithmetic such as adding
    and multiplying with them, you‚Äôll quickly run into difficulty. This is a classic
    example of how the choice of representation can heavily affect your ability to
    do certain types of computation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Split Tallies*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *split tally* was a variation of the tally stick, in which the stick was marked
    up, then split into two pieces down its length, as in [Figure 2-6](ch02.xhtml#ch02fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0048-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: A split tally*'
  prefs: []
  type: TYPE_NORMAL
- en: Both halves contain parts of the same notches, and both halves could be reunited
    to show they were genuine and fitted together. They were used to record loans,
    with the long and short halves (the *stock* and *foil*) given to the lender and
    borrower, the origin of our modern financial *long* and *short* positions in stocks.
    The British government continued to use split tally sticks until it burned its
    last wooden tallies to modernize its IT systems around 1836, the time of Babbage‚Äôs
    Analytical Engine.
  prefs: []
  type: TYPE_NORMAL
- en: '*Arabic and Other Numerals*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other civilizations developed number representations using copies of symbols
    for large numbers, as shown in [Figure 2-7](ch02.xhtml#ch02fig7).
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ancient Egyptians had symbols for 10, 100, 1,000, and 10,000\.
    The number 23 would be shown using two copies of the 10 symbol (a heel) and three
    copies of the 1 symbol (a tally stroke). The number 354,000 would be shown using
    three copies of the 100,000 symbol (a tadpole), five copies of the 10,000 symbol
    (a finger), and four copies of the 1,000 symbol (a lotus flower).
  prefs: []
  type: TYPE_NORMAL
- en: Eastern Arabic numbers appeared in the Islamic Golden Age, based on an earlier
    Indian system from around 500 CE. This system introduced the base-exponent method
    that we use today, with fixed columns containing symbols for numbers of 1s, 10s,
    100s, 1,000s, and so on. Importantly, this introduced the need for a concept and
    symbol of zero to fill in columns having no counts, which is missing from ancient
    Egyptian and similar systems. These symbols evolved into the Arabic numerals (1,
    2, 3, and so on) used in the West today.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0049-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Modern Arabic, Ancient Egyptian, Suzhou Chinese, and Eastern Arabic
    numerals*'
  prefs: []
  type: TYPE_NORMAL
- en: Suzhou Chinese numerals evolved from ancient Chinese symbols relating to the
    base 10 abacus seen previously in [Figure 1-4](ch01.xhtml#ch01fig4), and are occasionally
    still in use today. You can see the symbols for 1 to 4 are based on tally strokes,
    while those from 5 to 9 are similar symbols placed under a ‚Äúbead‚Äù for 5\. For
    a few significant digits, Suzhou uses a column system similar to Arabic numerals.
    For larger numbers, however, it uses a more advanced representation that shows
    the first few significant digits, followed by a separate symbol denoting what
    power of 10 they are multiplied by. In English we sometimes do this by writing
    *354 thousand* or *354k* rather than *354,000*.
  prefs: []
  type: TYPE_NORMAL
- en: This history of number *representation* belongs more properly to computer science
    than to mathematics. We can see that, historically, *typed* quantities such as
    ‚Äúfive cows plus three cows‚Äù were represented and computed with before more abstract
    mathematical number concepts such as ‚Äúfive plus three.‚Äù Mathematics takes numbers
    for granted and performs proofs about their properties. By contrast, the business
    of representation, both of actual objects and of abstract number concepts derived
    from them, is computer science, as is the question of how to build algorithms
    and machines based on these representations.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Number Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We‚Äôve seen how our modern concept of numbers evolved from tallies into the symbolic,
    Arabic system used in everyday life today. The key innovation of the Arabic system
    is the use of columns to represent digits in a base. This (as we‚Äôll see when we
    start computing) makes algorithmic arithmetic easier, and also reduces the size
    of representations. For example, you only need four symbols to represent the number
    2,021, rather than 2,021 clay tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Our everyday Arabic numbers are decimal, using base 10, but this isn‚Äôt necessarily
    the base for computers. This section generalizes the idea of bases and exponents
    and presents several related systems that are useful in computers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bases and Exponents*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will make heavy use of exponentiation in representing numbers. *Exponentiation*
    is the repeated multiplication of a *base*, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 2¬≥ = 2 √ó 2 √ó 2
  prefs: []
  type: TYPE_NORMAL
- en: Here, 2 is the base and 3 is the exponent. This may also be written as 2^3\.
    In some computer languages, it appears as `2**3`, or is written via a power function,
    such as `pow(2,3)`. Exponentiation is sometimes called ‚Äúraising to the power,‚Äù
    as in ‚Äútwo to the power of three.‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: More generally, we write a base *b* to the power of an exponent *n* as
  prefs: []
  type: TYPE_NORMAL
- en: '*b^n* = *b* √ó *b* √ó *b* √ó . . . √ó *b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'meaning there are *n* copies of *b*. Zero and negative exponentiation are defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we choose a base *b*, we may then define a *number system* as a mapping from
    a list of *numeral symbols* to a *number*. Symbols are marks on a piece of paper
    or entries in some other type of storage system; numbers are the actual mathematical
    objects being represented.
  prefs: []
  type: TYPE_NORMAL
- en: To write base *b* numbers, we need an alphabet containing *b* symbols. Strings
    of *N* of these symbols can have *b^N* different states, which are used to represent
    numbers from 0 to *b^N* ‚Äì 1.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with symbols in different bases, we will sometimes use a subscript
    to indicate what base the symbols are written in. For example, 123[10] means one
    hundred and twenty-three in base 10, while 1001[2] means one 8, no 4s, no 2s,
    and one 1 in base 2 (which equals 9[10]). In other cases, we‚Äôll omit the subscript
    where the base is clear from the context.
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 10: Decimal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Everyday arithmetic uses base 10, in which, for example, the string of symbols
    7, 4, 3, written as 743, is interpreted as representing the number seven hundred
    and forty-three. We can see this mathematically using exponents of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 743 = 7 √ó 10¬≤ + 4 √ó 10¬π + 3 √ó 10‚Å∞
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a point notation and negative exponents, we can represent fractional
    numbers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 743.29 = 7 √ó 10¬≤ + 4 √ó 10¬π + 3 √ó 10‚Å∞ + 2 √ó 10^(‚Äì1) + 9 √ó 10^(‚Äì2)
  prefs: []
  type: TYPE_NORMAL
- en: 'For base 10 we have an alphabet of 10 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, and
    9\. Strings of *n* symbols from this alphabet can specify one of 10^(*n*) numbers;
    for example, with *n* = 4, there are 10,000 numbers, 0 to 9,999 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 2: Binary*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Base 2 is known as *binary* and is used in almost all modern computers. It has
    an alphabet of two symbols, usually written as 0 and 1, but sometimes as T and
    F for *true* and *false*. In electronic computers, the two symbols are represented
    using high and low voltages. *High* is usually the system‚Äôs positive voltage,
    such as 5 V or 3.3 V, while *low* is usually ground or 0 V. Binary is useful for
    electrical machines because real voltages are noisy, and attempts to include extra
    symbols such as *medium* have been doomed to failure. But *high* and *low* can
    more easily and cheaply be separated into two clear classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single symbol in base 2 is called a *bit*, short for *bi*nary dig*it*. A
    string of *N* bits can represent one of 2^(*N*) numbers, such as ranging from
    0 to 2^(*N*) ‚Äì 1\. The columns of the string represent powers of 2\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0051-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The powers of two that appear in this calculation (0, 1, 2, 4, 8, 16, 32, 64,
    128, 256, 512, 1,024, 2,048, and so on) should be instantly recognizable to anyone
    used to computing. They often appear as sizes of memory capacity and as sizes
    in bits or bytes of data structures used at the hardware level. If you plan to
    work at or near the hardware level, you‚Äôll need to memorize these powers of two
    for everyday use.
  prefs: []
  type: TYPE_NORMAL
- en: To convert from binary to decimal, add up the powers of two for each column
    that has a 1 in it. To convert from decimal to binary, at each step, try to subtract
    the highest power of two from the decimal, and make a note of which powers of
    two have been subtracted. Write 1s in those columns and 0s in the others.
  prefs: []
  type: TYPE_NORMAL
- en: Some mathematical operations are faster or slower in different bases. In base
    10, you can quickly multiply or divide by 10 by shifting the decimal (radix) point
    one place to the left or right. Where numbers are represented in binary, you can
    use a similar trick to quickly multiply or divide by 2\. This is known as *binary
    shift* and is implemented in hardware by most CPUs. In the C language, for example,
    a fast multiplication by 8 (2¬≥) can be done by writing `y=x>>3;`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate notations used in some books and programming languages for binary
    include 1110[2], 0b1110, and 1110b.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A famous computer science joke says, ‚ÄúThere are 10 kinds of computer scientists:
    those who know nothing, and those who know binary.‚Äù*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 1,000*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a means of introducing other notations‚Äîhex and byte codes‚Äîlet‚Äôs look at decimal
    notation in a different way, which we‚Äôll call *compound notation*. It‚Äôs common
    to write large numbers by grouping them into chunks of three digits separated
    by commas, to make them easier to read. For example, the number 123,374,743,125
    symbolizes the value one hundred and twenty-three *billion*, three hundred and
    seventy-four *million*, seven hundred and forty-three *thousand*, one hundred
    and twenty-five. (The ‚Äúone hundred and twenty-five‚Äù at the end refers to the number
    of *ones*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine for a moment that these chunks are individual symbols, from an alphabet
    containing 1,000 symbols from 0 to 999\. Don‚Äôt think of 999 as three 9s, but as
    a single symbol. Under this view, we can consider the comma-separated string as
    a string of 4 symbols in base 1,000, rather than 12 symbols in base 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 123,374,743,125 = 123 √ó 1,000¬≥ + 374 √ó 1,000¬≤ + 743 √ó 1,000¬π + 125 √ó 1,000‚Å∞
  prefs: []
  type: TYPE_NORMAL
- en: 'This reflects our spoken language more accurately than thinking in base 10:
    we have names for powers of 1,000 (thousand, million, billion, trillion), but
    we don‚Äôt have names for 10,000 or 100,000 or 10,000,000\. Scientific units also
    follow this base 1,000 convention: kilo, mega, giga, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: What‚Äôs interesting about base 1,000 is the special relationship it has to base
    10\. Usually when we change bases, we expect the symbols to have a completely
    different appearance in the two bases. But when we switch between base 10 and
    base 1,000, the written symbols don‚Äôt change at all. We‚Äôve simply gone from thinking
    of, say, 123 as three symbols in base 10 to thinking of it as a single symbol
    in base 1,000\. This makes it very easy and convenient to convert between the
    bases, as we do in our heads whenever we see or hear large numbers in everyday
    life.
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 60: Sexagesimal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let‚Äôs talk about *sexagesimal*, also known as *base 60*. This system is relevant
    to modern computing for two reasons: first, like base 1,000, it‚Äôs another example
    of the sort of compound notation we‚Äôll explore later; and second, it‚Äôs still in
    heavy computational use today.'
  prefs: []
  type: TYPE_NORMAL
- en: We believe that some prehistoric human groups counted in base 12\. When we reach
    the time of the first cities (4000 BCE), the Sumerians switched to base 60 for
    their scientific studies, which included astronomy and the invention of an algorithmic
    version of the Pythagorean theorem. This may have arisen through a fusion, collision,
    or compromise between people using bases 10 and 12, as 60 is readily divisible
    by both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than invent an alphabet of 60 distinct symbols, which would have required
    a large effort to learn, the Sumerians used a hybrid notation. They wrote the
    numbers from 0 to 59 (inclusive) in the existing base 10, but they treated these
    compound symbols as individual numerals in a base 60 system. For example, the
    symbols (using modern Arabic digits with compounds separated by colons) 11:23:13
    would represent the following number:'
  prefs: []
  type: TYPE_NORMAL
- en: 11 √ó 60¬≤ + 23 √ó 60¬π + 13 √ó 10‚Å∞ = 39,889[10]
  prefs: []
  type: TYPE_NORMAL
- en: 'We still use a sexagesimal system today to represent time: the number above
    means 23 minutes and 13 seconds past 11, which is equal to 39,889 seconds into
    the day. Modern databases, data science systems, and date-time libraries therefore
    need to be carefully designed to handle conversions between sexagesimal, binary,
    and decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 16: Hexadecimal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let‚Äôs talk about hex! Short for *hexadecimal* or *hex code*, *hex* is a base
    16 system. Its symbols are a mix of the digits 0 through 9 and the letters a through
    `f` (for the decimal numbers 10 through 15), often prefixed by 0x to indicate
    they are hex.
  prefs: []
  type: TYPE_NORMAL
- en: 'You‚Äôve probably seen hex numbers around in any computer programs in languages
    that allow direct access to and use of memory, including C and assembly. They
    also appear in higher-level languages as a way to differentiate copies of objects
    that otherwise have the same properties. For example, if you copy a `Cat` object
    (in an object-oriented language) with properties `numberOfLegs = 4` and `age =
    6,` you‚Äôll get a second `Cat` object with those same properties, but the two copies
    are distinct because they have different names and are stored in different locations
    in memory. Some debugging tools will show these memory locations to allow you
    to see which object is which. For example, when you ask Python to print an object,
    you‚Äôll see a hex address, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Human interfaces to low-level computer architecture, such as memory locations,
    often use hex as an alternative, more human-readable way to display what is binary
    information. The address in the output above is really a long string of 0s and
    1s in binary, but this would be hard for a human to recognize, for example, when
    comparing two addresses to see if they‚Äôre the same or different. Comparing hex
    numbers is much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hex is used for displaying binary, rather than some other system, because it
    has a similar relationship to binary as base 1,000 has to base 10\. Because 16
    is a power of 2, just as 1,000 is a power of 10, there‚Äôs a one-to-one relationship
    between groups of columns in binary and columns in hex. This allows for fast,
    easy conversion between the two systems. Consider a binary number with its digits
    organized into groups of four: 0010,1111,0100,1101\. We can view this as'
  prefs: []
  type: TYPE_NORMAL
- en: 0010[2] √ó 2^(12) + 1111[2] √ó 2‚Å∏ + 0100[2] √ó 2‚Å¥ + 1101[2] √ó 2‚Å∞
  prefs: []
  type: TYPE_NORMAL
- en: 'which is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: 2[10] √ó 16¬≥ + 15[10] √ó 16¬≤ + 4[10] √ó 16¬π + 13[10] √ó 16‚Å∞
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these powers of 16 has a number from 0 to 15 inclusive, so if we use
    the letters a[16] to f[16] to denote 10[10] to 15[10], then we can write the number
    in hex as 2f4d[16]. Every 4 bits in the binary number (a quantity sometimes called
    a *nybble*) corresponds to one hex digit: the 2 in hex corresponds exactly to
    the first 4 bits, 0010; the `f` to 1111; the 4 to 0100; and the d to 1101\. This
    four-to-one correspondence makes it easy to convert back and forth between hex
    and binary‚Äîmuch easier than, say, converting between decimal and binary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HEX EDITORS**'
  prefs: []
  type: TYPE_NORMAL
- en: Hex editors (for example, in Vim, %!xxd, as shown in the following image) display
    the contents of files or memory in byte notation, sometimes together with other
    translations such as ASCII characters. They allow you to edit the corresponding
    binary data directly. This is useful for editing binary data and executable (compiled
    program) files on disk, or poking (overwriting programs and data) in the computer‚Äôs
    memory, such as programs currently running. These editors have many interesting
    security-related applications. For example, you might use one to try to find and
    circumvent parts of a proprietary program that check for verified purchases, or
    to overwrite your number of lives in a computer game to get 255 instead of 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0054-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hex is a convenient tool for humans to think about binary numbers in a computer,
    but it‚Äôs important to recognize that hex isn‚Äôt a tool the computers themselves
    use. We don‚Äôt build physical computers using hex as a base; we build them using
    binary. Then we chunk the computers‚Äô binary numbers into fours and translate them
    into hex to make them more human-friendly. After all, 16 is just a bit more than
    10, and so is the kind of number that humans can get used to thinking in, rather
    than binary.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate notations used in some books and programming languages for hex include
    2F4D[16], 0x2f4d, 2F4Dh, &2F4D, and $2F4D.
  prefs: []
  type: TYPE_NORMAL
- en: '*Base 256: Bytes*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the base 1,000 trick again, it‚Äôs common to see hex code grouped into *pairs*
    of hex digits, such as 2D 4F 13 A7\. Here, each pair can be viewed as a single
    symbol from an alphabet of 256 symbols, with each symbol representing 8 bits,
    known as a *byte*. Bytes were the main unit of computation in the 8-bit era. The
    nybble is so-called because it‚Äôs half a byte. Remember that a nybble is one hex
    digit; a byte is a pair of hex digits.
  prefs: []
  type: TYPE_NORMAL
- en: '*How to Convert Between Bases*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert from any base *b* representation to decimal, sum the decimal values
    of each of the base *b* columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*[*n*]*b*^(*n*) + *x*[*n* ‚Äì 1]*b*^(*n* ‚Äì 1) + . . . + *x*[0]*b*‚Å∞'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here‚Äôs how to convert a number from base 19 to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0055-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To convert from decimal to base *b*, use repeated integer division by *b* with
    remainders. [Table 2-1](ch02.xhtml#ch02tab1) shows the steps of converting 186[10]
    to binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Converting 186 to Base 2'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Step** | **Result** | **Remainder** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 186/2 | 93 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 93/2 | 46 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 46/2 | 23 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 23/2 | 11 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 11/2 | 5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5/2 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2/2 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1/2 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Here, the binary form of 186[10] is obtained by reading up the remainder column:
    10111010[2].'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages provide functions that automatically carry out common
    conversions, with names like `bin2hex` and `hex2dec`.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have a basic representation for whole numbers, such as any of the
    base systems we‚Äôve discussed, you can use it as a first building block to construct
    representations of other things: more complicated types of numbers, text, multimedia,
    and any general hierarchical data structure. Here we‚Äôll see such representations,
    often using systems we‚Äôve already defined as components of other higher-level
    systems. This can be as simple as using a pair of whole numbers to represent a
    fractional number or as complex as using billions of floating-point numbers grouped
    into spatiotemporal hierarchies to represent a multimedia stream of video, multilingual
    audio, and text subtitles, as found in your movie player.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Natural Numbers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *natural numbers* (traditionally denoted by the set symbol N) are the numbers
    0, 1, 2, 3, 4, and so on. They‚Äôre often used to represent numbers of *physical*
    things in the world, such as rocks or cows.
  prefs: []
  type: TYPE_NORMAL
- en: Natural numbers can be represented in many ways, including tallies and Roman
    numerals. In computer architecture, the most obvious way is to use one of the
    base-exponent systems we‚Äôve discussed. Some computers have used the decimal base
    (see the ‚ÄúDecimal Computers‚Äù box), while most modern machines use binary. For
    example, using light bulbs that can be either on or off, we can represent the
    binary columns of the number 74 (one 64, one 8, one 2), as in [Figure 2-8](ch02.xhtml#ch02fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0056-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: A representation of the number 74 in binary*'
  prefs: []
  type: TYPE_NORMAL
- en: There‚Äôs some subtlety to this, which will become important in more complex representations.
    First, you need to choose a convention for how to read the bulbs. In this case,
    we‚Äôve chosen to put the highest power on the left, as with human-readable decimal
    numbers. We could equally have chosen the other way around, however, with the
    highest power on the right. Second, we‚Äôve assumed in our example that eight bulbs
    are available and are being used. This means we can only represent the numbers
    0 through 255\. If we want to represent larger numbers, or even communicate the
    fact that we‚Äôve run out of bulbs to represent a larger number, we‚Äôll need a new
    plan.
  prefs: []
  type: TYPE_NORMAL
- en: '**DECIMAL COMPUTERS**'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal computers have a long history, spanning the mechanical and electronic
    ages. Here are some details of how they worked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Babbage‚Äôs Analytical Engine**'
  prefs: []
  type: TYPE_NORMAL
- en: Like Babbage‚Äôs Difference Engine, his Analytical Engine uses a decimal representation,
    with gear wheels containing the digits 0 through 9\. A gear‚Äôs orientation represents
    a particular decimal digit, *d*, when that digit is oriented toward a fixed marker,
    as shown in the following figure. As in Pascal‚Äôs calculator (and unlike da Vinci‚Äôs),
    the gear never stops at continuous angles in between digits; it has only 10 discrete
    states.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0057-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The gear is hollow, and there‚Äôs a shaft inside it. The gear and this shaft may
    connect via two tappets, one attached to each of their circumferences. These tappets
    are arranged so that if the shaft is rotated by a full circle, the tappets will
    connect for part of the circle, with the effect of rotating the gear by the value
    of its digit rather than the full circle. To read the represented number, you
    rotate the shaft by a full circle. For the first part of this rotation, the tappets
    aren‚Äôt in contact and the gear doesn‚Äôt move. For the second part of this rotation,
    the tappets come into contact and the rotating shaft makes the gear rotate along
    with it for *n*-tenths of a rotation, where *n* is the number represented. This
    rotation of the gear is what gives you access to the number. For example, if you
    first connect the gear to a second gear, it will have the effect of advancing
    that second gear‚Äôs digit by *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the data is lost from the first gear when it‚Äôs read, as the tappet
    always moves the gear into its zero position during the second part of the rotation.
    The act of reading the data is thus a *move* rather than a *copy*.
  prefs: []
  type: TYPE_NORMAL
- en: Many gears can be stacked vertically to represent digits of larger decimal numbers.
    Likewise, many of these vertical stacks are arranged horizontally in the Analytical
    Engine to represent many numbers together.
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Decimal Machines**'
  prefs: []
  type: TYPE_NORMAL
- en: Less well known in history are decimal machines of the early electronic age.
    The first commercial computer, UNIVAC (1951), discussed in the previous chapter,
    was one of them. Its main console (see the following figure) is characterized
    by many groups of 10 lights, used for displaying various decimals.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0058-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IBM 650 in the following figure, dating from 1953, was notable for its use
    of a ‚Äúbi-quinary‚Äù representation. Exactly as in the abacus, this involved a mixture
    of units and fives making up decimal columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0058-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binary isn‚Äôt the only way for digital systems, such as light bulbs, to represent
    natural numbers. Sometimes a one-of-*N* representation is more useful, as in [Figure
    2-9](ch02.xhtml#ch02fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0059-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: A representation of the number 5 in a one-of*-N *system (the leftmost
    bulb represents 0)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assume that *N* bulbs are available and being used, and that exactly
    one of them will be on at any time. This can be wasteful, because we don‚Äôt use
    most of the possible states of the set of bulbs. But it can also be useful: for
    example, if we want to actually shine a light on some object in the real world,
    such as the fifth car in a row, we now have a single physical light bulb dedicated
    to that purpose. This will be very useful in computer architecture, as we very
    often want to switch on and off one of *N* physical circuits in a similar way.
    As with binary, we need to agree on a left-to-right or opposite convention, and
    there‚Äôs no way to indicate that we‚Äôve run out of bulbs if a number is too large.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Integers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *integers* (set symbol Z) are the numbers . . . , ‚Äì3, 2, ‚Äì1, 0, 1, 2, 3,
    and so on. They can be defined as pairing natural numbers with positive or negative
    signs (apart from zero, where +0 = ‚Äì0). [Table 2-2](ch02.xhtml#ch02tab2) shows
    three different options for encoding them in binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Three Possible Binary Encodings for Integers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Integer** | **Signed** | **One‚Äôs complement** | **Two‚Äôs complement** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†3 | 011 | 011 | 011 |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†2 | 010 | 010 | 010 |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†1 | 001 | 001 | 001 |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†0 | 000 and 100 | 000 and 111 | 000 |'
  prefs: []
  type: TYPE_TB
- en: '| ‚Äì1 | 101 | 110 | 111 |'
  prefs: []
  type: TYPE_TB
- en: '| ‚Äì2 | 110 | 101 | 110 |'
  prefs: []
  type: TYPE_TB
- en: '| ‚Äì3 | 111 | 100 | 101 |'
  prefs: []
  type: TYPE_TB
- en: '| ‚Äì4 | n/a | n/a | 100 |'
  prefs: []
  type: TYPE_TB
- en: A naive way to represent integers is to use binary codes for the natural numbers
    corresponding to their absolute values, together with an extra bit for their sign,
    as in the signed column of [Table 2-2](ch02.xhtml#ch02tab2) (the leftmost bit
    indicates the sign). It‚Äôs difficult to build machinery to correctly process these
    representations, however, as the sign has to be handled separately and used to
    select what should be done with the rest of the number. Having two different representations
    of the number 0 may also be a problem, requiring extra machinery to sort out.
  prefs: []
  type: TYPE_NORMAL
- en: Consider for a moment the alternative one‚Äôs complement representation of the
    same integers given in the table. (Few people actually use this, but it will help
    you understand the next one.) In this representation, the codes for the positive
    integers are the same as for natural numbers, but the codes for negatives are
    obtained by inverting all of the bits for their corresponding naturals. For example,
    to get the code for ‚Äì2, we start with the code for +2, which is 010, and invert
    all the bits to get 101.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the two‚Äôs complement representation of integers in the table. This
    is formed by taking the one‚Äôs complement codes and adding 1 to them for negative
    numbers only. For example, ‚Äì2 becomes 110, which is 101 + 1\. This may seem like
    a random thing to do, but as you‚Äôll see later, the two‚Äôs complement approach turns
    out to be very useful. It simplifies the required arithmetic machinery, which
    is why today‚Äôs computers typically use it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Rationals*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *rationals* (set symbol ‚Ñö) are defined as, and may be represented by, pairs
    of integers *a*/*b*, with *b* ‚â† 0\. Examples include 1/2, ‚Äì3/4, 50/2, ‚Äì150/2,
    and 0/2\. Many rationals are equivalent to one another, such as 4/2 and 2/1\.
    Detecting and simplifying equivalences requires dedicated computational work,
    and without this work rationals tend to expand to silly scales such as the representation
    1,000,000,000/2,000,000,000 representing the number 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing rationals is our first example of combining multiple existing
    representations: we need to use a pair of integers. For example, consider [Figure
    2-8](ch02.xhtml#ch02fig8), which we previously interpreted as a single natural
    number; this figure could instead be viewed as representing the rational 4/10
    = 2/5 by assuming that the first and second groups of four bulbs represent 4 and
    10.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There‚Äôs some subtlety in this: we need to agree that the first four of the
    eight bulbs are to represent the first integer, and the second four the second
    integer, plus we need to agree on conventions for the integers themselves (how
    to convey positive versus negative values), as discussed earlier. We will end
    up with multiple representations for many rationals, such as 4/10 and 2/5, which
    may initially confuse us if we want to ask whether two rationals are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixed Point*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fixed-point numbers*, such as 4.56, 136.78, and ‚Äì14.23, are numbers with a
    limited number of digits before and after the point. In these examples there are
    always two digits after the point. Formally, fixed-point numbers are a subset
    of the rationals, as they can always be written as an integer divided by some
    power of 10\. They can be easily represented in computers as pairs of integers,
    corresponding to the two parts of the number before and after the decimal point,
    provided we agree on a convention for their ordering and size, as well as a convention
    for the integers themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the bulbs in [Figure 2-8](ch02.xhtml#ch02fig8) could now represent
    the fixed-point binary number ![Image](../images/f0061-01.jpg) if we agree that
    the point is fixed after the fourth bulb. Note that these are exactly the same
    bulbs that we previously used to represent the rational 4/10 and the integer 74;
    to interpret data as a representation, we need to agree on which representation
    system is being used.
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating Point*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Floating-point numbers*, such as 4.56 √ó 10^(34) and ‚Äì1.23 √ó 10^(‚Äì2), are a
    computational version of the Suzhou place notation system seen previously in [Figure
    2-7](ch02.xhtml#ch02fig7), and are composed of a fixed-point mantissa (here, 4.56)
    and an integer exponent (here, 34). They are easily represented in computers by
    pairing together an integer representation and a fixed-point representation.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this in practice, you need to choose specific representations for the
    fixed-point and integer parts, with specific bit lengths and a specific ordering
    for how to pack them together into a pair. It‚Äôs also useful to reserve a few bit
    strings for special codes, such as plus and minus infinity (which can be used
    to code results for 1/0 and ‚Äì1/0) and ‚Äúnot a number‚Äù (*NaN*, used to code exceptions
    such as when trying to compute 0/0.0). *IEEE 754* is a commonly used standard
    for making these choices. It includes a set of bit orderings to best make use
    of 8, 16, 32, 64, 128, or 256 bits as floating-point representations. For example,
    IEEE 754‚Äôs 64-bit standard specifies that the first 53 bits should be used as
    the fixed-point mantissa in a signed encoding, with the first bit holding the
    sign; the remaining 11 bits should serve as a two‚Äôs complement integer exponent.
    Some bit patterns are reserved for infinities and NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPUTABLE REALS**'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond floating points, computer science has its own concept of *computable
    real numbers*, sometimes written as ùïã, which are different from‚Äîand better than‚Äîthe
    *real numbers* used in mathematics, denoted with ‚Ñù. Computable reals are all the
    numbers that can be defined by programs. In contrast, the much larger set of mathematicians‚Äô
    real numbers are useless as they can‚Äôt be individually defined or used in computation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a physical turtle robot controlled by a language like Scratch, moving
    left and right along a number line. The computable reals are all the locations
    on the number line that you can write a program for the turtle to stop at. Specifically,
    they‚Äôre all the numbers whose *n*th digit can be specified by some finitelength
    computer program.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write a function `pi(n)` that takes an integer n as input
    and returns the *n*th digit of *œÄ*. Likewise, we can add two computable reals,
    `a(n)` + `b(n)`, by forming a new program from the programs `a(n)` and `b(n)`.
    The new program will take `n` as an input and call `a()` and `b()` one or more
    times to generate the *n*th digit of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Computable reals have many fascinating and almost paradoxical properties, which
    have deep implications for both computer and human arithmetic. For example, it‚Äôs
    generally impossible (uncomputable) to know whether two computable reals are equal
    or different! The programs formed from performing just a few basic arithmetic
    operations on computable reals can quickly get quite large and unwieldy. It would
    be nice if we could optimize them by replacing them with shorter (or shortest)
    programs that give the same outputs, but it‚Äôs impossible to do this. There is
    a ‚Äúcountable‚Äù number of computable reals, which is the same ‚Äúsize‚Äù of infinity
    as the integers. This is different from the mathematicians‚Äô reals, which have
    a larger ‚Äúsize‚Äù that‚Äôs ‚Äúuncountable.‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing defined the computable reals in his great paper ‚ÄúOn Computable Numbers,‚Äù
    hence the letter ùïã. They are his true genius contribution to computer science,
    rather than ‚Äúinventing the computer‚Äù (the title of this paper is a clue that it‚Äôs
    about computable numbers, rather than about computers). Turing‚Äôs theory is still
    underappreciated. If it were more widely developed and used, we might one day
    get rid of the errors caused by floating-point approximations and be able to make
    perfectly accurate computations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Arrays*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *one-dimensional array* is a sequence of *R* values:'
  prefs: []
  type: TYPE_NORMAL
- en: '{*a*[*r*]}[*r*=0:*R*‚Äì1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *two-dimensional array* is a collection of *R* √ó *C* values (standing for
    numbers of rows and columns), where:'
  prefs: []
  type: TYPE_NORMAL
- en: '{*a*[*r,c*]}[*r*=0:*R*‚Äì1,*c*=0:*C*‚Äì1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *D-dimensional array* is a collection of values with *D* indices, such as
    the 3D *R* √ó *C* √ó *D* array with the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '{*t[r,c,d]*}[*r*=0:*R*‚Äì1,*c*=0:*C*‚Äì1,*d*=0:*D*‚Äì1]'
  prefs: []
  type: TYPE_NORMAL
- en: The values in arrays may be numbers (of any of the types of numbers we‚Äôve discussed)
    or other types of data.
  prefs: []
  type: TYPE_NORMAL
- en: Often numerical arrays are used to represent vectors, matrices, and tensors.
    These are mathematical concepts that *extend* the data structure with specific,
    defined, mathematical operations. For example, a *vector* is a 1D array with specific
    rules for addition, multiplication by a scalar, and computing dot products and
    norms. A *matrix* is a 2D array with specific rules such as for multiplication
    and inversion. A *tensor* is an *N*-dimensional array with specific rules for
    covariant and contravariant coordinate transforms, in addition to multiplication
    and inversion. Vectors and matrices are special cases of tensors. (Many computer
    scientists use the term *tensor* incorrectly to refer only to the *N*-dimensional
    data structure, forgetting the other mathematical requirements of true tensors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic data representation for all types of arrays is to ‚Äúpack‚Äù them into
    a series of individual numbers in contiguous areas of computer memory. For example,
    [Figure 2-8](ch02.xhtml#ch02fig8) might represent the 1D array of integers [1,0,2,2]
    if we agree on a convention that each integer is represented by two bulbs. Similarly,
    it might represent this 2D array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0063-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case we‚Äôre considering each of the 2D array‚Äôs rows as a 1D array, [1,0]
    and [2,2]. We encode each 1D array using two bulbs per integer and store the series
    of encodings for the rows in order. By extension, for a general *N*-dimension
    array, we may do the same: split it into a series of (*N* ‚Äì 1)-dimension arrays,
    encode each of them, and store the series of encodings in order.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data representation and computation architectures for vectors, matrices,
    and tensors has become a major driver of the tech industry. GPUs were first built
    to perform fast 3D vector-matrix operations for realtime 3D games, and have more
    recently been generalized for fast tensor computations, which have found important
    applications in neural network acceleration. Google‚Äôs tensor processing units
    (TPUs) are designed specifically for this task.
  prefs: []
  type: TYPE_NORMAL
- en: '*Text*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let‚Äôs talk about text. Once you have a finite, discrete alphabet of symbols,
    such as the characters we use to write human-readable text, you can assign a natural
    number to represent each one. You can then use a bunch of natural numbers in an
    array to represent *strings* of text. This idea has evolved from the long-standard-but-now-outdated
    ASCII to modern Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: '**A HISTORY OF TEXT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbers aren‚Äôt very useful by themselves: we need to know *what* is being counted.
    Sumerian trading tokens were ‚Äútyped‚Äù‚Äîthree cow tokens to represent three cows.
    But when we moved from tokens to more abstract numerals, we lost the information
    about what the numbers were supposed to represent. The numbers needed to be accompanied
    by extra symbols describing the type, as in ‚Äú3 cows.‚Äù Writing thus emerged from
    the same trading tokens as numbers, but it forked to become pictograms and then
    text.'
  prefs: []
  type: TYPE_NORMAL
- en: The first writing appeared in Sumeria around 4000 BCE. It used pictures of objects
    (pictograms) to represent them. Pictograms appeared in many cultures, then gradually
    transformed into phonetic symbols. The phonetic and semantic uses may coexist
    for a while‚Äîas in modern Chinese‚Äîbut the phonetic use usually becomes dominant.
    Text symbols also evolved over time to become simplified and easier to write,
    losing the original pictorial similarities to their objects. Where writing was
    carved on stone, the symbols evolved to be made from straight lines that are easier
    to carve. The most common symbols evolved fastest into quick-to-write shapes.
    They thus became the handiest to use in phonetic transcriptions, so the phonetic
    letters that survived the transition from pictures to sounds tended to come from
    the most common words.
  prefs: []
  type: TYPE_NORMAL
- en: Text isn‚Äôt always written from left to right. Arabic and Hebrew go right to
    left, and many East Asian languages can be written from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Morse code was developed around the great computing year, 1836, to enable operators
    of the Victorian internet‚Äîthe telegraph‚Äîto communicate quickly. Samuel Morse studied
    the frequency of letter usage in English to give the common ones the shortest
    representations. Morse is *almost* a binary code, as it uses sequences of two
    symbols to represent letters, but they‚Äôre usually used together with a third symbol,
    empty space, to show breaks between words.
  prefs: []
  type: TYPE_NORMAL
- en: Braille was also developed around 1836 by Louis Braille. It‚Äôs a true binary
    code, with each letter represented by binary states of a 2√ó3 grid. It was originally
    developed for secret use by soldiers but became popular for its present-day use
    by blind readers.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *American Standard Code for Information Interchange (ASCII)*, shown in [Figure
    2-10](ch02.xhtml#ch02fig10), represents each character as a unique 7-bit code,
    meaning it can represent 128 characters in total. This allows for uppercase and
    lowercase letters, digits, symbols, and punctuation, as well as historical *controls*
    such as delete, carriage return, line feed, and ring a bell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In old email systems, ASCII control codes would sometimes be transmitted and
    displayed as part of the email message rather than actually being executed. The
    backspace control code was particularly prone to this effect, so you would get
    emails such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The team has identified several fuckups^H^H^H^H^H^H^Hchallenges in the plan.
  prefs: []
  type: TYPE_NORMAL
- en: Today, old-timers sometimes type out similar ‚Äúbackspace fails‚Äù on purpose for
    humor.
  prefs: []
  type: TYPE_NORMAL
- en: Some operating systems use different conventions to represent the ends of lines,
    involving line feeds (code 10) and carriage returns (code 13) in text files, which
    may need to be fixed if you move text files between systems. In the days of typewriters
    and then teletype machines, these were two different physical controls, one to
    advance the paper in the machine by a row, and the other to return the print head
    carriage back to the left side of the paper.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII code 0 is commonly used to represent the end of a string. If a string
    is laid out in memory, programs need a way to work their way through it one character
    at a time. The convention is that when they reach a zero, they know to stop.
  prefs: []
  type: TYPE_NORMAL
- en: As a 1960s American standard, ASCII is a product of a time before globalization
    and the internet, and it has come to show its age. It can only represent characters
    from the Latin alphabet, so it can‚Äôt directly represent characters needed by languages
    other than English. Many European languages require multiple versions of Latin
    characters containing accents, for example, while languages such as Chinese and
    Arabic use completely different alphabets.
  prefs: []
  type: TYPE_NORMAL
- en: However, in one of the most foresighted design decisions ever made in computing,
    coupled with coincidence, the designers of ASCII were aware of this potential
    future issue and planned for it. The coincidence was that the machines of the
    time used groups of 8 bits, while the size of the set of characters needed for
    English was just under 7 bits. The design decision was to thus use 8-bit representations
    for ASCII characters but to always make the first bit a 0\. In the future, if
    additional characters were needed, this first bit could be used for other purposes.
    This has now happened, giving rise to the modern Unicode Standard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: The ASCII character representations*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII AS BASE 256**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you‚Äôve written a program in your favorite language, such as the following
    in BASIC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then suppose you encode the characters of this program as ASCII characters
    and save them in a text file. Each one of these characters is a byte. If you open
    your program in a hex editor rather than a normal text editor, you‚Äôll see your
    program represented as a list of byte codes, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about the compound notation concept we‚Äôve previously used in base 1,000,
    sexagesimal, and byte codes themselves, and apply it to this whole list of byte
    codes. Consider each byte code as a base 256 digit, and form the *entire program*
    into a single very large number, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 31[256] √ó 256^(27) + 30[256] √ó 256^(26) + 20[256] √ó 256^(25) + 50[256] √ó 256^(24)
    . . . + 30[256] √ó 256‚Å∞
  prefs: []
  type: TYPE_NORMAL
- en: 'This calculation would give a single astronomically sized integer. This means
    we have a mapping between programs and integers: we can represent any program
    with a single integer. When you write a program, you‚Äôre just choosing which integer
    to apply. This view can be used in computational theory, because it allows math
    about numbers to talk about programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What we collectively know as *Unicode* actually refers to three different but
    related standards defined in 1991: UTF-8, UTF-16, and UTF-32\. *UTF-8* extends
    ASCII by making use of the previously unused eighth bit. If it‚Äôs a 1, then a second
    byte follows to enlarge the space of symbols. If the second byte starts with a
    1, then a third byte follows as well. If the third byte starts with a 1, then
    a final, fourth byte is also used. UTF-8 thus allows for more than one million
    different characters. Its standard doesn‚Äôt use all of them, but it includes mappings
    to symbols needed for all major world languages. So many character encodings are
    available that international communities have been able to add to the standard,
    including symbols for less widely spoken languages, ancient languages such as
    Cuneiform, fictional languages such as Klingon, other symbols such as from mathematics
    and music, and a large number of emoji (see [Figure 2-11](ch02.xhtml#ch02fig11)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0067-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: Unicode Thai, math, emoji, and Cuneiform sectors*'
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency, the most widely used languages are given the symbols that require
    only 2 bytes, with the rarer ones requiring 3 bytes and the comedy ones requiring
    4 bytes. There are sometimes lively debates about which of these sectors a newly
    proposed character set should be assigned to. The next time you send a text with
    just the right emojum to express your feelings, you can thank the ASCII designers
    for their foresight.
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-32* is a fixed-width encoding that uses all four available bytes in *every*
    character. From a storage standpoint, this is obviously inefficient, but for some
    applications it may speed up the process of looking up symbols. For example, if
    you want to read the 123rd symbol, then you can find it right away in bytes 123√ó4
    to 123√ó5.'
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-16* is like UTF-8, but at least 2 bytes are always used, even for ASCII
    characters. This covers a large set of symbols in common use around the world,
    so it can often act as if it were a fixed-width coding, to enable fast look-ups
    as in UTF-32\. It‚Äôs a compromise encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting files between the different UTF formats is a modern version of the
    pain we used to have with carriage returns and line feeds in ASCII. Especially
    with CSV spreadsheet files, using the wrong UTF import can make good files look
    like garbage.
  prefs: []
  type: TYPE_NORMAL
- en: '*Multimedia Data Representation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data representation gets more fun as we move to images, video, and audio to
    bring our computers to life. These representations are all built on the arrays
    of numbers we‚Äôve previously constructed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image Data**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grayscale images can be represented by 2D arrays of numbers, with each element
    representing a pixel, and its value representing the shade of gray. The type of
    integer representation within this array affects the quality of the image: if
    1-bit integers are used, then each pixel can only be black (0) or white (1), whereas
    if 8-bit integers are used, then 256 shades of gray are available between black
    (0) and white (255).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Human eyes are receptive to three main frequencies of light: red, green, and
    blue. This means the experience of seeing an image in color can be reproduced
    by shining lights at each of these frequencies from each pixel. To represent a
    color image, we can therefore take three grayscale image representations; use
    them to represent the red, green, and blue channels of the image; and somehow
    store them together. Different systems may use different approaches to this storage.
    For example, we might store the complete red image first, then the green after
    it, then the blue. But some computations may run faster if we *interleave* the
    channels, with the red, green, and blue values for the top-left pixel stored first,
    one after the other, then the red, green, and blue values for the pixel next to
    it, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: For some applications, it‚Äôs useful to add a fourth channel, called *alpha*,
    to represent the transparency of each pixel. This representation is known as RGBA.
    For example, in sprite-based games this tells the graphics code how to mask each
    sprite, leaving the background intact behind its shape. Non-binary alphas can
    also be used to blend images together by making them partially transparent to
    various degrees. Including an alpha channel is especially convenient because having
    four channels makes a power of two, which plays nicely with binary architectures.
    For example, it is common to use 32-bit colors with four 8-bit channels, rather
    than 24-bit colors with three 8-bit channels, on a 32-bit machine. Of course,
    this requires more storage, so pixel values might be stored as 24 bits and converted
    to 32 bits when loaded into memory. (Since 24-bit RGB is usually considered the
    maximum color depth that humans can distinguish, there‚Äôs little point in going
    to 64-bit color, even on 64-bit machines.)
  prefs: []
  type: TYPE_NORMAL
- en: Video can be represented (most basically) as a sequence of still images packed
    in temporal sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Data**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Continuous sound waves can be represented as a series of discrete samples. The
    samples need to be taken at a rate of double the highest frequency present in
    the signal. Human hearing ranges from around 20 to 20,000 Hz, so common audio
    sample rates are around 40,000 Hz. Each sample is a number, and as with color
    depth, the choice of the number of bits to devote to each sample affects the sound
    quality. Consumer media such as Blu-ray uses a depth of 24 bits, around the maximum
    distinguishable to humans, while 32 bits may be used internally and by audio producers,
    as it‚Äôs a power of two and gives more robustness to editing manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Stereo or multichannel audio can be thought of as a collection of sound waves
    meant to be played together. These might be stored as one whole wave at a time
    in memory, or interleaved over time, with one sample from each channel stored
    contiguously for each sample time.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all sound representations use either integer or fixed-point representations
    for the individual samples. A consequence of this is that there are clear minimum
    and maximum values that samples can take. If the signal goes out of this ‚Äúheadroom‚Äù
    range it will *clip*, losing information and sounding distorted. Musicians and
    voice actors often curse these data representations if they have just performed
    a perfect take but it got clipped and they have to do it again. A recent trend
    in professional audio systems is a move to all floating-point representations,
    which are much more computationally intensive but free the artists from the clipping
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with *multi*media, such as movies that include video and audio
    together, the interleaving representation concept is often extended so that data
    from each medium for a point in time is coded together in a contiguous area of
    memory‚Äîfor example, all the data for one video frame, plus an audio segment for
    the duration of that frame. The interleaving schemes are known as *containers*.
    *Ogg* and *MP4* are two well-known container data representations used for movies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compression**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simple media representations for images, video, and audio that we‚Äôve just
    discussed are good during computation, but they aren‚Äôt usually ideal in terms
    of storage. For efficiency, we often look for ways to *compress* the data without
    changing the human experience of it.
  prefs: []
  type: TYPE_NORMAL
- en: The natural world tends to contain a lot of redundancy‚Äîthat is, it has regions
    of space and time that are composed of similar stuff. For example, in a video
    of a thrown red ball, if you see one red pixel belonging to the ball, then it‚Äôs
    very likely that the pixels around it are also red, and that this pixel or nearby
    pixels will be red in the next frame as well. Also, the human senses have particular
    focuses and blind spots, for example being sensitive to the amplitude but not
    the phase of audio frequencies, and not hearing some frequencies in the background
    when others are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information theory explains how to compress media data by exploiting and removing
    these redundancies and perceptual blind spots. This way, a smaller number of bits
    can be used in a more complex way to represent the same or perceptually similar
    media data. This is useful both to reduce physical storage needs, such as the
    size of a Blu-ray disc, and also to reduce network use when streaming media. However,
    it comes at a cost of additional computation: we usually need to convert the compressed
    representations back to the raw ones, which can be quite complex, depending on
    the compression scheme used. Most schemes rely on mathematical operations like
    Fourier transforms to find spatial or temporal frequencies. These can be costly
    for conventional CPUs to compute and have been a major driver of specialized signal
    processing architectures to accelerate them. Implementations of compression algorithms
    are known as *codecs*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data Structures*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any data structure, such as the structs and objects found in most programming
    languages, can be represented through *serialization*, whereby the data is transformed
    into a *series* of bits to store in memory. Serialization can be performed hierarchically:
    if a complex structure is composed of several smaller structures, we serialize
    it by first serializing each of these components, then joining their representations
    together in series to make the total representation. If the component structures
    are themselves complex, the process becomes recursive, but eventually we always
    reach a level of simple elements such as numbers or text, and we‚Äôve already discussed
    how to represent these as a series of bits (that is, serialize them).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, say we have the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will be serialized as a bit sequence beginning with the encoding for integer
    `age`, followed by the encoding for integer `legs`, and then perhaps a Unicode
    sequence for the string `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now say a `Cat` object is included in another structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Game` object will be serialized with its first bits being the encoding
    of the `Cat` object (itself a serialization of various components), followed by
    the encodings of the `lives` and `score` integers. We can continue to build higher
    and higher levels of structure in this way, which is how real-world large-scale
    programs work.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic unit of data is the *bit (b)*, which can take one of two possible
    states, usually written as 0 and 1\. When studying data, we‚Äôll often be working
    with very large numbers of bits, however, so we need notations and visualizations
    to handle these.
  prefs: []
  type: TYPE_NORMAL
- en: '*SI (Syst√®me Internationale)* is an international organization of scientists
    and engineers that sets generally accepted standards for scientific measurement
    units. This includes defining standard prefixes for powers of 1,000, as shown
    in [Table 2-3](ch02.xhtml#ch02tab3).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Large SI Prefixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Symbol** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| kilo | k | 10¬≥ =1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| mega | M | 10‚Å∂ = 1,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| giga | G | 10‚Åπ = 1,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| tera | T | 10^(12) = 1,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| peta | P | 10^(15) = 1,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| exa | E | 10^(18) = 1,000,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| zetta | Z | 10^(21) = 1,000,000,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: To visualize the large scales represented by SI prefixes, it can be useful to
    imagine 3D cubes, based on a cubic meter. Perhaps the reason we give special names
    and prefixes to powers of 1,000 is that 1,000 is three scalings of 10, which in
    3D means scaling an object by 10 in all three of its dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Using SI prefixes with bits should be the preferred standard for describing
    quantities of data, according to SI‚Äîfor example, 5 megabits means 5,000 bits.
    In fact, network speeds are often measured in megabits per second. However, at
    the architectural level we more commonly need to work with numbers that are exact
    powers of 2, not 10\. For example, a 10-bit address space provides 2^(10) = 1,024
    addresses, while a 16-bit address space provides 2^(16) = 65,536 addresses. Before
    architects adopted the SI standards‚Äîduring the 8-bit era, for example‚Äîit was common
    for architects to abuse the prefix ‚Äúkilo‚Äù to refer to 1,024 instead of 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: This naturally led to much confusion. Data sizes have gotten larger, and most
    computer people operate at a higher level, where working in proper SI units makes
    more sense. As a compromise, in 1998 the International Electrotechnical Commission
    defined an alternate set of prefixes to distinguish the powers of two from the
    SI prefixes. These have the morpheme *bi* in them, from the word *binary*. For
    example, 2^(10) has become kibi, 2^(20) has become mebi, and so on, as in [Table
    2-4](ch02.xhtml#ch02tab4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** Large Binary Prefixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Symbols** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| kibi | k[2], ki | 2^(10) = 1,024 |'
  prefs: []
  type: TYPE_TB
- en: '| mebi | M[2], Mi | 2^(20) = 1,048,576 |'
  prefs: []
  type: TYPE_TB
- en: '| gibi | G[2], Gi | 2^(30) = 1,073,741,824 |'
  prefs: []
  type: TYPE_TB
- en: '| tebi | T[2], Ti | 2^(40) = 1,099,511,627,776 |'
  prefs: []
  type: TYPE_TB
- en: '| pebi | P[2], Pi | 2^(50) = 1,125,899,906,842,624 |'
  prefs: []
  type: TYPE_TB
- en: '| exbi | E[2], Ei | 2^(60) = 1,152,921,504,606,846,976 |'
  prefs: []
  type: TYPE_TB
- en: '| zebi | Z[2], Zi | 2^(70) = 1,180,591,620,717,411,303,424 |'
  prefs: []
  type: TYPE_TB
- en: Binary prefixes are slightly larger than their SI counterparts. Not everyone
    is using them yet, and many older people and machines still use SI names to refer
    to binary units. Unscrupulous hardware manufacturers often exploit this ambiguity
    by picking whichever interpretation of the SI names will give them the best-looking
    numbers on their products.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers usually need to represent various types of numbers, text, and media
    data. It‚Äôs convenient for modern machines to do this using binary. Hex representations
    chunk binary together to appear more readable to humans. Different representations
    make different computations easier to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have methods for representing data, we can begin to build up methods
    for computing with the data. In the next chapter, we‚Äôll preview a simple but complete
    computer that does this. We‚Äôll then build up a more detailed modern electronic
    computer to do similar.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Base System Conversions**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Convert your phone number to binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert your phone number to hex. Making use of the binary from before might
    be helpful. Convert it again to byte codes, and convert the bytes to ASCII characters.
    What do they spell out?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Negate your phone number and convert this negative number to its two‚Äôs complement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a decimal point halfway through your phone number to make a floating-point
    number. Write it in IEEE 754 standard binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text and Media**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Find out how to type in Unicode on your computer. On many Linuxes, for example,
    you can press and release SHIFT-CTRL-U, then type a series of hex numbers such
    as 131bc to enter an ancient Egyptian digit at your command line or in your editor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring Data**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Obtain street, aerial, and satellite photos of an area you know, and draw a
    kilocube, megacube, gigacube, teracube, petacube, exacube, and zettacube on them,
    where, for example, each side of a kilocube is 10 m long.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use a hex editor and the internet to reverse engineer and modify some of your
    favorite media files.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For discussions and psychological models of numerosity, see Stanislas Dehaene,
    *The Number Sense* (Oxford: Oxford University Press, 2011), and the ‚ÄúNumbo‚Äù chapter
    in Douglas R. Hofstadter, *Fluid Concepts and Creative Analogies* (New York: Basic
    Books, 1995).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an advanced but classic paper full of details on floating points, see D.
    Goldberg, ‚ÄúWhat Every Programmer Should Know About Floating Point Arithmetic,‚Äù
    *ACM Computing Surveys (CSUR)* 23, no. 1 (1991): 5‚Äì48.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an extremely advanced but blindingly beautiful book on Turing reals, see
    Oliver Aberth, *Computable Calculus* (San Diego: Academic Press, 2001).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
