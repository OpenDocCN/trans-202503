["```\n   $ objdump -M   intel --start-address=0x4005f6 -d overlapping_bb\n   4005f6: push   rbp\n   4005f7: mov    rbp,rsp\n   4005fa: mov    DWORD PTR [rbp-0x14],edi   ; ➊load i\n   4005fd: mov    DWORD PTR [rbp-0x4],0x0    ; ➋j = 0\n   400604: mov    eax,DWORD PTR [rbp-0x14]   ; eax = i\n   400607: cmp    eax,0x0                    ; cmp i to 0\n➌ 40060a: jne    400612 <overlapping+0x1c>   ; if i != 0, goto 0x400612\n   400610: xor    eax,0x4                    ; eax = 4 (0 xor 4)\n   400613: add    al,0x90                    ; ➍eax = 148 (4 + 144)\n   400615: mov    DWORD PTR [rbp-0x4],eax    ; j = eax\n   400618: mov    eax,DWORD PTR [rbp-0x4]    ; return j\n   40061b: pop    rbp\n   40061c: ret\n```", "```\n   $ objdump -M intel --start-address=0x4005f6 -d overlapping_bb\n   4005f6:  push  rbp\n   4005f7:  mov   rbp,rsp\n 4005fa:  mov   DWORD PTR [rbp-0x14],edi  ; load i\n   4005fd:  mov   DWORD PTR [rbp-0x4],0x0   ; j = 0\n   400604:  mov   eax,DWORD PTR [rbp-0x14]  ; eax = i\n   400607:  cmp   eax,0x0                   ; cmp i to 0\n➊ 40060a:  jne   400612 <overlapping+0x1c> ; if i != 0, goto 0x400612\n\n   # 400610: ; skipped\n   # 400611: ; skipped\n\n   $ objdump -M intel --start-address=0x400612 -d overlapping_bb\n➋ 400612:  add  al,0x4                      ; ➌eax = i + 4\n   400614:  nop\n   400615:  mov  DWORD PTR [rbp-0x4],eax    ; j = eax\n   400618:  mov  eax,DWORD PTR [rbp-0x4]    ; return j\n   40061b:  pop  rbp\n   40061c:  ret\n```", "```\n7b05a: cmp          DWORD PTR fs:0x18,0x0\n7b063: je           7b066\n7b065: lock cmpxchg QWORD PTR [rip+0x3230fa],rcx\n```", "```\npip install capstone\n```", "```\n   >>> import capstone\n➊ >>> help(capstone)\n   Help on package capstone:\n\n   NAME\n       capstone - # Capstone Python bindings, by Nguyen Anh\n                  # Quynnh <aquynh@gmail.com>\n\n   FILE\n       /usr/local/lib/python2.7/dist-packages/capstone/__init__.py\n\n   [...]\n\n   CLASSES\n       __builtin__.object\n           Cs\n           CsInsn\n       _ctypes.PyCFuncPtr(_ctypes._CData)\n           ctypes.CFunctionType\n       exceptions.Exception(exceptions.BaseException)\n           CsError\n    ➋class Cs(__builtin__.object)\n        | Methods defined here:\n        |\n        | __del__(self)\n        |      # destructor to be called automatically when\n        |      # object is destroyed.\n        |\n        | __init__(self, arch, mode)\n        |\n | disasm(self, code, offset, count=0)\n        |     # Disassemble binary & return disassembled\n        |     # instructions in CsInsn objects\n        [...]\n```", "```\n   #include  <stdio.h>\n   #include  <string>\n   #include  <capstone/capstone.h>\n   #include  \"../inc/loader.h\"\n\n   int disasm(Binary *bin);\n\n   int\n   main(int argc, char *argv[])\n   {\n     Binary bin;\n     std::string fname;\n\n     if(argc < 2) {\n       printf(\"Usage: %s <binary>\\n\", argv[0]);\n       return 1;\n     }\n fname.assign(argv[1]);\n➊    if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) {\n       return 1;\n     }\n\n➋    if(disasm(&bin) < 0) {\n       return 1;\n     }\n\n     unload_binary(&bin);\n\n     return 0;\n  }\n\n  int\n  disasm(Binary *bin)\n  {\n    csh dis;\n    cs_insn *insns;\n    Section *text;\n    size_t n;\n\n    text = bin->get_text_section();\n    if(!text) {\n      fprintf(stderr, \"Nothing to disassemble\\n\");\n      return 0;\n    }\n\n➌   if(cs_open(CS_ARCH_X86, CS_MODE_64, &dis) != CS_ERR_OK) {\n      fprintf(stderr, \"Failed to open Capstone\\n\");\n      return -1;\n    }\n\n➍   n = cs_disasm(dis, text->bytes, text->size, text->vma, 0, &insns);\n    if(n <= 0) {\n      fprintf(stderr, \"Disassembly error: %s\\n\",\n              cs_strerror(cs_errno(dis)));\n      return -1;\n    }\n\n➎   for(size_t i = 0; i < n; i++) {\n      printf(\"0x%016jx: \", insns[i].address);\n      for(size_t j = 0; j < 16; j++) {\n        if(j < insns[i].size) printf(\"%02x \", insns[i].bytes[j]);\n        else printf(\"   \");\n      }\n printf(\"%-12s %s\\n\", insns[i].mnemonic, insns[i].op_str);\n      }\n\n➏    cs_free(insns, n);\n      cs_close(&dis);\n\n      return 0;\n   }\n```", "```\ntypedef struct   cs_insn {\n  unsigned int    id;\n  uint64_t        address;\n  uint16_t        size;\n  uint8_t         bytes[16];\n  char            mnemonic[32];\n  char            op_str[160];\n  cs_detail      *detail;\n} cs_insn;\n```", "```\nswitch(insn->id) {\ncase X86_INS_NOP:\n  /* handle NOP instruction */\n  break;\ncase X86_INS_CALL:\n  /* handle call instruction */\n  break;\ndefault:\n  break;\n}\n```", "```\n$ ./basic_capstone_linear /bin/ls | head   -n 10\n0x402a00: 41 57                  push      r15\n0x402a02: 41 56                  push      r14\n0x402a04: 41 55                  push      r13\n 0x402a06: 41 54                  push      r12\n0x402a08: 55                     push      rbp\n0x402a09: 53                     push      rbx\n0x402a0a: 89 fb                  mov       ebx,   edi\n0x402a0c: 48 89 f5               mov       rbp,   rsi\n0x402a0f: 48 81 ec 88 03 00 00   sub       rsp,   0x388\n0x402a16: 48 8b 3e               mov       rdi,   qword ptr [rsi]\n```", "```\n$ ls /usr/include/capstone/\narm.h arm64.h capstone.h    mips.h   platform.h  ppc.h\n\nsparc.h  systemz.h  x86.h  xcore.h\n```", "```\n   #include   <stdio.h>\n   #include   <queue>\n   #include   <map>\n   #include   <string>\n   #include   <capstone/capstone.h>\n   #include   \"../inc/loader.h\"\n int disasm(Binary *bin);\n   void print_ins(cs_insn *ins);\n   bool is_cs_cflow_group(uint8_t g);\n   bool is_cs_cflow_ins(cs_insn *ins);\n   bool is_cs_unconditional_cflow_ins(cs_insn *ins);\n   uint64_t get_cs_ins_immediate_target(cs_insn *ins);\n\n   int\n   main(int argc, char *argv[])\n   {\n     Binary bin;\n     std::string fname;\n\n     if(argc < 2) {\n       printf(\"Usage: %s <binary>\\n\", argv[0]);\n       return 1;\n     }\n\n     fname.assign(argv[1]);\n     if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) {\n       return 1;\n     }\n\n     if(disasm(&bin) < 0) {\n       return 1;\n     }\n\n     unload_binary(&bin);\n\n     return 0;\n   }\n\n   int\n   disasm(Binary *bin)\n   {\n     csh dis;\n     cs_insn *cs_ins;\n     Section *text;\n     size_t n;\n     const uint8_t *pc;\n     uint64_t addr, offset, target;\n     std::queue<uint64_t> Q;\n     std::map<uint64_t, bool> seen;\n\n     text = bin->get_text_section();\n     if(!text) {\n\n     fprintf(stderr, \"Nothing to disassemble\\n\");\n     return 0;\n   }\n\n   if(cs_open(CS_ARCH_X86, CS_MODE_64, &dis) != CS_ERR_OK) {\n     fprintf(stderr, \"Failed to open Capstone\\n\");\n     return -1;\n   }\n➊  cs_option(dis, CS_OPT_DETAIL, CS_OPT_ON);\n\n➋  cs_ins = cs_malloc(dis);\n    if(!cs_ins) {\n      fprintf(stderr, \"Out of memory\\n\");\n      cs_close(&dis);\n      return -1;\n   }\n\n   addr = bin->entry;\n➌  if(text->contains(addr)) Q.push(addr);\n    printf(\"entry point: 0x%016jx\\n\", addr);\n\n➍  for(auto &sym: bin->symbols) {\n      if(sym.type == Symbol::SYM_TYPE_FUNC\n         && text->contains(sym.addr)) {\n        Q.push(sym.addr);\n        printf(\"function symbol: 0x%016jx\\n\", sym.addr);\n      }\n    }\n\n➎  while(!Q.empty()) {\n      addr = Q.front();\n      Q.pop();\n      if(seen[addr]) continue;\n\n      offset = addr - text->vma;\n      pc      = text->bytes + offset;\n      n       = text->size - offset;\n➏    while(cs_disasm_iter(dis, &pc, &n, &addr, cs_ins)) {\n        if(cs_ins->id == X86_INS_INVALID || cs_ins->size == 0) {\n          break;\n        }\n\n        seen[cs_ins->address] = true;\n        print_ins(cs_ins);\n\n➐      if(is_cs_cflow_ins(cs_ins)) {\n➑        target = get_cs_ins_immediate_target(cs_ins);\n if(target && !seen[target] && text->contains(target)) {\n            Q.push(target);\n            printf(\" -> new target: 0x%016jx\\n\", target);\n          }\n➒        if(is_cs_unconditional_cflow_ins(cs_ins)) {\n           break;\n          }\n        } ➓else if(cs_ins->id == X86_INS_HLT) break;\n      }\n      printf(\"----------\\n\");\n   }\n\n   cs_free(cs_ins, 1);\n   cs_close(&dis);\n\n   return 0;\n   }\n\n   void\n   print_ins(cs_insn *ins)\n   {\n     printf(\"0x%016jx: \", ins->address);\n     for(size_t i = 0; i < 16; i++) {\n       if(i < ins->size) printf(\"%02x \", ins->bytes[i]);\n       else printf(\"   \");\n     }\n     printf(\"%-12s %s\\n\", ins->mnemonic, ins->op_str);\n   }\n\n   bool\n   is_cs_cflow_group(uint8_t g)\n   {\n     return (g == CS_GRP_JUMP) || (g == CS_GRP_CALL)\n            || (g == CS_GRP_RET) || (g == CS_GRP_IRET);\n   }\n\n   bool\n   is_cs_cflow_ins(cs_insn *ins)\n   {\n     for(size_t i = 0; i < ins->detail->groups_count; i++) {\n       if(is_cs_cflow_group(ins->detail->groups[i])) {\n         return true;\n       }\n     }\n\n     return false;\n   }\n bool\n   is_cs_unconditional_cflow_ins(cs_insn *ins)\n   {\n     switch(ins->id) {\n     case X86_INS_JMP:\n     case X86_INS_LJMP:\n     case X86_INS_RET:\n     case X86_INS_RETF:\n     case X86_INS_RETFQ:\n       return true;\n     default:\n       return false;\n     }\n   }\n\n   uint64_t\n   get_cs_ins_immediate_target(cs_insn *ins)\n   {\n     cs_x86_op *cs_op;\n\n     for(size_t i = 0; i < ins->detail->groups_count; i++) {\n       if(is_cs_cflow_group(ins->detail->groups[i])) {\n         for(size_t j = 0; j < ins->detail->x86.op_count; j++) {\n           cs_op = &ins->detail->x86.operands[j];\n           if(cs_op->type == X86_OP_IMM) {\n             return cs_op->imm;\n           }\n         }\n       }\n     }\n\n     return 0;\n   }\n```", "```\n   $ ./basic_capstone_recursive overlapping_bb\n   entry point: 0x400500\n   function symbol: 0x400530\n   function symbol: 0x400570\n   function symbol: 0x4005b0\n   function symbol: 0x4005d0\n   function symbol: 0x4006f0\n   function symbol: 0x400680\n   function symbol: 0x400500\n function symbol: 0x40061d\n   function symbol: 0x4005f6\n   0x400500: 31 ed                    xor    ebp, ebp\n   0x400502: 49 89 d1                 mov    r9, rdx\n   0x400505: 5e                       pop    rsi\n   0x400506: 48 89 e2                 mov    rdx, rsp\n   0x400509: 48 83 e4 f0              and    rsp, 0xfffffffffffffff0\n   0x40050d: 50                       push   rax\n   0x40050e: 54                       push   rsp\n   0x40050f: 49 c7 c0 f0 06 40   00   mov    r8, 0x4006f0\n   0x400516: 48 c7 c1 80 06 40   00   mov    rcx, 0x400680\n   0x40051d: 48 c7 c7 1d 06 40   00   mov    rdi, 0x40061d\n   0x400524: e8 87 ff ff ff           call   0x4004b0\n   0x400529: f4                       hlt\n   ----------\n   0x400530: b8 57 10 60 00           mov    eax, 0x601057\n   0x400535: 55                       push   rbp\n   0x400536: 48 2d 50 10 60 00        sub    rax, 0x601050\n   0x40053c: 48 83 f8 0e              cmp    rax, 0xe\n   0x400540: 48 89 e5                 mov    rbp, rsp\n   0x400543: 76 1b                    jbe    0x400560\n     -> ➊new target: 0x400560\n   0x400545: b8 00 00 00 00           mov    eax, 0\n   0x40054a: 48 85 c0                 test   rax, rax\n   0x40054d: 74 11                    je     0x400560\n     -> new target: 0x400560\n   0x40054f: 5d                       pop    rbp\n   0x400550: bf 50 10 60 00           mov    edi, 0x601050\n   0x400555: ff e0                    jmp    rax\n   ----------\n   ...\n   0x4005f6: 55                       push   rbp\n   0x4005f7: 48 89 e5                 mov    rbp, rsp\n   0x4005fa: 89 7d ec                 mov    dword ptr [rbp - 0x14], edi\n   0x4005fd: c7 45 fc 00 00 00 00     mov    dword ptr [rbp - 4], 0\n   0x400604: 8b 45 ec                 mov    eax, dword ptr [rbp - 0x14]\n   0x400607: 83 f8 00                 cmp    eax, 0\n   0x40060a: 0f 85 02 00 00 00        jne    0x400612\n     -> new target: 0x400612\n ➋  0x400610: 83 f0 04                 xor    eax, 4\n   0x400613: 04 90                    add    al, 0x90\n   0x400615: 89 45 fc                 mov    dword ptr [rbp - 4], eax\n   0x400618: 8b 45 fc                 mov    eax, dword ptr [rbp - 4]\n   0x40061b: 5d                       pop    rbp\n   0x40061c: c3                       ret\n   ----------\n   ...\n➌  0x400612: 04 04                   add     al, 4\n   0x400614: 90                       nop\n   0x400615: 89 45 fc                 mov    dword ptr [rbp - 4], eax\n   0x400618: 8b 45 fc                 mov    eax, dword ptr [rbp - 4]\n   0x40061b: 5d                       pop    rbp\n   0x40061c: c3                       ret\n   ----------\n```", "```\n  #include <stdio.h>\n  #include <map>\n  #include <vector>\n  #include <string>\n  #include <capstone/capstone.h>\n  #include \"../inc/loader.h\"\n\n  int find_gadgets(Binary *bin);\n  int find_gadgets_at_root(Section *text, uint64_t root,\n                           std::map<std::string, std::vector<uint64_t> > *gadgets,\n                           csh dis);\n  bool is_cs_cflow_group(uint8_t g);\n  bool is_cs_cflow_ins(cs_insn *ins);\n  bool is_cs_ret_ins(cs_insn *ins);\n  int\n  main(int argc, char *argv[])\n  {\n    Binary bin;\n    std::string fname;\n\n    if(argc < 2) {\n      printf(\"Usage: %s <binary>\\n\", argv[0]);\n      return 1;\n    }\n\n    fname.assign(argv[1]);\n    if(load_binary(fname, &bin, Binary::BIN_TYPE_AUTO) < 0) {\n      return 1;\n    }\n\n    if(find_gadgets(&bin) < 0) {\n      return 1;\n    }\n\n    unload_binary(&bin);\n\n    return 0;\n  }\n\n  int\n  find_gadgets(Binary *bin)\n  {\n    csh dis;\n    Section *text;\n    std::map<std::string, std::vector<uint64_t> > gadgets;\n\n    const uint8_t x86_opc_ret = 0xc3;\n\n    text = bin->get_text_section();\n    if(!text) {\n      fprintf(stderr, \"Nothing to disassemble\\n\");\n      return 0;\n    }\n\n    if(cs_open(CS_ARCH_X86, CS_MODE_64, &dis) != CS_ERR_OK) {\n      fprintf(stderr, \"Failed to open Capstone\\n\");\n      return -1;\n    }\n    cs_option(dis, CS_OPT_DETAIL, CS_OPT_ON);\n\n    for(size_t i = 0; i < text->size; i++) {\n➊   if(text->bytes[i] == x86_opc_ret) {\n➋     if(find_gadgets_at_root(text, text->vma+i, &gadgets, dis) < 0) {\n         break;\n        }\n      }\n    }\n\n➌   for(auto &kv: gadgets) {\n       printf(\"%s\\t[ \", kv.first.c_str());\n       for(auto addr: kv.second) {\n         printf(\"0x%jx \", addr);\n       }\n       printf(\"]\\n\");\n    }\n\n    cs_close(&dis);\n\n    return 0;\n  }\n\n  int\n  find_gadgets_at_root(Section *text, uint64_t root,\n     std::map<std::string, std::vector<uint64_t> > *gadgets,\n     csh dis)\n  {\n     size_t n, len;\n     const uint8_t *pc;\n     uint64_t offset, addr;\n     std::string gadget_str;\n     cs_insn *cs_ins;\n\n     const size_t max_gadget_len    = 5; /* instructions */\n     const size_t x86_max_ins_bytes = 15;\n     const uint64_t root_offset = max_gadget_len*x86_max_ins_bytes;\n\n     cs_ins = cs_malloc(dis);\n     if(!cs_ins) {\n       fprintf(stderr, \"Out of memory\\n\");\n       return -1;\n     }\n\n➍   for(uint64_t a = root-1;\n                 a >= root-root_offset && a >= 0;\n                 a--) {\n       addr   = a;\n       offset = addr - text->vma;\n       pc     = text->bytes + offset;\n       n      = text->size - offset;\n       len    = 0;\n       gadget_str = \"\";\n➎      while(cs_disasm_iter(dis, &pc, &n, &addr, cs_ins)) {\n          if(cs_ins->id == X86_INS_INVALID || cs_ins->size == 0) {\n            break;\n          } ➏else if(cs_ins->address > root) {\n            break;\n          } ➐else if(is_cs_cflow_ins(cs_ins) && !is_cs_ret_ins(cs_ins)) {\n            break;\n          } ➑else if(++len > max_gadget_len) {\n            break;\n          }\n\n➒         gadget_str += std::string(cs_ins->mnemonic)\n                        + \" \" + std::string(cs_ins->op_str);\n\n➓         if(cs_ins->address == root) {\n            (*gadgets)[gadget_str].push_back(a);\n            break;\n          }\n\n          gadget_str += \"; \";\n        }\n      }\n\n      cs_free(cs_ins, 1);\n\n      return 0;\n  }\n\n  bool\n  is_cs_cflow_group(uint8_t g)\n  {\n    return (g == CS_GRP_JUMP) || (g == CS_GRP_CALL)\n            || (g == CS_GRP_RET) || (g == CS_GRP_IRET);\n  }\n\n  bool\n  is_cs_cflow_ins(cs_insn *ins)\n  {\n    for(size_t i = 0; i < ins->detail->groups_count; i++) {\n      if(is_cs_cflow_group(ins->detail->groups[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool\n  is_cs_ret_ins(cs_insn *ins)\n  {\n    switch(ins->id) {\n    case X86_INS_RET:\n      return true;\n    default:\n      return false;\n    }\n  }\n```", "```\n$ ./capstone_gadget_finder /bin/ls | head -n 10\nadc byte ptr [r8], r8b; ret                       [ 0x40b5ac ]\nadc byte ptr [rax - 0x77], cl; ret                [ 0x40eb10 ]\nadc byte ptr [rax], al; ret                       [ 0x40b5ad ]\nadc byte ptr [rbp - 0x14], dh; xor eax, eax; ret  [ 0x412f42 ]\nadc byte ptr [rcx + 0x39], cl; ret                [ 0x40eb8c ]\nadc eax, 0x5c415d5b; ret                 [ 0x4096d7 0x409747 ]\nadd al, 0x5b; ret                                 [ 0x41254b ]\nadd al, 0xf3; ret                                 [ 0x404d8b ]\nadd al, ch; ret                                   [ 0x406697 ]\nadd bl, dh; ret ; xor eax, eax; ret               [ 0x40b4cf ]\n```"]