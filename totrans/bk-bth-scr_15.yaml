- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 14 ESCAPING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is about a vexing problem and its Batch solution. The problem is
    that you sometimes want to use a character as simple text but that particular
    character has a specific function in the coding language. The solution is escaping.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll explain all the intricacies surrounding how to escape
    a character in Batch. A certain syntax is used the majority of the time, except
    for when it isn’t. You’ll learn about multiple rounds of escaping, the syntax,
    and why you might want to escape a character more than once. I’ll also return
    to the “continuation character,” used to continue a command on multiple lines
    of code, because when you remove its veil, it turns out to be an escape character.
    However, before getting into how to solve this problem, you must first understand
    and appreciate the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may want to use a certain character in some code, but what happens if it’s
    a special character with a certain predefined function in the coding language?
    For instance, say you’re attempting to use the special character in a text string.
    It happens in all languages, but it happens quite frequently in Batch because
    of the language’s uniquely esoteric syntax.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen repeatedly in this book, percent signs delimit variables; one
    on either side of a variable resolves the variable to its value. But long before
    the existence of Batch, the percent sign was used to denote a percentage—that
    is, a proportion of 100\. Hence, a text string in Batch can’t simply refer to
    50% without the percent sign being interpreted as a delimiter. The insidious aspect
    of this issue is that there’s no compiler to catch the problem and the interpreter
    might not even fail to execute the code, instead producing unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, consider this command writing what appears to be a simple statement
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpreter treats everything between the two percent signs—that is, the
    space followed by and 80—as a variable. Assuming that such a variable isn’t set,
    which is a virtual certainty, it (along with the percent signs) resolves to null.
    The result is this nonsensical statement written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And if this command had used only one percent sign, it alone would’ve been dropped
    from the output. By the way, what happened to the exclamation mark at the end?
    Hold that thought.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this quandary is escaping any special characters. Escape characters
    can be tricky, but they are very useful and indispensable in many situations.
    Before long, I’ll come back to the previous echo command to show you how to make
    it write the desired text.
  prefs: []
  type: TYPE_NORMAL
- en: The Caret Escape Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary Batch escape character is the caret (^). In other contexts, it’s
    called a hat or used to indicate an exponential, but in the Batch realm, it’s
    a caret. On most keyboards, you can type it using SHIFT-6\. The upshot is that
    the interpreter treats the vast majority of characters following the caret as
    simple text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following echo command is attempting to write to the console some trite
    pablum one might expect to find on a bad motivational poster at an office run
    by people who don’t understand that *Office Space* was a comedy, but the cringeworthy
    content is only part of the problem. It simply doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter treats the second greater-than sign as a second redirection
    character, creating an extensionless file named You in the current directory,
    and the ampersand ends one command and starts another. Obviously, the Me command
    with the Alone argument fails outright.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command is clearly a mess, but it’s fixable with carets. I’m inserting
    the primary Batch escape character just prior to the two characters that thwarted
    us before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of each caret in this command as a special messenger. The escape
    character is giving the interpreter this clear message upon its discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: The very next character following me is to be treated as simple text. Don’t
    interpret it as you normally would. Oh, and by the way, promptly discard me for
    I am but a digital Pheidippides, a simple messenger who expires after the completion
    of his task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is this maybe inspirational and motivational message written to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get the interpreter to treat the special characters as text
    is to enclose the string in double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note that while this command doesn’t have escape characters,
    it also writes out the double quotes to the console.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll soon reveal some exceptions, but the caret is the most commonly used Batch
    escape character, and you can use it to escape the less-than symbol (<), pipe
    (|), and parentheses (()), among other special characters. But Batch doesn’t treat
    all characters equally.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping the Caret
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the interpreter treats the caret as an escape character and throws it
    away, you might ponder the plight of a caret wanting to be treated simply as text
    itself. For example, if you were to write the Pythagorean theorem to the console,
    I hope you aren’t surprised to learn that Batch doesn’t support superscripts:
    A2 + B2 = C2. Instead, carets indicating exponentiation will suffice if we can
    make it work: A^2 + B^2 = C^2. (The Pythagorean theorem assumes that A and B are
    the sides of a right triangle adjacent to the right angle and that C is the hypotenuse.)
    This might be a first attempt at a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, each caret tells the interpreter to treat the following character,
    a 2 in each instance, as simple text, which it would’ve done anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter simply throws away the carets as if they were never there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution rests in the fact that the caret is self-escaping; a caret is
    escaped with another caret. I’ve replaced each caret in the following code with
    double carets. In each instance, the first caret is the escape character, followed
    by the text caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’ll get the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We still can’t manage a superscript, but the result written to the console is
    the next best thing and much to a mathematician’s liking.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping Percent Signs and Exclamation Marks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After studying the Pythagorean theorem, you might ace the math test, but this
    celebratory Batch command fails to produce the desired result as the two special
    characters are dropped from the text written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'D’oh! We forgot the carets. You can be forgiven for thinking this quick fix
    will show the percent sign and the exclamation mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But the output is unchanged. Unfortunately, as is often the case with Batch,
    there are batveats. The caret doesn’t work as the escape character for the percent
    sign or the exclamation mark.
  prefs: []
  type: TYPE_NORMAL
- en: 'The escape character for the percent sign is another percent sign, and the
    escape character—actually the escape characters, plural—for the exclamation mark
    is two carets. If this doesn’t make any sense to you, you are not alone. I’ve
    never found a good justification for this anomaly, but the following command writes
    I Scored 100% on my Math Test! to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Reflect on this a moment; in comparison to the Pythagorean theorem example,
    there seems to be a contradiction in how Batch handles double carets. The text
    ^^2 resolves to ^2, but in relation to the math test, the text ^^! resolves to
    !, leaving nary a caret in sight. Yes, that’s how it works. The interpreter handles
    double carets one way if followed by an exclamation mark and another way if followed
    by anything else. Consider it a batveat of a batveat (or a meta-batveat).
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the problem statement from the beginning of the chapter, this
    command writes the desired text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter writes the appropriate text to the console thanks to each set
    of double percent signs and the two carets preceding the exclamation mark.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As noted in [Chapter 3](chapter3.xhtml), I’ve written this book with the assumption
    that delayed expansion is always enabled, but if it’s disabled, Batch treats the
    exclamation mark like any other character with no particular significance in Batch
    and with no need of being escaped.*'
  prefs: []
  type: TYPE_NORMAL
- en: Multilevel Escaping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous examples demonstrate how to write hardcoded text to the console
    with single-level escaping, and the same techniques successfully set a simple
    variable, but there’s a catch. For instance, the following set command resolves
    the two escape characters and stores Together We Are > You & Me Alone into the
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the uses for this variable are severely limited. The variable
    does in fact contain the two special characters, but if you tried writing it to
    the console or a file or tried piping it to another command, it would fail to
    work as intended. Because the escape characters were removed from the text as
    it was assigned to the variable, when that variable is later resolved, the characters
    that have special meaning to the interpreter pose the same problem that escaping
    initially solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to escape the escape character—yes, double-level escaping.
    The following two lines of code write the desired text to the console, and by
    desired text I mean that it contains a greater-than sign and an ampersand with
    no escape characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To see what’s happening, let’s focus on ^^^&. The first caret is the escape
    character for the second caret, and the third caret is the escape character for
    the ampersand. When resolved, the set command stores ^& as part of the variable’s
    value. When the echo command resolves the variable, the remaining caret—the one
    that was treated as text just a moment ago—is now the escape character for the
    ampersand, resulting in just the ampersand surviving to be written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the entire text string. The first command sets pureDrivel to the
    value Together We Are ^> You ^& Me Alone; then the second command writes the text
    Together We Are > You & Me Alone to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Multilevel escaping can get a bit more complicated. For instance, if you’re
    concatenating two variables into a larger variable before writing that second
    variable to a file, you’ll need three levels of escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the mechanics of triple-level escaping, consider this: because of the
    four escape characters in ^^^^^^^& (that’s seven carets), it resolves to ^^^&.
    A second round of escaping sees this resolve to ^&, which ultimately resolves
    to & on the third round. The number of escape characters is 2*^n* – 1, where *n*
    is the number of escapes. I said it was tricky, but it’s also pretty cool.'
  prefs: []
  type: TYPE_NORMAL
- en: The Continuation Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On more than one occasion, I’ve heard coders refer to the caret as the Batch
    *continuation character*, and I even introduced it as such in [Chapter 5](chapter5.xhtml)
    with an example that used it in a set command spanning four lines of code. Technically,
    that’s incorrect, but in practice, it does perform this function. Allow me to
    explain.
  prefs: []
  type: TYPE_NORMAL
- en: It should be the goal of every coder to write code that does not force the reader
    to scroll right and left. (It should also be efficient, well-documented, well-organized,
    and even elegant, but maybe that’s just my opinion, so I digress.) In most compiled
    languages when a command gets too long to easily read, you simply press ENTER
    and continue typing on the next line. The compiler is smart enough to know that
    the command encompasses two, three, or even more, lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Batch interpreter isn’t that forgiving (or smart), but when you append
    a caret to the *very end* of a line of code, the statement continues on the following
    line. Even when a line isn’t particularly long, I sometimes use this technique
    to line up the arguments I’m passing to an executable for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the end of most lines in a text file, two bytes represent the *carriage return
    line feed*. In hex, the bytes are x'0D' x'0A', and together they are often referred
    to as the CRLF, but they are not usually visible in the text editor. (If using
    Notepad++, select **View** ▶ **Show Symbol** ▶ **Show End of Line** to make the
    CRLFs visible. Other editors have a similar feature.)
  prefs: []
  type: TYPE_NORMAL
- en: In reality, the caret is still just an escape character, and it’s escaping the
    CRLF. In keeping with what an escape character does, when the interpreter sees
    the caret, it doesn’t treat the CRLF following as it normally would—that is, as
    the end of a line. Instead, it just treats the CRLF as any other whitespace and
    ignores it, essentially wrapping the line. In this way, the caret is the “continuation
    character.” (But I still cringe.)
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake that invalidates this text wrapping is to append the line apparently
    ending in a caret with a space or two after the caret. Since the caret escapes
    the very next character, this does nothing more than escape a space, which is
    pretty close to doing nothing at all and leaves the CRLF undisturbed. This oversight
    can be very difficult to troubleshoot for those who simply think of the caret
    as a continuation character instead of as an escape character for the CRLF. Knowledge
    is power.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned that single characters are escaped by a single escape character,
    except for the exclamation mark, which requires two escape characters. The CRLF
    is yet another exception, but for the opposite reason. The CRLF is actually two
    characters, the carriage return character and the line feed character, and it’s
    the only example in Batch of two characters escaped by a lone character.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned the many ways to use the caret, and sometimes the
    percent sign, to escape special characters, but the discussion is just beginning.
    This technique is an indispensable tool, and you’ll see more than one application
    of it later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If nothing else, I hope this chapter has demonstrated how very tricky escaping
    can be. When I was a novice Batch coder, I received some simple, yet sage, advice
    about escaping from a more experienced co-worker. The advice was to test diligently;
    test all possible characters that the code might reasonably encounter in the data.
    With so many caveats, batveats, and exceptions, you shouldn’t assume that escaping
    will work in all contexts after seeing it work in one particular context. In your
    test plan, pepper the code doing the escaping with all of the special characters
    that could possibly come its way.
  prefs: []
  type: TYPE_NORMAL
- en: For something completely different, the next chapter will discuss how a bat
    file can work interactively with a human, asking questions, getting responses,
    and performing conditional logic based on those answers.
  prefs: []
  type: TYPE_NORMAL
