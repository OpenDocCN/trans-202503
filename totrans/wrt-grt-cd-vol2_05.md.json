["```\ngcc -O2 -S t1.c     # -O2 option is for optimization\n```", "```\ncl -O2 -FA t1.c\n```", "```\n\n\t\t\t#include <stdio.h>\nint main( int argc, char **argv )\n{\n    int i;\n    int j;\n\n    i = argc;\n    j = **argv;\n\n    if( i == 2 )\n    {\n        ++j;\n    }\n    else\n    {\n        --j;\n    }\n\n    printf( \"i=%d, j=%d\\n\", i, j );\n    return 0;\n}\n```", "```\ncl -Fa -O1 t1.c\n```", "```\n\n\t\t\t; Listing generated by Microsoft (R) Optimizing\n; Compiler Version 19.00.24234.1\n; This listing is manually annotated for readability.\n\ninclude listing.inc\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC  __local_stdio_printf_options\nPUBLIC  _vfprintf_l\nPUBLIC  printf\nPUBLIC  main\nPUBLIC  ??_C@_0M@MJLDLLNK@i?$DN?$CFd?0?5j?$DN?$CFd?6?$AA@ ; `string'\nEXTRN   __acrt_iob_func:PROC\nEXTRN   __stdio_common_vfprintf:PROC\n_DATA   SEGMENT\nCOMM    ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD                                                    ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n_DATA   ENDS\n;       COMDAT pdata\npdata   SEGMENT\n    .\n    .\n    .\n;       COMDAT main\n_TEXT   SEGMENT\nargc$ = 48\nargv$ = 56\nmain    PROC                                            ; COMDAT\n\n$LN6:\n        sub     rsp, 40                                 ; 00000028H\n\n; if( i == 2 )\n;{\n;    ++j;\n;}\n;else\n;{\n;    --j\n;}\n\n        mov     rax, QWORD PTR [rdx]   ; rax (i) = *argc\n        cmp     ecx, 2\n        movsx   edx, BYTE PTR [rax]    ; rdx(j) = **argv\n\n        lea     eax, DWORD PTR [rdx-1] ; rax = ++j\n        lea     r8d, DWORD PTR [rdx+1] ; r8d = --j;\n\n        mov     edx, ecx               ; edx = argc (argc was passed in rcx)\n        cmovne  r8d, eax               ; eax = --j if i != 2\n\n; printf( \"i=%d, j+5d\\n\", i, j ); (i in edx, j in eax)\n\n        lea     rcx, OFFSET FLAT:??_C@_0M@MJLDLLNK@i?$DN?$CFd?0?5j?$DN?$CFd?6?$AA@\n        call    printf\n\n; return 0;\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File c:\\program files (x86)\\windows kits\\10\\include\\10.0.17134.0\\ucrt\\stdio.h\n;       COMDAT printf\n_TEXT   SEGMENT\n    .\n    .\n    .\n    END\n```", "```\n\n\t\t\tgcc -O1 -S t1.c\n\n.data\n.cstring\n        .align 2\nLC0:\n        .ascii \"i=%d, j=%d\\12\\0\"\n.text\n        .align 2\n        .globl _main\n_main:\nLFB1:\n        mflr r0\n        stw r31,-4(r1)\nLCFI0:\n        stw r0,8(r1)\nLCFI1:\n        stwu r1,-80(r1)\nLCFI2:\n        bcl 20,31,L1$pb\nL1$pb:\n        mflr r31\n        mr r11,r3\n        lwz r9,0(r4)\n        lbz r0,0(r9)\n        extsb r5,r0\n        cmpwi cr0,r3,2\n        bne+ cr0,L2\n        addi r5,r5,1\n        b L3\nL2:\n        addi r5,r5,-1\nL3:\n        addis r3,r31,ha16(LC0-L1$pb)\n        la r3,lo16(LC0-L1$pb)(r3)\n        mr r4,r11\n        bl L_printf$stub\n        li r3,0\n        lwz r0,88(r1)\n        addi r1,r1,80\n        mtlr r0\n        lwz r31,-4(r1)\n        blr\nLFE1:\n.data\n.picsymbol_stub\nL_printf$stub:\n        .indirect_symbol _printf\n        mflr r0\n        bcl 20,31,L0$_printf\nL0$_printf:\n        mflr r11\n        addis r11,r11,ha16(L_printf$lazy_ptr-L0$_printf)\n        mtlr r0\n        lwz r12,lo16(L_printf$lazy_ptr-L0$_printf)(r11)\n        mtctr r12\n        addi r11,r11,lo16(L_printf$lazy_ptr-L0$_printf)\n        bctr\n.data\n.lazy_symbol_pointer\nL_printf$lazy_ptr:\n        .indirect_symbol _printf\n        .long dyld_stub_binding_helper\n.data\n.constructor\n.data\n.destructor\n        .align 1\n```", "```\n\n\t\t\t      .section    __TEXT,__text,regular,pure_instructions\n    .macosx_version_min 10, 13\n    .globl  _main                   ## -- Begin function main\n    .p2align    4, 0x90\n_main:                              ## @main\n    .cfi_startproc\n## BB#0:\n    pushq   %rbp\nLcfi0:\n    .cfi_def_cfa_offset 16\nLcfi1:\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\nLcfi2:\n    .cfi_def_cfa_register %rbp\n    movl    %edi, %ecx\n    movq    (%rsi), %rax\n    movsbl  (%rax), %eax\n    cmpl    $2, %ecx\n    movl    $1, %esi\n    movl    $-1, %edx\n    cmovel  %esi, %edx\n    addl    %eax, %edx\n    leaq    L_.str(%rip), %rdi\n    xorl    %eax, %eax\n    movl    %ecx, %esi\n    callq   _printf\n    xorl    %eax, %eax\n    popq    %rbp\n    retq\n    .cfi_endproc\n                                        ## -- End function\n    .section    __TEXT,__cstring,cstring_literals\nL_.str:                                 ## @.str\n    .asciz  \"i=%d, j=%d\\n\"\n\n.subsections_via_symbols\n```", "```\n\n\t\t\t..arch armv6\n    .eabi_attribute 27, 3\n    .eabi_attribute 28, 1\n    .fpu vfp\n    .eabi_attribute 20, 1\n    .eabi_attribute 21, 1\n    .eabi_attribute 23, 3\n    .eabi_attribute 24, 1\n    .eabi_attribute 25, 1\n    .eabi_attribute 26, 2\n    .eabi_attribute 30, 2\n    .eabi_attribute 34, 1\n    .eabi_attribute 18, 4\n    .file   \"t1.c\"\n    .section    .text.startup,\"ax\",%progbits\n    .align  2\n    .global main\n    .type   main, %function\nmain:\n    @ args = 0, pretend = 0, frame = 0\n    @ frame_needed = 0, uses_anonymous_args = 0\n    stmfd   sp!, {r3, lr}\n    cmp r0, #2\n    ldr r3, [r1]\n    mov r1, r0\n    ldr r0, .L5\n    ldrb    r2, [r3]    @ zero_extendqisi2\n    addeq   r2, r2, #1\n    subne   r2, r2, #1\n    bl  printf\n    mov r0, #0\n    ldmfd   sp!, {r3, pc}\n.L6:\n    .align  2\n.L5:\n    .word   .LC0\n    .size   main, .-main\n    .section    .rodata.str1.4,\"aMS\",%progbits,1\n    .align  2\n.LC0:\n    .ascii  \"i=%d, j=%d\\012\\000\"\n    .ident  \"GCC: (Raspbian 4.9.2-10) 4.9.2\"\n    .section    .note.GNU-stack,\"\",%progbits\n```", "```\nswiftc -O -emit-assembly main.swift -o result.asm\n```", "```\n\n\t\t\timport Foundation\n\nvar i:Int = 0;\nvar j:Int = 1;\n\n    if( i == 2 )\n    {\n        i = i + 1\n    }\n    else\n    {\n        i = i - 1\n    }\n\n    print( \"i=\\(i), j=\\(j)\" )\n```", "```\n\n\t\t\t_main:\n.cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    pushq   %r15\n    pushq   %r14\n    pushq   %r13\n    pushq   %r12\n    pushq   %rbx\n    pushq   %rax\n    .cfi_offset %rbx, -56\n    .cfi_offset %r12, -48\n    .cfi_offset %r13, -40\n    .cfi_offset %r14, -32\n    .cfi_offset %r15, -24\n    movq    $1, _$S6result1jSivp(%rip)\n    movq    $-1, _$S6result1iSivp(%rip)\n    movq    _$Ss23_ContiguousArrayStorageCyypGML(%rip), %rdi\n    testq   %rdi, %rdi\n    jne LBB0_3\n    movq    _$SypN@GOTPCREL(%rip), %rsi\n    addq    $8, %rsi\n    xorl    %edi, %edi\n    callq   _$Ss23_ContiguousArrayStorageCMa\n    movq    %rax, %rdi\n    testq   %rdx, %rdx\n    jne LBB0_3\n    movq    %rdi, _$Ss23_ContiguousArrayStorageCyypGML(%rip)\nLBB0_3:\n    movabsq $8589934584, %r12\n    movl    48(%rdi), %esi\n    movzwl  52(%rdi), %edx\n    addq    $7, %rsi\n    andq    %r12, %rsi\n    addq    $32, %rsi\n    orq $7, %rdx\n    callq   _swift_allocObject\n    movq    %rax, %r14\n    movq    _$Ss27_ContiguousArrayStorageBaseC16countAndCapacitys01_B4BodyVvpWvd@GOTPCREL(%rip), %rbx\n    movq    (%rbx), %r15\n    movaps  LCPI0_0(%rip), %xmm0\n    movups  %xmm0, (%r14,%r15)\n    movq    _$SSSN@GOTPCREL(%rip), %rax\n    movq    %rax, 56(%r14)\n    movq    _$Ss23_ContiguousArrayStorageCySSGML(%rip), %rdi\n    testq   %rdi, %rdi\n    jne LBB0_6\n    movq    _$SSSN@GOTPCREL(%rip), %rsi\n    xorl    %edi, %edi\n    callq   _$Ss23_ContiguousArrayStorageCMa\n    movq    %rax, %rdi\n    testq   %rdx, %rdx\n    jne LBB0_6\n    movq    %rdi, _$Ss23_ContiguousArrayStorageCySSGML(%rip)\n    movq    (%rbx), %r15\nLBB0_6:\n    movl    48(%rdi), %esi\n    movzwl  52(%rdi), %edx\n    addq    $7, %rsi\n    andq    %r12, %rsi\n    addq    $80, %rsi\n    orq $7, %rdx\n    callq   _swift_allocObject\n    movq    %rax, %rbx\n    movaps  LCPI0_1(%rip), %xmm0\n    movups  %xmm0, (%rbx,%r15)\n    movabsq $-2161727821137838080, %r15\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRetain\n    movl    $15721, %esi\n    movq    %r15, %rdi\n    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n\n    movq    %rax, %r12\n    movq    %rdx, %r13\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRelease\n    movq    %r12, 32(%rbx)\n    movq    %r13, 40(%rbx)\n    movq    _$S6result1iSivp(%rip), %rdi\n    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5\n    movq    %rax, 48(%rbx)\n    movq    %rdx, 56(%rbx)\n    movabsq $-2017612633061982208, %r15\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRetain\n    movl    $1030365228, %esi\n    movq    %r15, %rdi\n    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n\n    movq    %rax, %r12\n    movq    %rdx, %r13\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRelease\n    movq    %r12, 64(%rbx)\n    movq    %r13, 72(%rbx)\n    movq    _$S6result1jSivp(%rip), %rdi\n    callq   _$Ss26_toStringReadOnlyPrintableySSxs06CustomB11ConvertibleRzlFSi_Tg5\n    movq    %rax, 80(%rbx)\n    movq    %rdx, 88(%rbx)\n    movabsq $-2305843009213693952, %r15\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRetain\n    xorl    %esi, %esi\n    movq    %r15, %rdi\n    callq   _$Ss27_toStringReadOnlyStreamableySSxs010TextOutputE0RzlFSS_Tg5Tf4x_n\n    movq    %rax, %r12\n    movq    %rdx, %r13\n    movq    %r15, %rdi\n    callq   _swift_bridgeObjectRelease\n    movq    %r12, 96(%rbx)\n    movq    %r13, 104(%rbx)\n    movq    %rbx, %rdi\n    callq   _$SSS19stringInterpolationS2Sd_tcfCTf4nd_n\n    movq    %rax, 32(%r14)\n    movq    %rdx, 40(%r14)\n    callq   _$Ss5print_9separator10terminatoryypd_S2StFfA0_\n    movq    %rax, %r12\n    movq    %rdx, %r15\n    callq   _$Ss5print_9separator10terminatoryypd_S2StFfA1_\n    movq    %rax, %rbx\n    movq    %rdx, %rax\n    movq    %r14, %rdi\n    movq    %r12, %rsi\n    movq    %r15, %rdx\n    movq    %rbx, %rcx\n    movq    %rax, %r8\n    callq   _$Ss5print_9separator10terminatoryypd_S2StF\n    movq    %r14, %rdi\n    callq   _swift_release\n    movq    %r12, %rdi\n    callq   _swift_bridgeObjectRelease\n    movq    %rbx, %rdi\n    callq   _swift_bridgeObjectRelease\n    xorl    %eax, %eax\n    addq    $8, %rsp\n    popq    %rbx\n    popq    %r12\n    popq    %r13\n    popq    %r14\n    popq    %r15\n    popq    %rbp\n    retq\n    .cfi_endproc\n```", "```\n\n\t\t\tdumpbin options filename\n```", "```\n\n\t\t\tMicrosoft (R) COFF/PE Dumper Version 14.00.24234.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nusage: dumpbin options files\n\n   options:\n\n      /ALL\n      /ARCHIVEMEMBERS\n      /CLRHEADER\n      /DEPENDENTS\n      /DIRECTIVES\n      /DISASM[:{BYTES|NOBYTES}]\n      /ERRORREPORT:{NONE|PROMPT|QUEUE|SEND}\n      /EXPORTS\n      /FPO\n      /HEADERS\n      /IMPORTS[:filename]\n      /LINENUMBERS\n      /LINKERMEMBER[:{1|2}]\n      /LOADCONFIG\n      /NOLOGO\n      /OUT:filename\n      /PDATA\n      /PDBPATH[:VERBOSE]\n      /RANGE:vaMin[,vaMax]\n      /RAWDATA[:{NONE|1|2|4|8}[,#]]\n      /RELOCATIONS\n      /SECTION:name\n      /SUMMARY\n      /SYMBOLS\n      /TLS\n      /UNWINDINFO\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint main( int argc, char **argv)\n{\n    printf( \"Hello World\\n\" );\n}\n```", "```\n\n\t\t\tG:\\>dumpbin /all hw.obj\nMicrosoft (R) COFF/PE Dumper Version 14.00.24234.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nDump of file hw.obj\n\nFile Type: COFF OBJECT\n\nFILE HEADER VALUES\n            8664 machine (x64)\n               D number of sections\n        5B2C175F time date stamp Thu Jun 21 14:23:43 2018\n             466 file pointer to symbol table\n              2D number of symbols\n               0 size of optional header\n               0 characteristics\n\nSECTION HEADER #1\n.drectve name\n       0 physical address\n       0 virtual address\n      2F size of raw data\n     21C file pointer to raw data (0000021C to 0000024A)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n  100A00 flags\n         Info\n         Remove\n         1 byte align\n\nHundreds of lines deleted...\n\n  Summary\n\n           D .data\n          70 .debug$S\n          2F .drectve\n          24 .pdata\n          C2 .text$mn\n          18 .xdata\n```", "```\n\n\t\t\tMicrosoft (R) COFF/PE Dumper Version 14.00.24234.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nDump of file hw.obj\n\nFile Type: COFF OBJECT\n\nmain:\n  0000000000000000: 48 89 54 24 10     mov         qword ptr [rsp+10h],rdx\n  0000000000000005: 89 4C 24 08        mov         dword ptr [rsp+8],ecx\n  0000000000000009: 48 83 EC 28        sub         rsp,28h\n  000000000000000D: 48 8D 0D 00 00 00  lea         rcx,[$SG4247]\n                    00\n  0000000000000014: E8 00 00 00 00     call        printf\n  0000000000000019: 33 C0              xor         eax,eax\n  000000000000001B: 48 83 C4 28        add         rsp,28h\n  000000000000001F: C3                 ret\n\n// Uninterested code emitted by dumpbin.exe left out...\n\n  Summary\n\n           D .data\n          70 .debug$S\n          2F .drectve\n          24 .pdata\n          C2 .text$mn\n          28 .xdata\n```", "```\n\n\t\t\t000000000000000D:  48 8D 0D 00 00 00  lea         rcx,[$SG4247]\n                   00\n0000000000000014:  E8 00 00 00 00     call        printf\n```", "```\n\n\t\t\tRELOCATIONS #4\n                                                Symbol    Symbol\n Offset    Type              Applied To         Index     Name\n --------  ----------------  -----------------  --------  ------\n 00000010  REL32                      00000000         8  $SG4247\n 00000015  REL32                      00000000        15  printf\n```", "```\n\n\t\t\t0000000140001009: 48 83 EC 28        sub         rsp,28h\n000000014000100D: 48 8D 0D EC DF 01  lea         rcx,[000000014001F000h]\n                  00\n0000000140001014: E8 67 00 00 00     call        0000000140001080\n0000000140001019: 33 C0              xor         eax,eax\n000000014000101B: 48 83 C4 28        add         rsp,28h\n000000014000101F: C3                 ret\n                              .\n                              .\n                              .\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint main( int argc, char **argv)\n{\n        char *hwstr = \"Hello World\\n\";\n\n        printf( hwstr );\n}\n```", "```\n\n\t\t\tMicrosoft (R) COFF Binary File Dumper Version 6.00.8168\n  0000000140001000: 48 89 54 24 10     mov         qword ptr [rsp+10h],rdx\n  0000000140001005: 89 4C 24 08        mov         dword ptr [rsp+8],ecx\n  0000000140001009: 48 83 EC 28        sub         rsp,28h\n  000000014000100D: 48 8D 0D EC DF 01  lea         rcx,[000000014001F000h]\n                    00\n  0000000140001014: E8 67 00 00 00     call        0000000140001080\n  0000000140001019: 33 C0              xor         eax,eax\n  000000014000101B: 48 83 C4 28        add         rsp,28h\n  000000014000101F: C3                 ret\n```", "```\n\n\t\t\tG:\\WGC>dumpbin /headers hw.exe\nMicrosoft (R) COFF/PE Dumper Version 14.00.24234.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nDump of file hw.exe\n\nPE signature found\n\nFile Type: EXECUTABLE IMAGE\n\nFILE HEADER VALUES\n            8664 machine (x64)\n               6 number of sections\n        5B2C1A9F time date stamp Thu Jun 21 14:37:35 2018\n               0 file pointer to symbol table\n               0 number of symbols\n              F0 size of optional header\n              22 characteristics\n                   Executable\n                   Application can handle large (>2GB) addresses\n\nOPTIONAL HEADER VALUES\n             20B magic # (PE32+)\n           14.00 linker version\n           13400 size of code\n            D600 size of initialized data\n               0 size of uninitialized data\n            1348 entry point (0000000140001348)\n            1000 base of code\n       140000000 image base (0000000140000000 to 0000000140024FFF)\n            1000 section alignment\n             200 file alignment\n            6.00 operating system version\n            0.00 image version\n            6.00 subsystem version\n               0 Win32 version\n           25000 size of image\n             400 size of headers\n               0 checksum\n               3 subsystem (Windows CUI)\n            8160 DLL characteristics\n                   High Entropy Virtual Addresses\n                   Dynamic base\n                   NX compatible\n                   Terminal Server Aware\n          100000 size of stack reserve\n            1000 size of stack commit\n          100000 size of heap reserve\n            1000 size of heap commit\n               0 loader flags\n              10 number of directories\n               0 [       0] RVA [size] of Export Directory\n           1E324 [      28] RVA [size] of Import Directory\n               0 [       0] RVA [size] of Resource Directory\n           21000 [    126C] RVA [size] of Exception Directory\n               0 [       0] RVA [size] of Certificates Directory\n           24000 [     620] RVA [size] of Base Relocation Directory\n           1CDA0 [      1C] RVA [size] of Debug Directory\n               0 [       0] RVA [size] of Architecture Directory\n               0 [       0] RVA [size] of Global Pointer Directory\n               0 [       0] RVA [size] of Thread Storage Directory\n           1CDC0 [      94] RVA [size] of Load Configuration Directory\n               0 [       0] RVA [size] of Bound Import Directory\n           15000 [     230] RVA [size] of Import Address Table Directory\n               0 [       0] RVA [size] of Delay Import Directory\n               0 [       0] RVA [size] of COM Descriptor Directory\n               0 [       0] RVA [size] of Reserved Directory\n\nSECTION HEADER #1\n   .text name\n   1329A virtual size\n    1000 virtual address (0000000140001000 to 0000000140014299)\n   13400 size of raw data\n     400 file pointer to raw data (00000400 to 000137FF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n60000020 flags\n         Code\n         Execute Read\n\nSECTION HEADER #2\n  .rdata name\n    9A9A virtual size\n   15000 virtual address (0000000140015000 to 000000014001EA99)\n    9C00 size of raw data\n   13800 file pointer to raw data (00013800 to 0001D3FF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n40000040 flags\n         Initialized Data\n         Read Only\n\n  Debug Directories\n        Time Type        Size      RVA  Pointer\n    -------- ------- -------- -------- --------\n    5B2C1A9F coffgrp      2CC 0001CFC4    1B7C4\n\nSECTION HEADER #3\n   .data name\n    1BA8 virtual size\n   1F000 virtual address (000000014001F000 to 0000000140020BA7)\n     A00 size of raw data\n   1D400 file pointer to raw data (0001D400 to 0001DDFF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\nC0000040 flags\n         Initialized Data\n         Read Write\n\nSECTION HEADER #4\n  .pdata name\n    126C virtual size\n   21000 virtual address (0000000140021000 to 000000014002226B)\n    1400 size of raw data\n   1DE00 file pointer to raw data (0001DE00 to 0001F1FF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n40000040 flags\n         Initialized Data\n         Read Only\n\nSECTION HEADER #5\n  .gfids name\n      D4 virtual size\n   23000 virtual address (0000000140023000 to 00000001400230D3)\n     200 size of raw data\n   1F200 file pointer to raw data (0001F200 to 0001F3FF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n40000040 flags\n         Initialized Data\n         Read Only\n\nSECTION HEADER #6\n  .reloc name\n     620 virtual size\n   24000 virtual address (0000000140024000 to 000000014002461F)\n     800 size of raw data\n   1F400 file pointer to raw data (0001F400 to 0001FBFF)\n       0 file pointer to relocation table\n       0 file pointer to line numbers\n       0 number of relocations\n       0 number of line numbers\n42000040 flags\n         Initialized Data\n         Discardable\n         Read Only\n\n  Summary\n\n        2000 .data\n        1000 .gfids\n        2000 .pdata\n        A000 .rdata\n        1000 .reloc\n       14000 .text\n```", "```\n\n\t\t\tUsage: objdump <option(s)> <file(s)>\nUsage: objdump <option(s)> <file(s)>\nDisplay information from object <file(s)>.\nAt least one of the following switches must be given:\n  -a, --archive-headers    Display archive header information\n  -f, --file-headers       Display the contents of the overall file header\n  -p, --private-headers    Display object format specific file header contents\n  -P, --private=OPT,OPT... Display object format specific contents\n  -h, --[section-]headers  Display the contents of the section headers\n  -x, --all-headers        Display the contents of all headers\n  -d, --disassemble        Display assembler contents of executable sections\n  -D, --disassemble-all    Display assembler contents of all sections\n  -S, --source             Intermix source code with disassembly\n  -s, --full-contents      Display the full contents of all sections requested\n  -g, --debugging          Display debug information in object file\n  -e, --debugging-tags     Display debug information using ctags style\n  -G, --stabs              Display (in raw form) any STABS info in the file\n  -W[lLiaprmfFsoRt] or\n  --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n          =frames-interp,=str,=loc,=Ranges,=pubtypes,\n          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n          =addr,=cu_index]\n                           Display DWARF info in the file\n  -t, --syms               Display the contents of the symbol table(s)\n  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n  -r, --reloc              Display the relocation entries in the file\n  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n  @<file>                  Read options from <file>\n  -v, --version            Display this program's version number\n  -i, --info               List object formats and architectures supported\n  -H, --help               Display this information\n\n The following switches are optional:\n  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n  -j, --section=NAME             Only display information for section NAME\n  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n  -EB --endian=big               Assume big endian format when disassembling\n  -EL --endian=little            Assume little endian format when disassembling\n      --file-start-context       Include context from start of file (with -S)\n  -I, --include=DIR              Add DIR to search list for source files\n  -l, --line-numbers             Include line numbers and filenames in output\n  -F, --file-offsets             Include file offsets when displaying information\n  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n                                 The STYLE, if specified, can be `auto', `gnu',\n                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n                                  or `gnat'\n  -w, --wide                     Format output for more than 80 columns\n  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n      --start-address=ADDR       Only process data whose address is >= ADDR\n      --stop-address=ADDR        Only process data whose address is <= ADDR\n      --prefix-addresses         Print complete address alongside disassembly\n      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n      --insn-width=WIDTH         Display WIDTH bytes on a single line for -d\n      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n      --special-syms             Include special symbols in symbol dumps\n      --prefix=PREFIX            Add PREFIX to absolute paths for -S\n      --prefix-strip=LEVEL       Strip initial directory names for -S\n      --dwarf-depth=N            Do not display DIEs at depth N or greater\n      --dwarf-start=N            Display DIEs starting with N, at the same depth\n                                 or deeper\n      --dwarf-check              Make additional dwarf internal consistency checks.\n\nobjdump: supported targets: elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 a.out-i386-linux pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 plugin srec symbolsrec verilog tekhex binary ihex\nobjdump: supported architectures: i386 i386:x86-64 i386:x64-32 i8086 i386:intel i386:x86-64:intel i386:x64-32:intel i386:nacl i386:x86-64:nacl i386:x64-32:nacl iamcu iamcu:intel l1om l1om:intel k1om k1om:intel plugin\nThe following i386/x86-64 specific disassembler options are supported for use\nwith the -M switch (multiple options should be separated by commas):\n  x86-64          Disassemble in 64bit mode\n  i386            Disassemble in 32bit mode\n  i8086           Disassemble in 16bit mode\n  att             Display instruction in AT&T syntax\n  intel           Display instruction in Intel syntax\n  att-mnemonic    Display instruction in AT&T mnemonic\n  intel-mnemonic  Display instruction in Intel mnemonic\n  addr64          Assume 64bit address size\n  addr32          Assume 32bit address size\n  addr16          Assume 16bit address size\n  data32          Assume 32bit data size\n  data16          Assume 16bit data size\n  suffix          Always display instruction suffix in AT&T syntax\n  amd64           Display instruction in AMD64 ISA\n  intel64         Display instruction in Intel64 ISA\nReport bugs to <http://www.sourceware.org/bugzilla/>.\n```", "```\n\n\t\t\tbegin t;\n\n        // test mem.alloc and mem.free:\n\n        for( mov( 0, ebx ); ebx < 16; inc( ebx )) do\n\n                // Allocate lots of storage:\n\n                for( mov( 0, ecx ); ecx < 65536; inc( ecx )) do\n\n                        rand.range( 1, 256 );\n                        malloc( eax );\n                        mov( eax, ptrs[ ecx*4 ] );\n\n                endfor;\n                   .\n                   .\n                   .\n```", "```\n\n\t\t\t        objdump -S m\n\n 0804807e <_HLAMain>:\n 804807e:   89 e0                   mov    %esp,%eax\n\n        .\n        . // Some deleted code here,\n        . // that HLA automatically generated.\n        .\n\n 80480ae:   bb 00 00 00 00          mov    $0x0,%ebx\n 80480b3:   eb 2a                   jmp    80480df <StartFor__hla_2124>\n\n080480b5 <for__hla_2124>:\n 80480b5:   b9 00 00 00 00          mov    $0x0,%ecx\n 80480ba:   eb 1a                   jmp    80480d6 <StartFor__hla_2125>\n\n080480bc <for__hla_2125>:\n 80480bc:   6a 01                   push   $0x1\n 80480be:   68 00 01 00 00          push   $0x100\n 80480c3:   e8 64 13 00 00          call   804942c <RAND_RANGE>\n 80480c8:   50                      push   %eax\n 80480c9:   e8 6f 00 00 00          call   804813d <MEM_ALLOC1>\n 80480ce:   89 04 8d 68 c9 04 08    mov    %eax,0x804c968(,%ecx,4)\n\n080480d5 <continue__hla_2125>:\n 80480d5:   41                      inc    %ecx\n\n080480d6 <StartFor__hla_2125>:\n 80480d6:   81 f9 00 00 01 00       cmp    $0x10000,%ecx\n 80480dc:   72 de                   jb     80480bc <for__hla_2125>\n\n080480de <continue__hla_2124>:\n 80480de:   43                      inc    %ebx\n\n080480df <StartFor__hla_2124>:\n 80480df:   83 fb 10                cmp    $0x10,%ebx\n 80480e2:   72 d1                   jb     80480b5 <for__hla_2124>\n\n080480e4 <QuitMain__hla_>:\n 80480e4:   b8 01 00 00 00          mov    $0x1,%eax\n 80480e9:   31 db                   xor    %ebx,%ebx\n 80480eb:   cd 80                   int    $0x80\n 8048274:   bb 00 00 00 00          mov    $0x0,%ebx\n 8048279:   e9 d5 00 00 00          jmp    8048353 <L1021_StartFor__hla_>\n 0804827e <L1021_for__hla_>:\n 804827e:   b9 00 00 00 00          mov    $0x0,%ecx\n 8048283:   eb 1a                   jmp    804829f <L1022_StartFor__hla_>\n\n08048285 <L1022_for__hla_>:\n 8048285:   6a 01                   push   $0x1\n 8048287:   68 00 01 00 00          push   $0x100\n 804828c:   e8 db 15 00 00          call   804986c <RAND_RANGE>\n 8048291:   50                      push   %eax\n 8048292:   e8 63 0f 00 00          call   80491fa <MEM_ALLOC>\n 8048297:   89 04 8d 60 ae 04 08    mov    %eax,0x804ae60(,%ecx,4)\n\n0804829e <L1022_continue__hla_>:\n 804829e:   41                      inc    %ecx\n\n0804829f <L1022_StartFor__hla_>:\n 804829f:   81 f9 00 00 01 00       cmp    $0x10000,%ecx\n 80482a5:   72 de                   jb     8048285 <L1022_for__hla_>\n\n080482a7 <L1022_exitloop__hla_>:\n 80482a7:   b9 00 00 00 00          mov    $0x0,%ecx\n 80482ac:   eb 0d                   jmp    80482bb <L1023_StartFor__hla_>\n```", "```\n\n\t\t\t// Original C code:\n\n#include <stdio.h>\nint main( int argc, char **argv )\n{\n    int i,j,k;\n\n    j = **argv;\n    k = argc;\n    i = j && k;\n    printf( \"%d\\n\", i );\n    return 0;\n}\n```", "```\n\n\t\t\t    .file   \"t.c\"\n    .section    .rodata\n.LC0:\n    .string \"%d\\n\"\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n.LFB0:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    subq    $32, %rsp\n    movl    %edi, -20(%rbp)\n    movq    %rsi, -32(%rbp)\n    movq    -32(%rbp), %rax\n    movq    (%rax), %rax\n    movzbl  (%rax), %eax\n    movsbl  %al, %eax\n    movl    %eax, -12(%rbp)\n    movl    -20(%rbp), %eax\n    movl    %eax, -8(%rbp)\n    cmpl    $0, -12(%rbp)\n    je  .L2\n    cmpl    $0, -8(%rbp)\n    je  .L2\n    movl    $1, %eax\n    jmp .L3\n.L2:\n    movl    $0, %eax\n.L3:\n    movl    %eax, -4(%rbp)\n    movl    -4(%rbp), %eax\n    movl    %eax, %esi\n    movl    $.LC0, %edi\n    movl    $0, %eax\n    call    printf\n    movl    $0, %eax\n    leave\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size   main, .-main\n    .ident  \"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n    .section    .note.GNU-stack,\"\",@progbits\n```", "```\n\n\t\t\t.file   \"t.c\"\n\n0000000000400526 <main>:\n  400526:   55                      push   %rbp\n  400527:   48 89 e5                mov    %rsp,%rbp\n  40052a:   48 83 ec 20             sub    $0x20,%rsp\n  40052e:   89 7d ec                mov    %edi,-0x14(%rbp)\n  400531:   48 89 75 e0             mov    %rsi,-0x20(%rbp)\n  400535:   48 8b 45 e0             mov    -0x20(%rbp),%rax\n  400539:   48 8b 00                mov    (%rax),%rax\n  40053c:   0f b6 00                movzbl (%rax),%eax\n  40053f:   0f be c0                movsbl %al,%eax\n  400542:   89 45 f4                mov    %eax,-0xc(%rbp)\n  400545:   8b 45 ec                mov    -0x14(%rbp),%eax\n  400548:   89 45 f8                mov    %eax,-0x8(%rbp)\n  40054b:   83 7d f4 00             cmpl   $0x0,-0xc(%rbp)\n  40054f:   74 0d                   je     40055e <main+0x38>\n  400551:   83 7d f8 00             cmpl   $0x0,-0x8(%rbp)\n  400555:   74 07                   je     40055e <main+0x38>\n  400557:   b8 01 00 00 00          mov    $0x1,%eax\n  40055c:   eb 05                   jmp    400563 <main+0x3d>\n  40055e:   b8 00 00 00 00          mov    $0x0,%eax\n  400563:   89 45 fc                mov    %eax,-0x4(%rbp)\n  400566:   8b 45 fc                mov    -0x4(%rbp),%eax\n  400569:   89 c6                   mov    %eax,%esi\n  40056b:   bf 14 06 40 00          mov    $0x400614,%edi\n  400570:   b8 00 00 00 00          mov    $0x0,%eax\n  400575:   e8 86 fe ff ff          callq  400400 <printf@plt>\n  40057a:   b8 00 00 00 00          mov    $0x0,%eax\n  40057f:   c9                      leaveq\n  400580:   c3                      retq\n```", "```\n\n\t\t\t; int __cdecl main(int argc, const char **argv, const char **envp)\nmain    proc    near\n        sub     rsp, 28h\n        mov     rax, [rdx]\n        cmp     ecx, 2\n        movsx   edx, byte ptr [rax]\n        lea     eax, [rdx-1]\n        lea     r8d, [rdx+1]\n        mov     edx, ecx\n        cmovnz  r8d, eax\n        lea     rcx, aIDJD      ; \"i=%d, j=%d\\n\"\n        call    sub_140001040\n        xor     eax, eax\n        add     rsp, 28h\n        retn\nmain endp\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static void main( String[] args )\n    {\n        switch(5)\n        {\n            case 0:\n                System.out.println(\"0\");\n                break;\n            case 1:\n                System.out.println(\"1\");\n                break;\n            case 2:\n            case 5:\n                System.out.println(\"5\");\n                break;\n            default:\n                System.out.println(\"default\" );\n        }\n        System.out.println( \"Hello World\" );\n    }\n}\n```", "```\njavac Welcome.java\n```", "```\njavap -c Welcome\n```", "```\n\n\t\t\tCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n   1:   invokespecial   #1; //Method java/lang/Object.\"<init>\":()V\n   4:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   iconst_5\n   1:   tableswitch{ //0 to 5\n        0: 40;\n        1: 51;\n        2: 62;\n        3: 73;\n        4: 73;\n        5: 62;\n        default: 73 }\n   40:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;\n   43:  ldc #3;             //String 0\n   45:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   48:  goto    81\n   51:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;\n   54:  ldc #5;             //String 1\n   56:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   59:  goto    81\n   62:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;\n   65:  ldc #6;             //String 5\n   67:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   70:  goto    81\n   73:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;\n   76:  ldc #7;             //String default\n   78:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   81:  getstatic   #2;     //Field java/lang/System.out:Ljava/io/PrintStream;\n   84:  ldc #8;             //String Hello World\n   86:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   89:  return\n}\n```", "```\n\n\t\t\tusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Hello_World\n{\n    class program\n    {\n        static void Main( string[] args)\n        {\n            int i = 5;\n            int j = 6;\n            int k = i + j;\n            Console.WriteLine(\"Hello World! k={0}\", k);\n        }\n    }\n}\n```", "```\n\n\t\t\t.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // Code size       25 (0x19)\n  .maxstack  2\n  .locals init (int32 V_0,\n           int32 V_1,\n           int32 V_2)\n; push constant 5 on stack\n\n  IL_0000:  ldc.i4.5\n\n; pop stack and store into i\n\n  IL_0001:  stloc.0\n\n; push constant 6 on stack\n\n  IL_0002:  ldc.i4.6\n\n; pop stack and store in j\n\n  IL_0003:  stloc.1\n\n; Push i and j onto stack:\n\n  IL_0004:  ldloc.0\n  IL_0005:  ldloc.1\n\n; Add two items on stack, leave result on stack\n\n  IL_0006:  add\n\n; Store sum into k\n\n  IL_0007:  stloc.2\n\n; Load string onto stack (pointer to string)\n\n  IL_0008:  ldstr      \"Hello World! k={0}\"\n\n; Push k's value onto stack:\n\n  IL_000d:  ldloc.2\n  IL_000e:  box        [mscorlib]System.Int32\n\n; call writeline routine:\n\n  IL_0013:  call       void [mscorlib]System.Console::WriteLine(string,\n                                                                object)\n  IL_0018:  ret\n} // end of method program::Main\n```", "```\n\n\t\t\t--- c:\\users\\rhyde\\test\\t\\t\\t.cpp ----------------------------------------------\n#include \"stdafx.h\"\n#include <stdio.h>\nint main(int argc, char **argv)\n{\n00F61000  push        ebp\n00F61001  mov         ebp,esp\n00F61003  sub         esp,8\n    int i;\n    int j;\n\n    i = argc;\n00F61006  mov         eax,dword ptr [argc]\n00F61009  mov         dword ptr [i],eax\n    j = **argv;\n00F6100C  mov         ecx,dword ptr [argv]\n00F6100F  mov         edx,dword ptr [ecx]\n00F61011  movsx       eax,byte ptr [edx]\n00F61014  mov         dword ptr [j],eax\n\n    if (i == 2)\n00F61017  cmp         dword ptr [i],2\n00F6101B  jne         main+28h (0F61028h)\n    {\n        ++j;\n00F6101D  mov         ecx,dword ptr [j]\n00F61020  add         ecx,1\n00F61023  mov         dword ptr [j],ecx\n    }\n    else\n00F61026  jmp         main+31h (0F61031h)\n    {\n        --j;\n00F61028  mov         edx,dword ptr [j]\n00F6102B  sub         edx,1\n00F6102E  mov         dword ptr [j],edx\n    }\n\n    printf(\"i=%d, j=%d\\n\", i, j);\n00F61031  mov         eax,dword ptr [j]\n00F61034  push        eax\n00F61035  mov         ecx,dword ptr [i]\n00F61038  push        ecx\n00F61039  push        0F620F8h\n00F6103E  call        printf (0F61090h)\n00F61043  add         esp,0Ch\n    return 0;\n00F61046  xor         eax,eax\n}\n00F61048  mov         esp,ebp\n00F6104A  pop         ebp\n00F6104B  ret\n```", "```\n\n\t\t\textern void f( void );\nint main( int argc, char **argv )\n{\n    int boolResult;\n\n    switch( argc )\n    {\n        case 1:\n            f();\n            break;\n\n        case 10:\n            f();\n            break;\n\n        case 100:\n            f();\n            break;\n\n        case 1000:\n            f();\n            break;\n\n        case 10000:\n            f();\n            break;\n\n        case 100000:\n            f();\n            break;\n\n        case 1000000:\n            f();\n            break;\n\n        case 10000000:\n            f();\n            break;\n\n        case 100000000:\n            f();\n            break;\n case 1000000000:\n            f();\n            break;\n\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t  ; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1\n\ninclude listing.inc\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC  main\nEXTRN   f:PROC\npdata   SEGMENT\n$pdata$main DD  imagerel $LN16\n        DD      imagerel $LN16+201\n        DD      imagerel $unwind$main\npdata   ENDS\nxdata   SEGMENT\n$unwind$main DD 010d01H\n        DD      0620dH\nxdata   ENDS\n; Function compile flags: /Odtp\n_TEXT   SEGMENT\ntv64 = 32\nargc$ = 64\nargv$ = 72\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 4\n$LN16:\n        mov     QWORD PTR [rsp+16], rdx\n        mov     DWORD PTR [rsp+8], ecx\n        sub     rsp, 56                                 ; 00000038H\n; Line 7\n        mov     eax, DWORD PTR argc$[rsp]\n        mov     DWORD PTR tv64[rsp], eax\n        cmp     DWORD PTR tv64[rsp], 100000             ; 000186a0H\n        jg      SHORT $LN15@main\n        cmp     DWORD PTR tv64[rsp], 100000             ; 000186a0H\n        je      SHORT $LN9@main\n        cmp     DWORD PTR tv64[rsp], 1\n        je      SHORT $LN4@main\n        cmp     DWORD PTR tv64[rsp], 10\n        je      SHORT $LN5@main\n        cmp     DWORD PTR tv64[rsp], 100                ; 00000064H\n        je      SHORT $LN6@main\n        cmp     DWORD PTR tv64[rsp], 1000               ; 000003e8H\n        je      SHORT $LN7@main\n        cmp     DWORD PTR tv64[rsp], 10000              ; 00002710H\n        je      SHORT $LN8@main\n        jmp     SHORT $LN2@main\n$LN15@main:\n        cmp     DWORD PTR tv64[rsp], 1000000            ; 000f4240H\n        je      SHORT $LN10@main\n        cmp     DWORD PTR tv64[rsp], 10000000           ; 00989680H\n        je      SHORT $LN11@main\n        cmp     DWORD PTR tv64[rsp], 100000000          ; 05f5e100H\n        je      SHORT $LN12@main\n        cmp     DWORD PTR tv64[rsp], 1000000000         ; 3b9aca00H\n        je      SHORT $LN13@main\n        jmp     SHORT $LN2@main\n$LN4@main:\n; Line 10\n        call    f\n; Line 11\n        jmp     SHORT $LN2@main\n$LN5@main:\n; Line 14\n        call    f\n; Line 15\n        jmp     SHORT $LN2@main\n$LN6@main:\n; Line 18\n        call    f\n; Line 19\n        jmp     SHORT $LN2@main\n$LN7@main:\n; Line 22\n        call    f\n; Line 23\n        jmp     SHORT $LN2@main\n$LN8@main:\n; Line 26\n        call    f\n; Line 27\n        jmp     SHORT $LN2@main\n$LN9@main:\n; Line 30\n        call    f\n; Line 31\n        jmp     SHORT $LN2@main\n$LN10@main:\n; Line 34\n        call    f\n; Line 35\n        jmp     SHORT $LN2@main\n$LN11@main:\n; Line 38\n        call    f\n; Line 39\n        jmp     SHORT $LN2@main\n\n$LN12@main:\n; Line 42\n        call    f\n; Line 43\n        jmp     SHORT $LN2@main\n$LN13@main:\n; Line 46\n        call    f\n$LN2@main:\n; Line 50\n        xor     eax, eax\n; Line 51\n        add     rsp, 56                                 ; 00000038H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\nEND\n```", "```\n\n\t\t\t    ; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1\n\ninclude listing.inc\n\nINCLUDELIB LIBCMT\nINCLUDELIB OLDNAMES\n\nPUBLIC  main\nEXTRN   f:PROC\npdata   SEGMENT\n$pdata$main DD  imagerel $LN18\n        DD      imagerel $LN18+89\n        DD      imagerel $unwind$main\npdata   ENDS\nxdata   SEGMENT\n$unwind$main DD 010401H\n        DD      04204H\nxdata   ENDS\n; Function compile flags: /Ogtpy\n_TEXT   SEGMENT\nargc$ = 48\nargv$ = 56\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 4\n$LN18:\n        sub     rsp, 40                                 ; 00000028H\n; Line 7\n        cmp     ecx, 100000                             ; 000186a0H\n        jg      SHORT $LN15@main\n        je      SHORT $LN10@main\n        sub     ecx, 1\n        je      SHORT $LN10@main\n        sub     ecx, 9\n        je      SHORT $LN10@main\n        sub     ecx, 90                                 ; 0000005aH\n        je      SHORT $LN10@main\n        sub     ecx, 900                                ; 00000384H\n        je      SHORT $LN10@main\n        cmp     ecx, 9000                               ; 00002328H\n; Line 27\n        jmp     SHORT $LN16@main\n$LN15@main:\n; Line 7\n        cmp     ecx, 1000000                            ; 000f4240H\n        je      SHORT $LN10@main\n        cmp     ecx, 10000000                           ; 00989680H\n        je      SHORT $LN10@main\n        cmp     ecx, 100000000                          ; 05f5e100H\n        je      SHORT $LN10@main\n        cmp     ecx, 1000000000                         ; 3b9aca00H\n$LN16@main:\n        jne     SHORT $LN2@main\n$LN10@main:\n; Line 34\n        call    f\n$LN2@main:\n; Line 50\n        xor     eax, eax\n; Line 51\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n        END\n```", "```\n\n\t\t\t50c50\n< cmp eax, 1000\n\n---\n> cmp eax, 1001\n```"]