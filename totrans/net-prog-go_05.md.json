["```\npackage ch03\n\nimport (\n    \"net\"\n    \"testing\"\n)\n\nfunc TestListener(t *testing.T) {\n  1listener, err := net.Listen(\"2tcp\", \"3127.0.0.1:0\")\n    if err != nil {\n        t.Fatal(err)\n    }\n   4  defer func() { _ = listener.Close() }()\n\n    t.Logf(\"bound to %q\", 5listener.Addr())\n}\n```", "```\n 1  for {\n      2conn, err := 3listener.Accept()\n        if err != nil {\n            return err\n        }\n\n       4  go func(c net.Conn) {\n       5      defer c.Close()\n\n            // Your code would handle the connection here.\n        }(conn)\n    }\n```", "```\npackage ch03\n\nimport (\n    \"io\"\n    \"net\"\n    \"testing\"\n)\n\nfunc TestDial(t *testing.T) {\n    // Create a listener on a random port.\n    listener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    done := make(chan struct{})\n   1  go func() {\n        defer func() { done <- struct{}{} }()\n\n        for {\n            conn, err := 2listener.Accept()\n            if err != nil {\n                t.Log(err)\n                return\n            }\n\n 3  go func(c net.Conn) {\n                defer func() {\n                    c.Close()\n                    done <- struct{}{}\n                }()\n\n                buf := make([]byte, 1024)\n                for {\n                    n, err := 4c.Read(buf)\n                    if err != nil {\n                        if err != io.EOF {\n                            t.Error(err)\n                        }\n                        return\n                    }\n\n                    t.Logf(\"received: %q\", buf[:n])\n                }\n            }(conn)\n        }\n    }()\n\n  5conn, err := net.Dial(\"6tcp\", 7listener.Addr().String())\n    if err != nil {\n        t.Fatal(err)\n    }\n\n   8  conn.Close()\n    <-done\n   9  listener.Close()\n    <-done\n}\n```", "```\nif nErr, ok := err.(net.Error); ok && !nErr.Temporary() { return err }\n```", "```\npackage ch03\n\nimport (\n    \"net\"\n    \"syscall\"\n    \"testing\"\n    \"time\"\n)\n\nfunc 1DialTimeout(network, address string, timeout time.Duration,\n) (net.Conn, error) {\n    d := net.Dialer{\n       2  Control: func(_, addr string, _ syscall.RawConn) error {\n            return &net.DNSError{\n                Err:         \"connection timed out\",\n                Name:        addr,\n                Server:      \"127.0.0.1\",\n                IsTimeout:   true,\n                IsTemporary: true,\n            }\n        },\n        Timeout: timeout,\n    }\n    return d.Dial(network, address)\n}\n\nfunc TestDialTimeout(t *testing.T) {\n    c, err := DialTimeout(\"tcp\", \"10.0.0.1:http\", 35*time.Second)\n    if err == nil {\n        c.Close()\n        t.Fatal(\"connection did not time out\")\n    }\n    nErr, ok := 4err.(net.Error)\n    if !ok {\n        t.Fatal(err)\n    }\n if 5!nErr.Timeout() {\n        t.Fatal(\"error is not a timeout\")\n    }\n}\n```", "```\npackage ch03\n\nimport (\n    \"context\"\n    \"net\"\n    \"syscall\"\n \"testing\"\n    \"time\"\n)\n\nfunc TestDialContext(t *testing.T) {\n    1 dl := time.Now().Add(5 * time.Second)\n    2 ctx, cancel := context.WithDeadline(context.Background(), dl)\n    3 defer cancel()\n\n    var d net.Dialer // DialContext is a method on a Dialer\n    d.Control = 4func(_, _ string, _ syscall.RawConn) error {\n        // Sleep long enough to reach the context's deadline.\n        time.Sleep(5*time.Second + time.Millisecond)\n        return nil\n    }\n    conn, err := d.DialContext(5ctx, \"tcp\", \"10.0.0.0:80\")\n    if err == nil {\n        conn.Close()\n        t.Fatal(\"connection did not time out\")\n    }\n    nErr, ok := err.(net.Error)\n    if !ok {\n        t.Error(err)\n    } else {\n        if !nErr.Timeout() {\n            t.Errorf(\"error is not a timeout: %v\", err)\n        }\n    }\n   6  if ctx.Err() != context.DeadlineExceeded {\n        t.Errorf(\"expected deadline exceeded; actual: %v\", ctx.Err())\n    }\n}\n```", "```\npackage ch03\n\nimport (\n    \"context\"\n    \"net\"\n    \"syscall\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestDialContextCancel(t *testing.T) {\n    ctx, cancel := 1context.WithCancel(context.Background())\n    sync := make(chan struct{})\n\n   2  go func() {\n        defer func() { sync <- struct{}{} }()\n\n        var d net.Dialer\n        d.Control = func(_, _ string, _ syscall.RawConn) error {\n            time.Sleep(time.Second)\n            return nil\n        }\n        conn, err := d.DialContext(ctx, \"tcp\", \"10.0.0.1:80\")\n        if err != nil {\n            t.Log(err)\n            return\n        }\n\n        conn.Close()\n        t.Error(\"connection did not time out\")\n    }()\n\n   3  cancel()\n    <-sync\n\n    if ctx.Err() != 4context.Canceled {\n        t.Errorf(\"expected canceled context; actual: %q\", ctx.Err())\n    }\n}\n```", "```\npackage ch03\n\nimport (\n    \"context\"\n    \"net\"\n    \"sync\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestDialContextCancelFanOut(t *testing.T) {\n   1  ctx, cancel := context.WithDeadline(\n        context.Background(),\n        time.Now().Add(10*time.Second),\n    )\n\n    listener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer listener.Close()\n\n   2  go func() {\n            // Only accepting a single connection.\n            conn, err := listener.Accept()\n            if err == nil {\n                conn.Close()\n            }\n    }()\n\n   3  dial := func(ctx context.Context, address string, response chan int,\n        id int, wg *sync.WaitGroup) {\n        defer wg.Done()\n\n        var d net.Dialer\n c, err := d.DialContext(ctx, \"tcp\", address)\n        if err != nil {\n            return\n        }\n        c.Close()\n\n        select {\n        case <-ctx.Done():\n        case response <- id:\n        }\n    }\n\n    res := make(chan int)\n    var wg sync.WaitGroup\n\n   4  for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go dial(ctx, listener.Addr().String(), res, i+1, &wg)\n    }\n\n   5  response := <-res\n    cancel()\n    wg.Wait()\n    close(res)\n\n    if ctx.Err() != 6context.Canceled {\n        t.Errorf(\"expected canceled context; actual: %s\",\n            ctx.Err(),\n        )\n    }\n\n    t.Logf(\"dialer %d retrieved the resource\", response)\n}\n```", "```\npackage ch03\n\nimport (\n    \"io\"\n    \"net\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestDeadline(t *testing.T) {\n    sync := make(chan struct{})\n\n    listener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    go func() {\n        conn, err := listener.Accept()\n        if err != nil {\n            t.Log(err)\n            return\n }\n        defer func() {\n            conn.Close()\n            close(sync) // read from sync shouldn't block due to early return\n        }()\n\n       1  err = conn.SetDeadline(time.Now().Add(5 * time.Second))\n        if err != nil {\n            t.Error(err)\n            return\n        }\n\n        buf := make([]byte, 1)\n        _, err = conn.Read(buf) // blocked until remote node sends data\n        nErr, ok := err.(net.Error)\n        if !ok || 2!nErr.Timeout() {\n            t.Errorf(\"expected timeout error; actual: %v\", err)\n        }\n\n        sync <- struct{}{}\n\n       3  err = conn.SetDeadline(time.Now().Add(5 * time.Second))\n        if err != nil {\n            t.Error(err)\n            return\n        }\n\n        _, err = conn.Read(buf)\n        if err != nil {\n            t.Error(err)\n        }\n    }()\n\n    conn, err := net.Dial(\"tcp\", listener.Addr().String())\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer conn.Close()\n\n    <-sync\n    _, err = conn.Write([]byte(\"1\"))\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    buf := make([]byte, 1)\n    _, err = conn.Read(buf) // blocked until remote node sends data\n    if err != 4io.EOF {\n        t.Errorf(\"expected server termination; actual: %v\", err)\n    }\n}\n```", "```\npackage ch03\n\nimport (\n \"context\"\n    \"io\"\n    \"time\"\n)\n\nconst defaultPingInterval = 30 * time.Second\n\nfunc Pinger(ctx context.Context, w io.Writer, reset <-chan time.Duration) {\n    var interval time.Duration\n    select {\n    case <-ctx.Done():\n        return\n   1  case interval = <-reset: // pulled initial interval off reset channel\n    default:\n    }\n    if interval <= 0 {\n        interval = defaultPingInterval\n    }\n\n   2  timer := time.NewTimer(interval)\n    defer func() {\n        if !timer.Stop() {\n            <-timer.C\n        }\n    }()\n\n    for {\n        select {\n       3  case <-ctx.Done():\n            return\n       4  case newInterval := <-reset:\n            if !timer.Stop() {\n                <-timer.C\n            }\n            if newInterval > 0 {\n                interval = newInterval\n            }\n       5  case <-timer.C:\n            if _, err := w.Write([]byte(\"ping\")); err != nil {\n                // track and act on consecutive timeouts here\n                return\n            }\n        }\n\n       6  _ = timer.Reset(interval)\n    }\n}\n```", "```\npackage ch03\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"time\"\n)\n\nfunc ExamplePinger() {\n    ctx, cancel := context.WithCancel(context.Background())\n    r, w := io.Pipe() // in lieu of net.Conn\n    done := make(chan struct{})\n   1  resetTimer := make(chan time.Duration, 1)\n    resetTimer <- time.Second // initial ping interval\n\n    go func() {\n        Pinger(ctx, w, resetTimer)\n        close(done)\n    }()\n\n    receivePing := func(d time.Duration, r io.Reader) {\n        if d >= 0 {\n            fmt.Printf(\"resetting timer (%s)\\n\", d)\n            resetTimer <- d\n        }\n\n        now := time.Now()\n        buf := make([]byte, 1024)\n        n, err := r.Read(buf)\n if err != nil {\n            fmt.Println(err)\n        }\n\n        fmt.Printf(\"received %q (%s)\\n\",\n            buf[:n], time.Since(now).Round(100*time.Millisecond))\n    }\n\n   2  for i, v := range []int64{0, 200, 300, 0, -1, -1, -1} {\n        fmt.Printf(\"Run %d:\\n\", i+1)\n        receivePing(time.Duration(v)*time.Millisecond, r)\n    }\n\n    cancel()\n    <-done // ensures the pinger exits after canceling the context\n\n    // Output:\n   3  // Run 1:\n    // resetting timer (0s)\n    // received \"ping\" (1s)\n   4  // Run 2:\n    // resetting timer (200ms)\n    // received \"ping\" (200ms)\n   5  // Run 3:\n    // resetting timer (300ms)\n    // received \"ping\" (300ms)\n   6  // Run 4:\n    // resetting timer (0s)\n    // received \"ping\" (300ms)\n   7  // Run 5:\n    // received \"ping\" (300ms)\n    // Run 6:\n    // received \"ping\" (300ms)\n    // Run 7:\n    // received \"ping\" (300ms)\n\n}\n```", "```\n$ **go test ping.go ping_example_test.go**\n```", "```\npackage ch03\n\nimport (\n    \"context\"\n    \"io\"\n    \"net\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestPingerAdvanceDeadline(t *testing.T) {\n    done := make(chan struct{})\n    listener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    begin := time.Now()\n    go func() {\n        defer func() { close(done) }()\n conn, err := listener.Accept()\n        if err != nil {\n            t.Log(err)\n            return\n        }\n        ctx, cancel := context.WithCancel(context.Background())\n        defer func() {\n            cancel()\n            conn.Close()\n        }()\n\n        resetTimer := make(chan time.Duration, 1)\n        resetTimer <- time.Second\n        go Pinger(ctx, conn, resetTimer)\n\n        err = conn.SetDeadline(time.Now().Add(15 * time.Second))\n        if err != nil {\n            t.Error(err)\n            return\n        }\n\n        buf := make([]byte, 1024)\n        for {\n            n, err := conn.Read(buf)\n            if err != nil {\n                return\n            }\n            t.Logf(\"[%s] %s\", \n                time.Since(begin).Truncate(time.Second), buf[:n])\n\n           2  resetTimer <- 0\n            err = 3conn.SetDeadline(time.Now().Add(5 * time.Second))\n            if err != nil {\n                t.Error(err) \n                return\n            }\n        }\n    }()\n\n    conn, err := net.Dial(\"tcp\", listener.Addr().String())\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer conn.Close()\n\n    buf := make([]byte, 1024)\n   4  for i := 0; i < 4; i++ { // read up to four pings\n        n, err := conn.Read(buf)\n        if err != nil {\n            t.Fatal(err)\n        }\n        t.Logf(\"[%s] %s\", time.Since(begin).Truncate(time.Second), buf[:n])\n    }\n    _, err = 5conn.Write([]byte(\"PONG!!!\")) // should reset the ping timer\n    if err != nil {\n t.Fatal(err)\n    }\n   6  for i := 0; i < 4; i++ { // read up to four more pings\n        n, err := conn.Read(buf)\n        if err != nil {\n            if err != io.EOF {\n                t.Fatal(err)\n            }\n            break\n        }\n        t.Logf(\"[%s] %s\", time.Since(begin).Truncate(time.Second), buf[:n])\n    }\n    <-done\n    end := time.Since(begin).Truncate(time.Second)\n    t.Logf(\"[%s] done\", end)\n    if end != 79*time.Second {\n        t.Fatalf(\"expected EOF at 9 seconds; actual %s\", end)\n    }\n}\n```"]