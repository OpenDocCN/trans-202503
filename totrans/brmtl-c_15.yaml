- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic Memory
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Embedded systems have very limited random access memory (RAM). So far, we’ve
    divided the free memory into a small stack with no space left for anything else.
    When dealing with bigger systems, we have gigabytes of memory, making it easier
    to divide the memory into two sections: the stack and the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the stack in Chapter 7. It’s where the program allocates local
    variables and temporary values for each procedure as it’s needed. The heap is
    a little different. You decide when memory is allocated from the heap as well
    as when it is returned to the heap. Using the heap, you can create very complex
    and large data structures. For example, web browsers use the heap to store the
    structural elements that make up a web page.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how to allocate and deallocate memory. In addition, we’ll
    explore how to implement a linked-list data structure to demonstrate common dynamic
    memory operations and how to debug common memory problems.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Heap Allocation and Deallocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `malloc` function to get memory from the heap. Here is the general
    form of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function gets `number-of-bytes` from the heap and returns a pointer to
    them. The memory is uninitialized, so it contains random values. If the program
    is out of heap, the function returns the `NULL` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 13-1](#listing13-1) allocates memory for a structure
    on the heap and then does absolutely nothing with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**simple.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: A simple pointer allocation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the program more reliable, we use `sizeof(*listPtr)` to determine how
    many bytes to allocate, which is a common design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A common design mistake is to omit the asterisk, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are things and pointers to things. The `listPtr` variable is a pointer,
    and the `*listPtr` expression is a thing. A pointer is small: 8 bytes on a 64-bit
    system. The size of a thing, in this case, is 56 bytes. The design pattern ensures
    that you allocate the right number of bytes for the variable, since the variable
    is repeated in the argument to `malloc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes you’ll see the structure itself, instead of a pointer to the structure,
    used in `sizeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That works, but it’s slightly dangerous. Suppose someone changes the type of
    `listPtr`. For example, the following is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So what happened? In the beginning we had the following correct but dangerous
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything worked, because `listPtr` was a pointer to `struct aList`. As long
    as the types matched, everything was okay. Now let’s say someone decided to alter
    the code and made `listPtr` point to the new and improved version of the `aList`
    called `aListImproved`, *but they didn’t change the type in the* `malloc` *function*.
    What’s worse, imagine if the code wasn’t the simple, obvious one-liner from earlier
    and instead looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code doesn’t allocate enough space for the new fields, so every time someone
    uses the new fields, random memory is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice to see if you ran out of memory is to check whether `malloc`
    returned a `NULL` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is vital even if you think `malloc` will never fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program has a *memory leak*, meaning that it does not deallocate the memory
    it uses. When a program deallocates memory, it’s returned to the heap for reuse
    by a later `malloc`. To do that, we use the `free` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `listPtr` to `NULL` is a design pattern that makes sure you don’t
    try to use the memory after it’s freed. It’s not required by the C language.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to use the freed `listPtr` without setting it to `NULL` first, we’ll
    write into memory that shouldn’t have been written to. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we write to freed memory, something bad may happen later in the program
    that will be difficult to debug because the relationship between the bug and the
    preceding mistake will not be obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s nice if we make our mistakes in an obvious manner, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a form of paranoid programming. The idea is to turn a subtle, hard-to-find
    screwup into one that crashes the entire program and is thus much easier to find.
  prefs: []
  type: TYPE_NORMAL
- en: Linked Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a heap and can store data in it, we’re going to use a primitive
    data structure called a *singly linked list*, which has several advantages over
    an array. It does not have a fixed size, and insert and delete operations are
    much quicker using it than using an array. (Arrays have the advantage of being
    faster to search.)
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we need to store a number of names for a phone book. The problem is
    that we don’t know how many names. Also, names may be added or removed at any
    time. For embedded systems, this problem is simple. We create an array in which
    to store the names. If we run out of room in the array, we tell the users they
    can’t store any more names. A linked list would be better, if we had the memory
    and if we had a heap. On an extremely limited embedded system, we have neither.
  prefs: []
  type: TYPE_NORMAL
- en: Each element of our list, called a *node*, is allocated from the heap. To keep
    track of these elements, we have a pointer to the first node. The first node has
    a pointer to the second node, and so on, until we reach the last node. Its pointer
    is `NULL`, indicating the end of the list. There is no fixed number of nodes.
    If we need another one, we just allocate it from the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the structure for the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `next` pointer points to the next node (or `NULL`), and the `name` array
    stores up to 20 characters. [Figure 13-1](#figure13-1) is a diagram of this list.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001](image_fi/501621c13/f13001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists provide a very simple way of storing a variable number of
    items in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add a node (say, “Fred”) to the list, we must first create one. In the code,
    we make the `newNode` variable point to the newly created node. The memory now
    looks like [Figure 13-2](#figure13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002](image_fi/501621c13/f13002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: New node created'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](#figure13-2) shows our linked list (without “Fred”) and the new
    node we’ve allocated for “Fred.” Next, we make the `next` link of our new node
    point to the start of the list (see [Figure 13-3](#figure13-3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f13003](image_fi/501621c13/f13003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The `next` pointer of the new node points to the start of the
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to assign `theList = newNode`, moving the pointer to the head
    of our list to our new first node (see [Figure 13-4](#figure13-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004](image_fi/501621c13/f13004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: Moving the new node to the head of the list'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-2](#listing13-2) shows the code for adding the new node to the
    start of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: Adding a word to the linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a function declaration, and the `static` keyword indicates that
    the function is visible only to the code in this file. We first ask for the word
    to add and get it using the `fgets` function, which has the following general
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function reads a line from the `file` and puts it in the `array`. The `size`
    is the number of bytes to stick in the array, including an end-of-string (`\0`)
    character. In this case, the array is `line` (the input line), and the file is
    `stdin` (standard in, or in other words, the terminal). If `fgets` returns `NULL`,
    we couldn’t read `stdin` because of an error or running out of data. At that point,
    we give up and return because we didn’t get a word.
  prefs: []
  type: TYPE_NORMAL
- en: The `fgets` function reads at most `size``-1` characters, because it always
    puts an end-of-string character (`\0`) in the array. If the line that’s entered
    is shorter than `size`, the entire line is put in the buffer, including the newline.
    If it’s longer, the input is truncated.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t count on a newline being in the buffer, nor do we want one. If the
    last character in the string (found using the `strlen` function, which returns
    the number of characters in the string) is a newline, we delete it by changing
    it to a null (`'\0'`). Then we allocate memory for the new node and populate it
    by copying `line` into the node’s name.
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` function copies the second argument (`line`) into the first (`newNode->name`)
    but copies only the number of characters specified by the third argument. If the
    data to be copied (`line`) has more characters than the `size` parameter, it limits
    the number of characters copied and doesn’t insert an end-of-string character
    (`\0`) at the end, so just to be safe, we manually add an end-of-string character
    at the end of the `name` array.
  prefs: []
  type: TYPE_NORMAL
- en: We make `newNode` point to the first node, and then we take `theList` and make
    it point to the new node, as shown in Figures 13-3 and 13-4.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Linked List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rules for printing a linked list are simple. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start with the first node 1, print it, and then go to the next node 3. We
    keep going until we run out of list 2. In this example, the `for` loop initializer,
    end condition, and iteration statement are split over three lines. The code does
    add an extra comma at the end of the list, but I’m sure you can figure out how
    to fix that. [Figure 13-5](#figure13-5) shows how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13005](image_fi/501621c13/f13005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: Printing the list'
  prefs: []
  type: TYPE_NORMAL
- en: Because our list is a simple data structure, printing is simple, and the flexibility
    of the C `for` loop makes it easy to go through the list.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To delete a node, we first go through the list and find the one we want. Next,
    we remove the node and then connect the previous node to the next node. The code
    to go through the list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use a `for` loop, much like we did for printing 1, but instead of printing
    the node, we check to see whether it’s the one we want with the `strcmp` function
    2, which returns `0` if the strings are the same. If it’s not the one we want,
    we update the pointer to the previous node 6 (which we’ll need for deleting) and
    go to the next node using the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: If we do find the node (say, “Joe”), `prevNode` will point to “Sam” and `curNode`
    will point to “Joe,” as shown in [Figure 13-6](#figure13-6).
  prefs: []
  type: TYPE_NORMAL
- en: We next make the link from “Sam” point to “Mac,” bypassing the “Joe” node 4.
    Then we delete the node by freeing it *and* setting the pointer to `NULL` 5, which
    works as long as `prevNode` is set. If we want to delete the first node, “Sam,”
    we need to change the pointer to the list to bypass the deleted node 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![f13006](image_fi/501621c13/f13006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: Deleting the node `“Joe”`'
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 13-3](#listing13-3) is a small command line program designed to edit
    and print a linked list interactively.'
  prefs: []
  type: TYPE_NORMAL
- en: '**linked.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: A program that implements a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: The user inputs commands to add or remove nodes by name, print the list, or
    quit the program. When the user adds or removes a node, the program dynamically
    allocates or deallocates memory.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Memory Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several common errors can occur when we’re using dynamic memory, such as memory
    leaks, using a pointer after it’s freed, and writing data beyond the end of a
    structure and trashing random memory. Let’s look at each error and how to prevent
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *memory leak* happens when memory is allocated and never freed. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Every time the program executes this code, it allocates another 400 bytes of
    memory. If the program runs long enough, it will consume all available memory
    and die. (Actually, it will consume enough memory resources to make all the other
    programs very slow, before using so much memory that the computer is completely
    useless, runs for a while longer, and finally runs out of memory.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a pointer after it’s freed (often referred to as *use after free*) may
    result in random results or overwriting random memory. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `free` function may write bookkeeping or other data into the
    node, and as a result `nextPtr` is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, a simple design pattern will limit the
    damage this type of code can do. We always set the pointer to `NULL` after freeing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ve exchanged an undefined, random behavior for a reproducible, predictable
    one. The cause of the crash is easy to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last dynamic memory problem we’ll consider is writing data beyond the end
    of a structure. As you saw earlier, nothing prevents you from writing past the
    end of an array. You can do the same thing with allocated memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is no good way of preventing or detecting these types of errors using
    the C language. An external tool or augmented compilation is required.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind and the GCC Address Sanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory errors have become such a problem that many tools have been created to
    try to detect them, including Valgrind and the GCC address sanitizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valgrind is open source and freely available for Linux and macOS at [http://valgrind.org](http://valgrind.org).
    It’s designed to find the following: memory leaks, writing past the end of an
    array or allocated memory block, using a pointer after it’s freed, and making
    a decision based on the value of uninitialized memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind is a runtime tool. You don’t need to recompile your code to use it;
    instead, you compile your program normally and then run Valgrind with the program
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-4](#listing13-4) shows a program that leaks memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: A leaky program'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-5](#listing13-5) shows the result of running this program under
    Valgrind with leak checking set to the maximum.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-5: Valgrind results'
  prefs: []
  type: TYPE_NORMAL
- en: From this output, we can see that line 12 is leaking 1.
  prefs: []
  type: TYPE_NORMAL
- en: The GCC address sanitizer is designed to detect only memory leaks and writing
    past the end of an array or allocated memory block. Unlike Valgrind, it’s a compile-time
    tool, so you need to compile your code with the `–fsanitize=address` flag to use
    it. After that, when you run the program, it automatically generates its report,
    as shown in [Listing 13-6](#listing13-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-6: Address sanitizer results'
  prefs: []
  type: TYPE_NORMAL
- en: Memory problems have plagued programs since the time of the first computer,
    and they are nasty to try to find. The address sanitizer is one tool that gives
    us extra help in finding them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heap allows you to add and remove extra memory for your program, as needed.
    It gives you the ability to create large, complex, and wonderful data structures.
    A description of the various sorts of data structures and data structure designs
    could fill an entire book.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the single linked list, which is the “Hello World” of
    data structures. As you progress, you can learn how to use the heap to store more
    complex data. For now, you’ve learned the basics, so where you take it from here
    is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change the program in [Listing 13-3](#listing13-3), which implements a linked
    list, so that it always keeps the nodes in order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given two ordered linked lists, create a function that returns a list of the
    common nodes. You can do this as a new list or create a list where the body is
    just a pointer to one of the nodes in the other lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the program in [Listing 13-3](#listing13-3) to use a doubly linked list.
    Each node will have a `next` pointer that points to the next node and a `previous`
    pointer that points to the previous node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function to reverse the order of a singly linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function that will remove duplicates from a linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
