["```\n7 6\n11\nA 1 4\nA 4 5\nA 3 6\nE 1 5\nE 2 5\nA 1 5\nA 2 5\nA 4 3\nS 4\nA 7 6\nS 4\n```", "```\nYes\nNo\n6\n6\n```", "```\n#define MAX_PEOPLE 100000\n\ntypedef struct edge {\n  int to_person;\n  struct edge *next;\n} edge;\n```", "```\nint main(void) {\n  static edge *adj_list[MAX_PEOPLE + 1] = {NULL};\n  static int min_moves[MAX_PEOPLE + 1];\n  int num_people, num_community, num_ops, i;\n  char op;\n  int person1, person2;\n  edge *e;\n  int size1, size2, same_community;\n  scanf(\"%d%d\", &num_people, &num_community);\n  scanf(\"%d\", &num_ops);\n\n  for (i = 0; i < num_ops; i++) {\n    scanf(\" %c\", &op);\n ❶ if (op == 'A') {\n         scanf(\"%d%d\", &person1, &person2);\n      ➋ find_distances(adj_list, person1, num_people, min_moves);\n      ➌ size1 = size(num_people, min_moves);\n         same_community = 0;\n      ➍ if (min_moves[person2] != -1)\n           same_community = 1;\n      ➎ find_distances(adj_list, person2, num_people, min_moves);\n      ➏ size2 = size(num_people, min_moves);\n      ❼ if (same_community || size1 + size2 <= num_community) {\n           e = malloc(sizeof(edge));\n           if (e == NULL) {\n             fprintf(stderr, \"malloc error\\n\");\n             exit(1);\n          }\n          e->to_person = person2;\n          e->next = adj_list[person1];\n          adj_list[person1] = e;\n          e = malloc(sizeof(edge));\n          if (e == NULL) {\n            fprintf(stderr, \"malloc error\\n\");\n            exit(1);\n          }\n          e->to_person = person1;\n          e->next = adj_list[person2];\n          adj_list[person2] = e;\n        }\n     }\n\n   ❽ else if (op == 'E') {\n        scanf(\"%d%d\", &person1, &person2);\n        find_distances(adj_list, person1, num_people, min_moves);\n        if (min_moves[person2] != -1)\n          printf(\"Yes\\n\");\n        else\n          printf(\"No\\n\");\n     }\n\n  ❾ else {\n       scanf(\"%d\", &person1);\n       find_distances(adj_list, person1, num_people, min_moves);\n       printf(\"%d\\n\", size(num_people, min_moves));\n     }\n  }\n  return 0;\n}\n```", "```\nvoid add_position(int from_person, int to_person,\n                  int new_positions[], int *num_new_positions,\n                  int min_moves[]) {\n  if (min_moves[to_person] == -1) {\n    min_moves[to_person] = 1 + min_moves[from_person];\n    new_positions[*num_new_positions] = to_person;\n    (*num_new_positions)++;\n  }\n}\n\nvoid find_distances(edge *adj_list[], int person, int num_people,\n                    int min_moves[]) {\n  static int cur_positions[MAX_PEOPLE + 1], new_positions[MAX_PEOPLE + 1];\n  int num_cur_positions, num_new_positions;\n  int i, from_person;\n  edge *e;\n  for (i = 1; i <= num_people; i++)\n    min_moves[i] = -1;\n  min_moves[person] = 0; cur_positions[0] = person;\n  num_cur_positions = 1;\n\n  while (num_cur_positions > 0) {\n    num_new_positions = 0;\n    for (i = 0; i < num_cur_positions; i++) {\n      from_person = cur_positions[i];\n      e = adj_list[from_person];\n\n      while (e) {\n        add_position(from_person, e->to_person,\n                     new_positions, &num_new_positions, min_moves);\n        e = e->next;\n      }\n    }\n\n    num_cur_positions = num_new_positions;\n    for (i = 0; i < num_cur_positions; i++)\n      cur_positions[i] = new_positions[i];\n  }\n}\n```", "```\nint size(int num_people, int min_moves[]) {\n  int i, total = 0;\n  for (i = 1; i <= num_people; i++)\n    if (min_moves[i] != -1)\n      total++;\n  return total;\n}\n```", "```\nint find(int person, int community_of[]) {\n  return community_of[person];\n}\n```", "```\nvoid union_communities(int person1, int person2,\n                       int community_of[], int num_people) {\n  int community1, community2, i;\n  community1 = find(person1, community_of);\n  community2 = find(person2, community_of);\n  for (i = 1; i <= num_people; i++)\n    if (community_of[i] == community1)\n      community_of[i] = community2;\n}\n```", "```\nint main(void) {\n❶ static int parent[MAX_PEOPLE + 1], size[MAX_PEOPLE + 1];\n   int num_people, num_community, num_ops, i;\n   char op;\n   int person1, person2;\n   scanf(\"%d%d\", &num_people, &num_community);\n➋ for (i = 1; i <= num_people; i++) {\n     parent[i] = i;\n     size[i] = 1;\n   }\n   scanf(\"%d\", &num_ops);\n\n   for (i = 0; i < num_ops; i++) {\n     scanf(\" %c\", &op);\n\n     if (op == 'A') {\n       scanf(\"%d%d\", &person1, &person2);\n     ➌ union_communities(person1, person2, parent, size, num_community);\n     }\n\n     else if (op == 'E') {\n       scanf(\"%d%d\", &person1, &person2);\n     ➍ if (find(person1, parent) == find(person2, parent))\n         printf(\"Yes\\n\");\n       else\n         printf(\"No\\n\");\n     }\n\n     else {\n       scanf(\"%d\", &person1);\n     ➎ printf(\"%d\\n\", size[find(person1, parent)]);\n     }\n  }\n return 0;\n}\n```", "```\nint find(int person, int parent[]) {\n  int community = person;\n  while (parent[community] !=  community)\n    community = parent[community];\n  return community;\n}\n```", "```\nvoid union_communities(int person1, int person2, int parent[],\n                       int size[], int num_community) {\n  int community1, community2;\n ❶ community1 = find(person1, parent);\n  ➋ community2 = find(person2, parent);\n     if (community1 != community2 &&\n         size[community1] + size[community2] <= num_community) {\n    ➌ parent[community1] = community2;\n    ➍ size[community2] = size[community2] + size[community1];\n  }\n}\n```", "```\n7 7\n7\nA 1 2\nA 2 3\nA 3 4\nA 4 5\nA 5 6\nA 6 7\nE 1 2\n```", "```\n9 9\n9\nA 1 2\nA 3 4\nA 5 6\nA 7 8\nA 8 9\nA 2 4\nA 6 8\nA 4 8\nE 1 5\n```", "```\nvoid union_communities(int person1, int person2, int parent[],\n                       int size[], int num_community) {\n  int community1, community2, temp;\n  community1 = find(person1, parent);\n  community2 = find(person2, parent);\n  if (community1 != community2 &&\n      size[community1] + size[community2] <= num_community) {\n ❶ if (size[community1] > size[community2]) {\n      temp = community1;\n      community1 = community2;\n      community2 = temp;\n    }\n ➋ parent[community1] = community2;\n    size[community2] = size[community2] + size[community1];\n  }\n}\n```", "```\n9 9\n13\nA 1 2\nA 3 4\nA 5 6\nA 7 8\nA 8 9\nA 2 4\nA 6 8\nA 4 8\nE 1 5\nE 1 5\nE 1 5\nE 1 5\nE 1 5\n```", "```\nint find(int person, int parent[]) {\n  int community = person, temp;\n❶ while (parent[community] !=  community)\n     community = parent[community];\n➋ while (parent[person] != community) {\n     temp = parent[person];\n     parent[person] = community;\n     person = temp;\n   }\n   return community;\n}\n```", "```\n   9\n   1 0 1\n   1 1 2\n   1 3 4\n   1 5 6\n❶ 2 1 7\n➋ 2 5 8\n➌ 1 2 5\n   0 0 0\n```", "```\n   9\n   1 0 1\n   1 1 2\n 1 3 4\n   1 5 6\n   2 1 7\n   2 5 8\n❶ 2 2 5\n   0 0 0\n```", "```\n#define MAX_PEOPLE 9999\n\nint main(void) {\n  static int parent[MAX_PEOPLE], size[MAX_PEOPLE];\n  static int enemy_of[MAX_PEOPLE];\n  int num_people, i;\n  int op, person1, person2;\n  scanf(\"%d\", &num_people);\n  for (i = 0; i < num_people; i++) {\n    parent[i] = i;\n    size[i] = 1;\n ❶ enemy_of[i] = -1;\n  }\n scanf(\"%d%d%d\", &op, &person1, &person2);\n\n  while (op != 0) {\n ➋ if (op == 1)\n      if (are_enemies(person1, person2, parent, enemy_of))\n        printf(\"-1\\n\");\n      else\n        set_friends(person1, person2, parent, size, enemy_of);\n\n ➌ else if (op == 2)\n      if (are_friends(person1, person2, parent))\n        printf(\"-1\\n\");\n      else\n        set_enemies(person1, person2, parent, size, enemy_of);\n\n ➍ else if (op == 3)\n      if (are_friends(person1, person2, parent))\n        printf(\"1\\n\");\n      else\n        printf(\"0\\n\");\n\n ➎ else if (op == 4)\n      if (are_enemies(person1, person2, parent, enemy_of))\n        printf(\"1\\n\");\n      else\n        printf(\"0\\n\");\n\n    scanf(\"%d%d%d\", &op, &person1, &person2);\n  }\n  return 0;\n}\n```", "```\nint find(int person, int parent[]) {\n  int set = person, temp;\n  while (parent[set] !=  set)\n    set = parent[set];\n  while (parent[person] != set) {\n    temp = parent[person];\n    parent[person] = set;\n    person = temp;\n  }\n  return set;\n}\n```", "```\nint union_sets(int person1, int person2, int parent[],\n               int size[]) {\n  int set1, set2, temp;\n  set1 = find(person1, parent);\n  set2 = find(person2, parent);\n  if (set1 != set2) {\n    if (size[set1] > size[set2]) {\n      temp = set1;\n      set1 = set2;\n      set2 = temp;\n    }\n    parent[set1] = set2;\n    size[set2] = size[set2] + size[set1];\n  }\n❶ return set2;\n}\n```", "```\nvoid set_friends(int person1, int person2, int parent[],\n                 int size[], int enemy_of[]) {\n  int set1, set2, bigger_set, other_set;\n❶ set1 = find(person1, parent);\n➋ set2 = find(person2, parent);\n➌ bigger_set = union_sets(person1, person2, parent, size);\n➍ if (enemy_of[set1] != -1 && enemy_of[set2] != -1)\n  ➎ union_sets(enemy_of[set1], enemy_of[set2], parent, size);\n➏ if (bigger_set == set1)\n     other_set = set2;\n   else\n     other_set = set1;\n❼ if (enemy_of[bigger_set] == -1)\n     enemy_of[bigger_set] = enemy_of[other_set];\n}\n```", "```\nvoid set_enemies(int person1, int person2, int parent[],\n                 int size[], int enemy_of[]) {\n  int set1, set2, enemy;\n  set1 = find(person1, parent);\n  set2 = find(person2, parent);\n❶ enemy = enemy_of[set1];\n   if (enemy == -1)\n   ➋ enemy_of[set1] = person2;\n else\n  ➌ union_sets(enemy, person2, parent, size);\n➍ enemy = enemy_of[set2];\n   if (enemy == -1)\n     enemy_of[set2] = person1;\n   else\n     union_sets(enemy, person1, parent, size);\n}\n```", "```\nint are_friends(int person1, int person2, int parent[]) {\n  return find(person1, parent) == find(person2, parent);\n}\n```", "```\nint are_enemies(int person1, int person2, int parent[],\n                int enemy_of[]) {\n  int set1, enemy;\n  set1 = find(person1, parent);\n  enemy = enemy_of[set1];\n❶ return (enemy != -1) &&\n          (find(enemy, parent) == find(person2, parent));\n}\n```", "```\n6 7\n1 2\n2 6\n6 4\n5 3\n5 7\n2 5\n```", "```\nLADICA\nLADICA\nLADICA\nLADICA\nLADICA\nLADICA\n```", "```\n   7 7\n   1 2\n   2 6\n   6 4\n❶ 1 4\n   2 4\n   1 7\n   7 6\n```", "```\nLADICA\nLADICA\nLADICA\nLADICA\nSMECE\nLADICA\nSMECE\n```", "```\n#define MAX_DRAWERS 300000\n\nint main(void) {\n  static int parent[MAX_DRAWERS + 1];\n  int num_items, num_drawers, i;\n  int drawer_a, drawer_b;\n  scanf(\"%d%d\", &num_items, &num_drawers);\n❶ parent[0] = 0;\n   for (i = 1; i <= num_drawers; i++)\n     parent[i] = i;\n\n   for (i = 1; i <= num_items; i++) {\n     scanf(\"%d%d\", &drawer_a, &drawer_b);\n\n  ➋ if (find(drawer_a, parent) == drawer_a)\n    ➌ union_sets(drawer_a, drawer_b, parent);\n ➍ else if (find(drawer_b, parent) == drawer_b)\n    ➎ union_sets(drawer_b, drawer_a, parent);\n\n  ➏ else if (find(drawer_a, parent) > 0)\n    ❼ union_sets(drawer_a, drawer_b, parent);\n\n  ❽ else if (find(drawer_b, parent) > 0)\n    ❾ union_sets(drawer_b, drawer_a, parent);\n\n     else\n       printf(\"SMECE\\n\");\n  }\n  return 0;\n}\n```", "```\nint find(int drawer, int parent[]) {\n  int set = drawer, temp;\n  while (parent[set] !=  set)\n    set = parent[set];\n  while (parent[drawer] != set) {\n    temp = parent[drawer];\n    parent[drawer] = set;\n    drawer = temp;\n  }\n  return set;\n}\n```", "```\nvoid union_sets(int drawer1, int drawer2, int parent[]) {\n  int set1, set2;\n  set1 = find(drawer1, parent);\n  set2 = find(drawer2, parent);\n❶ parent[set1] = set2;\n➋ if (set1 == set2)\n  ➌ parent[set2] = 0; \n   printf(\"LADICA\\n\");\n}\n```"]