- en: Chapter 20. Using the Smartphone Pentest Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bring your own device (BYOD)* is a big buzzword in the industry right now.
    Though we’ve been bringing our own devices to work in one form or another for
    years (contractor laptops or that game console someone left connected to the network
    in the breakroom, for example), mobile devices are now entering the workplace
    en masse, and it falls to security teams and pentesters to evaluate the security
    risks of these devices.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on tools and attacks for assessing the security
    of mobile devices. Mobile technology is a rapidly developing field, and though
    we can cover only the basics here, developing new mobile attacks and post-exploitation
    techniques is an ideal place to start with your own security research. For example,
    we’ll be discussing a tool I created to help pentesters to assess the security
    posture of mobile devices, the *Smartphone Pentest Framework (SPF)*. After working
    your way through this book, you will be ready to embark on your own infosec journey
    and perhaps write a tool of your own.
  prefs: []
  type: TYPE_NORMAL
- en: For most of the examples in this chapter, we’ll use the Android platform as
    a target because, in addition to being the most ubiquitous platform, it also allows
    you to create emulators on Windows, Linux, and Mac OS platforms. Although we’ll
    focus on Android, we’ll also explore an attack on a jailbroken iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Attack Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though mobile devices run operating systems, speak TCP/IP, and access a lot
    of the same resources that traditional computers do, they also have their own
    unique features that add new attack vectors and protocols to the mix. Some features
    have been causing security problems on devices for years, while others such as
    near field communication, discussed later, are fairly new.
  prefs: []
  type: TYPE_NORMAL
- en: Text Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many mobile devices can send and receive text (SMS) messages. Though limited
    in size, text messages allow users to communicate almost simultaneously, often
    replacing email for written communications. SMS opens up a new social-engineering
    attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, email has been the medium for sending spam and phishing attempts,
    but even free email solutions do a decent job of filtering out the garbage these
    days. (If you ever need a laugh at work, check your email spam folder.) SMS is
    a different story: Although some mobile antivirus suites allow you to blacklist
    and whitelist certain mobile numbers, generally if you text a number to a device,
    the message will be received. This makes SMS an ideal vector for spam and phishing
    attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re already seeing annoying mobile ads and SMS phishing attempts that lure
    users to a counterfeit website to enter their credentials, much like the site-cloning
    attacks from [Chapter 11](ch11.xhtml "Chapter 11. Social Engineering"). These
    attacks will no doubt become more prevalent as time goes on. Security-awareness
    training will need to be augmented to include this threat. A user who knows better
    than to click a random link in a suspicious-looking email may still click a random
    link in a text message. After all, it’s just a text—how could a text possibly
    hurt you? But that link will open in the mobile browser or another app that may
    contain additional vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Near Field Communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mobile devices bring yet another attack vector to the table: *near field communication*,
    or *NFC*. NFC allows devices to share data by touching or being near each other.
    Mobile devices with NFC enabled can scan NFC tags to automate tasks such as changing
    settings or opening applications. Some can beam data, such as a photo or an entire
    app, from one device to another. NFC is another ideal social-engineering attack
    vector. For example, in Mobile Pwn2Own 2013, an exploitation contest, researchers
    used NFC to attack an Android device by beaming a malicious payload to a vulnerable
    application on the device. Therefore, security awareness training should also
    teach users to be aware of which NFC tags their device responds to and who they
    are beaming data with.'
  prefs: []
  type: TYPE_NORMAL
- en: QR Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Quick response (QR) codes* are matrix barcodes originally developed for use
    in auto manufacturing. QR codes can embed URLs, send data to an application on
    a mobile device, and so on, and users should be aware that what they are scanning
    may open something malicious. That QR code on a store window doesn’t have to point
    to the store’s website, and malicious QR code attacks have occurred in the wild.
    For instance, one prominent hacktivist changed his Twitter profile picture to
    a QR code, prompting many curious users to scan it with their phones. The QR code
    directed them to a malicious web page that attempted to exploit vulnerabilities
    in WebKit, a web page rendering engine used by both iOS and Android.'
  prefs: []
  type: TYPE_NORMAL
- en: The Smartphone Pentest Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough talk; let’s turn our attention to actually attacking mobile devices with
    the help of SPF. SPF is still under active development and its feature set changes
    rapidly. By the time you work through this section, many of the menus may offer
    additional options. In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual
    Lab"), you downloaded the version of the SPF used in this book, but to get the
    main and most up-to-date branch of SPF, visit *[https://github.com/georgiaw/Smartphone-Pentest-Framework.git/](https://github.com/georgiaw/Smartphone-Pentest-Framework.git/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up SPF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you followed the instructions in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), SPF should be all set up and ready to go. Because SPF uses
    Kali’s built-in web server to deliver some payloads, make sure that the Apache
    server is running, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, SPF records information in either a MySQL or PostgreSQL database.
    Make sure the MySQL database is started, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last thing to do is edit our SPF configuration file, */root/Smartphone-Pentest-Framework/frameworkconsole/config*,
    to match our environment. The default configuration file is shown in [Example 20-1](ch20.xhtml#spf_config_file
    "Example 20-1. SPF config file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-1. SPF config file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default should meet your needs if your Kali IP address is 192.168.20.9 and
    you installed SPF in */root/Smartphone-Pentest-Framework/*. Otherwise, change
    the `IPADDRESS` ❶ and `SHELLIPADDRESS` ❷ to your Kali machine’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Now run SPF by changing the directory to */root/Smartphone-Pentest-Framework/frameworkconsole/*
    and running **`./framework.py`**. You should be presented with a menu similar
    to [Example 20-2](ch20.xhtml#starting_spf "Example 20-2. Starting SPF").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-2. Starting SPF
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will spend the rest of the chapter exploring SPF’s various options. For now,
    let’s run a quick test to make sure that SPF can communicate with the database.
    The SPF installer set up an empty database for SPF, but you can clear out all
    your data and start fresh by running option `7.) Clear/Create` `Database`, as
    shown here. This command will clear the SPF database tables and create them if
    they do not already exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Android Emulators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"), we created
    three Android emulators. Though some of our attacks will work regardless of the
    Android version, we’ll look at certain client-side and privilege-escalation attacks
    that work well on emulators that target these specific older versions. Because
    they’re only emulators, you won’t be able to successfully test all known Android
    exploits against your Android emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a Mobile Modem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because not all mobile attack vectors use the TCP/IP network, SPF piggybacks
    on the pentester’s devices. As of this writing, SPF can use the mobile modem of
    an Android phone with the SPF app installed or USB modem with a SIM card to send
    SMS messages. Additionally, when using an Android phone with NFC capability, SPF
    can deliver payloads via Android Beam and the SPF Android App.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Android App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build the Android app from SPF, choose option `4.) Attach Framework to a
    Mobile Modem`, as shown in [Example 20-3](ch20.xhtml#building_the_spf_app "Example 20-3. Building
    the SPF app").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-3. Building the SPF app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next select option `3.) Generate smartphone based app` ❶. SPF can make two
    kinds of apps: one that uses NFC, and one that does not. Because our Android emulator
    lacks NFC capabilities, choose `1.) Android App (Android 1.6)` ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be asked to enter information about an SPF agent to control via the SPF
    app. SPF agents allow us to control an infected mobile device. We’ll look at generating
    and deploying SPF agents later in the chapter; for now, just enter the phone number
    of your Android 2.2 emulator ❸, a seven-character key ❹, and a path on the web
    server starting with `/` ❺. SPF will then use the Android SDK to build the SPF
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now to deploy the app on our Android 4.3 emulator. This emulator will simulate
    the pentester-controlled device, and the other two emulators will be our targets.
    If you’re running your emulators on Kali Linux or using real Android devices that
    you can attach via USB to your Kali virtual machine, you can use Android Debug
    Bridge (ADB) to install the app, as shown in [Example 20-4](ch20.xhtml#installing_the_spf_app
    "Example 20-4. Installing the SPF app"). (First, choose option `4.) Attach Framework
    to a Mobile Modem` from the main menu.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-4. Installing the SPF app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the Choose a type of modem to attach to menu, select option **`5`** to
    have ADB search for all attached devices. Next, tell SPF which emulator or device
    to install SPF on; in this example I’ve chosen `emulator-5554` ❶, the Android
    4.3 emulator with phone number 1-555-521-5554\. Finally, tell SPF to install the
    Android app without NFC (option **`2`**) ❷.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using emulators on your host system, ADB from Kali will not be able
    to attach to them. Instead, to deploy the app, choose option `4.) Attach` `Framework
    to a Mobile Modem` from the main menu and then choose option `4.) Copy App to
    Webserver`, as shown in [Example 20-5](ch20.xhtml#copy_app_to_web_server "Example 20-5. Copy
    app to web server").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-5. Copy app to web server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to copy the app to Kali’s web server, where we can download
    and install it to the emulator. Tell SPF to copy the Framework Android App without
    NFC ❶, and then tell it where to put the app on the web server ❷. Finally, tell
    SPF the filename for the app to be downloaded ❸. Download the app from your Android
    4.3 emulator by opening the URL *[http://192.168.20.9/bookspf2/app.apk](http://192.168.20.9/bookspf2/app.apk)*
    in the mobile browser.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the SPF Server and App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to attach the SPF server and the SPF app, as shown in [Example 20-6](ch20.xhtml#attaching_to_spf_app
    "Example 20-6. Attaching to SPF app"). (Again, begin with option **`4`** in the
    main menu.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-6. Attaching to SPF app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Choose `2.) Attach to a smartphone based app` ❶. Next, give SPF the phone number
    of the emulator running the SPF app ❷, a seven-character key ❸, and the URL where
    the app will check in ❹. (The key does not need to be the same one we used for
    the agent when building the app. Also the URL should be different from the one
    used for the agent when building the app.) Once you’ve confirmed that this information
    is correct, SPF will appear to hang. We need to attach the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![SPF app](httpatomoreillycomsourcenostarchimages2030588.png.jpg)Figure 20-1. SPF
    app'
  prefs: []
  type: TYPE_NORMAL
- en: To attach the app, first open it on the Android emulator. The main screen asks
    for the IP address of the SPF server, the URL to check in, and the seven-character
    key. Use the same values as in the previous step (except the IP address should
    be the IP address of the SPF server rather than the phone number), as shown in
    [Figure 20-1](ch20.xhtml#spf_app "Figure 20-1. SPF app").
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve filled out the information, click **Attach** on the app. You will
    now be able to control the phone from SPF until you click Detach. Now return to
    SPF on Kali. When the app is attached, you are dropped back to the main SPF menu,
    which means we’re ready to start running mobile attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the history of mobile devices, there have been attacks on the mobile modem
    and other externally facing interfaces. For example, researchers found vulnerabilities
    in the mobile modem drivers for both Android phones and the iPhone that allowed
    attackers to crash the phone, take it off the mobile network, or even gain command
    execution on it, just by sending an SMS message. Like traditional computers, as
    the security position of mobile devices improves, the number of available remote
    attacks will decrease. That said, the more software users install on their phones,
    the greater the chance that there’s a potentially vulnerable service listening
    on a network port, as you’ll learn in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Default iPhone SSH Login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One remote attack was perhaps the cause of the first iPhone botnet. On jailbroken
    iPhones, users can install SSH to log in to their iPhone terminals remotely. By
    default, SSH has the root password *alpine* on all devices. Of course, users should
    change this value, but many who jailbreak their iPhones do not. Though this issue
    came to light years ago, as with many default password issues, it continues to
    pop up.
  prefs: []
  type: TYPE_NORMAL
- en: To test for this default SSH password on a jailbroken iPhone, we could choose
    `5.) Run a Remote Attack`, or use our old friend, Metasploit. Much as SET allowed
    us to create client-side attacks in Metasploit in [Chapter 11](ch11.xhtml "Chapter 11. Social
    Engineering"), we can use SPF to interface with Msfcli to automate running mobile
    modules from Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, as of this writing, not much in Metasploit targets mobile devices,
    but one module does test for use of the default iPhone password. As shown in [Example 20-7](ch20.xhtml#root_ssh_default_password_metasploit_mod
    "Example 20-7. Root SSH default password Metasploit module"), from the main SPF
    menu choose `8.) Use Metasploit`, and then choose `1.) Run iPhone Metasploit Modules`.
    Next, choose `1.) Cydia Default SSH Password`. SPF will ask you for the IP address
    of the iPhone in order to fill in the `RHOST` option in the module. SPF will then
    call Msfcli and run the desired module.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-7. Root SSH default password Metasploit module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you have a jailbroken iPhone handy, you can test this module. Metasploit
    will present you with a root shell if the login succeeds. When you are finished,
    type **`exit`** to close the shell and return to SPF. Of course, if you have SSH
    on your iPhone, be sure to change the password from *alpine* right away.
  prefs: []
  type: TYPE_NORMAL
- en: Client-Side Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With mobile devices, client-side attacks are more prevalent than remote attacks.
    And as with the attacks we studied in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), our client-side attacks are not restricted to the mobile browser.
    We can attack other default apps on the device as well as any third-party apps
    that may have bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Client-Side Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at an example of attacking the WebKit package in the mobile browser
    to gain a shell on an Android device. (This is similar to the browser attacks
    discussed in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side Exploitation").)
    We’ll attack a flaw in the mobile browser after enticing the user into opening
    a malicious page. The executed shellcode will be for Android, not Windows, but
    the overall attack dynamics are the same, as shown in [Example 20-8](ch20.xhtml#android_browser_attack
    "Example 20-8. Android browser attack").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-8. Android browser attack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the main SPF menu choose `6.) Run a social engineering or client s``ide
    attack`. Now choose `2.) Client Side Shell` ❶ then exploit option `1.)` `CVE=2010-1759
    Webkit Vuln Android` ❷. You will be prompted for the path on the web server ❸
    and asked for a filename ❹. SPF will then generate a malicious page to attack
    the CVE-2010-1759 WebKit vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be asked how you want to deliver a link to the malicious page
    ❺. You can use either NFC or SMS. Because our emulator does not support NFC, we
    choose SMS. When prompted for the number to attack, send the SMS to your Android
    2.1 emulator. Finally, when asked if you want to use custom text for the SMS (rather
    than the default “This is a cool page: <link>”), change the default to something
    more creative, or not.'
  prefs: []
  type: TYPE_NORMAL
- en: We have only one mobile modem attached to SPF, so SPF automatically uses it
    to send the SMS message. SPF contacts our SPF app on the Android 4.3 emulator
    and instructs it to send a text message to the Android 2.1 emulator. The SMS received
    by the Android 2.1 emulator will be from the Android 4.3 emulator. (Some mobile
    devices, such as iPhones, have a flaw in how they implement SMS that allows attackers
    to spoof the sender number to make it look like this attack came from any number
    they’d like.) The message received is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Like the client-side attacks discussed in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), this attack relies on the user opening the link in a vulnerable
    mobile browser. Our Android 2.1 emulator browser is vulnerable to the attack,
    and when you click the link to open the mobile browser, the browser will attempt
    to open the page for 30 seconds or so as the attack is running, before crashing.
    At that point, you should have a shell waiting for you in SPF. SPF automatically
    runs the Android equivalent of `whoami` when the shell opens.
  prefs: []
  type: TYPE_NORMAL
- en: Because we attacked the browser, we’re running as *app_2*, the mobile browser
    on our emulator. As usual, the shell has all the permissions of the exploited
    app, meaning that you can run any commands available to the browser. For example,
    enter **`/system/bin/ls`**, as shown in [Example 20-9](ch20.xhtml#android_shell
    "Example 20-9. Android shell"), to use `ls` to list the contents of the current
    directory. When you’ve finished, enter **`exit`** to return to SPF.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-9. Android shell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android is a forked Linux kernel, so once we have a shell, we should be ready
    to go with Android, right? Unfortunately, many Linux utilities like `cp` aren’t
    there. Additionally, the user structure is a bit different, with each app having
    its own UID. A deep dive into Android, however, is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at an alternative way to control exploited Android devices, using
    backdoored apps to call Android APIs, later in this chapter. But first let’s look
    at another client-side attack.
  prefs: []
  type: TYPE_NORMAL
- en: USSD Remote Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unstructured Supplementary Service Data (USSD)* is a way for mobile devices
    to communicate with the mobile network. When you dial specific numbers, the device
    will perform certain functions.'
  prefs: []
  type: TYPE_NORMAL
- en: In late 2012, it came to light that some Android devices would automatically
    open a number they discovered on a web page in the dialer application. When USSD
    codes are entered in the dialer, the functionality is automatically called. That
    sounds like a great function for attackers to abuse to control a device remotely.
  prefs: []
  type: TYPE_NORMAL
- en: As it turned out, attackers could put USSD codes in a web page as the number
    to dial and end up forcing these vulnerable devices to do all sorts of interesting
    things. For example, as shown here, the `tel:` tag in a malicious web page tells
    Android this is a phone number. But when the USSD code `2673855%23` is opened
    in the dialer, the device performs a factory restore, deleting all the user’s
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The vulnerability is not in the USSD code itself, but in certain devices’ implementation
    of the `tel:` tag. Various USSD tags offer all sorts of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Our example will use a more innocuous payload than the one described previously.
    We’ll have our device automatically dial a code to present its unique identifier
    in a pop-up, as shown in [Example 20-10](ch20.xhtml#android_ussd_attack "Example 20-10. Android
    USSD attack").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-10. Android USSD attack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To run the safe USSD example in SPF, choose menu option **`6`**, then `3.) USSD
    Webpage Attack (Safe)` ❶. You’ll be asked for the location of the web server,
    the name of the malicious page, and the phone number to text it to. Send it to
    your Android 2.1 emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Now open the page in the SMS you receive on the Android 2.1 emulator. This time,
    instead of crashing the browser, the dialer app opens, and a pop-up notification
    appears, as shown in [Figure 20-2](ch20.xhtml#ussd_autodial "Figure 20-2. USSD
    autodial").
  prefs: []
  type: TYPE_NORMAL
- en: '![USSD autodial](httpatomoreillycomsourcenostarchimages2030590.png.jpg)Figure 20-2. USSD
    autodial'
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, our emulator has no unique identifier, so the number is blank.
    Though this example was not harmful to the device or its data, other USSD codes
    can be if they are opened in the dialer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, this vulnerability, as well as the WebKit issue we exploited in the
    previous section, has been patched since its discovery. Android has a complicated
    relationship with security updates. The problem is that anyone can make an Android
    device with its own implementation of the Android OS. When Google releases a new
    version with a set of patches, every original equipment manufacturer (OEM) needs
    to port the changes to its version of Android, and the carriers need to push updates
    to their devices. However, updates are not delivered consistently, which means
    that millions of unpatched devices may be in use, depending on the model and the
    carrier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s turn our attention to a vulnerability that will probably never be
    patched: malicious applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve studied malicious programs intermittently throughout this book. We created
    malicious executables with Msfvenom in [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework"), uploaded backdoors to vulnerable web servers in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"), looked at social-engineering attacks to trick users
    into downloading and running malicious programs in [Chapter 11](ch11.xhtml "Chapter 11. Social
    Engineering"), and bypassed antivirus programs in [Chapter 12](ch12.xhtml "Chapter 12. Bypassing
    Antivirus Applications").
  prefs: []
  type: TYPE_NORMAL
- en: While social engineering and users undermining security policies by running
    malicious programs will likely be major issues for enterprise security for years
    to come, mobile devices make this issue even more complicated. It’s hard to imagine
    anyone giving you a laptop computer for work and encouraging you to go out to
    the Internet and download every potentially interesting, fun, or productivity-increasing
    program you can find—but that’s exactly how mobile devices are marketed. (“Buy
    our device. It has the best apps.” “Download our apps. They’re the best in productivity/entertainment/security.”)
    Mobile antivirus applications often require extreme permissions and even administrative
    functions on the device in order to run, and mobile device management solutions
    typically require installing even more applications on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile users are inundated with reasons to download apps to their devices, and
    mobile malware is on the rise, much of it in the form of malicious applications.
    If a user can be tricked into installing a malicious app, the attacker can utilize
    Android’s APIs to steal data, gain remote control, and even attack other devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the Android security model, apps must request permissions to use APIs that
    could be used maliciously, and users must accept the requested permissions at
    installation. Unfortunately, users often grant access to all sorts of potentially
    dangerous permissions. We can use Android permissions to control the device without
    running an additional exploit after the user installs the malicious app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Malicious SPF Agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SPF allows us to create a malicious app with a variety of interesting functionality.
    Earlier we used the SPF app on our pentester-controlled device to allow SPF to
    use the device’s mobile modem and other functionality; our goal here is to trick
    users into installing the SPF agent on target devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing, SPF agents can receive commands by checking in to a web
    server over HTTP or via hidden SMS messages from an SPF-controlled mobile modem.
    Naturally, we’ll be more successful if our agent appears to be an interesting
    and/or trustworthy app. We can embed the agent inside any legitimate app: SPF
    can take a compiled APK file and backdoor it with the agent, or if we have the
    source code of the app, we can backdoor that as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring Source Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use backdooring source code for our example. Choose `1.) Attach Framework
    to a Deployed Agent/Create Agent` at the main SPF menu. SPF includes a couple
    of app templates that we can use for our example. You can also import any app
    source code into SPF with option `4`. If you don’t have source code for the app
    you want to impersonate, you can use option `5` to backdoor a compiled APK. You
    can even use the Android Master Key vulnerability discovered in 2013 to replace
    applications already installed on the device with a backdoored version. For now,
    let’s just use one of SPF’s templates, as shown in [Example 20-11](ch20.xhtml#building_the_android_agent
    "Example 20-11. Building the Android agent").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-11. Building the Android agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Choose `2.) Generate Agent App` ❶. We’ll use the MapsDemo example template ❷
    distributed with Android SDK by Google to demonstrate functionality. When prompted,
    give the phone number to send SMS commands to ❸, the SPF the seven-character key
    ❹, and the directory to check in for HTTP commands ❺. For the agent key and path,
    use the same values that you used when you created the SPF app ([Building the
    Android App](ch20.xhtml#building_the_android_app "Building the Android App")).
    Use the Android 4.3 emulator (SPF app) phone number as the control phone number.
    SPF will build the Android agent in the chosen template.
  prefs: []
  type: TYPE_NORMAL
- en: Now to entice the user into downloading and installing the agent, a process
    similar to our client-side attacks, following the steps in [Example 20-12](ch20.xhtml#enticing_the_user_into_installing_the_ag
    "Example 20-12. Enticing the user into installing the agent").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-12. Enticing the user into installing the agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Choose option **`6`** at the main menu, and then choose `1.) Direct Download
    Agent` ❶. You will be asked if you want to send the Android agent or Android Meterpreter
    (a recent addition to Metasploit). Because we’re working with the Android agent,
    choose **`Agent`** ❷. As usual, you are prompted for the path, app name on the
    web server, attack vector, and the number to attack, beginning at ❸. Instruct
    SPF to send an SMS with default text to the Android 2.2 emulator.
  prefs: []
  type: TYPE_NORMAL
- en: On the Android 2.2 emulator, click the link in the SMS when it arrives. The
    app should be downloaded. After it downloads, click **Install**, accept the permissions,
    and open the app. As shown in [Figure 20-3](ch20.xhtml#backdoored_app "Figure 20-3. Backdoored
    app"), the agent will look and feel like the original app template (the Google
    Maps demo), but it has some extra functionality in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '![Backdoored app](httpatomoreillycomsourcenostarchimages2030592.png.jpg)Figure 20-3. Backdoored
    app'
  prefs: []
  type: TYPE_NORMAL
- en: Now to attach SPF to the deployed agent. If you send an SMS campaign to lots
    of numbers, who knows how many users will install the agent or how quickly, but
    the agent has check-in functionality (see [Example 20-13](ch20.xhtml#attaching_spf_to_the_deployed_agent
    "Example 20-13. Attaching SPF to the deployed agent")) that will respond to SPF’s
    query to see if it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-13. Attaching SPF to the deployed agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Choose option **`1`** at the main menu and then choose `1.) Attach Framework`
    `to a` `Deployed Agent` ❶. You are prompted for the path ❷, key ❸, and communication
    method ❹. Enter the values you used when creating the agent.
  prefs: []
  type: TYPE_NORMAL
- en: SPF will appear to hang for a minute as it waits for the agent to respond. After
    it returns to the menu, you should be connected to the agent. Now choose `2.)
    Send Commands to an Agent` from the main menu. You will be presented with a list
    of agents in the database; you should see the agent you just attached to SPF in
    the list as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Backdooring APKs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we move on to using our deployed SPF agent, let’s look at another, perhaps
    more sophisticated, way of creating an agent. Because you may not always have
    the source code of the app you want to backdoor, SPF can work with the precompiled
    APK file. Any APK, including those in the Google Play store, are in scope.
  prefs: []
  type: TYPE_NORMAL
- en: To backdoor an APK with the SPF agent, choose **`1`** from the main menu, and
    then `5.) Backdoor Android APK with Agent`, as shown in [Example 20-14](ch20.xhtml#backdooring_an_apk
    "Example 20-14. Backdooring an APK").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-14. Backdooring an APK
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: SPF does not install the APKTool program, required to decompile APKs, by default;
    it asks if you want to install it. Enter **`y`**, and SPF will install APKTool
    and continue.
  prefs: []
  type: TYPE_NORMAL
- en: When prompted, tell SPF to backdoor the APK */root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk*
    (a compiled version of the Google Maps demo code used previously). SPF will then
    decompile the APK, combine it with the SPF agent, and recompile it.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the agent, SPF needs to know the control phone number, control key,
    and control path. This is the same information we used when backdooring source
    code and is shown in [Example 20-15](ch20.xhtml#setting_options-id00053 "Example 20-15. Setting
    options").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-15. Setting options
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After APKTool recompiles the backdoored APK, we need to sign it. At installation,
    the Android device checks the signatures on an APK. If it is not signed, it will
    be rejected, even by an emulator. Google Play apps are signed using a developer
    key registered with Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: To run apps on emulators and devices that are not restricted to Google Play
    apps, we just use a debug key that is not registered with Google, but the app
    still must be signed. We were able to skip this step when backdooring source code
    because we compiled the code with the Android SDK, which automatically signed
    our code with the default Android keystore. Because we used APKTool here, we need
    to manually re-create the signature.
  prefs: []
  type: TYPE_NORMAL
- en: You will be asked whether you want to use the Android Master Key vulnerability,
    which allows attackers and pentesters to trick the Android signature-verification
    process into thinking our app is a legitimate update to an already installed application.
    In other words, we will be allowed to replace legitimate applications with our
    code, and the Android system will view them as legitimate updates from the vendor.
    (This flaw in the verification process was fixed in Android 4.2.) To use the Android
    Master Key vulnerability, enter **`y`** at the prompt, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To leverage this issue, the original application and its signatures are copied
    into our backdoored APK. Details about how this triggers the Master Key vulnerability
    can be found here: http://www.saurik.com/id/17.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To see the Android Master Key vulnerability at work, install the legitimate
    version of *MapsDemo.apk* from */root/Smartphone-Pentest-Framework/APKs* onto
    a device running an Android version earlier than 4.2, and then try to install
    the backdoored version you just created by delivering it via SMS or NFC with SPF.
    You should be prompted to replace *MapsDemo.apk*, and the signature verification
    should succeed, even though we didn’t have access to the private keys required
    to build a correct signature for our backdoored version.
  prefs: []
  type: TYPE_NORMAL
- en: If your target is not vulnerable to Master Key or the app is not already on
    the target device, you can just sign the app with your default key for the Android
    keystore on Kali. To do this, enter **`n`** at the prompt for Use Android Master
    Key Vuln, as shown in [Example 20-16](ch20.xhtml#signing_the_apk "Example 20-16. Signing
    the APK").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-16. Signing the APK
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You are prompted for the password for the debug keystore. By default, this action
    does not sign the APK with a key for publishing it on Google Play, but it will
    work for our purposes. The app is now signed with a debug key and should install
    on any device that does not restrict apps to official Play Store apps. Note that
    there’s nothing stopping a pentester from signing the app with a legitimate Google
    Play key they have registered if it’s in the scope of the pentest to attempt to
    trick users into downloading malicious apps from the Google Play store.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The backdoored APK is functionality equivalent to the agent we created in [Backdooring
    Source Code](ch20.xhtml#backdooring_source_code "Backdooring Source Code") and
    can be deployed the same way. Of course, we already have a deployed agent to work
    with as we look at what we can do to a device and its local network after an agent
    is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Post Exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’re on the device, we have a few options open to us. We can gather
    local information from the device such as contacts or received SMS messages, and
    we can remotely control the device to have it do things like take a picture. If
    we’re unsatisfied with our permissions, we can attempt to perform privilege escalation
    on the device and get root privileges. We can even use the exploited mobile device
    to attack other devices on the network. (This attack can be particularly interesting
    if the device connects directly to a corporate network or uses a VPN to access
    one.)
  prefs: []
  type: TYPE_NORMAL
- en: Information Gathering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will run an example of information gathering by getting a list of installed
    applications on the infected device as shown in [Example 20-17](ch20.xhtml#running_a_command_on_an_agent
    "Example 20-17. Running a command on an agent").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-17. Running a command on an agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Choose option **`2`** from the main menu, then select the agent from the list
    ❶. When presented with a list of available agent functionality ❷, choose `14.)
    Get Installed Apps List` ❸. SPF asks how you would like to deliver the command;
    we’ll use HTTP ❹. (Recall that agents can communicate and receive commands via
    HTTP and SMS.)
  prefs: []
  type: TYPE_NORMAL
- en: Enter **`0`** to return to the previous menu until you reach the main menu.
    Wait a minute, and then choose `3.) View Information Gathered`, as shown in [Example 20-18](ch20.xhtml#viewing_gathered_data
    "Example 20-18. Viewing gathered data").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-18. Viewing gathered data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You are asked if you want to see the results of Attacks or Agents; type **`Agents`**
    ❶. Choose our agent ❷. Information about the device is pulled from the database,
    though currently all we have is a list of installed apps, gathered by the previous
    command ❸. (You can run additional information-gathering commands to fill in more
    entries.)
  prefs: []
  type: TYPE_NORMAL
- en: Remote Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s see how to use the agent to remotely control the device. We can tell
    the device to send a text message that will not show up in the sent messages of
    the SMS app. In fact, the user will have no indication that a message was sent
    at all—what better way to exploit the circle of trust? Perhaps we can grab all
    the user’s contacts and send them messages telling them they should install our
    cool app, which just so happens to point to the SPF agent. Because the message
    comes from someone they know, the users will be more likely to install the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s just send an example message for now, as shown in [Example 20-19](ch20.xhtml#remotely_controlling_an_agent
    "Example 20-19. Remotely controlling an agent").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-19. Remotely controlling an agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From the agent commands menu, select option `1.) Send SMS` ❶. When prompted
    for a phone number, message contents, and how you want to deliver the command,
    tell your agent to send the message to the Android 2.1 emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Your Android 2.1 emulator will receive an SMS with the text you entered from
    the Android 2.2 emulator, with no indication on either emulator that this is not
    a normal message.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting Through Mobile Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mobile Device Management (MDM) and mobile antivirus applications have a long
    way to go. The number of companies that mandate these solutions for their employees
    is still small when compared with many other security controls, and some companies
    choose not to allow mobile devices at all. But let’s face it: Employees probably
    know the company’s wireless password. Connect your mobile device, and magically
    it’s a member of the same network as your workstation and other devices that might
    contain sensitive information.'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, companies are much better at hardening their externally facing assets.
    After all, these devices are open to attack from anyone on the Internet, and they
    get the lion’s share of the attention. But internally, things start to break down.
    Weak passwords, missing patches, and out-of-date client-side software are all
    issues we’ve examined in this book that could be lurking in the internal network.
    If an exploited mobile device has direct network access to these vulnerable systems,
    we may be able to use it as a pivot to launch additional attacks, completely bypassing
    the perimeter.
  prefs: []
  type: TYPE_NORMAL
- en: We studied pivoting in [Chapter 13](ch13.xhtml "Chapter 13. Post Exploitation"),
    when we used an exploited machine to move from one network to another. We can
    do the same thing here using the SPF agent, effectively running a pentest on the
    mobile network through the exploited mobile device, as illustrated in [Figure 20-4](ch20.xhtml#pivoting_through_an_infected_mobile_devi
    "Figure 20-4. Pivoting through an infected mobile device to attack internal devices").
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting through an infected mobile device to attack internal devices](httpatomoreillycomsourcenostarchimages2030594.png.jpg)Figure 20-4. Pivoting
    through an infected mobile device to attack internal devices'
  prefs: []
  type: TYPE_NORMAL
- en: Portscanning with Nmap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We start by seeing what devices are out there using an agent command option
    to ping sweep the local network. Next, we’ll do some port scanning, as discussed
    in [Chapter 5](ch05.xhtml "Chapter 5. Information Gathering"). As it turns out
    you can install Nmap Android binaries on the exploited device. SPF has install
    scripts for this and other supporting tools. Choose option `10.) Install Stuff`
    from the main menu, and tell SPF to install Nmap for Android, as shown in [Example 20-20](ch20.xhtml#installing_nmap_for_android
    "Example 20-20. Installing Nmap for Android").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-20. Installing Nmap for Android
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now to run Nmap from our Android agent using option `12.) Run Nmap`. Let’s run
    Nmap against our Windows XP target ❶, as shown in [Example 20-21](ch20.xhtml#running_nmap_from_android
    "Example 20-21. Running Nmap from Android"). Make sure that the War-FTP program
    we exploited in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow
    in Windows") and [Chapter 18](ch18.xhtml "Chapter 18. Structured Exception Handler
    Overwrites") is still running. (We’ll exploit it through the pivot in the next
    section.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-21. Running Nmap from Android
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let Nmap run for a couple of minutes, and then check your agent’s gathered information.
    You should notice that the File field links to */root/Smartphone-Pentest-Framework/frameworkconsole/text.txt*.
    View the contents of this file—you should see something similar to [Example 20-22](ch20.xhtml#nmap_results
    "Example 20-22. Nmap results").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-22. Nmap results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rather than run an entire pentest using the exploited mobile device as a pivot,
    let’s finish by running an exploit through the SPF agent.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a System on the Local Network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, Android devices don’t know scripting languages such as Python
    and Perl by default; to run an exploit, we need some C code. A simple C version
    of the exploit we wrote for War-FTP 1.65 in [Chapter 17](ch17.xhtml "Chapter 17. A
    Stack-Based Buffer Overflow in Windows") is in */root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c*.
    The included shellcode runs a *windows/meterpreter/reverse_tcp* payload and sends
    it back to 192.168.20.9 on port 4444\. If your Kali system is at another IP address,
    regenerate the shellcode with Msfvenom, as shown here. (Don’t forget the bad characters
    for War-FTP from [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow
    in Windows"). We can avoid them with Msfvenom using the `-b` flag.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve replaced the shellcode in the exploit, if necessary, we need to
    compile the C code to run on an Android device. If we use GCC, as in [Chapter 3](ch03.xhtml
    "Chapter 3. Programming"), the exploit will run fine from our Kali box, but the
    ARM processor on our Android phones won’t know what to make of it.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly ran into cross compilers for Windows in [Chapter 12](ch12.xhtml "Chapter 12. Bypassing
    Antivirus Applications") that allowed us to compile C code on Kali to run on Windows.
    We can do the same thing for Android as long as we have an ARM cross compiler.
    Luckily, SPF has one. As shown in [Example 20-23](ch20.xhtml#compiling_c_code_to_run_on_android
    "Example 20-23. Compiling C code to run on Android"), choose option `9.) Compile
    code to run on mobile devices` from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-23. Compiling C code to run on Android
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Select `1.) Compile C code for ARM Android` ❶. You will be prompted for the
    C file to compile as well as where you want to put the compiled binary ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to download the War-FTP exploit to our infected Android device.
    From the agent commands menu, choose option **`6`** to download a file. You will
    be asked for the file to download and the delivery method, as shown in [Example 20-24](ch20.xhtml#downloading_the_exploit
    "Example 20-24. Downloading the exploit").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-24. Downloading the exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before we run the exploit, we need to set up a handler in Msfconsole, as shown
    in [Example 20-25](ch20.xhtml#setting_up_multisolidushandler "Example 20-25. Setting
    up multi/handler"). Open Msfconsole on Kali, and use the *multi/handler* module,
    setting the options to match the payload in the War-FTP exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-25. Setting up multi/handler
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it’s time to run the exploit. As shown in [Example 20-26](ch20.xhtml#running_the_exploit-id00055
    "Example 20-26. Running the exploit"), choose option `7.) Execute Command` from
    the agent commands menu; you will be prompted for the command to run.
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-26. Running the exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tell SPF the full command, including arguments ❶. In this case, we need to tell
    the exploit the IP address and port to attack. SPF asks if the binary was downloaded.
    If it was downloaded through SPF, it will be in the agent’s files directory, and
    SPF will need to know to run it from there. In our case, we answer **`yes`** ❷,
    then enter the delivery method as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Watch your Metasploit listener. In about a minute you should receive a Meterpreter
    prompt like the one shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully used SPF as a pivot to run an attack. This may not seem very
    exciting because the emulator, Kali, and the Windows XP target are all on the
    same network, but if Kali is in the cloud and the Windows XP target and an infected
    Android device are on the corporate network, this process would be more useful.
    We can make it more interesting by using command option `10.) TCP Listener` to
    set up a listener to catch our shell on the infected mobile device. Rather than
    calling back out to a listener on our Kali machine, we can instead send our shell
    back to SPF directly using either HTTP or SMS. Using SMS will, of course, allow
    us to completely bypass any perimeter filtering such as firewalls and proxies
    that may inhibit getting shells out of the network from your attacks. This is
    illustrated in [Figure 20-5](ch20.xhtml#bypassing_perimeter_controls_with_an_sms
    "Figure 20-5. Bypassing perimeter controls with an SMS-based shell.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Bypassing perimeter controls with an SMS-based shell.](httpatomoreillycomsourcenostarchimages2030596.png.jpg)Figure 20-5. Bypassing
    perimeter controls with an SMS-based shell.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aside from the privilege escalation example discussed next, there is no reason
    we needed to use Android 2.2 as our target emulator. The other malicious app examples
    we have used in this chapter will work on any version of Android.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege Escalation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a forked Linux kernel, Android shares some of Linux’s privilege escalation
    vulnerabilities, as well as having a few security mistakes of its own. Even OEMs
    have added bugs into their implementations of Android. For example, in 2012, a
    privilege-escalation vulnerability was found in how Samsung devices handled the
    camera memory if they used a certain kind of chip, giving attackers read/write
    access to all of memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more permissions granted to your app, you can attempt to use a known
    issue from the agent to get root privileges, as shown in [Example 20-27](ch20.xhtml#running_a_privilege-escalation_exploit
    "Example 20-27. Running a privilege-escalation exploit").
  prefs: []
  type: TYPE_NORMAL
- en: Example 20-27. Running a privilege-escalation exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From the agent commands menu, choose option `5.) Privilege Escalation`. From
    here we have two options. We can manually choose an exploit from the exploits
    for Android that SPF knows, or we can let SPF make a selection based on the Android
    version number. Our Android 2.2 emulator is vulnerable to an exploit known as
    Rage Against the Cage. Though this is an older exploit, it works well on the emulator,
    so let’s allow SPF to automatically select the exploit, as shown at ❶. Because
    this is Android 2.2, SPF correctly selects `rageagainstthecage` ❷ and asks for
    the delivery method ❸.
  prefs: []
  type: TYPE_NORMAL
- en: After giving the exploit a little time to run, check back with option **`3`**
    from the main menu. The Rooted field should read `RageAgainstTheCage`, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From here we have full control of the device. We can issue commands from a root
    shell or reinstall the agent as a system app, giving us even more privileges than
    the original app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This particular exploit is a resource exhaustion attack, so if you want to continue
    using the emulator for additional exercises, you may want to restart it, as it
    may perform slower after this attack.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we took a brief look at the relatively new and rapidly evolving
    world of mobile exploitation. We used my SPF tool to run a variety of attacks,
    primarily on emulated Android mobile devices. These attacks will, of course, work
    on real devices in the same way. We looked at a remote attack that checked for
    a default SSH password on jailbroken iPhones, and then studied two client-side
    attack examples. One gave us a shell through a WebKit vulnerability in the browser,
    and the other remotely controlled the device through USSD codes that were automatically
    dialed from a web page.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to malicious applications, backdooring legitimate source code or
    compiled APK files with the SPF Android agent. We can use mobile-attack vectors
    such as NFC and SMS to trick users into installing our malicious app. Once the
    agent was installed, we ran attacks such as information gathering and remote control,
    and we used SPF to escalate our privileges to root using known vulnerabilities
    in the Android platform. Finally, we used the SPF agent as a pivot to attack other
    devices in the network. We ran Nmap from the Android device against our Windows
    XP target, and then used a C exploit for War-FTP to exploit the Windows XP target
    from the SPF agent.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile device security is an exciting field that is adding new dimensions to
    pentesting as the devices enter the workplace. As a pentester, knowing a bit about
    mobile vulnerabilities will come in handy. As attackers use these devices to gain
    sensitive data and a foothold in the network, pentesters must be able to simulate
    these same threats.
  prefs: []
  type: TYPE_NORMAL
