- en: Chapter 20. Using the Smartphone Pentest Framework
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20章 使用智能手机渗透框架
- en: '*Bring your own device (BYOD)* is a big buzzword in the industry right now.
    Though we’ve been bringing our own devices to work in one form or another for
    years (contractor laptops or that game console someone left connected to the network
    in the breakroom, for example), mobile devices are now entering the workplace
    en masse, and it falls to security teams and pentesters to evaluate the security
    risks of these devices.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*自带设备（BYOD）*目前在行业中是一个热门话题。尽管多年来我们一直以某种形式将自己的设备带到工作中（例如承包商的笔记本电脑或某人将游戏主机连接到休息室网络上），但如今移动设备正大规模进入职场，安全团队和渗透测试人员的任务是评估这些设备的安全风险。'
- en: In this chapter, we’ll focus on tools and attacks for assessing the security
    of mobile devices. Mobile technology is a rapidly developing field, and though
    we can cover only the basics here, developing new mobile attacks and post-exploitation
    techniques is an ideal place to start with your own security research. For example,
    we’ll be discussing a tool I created to help pentesters to assess the security
    posture of mobile devices, the *Smartphone Pentest Framework (SPF)*. After working
    your way through this book, you will be ready to embark on your own infosec journey
    and perhaps write a tool of your own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍用于评估移动设备安全性的工具和攻击方式。移动技术是一个快速发展的领域，尽管我们这里只能涵盖基础内容，但开发新的移动攻击和后渗透技术是进行安全研究的理想起点。例如，我们将讨论我创建的一款工具——*智能手机渗透框架（SPF）*，它帮助渗透测试人员评估移动设备的安全状态。通过本书的学习，你将准备好开始自己的信息安全之旅，甚至可能会开发出你自己的工具。
- en: For most of the examples in this chapter, we’ll use the Android platform as
    a target because, in addition to being the most ubiquitous platform, it also allows
    you to create emulators on Windows, Linux, and Mac OS platforms. Although we’ll
    focus on Android, we’ll also explore an attack on a jailbroken iPhone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数示例将使用Android平台作为目标，因为除了它是最普及的操作平台外，它还允许你在Windows、Linux和Mac OS平台上创建模拟器。尽管我们将重点讨论Android，但我们也会探讨对越狱iPhone的攻击。
- en: Mobile Attack Vectors
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动攻击向量
- en: Though mobile devices run operating systems, speak TCP/IP, and access a lot
    of the same resources that traditional computers do, they also have their own
    unique features that add new attack vectors and protocols to the mix. Some features
    have been causing security problems on devices for years, while others such as
    near field communication, discussed later, are fairly new.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管移动设备运行操作系统、支持TCP/IP协议，并且能够访问与传统计算机相同的资源，但它们也有自己独特的功能，带来了新的攻击向量和协议。一些功能已经在设备上存在多年并造成了安全问题，而像近场通信（NFC）这样的新功能，稍后将进行讨论，算是比较新的安全挑战。
- en: Text Messages
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短信
- en: Many mobile devices can send and receive text (SMS) messages. Though limited
    in size, text messages allow users to communicate almost simultaneously, often
    replacing email for written communications. SMS opens up a new social-engineering
    attack vector.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动设备都能发送和接收文本（短信）消息。尽管短信的大小有限，但它使用户几乎可以实时通信，常常取代电子邮件作为书面沟通方式。短信为社交工程攻击提供了一个新的攻击向量。
- en: 'Traditionally, email has been the medium for sending spam and phishing attempts,
    but even free email solutions do a decent job of filtering out the garbage these
    days. (If you ever need a laugh at work, check your email spam folder.) SMS is
    a different story: Although some mobile antivirus suites allow you to blacklist
    and whitelist certain mobile numbers, generally if you text a number to a device,
    the message will be received. This makes SMS an ideal vector for spam and phishing
    attacks.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，电子邮件一直是发送垃圾邮件和网络钓鱼尝试的媒介，但即使是免费的电子邮件解决方案，今天也能有效地过滤掉垃圾邮件。（如果你需要在工作中找点乐子，可以去看看你的电子邮件垃圾邮件文件夹。）短信则是另一个故事：尽管一些移动防病毒软件允许你对某些手机号码进行黑名单和白名单设置，但通常只要你向设备发送短信，该消息就会被接收。这使得短信成为进行垃圾邮件和网络钓鱼攻击的理想载体。
- en: We’re already seeing annoying mobile ads and SMS phishing attempts that lure
    users to a counterfeit website to enter their credentials, much like the site-cloning
    attacks from [Chapter 11](ch11.xhtml "Chapter 11. Social Engineering"). These
    attacks will no doubt become more prevalent as time goes on. Security-awareness
    training will need to be augmented to include this threat. A user who knows better
    than to click a random link in a suspicious-looking email may still click a random
    link in a text message. After all, it’s just a text—how could a text possibly
    hurt you? But that link will open in the mobile browser or another app that may
    contain additional vulnerabilities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始看到令人烦恼的移动广告和短信钓鱼攻击，这些攻击诱使用户访问虚假的网站并输入他们的凭证，类似于[第11章](ch11.xhtml "第11章
    社会工程学")中的网站克隆攻击。随着时间的推移，这些攻击无疑会变得更加普遍。安全意识培训需要加强，以应对这一威胁。一个知道不该点击可疑邮件中随机链接的用户，仍然可能会点击短信中的随机链接。毕竟，那只是一个短信——短信怎么可能伤害你呢？但是，那个链接会在移动浏览器或其他应用中打开，而这些应用可能存在额外的漏洞。
- en: Near Field Communication
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近场通信
- en: 'Mobile devices bring yet another attack vector to the table: *near field communication*,
    or *NFC*. NFC allows devices to share data by touching or being near each other.
    Mobile devices with NFC enabled can scan NFC tags to automate tasks such as changing
    settings or opening applications. Some can beam data, such as a photo or an entire
    app, from one device to another. NFC is another ideal social-engineering attack
    vector. For example, in Mobile Pwn2Own 2013, an exploitation contest, researchers
    used NFC to attack an Android device by beaming a malicious payload to a vulnerable
    application on the device. Therefore, security awareness training should also
    teach users to be aware of which NFC tags their device responds to and who they
    are beaming data with.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备带来了另一个攻击向量：*近场通信*，或称 *NFC*。NFC 允许设备通过接触或靠近彼此来共享数据。启用 NFC 的移动设备可以扫描 NFC 标签来自动执行任务，如更改设置或打开应用程序。有些设备还可以将数据（如照片或整个应用）从一台设备传输到另一台设备。NFC
    是另一个理想的社会工程学攻击向量。例如，在 2013 年的 Mobile Pwn2Own 持续漏洞利用竞赛中，研究人员通过将恶意载荷传送到设备上的一个易受攻击应用，利用
    NFC 攻击了一台 Android 设备。因此，安全意识培训还应教授用户注意自己的设备响应哪些 NFC 标签，以及他们与谁共享数据。
- en: QR Codes
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维码
- en: '*Quick response (QR) codes* are matrix barcodes originally developed for use
    in auto manufacturing. QR codes can embed URLs, send data to an application on
    a mobile device, and so on, and users should be aware that what they are scanning
    may open something malicious. That QR code on a store window doesn’t have to point
    to the store’s website, and malicious QR code attacks have occurred in the wild.
    For instance, one prominent hacktivist changed his Twitter profile picture to
    a QR code, prompting many curious users to scan it with their phones. The QR code
    directed them to a malicious web page that attempted to exploit vulnerabilities
    in WebKit, a web page rendering engine used by both iOS and Android.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速响应（QR）码* 是最初为汽车制造业开发的矩阵条形码。二维码可以嵌入网址，将数据发送到移动设备上的应用程序等，用户应当意识到他们扫描的内容可能会打开恶意网站。商店窗户上的二维码不一定指向商店的官网，而且恶意二维码攻击已经在现实中发生过。例如，一位著名的黑客活动者将他的
    Twitter 头像改为二维码，促使许多好奇的用户使用手机扫描它。二维码将他们引导到一个恶意网页，试图利用 WebKit 漏洞，WebKit 是 iOS 和
    Android 都使用的网页渲染引擎。'
- en: The Smartphone Pentest Framework
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能手机渗透测试框架
- en: Enough talk; let’s turn our attention to actually attacking mobile devices with
    the help of SPF. SPF is still under active development and its feature set changes
    rapidly. By the time you work through this section, many of the menus may offer
    additional options. In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual
    Lab"), you downloaded the version of the SPF used in this book, but to get the
    main and most up-to-date branch of SPF, visit *[https://github.com/georgiaw/Smartphone-Pentest-Framework.git/](https://github.com/georgiaw/Smartphone-Pentest-Framework.git/)*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，话不多说；让我们将注意力转向如何利用 SPF 实际攻击移动设备。SPF 仍在积极开发中，其功能集变化迅速。当你完成这一部分内容时，许多菜单可能会提供额外的选项。在[第1章](ch01.xhtml
    "第1章 设置虚拟实验室")中，你下载了本书使用的 SPF 版本，但要获取 SPF 的主分支和最新版本，请访问 *[https://github.com/georgiaw/Smartphone-Pentest-Framework.git/](https://github.com/georgiaw/Smartphone-Pentest-Framework.git/)*。
- en: Setting Up SPF
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 SPF
- en: If you followed the instructions in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), SPF should be all set up and ready to go. Because SPF uses
    Kali’s built-in web server to deliver some payloads, make sure that the Apache
    server is running, as shown here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[第1章](ch01.xhtml "第1章. 设置虚拟实验室")中的说明进行操作，SPF应该已经设置完毕并可以运行。因为SPF使用Kali内置的Web服务器来交付某些payload，请确保Apache服务器正在运行，如下所示。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Additionally, SPF records information in either a MySQL or PostgreSQL database.
    Make sure the MySQL database is started, as shown here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SPF会将信息记录在MySQL或PostgreSQL数据库中。确保MySQL数据库已启动，如下所示。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last thing to do is edit our SPF configuration file, */root/Smartphone-Pentest-Framework/frameworkconsole/config*,
    to match our environment. The default configuration file is shown in [Example 20-1](ch20.xhtml#spf_config_file
    "Example 20-1. SPF config file").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是编辑我们的SPF配置文件*/root/Smartphone-Pentest-Framework/frameworkconsole/config*，以匹配我们的环境。默认的配置文件在[示例
    20-1](ch20.xhtml#spf_config_file "示例 20-1. SPF配置文件")中显示。
- en: Example 20-1. SPF config file
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-1. SPF配置文件
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default should meet your needs if your Kali IP address is 192.168.20.9 and
    you installed SPF in */root/Smartphone-Pentest-Framework/*. Otherwise, change
    the `IPADDRESS` ❶ and `SHELLIPADDRESS` ❷ to your Kali machine’s IP address.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Kali IP地址是192.168.20.9，并且你将SPF安装在*/root/Smartphone-Pentest-Framework/*中，默认配置应该满足你的需求。否则，修改`IPADDRESS`
    ❶和`SHELLIPADDRESS` ❷为你的Kali机器的IP地址。
- en: Now run SPF by changing the directory to */root/Smartphone-Pentest-Framework/frameworkconsole/*
    and running **`./framework.py`**. You should be presented with a menu similar
    to [Example 20-2](ch20.xhtml#starting_spf "Example 20-2. Starting SPF").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过切换目录到*/root/Smartphone-Pentest-Framework/frameworkconsole/*并运行**`./framework.py`**来启动SPF。你应该看到一个类似于[示例
    20-2](ch20.xhtml#starting_spf "示例 20-2. 启动SPF")的菜单。
- en: Example 20-2. Starting SPF
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-2. 启动SPF
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will spend the rest of the chapter exploring SPF’s various options. For now,
    let’s run a quick test to make sure that SPF can communicate with the database.
    The SPF installer set up an empty database for SPF, but you can clear out all
    your data and start fresh by running option `7.) Clear/Create` `Database`, as
    shown here. This command will clear the SPF database tables and create them if
    they do not already exist.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分将探索SPF的各种选项。现在，让我们进行一个快速测试，确保SPF能够与数据库通信。SPF安装程序为SPF设置了一个空的数据库，但你可以通过运行选项`7.)
    清除/创建` `数据库`来清除所有数据并重新开始，如下所示。此命令将清除SPF数据库表，并在它们不存在时创建它们。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Android Emulators
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android模拟器
- en: In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"), we created
    three Android emulators. Though some of our attacks will work regardless of the
    Android version, we’ll look at certain client-side and privilege-escalation attacks
    that work well on emulators that target these specific older versions. Because
    they’re only emulators, you won’t be able to successfully test all known Android
    exploits against your Android emulators.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml "第1章. 设置虚拟实验室")中，我们创建了三个Android模拟器。虽然我们的一些攻击不依赖于Android版本，但我们将查看一些适用于模拟器的客户端攻击和权限提升攻击，这些攻击在针对特定较旧版本的模拟器时效果较好。由于它们只是模拟器，你将无法成功测试所有已知的Android漏洞。
- en: Attaching a Mobile Modem
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加移动调制解调器
- en: Because not all mobile attack vectors use the TCP/IP network, SPF piggybacks
    on the pentester’s devices. As of this writing, SPF can use the mobile modem of
    an Android phone with the SPF app installed or USB modem with a SIM card to send
    SMS messages. Additionally, when using an Android phone with NFC capability, SPF
    can deliver payloads via Android Beam and the SPF Android App.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有移动攻击向量都使用TCP/IP网络，SPF通过渗透测试者的设备进行攻击。截至目前，SPF可以使用安装了SPF应用的Android手机的移动调制解调器，或带有SIM卡的USB调制解调器来发送短信。此外，当使用具有NFC功能的Android手机时，SPF可以通过Android
    Beam和SPF Android应用程序交付payload。
- en: Building the Android App
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建Android应用
- en: To build the Android app from SPF, choose option `4.) Attach Framework to a
    Mobile Modem`, as shown in [Example 20-3](ch20.xhtml#building_the_spf_app "Example 20-3. Building
    the SPF app").
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要从SPF构建Android应用程序，请选择选项`4.) 将框架附加到移动调制解调器`，如[示例 20-3](ch20.xhtml#building_the_spf_app
    "示例 20-3. 构建SPF应用程序")所示。
- en: Example 20-3. Building the SPF app
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-3. 构建SPF应用程序
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next select option `3.) Generate smartphone based app` ❶. SPF can make two
    kinds of apps: one that uses NFC, and one that does not. Because our Android emulator
    lacks NFC capabilities, choose `1.) Android App (Android 1.6)` ❷.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来选择选项`3.) 生成基于智能手机的应用` ❶。SPF可以制作两种类型的应用程序：一种使用NFC，另一种不使用。由于我们的Android模拟器不支持NFC功能，选择`1.)
    Android应用（Android 1.6）` ❷。
- en: You’ll be asked to enter information about an SPF agent to control via the SPF
    app. SPF agents allow us to control an infected mobile device. We’ll look at generating
    and deploying SPF agents later in the chapter; for now, just enter the phone number
    of your Android 2.2 emulator ❸, a seven-character key ❹, and a path on the web
    server starting with `/` ❺. SPF will then use the Android SDK to build the SPF
    app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将要求你输入有关SPF代理的信息，以便通过SPF应用程序进行控制。SPF代理允许我们控制被感染的移动设备。我们将在本章稍后讨论如何生成和部署SPF代理；目前，只需输入你的Android
    2.2模拟器的电话号码❸，一个七字符的密钥❹，以及Web服务器上的路径，从`/`开始❺。SPF将使用Android SDK来构建SPF应用程序。
- en: Deploying the App
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Now to deploy the app on our Android 4.3 emulator. This emulator will simulate
    the pentester-controlled device, and the other two emulators will be our targets.
    If you’re running your emulators on Kali Linux or using real Android devices that
    you can attach via USB to your Kali virtual machine, you can use Android Debug
    Bridge (ADB) to install the app, as shown in [Example 20-4](ch20.xhtml#installing_the_spf_app
    "Example 20-4. Installing the SPF app"). (First, choose option `4.) Attach Framework
    to a Mobile Modem` from the main menu.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将应用程序部署到我们的Android 4.3模拟器上。这个模拟器将模拟渗透测试人员控制的设备，另外两个模拟器将是我们的目标。如果你在Kali Linux上运行模拟器，或者使用可以通过USB连接到Kali虚拟机的真实Android设备，你可以使用Android调试桥（ADB）来安装应用程序，如[示例20-4](ch20.xhtml#installing_the_spf_app
    "示例20-4. 安装SPF应用程序")所示。（首先，从主菜单选择选项`4.) 将框架附加到移动调制解调器`。）
- en: Example 20-4. Installing the SPF app
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例20-4. 安装SPF应用程序
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the Choose a type of modem to attach to menu, select option **`5`** to
    have ADB search for all attached devices. Next, tell SPF which emulator or device
    to install SPF on; in this example I’ve chosen `emulator-5554` ❶, the Android
    4.3 emulator with phone number 1-555-521-5554\. Finally, tell SPF to install the
    Android app without NFC (option **`2`**) ❷.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要附加的调制解调器类型菜单中，选择选项**`5`**，让ADB搜索所有已连接的设备。接下来，告诉SPF要在哪个模拟器或设备上安装SPF；在这个例子中，我选择了`emulator-5554`❶，这是一个Android
    4.3模拟器，电话号码是1-555-521-5554。最后，告诉SPF安装不带NFC的Android应用程序（选项**`2`**）❷。
- en: If you’re using emulators on your host system, ADB from Kali will not be able
    to attach to them. Instead, to deploy the app, choose option `4.) Attach` `Framework
    to a Mobile Modem` from the main menu and then choose option `4.) Copy App to
    Webserver`, as shown in [Example 20-5](ch20.xhtml#copy_app_to_web_server "Example 20-5. Copy
    app to web server").
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在主机系统上使用模拟器，Kali中的ADB将无法连接到它们。相反，为了部署应用程序，从主菜单选择选项`4.) 将框架附加到移动调制解调器`，然后选择选项`4.)
    将应用程序复制到Web服务器`，如[示例20-5](ch20.xhtml#copy_app_to_web_server "示例20-5. 复制应用程序到Web服务器")所示。
- en: Example 20-5. Copy app to web server
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例20-5. 复制应用程序到Web服务器
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will allow us to copy the app to Kali’s web server, where we can download
    and install it to the emulator. Tell SPF to copy the Framework Android App without
    NFC ❶, and then tell it where to put the app on the web server ❷. Finally, tell
    SPF the filename for the app to be downloaded ❸. Download the app from your Android
    4.3 emulator by opening the URL *[http://192.168.20.9/bookspf2/app.apk](http://192.168.20.9/bookspf2/app.apk)*
    in the mobile browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们将应用程序复制到Kali的Web服务器上，在那里我们可以下载并安装到模拟器中。告诉SPF复制不带NFC的框架Android应用程序❶，然后告诉它将应用程序放到Web服务器上的位置❷。最后，告诉SPF要下载的应用程序的文件名❸。通过在移动浏览器中打开URL
    *[http://192.168.20.9/bookspf2/app.apk](http://192.168.20.9/bookspf2/app.apk)*，从你的Android
    4.3模拟器下载应用程序。
- en: Attaching the SPF Server and App
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加SPF服务器和应用程序
- en: Now we need to attach the SPF server and the SPF app, as shown in [Example 20-6](ch20.xhtml#attaching_to_spf_app
    "Example 20-6. Attaching to SPF app"). (Again, begin with option **`4`** in the
    main menu.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要附加SPF服务器和SPF应用程序，如[示例20-6](ch20.xhtml#attaching_to_spf_app "示例20-6. 附加到SPF应用程序")所示。（再次，从主菜单开始选择选项**`4`**。）
- en: Example 20-6. Attaching to SPF app
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例20-6. 附加到SPF应用程序
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Choose `2.) Attach to a smartphone based app` ❶. Next, give SPF the phone number
    of the emulator running the SPF app ❷, a seven-character key ❸, and the URL where
    the app will check in ❹. (The key does not need to be the same one we used for
    the agent when building the app. Also the URL should be different from the one
    used for the agent when building the app.) Once you’ve confirmed that this information
    is correct, SPF will appear to hang. We need to attach the app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`2.) 附加到智能手机应用程序`❶。接下来，提供运行SPF应用程序的模拟器的电话号码❷，一个七字符的密钥❸，以及应用程序将检查的URL❹。（密钥不需要与我们在构建应用程序时为代理使用的密钥相同。并且，URL应该与构建应用程序时为代理使用的URL不同。）一旦确认这些信息无误，SPF似乎会挂起。我们需要附加应用程序。
- en: '![SPF app](httpatomoreillycomsourcenostarchimages2030588.png.jpg)Figure 20-1. SPF
    app'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![SPF 应用程序](httpatomoreillycomsourcenostarchimages2030588.png.jpg)图 20-1. SPF
    应用程序'
- en: To attach the app, first open it on the Android emulator. The main screen asks
    for the IP address of the SPF server, the URL to check in, and the seven-character
    key. Use the same values as in the previous step (except the IP address should
    be the IP address of the SPF server rather than the phone number), as shown in
    [Figure 20-1](ch20.xhtml#spf_app "Figure 20-1. SPF app").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接该应用程序，首先在 Android 模拟器上打开它。主屏幕会要求输入 SPF 服务器的 IP 地址、要检查的 URL 以及七位字符的密钥。使用与前一步相同的值（除了
    IP 地址应为 SPF 服务器的 IP 地址，而不是电话号码），如 [图 20-1](ch20.xhtml#spf_app "图 20-1. SPF 应用程序")
    所示。
- en: After you’ve filled out the information, click **Attach** on the app. You will
    now be able to control the phone from SPF until you click Detach. Now return to
    SPF on Kali. When the app is attached, you are dropped back to the main SPF menu,
    which means we’re ready to start running mobile attacks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 填写完信息后，点击应用程序上的 **附加**。现在，直到你点击解除连接，你就可以通过 SPF 控制手机了。现在返回 Kali 上的 SPF。当应用程序附加后，你会被带回到
    SPF 的主菜单，这意味着我们准备开始运行移动攻击了。
- en: Remote Attacks
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程攻击
- en: In the history of mobile devices, there have been attacks on the mobile modem
    and other externally facing interfaces. For example, researchers found vulnerabilities
    in the mobile modem drivers for both Android phones and the iPhone that allowed
    attackers to crash the phone, take it off the mobile network, or even gain command
    execution on it, just by sending an SMS message. Like traditional computers, as
    the security position of mobile devices improves, the number of available remote
    attacks will decrease. That said, the more software users install on their phones,
    the greater the chance that there’s a potentially vulnerable service listening
    on a network port, as you’ll learn in the following sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备的历史上，曾经有过对移动调制解调器和其他面向外部的接口的攻击。例如，研究人员发现了 Android 手机和 iPhone 的移动调制解调器驱动程序中的漏洞，攻击者可以通过发送
    SMS 短信使手机崩溃、使其脱离移动网络，甚至获得手机的命令执行权限。与传统计算机类似，随着移动设备的安全状况不断改善，可用的远程攻击数量将减少。话虽如此，用户在手机上安装的软件越多，潜在的漏洞服务监听网络端口的机会就越大，正如你将在接下来的章节中了解到的那样。
- en: Default iPhone SSH Login
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认 iPhone SSH 登录
- en: One remote attack was perhaps the cause of the first iPhone botnet. On jailbroken
    iPhones, users can install SSH to log in to their iPhone terminals remotely. By
    default, SSH has the root password *alpine* on all devices. Of course, users should
    change this value, but many who jailbreak their iPhones do not. Though this issue
    came to light years ago, as with many default password issues, it continues to
    pop up.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一次远程攻击可能是第一个 iPhone 僵尸网络的原因。在越狱的 iPhone 上，用户可以安装 SSH 以远程登录到他们的 iPhone 终端。默认情况下，SSH
    在所有设备上都有 root 密码 *alpine*。当然，用户应该更改这个值，但许多越狱 iPhone 的用户并没有这么做。尽管这个问题在多年前就已经曝光，但与许多默认密码问题一样，它依然时常出现。
- en: To test for this default SSH password on a jailbroken iPhone, we could choose
    `5.) Run a Remote Attack`, or use our old friend, Metasploit. Much as SET allowed
    us to create client-side attacks in Metasploit in [Chapter 11](ch11.xhtml "Chapter 11. Social
    Engineering"), we can use SPF to interface with Msfcli to automate running mobile
    modules from Metasploit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试越狱 iPhone 上的默认 SSH 密码，我们可以选择 `5.) 运行远程攻击`，或者使用我们的老朋友 Metasploit。正如 SET 允许我们在
    [第11章](ch11.xhtml "第11章. 社会工程学")中使用 Metasploit 创建客户端攻击一样，我们可以使用 SPF 与 Msfcli 接口，以自动运行来自
    Metasploit 的移动模块。
- en: Unfortunately, as of this writing, not much in Metasploit targets mobile devices,
    but one module does test for use of the default iPhone password. As shown in [Example 20-7](ch20.xhtml#root_ssh_default_password_metasploit_mod
    "Example 20-7. Root SSH default password Metasploit module"), from the main SPF
    menu choose `8.) Use Metasploit`, and then choose `1.) Run iPhone Metasploit Modules`.
    Next, choose `1.) Cydia Default SSH Password`. SPF will ask you for the IP address
    of the iPhone in order to fill in the `RHOST` option in the module. SPF will then
    call Msfcli and run the desired module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截止到目前为止，Metasploit 中针对移动设备的模块并不多，但有一个模块可以测试是否使用了默认的 iPhone 密码。如 [示例 20-7](ch20.xhtml#root_ssh_default_password_metasploit_mod
    "示例 20-7. Root SSH 默认密码 Metasploit 模块") 中所示，从 SPF 主菜单中选择 `8.) 使用 Metasploit`，然后选择
    `1.) 运行 iPhone Metasploit 模块`。接下来，选择 `1.) Cydia 默认 SSH 密码`。SPF 会询问你 iPhone 的 IP
    地址，以便填写模块中的 `RHOST` 选项。然后 SPF 会调用 Msfcli，并运行所需的模块。
- en: Example 20-7. Root SSH default password Metasploit module
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-7. Root SSH 默认密码 Metasploit 模块
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you have a jailbroken iPhone handy, you can test this module. Metasploit
    will present you with a root shell if the login succeeds. When you are finished,
    type **`exit`** to close the shell and return to SPF. Of course, if you have SSH
    on your iPhone, be sure to change the password from *alpine* right away.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手边有一台越狱的 iPhone，可以测试此模块。如果登录成功，Metasploit 将为你提供一个 root shell。完成后，输入**`exit`**以关闭
    Shell 并返回 SPF。当然，如果你的 iPhone 上启用了 SSH，务必立即将密码从*alpine*更改。
- en: Client-Side Attacks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端攻击
- en: With mobile devices, client-side attacks are more prevalent than remote attacks.
    And as with the attacks we studied in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), our client-side attacks are not restricted to the mobile browser.
    We can attack other default apps on the device as well as any third-party apps
    that may have bugs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上，客户端攻击比远程攻击更为普遍。就像我们在[第 10 章](ch10.xhtml "第 10 章. 客户端利用")研究的攻击一样，我们的客户端攻击并不限于移动浏览器。我们可以攻击设备上的其他默认应用，以及任何可能存在漏洞的第三方应用。
- en: Client-Side Shell
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端 Shell
- en: Let’s look at an example of attacking the WebKit package in the mobile browser
    to gain a shell on an Android device. (This is similar to the browser attacks
    discussed in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side Exploitation").)
    We’ll attack a flaw in the mobile browser after enticing the user into opening
    a malicious page. The executed shellcode will be for Android, not Windows, but
    the overall attack dynamics are the same, as shown in [Example 20-8](ch20.xhtml#android_browser_attack
    "Example 20-8. Android browser attack").
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个攻击移动浏览器中 WebKit 包以获取 Android 设备 Shell 的例子。（这类似于在[第 10 章](ch10.xhtml "第
    10 章. 客户端利用")中讨论的浏览器攻击。）我们将在诱使用户打开恶意页面后攻击移动浏览器中的一个漏洞。执行的 Shell 代码将是 Android 的，而不是
    Windows，但整体攻击动态是相同的，如[示例 20-8](ch20.xhtml#android_browser_attack "示例 20-8. Android
    浏览器攻击")所示。
- en: Example 20-8. Android browser attack
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-8. Android 浏览器攻击
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the main SPF menu choose `6.) Run a social engineering or client s``ide
    attack`. Now choose `2.) Client Side Shell` ❶ then exploit option `1.)` `CVE=2010-1759
    Webkit Vuln Android` ❷. You will be prompted for the path on the web server ❸
    and asked for a filename ❹. SPF will then generate a malicious page to attack
    the CVE-2010-1759 WebKit vulnerability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从主 SPF 菜单中选择`6.) 进行社交工程或客户端攻击`。现在选择`2.) 客户端 Shell` ❶ 然后选择利用选项`1.)` `CVE=2010-1759
    Webkit 漏洞 Android` ❷。系统会提示你输入网页服务器的路径 ❸，并要求输入文件名 ❹。SPF 然后会生成一个恶意页面来攻击 CVE-2010-1759
    WebKit 漏洞。
- en: 'You will then be asked how you want to deliver a link to the malicious page
    ❺. You can use either NFC or SMS. Because our emulator does not support NFC, we
    choose SMS. When prompted for the number to attack, send the SMS to your Android
    2.1 emulator. Finally, when asked if you want to use custom text for the SMS (rather
    than the default “This is a cool page: <link>”), change the default to something
    more creative, or not.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，系统会询问你希望如何传送恶意页面的链接 ❺。你可以选择使用 NFC 或 SMS。由于我们的模拟器不支持 NFC，我们选择了 SMS。当系统提示输入攻击目标的号码时，向你的
    Android 2.1 模拟器发送短信。最后，当询问是否使用自定义文本发送短信（而不是默认的“这是一个酷页面：<link>”）时，可以将默认文本更改为更具创意的内容，或者不更改。
- en: We have only one mobile modem attached to SPF, so SPF automatically uses it
    to send the SMS message. SPF contacts our SPF app on the Android 4.3 emulator
    and instructs it to send a text message to the Android 2.1 emulator. The SMS received
    by the Android 2.1 emulator will be from the Android 4.3 emulator. (Some mobile
    devices, such as iPhones, have a flaw in how they implement SMS that allows attackers
    to spoof the sender number to make it look like this attack came from any number
    they’d like.) The message received is shown here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个移动调制解调器连接到 SPF，因此 SPF 会自动使用它发送短信。SPF 会联系 Android 4.3 模拟器上的 SPF 应用，并指示它将短信发送到
    Android 2.1 模拟器。Android 2.1 模拟器接收到的短信将来自 Android 4.3 模拟器。（一些移动设备，如 iPhone，存在实现短信功能时的缺陷，使得攻击者能够伪造发送号码，造成此攻击看起来像是来自任何他们想要的号码。）收到的短信如下所示。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like the client-side attacks discussed in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), this attack relies on the user opening the link in a vulnerable
    mobile browser. Our Android 2.1 emulator browser is vulnerable to the attack,
    and when you click the link to open the mobile browser, the browser will attempt
    to open the page for 30 seconds or so as the attack is running, before crashing.
    At that point, you should have a shell waiting for you in SPF. SPF automatically
    runs the Android equivalent of `whoami` when the shell opens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第10章](ch10.xhtml "第10章. 客户端攻击")中讨论的客户端攻击类似，这种攻击依赖于用户在易受攻击的移动浏览器中打开链接。我们的 Android
    2.1 模拟器浏览器易受到此攻击，当你点击链接以打开移动浏览器时，浏览器将在大约 30 秒内尝试打开页面，期间攻击正在进行，随后崩溃。此时，你应该已经在 SPF
    中获得了一个 shell。SPF 会在 shell 打开时自动运行 Android 相当于 `whoami` 的命令。
- en: Because we attacked the browser, we’re running as *app_2*, the mobile browser
    on our emulator. As usual, the shell has all the permissions of the exploited
    app, meaning that you can run any commands available to the browser. For example,
    enter **`/system/bin/ls`**, as shown in [Example 20-9](ch20.xhtml#android_shell
    "Example 20-9. Android shell"), to use `ls` to list the contents of the current
    directory. When you’ve finished, enter **`exit`** to return to SPF.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们攻击的是浏览器，因此我们是以 *app_2*（模拟器中的移动浏览器）的身份运行。像往常一样，shell 拥有被利用应用的所有权限，这意味着你可以运行浏览器可用的任何命令。例如，输入
    **`/system/bin/ls`**，如[示例 20-9](ch20.xhtml#android_shell "示例 20-9. Android shell")所示，使用
    `ls` 列出当前目录的内容。完成后，输入 **`exit`** 以返回 SPF。
- en: Example 20-9. Android shell
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-9. Android shell
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android is a forked Linux kernel, so once we have a shell, we should be ready
    to go with Android, right? Unfortunately, many Linux utilities like `cp` aren’t
    there. Additionally, the user structure is a bit different, with each app having
    its own UID. A deep dive into Android, however, is beyond the scope of this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Android 是一个分支的 Linux 内核，因此一旦我们获得了 shell，我们应该可以开始使用 Android，对吧？不幸的是，许多 Linux
    工具如 `cp` 并不在其中。此外，用户结构也略有不同，每个应用都有自己的 UID。然而，深入了解 Android 超出了本章的范围。
- en: We’ll look at an alternative way to control exploited Android devices, using
    backdoored apps to call Android APIs, later in this chapter. But first let’s look
    at another client-side attack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后探讨另一种控制被利用的 Android 设备的方法，使用植入后门的应用调用 Android API。但首先，让我们来看一下另一种客户端攻击。
- en: USSD Remote Control
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USSD 远程控制
- en: '*Unstructured Supplementary Service Data (USSD)* is a way for mobile devices
    to communicate with the mobile network. When you dial specific numbers, the device
    will perform certain functions.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*无结构补充服务数据（USSD）* 是一种移动设备与移动网络通信的方式。当你拨打特定的号码时，设备将执行特定的功能。'
- en: In late 2012, it came to light that some Android devices would automatically
    open a number they discovered on a web page in the dialer application. When USSD
    codes are entered in the dialer, the functionality is automatically called. That
    sounds like a great function for attackers to abuse to control a device remotely.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 2012 年底，有报道称一些 Android 设备会自动在拨号器应用中打开它们在网页上发现的号码。当在拨号器中输入 USSD 代码时，相应功能会自动被调用。这听起来像是一个攻击者可以滥用的好功能，用来远程控制设备。
- en: As it turned out, attackers could put USSD codes in a web page as the number
    to dial and end up forcing these vulnerable devices to do all sorts of interesting
    things. For example, as shown here, the `tel:` tag in a malicious web page tells
    Android this is a phone number. But when the USSD code `2673855%23` is opened
    in the dialer, the device performs a factory restore, deleting all the user’s
    data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，攻击者可以将 USSD 代码放在网页中作为要拨打的号码，最终迫使这些易受攻击的设备执行各种有趣的操作。例如，如此处所示，恶意网页中的 `tel:`
    标签告诉 Android 这是一个电话号码。但当 USSD 代码 `2673855%23` 在拨号器中打开时，设备会执行恢复出厂设置，删除所有用户数据。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The vulnerability is not in the USSD code itself, but in certain devices’ implementation
    of the `tel:` tag. Various USSD tags offer all sorts of functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞并不在 USSD 代码本身，而是在某些设备实现 `tel:` 标签的方式上。各种 USSD 标签提供了各种功能。
- en: Our example will use a more innocuous payload than the one described previously.
    We’ll have our device automatically dial a code to present its unique identifier
    in a pop-up, as shown in [Example 20-10](ch20.xhtml#android_ussd_attack "Example 20-10. Android
    USSD attack").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将使用比之前描述的更无害的有效载荷。我们将使设备自动拨打一个代码，以在弹出窗口中显示其唯一标识符，如[示例 20-10](ch20.xhtml#android_ussd_attack
    "示例 20-10. Android USSD 攻击")所示。
- en: Example 20-10. Android USSD attack
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-10. Android USSD 攻击
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To run the safe USSD example in SPF, choose menu option **`6`**, then `3.) USSD
    Webpage Attack (Safe)` ❶. You’ll be asked for the location of the web server,
    the name of the malicious page, and the phone number to text it to. Send it to
    your Android 2.1 emulator.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SPF 中运行安全的 USSD 示例，选择菜单选项 **`6`**，然后选择 `3.) USSD 网页攻击（安全）` ❶。系统会要求你输入网页服务器的地址、恶意页面的名称和要发送的电话号码。将其发送到你的
    Android 2.1 模拟器。
- en: Now open the page in the SMS you receive on the Android 2.1 emulator. This time,
    instead of crashing the browser, the dialer app opens, and a pop-up notification
    appears, as shown in [Figure 20-2](ch20.xhtml#ussd_autodial "Figure 20-2. USSD
    autodial").
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你收到的 Android 2.1 模拟器中的短信页面打开。此次，不是浏览器崩溃，而是拨号应用打开，并且弹出了通知，如[图 20-2](ch20.xhtml#ussd_autodial
    "图 20-2. USSD 自动拨号")所示。
- en: '![USSD autodial](httpatomoreillycomsourcenostarchimages2030590.png.jpg)Figure 20-2. USSD
    autodial'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![USSD 自动拨号](httpatomoreillycomsourcenostarchimages2030590.png.jpg)图 20-2.
    USSD 自动拨号'
- en: As it turns out, our emulator has no unique identifier, so the number is blank.
    Though this example was not harmful to the device or its data, other USSD codes
    can be if they are opened in the dialer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们的模拟器没有唯一标识符，所以号码为空。虽然这个示例对设备或数据没有害，但如果其他 USSD 代码在拨号器中打开，可能会带来风险。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, this vulnerability, as well as the WebKit issue we exploited in the
    previous section, has been patched since its discovery. Android has a complicated
    relationship with security updates. The problem is that anyone can make an Android
    device with its own implementation of the Android OS. When Google releases a new
    version with a set of patches, every original equipment manufacturer (OEM) needs
    to port the changes to its version of Android, and the carriers need to push updates
    to their devices. However, updates are not delivered consistently, which means
    that millions of unpatched devices may be in use, depending on the model and the
    carrier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个漏洞以及我们在上一节中利用的 WebKit 问题，自从被发现以来已经修复。Android 在安全更新方面有着复杂的关系。问题在于任何人都可以制造
    Android 设备，并且实现自己的 Android 操作系统。当 Google 发布包含一系列补丁的新版本时，每个原始设备制造商（OEM）都需要将这些更改移植到其
    Android 版本中，运营商也需要将更新推送到他们的设备上。然而，更新并不是一致地交付的，这意味着根据型号和运营商的不同，可能有数百万台未修复的设备在使用。
- en: 'Now let’s turn our attention to a vulnerability that will probably never be
    patched: malicious applications.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向一个可能永远不会被修复的漏洞：恶意应用。
- en: Malicious Apps
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶意应用
- en: We’ve studied malicious programs intermittently throughout this book. We created
    malicious executables with Msfvenom in [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework"), uploaded backdoors to vulnerable web servers in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"), looked at social-engineering attacks to trick users
    into downloading and running malicious programs in [Chapter 11](ch11.xhtml "Chapter 11. Social
    Engineering"), and bypassed antivirus programs in [Chapter 12](ch12.xhtml "Chapter 12. Bypassing
    Antivirus Applications").
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们间歇性地研究了恶意程序。我们在[第 4 章](ch04.xhtml "第 4 章. 使用 Metasploit 框架")中使用 Msfvenom
    创建了恶意可执行文件，在[第 8 章](ch08.xhtml "第 8 章. 利用")中上传了后门到易受攻击的 Web 服务器，在[第 11 章](ch11.xhtml
    "第 11 章. 社会工程学")中查看了通过社会工程攻击诱使用户下载和运行恶意程序，在[第 12 章](ch12.xhtml "第 12 章. 绕过防病毒程序")中绕过了防病毒程序。
- en: While social engineering and users undermining security policies by running
    malicious programs will likely be major issues for enterprise security for years
    to come, mobile devices make this issue even more complicated. It’s hard to imagine
    anyone giving you a laptop computer for work and encouraging you to go out to
    the Internet and download every potentially interesting, fun, or productivity-increasing
    program you can find—but that’s exactly how mobile devices are marketed. (“Buy
    our device. It has the best apps.” “Download our apps. They’re the best in productivity/entertainment/security.”)
    Mobile antivirus applications often require extreme permissions and even administrative
    functions on the device in order to run, and mobile device management solutions
    typically require installing even more applications on the device.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管社会工程学和用户通过运行恶意程序破坏安全策略，可能会成为企业安全的长期问题，但移动设备使这个问题变得更加复杂。很难想象有人会给你一台工作用的笔记本电脑，并鼓励你去互联网上下载任何可能有趣、好玩或提高生产力的程序——但这正是移动设备的营销方式。（“购买我们的设备，它有最好的应用。”
    “下载我们的应用，它们在生产力/娱乐/安全方面是最好的。”）移动防病毒应用通常需要极高的权限，甚至需要设备上的管理功能才能运行，而移动设备管理解决方案通常需要在设备上安装更多的应用程序。
- en: Mobile users are inundated with reasons to download apps to their devices, and
    mobile malware is on the rise, much of it in the form of malicious applications.
    If a user can be tricked into installing a malicious app, the attacker can utilize
    Android’s APIs to steal data, gain remote control, and even attack other devices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 移动用户充斥着下载应用的理由，而移动恶意软件正在上升，其中许多以恶意应用程序的形式出现。如果用户被欺骗安装了恶意应用，攻击者就可以利用 Android
    的 API 窃取数据、远程控制，甚至攻击其他设备。
- en: In the Android security model, apps must request permissions to use APIs that
    could be used maliciously, and users must accept the requested permissions at
    installation. Unfortunately, users often grant access to all sorts of potentially
    dangerous permissions. We can use Android permissions to control the device without
    running an additional exploit after the user installs the malicious app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 安全模型中，应用程序必须请求使用可能被恶意使用的 API 权限，用户必须在安装时接受请求的权限。不幸的是，用户常常会授予各种潜在危险的权限。我们可以利用
    Android 权限，在用户安装恶意应用后，控制设备，而无需运行额外的漏洞利用程序。
- en: Creating Malicious SPF Agents
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建恶意 SPF 代理
- en: SPF allows us to create a malicious app with a variety of interesting functionality.
    Earlier we used the SPF app on our pentester-controlled device to allow SPF to
    use the device’s mobile modem and other functionality; our goal here is to trick
    users into installing the SPF agent on target devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SPF 允许我们创建具有各种有趣功能的恶意应用程序。之前我们在渗透测试者控制的设备上使用了 SPF 应用，允许 SPF 使用设备的移动调制解调器及其他功能；我们的目标是欺骗用户将
    SPF 代理安装到目标设备上。
- en: 'As of this writing, SPF agents can receive commands by checking in to a web
    server over HTTP or via hidden SMS messages from an SPF-controlled mobile modem.
    Naturally, we’ll be more successful if our agent appears to be an interesting
    and/or trustworthy app. We can embed the agent inside any legitimate app: SPF
    can take a compiled APK file and backdoor it with the agent, or if we have the
    source code of the app, we can backdoor that as well.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，SPF 代理可以通过 HTTP 检查服务器或通过 SPF 控制的移动调制解调器接收隐藏的 SMS 消息来接收命令。自然地，如果我们的代理看起来像一个有趣和/或值得信赖的应用，我们会更成功。我们可以将代理嵌入到任何合法的应用程序中：SPF
    可以将已编译的 APK 文件嵌入代理后门，或者如果我们有应用程序的源代码，我们也可以在其中加入后门。
- en: Backdooring Source Code
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 后门源代码
- en: Let’s use backdooring source code for our example. Choose `1.) Attach Framework
    to a Deployed Agent/Create Agent` at the main SPF menu. SPF includes a couple
    of app templates that we can use for our example. You can also import any app
    source code into SPF with option `4`. If you don’t have source code for the app
    you want to impersonate, you can use option `5` to backdoor a compiled APK. You
    can even use the Android Master Key vulnerability discovered in 2013 to replace
    applications already installed on the device with a backdoored version. For now,
    let’s just use one of SPF’s templates, as shown in [Example 20-11](ch20.xhtml#building_the_android_agent
    "Example 20-11. Building the Android agent").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以后门源代码为例。选择主 SPF 菜单中的 `1.) 附加框架到已部署的代理/创建代理`。SPF 包括一些我们可以用于示例的应用模板。你还可以使用选项
    `4` 将任何应用的源代码导入到 SPF 中。如果你没有要伪装的应用程序的源代码，你可以使用选项 `5` 给已编译的 APK 添加后门。你甚至可以利用 2013
    年发现的 Android 主密钥漏洞，将已安装在设备上的应用程序替换为带有后门的版本。现在，让我们只使用 SPF 的模板之一，如[示例 20-11](ch20.xhtml#building_the_android_agent
    "示例 20-11. 构建 Android 代理")所示。
- en: Example 20-11. Building the Android agent
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-11. 构建 Android 代理
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Choose `2.) Generate Agent App` ❶. We’ll use the MapsDemo example template ❷
    distributed with Android SDK by Google to demonstrate functionality. When prompted,
    give the phone number to send SMS commands to ❸, the SPF the seven-character key
    ❹, and the directory to check in for HTTP commands ❺. For the agent key and path,
    use the same values that you used when you created the SPF app ([Building the
    Android App](ch20.xhtml#building_the_android_app "Building the Android App")).
    Use the Android 4.3 emulator (SPF app) phone number as the control phone number.
    SPF will build the Android agent in the chosen template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `2.) 生成代理应用` ❶。我们将使用 Google 随 Android SDK 提供的 MapsDemo 示例模板 ❷ 来演示功能。当系统提示时，输入接收
    SMS 命令的电话号码 ❸，SPF 的七位字符密钥 ❹，以及用于 HTTP 命令的检查目录 ❺。对于代理密钥和路径，使用你在创建 SPF 应用时所用的相同值（[构建
    Android 应用](ch20.xhtml#building_the_android_app "构建 Android 应用")）。使用 Android 4.3
    模拟器（SPF 应用）上的电话号码作为控制电话号码。SPF 会在选择的模板中构建 Android 代理。
- en: Now to entice the user into downloading and installing the agent, a process
    similar to our client-side attacks, following the steps in [Example 20-12](ch20.xhtml#enticing_the_user_into_installing_the_ag
    "Example 20-12. Enticing the user into installing the agent").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在引诱用户下载和安装代理，这个过程类似于我们的客户端攻击，按照 [示例 20-12](ch20.xhtml#enticing_the_user_into_installing_the_ag
    "示例 20-12. 引诱用户安装代理") 中的步骤进行。
- en: Example 20-12. Enticing the user into installing the agent
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-12. 引诱用户安装代理
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Choose option **`6`** at the main menu, and then choose `1.) Direct Download
    Agent` ❶. You will be asked if you want to send the Android agent or Android Meterpreter
    (a recent addition to Metasploit). Because we’re working with the Android agent,
    choose **`Agent`** ❷. As usual, you are prompted for the path, app name on the
    web server, attack vector, and the number to attack, beginning at ❸. Instruct
    SPF to send an SMS with default text to the Android 2.2 emulator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在主菜单中选择选项 **`6`**，然后选择 `1.) 直接下载代理` ❶。系统会询问你是否要发送 Android 代理或 Android Meterpreter（Metasploit
    的最新添加）。因为我们正在使用 Android 代理，选择 **`代理`** ❷。像往常一样，你将被提示路径、Web 服务器上的应用名称、攻击向量以及从 ❸
    开始攻击的号码。指示 SPF 发送带有默认文本的短信到 Android 2.2 模拟器。
- en: On the Android 2.2 emulator, click the link in the SMS when it arrives. The
    app should be downloaded. After it downloads, click **Install**, accept the permissions,
    and open the app. As shown in [Figure 20-3](ch20.xhtml#backdoored_app "Figure 20-3. Backdoored
    app"), the agent will look and feel like the original app template (the Google
    Maps demo), but it has some extra functionality in the background.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 2.2 模拟器上，当短信到达时点击链接。应用程序将被下载。下载完成后，点击 **安装**，接受权限并打开应用。如 [图 20-3](ch20.xhtml#backdoored_app
    "图 20-3. 后门应用") 所示，代理将看起来和感觉像原始应用模板（Google 地图演示），但在后台具有额外功能。
- en: '![Backdoored app](httpatomoreillycomsourcenostarchimages2030592.png.jpg)Figure 20-3. Backdoored
    app'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![后门应用](httpatomoreillycomsourcenostarchimages2030592.png.jpg)图 20-3. 后门应用'
- en: Now to attach SPF to the deployed agent. If you send an SMS campaign to lots
    of numbers, who knows how many users will install the agent or how quickly, but
    the agent has check-in functionality (see [Example 20-13](ch20.xhtml#attaching_spf_to_the_deployed_agent
    "Example 20-13. Attaching SPF to the deployed agent")) that will respond to SPF’s
    query to see if it is deployed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 SPF 附加到已部署的代理。如果向大量号码发送短信广告，谁知道多少用户会安装代理或多快，但代理具有签到功能（参见 [示例 20-13](ch20.xhtml#attaching_spf_to_the_deployed_agent
    "示例 20-13. 将 SPF 附加到部署的代理")），将会响应 SPF 的查询以查看其是否已部署。
- en: Example 20-13. Attaching SPF to the deployed agent
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-13. 将 SPF 附加到部署的代理
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Choose option **`1`** at the main menu and then choose `1.) Attach Framework`
    `to a` `Deployed Agent` ❶. You are prompted for the path ❷, key ❸, and communication
    method ❹. Enter the values you used when creating the agent.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在主菜单中选择选项 **`1`**，然后选择 `1.) 将框架附加到已部署的代理` ❶。系统会询问路径 ❷、密钥 ❸ 和通信方法 ❹。输入创建代理时使用的值。
- en: SPF will appear to hang for a minute as it waits for the agent to respond. After
    it returns to the menu, you should be connected to the agent. Now choose `2.)
    Send Commands to an Agent` from the main menu. You will be presented with a list
    of agents in the database; you should see the agent you just attached to SPF in
    the list as shown here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SPF 将会等待代理响应一分钟，看起来好像挂起了。返回菜单后，你应该已连接到代理。现在从主菜单选择 `2.) 发送命令给代理`。你将看到数据库中代理的列表；你应该能在列表中看到刚刚附加到
    SPF 的代理，如图所示。
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Backdooring APKs
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 给 APK 加后门
- en: Before we move on to using our deployed SPF agent, let’s look at another, perhaps
    more sophisticated, way of creating an agent. Because you may not always have
    the source code of the app you want to backdoor, SPF can work with the precompiled
    APK file. Any APK, including those in the Google Play store, are in scope.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用部署的 SPF 代理之前，让我们看看另一种更复杂的创建代理的方法。因为你可能并不总是拥有你想要给其加后门的应用程序的源代码，SPF 可以与预编译的
    APK 文件一起工作。包括 Google Play 商店中的任何 APK 都在其范围之内。
- en: To backdoor an APK with the SPF agent, choose **`1`** from the main menu, and
    then `5.) Backdoor Android APK with Agent`, as shown in [Example 20-14](ch20.xhtml#backdooring_an_apk
    "Example 20-14. Backdooring an APK").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要给 APK 加上 SPF 代理后门，在主菜单中选择选项 **`1`**，然后选择 `5.) 使用代理给 Android APK 加上后门`，如 [示例 20-14](ch20.xhtml#backdooring_an_apk
    "示例 20-14. 给 APK 加后门") 所示。
- en: Example 20-14. Backdooring an APK
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-14. 给 APK 加后门
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: SPF does not install the APKTool program, required to decompile APKs, by default;
    it asks if you want to install it. Enter **`y`**, and SPF will install APKTool
    and continue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SPF 不会安装 APKTool 程序，而该程序是解编译 APK 所必需的；它会询问是否安装。输入 **`y`**，SPF 将安装 APKTool
    并继续。
- en: When prompted, tell SPF to backdoor the APK */root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk*
    (a compiled version of the Google Maps demo code used previously). SPF will then
    decompile the APK, combine it with the SPF agent, and recompile it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，告诉 SPF 对 APK */root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk*（先前使用的
    Google Maps 演示代码的编译版本）植入后门。SPF 将解编译该 APK，结合 SPF 代理，并重新编译。
- en: To set up the agent, SPF needs to know the control phone number, control key,
    and control path. This is the same information we used when backdooring source
    code and is shown in [Example 20-15](ch20.xhtml#setting_options-id00053 "Example 20-15. Setting
    options").
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置代理，SPF 需要知道控制电话号码、控制密钥和控制路径。这些信息与我们在给源代码植入后门时使用的相同，详见[示例 20-15](ch20.xhtml#setting_options-id00053
    "示例 20-15. 设置选项")。
- en: Example 20-15. Setting options
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-15. 设置选项
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After APKTool recompiles the backdoored APK, we need to sign it. At installation,
    the Android device checks the signatures on an APK. If it is not signed, it will
    be rejected, even by an emulator. Google Play apps are signed using a developer
    key registered with Google Play.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 APKTool 重新编译了带后门的 APK 后，我们需要对其进行签名。在安装时，Android 设备会检查 APK 上的签名。如果 APK 没有签名，它将被拒绝，即使是在模拟器上也是如此。Google
    Play 应用使用开发者密钥进行签名，该密钥在 Google Play 上注册。
- en: To run apps on emulators and devices that are not restricted to Google Play
    apps, we just use a debug key that is not registered with Google, but the app
    still must be signed. We were able to skip this step when backdooring source code
    because we compiled the code with the Android SDK, which automatically signed
    our code with the default Android keystore. Because we used APKTool here, we need
    to manually re-create the signature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不限制 Google Play 应用的模拟器和设备上运行应用，我们只需使用未在 Google 注册的调试密钥，但应用仍然必须签名。当我们给源代码植入后门时，由于我们使用
    Android SDK 编译代码，自动将我们的代码使用默认的 Android 密钥库签名，因此可以跳过这一步。而在此处使用 APKTool 时，我们需要手动重新创建签名。
- en: You will be asked whether you want to use the Android Master Key vulnerability,
    which allows attackers and pentesters to trick the Android signature-verification
    process into thinking our app is a legitimate update to an already installed application.
    In other words, we will be allowed to replace legitimate applications with our
    code, and the Android system will view them as legitimate updates from the vendor.
    (This flaw in the verification process was fixed in Android 4.2.) To use the Android
    Master Key vulnerability, enter **`y`** at the prompt, as shown next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被询问是否使用 Android Master Key 漏洞，该漏洞允许攻击者和渗透测试者欺骗 Android 的签名验证过程，使其认为我们的应用是已经安装的应用的合法更新。换句话说，我们将能够用我们的代码替换合法的应用，Android
    系统会将其视为厂商的合法更新。（此验证过程中的缺陷在 Android 4.2 中得到了修复。）要使用 Android Master Key 漏洞，请在提示时输入
    **`y`**，如下面所示。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To leverage this issue, the original application and its signatures are copied
    into our backdoored APK. Details about how this triggers the Master Key vulnerability
    can be found here: http://www.saurik.com/id/17.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用此问题，原始应用及其签名会被复制到我们的带后门的 APK 中。有关如何触发 Master Key 漏洞的详细信息，请参见：http://www.saurik.com/id/17。
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To see the Android Master Key vulnerability at work, install the legitimate
    version of *MapsDemo.apk* from */root/Smartphone-Pentest-Framework/APKs* onto
    a device running an Android version earlier than 4.2, and then try to install
    the backdoored version you just created by delivering it via SMS or NFC with SPF.
    You should be prompted to replace *MapsDemo.apk*, and the signature verification
    should succeed, even though we didn’t have access to the private keys required
    to build a correct signature for our backdoored version.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Android Master Key 漏洞的工作情况，请在运行 Android 4.2 之前版本的设备上安装来自 */root/Smartphone-Pentest-Framework/APKs*
    的合法版本的 *MapsDemo.apk*，然后尝试通过 SMS 或 NFC 使用 SPF 安装您刚刚创建的带后门的版本。您应该会被提示替换 *MapsDemo.apk*，并且即使我们没有访问构建正确签名所需的私钥，签名验证也应成功。
- en: If your target is not vulnerable to Master Key or the app is not already on
    the target device, you can just sign the app with your default key for the Android
    keystore on Kali. To do this, enter **`n`** at the prompt for Use Android Master
    Key Vuln, as shown in [Example 20-16](ch20.xhtml#signing_the_apk "Example 20-16. Signing
    the APK").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标设备没有受到 Master Key 的影响，或者应用还未安装在目标设备上，你可以直接使用 Kali 上的 Android 密钥库默认密钥来签名该应用。为此，在提示“是否使用
    Android Master Key 漏洞”时，输入**`n`**，如[示例 20-16](ch20.xhtml#signing_the_apk "Example
    20-16. Signing the APK")所示。
- en: Example 20-16. Signing the APK
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-16. 签名 APK
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You are prompted for the password for the debug keystore. By default, this action
    does not sign the APK with a key for publishing it on Google Play, but it will
    work for our purposes. The app is now signed with a debug key and should install
    on any device that does not restrict apps to official Play Store apps. Note that
    there’s nothing stopping a pentester from signing the app with a legitimate Google
    Play key they have registered if it’s in the scope of the pentest to attempt to
    trick users into downloading malicious apps from the Google Play store.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示你输入调试密钥库的密码。默认情况下，此操作不会使用发布在 Google Play 上的密钥来签名 APK，但对于我们的目的来说已经足够。该应用现在已用调试密钥签名，应该可以在任何不限制只能安装官方
    Play Store 应用的设备上安装。请注意，如果渗透测试的范围包括诱使用户从 Google Play 商店下载恶意应用，渗透测试人员完全可以用他们注册的合法
    Google Play 密钥来签名该应用。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The backdoored APK is functionality equivalent to the agent we created in [Backdooring
    Source Code](ch20.xhtml#backdooring_source_code "Backdooring Source Code") and
    can be deployed the same way. Of course, we already have a deployed agent to work
    with as we look at what we can do to a device and its local network after an agent
    is deployed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 带有后门的 APK 与我们在[后门源代码](ch20.xhtml#backdooring_source_code "Backdooring Source
    Code")中创建的代理功能等效，可以通过相同的方式进行部署。当然，部署后我们已经有一个可用的代理可以进行操作，接下来我们将查看在代理部署后，我们可以对设备及其本地网络执行哪些操作。
- en: Mobile Post Exploitation
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动后渗透
- en: Now that we’re on the device, we have a few options open to us. We can gather
    local information from the device such as contacts or received SMS messages, and
    we can remotely control the device to have it do things like take a picture. If
    we’re unsatisfied with our permissions, we can attempt to perform privilege escalation
    on the device and get root privileges. We can even use the exploited mobile device
    to attack other devices on the network. (This attack can be particularly interesting
    if the device connects directly to a corporate network or uses a VPN to access
    one.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入设备，有几个选项可以选择。我们可以从设备上收集本地信息，如联系人或收到的 SMS 消息，还可以远程控制设备执行一些操作，如拍照。如果我们对权限不满意，可以尝试对设备进行权限提升，获得
    root 权限。我们甚至可以利用被攻陷的移动设备攻击网络上的其他设备。（如果设备直接连接到公司网络或使用 VPN 访问网络，这种攻击尤其有趣。）
- en: Information Gathering
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息收集
- en: We will run an example of information gathering by getting a list of installed
    applications on the infected device as shown in [Example 20-17](ch20.xhtml#running_a_command_on_an_agent
    "Example 20-17. Running a command on an agent").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过获取感染设备上已安装应用程序的列表来进行信息收集示例，如[示例 20-17](ch20.xhtml#running_a_command_on_an_agent
    "Example 20-17. Running a command on an agent")所示。
- en: Example 20-17. Running a command on an agent
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-17. 在代理上运行命令
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choose option **`2`** from the main menu, then select the agent from the list
    ❶. When presented with a list of available agent functionality ❷, choose `14.)
    Get Installed Apps List` ❸. SPF asks how you would like to deliver the command;
    we’ll use HTTP ❹. (Recall that agents can communicate and receive commands via
    HTTP and SMS.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从主菜单中选择**`2`**选项，然后从列表 ❶ 中选择代理。当出现可用代理功能的列表 ❷ 时，选择 `14.) 获取已安装应用列表` ❸。SPF 会询问你如何传递命令，我们将使用
    HTTP ❹。（回想一下，代理可以通过 HTTP 和 SMS 与外界通信并接收命令。）
- en: Enter **`0`** to return to the previous menu until you reach the main menu.
    Wait a minute, and then choose `3.) View Information Gathered`, as shown in [Example 20-18](ch20.xhtml#viewing_gathered_data
    "Example 20-18. Viewing gathered data").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**`0`**以返回到上一个菜单，直到到达主菜单。稍等片刻，然后选择 `3.) 查看收集到的信息`，如[示例 20-18](ch20.xhtml#viewing_gathered_data
    "Example 20-18. Viewing gathered data")所示。
- en: Example 20-18. Viewing gathered data
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-18. 查看收集到的数据
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You are asked if you want to see the results of Attacks or Agents; type **`Agents`**
    ❶. Choose our agent ❷. Information about the device is pulled from the database,
    though currently all we have is a list of installed apps, gathered by the previous
    command ❸. (You can run additional information-gathering commands to fill in more
    entries.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会询问你是否想查看攻击或代理的结果；输入**`Agents`** ❶。选择我们的代理 ❷。设备信息会从数据库中提取，尽管目前我们只有由之前命令收集的已安装应用列表
    ❸。（你可以运行额外的信息收集命令来填充更多条目。）
- en: Remote Control
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程控制
- en: Now let’s see how to use the agent to remotely control the device. We can tell
    the device to send a text message that will not show up in the sent messages of
    the SMS app. In fact, the user will have no indication that a message was sent
    at all—what better way to exploit the circle of trust? Perhaps we can grab all
    the user’s contacts and send them messages telling them they should install our
    cool app, which just so happens to point to the SPF agent. Because the message
    comes from someone they know, the users will be more likely to install the agent.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用代理来远程控制设备。我们可以告诉设备发送一条不会出现在短信应用的已发送消息中的短信。事实上，用户根本不会知道有消息被发送——这不就是利用信任圈的最佳方式吗？也许我们可以抓取所有用户的联系人，并向他们发送消息，告诉他们应该安装我们的酷炫应用，而这个应用恰好指向
    SPF 代理。由于消息来自他们认识的人，用户更可能会安装该代理。
- en: Let’s just send an example message for now, as shown in [Example 20-19](ch20.xhtml#remotely_controlling_an_agent
    "Example 20-19. Remotely controlling an agent").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先发送一条示例消息，如[示例 20-19](ch20.xhtml#remotely_controlling_an_agent "示例 20-19.
    远程控制代理")所示。
- en: Example 20-19. Remotely controlling an agent
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-19. 远程控制代理
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From the agent commands menu, select option `1.) Send SMS` ❶. When prompted
    for a phone number, message contents, and how you want to deliver the command,
    tell your agent to send the message to the Android 2.1 emulator.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理命令菜单中，选择选项 `1.) 发送短信` ❶。当系统要求输入电话号码、消息内容和发送命令的方式时，告诉你的代理将短信发送到 Android 2.1
    模拟器。
- en: Your Android 2.1 emulator will receive an SMS with the text you entered from
    the Android 2.2 emulator, with no indication on either emulator that this is not
    a normal message.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Android 2.1 模拟器将收到来自 Android 2.2 模拟器的短信，内容是你输入的文本，在两个模拟器上都没有任何迹象表明这不是一条正常的消息。
- en: Pivoting Through Mobile Devices
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过移动设备进行跳板攻击
- en: 'Mobile Device Management (MDM) and mobile antivirus applications have a long
    way to go. The number of companies that mandate these solutions for their employees
    is still small when compared with many other security controls, and some companies
    choose not to allow mobile devices at all. But let’s face it: Employees probably
    know the company’s wireless password. Connect your mobile device, and magically
    it’s a member of the same network as your workstation and other devices that might
    contain sensitive information.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备管理（MDM）和移动 antivirus 应用程序还有很长的路要走。与许多其他安全控制措施相比，要求员工使用这些解决方案的公司数量仍然很少，有些公司甚至选择完全不允许使用移动设备。但我们不得不面对一个现实：员工们可能知道公司的无线网络密码。连接你的移动设备后，它神奇地变成了与工作站及其他可能包含敏感信息的设备同一个网络中的一员。
- en: Naturally, companies are much better at hardening their externally facing assets.
    After all, these devices are open to attack from anyone on the Internet, and they
    get the lion’s share of the attention. But internally, things start to break down.
    Weak passwords, missing patches, and out-of-date client-side software are all
    issues we’ve examined in this book that could be lurking in the internal network.
    If an exploited mobile device has direct network access to these vulnerable systems,
    we may be able to use it as a pivot to launch additional attacks, completely bypassing
    the perimeter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，企业在强化外部资产方面做得要好得多。毕竟，这些设备对来自互联网的任何攻击者开放，它们也得到了大部分的关注。但在内部，情况就开始出现问题了。弱密码、缺失补丁和过时的客户端软件，都是我们在本书中讨论过的可能潜伏在内部网络中的问题。如果一个被利用的移动设备能够直接访问这些脆弱的系统，我们可能能够利用它作为跳板发起更多攻击，完全绕过外围防线。
- en: We studied pivoting in [Chapter 13](ch13.xhtml "Chapter 13. Post Exploitation"),
    when we used an exploited machine to move from one network to another. We can
    do the same thing here using the SPF agent, effectively running a pentest on the
    mobile network through the exploited mobile device, as illustrated in [Figure 20-4](ch20.xhtml#pivoting_through_an_infected_mobile_devi
    "Figure 20-4. Pivoting through an infected mobile device to attack internal devices").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 13 章](ch13.xhtml "第 13 章. 后期利用")中研究了枢纽操作，当时我们使用一个被利用的机器从一个网络移动到另一个网络。在这里，我们可以使用
    SPF 代理做同样的事情，通过被利用的移动设备在移动网络上有效地进行渗透测试，如[图 20-4](ch20.xhtml#pivoting_through_an_infected_mobile_devi
    "图 20-4. 通过感染的移动设备攻击内部设备")所示。
- en: '![Pivoting through an infected mobile device to attack internal devices](httpatomoreillycomsourcenostarchimages2030594.png.jpg)Figure 20-4. Pivoting
    through an infected mobile device to attack internal devices'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过感染的移动设备攻击内部设备](httpatomoreillycomsourcenostarchimages2030594.png.jpg)图 20-4.
    通过感染的移动设备攻击内部设备'
- en: Portscanning with Nmap
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行端口扫描
- en: We start by seeing what devices are out there using an agent command option
    to ping sweep the local network. Next, we’ll do some port scanning, as discussed
    in [Chapter 5](ch05.xhtml "Chapter 5. Information Gathering"). As it turns out
    you can install Nmap Android binaries on the exploited device. SPF has install
    scripts for this and other supporting tools. Choose option `10.) Install Stuff`
    from the main menu, and tell SPF to install Nmap for Android, as shown in [Example 20-20](ch20.xhtml#installing_nmap_for_android
    "Example 20-20. Installing Nmap for Android").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用代理命令选项来执行本地网络的 ping 扫描，看看有哪些设备在网络中。接下来，我们将进行一些端口扫描，如在[第 5 章](ch05.xhtml
    "第 5 章. 信息收集")中所讨论的那样。事实证明，你可以在被利用的设备上安装 Nmap 的 Android 二进制文件。SPF 提供了安装脚本来安装 Nmap
    和其他支持工具。从主菜单选择选项 `10.) Install Stuff`，并告诉 SPF 安装 Nmap for Android，如[示例 20-20](ch20.xhtml#installing_nmap_for_android
    "示例 20-20. 安装 Nmap for Android")所示。
- en: Example 20-20. Installing Nmap for Android
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-20. 安装 Nmap for Android
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now to run Nmap from our Android agent using option `12.) Run Nmap`. Let’s run
    Nmap against our Windows XP target ❶, as shown in [Example 20-21](ch20.xhtml#running_nmap_from_android
    "Example 20-21. Running Nmap from Android"). Make sure that the War-FTP program
    we exploited in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow
    in Windows") and [Chapter 18](ch18.xhtml "Chapter 18. Structured Exception Handler
    Overwrites") is still running. (We’ll exploit it through the pivot in the next
    section.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过选择选项 `12.) Run Nmap` 从我们的 Android 代理运行 Nmap。让我们对 Windows XP 目标 ❶ 运行 Nmap，如[示例 20-21](ch20.xhtml#running_nmap_from_android
    "示例 20-21. 从 Android 运行 Nmap")所示。确保我们在[第 17 章](ch17.xhtml "第 17 章. Windows 中的基于栈的缓冲区溢出")和[第
    18 章](ch18.xhtml "第 18 章. 结构化异常处理程序覆盖")中利用的 War-FTP 程序仍在运行。（我们将在下一节通过枢纽再次利用它。）
- en: Example 20-21. Running Nmap from Android
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-21. 从 Android 运行 Nmap
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let Nmap run for a couple of minutes, and then check your agent’s gathered information.
    You should notice that the File field links to */root/Smartphone-Pentest-Framework/frameworkconsole/text.txt*.
    View the contents of this file—you should see something similar to [Example 20-22](ch20.xhtml#nmap_results
    "Example 20-22. Nmap results").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让 Nmap 运行几分钟，然后检查代理收集的信息。你应该注意到文件字段链接到 */root/Smartphone-Pentest-Framework/frameworkconsole/text.txt*。查看该文件的内容——你应该能看到类似[示例 20-22](ch20.xhtml#nmap_results
    "示例 20-22. Nmap 结果")的内容。
- en: Example 20-22. Nmap results
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-22. Nmap 结果
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rather than run an entire pentest using the exploited mobile device as a pivot,
    let’s finish by running an exploit through the SPF agent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用被利用的移动设备作为枢纽进行整个渗透测试，不如通过SPF代理来执行一个利用程序。
- en: Exploiting a System on the Local Network
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在本地网络上利用系统
- en: Unfortunately, Android devices don’t know scripting languages such as Python
    and Perl by default; to run an exploit, we need some C code. A simple C version
    of the exploit we wrote for War-FTP 1.65 in [Chapter 17](ch17.xhtml "Chapter 17. A
    Stack-Based Buffer Overflow in Windows") is in */root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c*.
    The included shellcode runs a *windows/meterpreter/reverse_tcp* payload and sends
    it back to 192.168.20.9 on port 4444\. If your Kali system is at another IP address,
    regenerate the shellcode with Msfvenom, as shown here. (Don’t forget the bad characters
    for War-FTP from [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow
    in Windows"). We can avoid them with Msfvenom using the `-b` flag.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Android设备默认无法识别像Python和Perl这样的脚本语言；为了运行漏洞利用，我们需要一些C代码。我们为War-FTP 1.65编写的一个简单C版本的漏洞利用代码可以在[第17章](ch17.xhtml
    "第17章. Windows中的基于堆栈的缓冲区溢出")中找到，路径是*/root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c*。其中包含的shellcode运行一个*windows/meterpreter/reverse_tcp*载荷，并将其发送回192.168.20.9的4444端口。如果你的Kali系统使用的是其他IP地址，可以通过Msfvenom重新生成shellcode，具体方法如下所示。（别忘了[第17章](ch17.xhtml
    "第17章. Windows中的基于堆栈的缓冲区溢出")中的War-FTP的坏字符，我们可以使用Msfvenom的`-b`标志来避免这些字符。）
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once you’ve replaced the shellcode in the exploit, if necessary, we need to
    compile the C code to run on an Android device. If we use GCC, as in [Chapter 3](ch03.xhtml
    "Chapter 3. Programming"), the exploit will run fine from our Kali box, but the
    ARM processor on our Android phones won’t know what to make of it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在漏洞利用中替换了shellcode（如果需要的话），我们需要编译C代码以在Android设备上运行。如果我们使用GCC，如[第3章](ch03.xhtml
    "第3章. 编程")中所示，漏洞利用将在我们的Kali机器上正常运行，但Android手机上的ARM处理器将无法识别它。
- en: We briefly ran into cross compilers for Windows in [Chapter 12](ch12.xhtml "Chapter 12. Bypassing
    Antivirus Applications") that allowed us to compile C code on Kali to run on Windows.
    We can do the same thing for Android as long as we have an ARM cross compiler.
    Luckily, SPF has one. As shown in [Example 20-23](ch20.xhtml#compiling_c_code_to_run_on_android
    "Example 20-23. Compiling C code to run on Android"), choose option `9.) Compile
    code to run on mobile devices` from the main menu.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第12章](ch12.xhtml "第12章. 绕过杀毒软件")中简要介绍了Windows的交叉编译器，它允许我们在Kali上编译C代码并在Windows上运行。只要我们拥有ARM交叉编译器，也可以对Android做同样的事情。幸运的是，SPF中就有一个。如[示例
    20-23](ch20.xhtml#compiling_c_code_to_run_on_android "示例 20-23. 为Android编译C代码")所示，从主菜单中选择`9.)
    编译代码以在移动设备上运行`选项。
- en: Example 20-23. Compiling C code to run on Android
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-23. 为Android编译C代码
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Select `1.) Compile C code for ARM Android` ❶. You will be prompted for the
    C file to compile as well as where you want to put the compiled binary ❷.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`1.) 为ARM Android编译C代码` ❶。系统会提示你选择要编译的C文件以及要保存编译后的二进制文件的位置 ❷。
- en: Now we need to download the War-FTP exploit to our infected Android device.
    From the agent commands menu, choose option **`6`** to download a file. You will
    be asked for the file to download and the delivery method, as shown in [Example 20-24](ch20.xhtml#downloading_the_exploit
    "Example 20-24. Downloading the exploit").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将War-FTP漏洞利用下载到我们的感染了的Android设备上。从代理命令菜单中，选择**`6`**选项下载文件。系统会询问你要下载的文件以及下载方法，如[示例
    20-24](ch20.xhtml#downloading_the_exploit "示例 20-24. 下载漏洞利用")所示。
- en: Example 20-24. Downloading the exploit
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-24. 下载漏洞利用
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before we run the exploit, we need to set up a handler in Msfconsole, as shown
    in [Example 20-25](ch20.xhtml#setting_up_multisolidushandler "Example 20-25. Setting
    up multi/handler"). Open Msfconsole on Kali, and use the *multi/handler* module,
    setting the options to match the payload in the War-FTP exploit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行漏洞利用之前，我们需要在Msfconsole中设置一个处理程序，如[示例 20-25](ch20.xhtml#setting_up_multisolidushandler
    "示例 20-25. 设置multi/handler")所示。在Kali中打开Msfconsole，使用*multi/handler*模块，并将选项设置为与War-FTP漏洞利用中的载荷相匹配。
- en: Example 20-25. Setting up multi/handler
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-25. 设置multi/handler
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, it’s time to run the exploit. As shown in [Example 20-26](ch20.xhtml#running_the_exploit-id00055
    "Example 20-26. Running the exploit"), choose option `7.) Execute Command` from
    the agent commands menu; you will be prompted for the command to run.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到了运行漏洞利用的时候。如[示例 20-26](ch20.xhtml#running_the_exploit-id00055 "示例 20-26.
    运行漏洞利用")所示，选择代理命令菜单中的`7.) 执行命令`选项；系统会提示你输入要运行的命令。
- en: Example 20-26. Running the exploit
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-26. 运行漏洞利用
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tell SPF the full command, including arguments ❶. In this case, we need to tell
    the exploit the IP address and port to attack. SPF asks if the binary was downloaded.
    If it was downloaded through SPF, it will be in the agent’s files directory, and
    SPF will need to know to run it from there. In our case, we answer **`yes`** ❷,
    then enter the delivery method as usual.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉SPF完整的命令，包括参数❶。在这种情况下，我们需要告诉漏洞攻击的IP地址和端口。SPF会询问二进制文件是否已下载。如果是通过SPF下载的，它会在代理的文件目录中，SPF需要知道从那里运行它。在我们的案例中，我们回答**`yes`**
    ❷，然后像往常一样输入传输方法。
- en: Watch your Metasploit listener. In about a minute you should receive a Meterpreter
    prompt like the one shown next.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 观察你的Metasploit监听器。在大约一分钟后，你应该会看到一个Meterpreter提示符，如下所示。
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve successfully used SPF as a pivot to run an attack. This may not seem very
    exciting because the emulator, Kali, and the Windows XP target are all on the
    same network, but if Kali is in the cloud and the Windows XP target and an infected
    Android device are on the corporate network, this process would be more useful.
    We can make it more interesting by using command option `10.) TCP Listener` to
    set up a listener to catch our shell on the infected mobile device. Rather than
    calling back out to a listener on our Kali machine, we can instead send our shell
    back to SPF directly using either HTTP or SMS. Using SMS will, of course, allow
    us to completely bypass any perimeter filtering such as firewalls and proxies
    that may inhibit getting shells out of the network from your attacks. This is
    illustrated in [Figure 20-5](ch20.xhtml#bypassing_perimeter_controls_with_an_sms
    "Figure 20-5. Bypassing perimeter controls with an SMS-based shell.").
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地使用了SPF作为攻击的枢纽。虽然这看起来不太令人兴奋，因为模拟器、Kali和Windows XP目标都在同一网络中，但如果Kali在云端，而Windows
    XP目标和一个感染的Android设备在公司网络中，这个过程将会更有用。我们可以通过使用命令选项`10.) TCP Listener`来设置监听器，在感染的移动设备上捕获我们的Shell。我们可以不再调用Kali机器上的监听器，而是直接通过HTTP或SMS将Shell发送回SPF。使用SMS当然可以让我们完全绕过任何可能阻止攻击者从网络中获取Shell的外围过滤，比如防火墙和代理。此过程如[图20-5](ch20.xhtml#bypassing_perimeter_controls_with_an_sms
    "图20-5. 使用基于SMS的Shell绕过外围控制")所示。
- en: '![Bypassing perimeter controls with an SMS-based shell.](httpatomoreillycomsourcenostarchimages2030596.png.jpg)Figure 20-5. Bypassing
    perimeter controls with an SMS-based shell.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用基于SMS的Shell绕过外围控制。](httpatomoreillycomsourcenostarchimages2030596.png.jpg)图20-5.
    使用基于SMS的Shell绕过外围控制。'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Aside from the privilege escalation example discussed next, there is no reason
    we needed to use Android 2.2 as our target emulator. The other malicious app examples
    we have used in this chapter will work on any version of Android.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接下来讨论的权限提升示例外，我们没有理由必须使用Android 2.2作为目标模拟器。本章中我们使用的其他恶意应用示例可以在任何版本的Android上运行。
- en: Privilege Escalation
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权限提升
- en: As a forked Linux kernel, Android shares some of Linux’s privilege escalation
    vulnerabilities, as well as having a few security mistakes of its own. Even OEMs
    have added bugs into their implementations of Android. For example, in 2012, a
    privilege-escalation vulnerability was found in how Samsung devices handled the
    camera memory if they used a certain kind of chip, giving attackers read/write
    access to all of memory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个分支的Linux内核，Android共享了一些Linux的权限提升漏洞，并且自身也有一些安全漏洞。甚至OEM厂商在实现Android时也加入了漏洞。例如，2012年，发现三星设备在使用某种芯片时，在处理相机内存时存在权限提升漏洞，攻击者可以获得所有内存的读写访问权限。
- en: If you want more permissions granted to your app, you can attempt to use a known
    issue from the agent to get root privileges, as shown in [Example 20-27](ch20.xhtml#running_a_privilege-escalation_exploit
    "Example 20-27. Running a privilege-escalation exploit").
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的应用获得更多权限，你可以尝试利用代理中的已知问题来获得root权限，如[示例20-27](ch20.xhtml#running_a_privilege-escalation_exploit
    "示例20-27. 运行权限提升漏洞")所示。
- en: Example 20-27. Running a privilege-escalation exploit
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例20-27. 运行权限提升漏洞
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the agent commands menu, choose option `5.) Privilege Escalation`. From
    here we have two options. We can manually choose an exploit from the exploits
    for Android that SPF knows, or we can let SPF make a selection based on the Android
    version number. Our Android 2.2 emulator is vulnerable to an exploit known as
    Rage Against the Cage. Though this is an older exploit, it works well on the emulator,
    so let’s allow SPF to automatically select the exploit, as shown at ❶. Because
    this is Android 2.2, SPF correctly selects `rageagainstthecage` ❷ and asks for
    the delivery method ❸.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理命令菜单中，选择选项`5.) 权限提升`。从这里我们有两个选项。我们可以手动选择SPF已知的Android漏洞利用，或者让SPF根据Android版本号自动选择。我们的Android
    2.2模拟器易受Rage Against the Cage漏洞利用的攻击。尽管这是一个较旧的漏洞，但它在模拟器上效果很好，所以让我们让SPF自动选择漏洞利用，如图❶所示。因为这是Android
    2.2，SPF正确地选择了`rageagainstthecage` ❷，并要求选择传递方法❸。
- en: After giving the exploit a little time to run, check back with option **`3`**
    from the main menu. The Rooted field should read `RageAgainstTheCage`, as shown
    here.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在让漏洞利用程序运行一段时间后，请返回主菜单，选择选项**`3`**。Rooted字段应显示`RageAgainstTheCage`，如下所示。
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From here we have full control of the device. We can issue commands from a root
    shell or reinstall the agent as a system app, giving us even more privileges than
    the original app.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以完全控制设备。我们可以通过root shell发出命令，或将代理重新安装为系统应用程序，从而比原始应用程序获得更多权限。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This particular exploit is a resource exhaustion attack, so if you want to continue
    using the emulator for additional exercises, you may want to restart it, as it
    may perform slower after this attack.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的漏洞利用是资源耗尽攻击，因此，如果你希望继续使用模拟器进行其他练习，可能需要重启它，因为在此攻击之后，它可能会变得较慢。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a brief look at the relatively new and rapidly evolving
    world of mobile exploitation. We used my SPF tool to run a variety of attacks,
    primarily on emulated Android mobile devices. These attacks will, of course, work
    on real devices in the same way. We looked at a remote attack that checked for
    a default SSH password on jailbroken iPhones, and then studied two client-side
    attack examples. One gave us a shell through a WebKit vulnerability in the browser,
    and the other remotely controlled the device through USSD codes that were automatically
    dialed from a web page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要了解了相对较新且快速发展的移动设备漏洞利用领域。我们使用我的SPF工具进行了多种攻击，主要是在模拟的安卓移动设备上。这些攻击当然也能在真实设备上以相同的方式工作。我们研究了一个远程攻击，检查越狱iPhone上的默认SSH密码，然后研究了两个客户端攻击示例。一个通过浏览器中的WebKit漏洞为我们提供了一个Shell，另一个则通过从网页自动拨打的USSD代码远程控制设备。
- en: We moved on to malicious applications, backdooring legitimate source code or
    compiled APK files with the SPF Android agent. We can use mobile-attack vectors
    such as NFC and SMS to trick users into installing our malicious app. Once the
    agent was installed, we ran attacks such as information gathering and remote control,
    and we used SPF to escalate our privileges to root using known vulnerabilities
    in the Android platform. Finally, we used the SPF agent as a pivot to attack other
    devices in the network. We ran Nmap from the Android device against our Windows
    XP target, and then used a C exploit for War-FTP to exploit the Windows XP target
    from the SPF agent.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转向了恶意应用程序，利用SPF Android代理在合法源代码或已编译的APK文件中植入后门。我们可以使用NFC和SMS等移动攻击向量欺骗用户安装我们的恶意应用。一旦代理安装成功，我们运行了如信息收集和远程控制等攻击，并使用SPF利用已知的Android平台漏洞提升我们的root权限。最后，我们将SPF代理作为跳板，攻击网络中的其他设备。我们从Android设备运行Nmap对Windows
    XP目标进行扫描，然后使用C语言编写的War-FTP漏洞利用，从SPF代理中利用Windows XP目标。
- en: Mobile device security is an exciting field that is adding new dimensions to
    pentesting as the devices enter the workplace. As a pentester, knowing a bit about
    mobile vulnerabilities will come in handy. As attackers use these devices to gain
    sensitive data and a foothold in the network, pentesters must be able to simulate
    these same threats.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备安全是一个令人兴奋的领域，随着这些设备进入工作场所，它为渗透测试增加了新的维度。作为渗透测试人员，了解一些移动设备漏洞将会派上用场。随着攻击者利用这些设备获取敏感数据并在网络中立足，渗透测试人员必须能够模拟这些相同的威胁。
