- en: Chapter 11. Asynchronous and Parallel Programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章。异步编程和并行编程
- en: 'For most of computing’s history, software developers have been spoiled by processor
    manufacturers that were constantly pushing the limits of their chips’ clock speeds.
    If you needed your software to run faster (to process larger data sets, or because
    users were complaining about the system freezing when it was really just busy),
    often all you had to do was upgrade to the latest chip. Over the past decade or
    so something changed: Processor manufacturers began improving processor performance
    not by increasing clock speeds but by adding processing cores.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机历史的大部分时间里，软件开发者一直受益于处理器制造商不断突破其芯片时钟速度的极限。如果你希望软件运行得更快（处理更大的数据集，或因为用户抱怨系统在忙碌时似乎冻结了），通常只需要升级到最新的处理器。然而，过去十年左右，情况发生了变化：处理器制造商开始通过增加处理核心来提高处理器性能，而不是单纯提高时钟速度。
- en: Although processor architecture has changed, software architecture has largely
    remained static. Multicore processors have become the norm, yet many applications
    are still written as though only one core is available to them and thus are not
    taking full advantage of the underlying hardware. Long-running tasks are still
    being executed on the UI thread, and large data sets are often processed synchronously.
    A big reason for this is that, traditionally, asynchronous and parallel programming
    have been sufficiently complex and error prone that they were typically the domain
    of expert developers working on highly specialized software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管处理器架构已经发生变化，但软件架构大体上仍保持不变。多核处理器已成为常态，但许多应用程序仍然以只有一个核心可用的方式编写，因此无法充分利用底层硬件。长时间运行的任务仍然在UI线程上执行，大型数据集通常是同步处理的。这其中一个重要原因是，传统上，异步编程和并行编程足够复杂且容易出错，因此它们通常是专家开发者在高度专业化的软件中使用的领域。
- en: Fortunately, software is starting to catch up. Programmers are learning that
    the days of solving performance issues by throwing faster hardware at the problem
    have passed and that it’s increasingly important to consider concurrent processing
    needs at an architectural level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，软件正在逐步迎头赶上。程序员们正在意识到，通过更快的硬件来解决性能问题的时代已经过去，越来越重要的是在架构层面考虑并发处理的需求。
- en: Although they’re closely related, asynchronous and parallel programming have
    different goals. Asynchronous programming aims to separate processing and reduce
    blocking so that longer-running tasks don’t prevent the system from completing
    other tasks within the same process. By contrast, parallel processing aims to
    improve performance by partitioning work into chunks that can be distributed across
    processors and operated against independently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们密切相关，异步编程和并行编程的目标是不同的。异步编程旨在分离处理过程并减少阻塞，以便长时间运行的任务不会阻碍系统在同一进程中完成其他任务。相比之下，并行处理则旨在通过将工作划分为可分配给多个处理器并独立操作的任务，从而提高性能。
- en: Since its inception, the .NET Framework has supported both asynchronous and
    parallel programming through threads and a multitude of synchronization mechanisms
    such as monitors, mutexes, semaphores, and so on. The *Asynchronous Programming
    Model (APM)*, where classes define `BeginX` and `EndX` methods for operations
    that should be run asynchronously (such as the `BeginRead` and `EndRead` methods
    on the `System.IO.FileStream` class) has long been the preferred approach to asynchronous
    programming in .NET.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET Framework诞生以来，它通过线程和多种同步机制（如监视器、互斥量、信号量等）支持异步编程和并行编程。*异步编程模型（APM）*，其中类定义了`BeginX`和`EndX`方法用于需要异步执行的操作（例如`System.IO.FileStream`类中的`BeginRead`和`EndRead`方法），长期以来一直是.NET中异步编程的首选方式。
- en: 'In this chapter, we’ll explore several ways that F# makes asynchronous and
    parallel programming more accessible, thereby freeing you to focus on creating
    correct solutions. We’ll begin with a brief introduction to the Task Parallel
    Library. Next, we’ll discuss another F# construct: asynchronous workflows. Finally,
    we’ll conclude with an introduction to the `MailboxProcessor`, F#’s agent-based
    model for asynchronous programming.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨F#使异步编程和并行编程更易于访问的几种方式，从而让你可以专注于创建正确的解决方案。我们将从对任务并行库（Task Parallel Library）的简要介绍开始。接下来，我们将讨论另一个F#构造：异步工作流。最后，我们将介绍`MailboxProcessor`，F#基于代理的异步编程模型。
- en: Task Parallel Library
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务并行库
- en: As its name implies, the *Task Parallel Library (TPL)* excels at handling parallel
    programming scenarios and is the preferred mechanism for CPU-bound operations.
    It abstracts much of the complexity of managing threads, locks, callbacks, cancellations,
    and exception handling behind a uniform interface. Although the TPL is not specific
    to F#, a basic understanding of it is helpful especially if you need to interact
    with code from libraries that use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，*任务并行库（TPL）* 擅长处理并行编程场景，并且是 CPU 密集型操作的首选机制。它通过统一的接口抽象了管理线程、锁、回调、取消和异常处理的大部分复杂性。尽管
    TPL 并非专门针对 F#，但理解它的基本概念仍然很有帮助，尤其是当你需要与使用它的库中的代码进行交互时。
- en: 'The TPL enables two types of parallelism: data parallelism and task parallelism.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 提供两种并行类型：数据并行和任务并行。
- en: '****Data parallelism****. Involves performing a specific action against each
    value in a sequence by distributing the work effectively across available processing
    resources. Under the data parallelism model, you specify a sequence along with
    an action and the TPL determines how to partition the data and distributes the
    work accordingly.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****数据并行****。涉及对序列中的每个值执行特定操作，通过有效地将工作分配到可用的处理资源上。在数据并行模型下，你需要指定一个序列及相应的操作，TPL
    会决定如何划分数据并相应地分配工作。'
- en: '****Task parallelism****. Focuses on executing independent tasks concurrently.
    With task parallelism, you are responsible for manually creating and managing
    tasks, but this model offers you more control. Through the various `Task` classes,
    you can easily initiate asynchronous processing, wait for tasks to complete, return
    values, set up continuations, or spawn additional tasks.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****任务并行****。专注于并发执行独立任务。在任务并行中，你需要手动创建和管理任务，但该模型为你提供了更多的控制权。通过各种 `Task` 类，你可以轻松启动异步处理，等待任务完成，返回值，设置后续任务或生成额外任务。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This section is not intended to be a comprehensive guide to the TPL. Thus,
    it won’t get into many of the intricacies of task creation, scheduling, management,
    or other associated topics. The intention here is to establish a baseline, providing
    you with enough information to make you immediately productive when writing code
    using the TPL.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节内容并非旨在提供关于 TPL 的全面指南。因此，它不会涉及任务创建、调度、管理或其他相关主题的许多细节。这里的目的是建立一个基准，提供足够的信息，使你在使用
    TPL 编写代码时能够立即提高生产力。*'
- en: Potential Parallelism
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 潜在并行性
- en: One of the key differences between working directly with threads and using the
    TPL is that the TPL is task based rather than thread based. This difference is
    quite important in that the TPL tries to run tasks concurrently by pulling threads
    from the thread pool, but it does not guarantee parallelism. This is known as
    *potential parallelism*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 直接操作线程与使用 TPL 之间的一个主要区别在于，TPL 是基于任务的，而不是基于线程的。这一差异非常重要，因为 TPL 试图通过从线程池中提取线程来并发执行任务，但它并不保证并行性。这被称为
    *潜在并行性*。
- en: Whenever you create a thread directly, you incur the overhead of allocating
    and scheduling it. This overhead can be detrimental to overall system performance
    if there aren’t enough system resources available to support it. The basic concurrency
    mechanisms, like thread pooling, help reduce the impact by reusing existing threads,
    but the TPL goes a step further by taking available system resources into account.
    If there aren’t sufficient resources available or the TPL otherwise determines
    that running a task in parallel will be detrimental to performance, it will run
    the task synchronously. As resources fluctuate over time, the TPL’s task scheduling
    and work partitioning algorithms help rebalance work to use the available resources
    effectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你直接创建一个线程时，就会产生分配和调度的开销。如果没有足够的系统资源来支持线程，这种开销可能会对整体系统性能造成不利影响。基本的并发机制，如线程池，帮助通过重用现有线程来减少影响，但
    TPL 进一步考虑了可用的系统资源。如果没有足够的资源可用，或者 TPL 认为并行执行任务会对性能造成不利影响，它将同步执行任务。随着资源随时间波动，TPL
    的任务调度和工作划分算法帮助重新平衡工作，以有效利用可用资源。
- en: Data Parallelism
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据并行
- en: Data parallelism is achieved primarily through the use of the static `For` and
    `ForEach` methods of the `Parallel` class located in the `System.Threading.Tasks`
    namespace. As their names imply, these methods are essentially parallel versions
    of the simple and enumerable `for` loops, respectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并行性主要通过使用位于 `System.Threading.Tasks` 命名空间中的 `Parallel` 类的静态 `For` 和 `ForEach`
    方法来实现。正如它们的名称所示，这些方法本质上是简单的 `for` 循环和可枚举 `for` 循环的并行版本。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Data parallelism can also be achieved through PLINQ’s (Parallel LINQ) AsParallel
    extension method. To simplify working with parallel sequences in F#, the PSeq
    module in the F# PowerPack exposes many of the ParallelEnumerable methods using
    the same nomenclature as the Seq module.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据并行性还可以通过 PLINQ（并行 LINQ）的 AsParallel 扩展方法来实现。为了简化在 F# 中处理并行序列，F# PowerPack
    中的 PSeq 模块使用与 Seq 模块相同的命名法暴露了许多 ParallelEnumerable 方法。*'
- en: For normal usage, `Parallel.For` and `Parallel.ForEach` differ only by their
    input; `Parallel.For` accepts range boundaries, whereas `Parallel.ForEach` accepts
    a sequence. Both methods also accept a function that serves as the loop body,
    and they implicitly wait for all iterations to complete before returning control
    to the caller. Since the methods are so similar, the examples in this section
    will use `Parallel.For` for consistency.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用法，`Parallel.For` 和 `Parallel.ForEach` 仅在输入上有所不同；`Parallel.For` 接受范围边界，而
    `Parallel.ForEach` 接受一个序列。这两个方法还接受一个作为循环体的函数，并且它们会隐式地等待所有迭代完成后再将控制权返回给调用者。由于这两个方法非常相似，本节的示例将统一使用
    `Parallel.For` 以保持一致性。
- en: The simplest form, the parallel `for` loop, simply invokes an action for each
    value in the range. Here, we use a parallel `for` loop to write the numbers 0
    through 99.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的形式，即并行 `for` 循环，仅为范围中的每个值调用一次操作。在这里，我们使用并行 `for` 循环来写出数字 0 到 99。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This snippet is pretty self-explanatory. The first argument passed to `Parallel.For`
    identifies the inclusive beginning of the range, while the second identifies the
    exclusive end of the range. The third argument is a function that writes a number
    to the console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段几乎不需要解释。传递给 `Parallel.For` 的第一个参数标识范围的包含起点，第二个参数标识范围的排除终点。第三个参数是一个将数字写入控制台的函数。
- en: Locking and Lock Avoidance
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定与避免锁定
- en: Now that we’re dealing with concurrency, there’s a subtle bug in the previous
    example. Internally, `printfn` incrementally sends its text to `System.Console.Out`
    as it parses the pattern. Hence, it’s possible that as each parallel iteration
    executes, multiple calls to `printfn` will be invoked simultaneously, resulting
    in some items being interlaced.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在处理并发，前面的示例中有一个微妙的 bug。内部，`printfn` 会在解析模式时逐步将文本发送到 `System.Console.Out`。因此，随着每个并行迭代的执行，可能会同时调用多个
    `printfn`，导致一些项目交织在一起。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The example used for this discussion is less of an issue in F# 3.1, where
    printf and its related functions have been improved such that they run up to 40
    times faster than in previous releases.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*用于本讨论的示例在 F# 3.1 中并不是一个问题，因为 printf 和相关函数得到了改进，使其运行速度比以前的版本快了最多 40 倍。*'
- en: 'We can address this problem a few ways. One approach is to control access to
    `System.Console.Out` with the `lock` operator. The `lock` operator serves the
    same purpose as the `lock` statement in C# (`SyncLock` in Visual Basic) in that
    it prevents additional threads from executing a block of code until the locked
    resource is freed. Here is the previous example reworked to use locking:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来解决这个问题。一个方法是使用 `lock` 操作符控制对 `System.Console.Out` 的访问。`lock` 操作符与
    C# 中的 `lock` 语句（Visual Basic 中的 `SyncLock`）具有相同的作用，即在锁定资源释放之前，防止其他线程执行该代码块。以下是将前一个示例重新编写以使用锁定的代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are times when locking is appropriate, but using it like this is a horrible
    idea. By locking, we negate most of the benefits of parallelizing the loop because
    only one item can be written at a time! Instead, we want to try another approach
    that avoids locking and doesn’t interlace the results.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时锁定是合适的，但像这样使用它是一个糟糕的主意。通过锁定，我们抵消了并行化循环的大部分好处，因为一次只能写入一个项目！相反，我们希望尝试另一种方法，避免锁定并且不交织结果。
- en: 'One of the easiest ways to achieve a satisfactory result is with function composition.
    Here, we use the `sprint` function to format the number and send that result to
    `Console.WriteLine`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实现满意结果的最简单方法之一是函数组合。在这里，我们使用 `sprint` 函数来格式化数字，并将结果传递给 `Console.WriteLine`：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This approach works because each call to `sprintf` writes to an isolated `StringBuilder`
    rather than a shared `TextWriter`. This eliminates the need to lock, thereby eliminating
    a potential bottleneck in your application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效，因为每次调用 `sprintf` 都是写入一个独立的 `StringBuilder`，而不是共享的 `TextWriter`。这消除了锁的需求，从而消除了应用程序中的潜在瓶颈。
- en: Short-Circuiting Parallel Loops
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并行循环的短路操作
- en: 'Unlike F#’s built-in `for` loops, parallel loops provide some short-circuiting
    mechanisms by means of the `ParallelLoopState` class’s `Break` and `Stop` methods.
    The TPL handles creating and managing the loop state, so all you need to do to
    access either of these methods is use one of the overloads that exposes it. Consider
    the following `shortCircuitExample` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与 F# 内建的 `for` 循环不同，并行循环通过 `ParallelLoopState` 类的 `Break` 和 `Stop` 方法提供了一些短路机制。TPL
    负责创建和管理循环状态，因此你所需要做的就是使用暴露这些方法的重载。考虑以下 `shortCircuitExample` 函数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like the previous examples, the `shortCircuitExample` function uses `Parallel.For`,
    but notice at ① that the supplied function accepts two parameters instead of one.
    The second parameter, `s`, is the loop state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，`shortCircuitExample` 函数使用 `Parallel.For`，但请注意在①处，提供的函数接受两个参数，而不是一个。第二个参数
    `s` 是循环状态。
- en: 'With `shortCircuitExample` in place we can now invoke it, passing a function
    that accepts a `ParallelLoopState` instance and calls either `Stop` or `Break`,
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shortCircuitExample` 后，我们可以调用它，传递一个接受 `ParallelLoopState` 实例并调用 `Stop` 或
    `Break` 的函数，像这样：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both of the preceding lines will force the parallel loop to terminate before
    all iterations complete, but they have very different effects. `Stop` causes the
    loop to terminate at its earliest convenience but allows any iterations that are
    executing to continue. `Break`, on the other hand, causes the loop to terminate
    at its earliest convenience after the current iteration. You also need to take
    care that you do not call `Stop` and `Break` in succession to avoid an `InvalidOperationException`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两行都会强制并行循环在所有迭代完成之前终止，但它们的效果截然不同。`Stop` 会使循环在最早的便利时终止，但允许正在执行的任何迭代继续；而`Break`
    会使循环在当前迭代之后的最早时刻终止。你还需要注意，避免连续调用 `Stop` 和 `Break`，以免引发 `InvalidOperationException`。
- en: The difference between these two methods can be drastic. For example, in one
    run on my desktop, the `Break` version processed 10,000 items, whereas the `Stop`
    version processed only 975.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法的差异可能非常明显。例如，在我桌面的一次运行中，`Break` 版本处理了 10,000 个项，而 `Stop` 版本仅处理了 975 个。
- en: Cancelling Parallel Loops
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消并行循环
- en: Cancelling a parallel `for` loop is similar to short-circuiting, except that
    instead of using the `Stop` or `Break` methods to terminate the loop from within,
    you identify an external *cancellation token* that the loop monitors and responds
    to. Unlike the short-circuiting mechanism, cancellation forces all tasks configured
    with the same token to stop. Cancelling does raise an `OperationCanceledException`,
    so you’ll want to handle that accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 取消并行 `for` 循环类似于短路操作，只不过它不是通过 `Stop` 或 `Break` 方法从内部终止循环，而是识别一个外部的 *取消令牌*，该令牌由循环监视并做出响应。与短路机制不同，取消操作会强制所有使用相同令牌配置的任务停止。取消操作会引发
    `OperationCanceledException`，因此你需要适当处理这个异常。
- en: 'The following function demonstrates cancelling a parallel `for` loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数演示了如何取消并行 `for` 循环：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we create a `CancellationTokenSource` at ①. This object
    is initialized to automatically cancel after a provided number of milliseconds.
    Inside the `try` block, we use an overload of `Parallel.For` that accepts a `ParallelOptions`
    instance as shown at ②. Through this `ParallelOptions` instance, we initialize
    the `CancellationToken` property ③ to the token exposed by the `CancellationTokenSource`
    ④. When the token source’s internal timer expires, the parallel loop raises an
    exception, which is then caught and handled at ⑤.Although we relied on a `CancellationTokenSource`
    that automatically cancelled, you can manually force cancellation by calling the
    `Cancel` method, typically from another task or thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们在①创建了一个 `CancellationTokenSource`。该对象初始化为在指定的毫秒数后自动取消。在 `try` 块内部，我们使用了一个重载的
    `Parallel.For`，它接受一个 `ParallelOptions` 实例，如②所示。通过这个 `ParallelOptions` 实例，我们将 `CancellationToken`
    属性③初始化为 `CancellationTokenSource` ④所暴露的令牌。当令牌源的内部定时器到期时，并行循环会引发一个异常，然后在⑤处捕获并处理。虽然我们依赖于一个自动取消的
    `CancellationTokenSource`，你也可以通过调用 `Cancel` 方法手动强制取消，通常是在另一个任务或线程中执行。
- en: Task Parallelism
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务并行性
- en: Task parallelism gives you the most control over executing code in parallel
    while still abstracting many of the implementation details from you.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行性使你可以在执行代码并行时，仍能对执行过程有最大的控制，同时抽象掉了许多实现细节。
- en: Creating and Starting Tasks
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建并启动任务
- en: 'Tasks can be created and started in several ways. The easiest, but least flexible,
    way is the `Parallel.Invoke` method, which accepts one or more functions to execute
    concurrently and implicitly waits for them to finish, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以通过几种方式创建和启动。最简单，但最不灵活的方式是 `Parallel.Invoke` 方法，它接受一个或多个函数并行执行，并隐式等待它们完成，像这样：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `Parallel.Invoke` creates and starts three independent tasks. The first
    and third tasks simply print a message, while the second task waits 100 milliseconds
    before printing its message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Parallel.Invoke` 创建并启动了三个独立的任务。第一个和第三个任务只是简单地打印消息，而第二个任务在打印消息之前等待了 100
    毫秒。
- en: '`Parallel.Invoke` limits what you can do because it doesn’t expose any information
    about the individual tasks, nor does it provide any feedback about whether the
    tasks succeeded or failed. You can catch and handle exceptions raised by the tasks
    and cancel them by providing a cancellation token (similar to the approach used
    in [Cancelling Parallel Loops](ch11.html#cancelling_parallel_loops "Cancelling
    Parallel Loops")), but that’s about it. When you want to do anything more advanced
    with tasks, you’ll need to create them manually.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke` 限制了你可以做的事情，因为它不暴露任何关于单个任务的信息，也没有提供任务成功或失败的反馈。你可以通过提供取消令牌来捕获和处理任务引发的异常并取消任务（类似于在[取消并行循环](ch11.html#cancelling_parallel_loops
    "Cancelling Parallel Loops")中使用的方法），但就是这么多了。当你想对任务做更高级的操作时，你需要手动创建它们。'
- en: 'There are two ways to create tasks manually: directly via a constructor, or
    through a `TaskFactory`. For our purposes, the primary difference between the
    two approaches is that when creating tasks with the constructor you must manually
    start them. Microsoft recommends favoring the `TaskFactory` when task creation
    and scheduling don’t need to be separated.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务有两种手动方式：通过构造函数直接创建，或者通过 `TaskFactory`。就我们的目的而言，这两种方法的主要区别在于，使用构造函数创建任务时，你必须手动启动它们。微软推荐在任务创建和调度不需要分开时，优先使用
    `TaskFactory`。
- en: 'To create a new task with the `Task` constructor, you need only provide a function
    that serves as the task’s body, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Task` 构造函数创建一个新任务，你只需要提供一个作为任务主体的函数，像这样：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This creates a new task that prints a string. To start the task, call its `Start`
    method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个打印字符串的新任务。要启动任务，调用它的 `Start` 方法。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can combine the two steps into one with a `TaskFactory`.
    Conveniently, the `Task` class has a static `Factory` property that is preset
    to a default `TaskFactory`, so you don’t need to create one on your own. Here,
    we create and start a task using the default factory’s `StartNew` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过 `TaskFactory` 将这两个步骤合并为一步。方便的是，`Task` 类有一个静态的 `Factory` 属性，已经预设为一个默认的
    `TaskFactory`，因此你无需自己创建一个。在这里，我们使用默认工厂的 `StartNew` 方法创建并启动一个任务：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Returning Values from Tasks
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从任务中返回值
- en: The tasks we’ve looked at so far simply invoke an action, but you also need
    to know how to return a value—a commonly needed but cumbersome process under traditional
    asynchronous models. The TPL makes returning values trivial through a generic
    `Task<'T>` class, where `'T` represents the task’s return type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所看到的任务只是调用一个操作，但你还需要知道如何返回值——这是传统异步模型中一个常见且繁琐的过程。TPL 通过一个泛型 `Task<'T>`
    类使返回值变得简单，其中 `'T` 代表任务的返回类型。
- en: Warning
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*The random-number generation used in the following examples is sufficient
    for demonstration purposes, but be aware that the `System.Random` class is not
    thread-safe and even creating a new instance per task may not be sufficient. Should
    your solution require a more robust approach to concurrently generating random
    numbers, I recommend reading Stephen Toub’s article on the subject at* [http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx](http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下示例中使用的随机数生成方法足以用于演示，但请注意，`System.Random` 类不是线程安全的，即使每个任务创建一个新的实例也可能不足以保证线程安全。如果你的解决方案需要更强大的并发随机数生成方法，建议阅读
    Stephen Toub 关于该主题的文章，地址是* [http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx](http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx)。'
- en: Creating tasks that return values is almost identical to the basic tasks we’ve
    already looked at. The `Task<'T>` class provides a set of constructor overloads
    that are comparable to that of the non-generic `Task` class, and the `TaskFactory`
    includes a generic overload of `StartNew`. To demonstrate, let’s use `StartNew<'T>`
    to create and run a task that returns a random number.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建返回值的任务几乎与我们已经看过的基本任务相同。`Task<'T>`类提供了一组构造函数重载，这些重载与非泛型`Task`类的构造函数类似，`TaskFactory`包括`StartNew`的泛型重载。为了演示，让我们使用`StartNew<'T>`来创建并运行一个返回随机数的任务。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The only truly notable thing about this example is that the function passed
    to `StartNew` returns an integer and the generic overload is inferred. Of course,
    returning a value doesn’t do much good without a way to access that value, and
    that’s why `Task<''T>` provides the `Result` property, which will contain the
    return value when the task completes. Here, we see how to access the return value:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中唯一真正值得注意的地方是传递给`StartNew`的函数返回一个整数，并且泛型重载是被推断出来的。当然，返回一个值如果没有方法来访问它，是没有太大意义的，这就是为什么`Task<'T>`提供了`Result`属性，当任务完成时，它将包含返回值。在这里，我们展示了如何访问返回值：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because this is an asynchronous operation, there’s no guarantee that the task
    has completed executing before the `Result` property is accessed. For this reason,
    `Result`’s `get` accessor checks whether the task has completed and waits for
    it to complete if necessary before returning its result. It’s more typical to
    access the result as part of a continuation (as shown a bit later in this chapter)
    than immediately after the task starts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个异步操作，因此无法保证在访问`Result`属性之前，任务已经执行完成。为此，`Result`的`get`访问器会检查任务是否已完成，并在必要时等待任务完成后再返回结果。通常，在任务开始后，立即访问结果不太常见，而是作为后续操作的一部分进行访问（如本章稍后所示）。
- en: Waiting for Task Completion
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: 'When your program depends on one or more tasks completing before it can continue
    processing, you can wait for those tasks using one of the wait mechanisms. For
    convenience, the examples in this section will use the following function, which
    returns a new function that sleeps for a random amount of time (simulating a long-running
    operation lasting up to `delayMs`) before printing a message:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序依赖于一个或多个任务完成后才能继续处理时，你可以使用其中一种等待机制来等待这些任务。为了方便，本节中的示例将使用以下函数，该函数返回一个新函数，该函数在打印消息之前会随机睡眠一段时间（模拟一个持续时间最长为`delayMs`的长时间操作）：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use the `TaskFactory` to create a task and wait for it to complete with
    the task’s `Wait` method like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`TaskFactory`来创建任务，并通过任务的`Wait`方法等待它完成，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, a new task is created and started, but the message “Done Waiting”
    won’t be written to the console until it completes due to the explicit wait. This
    can be helpful when subsequent code is dependent upon the task’s completion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，一个新的任务被创建并启动，但由于显式等待，直到任务完成后，消息“Done Waiting”才会被写入控制台。当后续代码依赖于任务完成时，这种方式非常有用。
- en: 'You’ll often want to run a number of tasks in parallel and block until one
    completes. To do so, you can use the static `WaitAny` method from the `Task` class.
    The most basic `WaitAny` overload accepts a `params` array of tasks and will stop
    blocking as soon as one of the tasks in the array completes. Here, we pass three
    started tasks to `WaitAny`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会希望并行运行多个任务，并在其中一个任务完成之前阻塞。为此，你可以使用`Task`类的静态`WaitAny`方法。最基本的`WaitAny`重载接受一个任务数组，并且只要数组中的任何一个任务完成，它就会停止阻塞。这里，我们将三个已启动的任务传递给`WaitAny`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When any of the three tasks complete, `WaitAny` will stop blocking, thus allowing
    execution to continue to the `Console.WriteLine` call. Note that `WaitAny` doesn’t
    kill the remaining tasks when it unblocks, so they’ll continue executing in parallel
    with the source thread.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当三个任务中的任何一个完成时，`WaitAny`将停止阻塞，从而允许执行继续进行到`Console.WriteLine`调用。请注意，`WaitAny`在解除阻塞时不会终止剩余的任务，因此它们会继续与源线程并行执行。
- en: Similar to `WaitAny`, the `Task` class provides a static `WaitAll` method. `WaitAll`
    also accepts a `params` array of tasks, but instead of allowing execution to continue
    when one task completes, `WaitAll` unblocks only when *all* of the tasks have
    completed. Because the code differs only by which method is called, I haven’t
    included a sample, but I encourage you to experiment with each. As you do so,
    run each form several times and observe the differences.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WaitAny`类似，`Task`类提供了一个静态的`WaitAll`方法。`WaitAll`同样接受一个`params`任务数组，但与允许执行在一个任务完成时继续不同，`WaitAll`只有在*所有*任务都完成时才会解除阻塞。由于代码的区别仅在于调用了哪个方法，所以我没有包括示例，但我鼓励你尝试每种方法。在尝试时，可以多次运行每种形式并观察其差异。
- en: Continuations
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 延续任务
- en: Traditionally, whenever you wanted to execute some code as soon as some parallel
    or asynchronous code completed, you needed to pass a function, called a *callback*,
    to the asynchronous code. In .NET, callbacks have typically been implemented through
    the built-in `AsyncCallback` delegate type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每当你希望在某些并行或异步代码完成后立即执行某些代码时，你需要将一个函数（称为*回调*）传递给异步代码。在 .NET 中，回调通常通过内置的`AsyncCallback`委托类型来实现。
- en: Using callbacks is effective, but they can complicate the code and be tricky
    to maintain. The TPL greatly simplifies this process with *continuations*, which
    are tasks configured to start when one or more tasks, called *antecedents*, complete.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调是有效的，但它们可能会使代码变得复杂且难以维护。TPL通过*延续任务*大大简化了这个过程，延续任务是配置为在一个或多个任务（称为*先行任务*）完成时启动的任务。
- en: 'The simplest continuations are created from individual tasks. Let’s start by
    creating a task that will serve as an antecedent:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的延续任务是由单个任务创建的。我们从创建一个作为先行任务的任务开始：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have a task, we can set up a continuation by passing a function
    to the task’s `ContinueWith` method, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个任务，我们可以通过将一个函数传递给任务的`ContinueWith`方法来设置延续任务，像这样：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, creating a continuation is very similar to creating a regular
    task, but notice at ① how the function passed to the `ContinueWith` method accepts
    a parameter of type `Task<string>`. This parameter represents the antecedent so
    that the continuation can branch according to the antecedent’s status (for example,
    `RanToCompletion`, `Faulted`, `Canceled`, and so on) or its result if it has one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建一个延续任务与创建常规任务非常相似，但请注意在①处传递给`ContinueWith`方法的函数如何接受一个类型为`Task<string>`的参数。这个参数代表先行任务，以便延续任务可以根据先行任务的状态（例如，`RanToCompletion`、`Faulted`、`Canceled`等）或其结果（如果有的话）来分支。
- en: 'At this point, neither task has been started, so we’ll start `antecedent`.
    When it completes, the TPL will automatically start `continuation`. We can observe
    this behavior as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，两个任务都尚未开始，因此我们将启动`antecedent`。当它完成时，TPL 将自动启动`continuation`。我们可以通过以下方式观察这种行为：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'which should print the following messages:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应该打印以下信息：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ContinueWith` method is useful when you’re dealing with only a single task.
    When you have multiple tasks, you can turn to the `TaskFactory`’s `ContinueWhenAny`
    or `ContinueWhenAll` methods. Like their `WaitAny` and `WaitAll` counterparts,
    the `ContinueWhenAny` and `ContinueWhenAll` methods will start the continuation
    task when any or all of the tasks in an array complete, respectively. For brevity
    we’ll focus on the `ContinueWhenAll` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`方法在你处理单个任务时非常有用。当你有多个任务时，你可以转向`TaskFactory`的`ContinueWhenAny`或`ContinueWhenAll`方法。像它们的`WaitAny`和`WaitAll`对应方法一样，`ContinueWhenAny`和`ContinueWhenAll`方法将在数组中的任何任务或所有任务完成时启动延续任务。为了简洁起见，我们将重点介绍`ContinueWhenAll`方法。'
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ContinueWhenAny` follows the same pattern as `WaitAny`. Here we’ve defined
    three tasks, which we manually start after creating the continuation at ①.Notice
    the continuation task’s parameter at ②. Instead of receiving a single antecedent
    task as you would with `ContinueWith` or `ContinueWhenAny`, continuations created
    with `ContinueWhenAll` accept an array of tasks. This array contains all of the
    tasks supplied to `ContinueWhenAll` instead of the individual task that caused
    the continuation to start. This allows you to inspect each antecedent and handle
    success and failure scenarios as granularly as you need.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWhenAny`遵循与`WaitAny`相同的模式。在这里，我们定义了三个任务，并在创建延续任务后手动启动它们，在①处创建延续任务。请注意在②处延续任务的参数。与使用`ContinueWith`或`ContinueWhenAny`时传递单个先行任务不同，使用`ContinueWhenAll`创建的延续任务接受一个任务数组。这个数组包含传递给`ContinueWhenAll`的所有任务，而不是启动延续任务的单个任务。这使你能够检查每个先行任务并根据需要细粒度地处理成功和失败的场景。'
- en: Cancelling Tasks
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'Cancelling a task is fundamentally the same as cancelling a parallel `for`
    loop, but it requires a bit more work because the parallel `for` loops handle
    the cancellation details for you. The following function demonstrates cancelling
    a task and follows the typical pattern for handling the cancellation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 取消任务在本质上与取消并行`for`循环相同，但它需要更多的工作，因为并行`for`循环会为你处理取消的细节。以下函数演示了取消任务，并遵循了典型的取消处理模式：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with cancelling parallel `for` loops, we start by creating a `CancellationTokenSource`
    at ①. For convenience, we then bind the token to a name at ② so we can reference
    it within the function the task is based upon. Within the task body, the first
    thing we do at ③ is call the token’s `ThrowIfCancellationRequested` method, which
    interrogates the token’s `Is CancellationRequested` property and throws an `OperationCanceledException`
    if that property returns `true`. We do this to ensure that no unnecessary work
    is performed if cancellation was requested when the task was started. When no
    exception is thrown, execution continues. At ④ we again check for cancellation
    to avoid a successful task completion. Finally, at ⑤ we wait for the task to complete
    so we can handle any exceptions thrown by the task.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与取消并行`for`循环类似，我们首先在①创建一个`CancellationTokenSource`。为了方便起见，我们在②将该令牌绑定到一个名称，以便在任务基于的函数内引用它。在任务体内，我们首先在③调用令牌的`ThrowIfCancellationRequested`方法，该方法检查令牌的`IsCancellationRequested`属性，如果该属性返回`true`，则抛出`OperationCanceledException`。我们这样做是为了确保在任务启动时如果请求了取消，就不会执行不必要的工作。当没有抛出异常时，执行将继续进行。在④，我们再次检查取消状态，以避免任务成功完成。最后，在⑤我们等待任务完成，以便处理任务抛出的任何异常。
- en: Exception Handling
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exceptions can be raised by any number of executing tasks at any time. When
    this happens, we need a way to capture and handle them. In the previous section,
    we handled the exception in a general manner—by matching any exception and writing
    it to the console. If you executed the `taskWithCancellation` function, you may
    have noticed that the exception we caught wasn’t an `OperationCanceledException`
    but rather an `AggregateException` that included an `OperationCanceledException`.
    The base exception classes aren’t well suited for parallel scenarios because they
    represent only a single failure. To compensate, a new exception type, `AggregateException`,
    was introduced to allow us to report one or more failures within a single construct.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以由任何数量的执行任务在任何时候抛出。当这种情况发生时，我们需要一种方法来捕获和处理它们。在前一节中，我们以通用方式处理了异常——通过匹配任何异常并将其写入控制台。如果你执行了`taskWithCancellation`函数，你可能注意到我们捕获的异常不是`OperationCanceledException`，而是一个包含`OperationCanceledException`的`AggregateException`。基本的异常类不太适合并行场景，因为它们只表示单一的失败。为了弥补这一点，介绍了一个新的异常类型`AggregateException`，它允许我们在一个构造体中报告一个或多个失败。
- en: Although you certainly could handle an `AggregateException` directly, you’ll
    typically want to find a specific exception within it. For this, the `AggregateException`
    class provides the `Handle` method, which iterates over the exceptions contained
    within its `InnerExceptions` collection so you can find the exception you really
    care about and handle it accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你完全可以直接处理`AggregateException`，但通常你会希望在其中找到一个特定的异常。为此，`AggregateException`类提供了`Handle`方法，该方法遍历其`InnerExceptions`集合中的异常，以便你找到真正关心的异常并进行相应处理。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Handling an `AggregateException` follows the familiar exception-handling pattern:
    We match against the `AggregateException` and bind it to the name `ex` as you
    might expect. Inside the handler, we invoke the `Handle` method ①, which accepts
    a `Func<exn, bool>` indicating that the supplied function accepts an exception,
    and return a Boolean value. (To use pattern-matching functions as we’ve done here,
    we explicitly construct `Func<_, _>` instances and allow the compiler to infer
    the proper type arguments.) Inside the pattern-matching function ②, we detect
    whether we have a nested `AggregateException` and handle it at ③. At each level,
    we need to return a Boolean value indicating whether the particular exception
    was handled. If we return `false` for any exception, a new `AggregateException`
    which contains the unhandled exception will be raised.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`AggregateException`遵循熟悉的异常处理模式：我们匹配`AggregateException`并将其绑定到名称`ex`，正如你所预期的那样。在处理程序内部，我们调用`Handle`方法①，接受一个`Func<exn,
    bool>`，表示提供的函数接受一个异常并返回布尔值。（为了像这里一样使用模式匹配函数，我们显式构造`Func<_, _>`实例，并让编译器推断出适当的类型参数。）在模式匹配函数②内部，我们检测是否有嵌套的`AggregateException`并在③处进行处理。在每一层，我们需要返回一个布尔值，指示特定的异常是否已处理。如果我们对任何异常返回`false`，则会抛出一个新的`AggregateException`，该异常包含未处理的异常。
- en: 'Handling `AggregateException`s like this can get quite cumbersome, complex,
    and tedious. Fortunately, `AggregateException` provides another method, `Flatten`,
    which simplifies error handling by iterating over the `InnerExceptions` collection
    and recursing over each nested `AggregateException` to construct a new `AggregateException`
    instance that directly contains all of the exceptions within the source exception’s
    hierarchy. For example, we can revise the previous example to use `Flatten` to
    simplify the handler, like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`AggregateException`像这样可能变得相当繁琐、复杂和乏味。幸运的是，`AggregateException`提供了另一个方法`Flatten`，通过迭代`InnerExceptions`集合并递归遍历每个嵌套的`AggregateException`，来简化错误处理，构造一个新的`AggregateException`实例，该实例直接包含源异常层次结构中的所有异常。例如，我们可以修改之前的示例，使用`Flatten`来简化处理程序，如下所示：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this revised example, we call `Handle` against the flattened `AggregateException`.
    With only one level to process, we can omit the checks for nested `AggregateExceptions`
    and handle the `NotImplementedException` directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的示例中，我们对已展平的`AggregateException`调用`Handle`。由于只有一层需要处理，我们可以省略对嵌套`AggregateExceptions`的检查，直接处理`NotImplementedException`。
- en: Asynchronous workflows
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步工作流
- en: Despite the many improvements that the TPL brings to asynchronous and parallel
    programming, F# offers its own model, which better matches the functional paradigm
    emphasized by the language. While it’s sometimes desirable to use the TPL in F#
    (particularly when working across language boundaries) you’ll often turn to F#’s
    asynchronous workflows, which are best suited for I/O-based operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TPL为异步和并行编程带来了许多改进，但F#提供了自己的模型，这种模型更好地匹配了语言强调的函数式范式。虽然有时在F#中使用TPL是可取的（特别是在跨语言边界工作时），但你通常会转向F#的异步工作流，它们最适合I/O操作。
- en: '*Asynchronous workflows* provide a uniform and idiomatic way to compose and
    execute asynchronous code against the thread pool. Furthermore, their very nature
    often makes it difficult (if not impossible) to fall into some of the asynchronous
    traps present even in the TPL.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步工作流*提供了一种统一且符合习惯的方式，用于在线程池上组合和执行异步代码。此外，它们的特性通常使得我们很难（如果不是不可能的话）陷入即使在TPL中也存在的某些异步陷阱。'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Like our TPL discussion, this section is intended to give you a basic working
    knowledge of asynchronous workflows rather than serving as a comprehensive guide.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*就像我们的TPL讨论一样，本节旨在为你提供异步工作流的基本工作知识，而不是作为一个全面的指南。*'
- en: Creating and Starting Asynchronous Workflows
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和启动异步工作流
- en: Asynchronous workflows are based on the `Async<'T>` class that resides in the
    `Microsoft.FSharp.Control` namespace. This type represents a bit of code you want
    to run asynchronously, ultimately returning some value. Instead of creating `Async<'T>`
    instances directly, though, we compose them through async expressions much like
    we compose sequences or queries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流基于位于`Microsoft.FSharp.Control`命名空间中的`Async<'T>`类。该类型表示你希望异步运行的一段代码，最终返回某个值。不过，不是直接创建`Async<'T>`实例，我们通过异步表达式来组合它们，就像我们组合序列或查询一样。
- en: 'Async expressions take the following form:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 异步表达式采用以下形式：
- en: '`async {` *async-expressions* `}`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`async {` *异步表达式* `}`'
- en: Here, *async-expressions* represents one or more expressions that will participate
    in the asynchronous operation. In addition to the standard expressions we’ve seen
    throughout this book, asynchronous workflows allow you to easily invoke additional
    workflows and wait for results without blocking through specialized variants of
    some familiar keywords such as `let` and `use`. For instance, the `let!` keyword
    invokes an asynchronous workflow and binds the result to a name. Similarly, the
    `use!` keyword invokes an asynchronous workflow that returns a disposable object,
    binds the result to a name, and disposes of the object when it goes out of scope.
    It’s also possible to invoke an asynchronous workflow and immediately return the
    result with the `return!` keyword.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*async-expressions* 代表一个或多个将参与异步操作的表达式。除了我们在本书中看到的标准表达式外，异步工作流允许你轻松地调用额外的工作流，并等待结果而不阻塞，通过一些熟悉的关键字如
    `let` 和 `use` 的特殊变体。例如，`let!` 关键字调用一个异步工作流，并将结果绑定到一个名称。类似地，`use!` 关键字调用一个异步工作流，该工作流返回一个可处置对象，将结果绑定到一个名称，并在超出作用域时处置该对象。还可以使用
    `return!` 关键字调用一个异步工作流并立即返回结果。
- en: 'To demonstrate, we’ll turn to the “hello world” example of asynchronous workflows:
    requesting multiple web pages. To begin, let’s define some functions that encapsulate
    the logic needed to create an asynchronous page request (note that a similar function,
    `Http.AsyncRequestString`, is available in the `FSharp.Data` framework):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将使用异步工作流的“hello world”示例：请求多个网页。首先，让我们定义一些函数来封装创建异步页面请求所需的逻辑（请注意，在 `FSharp.Data`
    框架中有一个类似的函数 `Http.AsyncRequestString`）：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After opening the relevant namespaces, we extend the `StreamReader` class with
    a single `AsyncReadToEnd` method. This method, adapted from the F# PowerPack,
    is similar to the existing `ReadToEndAsync` method except that instead of using
    the TPL, it returns an asynchronous workflow that we can evaluate as the final
    step of the larger workflow in the `getPage` function where we describe how to
    make the page request. The overall flow of the expression is pretty standard:
    Create a `WebRequest`, wait for the response, and then explicitly return the response
    stream’s contents.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开相关命名空间之后，我们通过单个 `AsyncReadToEnd` 方法扩展了 `StreamReader` 类。这个方法来自 F# PowerPack，类似于现有的
    `ReadToEndAsync` 方法，不同之处在于，它并没有使用 TPL，而是返回一个异步工作流，我们可以在描述如何发起页面请求的 `getPage` 函数的最终步骤中进行评估。整体表达式的流程非常标准：创建一个
    `WebRequest`，等待响应，然后显式返回响应流的内容。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The `AsyncGetResponseMethod` is an extension method defined in the F# core
    library. It conveniently wraps the standard .NET code within another asynchronous
    workflow, which makes it possible to employ use! and greatly simplifies the code.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*`AsyncGetResponseMethod` 是 F# 核心库中定义的一个扩展方法。它方便地将标准 .NET 代码包装在另一个异步工作流中，这使得使用
    `use!` 成为可能，并大大简化了代码。*'
- en: It’s important to recognize that `getPage` doesn’t actually execute the request;
    it merely creates an instance of `Async<string>` that represents the request.
    This allows us to define multiple requests or pass them around to other functions.
    We can even execute the request multiple times. To execute the request we need
    to turn to the static `Async` class, which you can think of as a controller for
    asynchronous workflows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，`getPage` 实际上并不执行请求；它仅仅创建了一个表示请求的 `Async<string>` 实例。这使我们能够定义多个请求，或者将它们传递给其他函数。我们甚至可以多次执行请求。要执行请求，我们需要转向静态的
    `Async` 类，你可以将其视为异步工作流的控制器。
- en: There are a number of methods for starting an asynchronous workflow. Some common
    methods are listed in [Table 11-1](ch11.html#common_async_start_methods "Table 11-1. Common
    Async Start Methods").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 启动异步工作流有多种方法。一些常见的方法列在[表 11-1](ch11.html#common_async_start_methods "表 11-1.
    常见的异步启动方法")中。
- en: Table 11-1. Common Async Start Methods
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1. 常见的异步启动方法
- en: '| Method | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `RunSynchronously` | Starts an asynchronous workflow and waits for its result.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `RunSynchronously` | 启动异步工作流并等待其结果。 |'
- en: '| `Start` | Starts an asynchronous workflow but does not wait for a result.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Start` | 启动异步工作流，但不等待结果。 |'
- en: '| `StartImmediate` | Starts an asynchronous workflow immediately using the
    current thread. Useful for UI updates. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `StartImmediate` | 使用当前线程立即启动异步工作流。适用于 UI 更新。 |'
- en: '| `StartWithContinuations` | Immediately starts an asynchronous workflow using
    the current thread, invoking a success, exception, or cancellation continuation
    depending on how the operation completed. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `StartWithContinuations` | 立即使用当前线程启动一个异步工作流，根据操作完成的情况调用成功、异常或取消的延续。 |'
- en: 'The method you choose is largely dependent upon what the workflow does, but
    you’ll typically use `Start` unless your application requires one of the others.
    The workflow created by the `getPage` function returns the result of a web request.
    Since we’re making the request, we probably don’t want to ignore the result, so
    we’ll need to wire up a continuation to do something with it. The easiest way
    to do that is to wrap the call to `getPage` inside another asynchronous expression,
    passing the result to another function when it completes, and starting the entire
    workflow with `Start`. Here, we call `getPage` and print the result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的方法主要取决于工作流的具体任务，但通常情况下，除非应用程序需要其他方法，否则你会使用`Start`。由`getPage`函数创建的工作流返回的是一个网页请求的结果。由于我们在发起请求，通常我们不希望忽略结果，因此需要通过延续来处理结果。最简单的方法是将`getPage`的调用包装在另一个异步表达式中，当它完成时将结果传递给另一个函数，并使用`Start`启动整个工作流。在这里，我们调用`getPage`并打印结果：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using Async
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Async
- en: The fact that `Async` is a static class rather than a module has ramifications
    for how you interact with it. Rather than providing `let`-bound functions as a
    module would, `Async` provides methods, many of which are overloaded primarily
    to aid in cancellation. Furthermore, `Async`’s methods are typically designed
    with a more object-oriented approach than is typical in the core F# libraries.
    Accordingly, their parameters are often tupled, making it difficult to use them
    with pipelining.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async`是一个静态类而不是一个模块，这对你与其交互的方式有一定影响。与模块提供`let`绑定的函数不同，`Async`提供方法，其中许多方法是重载的，主要是为了帮助取消操作。此外，`Async`的方法通常采用面向对象的方法设计，这与核心F#库中常见的设计方式不同。因此，它们的参数通常是元组，这使得使用管道操作时会比较困难。'
- en: 'Alternatively, we can use the `StartWithContinuations` method, which accepts
    an asynchronous workflow and three functions to invoke when the workflow finishes
    successfully, raises an exception, or is cancelled, respectively. The following
    code shows such an approach:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`StartWithContinuations`方法，该方法接受一个异步工作流以及三个函数，分别在工作流成功完成、抛出异常或被取消时调用。以下代码展示了这种方法：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the asynchronous operation ① completes successfully, the success continuation
    ② is invoked and the first 50 characters from the page source will be printed.
    Should the operation throw an exception, the exception continuation ③ will execute
    and print the exception. Finally, if the operation is cancelled, as described
    in [Cancelling Asynchronous Workflows](ch11.html#cancelling_asynchronous_workflows
    "Cancelling Asynchronous Workflows"), the cancellation continuation ④ will execute
    and display a note informing the user of the cancellation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步操作①成功完成时，成功的延续②将被调用，并且页面源代码的前50个字符将被打印。如果操作抛出异常，异常延续③将被执行，并打印异常信息。最后，如果操作被取消，正如在[取消异步工作流](ch11.html#cancelling_asynchronous_workflows
    "取消异步工作流")中所描述的，取消延续④将被执行，并显示一条通知用户操作已取消的信息。
- en: 'Instead of relying on continuations, we can use the `RunSynchronously` method
    and get the result directly, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以不依赖延续，而是使用`RunSynchronously`方法直接获取结果，如下所示：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Of course, running a single asynchronous workflow like this defeats the purpose
    of running it asynchronously because `RunSynchronously` waits for the result.
    Instead, `RunSynchronously` is often used in conjunction with `Async.Parallel`
    to run multiple workflows in parallel and wait for all of them to complete. For
    instance, we can make multiple requests, starting with an array of asynchronous
    workflows, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像这样运行一个单一的异步工作流实际上违背了异步运行的初衷，因为`RunSynchronously`会等待结果。相反，`RunSynchronously`通常与`Async.Parallel`一起使用，用于并行运行多个工作流并等待它们全部完成。例如，我们可以通过一个异步工作流数组来发起多个请求，如下所示：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we employ the `Parallel` method to combine each of the asynchronous workflows
    into a single workflow that is then piped to the `RunSynchronously` method. When
    each of the requests has completed, we iterate over the resulting array, stripping
    a few characters from the content for readability and printing the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `Parallel` 方法将每个异步工作流合并成一个单一的工作流，然后将其传递给 `RunSynchronously` 方法。当每个请求完成时，我们遍历结果数组，去除一些字符以便于阅读，并打印结果。
- en: Cancelling Asynchronous Workflows
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消异步工作流
- en: In the previous section I indicated that asynchronous workflows can be cancelled.
    Just as in the TPL, asynchronous workflows use cancellation tokens to control
    cancellation. It’s possible, and sometimes even necessary, to manage tokens on
    your own, but in many cases you can rely on the `Async` class’s default token.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提到过异步工作流可以被取消。就像在 TPL 中一样，异步工作流使用取消令牌来控制取消。你可以自己管理令牌，这在某些情况下甚至是必要的，但在很多情况下，你可以依赖于
    `Async` 类的默认令牌。
- en: 'For simple scenarios, such as when you’re starting a single work-flow via the
    `Start` or `StartWithContinuations` methods, you can use the `CancelDefaultToken`
    method to cancel the workflow, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的场景，例如当你通过 `Start` 或 `StartWithContinuations` 方法启动单个工作流时，你可以使用 `CancelDefaultToken`
    方法来取消工作流，如下所示：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `StartWithContinuations` method ① monitors the default token and cancels
    the workflow when the token is marked as cancelled via the `CancelDefaultToken`
    method ②. In this example, because the workflow is cancelled before it completes,
    the cancellation callback is invoked instead of the success callback, resulting
    in the cancellation message being displayed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartWithContinuations` 方法① 监视默认令牌，并在通过 `CancelDefaultToken` 方法② 标记令牌为已取消时取消工作流。在此示例中，由于工作流在完成之前被取消，因此会调用取消回调，而不是成功回调，导致显示取消消息。'
- en: The `TryCancelled` method, which accepts a workflow and a function that will
    be invoked when cancellation is requested, is a nice alternative for work-flows
    that don’t return a value. Here, the `displayPartialPage` function wraps a call
    to `getPage` within another asynchronous workflow. The outer workflow waits for
    the response and writes out the first 50 characters when the message is received.
    Because `TryCancelled` returns yet another workflow and doesn’t automatically
    start it, we need to explicitly do so with a call to `Start`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryCancelled` 方法接受一个工作流和一个在请求取消时将被调用的函数，这是一个很好的替代方案，适用于不返回值的工作流。在这里，`displayPartialPage`
    函数将对 `getPage` 的调用包装在另一个异步工作流中。外部工作流等待响应并在收到消息时输出前50个字符。由于 `TryCancelled` 返回另一个工作流，并且不会自动启动它，我们需要通过调用
    `Start` 显式启动它。'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default token is often sufficient for cancelling workflows. When you’re
    executing multiple workflows and want to coordinate cancellation or if you want
    more control over cancellation, you can supply your own. Consider what happens
    when you request three pages but request cancellation with the default token.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认令牌通常足以取消工作流。当你执行多个工作流并希望协调取消时，或者如果你希望对取消有更多控制时，你可以提供自己的令牌。考虑一下，当你请求三个页面并使用默认令牌请求取消时，会发生什么。
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Executing the preceding code usually results in all three workflows being cancelled.
    (Usually, but not always, because there’s a chance that one or more workflows
    complete before the cancellation is handled.) To isolate each workflow’s cancellation,
    we can use an overload of the `Start` method that accepts a user-specified token,
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码通常会导致所有三个工作流被取消。（通常是这样，但并非总是如此，因为有可能一个或多个工作流在取消处理之前就完成了。）为了隔离每个工作流的取消，我们可以使用一个重载的
    `Start` 方法，接受用户指定的令牌，如下所示：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this revised version, we use `Array.map` to map each `Uri` to a workflow
    with its own `CancellationTokenSource` created at ①. We then pass the associated
    token to `Async.Start` as the second argument ② before returning the `CancellationTokenSource`.
    Finally, at ③ and ④, respectively, we request cancellation of the first and second
    requests, allowing the third to proceed as normal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改版中，我们使用 `Array.map` 将每个 `Uri` 映射到一个具有自己 `CancellationTokenSource` 的工作流，该源在①处创建。然后，我们将相关的令牌作为第二个参数传递给
    `Async.Start`②，最后返回 `CancellationTokenSource`。最后，在③和④处，我们分别请求取消第一个和第二个请求，允许第三个请求正常进行。
- en: What’s especially nice about cancelling asynchronous workflows is that, unlike
    the TPL, cancellation tokens are propagated through the entire workflow automatically.
    This means that you don’t have to manually ensure that each new workflow is given
    a token, leaving you with cleaner code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 取消异步工作流的一个特别好的地方在于，与TPL不同，取消令牌会自动传播到整个工作流。这意味着你无需手动确保每个新工作流都获得一个令牌，从而使代码更加简洁。
- en: Exception Handling
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: Because exceptions can and do occur within asynchronous workflows, it’s important
    to know how to handle them properly. There are a few exception-handling options
    available, but their utility may vary depending on what you’re doing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常可能在异步工作流中发生，因此了解如何正确处理它们是非常重要的。有几种异常处理选项可供选择，但它们的有效性可能会根据你的具体操作有所不同。
- en: 'The most uniform way to handle exceptions in an asynchronous work-flow is to
    wrap the potentially offending code inside a `try...with` block within the async
    expression. For instance, we can provide a version of our `getPage` function that
    handles exceptions raised during the page request and read, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步工作流中异常的最统一方式是将潜在有问题的代码包装在异步表达式中的 `try...with` 块内。例如，我们可以提供一个版本的 `getPage`
    函数来处理页面请求和读取过程中抛出的异常，如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There’s nothing unusual about the `try...with` block in the preceding code—we
    simply wrap the asynchronous call to `getPage` in the `try...with` block and return
    a successful read as an option. Should the operation raise an exception, we match
    the exception type, print a message, and return `None`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的 `try...with` 块没有什么异常——我们只是将对 `getPage` 的异步调用包装在 `try...with` 块中，并将成功读取的结果作为一个选项返回。如果操作抛出异常，我们匹配异常类型，打印消息，并返回
    `None`。
- en: Another way to handle exceptions from asynchronous workflows is the `Async.Catch`
    method. `Async.Catch` takes a more functional approach than `StartWithContinuations`
    in that rather than accepting an exception-handling function, it returns `Choice<'T,
    exn>`, where `'T` is the asynchronous workflow’s return type and `exn` is the
    exception thrown by the workflow.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步工作流异常的另一种方式是使用 `Async.Catch` 方法。与 `StartWithContinuations` 相比，`Async.Catch`
    采用了更具函数式风格的方式：它返回 `Choice<'T, exn>`，其中 `'T` 是异步工作流的返回类型，`exn` 是工作流抛出的异常，而不是接受一个异常处理函数。
- en: 'The `Choice` type is a discriminated union with two union cases: `Choice1Of2`
    and `Choice2Of2`. For `Async.Catch`, `Choice1Of2` represents successful completion
    of the workflow and contains the result, whereas `Choice2Of2` represents failure
    and contains the first raised exception.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Choice` 类型是一个带有两个联合情况的区分联合类型：`Choice1Of2` 和 `Choice2Of2`。对于 `Async.Catch`，`Choice1Of2`
    代表工作流的成功完成并包含结果，而 `Choice2Of2` 代表失败并包含第一个抛出的异常。'
- en: Handling exceptions with `Async.Catch` lets you structure your asynchronous
    code to create an idiomatic, pipelined data flow. For example, the following code
    shows how we can model an asynchronous operation as a series of function applications,
    beginning with a `Uri`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Async.Catch` 处理异常使你能够结构化异步代码，创建符合惯用法的管道化数据流。例如，以下代码展示了如何将异步操作建模为一系列函数应用，从一个
    `Uri` 开始。
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, a `Uri` is piped into the `getPage` function to create an asynchronous
    workflow. The resulting workflow is piped into `Async.Catch` to set up another
    workflow, which we then pipe to `Async.RunSynchronously` so we can wait for the
    result. Finally, we pipe the `Choice` into a pattern-matching function where we
    either return `Some result` or handle the exception before returning `None`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个 `Uri` 被传递到 `getPage` 函数以创建一个异步工作流。生成的工作流被传递到 `Async.Catch` 中，设置另一个工作流，然后我们将其传递到
    `Async.RunSynchronously`，以便等待结果。最后，我们将 `Choice` 传递给模式匹配函数，在该函数中我们要么返回 `Some result`，要么处理异常后返回
    `None`。
- en: Asynchronous Workflows and the Task Parallel Library
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步工作流与任务并行库
- en: In addition to the `ThreadPool`-based asynchronous operations we’ve seen so
    far, the `Async` class provides a few methods for working with TPL tasks. Most
    notable among them are `StartAsTask` and `AwaitTask`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们迄今为止看到的基于 `ThreadPool` 的异步操作外，`Async` 类还提供了几个用于处理 TPL 任务的方法。其中最显著的是 `StartAsTask`
    和 `AwaitTask`。
- en: 'The `StartAsTask` method invokes an asynchronous workflow as a TPL task. You
    would typically use this for CPU-bound operations or to expose an asynchronous
    workflow to code using the TPL in C# or Visual Basic. For instance, we can treat
    the result of our `getPage` function as a TPL task like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartAsTask` 方法作为 TPL 任务调用一个异步工作流。通常，你会在 CPU 密集型操作或者需要将异步工作流暴露给使用 TPL 的 C#
    或 Visual Basic 代码时使用它。例如，我们可以像这样将 `getPage` 函数的结果视为 TPL 任务：'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The presence of the `Result` property at ① indicates that the result of `StartAsTask`
    is indeed a `Task`. In a more real-world scenario, you likely wouldn’t fire off
    a task and immediately block by waiting for the result, but this example is intended
    only to show how to start an asynchronous workflow as a TPL `Task`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ① 处存在 `Result` 属性，表明 `StartAsTask` 的结果确实是一个 `Task`。在更现实的场景中，你可能不会启动一个任务后立刻阻塞等待结果，但这个示例仅用于展示如何将异步工作流作为
    TPL `Task` 启动。
- en: The `StartAsTask` method is handy when you need to create a new task, but what
    about when you need to handle an existing task? Consider the `DownloadStringTaskAsync`
    method added to the `System.Net.WebClient` class in .NET 4.5\. This method serves
    the same purpose as our `getPage` function except that it encapsulates downloading
    a resource within a TPL task.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartAsTask` 方法在你需要创建新任务时非常方便，但如果你需要处理一个已有的任务怎么办？考虑一下在 .NET 4.5 中添加到 `System.Net.WebClient`
    类中的 `DownloadStringTaskAsync` 方法。这个方法与我们的 `getPage` 函数的作用相同，区别在于它将下载资源封装在 TPL
    任务中。'
- en: 'In C#, you can easily handle such methods with the `async` modifier and `await`
    operator, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你可以像这样通过 `async` 修饰符和 `await` 操作符轻松处理此类方法：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From a greatly simplified perspective, what happens in the preceding C# code
    is this: The `async` modifier ① is applied to the `GetPageAsync` method to signify
    that part of the method will run asynchronously. The `await` operator ② then signifies
    that execution should return to the caller and the remainder of the method should
    be treated as a continuation to be executed when the task completes.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个大大简化的角度来看，在前面的 C# 代码中发生的事情是这样的：`async` 修饰符①被应用于 `GetPageAsync` 方法，表示方法的一部分将异步执行。接着，`await`
    操作符②表示执行应该返回给调用者，方法的其余部分应作为一个后续操作，待任务完成时执行。
- en: 'Asynchronous workflows allow us to follow a similar pattern in F# using the
    `AwaitTask` method in combination with a TPL task and `let!`, `use!`, or `return!`.
    Here is the corresponding code in F#:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流使我们能够在 F# 中使用 `AwaitTask` 方法结合 TPL 任务和 `let!`、`use!` 或 `return!` 跟随类似的模式。下面是
    F# 中的对应代码：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although they’re not quite functionally equivalent (the C# version waits for
    the result in `Main` while the F# version passes the result to a continuation),
    the F# approach is similar to that of C#. In the F# version, the asynchronous
    workflow created by the `getPageAsync` function uses `return!` and `Async.AwaitTask`
    ① to wait for the task to complete before returning the result. Then, in the second
    asynchronous workflow, `let!` ② is used to evaluate `getPageAsync`, while printing
    the result is treated as a continuation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们在功能上并不完全等价（C# 版本会在 `Main` 中等待结果，而 F# 版本则将结果传递给一个后续操作），但 F# 方法与 C# 的方法类似。在
    F# 版本中，通过 `getPageAsync` 函数创建的异步工作流使用 `return!` 和 `Async.AwaitTask` ① 来等待任务完成后返回结果。然后，在第二个异步工作流中，`let!`
    ② 用于求值 `getPageAsync`，同时打印结果被视为一个后续操作。
- en: Agent-Based Programming
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于代理的编程
- en: As if the TPL and asynchronous workflows didn’t make parallel and asynchronous
    programming accessible enough, F# has borrowed a message-processing mechanism
    from Erlang. The `MailboxProcessor<'T>` class implements a queue-based system
    for asynchronously routing messages (data items) to handlers using shared memory.
    This is especially useful in scenarios where multiple sources (clients) need to
    request something from a single target (server), the canonical example being a
    web server. Furthermore, because `MailboxProcessor` instances are extremely lightweight,
    an application can manage thousands of them without breaking a sweat. This fact
    enables mailbox processors to work independently or together by passing messages
    between instances.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说 TPL 和异步工作流还不足以让并行和异步编程变得足够易用，F# 还借用了来自 Erlang 的消息处理机制。`MailboxProcessor<'T>`
    类实现了一个基于队列的系统，用于通过共享内存异步路由消息（数据项）到处理器。这在多个源（客户端）需要从单一目标（服务器）请求某些内容的场景中非常有用，经典的例子就是
    web 服务器。此外，由于 `MailboxProcessor` 实例极其轻量化，应用程序可以管理成千上万个实例而不至于出现问题。这一特性使得邮件处理器能够独立工作或通过实例之间传递消息共同工作。
- en: '`MailboxProcessor` instances are usually referred to as *agents*, and I’ll
    follow this convention throughout this section. In that regard, a common practice
    in agent-based programming is to alias `MailboxProcessor<''T>` as `Agent<''T>`as
    follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailboxProcessor`实例通常被称为*代理*，我将在本节中遵循这一惯例。在这方面，基于代理的编程中常见的做法是将`MailboxProcessor<''T>`别名为`Agent<''T>`，如下所示：'
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the type aliased, we can create agents using the more convenient name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型别名化，我们可以使用更方便的名称创建代理。
- en: Getting Started
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: I think the best way to understand agent-based programming is with an example.
    We’ll start with a simple agent that simply prints whatever is sent into it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为理解基于代理的编程的最佳方式是通过示例。我们从一个简单的代理开始，它会打印传递给它的任何内容。
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, we create an agent called `echoAgent` by passing a function
    to the `Start` method as shown at ①. By convention, the function’s parameter is
    called `inbox` because it’s the *mailbox* from which we’ll receive new messages.
    At ② we define the recursive `loop` function, which we’ll call continually to
    receive new messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过将一个函数传递给`Start`方法创建了一个名为`echoAgent`的代理，如①所示。根据惯例，函数的参数被命名为`inbox`，因为它是我们接收新消息的*邮箱*。在②处，我们定义了递归的`loop`函数，我们将不断调用该函数来接收新消息。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It’s certainly possible to loop imperatively using a while loop, but the recursive
    function is the more typical approach. Functional loops provide the additional
    benefit of easily allowing you to provide different looping logic when you need
    to manage multiple states. For instance, if your agent needs to behave differently
    in a paused state than a running state, you could define a pair of mutually recursive
    functions that both return a workflow that handles the corresponding state accordingly.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用while循环来进行命令式循环当然是可能的，但递归函数是更典型的方法。函数式循环提供了额外的好处，当你需要管理多个状态时，它使得提供不同的循环逻辑变得更加容易。例如，如果你的代理在暂停状态下需要与运行状态下有不同的行为，你可以定义一对互相递归的函数，它们都返回一个工作流，根据相应的状态进行处理。*'
- en: Inside the loop, we create an asynchronous workflow that first asynchronously
    receives a message from `inbox` using the `Receive` method as shown at ③.Next,
    the received message is printed before making an asynchronous recursive call to
    `loop` at ④. Finally, at ⑤ we initiate recursion by making a standard, synchronous
    call to `loop`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们创建了一个异步工作流，首先使用`Receive`方法异步地从`inbox`接收消息，如③所示。接下来，接收到的消息会被打印出来，然后在④处进行异步递归调用`loop`。最后，在⑤处，我们通过进行标准的同步调用来启动递归，调用`loop`。
- en: 'With `echoAgent` actively listening, we can send it some messages via the `Post`
    method, like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`echoAgent`处于主动监听状态时，我们可以通过`Post`方法向它发送一些消息，如下所示：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, when `echoAgent` receives a message, it is written to the console
    and then `echoAgent` waits for another message, and the process repeats ad infinitum.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当`echoAgent`接收到一条消息时，它会将其写入控制台，然后`echoAgent`等待另一条消息，整个过程不断重复。
- en: Scanning for Messages
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描消息
- en: In the `echoAgent` example, we used the `Receive` method to get messages from
    the underlying queue. In many cases, `Receive` is appropriate, but it makes it
    difficult to filter messages because it removes them from the queue. To selectively
    process messages, you might consider using the `Scan` method instead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`echoAgent`示例中，我们使用`Receive`方法从底层队列获取消息。在许多情况下，`Receive`方法是合适的，但它会将消息从队列中移除，导致难以过滤消息。为了有选择性地处理消息，你可以考虑改用`Scan`方法。
- en: Scanning for messages follows a different pattern than receiving them directly.
    Rather than processing the messages inline and always returning an asynchronous
    workflow, the `Scan` method accepts a filtering function that accepts a message
    and returns an `Async<'T>` option. In other words, when the message is something
    you want to process, you return `Some<Async<'T>`; otherwise, you return `None`.
    To demonstrate, let’s revise the `echoAgent` to process only strings and integers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描消息的方式与直接接收消息的方式不同。`Scan`方法不是直接内联处理消息并始终返回异步工作流，而是接受一个过滤函数，该函数接受一条消息并返回`Async<'T>`选项。换句话说，当消息是你想处理的内容时，你返回`Some<Async<'T>>`；否则，返回`None`。为了演示，我们将修改`echoAgent`，只处理字符串和整数。
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At ① and ② you can see standard dynamic type-test patterns used to filter incoming
    messages to strings and integers, respectively. When the message is one of those
    two types, we associate an asynchronous workflow with `Some` and return it. For
    all other messages, we return `None`. `Scan` the nexamines the returned value,
    and when it is `Some`, the message is consumed(removed from the queue) and the
    workflow is invoked. When the returned value is `None`, `Scan` immediately waits
    for another message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在①和②处，你可以看到标准的动态类型测试模式，用来分别将传入的消息过滤为字符串和整数。当消息是这两种类型之一时，我们会将一个异步工作流与`Some`关联并返回它。对于所有其他消息，我们返回`None`。`Scan`检查返回的值，当它是`Some`时，消息被消费（从队列中移除）并触发工作流。返回值是`None`时，`Scan`立即等待另一个消息。
- en: 'Passing messages to `echoAgent2` is the same as before—just pass the messages
    via the `Post` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 向`echoAgent2`传递消息和之前一样——只需通过`Post`方法传递消息：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Scanning for messages does offer some flexibility with how you process messages,
    but you need to be mindful of what you’re posting to the agent because messages
    not processed by `Scan` remain in the queue. As the queue size increases, scans
    will take longer to complete, so you can quickly run into performance issues using
    this approach if you’re not careful. You can see how many messages are in the
    queue at any time by inspecting the `CurrentQueueLength` property. If you need
    to remove messages from the queue, you can do so by invoking `Receive` for each
    message in the queue, but needing to do so is probably indicative of a larger
    design problem that should be addressed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描消息确实提供了一些处理消息的灵活性，但你需要注意你向代理发布了什么，因为`Scan`未处理的消息会保留在队列中。随着队列大小的增加，扫描将需要更长的时间，因此，如果不小心使用这种方法，你可能会很快遇到性能问题。你可以通过检查`CurrentQueueLength`属性来查看队列中有多少消息。如果你需要从队列中移除消息，可以通过调用`Receive`来处理队列中的每条消息，但如果你需要这样做，这可能意味着一个更大的设计问题需要解决。
- en: Replying to Messages
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回复消息
- en: 'The agents we’ve created so far have been self-contained: They receive a message,
    do something with it, and wait for another message. Agents don’t have to work
    in isolation, though. One way you can make agents more interactive is by having
    them reply via an `AsyncReplyChannel`. To demonstrate, let’s revise `echoAgent`
    again, but this time, instead of printing a message within the agent, we’ll have
    it reply.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的代理都是自包含的：它们接收消息，处理消息，然后等待下一个消息。不过，代理不必在孤立中工作。有一种方法可以使代理更加互动，那就是让它们通过`AsyncReplyChannel`来回复。为了演示这一点，我们再次修改`echoAgent`，这次，我们不再在代理内部打印消息，而是让它进行回复。
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The overall structure of `echoAgent3` doesn’t differ much from the previous
    versions. For convenience, we’re using a discriminated union ① for our message
    type as is typical in agent-based programming. In this case, the `ReplyMessage`
    union type has a single case with two associated values, an object and the reply
    channel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`echoAgent3`的整体结构与之前的版本差别不大。为了方便起见，我们使用了一个判别联合类型①作为我们的消息类型，这在基于代理的编程中是典型的做法。在这种情况下，`ReplyMessage`联合类型有一个单一的案例，包含两个关联值，一个对象和一个回复通道。'
- en: Inside the loop body, we use pattern matching ② to identify the union case and
    extract the message and channel. We then pass the message to the channel’s `Reply`
    method ③ before repeating. Now all that’s left is to send a message to the agent.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体内，我们使用模式匹配②来识别联合案例并提取消息和通道。然后，我们将消息传递给通道的`Reply`方法③，然后再继续循环。现在剩下的就是向代理发送消息了。
- en: '`ReplyMessage`’s second value is an `AsyncReplyChannel<obj>`, as you’ve already
    seen. In theory we could manually construct a reply channel and send the `ReplyMessage`
    to the agent with the `Post` method, but then we’d have to handle waiting for
    the result manually. There are much better ways to get the reply channel—namely,
    the `PostAndReply` method and its variants.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplyMessage`的第二个值是一个`AsyncReplyChannel<obj>`，正如你已经看到的那样。理论上，我们可以手动构建一个回复通道，并使用`Post`方法将`ReplyMessage`发送给代理，但那样我们就必须手动处理等待结果的过程。获取回复通道有更好的方法——即`PostAndReply`方法及其变种。'
- en: 'The `PostAndReply` methods differ a bit from `Post` in that, instead of accepting
    the message directly, they are higher-order functions that accept a function that
    takes in a preconstructed reply channel and returns the fully constructed method.
    For our purposes, we’ll simply create a `ReplyMessage` like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostAndReply`方法与`Post`方法略有不同，它们并不直接接受消息，而是高阶函数，接受一个函数，该函数接收一个预构建的回复通道并返回完全构建好的方法。为了方便起见，我们会简单地创建一个`ReplyMessage`，如下所示：'
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Internally, `PostAndReply` (and its variants) construct reply channels that
    they pass on to the supplied function, which then creates the message that is
    ultimately posted to the agent.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Agent-Based Calculator'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve seen a variety of ways to create and interact with agents,
    let’s look at a more interesting example that ties together several of the concepts
    for something a bit more useful than simply regurgitating its input: an agent-based
    calculator. We’ll begin by defining a discriminated union that represents the
    messages the calculator will support.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Operation` union type defines six cases. Of those, four represent basic
    mathematical operations and have an associated `float` that is used in the calculation.
    The `Clear` case allows us to clear the stored value. Finally, the `Current` case
    lets us interrogate the agent for its current value using its associated reply
    channel. From this definition, we can create a new agent that handles each case
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even though `calcAgent` appears to keep a running total, it is a bit of an illusion
    in that we keep state only by passing a value (`total`) to the recursive `loop`
    function. When `calcAgent` receives a message, it uses pattern matching to determine
    the appropriate action, binding the result to `newValue`. For instance, when it
    receives an `Add`, `Subtract`, `Multiply`, or `Divide` operation, it applies the
    corresponding mathematical operation to `total`. Similarly, when it receives a
    `Clear` operation, it simply returns `0.0` and `Current` returns `total` after
    replying.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To see `calcAgent` in action, we just need to send it some messages:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding snippet, we simply pass a list of `Operations` to `List.iter`,
    posting each message to `calcAgent`. When those have been processed, we query
    for the current value, clear, and then query again to ensure that the total has
    been zeroed out. Invoking the preceding snippet results in the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous and parallel programming have long been viewed as tools for specialized
    software and reserved for experienced developers. With processor manufacturers
    improving processor performance by adding cores instead of increasing clock speed,
    software developers can no longer solve performance issues solely by upgrading
    hardware, nor can they continue expecting users to wait for long-running operations
    to complete before returning control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as F# make asynchronous and parallel programming more accessible
    by providing multiple, robust mechanisms. The TPL makes it easy for developers
    to efficiently handle CPU-bound operations such as processing large data sets
    while effectively using available system resources. Language features such as
    asynchronous workflows excel at keeping applications responsive during IO-based
    operations such as web requests or file accesses. Finally, agent-based programming
    lets you easily coordinate complex systems by firing off individual asynchronous
    processes without having to directly manage the complexity of traditional thread-based
    models. Together, these approaches help you build scalable, responsive applications
    that meet the demands of modern computing while keeping you focused on the actual
    problems your software is trying to solve.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
