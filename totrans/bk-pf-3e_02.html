<html><head></head><body><section class="chapter" epub:type="chapter" id="pf_configuration_basics" title="Chapter&#xA0;2.&#xA0;PF Configuration Basics"><div class="titlepage"><div><div><h2 class="title">Chapter 2. PF Configuration Basics</h2></div></div></div><div class="mediaobject"><a id="med_id00003"/><img alt="PF Configuration Basics" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1161"/><a class="indexterm" id="iddle1636"/><a class="indexterm" id="iddle1783"/>In this chapter, we’ll create a very simple setup with PF. We’ll begin with the simplest configuration possible: a single machine configured to communicate with a single network. This network could very well be the Internet.</p><p>Your two main tools for configuring PF are your favorite text editor and the <code class="literal">pfctl</code> command-line administration tool. PF configurations, usually stored in <span class="emphasis"><em>/etc/pf.conf</em></span>, are called <span class="emphasis"><em>rule sets</em></span> because each line in the configuration file is a <span class="emphasis"><em>rule</em></span> that helps determine what the packet-filtering subsystem should do with the network traffic it sees. In ordinary, day-to-day administration, you edit your configuration in the <span class="emphasis"><em>/etc/pf</em></span>.<span class="emphasis"><em>conf</em></span> file and then load your changes using <code class="literal">pfctl</code>. There are Web interfaces for PF administration tasks, but they’re not part of the base system. The PF developers aren’t hostile toward these options, but they’ve yet to see a graphical interface for configuring PF that’s clearly preferable to editing <span class="emphasis"><em>pf.conf</em></span> and using <code class="literal">pfctl</code> commands.</p><div class="sect1" title="The First Step: Enabling PF"><div class="titlepage"><div><div><h2 class="title" id="first_step_enabling_pf" style="clear: both">The First Step: Enabling PF</h2></div></div></div><p><a class="indexterm" id="iddle1216"/><a class="indexterm" id="iddle1574"/><a class="indexterm" id="iddle1575"/><a class="indexterm" id="iddle1631"/><a class="indexterm" id="iddle1634"/><a class="indexterm" id="iddle1638"/><a class="indexterm" id="iddle1643"/><a class="indexterm" id="iddle1912"/>Before you can get started on the fun parts of shaping your network with PF and related tools, you need to make sure that PF is available and enabled. The details depend on your specific operating system: OpenBSD, FreeBSD, or NetBSD. Check your setup by following the instructions for your operating system and then move on to <a class="xref" href="ch02.html#simple_pf_rule_set_a_singlecomma_stand-a" title="A Simple PF Rule Set: A Single, Stand-Alone Machine">A Simple PF Rule Set: A Single, Stand-Alone Machine</a>.</p><p>The <code class="literal">pfctl</code> command is a program that requires higher privilege than the default for ordinary users. In the rest of this book, you’ll see commands that require extra privilege prefixed with <code class="literal">sudo</code>. If you haven’t started using <code class="literal">sudo</code> yet, you should. <code class="literal">sudo</code> is in the base system on OpenBSD. On FreeBSD, DragonFly BSD, and NetBSD, it’s within easy reach via the ports system or pkgsrc system, respectively, as <span class="emphasis"><em>security/sudo</em></span>.</p><p>Here are a couple general notes regarding using <code class="literal">pfctl</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The command to disable PF is <code class="literal">pfctl -d</code>. Once you’ve entered that command, all PF-based filtering that may have been in place will be disabled, and all traffic will be allowed to pass.</p></li><li class="listitem"><p>For convenience, <code class="literal">pfctl</code> can handle several operations on a single command line. To enable PF and load the rule set in a single command, enter the following:</p><a id="pro_id00003"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -ef /etc/pf.conf</strong></span></pre></li></ul></div><div class="sect2" title="Setting Up PF on OpenBSD"><div class="titlepage"><div><div><h3 class="title" id="setting_up_pf_on_openbsd">Setting Up PF on OpenBSD</h3></div></div></div><p>In OpenBSD 4.6 and later, you don’t need to enable PF because it’s enabled by default with a minimal configuration in place.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch02fn01" id="ch02fn01">9</a>]</sup> If you were watching the system console closely while the system was starting up, you may have noticed the <code class="literal">pf enabled</code> message appear soon after the kernel messages completed.</p><p>If you didn’t see the <code class="literal">pf enabled</code> message on the console at startup, you have several options to check that PF is indeed enabled. One simple way to check is to enter the command you would otherwise use to enable PF from the command line:</p><a id="pro_id00004"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -e</strong></span></pre><p>If PF is already enabled, the system responds with this message:</p><a id="pro_id00005"/><pre class="programlisting">pfctl: pf already enabled</pre><p><a class="indexterm" id="iddle1001"/><a class="indexterm" id="iddle1087"/><a class="indexterm" id="iddle1159"/><a class="indexterm" id="iddle1268"/><a class="indexterm" id="iddle1284"/><a class="indexterm" id="iddle1319"/><a class="indexterm" id="iddle1614"/><a class="indexterm" id="iddle1632"/><a class="indexterm" id="iddle1644"/><a class="indexterm" id="iddle1736"/><a class="indexterm" id="iddle1810"/><a class="indexterm" id="iddle1855"/>If PF isn’t enabled, the <code class="literal">pfctl -e</code> command will enable PF and display this:</p><a id="pro_id00006"/><pre class="programlisting">pf enabled</pre><p>In versions prior to OpenBSD 4.6, PF wasn’t enabled by default. You can override the default by editing your <span class="emphasis"><em>/etc/rc.conf.local</em></span> file (or creating the file, if it doesn’t exist). Although it isn’t necessary on recent OpenBSD versions, it doesn’t hurt to add this line to your <span class="emphasis"><em>/etc/rc.conf.local</em></span> file:</p><a id="pro_id00007"/><pre class="programlisting">pf=YES           # enable PF</pre><p>If you take a look at the <span class="emphasis"><em>/etc/pf.conf</em></span> file in a fresh OpenBSD installation, you get your first exposure to a working rule set.</p><p>The default OpenBSD <span class="emphasis"><em>pf.conf</em></span> file starts off with a <code class="literal">set skip on lo</code> rule to make sure traffic on the loopback interface group isn’t filtered in any way. The next active line is a simple <code class="literal">pass</code> default to let your network traffic pass by default. Finally, an explicit <code class="literal">block</code> rule blocks remote X11 traffic to your machine.</p><p>As you probably noticed, the default <span class="emphasis"><em>pf.conf</em></span> file also contains a few comment lines starting with a hash mark (<code class="literal">#</code>). In those comments, you’ll find suggested rules that hint at useful configurations, such as FTP passthrough via <code class="literal">ftp-proxy</code> (see <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>) and <code class="literal">spamd</code>, the OpenBSD spam-deferral daemon (see <a class="xref" href="ch06.html" title="Chapter 6. Turning the Tables for Proactive Defense">Chapter 6</a>). These items are potentially useful in various real-world scenarios, but because they may not be relevant in all configurations, they are commented out in the file by default.</p><p>If you look for PF-related settings in your <span class="emphasis"><em>/etc/rc.conf</em></span> file, you’ll find the setting <code class="literal">pf_rules=</code>. In principle, this lets you specify that your configuration is in a file other than the default <span class="emphasis"><em>/etc/pf.conf</em></span>. However, changing this setting is probably not worth the trouble. Using the default setting lets you take advantage of a number of automatic housekeeping features, such as automatic nightly backup of your configuration to <span class="emphasis"><em>/var/backups</em></span>.</p><p>On OpenBSD, the <span class="emphasis"><em>/etc/rc</em></span> script has a built-in mechanism to help you out if you reboot with either no <span class="emphasis"><em>pf.conf</em></span> file or one that contains an invalid rule set. Before enabling any network interfaces, the <span class="emphasis"><em>rc</em></span> script loads a rule set that allows a few basic services: SSH from anywhere, basic name resolution, and NFS mounts. This allows you to log in and correct any errors in your rule set, load the corrected rule set, and then go on working from there.</p></div><div class="sect2" title="Setting Up PF on FreeBSD"><div class="titlepage"><div><div><h3 class="title" id="setting_up_pf_on_freebsd">Setting Up PF on FreeBSD</h3></div></div></div><p>Good code travels well, and FreeBSD users will tell you that good code from elsewhere tends to find its way into FreeBSD sooner or later. PF is no exception, and from FreeBSD 5.2.1 and the 4.<span class="emphasis"><em>x</em></span> series onward, PF and related tools became part of FreeBSD.</p><p><a class="indexterm" id="iddle1156"/><a class="indexterm" id="iddle1274"/><a class="indexterm" id="iddle1913"/>If you read through the previous section on setting up PF on OpenBSD, you saw that on OpenBSD, PF is enabled by default. That isn’t the case on FreeBSD, where PF is one of three possible packet-filtering options. Here, you need to take explicit steps to enable PF, and compared to OpenBSD, it seems that you need a little more magic in your <span class="emphasis"><em>/etc/rc.conf</em></span>. A look at your <span class="emphasis"><em>/etc/defaults/rc.conf</em></span> file shows that the FreeBSD default values for PF-related settings are as follows:</p><a id="pro_id00008"/><pre class="programlisting">pf_enable="NO"                 # Set to YES to enable packet filter (PF)&#13;
pf_rules="/etc/pf.conf"        # rules definition file for PF&#13;
pf_program="/sbin/pfctl"       # where pfctl lives&#13;
pf_flags=""                    # additional flags for pfctl&#13;
pflog_enable="NO"              # set to YES to enable packet filter logging&#13;
pflog_logfile="/var/log/pflog" # where pflogd should store the logfile&#13;
pflog_program="/sbin/pflogd"   # where pflogd lives&#13;
pflog_flags=""                 # additional flags for pflogd&#13;
pfsync_enable="NO"             # expose pf state to other hosts for syncing&#13;
pfsync_syncdev=""              # interface for pfsync to work through&#13;
pfsync_ifconfig=""             # additional options to ifconfig(8) for pfsync</pre><p>Fortunately, you can safely ignore most of these—at least for now. The following are the only options that you need to add to your <span class="emphasis"><em>/etc/rc.conf</em></span> configuration:</p><a id="pro_id00009"/><pre class="programlisting">pf_enable="YES"       # Enable PF (load module if required)&#13;
pflog_enable="YES"    # start pflogd(8)</pre><p>There are some differences between FreeBSD releases with respect to PF. Refer to the <span class="emphasis"><em>FreeBSD Handbook</em></span> available from <span class="emphasis"><em><a class="ulink" href="http://www.freebsd.org/" target="_top">http://www.freebsd.org/</a></em></span>—specifically the PF section of the “Firewalls” chapter—to see which information applies in your case. The PF code in FreeBSD 9 and 10 is equivalent to the code in OpenBSD 4.5 with some bug fixes. The instructions in this book assume that you’re running FreeBSD 9.0 or newer.</p><p>On FreeBSD, PF is compiled as a kernel-loadable module by default. If your FreeBSD setup runs with a GENERIC kernel, you should be able to start PF with the following:</p><a id="pro_id00010"/><pre class="programlisting">$ <span class="strong"><strong>sudo kldload pf</strong></span>&#13;
$ <span class="strong"><strong>sudo pfctl -e</strong></span></pre><p>Assuming you have put the lines just mentioned in your <span class="emphasis"><em>/etc/rc.conf</em></span> and created an <span class="emphasis"><em>/etc/pf.conf</em></span> file, you could also use the PF <span class="emphasis"><em>rc</em></span> script to run PF. The following enables PF:</p><a id="pro_id00011"/><pre class="programlisting">$ <span class="strong"><strong>sudo /etc/rc.d/pf start</strong></span></pre><p>And this disables the packet filter:</p><a id="pro_id00012"/><pre class="programlisting">$ <span class="strong"><strong>sudo /etc/rc.d/pf stop</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><a class="indexterm" id="iddle1002"/><a class="indexterm" id="iddle1157"/><a class="indexterm" id="iddle1320"/><a class="indexterm" id="iddle1535"/><a class="indexterm" id="iddle1605"/><a class="indexterm" id="iddle1633"/><a class="indexterm" id="iddle1811"/><span class="emphasis"><em>On FreeBSD, the</em></span> /etc/rc.d/pf <span class="emphasis"><em>script requires at least a line in</em></span> /etc/rc.conf <span class="emphasis"><em>that reads <code class="literal">pf_enable="YES"</code> and a valid</em></span> /etc/pf.conf <span class="emphasis"><em>file. If either of these requirements isn’t met, the script will exit with an error message. There is no</em></span> /etc/pf.conf <span class="emphasis"><em>file in a default FreeBSD installation, so you’ll need to create one before you reboot the system with PF enabled. For our purposes, creating an empty</em></span> /etc/pf.conf <span class="emphasis"><em>with <code class="literal">touch</code> will do, but you could also work from a copy of the</em></span> /usr/share/examples/pf/pf.conf <span class="emphasis"><em>file supplied by the system.</em></span></p></div><p>The supplied sample file <span class="emphasis"><em>/usr/share/examples/pf/pf.conf</em></span> contains no active settings. It has only comment lines starting with a <code class="literal">#</code> character and commented-out rules, but it does give you a preview of what a working rule set will look like. For example, if you remove the <code class="literal">#</code> sign before the line that says <code class="literal">set skip on lo</code> to uncomment the line and then save the file as your <span class="emphasis"><em>/etc/pf.conf</em></span>, your loopback interface group will not be filtered once you enable PF and load the rule set. However, even if PF is enabled on your FreeBSD system, we haven’t gotten around to writing an actual rule set, so PF isn’t doing much of anything and all packets will pass.</p><p>As of this writing (August 2014), the FreeBSD <span class="emphasis"><em>rc</em></span> scripts don’t set up a default rule set as a fallback if the configuration read from <span class="emphasis"><em>/etc/pf.conf</em></span> fails to load. This means that enabling PF with no rule set or with <span class="emphasis"><em>pf.conf</em></span> content that is syntactically invalid will leave the packet filter enabled with a default <code class="literal">pass all</code> rule set.</p></div><div class="sect2" title="Setting Up PF on NetBSD"><div class="titlepage"><div><div><h3 class="title" id="setting_up_pf_on_netbsd">Setting Up PF on NetBSD</h3></div></div></div><p>On NetBSD 2.0, PF became available as a loadable kernel module that could be installed via packages (<span class="emphasis"><em>security/pflkm</em></span>) or compiled into a static kernel configuration. In NetBSD 3.0 and later, PF is part of the base system. On NetBSD, PF is one of several possible packet-filtering systems, and you need to take explicit action to enable it.</p><p>Some details of PF configuration have changed between NetBSD releases. This book assumes you are using NetBSD 6.0 or later.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch02fn02" id="ch02fn02">10</a>]</sup></p><p>To use the loadable PF module for NetBSD, add the following lines to your <span class="emphasis"><em>/etc/rc.conf</em></span> to enable loadable kernel modules, PF, and the PF log interface, respectively.</p><a id="pro_id00013"/><pre class="programlisting">lkm="YES" # do load kernel modules&#13;
pf=YES&#13;
pflogd=YES</pre><p>To load the <span class="emphasis"><em>pf</em></span> module manually and enable PF, enter this:</p><a id="pro_id00014"/><pre class="programlisting">$ <span class="strong"><strong>sudo modload /usr/lkm/pf.o</strong></span>&#13;
$ <span class="strong"><strong>sudo pfctl -e</strong></span></pre><p><a class="indexterm" id="iddle1084"/><a class="indexterm" id="iddle1418"/><a class="indexterm" id="iddle1609"/><a class="indexterm" id="iddle1629"/><a class="indexterm" id="iddle1788"/><a class="indexterm" id="iddle1789"/>Alternatively, you can run the <span class="emphasis"><em>rc.d</em></span> scripts to enable PF and logging, as follows:</p><a id="pro_id00015"/><pre class="programlisting">$ <span class="strong"><strong>sudo /etc/rc.d/pf start</strong></span>&#13;
$ <span class="strong"><strong>sudo /etc/rc.d/pflogd start</strong></span></pre><p>To load the module automatically at startup, add the following line to <span class="emphasis"><em>/etc/lkm.conf</em></span>:</p><a id="pro_id00016"/><pre class="programlisting">/usr/lkm/pf.o - - - - BEFORENET</pre><p>If your <span class="emphasis"><em>/usr</em></span> filesystem is on a separate partition, add this line to your <span class="emphasis"><em>/etc/rc.conf</em></span>:</p><a id="pro_id00017"/><pre class="programlisting">critical_filesystems_local="${critical_filesystems_local} /usr"</pre><p>If there are no errors at this point, you have enabled PF on your system, and you’re ready to move on to creating a complete configuration.</p><p>The supplied <span class="emphasis"><em>/etc/pf.conf</em></span> file contains no active settings; it has only comment lines starting with a hash mark (<code class="literal">#</code>) and commented-out rules. However, it does give you a preview of what a working rule set will look like. For example, if you remove the hash mark before the line that says <code class="literal">set skip on lo</code> to uncomment it and then save the file, your loopback interface will not be filtered once you enable PF and load the rule set. However, even if PF is enabled on your NetBSD system, we haven’t gotten around to writing an actual rule set, so PF isn’t doing much of anything but passing packets.</p><p>NetBSD implements a default or fallback rule set via the file <span class="emphasis"><em>/etc/defaults/ pf.boot.conf</em></span>. This rule set is intended only to let your system complete its boot process in case the <span class="emphasis"><em>/etc/pf.conf</em></span> file doesn’t exist or contains an invalid rule set. You can override the default rules by putting your own customizations in <span class="emphasis"><em>/etc/pf.boot.conf</em></span>.</p></div></div><div class="sect1" title="A Simple PF Rule Set: A Single, Stand-Alone Machine"><div class="titlepage"><div><div><h2 class="title" id="simple_pf_rule_set_a_singlecomma_stand-a" style="clear: both">A Simple PF Rule Set: A Single, Stand-Alone Machine</h2></div></div></div><p>Mainly to have a common, minimal baseline, we will start building rule sets from the simplest possible configuration.</p><div class="sect2" title="A Minimal Rule Set"><div class="titlepage"><div><div><h3 class="title" id="minimal_rule_set">A Minimal Rule Set</h3></div></div></div><p>The simplest possible PF setup is on a single machine that will not run any services and talks to only one network, which may be the Internet.</p><p>We’ll begin with an <span class="emphasis"><em>/etc/pf.conf</em></span> file that looks like this:</p><a id="pro_id00018"/><pre class="programlisting">block in all&#13;
pass out all keep state</pre><p><a class="indexterm" id="iddle1417"/><a class="indexterm" id="iddle1419"/><a class="indexterm" id="iddle1784"/><a class="indexterm" id="iddle1901"/>This rule set denies all incoming traffic, allows traffic we send, and retains state information on our connections. PF reads rules from top to bottom; the <span class="emphasis"><em>last</em></span> rule in a rule set that matches a packet or connection is the one that is applied.</p><p>Here, any connection coming into our system from anywhere else will match the <code class="literal">block in all</code> rule. Even with this tentative result, the rule evaluation will continue to the next rule (<code class="literal">pass out all keep state</code>), but the traffic will not even match the first criterion (the <code class="literal">out</code> direction) in this rule. With no more rules to evaluate, the status will not change, and the traffic will be blocked. In a similar manner, any connection initiated from the machine with this rule set will not match the first rule (once again, the wrong direction) but will match the second rule, which is a <code class="literal">pass</code> rule, and the connection is allowed to pass.</p><p>We’ll examine the way that PF evaluates rules and how ordering matters in a bit more detail in <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>, in the context of a slightly longer rule set.</p><p>For any rule that has a <code class="literal">keep state</code> part, PF keeps information about the connection, including various counters and sequence numbers, as an entry in the <span class="emphasis"><em>state table</em></span>. The state table is where PF keeps information about existing connections that have already matched a rule, and new packets that arrive are compared to existing state table entries to find a match first. Only when a packet doesn’t match any existing state will PF move on to a full <span class="emphasis"><em>rule set evaluation</em></span>, checking whether the packet matches a rule in the loaded rule set. We can also instruct PF to act on state information in various ways, but in a simple case like this, our main goal is to allow return traffic for connections we initiate to return to us.</p><p>Note that on OpenBSD 4.1 and later, the default for <code class="literal">pass</code> rules is to keep state information,<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch02fn03" id="ch02fn03">11</a>]</sup> and we no longer need to specify <code class="literal">keep state</code> explicitly in a simple case like this. This means the rule set could be written like this:</p><a id="pro_id00019"/><pre class="programlisting"># minimal rule set, OpenBSD 4.1 onward keeps state by default&#13;
block in all&#13;
pass out all</pre><p>In fact, you could even leave out the <code class="literal">all</code> keyword here if you like.</p><p>The other BSDs have mostly caught up with this change by now, and for the rest of this book, we’ll stick to the newer rules, with an occasional reminder in case you are using an older system.</p><p>It goes pretty much without saying that passing all traffic generated by a specific host implies that the host in question is, in fact, trustworthy. This is something you do only if this is a machine you know you can trust.</p><p><a class="indexterm" id="iddle1162"/><a class="indexterm" id="iddle1208"/><a class="indexterm" id="iddle1330"/><a class="indexterm" id="iddle1435"/><a class="indexterm" id="iddle1472"/><a class="indexterm" id="iddle1473"/><a class="indexterm" id="iddle1630"/><a class="indexterm" id="iddle1790"/><a class="indexterm" id="iddle1791"/><a class="indexterm" id="iddle1798"/>When you’re ready to use this rule set, load it with the following:</p><a id="pro_id00020"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -ef /etc/pf.conf</strong></span></pre><p>The rule set should load without any error messages or warnings. On all but the slowest systems, you should be returned to the <code class="literal">$</code> prompt immediately.</p></div><div class="sect2" title="Testing the Rule Set"><div class="titlepage"><div><div><h3 class="title" id="testing_the_rule_set">Testing the Rule Set</h3></div></div></div><p>It’s always a good idea to test your rule sets to make sure they work as expected. Proper testing will become essential once you move on to more complicated configurations.</p><p>To test the simple rule set, see whether it can perform domain name resolution. For example, you could see whether <code class="literal">$ host nostarch.com</code> returns information, such as the IP address of the host <span class="emphasis"><em>nostarch.com</em></span> and the host-names of that domain’s mail exchangers. Or just see whether you can surf the Web. If you can connect to external websites by name, the rule set allows your system to perform domain name resolution. Basically, any service you try to access from your own system should work, and any service you try to access on your system from another machine should produce a <code class="literal">Connection refused</code> message.</p></div></div><div class="sect1" title="Slightly Stricter: Using Lists and Macros for Readability"><div class="titlepage"><div><div><h2 class="title" id="slightly_stricter_using_lists_and_macros" style="clear: both">Slightly Stricter: Using Lists and Macros for Readability</h2></div></div></div><p>The rule set in the previous section is an extremely simple one—probably too simplistic for practical use. But it’s a useful starting point to build from to create a slightly more structured and complete setup. We’ll start by denying all services and protocols and then allow only those we know that we need,<sup>[<a class="footnote" href="#ftn.ch02fn04" id="ch02fn04">12</a>]</sup> using lists and macros for better readability and control.</p><p>A <span class="emphasis"><em>list</em></span> is simply two or more objects of the same type that you can refer to in a rule set, such as this:</p><a id="pro_id00021"/><pre class="programlisting">pass proto tcp to port { 22 80 443 }</pre><p>Here, <code class="literal">{ 22 80 443 }</code> is a list.</p><p>A <span class="emphasis"><em>macro</em></span> is a pure readability tool. If you have objects that you’ll refer to more than once in your configuration, such as an IP address for an important host, it could be useful to define a macro instead. For example, you might define this macro early in your rule set:</p><a id="pro_id00022"/><pre class="programlisting">external_mail = 192.0.2.12</pre><p><a class="indexterm" id="iddle1080"/><a class="indexterm" id="iddle1476"/><a class="indexterm" id="iddle1793"/>Then you could refer to that host as <code class="literal">$external_mail</code> later in the rule set:</p><a id="pro_id00023"/><pre class="programlisting">pass proto tcp to $external_mail port 25</pre><p>These two techniques have great potential for keeping your rule sets readable, and as such, they are important factors that contribute to the overall goal of keeping you in control of your network.</p><div class="sect2" title="A Stricter Baseline Rule Set"><div class="titlepage"><div><div><h3 class="title" id="stricter_baseline_rule_set">A Stricter Baseline Rule Set</h3></div></div></div><p>Up to this point, we’ve been rather permissive with regard to any traffic we generate ourselves. A permissive rule set can be very useful while we check that basic connectivity is in place or we check whether filtering is part of a problem we’re seeing. Once the “Do we have connectivity?” phase is over, it’s time to start tightening up to create a baseline that keeps us in control.</p><p>To begin, add the following rule to <span class="emphasis"><em>/etc/pf.conf</em></span>:</p><a id="pro_id00024"/><pre class="programlisting">block all</pre><p>This rule is completely restrictive and will block all traffic in all directions. This is the initial baseline filtering rule that we’ll use in all complete rule sets over the next few chapters. We basically start from zero, with a configuration where <span class="emphasis"><em>nothing</em></span> is allowed to pass. Later on, we’ll add rules that cut our traffic more slack, but we’ll do so incrementally and in a way that keeps us firmly in control.</p><p>Next, we’ll define a few macros for later use in the rule set:</p><a id="pro_id00025"/><pre class="programlisting">tcp_services = "{ ssh, smtp, domain, www, pop3, auth, https, pop3s }"&#13;
udp_services = "{ domain }"</pre><p>Here, you can see how the combination of lists and macros can be turned to our advantage. Macros can be lists, and as demonstrated in the example, PF understands rules that use the names of services as well as port numbers, as listed in your <span class="emphasis"><em>/etc/services</em></span> file. We’ll take care to use all these elements and some further readability tricks as we tackle complex situations that require more elaborate rule sets.</p><p>Having defined these macros, we can use them in our rules, which we’ll now edit slightly to look like this:</p><a id="pro_id00026"/><pre class="programlisting">block all&#13;
pass out proto tcp to port $tcp_services&#13;
pass proto udp to port $udp_services</pre><p>The strings <code class="literal">$tcp_services</code> and <code class="literal">$udp_services</code> are macro references. Macros that appear in a rule set are expanded in place when the rule set loads, and the running rule set will have the full lists inserted where the macros are referenced. Depending on the exact nature of the macros, they may cause single rules with macro references to expand into several rules. Even in a small rule set like this, the use of macros makes the rules easier <a class="indexterm" id="iddle1209"/><a class="indexterm" id="iddle1436"/><a class="indexterm" id="iddle1475"/><a class="indexterm" id="iddle1642"/><a class="indexterm" id="iddle1794"/><a class="indexterm" id="iddle1953"/><a class="indexterm" id="iddle2012"/><a class="indexterm" id="iddle2019"/>to grasp and maintain. The amount of information that needs to appear in the rule set shrinks, and with sensible macro names, the logic becomes clearer. To follow the logic in a typical rule set, more often than not, we don’t need to see full lists of IP addresses or port numbers in place of every macro reference.</p><p>From a practical rule set maintenance perspective, it’s important to keep in mind which services to allow on which protocol in order to keep a comfortably tight regime. Keeping separate lists of allowed services according to protocol is likely to be useful in keeping your rule set both functional and readable.</p><div class="sidebar"><a id="tcp_vsdot_udp"/><div class="sidebar-title">TCP vs. UDP</div><p>We’ve taken care to separate out UDP services from TCP services. Several services run primarily on well-known port numbers on either TCP or UDP, and a few alternate between using TCP and UDP according to specific conditions.</p><p>The two protocols are quite different in several respects. TCP is connection oriented and reliable, a perfect candidate for stateful filtering. In contrast, UDP is stateless and connectionless, but PF creates and maintains data equivalent to state information for UDP traffic in order to ensure UDP return traffic is allowed back if it matches an existing state.</p><p>One common example where state information for UDP is useful is when handling name resolution. When you ask a name server to resolve a domain name to an IP address or to resolve an IP address back to a hostname, it’s reasonable to assume that you want to receive the answer. Retaining state information, or the functional equivalent about your UDP traffic, makes this possible.</p></div></div><div class="sect2" title="Reloading the Rule Set and Looking for Errors"><div class="titlepage"><div><div><h3 class="title" id="reloading_the_rule_set_and_looking_for_e">Reloading the Rule Set and Looking for Errors</h3></div></div></div><p>After we’ve changed our <span class="emphasis"><em>pf.conf</em></span> file, we need to load the new rules as follows:</p><a id="pro_id00027"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -f /etc/pf.conf</strong></span></pre><p>If there are no syntax errors, <code class="literal">pfctl</code> shouldn’t display any messages during the rule load.</p><p>If you prefer to display verbose output, use the <code class="literal">-v</code> flag:</p><a id="pro_id00028"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -vf /etc/pf.conf</strong></span></pre><p><a class="indexterm" id="iddle1060"/><a class="indexterm" id="iddle1252"/><a class="indexterm" id="iddle1420"/><a class="indexterm" id="iddle1652"/><a class="indexterm" id="iddle1781"/><a class="indexterm" id="iddle1792"/><a class="indexterm" id="iddle1950"/><a class="indexterm" id="iddle2004"/>When you use verbose mode, <code class="literal">pfctl</code> should expand your macros into their separate rules before returning you to the command-line prompt, as follows:</p><a id="pro_id00029"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -vf /etc/pf.conf</strong></span>&#13;
tcp_services = "{ ssh, smtp, domain, www, pop3, auth, https, pop3s }"&#13;
udp_services = "{ domain }"&#13;
block drop all&#13;
pass out proto tcp from any to any port = ssh flags S/SA keep state&#13;
pass out proto tcp from any to any port = smtp flags S/SA keep state&#13;
pass out proto tcp from any to any port = domain flags S/SA keep state&#13;
pass out proto tcp from any to any port = www flags S/SA keep state&#13;
pass out proto tcp from any to any port = pop3 flags S/SA keep state&#13;
pass out proto tcp from any to any port = auth flags S/SA keep state&#13;
pass out proto tcp from any to any port = https flags S/SA keep state&#13;
pass out proto tcp from any to any port = pop3s flags S/SA keep state&#13;
pass proto udp from any to any port = domain keep state&#13;
$ _</pre><p>Compare this output to the content of the <span class="emphasis"><em>/etc/pf.conf</em></span> file you actually wrote. Our single TCP services rule is expanded into eight different ones: one for each service in the list. The single UDP rule takes care of only one service, and it expands from what we wrote to include the default options. Notice that the rules are displayed in full, with default values such as <code class="literal">flags S/SA keep state</code> applied in place of any options you do not specify explicitly. This is the configuration as it’s actually loaded.</p></div><div class="sect2" title="Checking Your Rules"><div class="titlepage"><div><div><h3 class="title" id="checking_your_rules">Checking Your Rules</h3></div></div></div><p>If you’ve made extensive changes to your rule set, check them before attempting to load the rule set by using the following:</p><a id="pro_id00030"/><pre class="programlisting">$ pfctl -nf /etc/pf.conf</pre><p>The <code class="literal">-n</code> option tells PF to parse the rules only, without loading them—more or less as a dry run and to allow you to review and correct any errors. If <code class="literal">pfctl</code> finds any syntax errors in your rule set, it’ll exit with an error message that points to the line number where the error occurred.</p><p>Some firewall guides advise you to make sure that your old configuration is truly gone, or you’ll run into trouble—your firewall might be in some kind of intermediate state that doesn’t match either the before or after state. That’s simply not true when you’re using PF. The last valid rule set loaded is active until you either disable PF or load a new rule set. <code class="literal">pfctl</code> checks the syntax and then loads your new rule set completely before switching over to the new one. This is often referred to as <span class="emphasis"><em>atomic rule set load</em></span> and means that once a valid rule set has been loaded, there’s no intermediate state with a partial rule set or no rules loaded. One consequence is that traffic that matches states that are valid in both the old and new rule set will not be disrupted.</p><p><a class="indexterm" id="iddle1200"/><a class="indexterm" id="iddle1331"/><a class="indexterm" id="iddle1606"/><a class="indexterm" id="iddle1616"/><a class="indexterm" id="iddle1640"/><a class="indexterm" id="iddle1647"/><a class="indexterm" id="iddle1795"/><a class="indexterm" id="iddle1816"/><a class="indexterm" id="iddle1898"/><a class="indexterm" id="iddle1931"/><a class="indexterm" id="iddle1932"/>Unless you’ve actually followed the advice from some of those old guides and <span class="emphasis"><em>flushed</em></span> your existing rules (that <span class="emphasis"><em>is</em></span> possible, using <code class="literal">pfctl -F all</code> or similar) before attempting to load a new one from your configuration file, the last valid configuration will remain loaded. In fact, flushing the rule set is rarely a good idea because it effectively puts your packet filter in a <code class="literal">pass all</code> mode, which in turn both opens the door to any comers and runs the risk of disrupting useful traffic while you’re getting ready to load your rules.</p></div><div class="sect2" title="Testing the Changed Rule Set"><div class="titlepage"><div><div><h3 class="title" id="testing_the_changed_rule_set">Testing the Changed Rule Set</h3></div></div></div><p>Once you have a rule set that <code class="literal">pfctl</code> loads without any errors, it’s time to see whether the rules you’ve written behave as expected. Testing name resolution with a command such as <code class="literal">$ host nostarch.com</code>, as we did earlier, should still work. However, it’s better to choose a domain you haven’t accessed recently, such as one for a political party you wouldn’t consider voting for, to be sure that you’re not pulling DNS information from the cache.</p><p>You should be able to surf the Web and use several mail-related services, but due to the nature of this updated rule set, attempts to access TCP services other than the ones defined—SSH, SMTP, and so forth—on any remote system should fail. And, as with our simple rule set, your system should refuse all connections that don’t match existing state table entries; only return traffic for connections initiated by this machine will be allowed in.</p></div></div><div class="sect1" title="Displaying Information About Your System"><div class="titlepage"><div><div><h2 class="title" id="displaying_information_about_your_system" style="clear: both">Displaying Information About Your System</h2></div></div></div><p>The tests you’ve performed on your rule sets should have shown that PF is running and that your rules are behaving as expected. There are several ways to keep track of what happens in your running system. One of the more straightforward ways of extracting information about PF is to use the already familiar <code class="literal">pfctl</code> program.</p><p>Once PF is enabled and running, the system updates various counters and statistics in response to network activity. To confirm that PF is running and to view statistics about its activity, you can use <code class="literal">pfctl -s</code>, followed by the type of information you want to display. A long list of information types is available (see <code class="literal">man 8 pfctl</code> and look for the <code class="literal">-s</code> options). We’ll get back to some of those display options in <a class="xref" href="ch09.html" title="Chapter 9. Logging, Monitoring, and Statistics">Chapter 9</a> and go into further detail about some of the statistics they provide in <a class="xref" href="ch10.html" title="Chapter 10. Getting Your Setup Just Right">Chapter 10</a>, when we use the data to optimize the configuration we’re building.</p><p>The following shows an example of just the top part of the output of <code class="literal">pfctl -s info</code> (taken from my home gateway). The high-level information that indicates the system actually passes traffic can be found in this upper part.</p><a id="pro_id00031"/><pre class="programlisting"><span class="strong"><strong>$ sudo pfctl -s info</strong></span>&#13;
Status: Enabled for 24 days 12:11:27                Debug: err&#13;
&#13;
Interface Stats for nfe0               IPv4               IPv6&#13;
  Bytes In                      43846385394                  0&#13;
  Bytes Out                     20023639992                 64&#13;
  Packets In&#13;
    Passed                          49380289                 0&#13;
    Blocked                            49530                 0&#13;
  Packets Out&#13;
    Passed                          45701100                 1&#13;
    Blocked                             1034                 0&#13;
&#13;
State Table                            Total              Rate&#13;
  current entries                        319&#13;
  searches                         178598618            84.3/s&#13;
  inserts                            4965347             2.3/s&#13;
  removals                           4965028             2.3/s</pre><p><a class="indexterm" id="iddle1114"/><a class="indexterm" id="iddle1373"/><a class="indexterm" id="iddle1375"/><a class="indexterm" id="iddle1386"/><a class="indexterm" id="iddle1603"/><a class="indexterm" id="iddle1772"/><a class="indexterm" id="iddle1907"/>The first line of the <code class="literal">pfctl</code> output indicates that PF is enabled and has been running for a little more than three weeks, which is equal to the time since I last performed a system upgrade that required a reboot.</p><p>The <code class="literal">Interface Stats</code> part of the display is an indication that the system’s administrator has chosen one interface (here, <code class="literal">nfe0</code>) as the log interface for the system and shows the bytes in and out handled by the interface. If no log interface has been chosen, the display is slightly different. Now would be a good time to check what output your system produces. The next few items are likely to be more interesting in our context, showing the number of packets blocked or passed in each direction. This is where we find an early indication of whether the filtering rules we wrote are catching any traffic. In this case, either the rule set matches expected traffic well, or we have fairly well-behaved users and guests, with the number of packets passed being overwhelmingly larger than the number of packets blocked in both directions.</p><p>The next important indicator of a working system that’s processing traffic is the block of <code class="literal">State Table</code> statistics. The state table <code class="literal">current entries</code> line shows that there are 319 active states or connections, while the state table has been searched (<code class="literal">searches</code>) for matches to existing states on average a little more than 84 times per second, for a total of just over 178 million times since the counters were reset. The <code class="literal">inserts</code> and <code class="literal">removals</code> counters show the number of times states have been created and removed, respectively. As expected, the number of insertions and removals differs by the number of currently active states, and the rate counters show that for the time since the counters were last reset, the rate of states created and removed matches exactly up to the resolution of this display.</p><p><a class="indexterm" id="iddle1081"/><a class="indexterm" id="iddle1401"/><a class="indexterm" id="iddle1963"/>The information here is roughly in line with the statistics you should expect to see on a gateway for a small network configured for IPv4 only. There’s no reason to be alarmed by the packet passed in the IPv6 column. OpenBSD comes with IPv6 built in. During network interface configuration, by default, the TCP/IP stack sends IPv6 neighbor solicitation requests for the link local address. In a normal IPv4-only configuration, only the first few packets actually pass, and by the time the PF rule set from <span class="emphasis"><em>/etc/ pf.conf</em></span> is fully loaded, IPv6 packets are blocked by the block all default rule. (In this example, they don’t show up in <code class="literal">nfe0</code>’s statistics because IPv6 is tunneled over a different interface.)</p></div><div class="sect1" title="Looking Ahead"><div class="titlepage"><div><div><h2 class="title" id="looking_ahead" style="clear: both">Looking Ahead</h2></div></div></div><p>You should now have a machine that can communicate with other Internet-connected machines, using a very basic rule set that serves as a starting point for controlling your network traffic. As you progress through this book, you’ll learn how to add rules that do various useful things. In <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>, we’ll extend the configuration to act as a gateway for a small network. Serving the needs of several computers has some consequences, and we’ll look at how to let at least some ICMP and UDP traffic through—for your own troubleshooting needs if nothing else.</p><p>In <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>, we’ll also consider network services that have consequences for your security, like FTP. Using packet filtering intelligently to handle services that are demanding, security-wise, is a recurring theme in this book.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch02fn01"><p><sup>[<a class="para" href="#ch02fn01">9</a>] </sup>If you’re setting up your first PF configuration on an OpenBSD version earlier than this, the best advice is to upgrade to the most recent stable version. If for some reason you must stay with the older version, it might be useful to consult the first edition of this book as well as the man pages and other documentation for the specific version you’re using.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch02fn02"><p><sup>[<a class="para" href="#ch02fn02">10</a>] </sup>For instructions on using PF in earlier releases, see the documentation for your release and look up supporting literature listed in <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a> of this book.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch02fn03"><p><sup>[<a class="para" href="#ch02fn03">11</a>] </sup>In fact, the new default corresponds <code class="literal">to keep state flags S/SA</code>, ensuring that only initial SYN packets during connection setup create state, eliminating some puzzling error scenarios. To filter statelessly, you can specify <code class="literal">no state</code> for the rules where you don’t want to record or keep state information. On FreeBSD, OpenBSD 4.1–equivalent PF code was merged into version 7.0. If you’re using a PF version old enough that it does not have this default, it is a very strong indicator that you should consider upgrading your operating system as soon as feasible.</p></div><div class="footnote" id="ftn.ch02fn04"><p><sup>[<a class="para" href="#ch02fn04">12</a>] </sup>Why write the rule set to default deny? The short answer is that it gives you better control. The point of packet filtering is to take control, not to play catch-up with what the bad guys do. Marcus Ranum has written a very entertaining and informative article about this called “The Six Dumbest Ideas in Computer Security” (<span class="emphasis"><em><a class="ulink" href="http://www.ranum.com/security/computer_security/editorials/dumb/index.html" target="_top">http://www.ranum.com/security/computer_security/editorials/dumb/index.html</a></em></span>).</p></div></div></section></body></html>