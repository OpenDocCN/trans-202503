- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Passwords**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of software’s most crucial tasks is the protection of passwords. That may
    be surprising. After all, aren’t passwords part of systems that *provide* protection?
    Don’t passwords secure our accounts with banks, web retailers, and online games?
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, while passwords are the keystones of computer security, they can
    become the targets of attacks. If a remote computer accepts your identity based
    on your password, a process known as *authentication*, it must have a list of
    user passwords to compare against. That password list is a tempting target for
    attackers. Recent years have seen a number of large-scale thefts of customer account
    data. How does this happen, and what can be done to make breaches less likely?
    That’s what this chapter is about.
  prefs: []
  type: TYPE_NORMAL
- en: Before you learn how passwords are protected, though, you’ll see how they are
    transformed into binary numbers, a process that has important implications for
    both password storage and encryption.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transforming a Password into a Number**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch01), you saw how an individual character could be
    replaced by a number from the ASCII table. Here, you’ll see how a string of characters
    can be replaced by one big number, such as the 128-bit key we need for AES. In
    computing, transforming something into a number in a specified range is called
    *hashing*, and the resulting number is called a *hash code*, *hash value*, or
    just plain *hash*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the word *hash* means chopping something up and then cramming the pieces
    back together, as with hash browns. A particular hashing method is known as a
    *hash function*. Hashing a password always begins by converting each character
    in the password to a number using an encoding system such as ASCII. Hash functions
    differ in how they combine those numbers; the hash functions used in encryption
    and authentication systems must be carefully designed or security may be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: '***Properties of Good Hash Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Developing a good hash function is no easy task. To understand what hash functions
    are up against, consider the short password *dog*. That word contains 3 ASCII
    bytes, or a mere 24 bits of data, while an AES key is a minimum of 128 bits. Therefore
    a good hash function must be capable of transforming those 24 bits into a 128-bit
    hash code with the following properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full Use of All Bits**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A major strength of a computer-based encryption system like AES is the *key
    size*, the sheer number of possible keys facing an attacker. This strength disappears,
    however, if all the possible keys aren’t actually being used. A good hash function
    must produce results across the full range of possible hash codes. Even for our
    short *dog* password, all 128 bits of the resulting hash code must be influenced
    by the original 24 bits of the password.
  prefs: []
  type: TYPE_NORMAL
- en: '**No Reversibility**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch01), you learned that an encryption method has to
    be reversible. A good hash function, in contrast, should *not* be reversible.
    I’ll discuss why this is important later in the chapter. For now, know that for
    a given hash code, there should be no direct way to recover a password that produced
    it. I say *a* password and not *the* password because multiple passwords may produce
    the same hash code, which is known as a hash *collision*. Because there are more
    possible passwords than hash codes, collisions are inevitable. A good hash function
    should make it difficult for attackers to find *any* password that produces a
    given hash code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avalanche**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The avalanche property that’s vital to encryption is just as important in hashing.
    Small changes in the password should result in large changes in the hash code—especially
    since many people, when required to choose a new password, choose a slight variation
    of their old one. The hash code produced for *dog* should be very different from
    those produced by similar passwords such as *doge*, *Dog*, or *odg*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The MD5 Hash Function**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Meeting all these criteria is not easy. Good hash functions solve this problem
    in a clever way. They start with a jumble of bits and use the bit patterns of
    the password to modify this jumble further. That’s the method of the widely used
    hash function called *MD5*—the fifth version of the *Message Digest* hash function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Encoding the Password***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get started, MD5 converts the password to a 512-bit block; I’ll call this
    the *encoded password*. The first part of this encoding consists of the ASCII
    codes of the characters in the password. For example, if the password is *BigFunTime*,
    the first character is a *B*, which has an ASCII byte of 01000010, so the first
    8 bits of the encoded password are 01000010; the next 8 bits are the byte for
    *i*, which is 01101001; and so on. Thus, the 10 letters in our sample *BigFunTime*
    password will take up 80 bits out of 512.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the rest of the bits have to be filled up. The next bit is set to 1, and
    all the bits up to the last 64 are set to 0\. The final 64 bits store a binary
    representation of the length, in bits, of the original password. In this case,
    the password is 10 characters, or 80 bits, long. The 64-bit binary representation
    of 80 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, we don’t need 64 bits to store the length of a password. Using 64 bits
    for the length allows MD5 to hash inputs of arbitrary length—the benefit of which
    we’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.html#ch2fig1) shows the encoding of the sample password,
    organized into 16 numbered rows of 32 bits each.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: The password* BigFunTime *transformed into the 512 bits used as
    input to the MD5 hash function*'
  prefs: []
  type: TYPE_NORMAL
- en: This encoded password is full of zeros and therefore doesn’t meet the “fully
    uses all the bits” property of a good function, but that’s okay because this is
    not the hash code; it’s just the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '***Bitwise Operations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The MD5 hash function uses a few operations I haven’t discussed before. Let’s
    go through these briefly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary Addition**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first new operation is *binary addition*. Binary addition is much like
    the decimal addition you already know but with binary numbers. For example, the
    32-bit representation of the number 5 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The 32-bit representation of 46 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add 5 and 46 together, the result is 51\. Likewise, the addition of those
    two binary representations results in the binary representation of 51:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unlike normal addition, though, where sometimes the result has more digits than
    the operands, in binary addition the number of bits is fixed. If the result of
    adding two 32-bit binary numbers is greater than 32 bits, we ignore the “carry”
    at the left side of the result and keep only the 32 bits on the right. It’s like
    working with a cheap calculator that has just a two-digit display, so when you
    add 75 and 49, instead of displaying 124, it displays only the last two digits,
    24.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise NOT**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next new operation is called “not,” often written in all uppercase as *NOT*.
    As demonstrated in [Figure 2-2](ch02.html#ch2fig2), NOT “flips” all of the bits,
    replacing each 1 with a 0 and each 0 with a 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: The bitwise NOT operation. All bits are inverted. The 1 bits are
    highlighted for clarity.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise OR**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Up next is *OR*, sometimes called *inclusive-OR* to distinguish it from the
    exclusive-or (XOR) that you saw in [Chapter 1](ch01.html#ch01). The OR operation
    lines up two binary numbers with the same number of bits. In each position of
    the resulting binary number, you get a 1 if there’s a 1 in the first number *or*
    in the second number; otherwise, you get a 0, as shown in [Figure 2-3](ch02.html#ch2fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: The bitwise OR operation. Bit positions are 1 in the result if
    they are 1 in either of the two inputs*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that unlike XOR, you can’t apply OR twice and get the original byte back.
    It’s a one-way trip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise AND**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last of the new operations is *AND*. Two binary numbers are aligned, and
    in each position, the result is 1 wherever both bits are 1 in that position; otherwise,
    the result is 0\. So a 1 in the result means there was a 1 in that position in
    the first number *and* the second number, as seen in [Figure 2-4](ch02.html#ch2fig4).
    As with OR, the AND operation isn’t reversible.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The bitwise AND operation. Bit positions are 1 in the result if
    they are 1 in both of the two inputs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***MD5 Hashing Rounds***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’re ready for some hashing. Pieces of the encoded password make only brief
    appearances in the MD5 process, but those appearances make all the difference.
    The MD5 process always starts with the same 128 bits, conceptually split into
    four 32-bit sections, labeled A through D, as shown in [Figure 2-5](ch02.html#ch2fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: The starting configuration of the 128 bits of an MD5 hash code*'
  prefs: []
  type: TYPE_NORMAL
- en: From here, it’s all about shifting these bits around and flipping them, in a
    process that repeats a whopping 64 times. In this respect, the process is a lot
    like AES but with even more rounds. [Figure 2-6](ch02.html#ch2fig6) is a broad
    diagram of one of the 64 rounds.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: One round of the MD5 hash function. In the result, three of the
    sections are transposed, while all four sections are combined to make a new section.*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown, sections B, C, and D are simply transposed, so that the D section
    of one round becomes the A section of the next. The main action of MD5 occurs
    in the “extra scrambling” of each round, which creates a new section from the
    bits of all four sections of the previous round. The extra scrambling uses the
    irreversible operations AND, OR, and NOT to combine the bits of all four sections
    with one of the rows of the encoded password. Different rows of the encoded password
    are used in different rounds, so that eventually all the rows of the encoded password
    are used multiple times. Because of the transposition, the process needs just
    four rounds to replace each of the four original sections with the result of the
    extra scrambling. After the complete 64-round process, the original bits of the
    sections will have been thoroughly sifted together with the encoded password.
  prefs: []
  type: TYPE_NORMAL
- en: '***Meeting the Criteria of a Good Hash Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because MD5 starts with an assortment of bits, then alters these bits over and
    over, adding in pieces of the encoded password, we can be sure that all the bits
    are affected along the way, giving us a true 128-bit hash code. The sheer number
    of operations that are irreversible—and remember, the actions described occur
    64 times—means the hash function as a whole is not reversible. This rotation and
    alteration of the bits in the “extra scrambling” each round, combined with the
    rotation of the sections themselves, distribute the bits and bytes and create
    the desired avalanche.
  prefs: []
  type: TYPE_NORMAL
- en: MD5 meets all the baseline requirements for a good hash function. It does have
    a few subtle weaknesses, however, as you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hash functions serve other purposes in security besides creating keys from passwords.
    One of the most important is the creation of file *signatures*. As stated earlier,
    MD5 can process any size of input. If the input is larger than 512 bits, it’s
    first divided into multiple 512-bit blocks. The MD5 process is then applied once
    per block. The first block starts with the initial 128 bits and each subsequent
    block starts with the hash code produced by the previous block. In this way, we
    could run the entire text of this book, an audio file, a video, or any other digital
    file through the function and get a single 128-bit hash code in return. This hash
    code would become the file’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does a file need a signature? Suppose you have decided to download FreeWrite,
    a (fictional) freeware word processor application. You’re wary, though, because
    of a bad experience in which you downloaded a freeware program that turned out
    to be bogus and riddled with malware. To avoid this, you want to be sure the FreeWrite
    file that you download is the same file that the developers uploaded. The developers
    could hash the file with MD5 and post the resulting hash code—the file signature—on
    their website, [freewrite.com](http://freewrite.com). This allows you to run the
    file through an MD5 hash program and compare the result to the code on the developer
    site. If the new result doesn’t match the signature, something has changed: the
    file, the signature, or both.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Problem of Identity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, matching the posted hash code proves the FreeWrite file is legitimate
    only if the hash code was actually published by the developers. But what if an
    attacker copies the developer’s [freewrite.com](http://freewrite.com) site to
    a similarly named domain like [free-write.com](http://free-write.com), and then
    posts a compromised file along with the hash of that compromised file? A digital
    signature is only as trustworthy as its provider. We’ll explore this problem in
    further detail in [Chapter 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: '***Collision Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even with a matching hash code from a legitimate source, though, a file might
    be trouble. Many different files will produce the same hash code, which means
    an attacker trying to modify a file for nefarious purposes can avoid detection
    if the new, modified file produces the same hash code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not too difficult to produce two files with the same hash code, which
    is known as a *collision attack*: just randomly generate files until two hash
    codes match. Finding a second file to match the *particular* hash code of another
    file is much harder. To be of any real use to an attacker, the file with the matching
    code can’t be a bunch of random bytes; it has to be a program that does something
    malicious on the attacker’s behalf.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are methods to produce a second file with the same MD5
    code that is very similar to the first file. The discovery of this flaw in the
    MD5 hash function has led researchers to suggest that other hash functions be
    used for signatures. These more advanced hash functions usually have longer hash
    codes (up to 512 bits), more hashing rounds, and more complicated binary math
    during each round. As with encryption, though, there are no guarantees that flaws
    won’t be discovered in the more complicated hash functions as well. Proper use
    of signatures means staying one step ahead of known design flaws because attackers
    will exploit flaws mercilessly. Digital security is a cat-and-mouse game in which
    the good guys are the mice, trying to avoid being eaten, never able to defeat
    the cats, and only hoping to stay alive a little longer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passwords in Authentication Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowhere is this cat-and-mouse game more evident than in authentication systems.
    Every place where you enter your password has to have a list of passwords to compare
    against, and properly securing the list requires great care.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Dangers of Password Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the most straightforward way passwords could be stored in a table.
    In this example, Northeast Money Bank (NEMB) stores the username and password
    of each of its customers, along with the account number and current balance. An
    excerpt from the password table is shown in [Table 2-1](ch02.html#ch2tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Poorly Designed Password Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Password** | **Account number** | **Balance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| richguy22 | ilikemoney | 21647365 | $27.21 |'
  prefs: []
  type: TYPE_TB
- en: '| mrgutman | falcon | 32846519 | $10,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| squire | yes90125 | 70023193 | $145,398.44 |'
  prefs: []
  type: TYPE_TB
- en: '| burgomeister78 | taco999 | 74766333 | $732.23 |'
  prefs: []
  type: TYPE_TB
- en: Just as Kerckhoffs’s principle says we can’t rely on encryption methods remaining
    secret, we shouldn’t rely on the password list remaining a secret, either. A disgruntled
    employee in the NEMB information technology department might easily acquire the
    file containing the list, or determined attackers on the outside might worm their
    way through the company defenses.
  prefs: []
  type: TYPE_NORMAL
- en: This is what’s known as a *single point of defense*, meaning that once anyone
    lays eyes on this table, the game is over. First, this table shows the account
    numbers and balances of all of the customers, so at the very least, that’s a major
    loss of privacy. What’s even worse is that each password is stored in the form
    entered by the user. Accessing this password list will allow attackers to log
    on as any customer—a disaster in the making.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the problems with this storage system are easily remedied. Knowing
    that, and knowing how dangerous the system is, you would think that it would never
    be used. Sadly, you would be wrong. Real companies are storing user passwords
    just like this. Some extremely large companies that probably spent a great deal
    of money on their websites have been caught following this practice.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hashing Passwords***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If [Table 2-1](ch02.html#ch2tab1) shows the wrong thing to do, what’s the right
    thing to do? One improvement is leaving the password out of the table and instead
    storing the hash code of the password, as shown by [Table 2-2](ch02.html#ch2tab2).
    (In the examples that follow, I show hash codes as decimal numbers to keep their
    length manageable.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Password Table with Hashed Passwords'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Hash of password** | **Account number** | **Balance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| richguy22 | 330,711,060,038,684,200,901,827,278,633,002,791,087 | 21647365
    | $27.21 |'
  prefs: []
  type: TYPE_TB
- en: '| mrgutman | 332,375,033,828,033,552,423,319,316,163,101,084,850 | 32846519
    | $10,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| squire | 295,149,488,455,763,164,542,524,060,437,757,020,453 | 70023193 |
    $145,398.44 |'
  prefs: []
  type: TYPE_TB
- en: '| burgomeister78 | 133,039,589,388,270,767,475,032,770,360,311,206,892 | 74766333
    | $732.23 |'
  prefs: []
  type: TYPE_TB
- en: When a user tries to log in, the submitted password is hashed and the result
    compared to the stored hash code. If they match, the user is logged in. Because
    the hash function isn’t reversible, getting access to the table isn’t the same
    as getting access to the passwords. An attacker can’t log on to an account with
    the hash code.
  prefs: []
  type: TYPE_NORMAL
- en: The account number and balance are still stored as plaintext, though, and it
    would be a good idea to encrypt them, making a table with only hash codes and
    ciphertext. The problem is if we used the hash of the password as our cipher key,
    then encrypting the data provides no additional protection because anyone who
    acquires this table will be able to decrypt the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to solve this problem. One solution is to use one hash
    function to transform the password for authentication and another hash function
    to transform the password into a cipher key to encrypt the account number and
    balance. As long as the hash functions are not reversible, this solution would
    provide security for the account data even if an attacker got access to the table.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionary Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hashing the passwords is a good defense against attackers, but it’s not enough.
    Authentication systems are still vulnerable to *dictionary attacks*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a basic dictionary attack, the attacker has no access to the password table
    and must guess the password. The attacker could just try random jumbles of characters
    but will have much more success with a *dictionary*, which in the world of software
    is simply a list of words. In this case, the dictionary is a list of the most
    common passwords, and it begins something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: • password
  prefs: []
  type: TYPE_NORMAL
- en: • 123456
  prefs: []
  type: TYPE_NORMAL
- en: • football
  prefs: []
  type: TYPE_NORMAL
- en: • mypassword
  prefs: []
  type: TYPE_NORMAL
- en: • abcdef
  prefs: []
  type: TYPE_NORMAL
- en: To foil the basic dictionary attack, most sites count the number of failed logins
    and, after a certain number (perhaps as few as three), temporarily prevent further
    login attempts from a particular computer. This renders the attack impractical
    by increasing the time required to find the right password.
  prefs: []
  type: TYPE_NORMAL
- en: A different form of dictionary attack is used when an attacker has acquired
    a copy of a hashed and encrypted password table. In this case, the attacker hashes
    each password in the dictionary and compares it to each of the hash codes in the
    stolen table. When a match is discovered, the attacker knows the password that
    generates that user’s hash code. To save time, the attacker can run all the passwords
    in the dictionary through a selected hash function once and store the results
    in a dictionary like in [Table 2-3](ch02.html#ch2tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Dictionary with Hash Codes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Password** | **MD5 hash code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| password | 126,680,608,771,750,945,340,162,210,354,335,764,377 |'
  prefs: []
  type: TYPE_TB
- en: '| 123456 | 299,132,688,689,127,175,738,334,524,183,350,839,358 |'
  prefs: []
  type: TYPE_TB
- en: '| football | 74,046,754,153,250,065,911,729,167,268,259,247,040 |'
  prefs: []
  type: TYPE_TB
- en: '| mypassword | 69,792,856,232,803,413,714,004,936,714,872,372,804 |'
  prefs: []
  type: TYPE_TB
- en: '| abcdef | 308,439,634,705,511,765,949,277,356,614,095,247,246 |'
  prefs: []
  type: TYPE_TB
- en: Dictionaries demonstrate why it is important for users to choose passwords that
    aren’t obvious. The more obscure a password, the less likely it will be in an
    attacker’s dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hash Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, an attacker can dispense with the dictionary altogether and build
    a table of randomly generated passwords and their corresponding hash codes, which
    I’ll call a *precomputed hash table*. Of course, the number of potential passwords
    is enormous, so if the attacker wants a decent chance of getting a match, the
    hash table needs to be huge. Building a precomputed hash table takes a lot of
    computing power and time, but it only has to be built once, and then it can be
    used over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: One weakness of the table is that its sheer size can make searching for a match
    extremely slow. When you consider how fast a word processor can find a particular
    word in a large document, this may seem surprising, but these precomputed tables
    are much larger than any file on your computer. Suppose an attacker has a table
    of all passwords composed of 10 or fewer uppercase and lowercase letters and digits.
    Even with these restrictions, the number of potential passwords is 62^(10), which
    is 839,299,365,868,340,224\. The precomputed hash table won’t need every one of
    these potential passwords as entries, but it would need to have a sizable fraction.
    The table would be so large, though, it couldn’t fit in a computer’s internal
    memory. It couldn’t even fit on a hard drive—or just to get to the point, it’s
    so big it might need to be split across a million hard drives. And that’s just
    the storage problem. Unless you have the distributed computing power of Google,
    it’s not practical to search a table that large. (And searching a huge mass of
    data isn’t easy even for Google; we’ll explore searching in detail in [Chapter
    7](ch07.html#ch07).)
  prefs: []
  type: TYPE_NORMAL
- en: '***Hash Chaining***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because a precomputed hash table is too large to store and search, attackers
    use a clever technique called *hash chaining* to drastically reduce the number
    of entries in the table without reducing its effectiveness. This technique uses
    a different type of function called a *reduction function* that does the same
    sorts of mathematical gyrations as a hash function but with the opposite purpose.
    Instead of creating a hash code from a password, it creates a password from a
    hash code—not the password that produced the hash, but simply a sequence of characters
    with the form of a valid password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of hash chaining. When *glopp26taz* is hashed using MD5,
    it produces this hash code:'
  prefs: []
  type: TYPE_NORMAL
- en: 22,964,925,579,257,552,835,515,378,304,344,866,835
  prefs: []
  type: TYPE_NORMAL
- en: A reduction function transforms this hash code into another valid password,
    say, *7HGupp2tss*. This, in turn, is sent through the hash function, producing
    another hash code, which is sent through the reduction function to generate another
    password, and so on. An alternating series of passwords and hash codes, such as
    that shown in [Figure 2-7](ch02.html#ch2fig7), is a *hash chain*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: In a hash chain, a hash function (H) alternates with a reduction
    function (R) that produces an arbitrary password from a hash code.*'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a table of passwords and hash codes, the attacker generates a series
    of hash chains, each of the same length, storing only the first and last links
    of each chain. The chain in [Figure 2-7](ch02.html#ch2fig7) is shown as the third
    entry in [Table 2-4](ch02.html#ch2tab4). This table has 5 entries, but each entry
    is a chain of 3 password/hash pairs, making this the equivalent of a plain table
    of 15 entries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** Hash Chain Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Start** | **End** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sop3H4Yzai | 302,796,960,148,170,554,741,517,711,430,674,339,836 |'
  prefs: []
  type: TYPE_TB
- en: '| 5jhfHTeu4y | 333,226,570,587,833,594,170,987,787,116,324,792,461 |'
  prefs: []
  type: TYPE_TB
- en: '| glopp26taz | 33,218,269,111,507,728,124,938,049,521,416,301,013 |'
  prefs: []
  type: TYPE_TB
- en: '| YYhs9j2a22 | 145,483,602,575,738,705,325,298,600,400,764,586,970 |'
  prefs: []
  type: TYPE_TB
- en: '| Pr2u912mn1 | 737,08,819,301,203,417,973,443,363,267,460,459,460 |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 2-8](ch02.html#ch2fig8) shows an example of using the table. Our attacker
    is trying to recover the password for the target hash code 117,182,660,124,686,473,
    413,705,332,853,526,309,255\. The attacker must determine which chain in the table,
    if any, contains the target hash code. First, the target code is compared against
    every number in the End column of the table. In this case, no match is found,
    so the attacker runs the target hash code through the reduction function to make
    a new password, runs that result through the hashing function, and then searches
    for this new hash code in the End column of the table. This process will continue
    until a match is found, or after the process is run three times (the length of
    the chains in this table).'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the initial target hash value is reduced to the password *pRh7T63y*,
    which, in turn, is hashed, and this new hash value appears in the third entry
    of the table, in the chain with the starting password *glopp26taz*. That identifies
    the hash chain in which the target password may appear, but the attacker must
    obtain the password by iterating through this chain. The starting password in
    that chain is hashed; the resulting hash value is not a match for the initial
    hash value, so it is reduced to a new password, *7HGupp2tss*, and hashed again.
    This hash code *does* match, which means *7HGupp2tss* is the password.
  prefs: []
  type: TYPE_NORMAL
- en: Hash code chains dramatically shrink the table while still providing the same
    amount of searchable data. For example, if a chain has 100 passwords and 100 hash
    codes, then the password matching any of those hash codes can be indirectly retrieved
    using that chain, even though the chain has only one password and hash code in
    the table. Therefore, a table with chains that long has the power of a regular
    precomputed hash table 100 times larger.
  prefs: []
  type: TYPE_NORMAL
- en: There are some potential snags, though. For one, searching takes more computational
    effort with hash chains. Also, because of collisions—multiple passwords that produce
    the same hash code—a matching chain doesn’t necessarily contain the searched-for
    hash code and its matching password, a problem known as *chain merging*. These
    are small consolations for those of us worried about our data security, however.
    There are methods for reducing the chain merging problem, but even without them,
    it’s clear that effective precomputed tables can be made for particular hash functions,
    rendering the passwords that use them vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Using a hash chain table to find a password that produces a particular
    hash code. Neither the password nor the hash code is listed in the table.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Iterative Hashing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One way to thwart the creation of precomputed hash tables is to apply the hash
    function more than once. Because the output of a hash function can itself be hashed,
    the original password can pass through the same hash function any number of times.
    This technique, unhelpfully, is also known as *hash chaining*, but to avoid confusion,
    I will refer to it as *iterative hashing*. [Figure 2-9](ch02.html#ch2fig9) shows
    a five-deep iterative hashing of the password *football*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f02-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: Applying a hash function repeatedly*'
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, passwords are repeatedly hashed when the password is stored
    and when the user logs in. To thwart this, the attacker has to produce a table
    based on the same idea, running the chosen hash code function the same number
    of times. From Kerchkoffs’s principle, we know that cryptographic systems shouldn’t
    depend on keeping their methods secret. The goal of iterative hashing isn’t to
    disguise how many times the password is hashed, but to make the creation of the
    attacker’s precomputed hash table as difficult as possible. In the example, the
    password runs through the hash function five times. That would multiply the time
    needed to create the attacker’s table by five as well. In real-world use, passwords
    can be run through hash functions hundreds or thousands of times. Is this enough
    to prevent the creation of useful precomputed hash tables? Maybe. Computers get
    faster every day. For the most part, this is wonderful, but the downside to ever-increasing
    computational power is that it keeps pushing the boundary of practical limitations,
    and so much of our information security is based on these practical limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Someone setting up a password system based on iterative hashing has to choose
    the number of iterations. It’s fairly easy to choose a number that provides good
    security today. What’s difficult is predicting the number of iterations required
    a year from now, or 2 years, or 10.
  prefs: []
  type: TYPE_NORMAL
- en: You might think the best choice is some impossibly large number to guard against
    the power of future computers. The problem is that today’s computers would have
    real trouble processing legitimate logins. Would you be willing to wait five minutes
    to access one of your online accounts?
  prefs: []
  type: TYPE_NORMAL
- en: '***Salting Passwords***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Authentication systems need a way to strengthen hashing without a performance-crushing
    number of hash iterations; that is, they need a method of storing passwords that
    requires an impractical time investment from attackers without creating an equally
    unrealistic time burden on legitimate access. That method is called *salt*. Salt
    is an apt term for this concept, and I commend whoever came up with it. In culinary
    usage, a pinch of salt profoundly changes the flavor of a dish. In cryptography,
    a small quantity of salt sprinkled on a password dramatically changes its hash
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works: when a new user signs up for an account and selects a
    username and password, the system automatically generates the salt for that account.
    The salt is a string of characters, like a short, random password, that is combined
    with the user’s password before hashing. For example, user *mrgutman* chooses
    *falcon* as his password, and the system generates *h38T2* as the salt.'
  prefs: []
  type: TYPE_NORMAL
- en: The salt and password can be combined in various ways, but the simplest is appending
    the salt to the end of the password, resulting in *falconh38T2* in this example.
    This combination is then hashed, and the hash code stored in the authentication
    table along with the username and the salt, as shown in [Table 2-5](ch02.html#ch2tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-5:** Password Table Using Salt'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Salt** | **Hash of password + salt** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| richguy22 | 7Pmnq | 106,736,954,704,360,738,602,545,963,558,770,944,412 |'
  prefs: []
  type: TYPE_TB
- en: '| mrgutman | h38T2 | 142,858,562,082,404,032,402,440,010,972,328,251,653 |'
  prefs: []
  type: TYPE_TB
- en: '| squire | 93ndy | 122,446,997,766,728,224,659,318,737,810,478,984,316 |'
  prefs: []
  type: TYPE_TB
- en: '| burgomeister78 | HuOw2 | 64,383,697,378,169,783,622,186,691,431,070,835,777
    |'
  prefs: []
  type: TYPE_TB
- en: Each time a user requests access, the salt is added to the end of the entered
    password before hashing. An attacker who acquires a copy of this authentication
    table can’t get much use out of a precomputed hash table. Although the table might
    have a password that hashes to the given code, that password won’t produce the
    right code when combined with the salt. Instead, the attacker would need to create
    a table for a specific salt. That could be done, but remember that the salt is
    randomly chosen. If there are, say, 100,000 users in a stolen authentication table,
    and the salts are numerous enough that no salt is duplicated in the table, the
    attacker will need to create 100,000 tables. At this point, we can’t even call
    them precomputed tables because the attacker is creating them for each attack.
  prefs: []
  type: TYPE_NORMAL
- en: '***Are Password Tables Safe?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Salting and iterative hashing are typically used together, creating real headaches
    for an attacker. Iterative hashing increases the time requirement for creating
    a single precomputed hash table, and salting means an attacker has to make a multitude
    of tables. But is this combination enough?
  prefs: []
  type: TYPE_NORMAL
- en: There is no definitive answer to that question. Cryptography researchers and
    security experts continue to develop new defenses against unauthorized access.
    At the same time, though, attackers continue to find new methods to penetrate
    defenses. Advances in computational power and programming theory help whichever
    side takes advantage of them first.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important lesson of this discussion is that security is often
    out of the user’s hands. There will always be vulnerabilities, but there’s no
    way for a user to know if a particular site or service is employing the best security
    practices. The salt technique, for example, benefits only systems that use it,
    and not every system does.
  prefs: []
  type: TYPE_NORMAL
- en: '**Password Storage Services**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That’s how passwords are stored on remote authentication systems. What about
    on the user end? How do we safely store our passwords?
  prefs: []
  type: TYPE_NORMAL
- en: A long time ago, I had so few passwords that I could safely entrust them to
    my memory, but eventually I knew I had to store passwords outside of my head.
    Writing the passwords on a piece of paper, though, is just a different kind of
    security liability. For a while, I had an elaborate homebrew solution involving
    a *.txt* file encrypted with AES and stored on a memory card that was kept in
    a metal box that was probably not 100 percent fireproof. This arrangement worked,
    except that every time I needed to look up a password, I had to go to the box,
    get the memory card, slot it into my computer, double-click the file, type the
    password (the one password I had to remember), and find the desired entry in my
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually I threw in the towel and signed up for a web-based password storage
    service. When I created an account with the service, I chose a master password.
    I then stored all my other passwords and usernames on this website. This information
    is stored in a way that renders it of little use to anyone who gains access to
    the raw data, so if my password at Amazon is *chickenfat* (it isn’t), then the
    word *chickenfat* isn’t stored anywhere on the password storage server. Instead,
    the passwords are encrypted by a program on my browser before being sent to the
    password storage site, using my chosen master password to generate the encryption
    key. Therefore, even if the server were breached, the attacker wouldn’t be able
    to retrieve my individual passwords without the master password.
  prefs: []
  type: TYPE_NORMAL
- en: The master password itself is not stored on the password storage site, either.
    When the encryption key is needed to encrypt or decrypt an individual login, the
    master password is salted and then hashed repeatedly, for as many iterations as
    I specify.
  prefs: []
  type: TYPE_NORMAL
- en: Although using a password storage service puts all of my eggs in one basket,
    so to speak, this frees me to use best practices for individual logins. Whereas
    previously I might have created passwords that were collages of words and numbers
    I thought I could remember, now my passwords are lengthy random jumbles. And they
    are all different because I no longer need to remember them all.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Final Thought**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all of this talk about authentication systems, I’ve avoided a crucial detail.
    Authentication systems compare stored user passwords to passwords provided during
    logons, but how does the remote computer doing the authentication get the users’
    chosen passwords in the first place? Secure transmission requires encryption,
    which implies the users would have had to encrypt the passwords—but how could
    the remote system decrypt the encrypted passwords without having the passwords
    already? This brings us back to the shared key problem—none of what we talked
    about in this chapter can work unless that problem is solved. So that’s what we’ll
    do next.
  prefs: []
  type: TYPE_NORMAL
