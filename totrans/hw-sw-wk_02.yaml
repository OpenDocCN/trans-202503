- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**Passwords**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: One of software’s most crucial tasks is the protection of passwords. That may
    be surprising. After all, aren’t passwords part of systems that *provide* protection?
    Don’t passwords secure our accounts with banks, web retailers, and online games?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件最重要的任务之一就是保护密码。这可能让人吃惊。毕竟，密码不就是用来*提供*保护的吗？难道密码不保护我们的银行账户、网上零售商和在线游戏账户吗？
- en: The truth is, while passwords are the keystones of computer security, they can
    become the targets of attacks. If a remote computer accepts your identity based
    on your password, a process known as *authentication*, it must have a list of
    user passwords to compare against. That password list is a tempting target for
    attackers. Recent years have seen a number of large-scale thefts of customer account
    data. How does this happen, and what can be done to make breaches less likely?
    That’s what this chapter is about.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尽管密码是计算机安全的基石，但它们也可能成为攻击的目标。如果远程计算机根据密码接受你的身份验证，这个过程被称为*身份验证*，它必须拥有一个用户密码列表来进行比对。这个密码列表成为攻击者诱人的目标。近年来，出现了许多大规模的客户账户数据盗窃事件。到底是怎么发生的，怎样才能减少此类漏洞发生的可能性？这就是本章所探讨的内容。
- en: Before you learn how passwords are protected, though, you’ll see how they are
    transformed into binary numbers, a process that has important implications for
    both password storage and encryption.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你了解密码是如何被保护的之前，你将看到它们是如何被转换为二进制数字的，这个过程对于密码存储和加密都有重要影响。
- en: '**Transforming a Password into a Number**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将密码转换为数字**'
- en: In [Chapter 1](ch01.html#ch01), you saw how an individual character could be
    replaced by a number from the ASCII table. Here, you’ll see how a string of characters
    can be replaced by one big number, such as the 128-bit key we need for AES. In
    computing, transforming something into a number in a specified range is called
    *hashing*, and the resulting number is called a *hash code*, *hash value*, or
    just plain *hash*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，你看到如何将一个单独的字符替换为来自ASCII表的数字。在这里，你将看到如何将一串字符替换为一个大数字，例如我们在AES中需要的128位密钥。在计算机中，将某物转换为一个指定范围内的数字被称为*哈希*，而生成的数字称为*哈希值*、*哈希码*，或者简称*哈希*。
- en: Here, the word *hash* means chopping something up and then cramming the pieces
    back together, as with hash browns. A particular hashing method is known as a
    *hash function*. Hashing a password always begins by converting each character
    in the password to a number using an encoding system such as ASCII. Hash functions
    differ in how they combine those numbers; the hash functions used in encryption
    and authentication systems must be carefully designed or security may be compromised.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*哈希*一词意味着将某物切碎后再将这些碎片重新组合在一起，就像做哈希土豆一样。一个特定的哈希方法被称为*哈希函数*。哈希密码总是从将密码中的每个字符转换为数字开始，使用如ASCII这样的编码系统。哈希函数在如何组合这些数字上有所不同；用于加密和身份验证系统的哈希函数必须经过精心设计，否则安全性可能会受到威胁。
- en: '***Properties of Good Hash Functions***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优秀哈希函数的特性***'
- en: Developing a good hash function is no easy task. To understand what hash functions
    are up against, consider the short password *dog*. That word contains 3 ASCII
    bytes, or a mere 24 bits of data, while an AES key is a minimum of 128 bits. Therefore
    a good hash function must be capable of transforming those 24 bits into a 128-bit
    hash code with the following properties.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个好的哈希函数并非易事。为了理解哈希函数面临的挑战，可以考虑一个简单的密码*dog*。这个单词包含3个ASCII字节，或者仅仅24位数据，而AES密钥至少有128位。因此，一个好的哈希函数必须能够将这24位数据转换成一个128位的哈希码，并具有以下特性。
- en: '**Full Use of All Bits**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**充分利用所有位**'
- en: A major strength of a computer-based encryption system like AES is the *key
    size*, the sheer number of possible keys facing an attacker. This strength disappears,
    however, if all the possible keys aren’t actually being used. A good hash function
    must produce results across the full range of possible hash codes. Even for our
    short *dog* password, all 128 bits of the resulting hash code must be influenced
    by the original 24 bits of the password.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像AES这样的基于计算机的加密系统的一个主要优点是*密钥长度*，即攻击者面对的可能密钥的数量。然而，如果所有可能的密钥实际上并未被使用，这一优点就会消失。一个好的哈希函数必须在所有可能的哈希码范围内产生结果。即使是我们的短密码*dog*，生成的128位哈希码的所有位也必须受到原始24位密码的影响。
- en: '**No Reversibility**'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**不可逆性**'
- en: In [Chapter 1](ch01.html#ch01), you learned that an encryption method has to
    be reversible. A good hash function, in contrast, should *not* be reversible.
    I’ll discuss why this is important later in the chapter. For now, know that for
    a given hash code, there should be no direct way to recover a password that produced
    it. I say *a* password and not *the* password because multiple passwords may produce
    the same hash code, which is known as a hash *collision*. Because there are more
    possible passwords than hash codes, collisions are inevitable. A good hash function
    should make it difficult for attackers to find *any* password that produces a
    given hash code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，你学到了一种加密方法必须是可逆的。相比之下，一个好的哈希函数**不应**是可逆的。我将在本章稍后讨论为什么这一点很重要。现在，要知道，对于给定的哈希值，不应该有直接的方式恢复生成它的密码。我说是**一个**密码而不是**这个**密码，因为多个密码可能会生成相同的哈希值，这种现象称为哈希**碰撞**。由于可能的密码比哈希值更多，因此碰撞是不可避免的。一个好的哈希函数应该使得攻击者很难找到生成特定哈希值的**任何**密码。
- en: '**Avalanche**'
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**雪崩效应**'
- en: The avalanche property that’s vital to encryption is just as important in hashing.
    Small changes in the password should result in large changes in the hash code—especially
    since many people, when required to choose a new password, choose a slight variation
    of their old one. The hash code produced for *dog* should be very different from
    those produced by similar passwords such as *doge*, *Dog*, or *odg*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对加密至关重要的雪崩效应在哈希中同样重要。密码的微小变化应该导致哈希值发生较大的变化——尤其是因为许多人在需要选择新密码时，通常会选择他们旧密码的轻微变体。对于*dog*生成的哈希值，应该与类似密码如*doge*、*Dog*或*odg*生成的哈希值有很大不同。
- en: '**The MD5 Hash Function**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**MD5哈希函数**'
- en: Meeting all these criteria is not easy. Good hash functions solve this problem
    in a clever way. They start with a jumble of bits and use the bit patterns of
    the password to modify this jumble further. That’s the method of the widely used
    hash function called *MD5*—the fifth version of the *Message Digest* hash function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 满足所有这些标准并不容易。好的哈希函数通过巧妙的方法解决了这个问题。它们从一堆杂乱的位开始，并利用密码的位模式进一步修改这些杂乱的位。这就是广泛使用的哈希函数*MD5*的工作原理——它是*消息摘要*哈希函数的第五个版本。
- en: '***Encoding the Password***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码编码***'
- en: To get started, MD5 converts the password to a 512-bit block; I’ll call this
    the *encoded password*. The first part of this encoding consists of the ASCII
    codes of the characters in the password. For example, if the password is *BigFunTime*,
    the first character is a *B*, which has an ASCII byte of 01000010, so the first
    8 bits of the encoded password are 01000010; the next 8 bits are the byte for
    *i*, which is 01101001; and so on. Thus, the 10 letters in our sample *BigFunTime*
    password will take up 80 bits out of 512.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，MD5将密码转换为512位的块；我将其称为*编码密码*。这个编码的第一部分由密码中每个字符的ASCII码组成。例如，如果密码是*BigFunTime*，第一个字符是*B*，它的ASCII字节是01000010，因此编码密码的前8位是01000010；接下来的8位是*i*的字节，01101001；以此类推。因此，我们示例中的10个字母*BigFunTime*密码将占用512中的80位。
- en: 'Now the rest of the bits have to be filled up. The next bit is set to 1, and
    all the bits up to the last 64 are set to 0\. The final 64 bits store a binary
    representation of the length, in bits, of the original password. In this case,
    the password is 10 characters, or 80 bits, long. The 64-bit binary representation
    of 80 is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其余的位需要填充。接下来的一个位被设置为1，直到最后64个比特之前的所有位都设置为0。最后64个比特存储的是原始密码的长度（二进制表示），以比特为单位。在这种情况下，密码长度为10个字符，或者80位。80的64位二进制表示是：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Clearly, we don’t need 64 bits to store the length of a password. Using 64 bits
    for the length allows MD5 to hash inputs of arbitrary length—the benefit of which
    we’ll see later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要64位来存储密码的长度。使用64位来表示长度，使MD5能够对任意长度的输入进行哈希——这个好处我们将在稍后看到。
- en: '[Figure 2-1](ch02.html#ch2fig1) shows the encoding of the sample password,
    organized into 16 numbered rows of 32 bits each.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.html#ch2fig1)显示了示例密码的编码，将其组织成16行，每行32位。'
- en: '![image](graphics/f02-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-01.jpg)'
- en: '*Figure 2-1: The password* BigFunTime *transformed into the 512 bits used as
    input to the MD5 hash function*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：密码* BigFunTime *转换为用于MD5哈希函数输入的512位*'
- en: This encoded password is full of zeros and therefore doesn’t meet the “fully
    uses all the bits” property of a good function, but that’s okay because this is
    not the hash code; it’s just the starting point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编码后的密码充满了零，因此不满足一个好的函数“充分利用所有位”的特性，但这没关系，因为这不是哈希值；它只是起始点。
- en: '***Bitwise Operations***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***位运算***'
- en: The MD5 hash function uses a few operations I haven’t discussed before. Let’s
    go through these briefly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MD5哈希函数使用了一些我之前没有讨论过的操作。我们来简单了解一下这些操作。
- en: '**Binary Addition**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**二进制加法**'
- en: 'The first new operation is *binary addition*. Binary addition is much like
    the decimal addition you already know but with binary numbers. For example, the
    32-bit representation of the number 5 is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新操作是*二进制加法*。二进制加法与你已经知道的十进制加法类似，只不过是使用二进制数。例如，数字5的32位表示是：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The 32-bit representation of 46 is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 46的32位表示是：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we add 5 and 46 together, the result is 51\. Likewise, the addition of those
    two binary representations results in the binary representation of 51:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将5和46相加，结果是51。同样，这两个二进制表示相加的结果也是51的二进制表示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike normal addition, though, where sometimes the result has more digits than
    the operands, in binary addition the number of bits is fixed. If the result of
    adding two 32-bit binary numbers is greater than 32 bits, we ignore the “carry”
    at the left side of the result and keep only the 32 bits on the right. It’s like
    working with a cheap calculator that has just a two-digit display, so when you
    add 75 and 49, instead of displaying 124, it displays only the last two digits,
    24.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与普通加法不同，在普通加法中有时结果的位数会超过操作数的位数，而在二进制加法中，位数是固定的。如果两个32位二进制数相加的结果超过了32位，我们会忽略结果左侧的“进位”，只保留右侧的32位。这就像使用一台便宜的计算器，只有两位数显示屏，因此当你加75和49时，它不会显示124，而只会显示最后两位数字24。
- en: '**Bitwise NOT**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**位运算 NOT**'
- en: The next new operation is called “not,” often written in all uppercase as *NOT*.
    As demonstrated in [Figure 2-2](ch02.html#ch2fig2), NOT “flips” all of the bits,
    replacing each 1 with a 0 and each 0 with a 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的新操作称为“not”，通常写作全大写的*NOT*。如[图2-2](ch02.html#ch2fig2)所示，NOT操作“翻转”所有位，将每个1替换为0，每个0替换为1。
- en: '![image](graphics/f02-02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-02.jpg)'
- en: '*Figure 2-2: The bitwise NOT operation. All bits are inverted. The 1 bits are
    highlighted for clarity.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：位运算 NOT。所有位都被翻转，1位用高亮显示以便清晰显示。*'
- en: '**Bitwise OR**'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**位或运算（OR）**'
- en: Up next is *OR*, sometimes called *inclusive-OR* to distinguish it from the
    exclusive-or (XOR) that you saw in [Chapter 1](ch01.html#ch01). The OR operation
    lines up two binary numbers with the same number of bits. In each position of
    the resulting binary number, you get a 1 if there’s a 1 in the first number *or*
    in the second number; otherwise, you get a 0, as shown in [Figure 2-3](ch02.html#ch2fig3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的操作是*OR*，有时称为*包含性OR*，用来区分它与[第1章](ch01.html#ch01)中看到的异或（XOR）。OR操作将两个具有相同位数的二进制数对齐。在结果二进制数的每个位置，如果第一个数或第二个数中有1，则结果为1；否则，结果为0，
    如[图2-3](ch02.html#ch2fig3)所示。
- en: '![image](graphics/f02-03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-03.jpg)'
- en: '*Figure 2-3: The bitwise OR operation. Bit positions are 1 in the result if
    they are 1 in either of the two inputs*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：位或运算（OR）。如果两个输入中的位之一为1，结果位为1。*'
- en: Notice that unlike XOR, you can’t apply OR twice and get the original byte back.
    It’s a one-way trip.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与异或（XOR）不同，你不能对 OR 操作应用两次以恢复原始字节。这是一个单向过程。
- en: '**Bitwise AND**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**位与运算（AND）**'
- en: The last of the new operations is *AND*. Two binary numbers are aligned, and
    in each position, the result is 1 wherever both bits are 1 in that position; otherwise,
    the result is 0\. So a 1 in the result means there was a 1 in that position in
    the first number *and* the second number, as seen in [Figure 2-4](ch02.html#ch2fig4).
    As with OR, the AND operation isn’t reversible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个新操作是*AND*。将两个二进制数对齐，在每个位置上，如果两个数的该位置位都是1，结果就是1；否则，结果为0。因此，结果中某个位置为1，意味着该位置在第一个数和第二个数中都是1，如[图2-4](ch02.html#ch2fig4)所示。与OR类似，AND操作是不可逆的。
- en: '![image](graphics/f02-04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-04.jpg)'
- en: '*Figure 2-4: The bitwise AND operation. Bit positions are 1 in the result if
    they are 1 in both of the two inputs.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：位与运算（AND）。如果两个输入中的位都是1，结果位为1。*'
- en: '***MD5 Hashing Rounds***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MD5哈希轮次***'
- en: Now we’re ready for some hashing. Pieces of the encoded password make only brief
    appearances in the MD5 process, but those appearances make all the difference.
    The MD5 process always starts with the same 128 bits, conceptually split into
    four 32-bit sections, labeled A through D, as shown in [Figure 2-5](ch02.html#ch2fig5).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进行哈希操作了。加密密码的部分数据在MD5过程中的出现只是短暂的，但这些出现决定了整个过程的不同。MD5过程始终以相同的128位开始，概念上分为四个32位部分，标记为A至D，如[图2-5](ch02.html#ch2fig5)所示。
- en: '![image](graphics/f02-05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-05.jpg)'
- en: '*Figure 2-5: The starting configuration of the 128 bits of an MD5 hash code*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：MD5 哈希码的 128 位初始配置*'
- en: From here, it’s all about shifting these bits around and flipping them, in a
    process that repeats a whopping 64 times. In this respect, the process is a lot
    like AES but with even more rounds. [Figure 2-6](ch02.html#ch2fig6) is a broad
    diagram of one of the 64 rounds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，整个过程就是不断地移动这些位并对它们进行翻转，这一过程会重复整整 64 次。在这方面，这个过程很像 AES，但轮数更多。[图 2-6](ch02.html#ch2fig6)是其中一个
    64 轮的宽泛示意图。
- en: '![image](graphics/f02-06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-06.jpg)'
- en: '*Figure 2-6: One round of the MD5 hash function. In the result, three of the
    sections are transposed, while all four sections are combined to make a new section.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：MD5 哈希函数的一个轮次。在结果中，三个部分被交换，而所有四个部分被组合成一个新的部分。*'
- en: As shown, sections B, C, and D are simply transposed, so that the D section
    of one round becomes the A section of the next. The main action of MD5 occurs
    in the “extra scrambling” of each round, which creates a new section from the
    bits of all four sections of the previous round. The extra scrambling uses the
    irreversible operations AND, OR, and NOT to combine the bits of all four sections
    with one of the rows of the encoded password. Different rows of the encoded password
    are used in different rounds, so that eventually all the rows of the encoded password
    are used multiple times. Because of the transposition, the process needs just
    four rounds to replace each of the four original sections with the result of the
    extra scrambling. After the complete 64-round process, the original bits of the
    sections will have been thoroughly sifted together with the encoded password.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，B、C 和 D 部分只是被交换，使得一轮的 D 部分成为下一轮的 A 部分。MD5 的主要操作发生在每轮的“额外混乱”中，这一过程利用前一轮所有四个部分的位生成一个新部分。额外混乱使用不可逆操作
    AND、OR 和 NOT，将所有四个部分的位与编码密码的一行结合起来。在不同的轮次中使用不同的编码密码行，因此最终所有的编码密码行都会被多次使用。由于有交换操作，这个过程只需四轮就能将四个原始部分中的每一个替换为额外混乱的结果。经过完整的
    64 轮过程后，原始的各个部分位将与编码密码彻底交织在一起。
- en: '***Meeting the Criteria of a Good Hash Function***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***满足良好哈希函数的标准***'
- en: Because MD5 starts with an assortment of bits, then alters these bits over and
    over, adding in pieces of the encoded password, we can be sure that all the bits
    are affected along the way, giving us a true 128-bit hash code. The sheer number
    of operations that are irreversible—and remember, the actions described occur
    64 times—means the hash function as a whole is not reversible. This rotation and
    alteration of the bits in the “extra scrambling” each round, combined with the
    rotation of the sections themselves, distribute the bits and bytes and create
    the desired avalanche.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MD5 从一组位开始，然后反复改变这些位，逐步加入编码密码的片段，我们可以确保所有的位在过程中都被影响，从而生成真正的 128 位哈希码。大量不可逆的操作——记住，这些操作会重复进行
    64 次——意味着整个哈希函数是不可逆的。每一轮中“额外混乱”的位移和改变，再加上各个部分本身的旋转，分散了位和字节，最终创建了预期的雪崩效应。
- en: MD5 meets all the baseline requirements for a good hash function. It does have
    a few subtle weaknesses, however, as you’ll soon see.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 满足一个良好哈希函数的所有基本要求。然而，它确实有一些微妙的弱点，正如你很快会看到的那样。
- en: '**Digital Signatures**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数字签名**'
- en: Hash functions serve other purposes in security besides creating keys from passwords.
    One of the most important is the creation of file *signatures*. As stated earlier,
    MD5 can process any size of input. If the input is larger than 512 bits, it’s
    first divided into multiple 512-bit blocks. The MD5 process is then applied once
    per block. The first block starts with the initial 128 bits and each subsequent
    block starts with the hash code produced by the previous block. In this way, we
    could run the entire text of this book, an audio file, a video, or any other digital
    file through the function and get a single 128-bit hash code in return. This hash
    code would become the file’s signature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数除了从密码生成密钥外，还在安全性中起着其他作用。其中最重要的之一是创建文件的 *签名*。如前所述，MD5 可以处理任何大小的输入。如果输入大于
    512 位，首先会将其分割成多个 512 位的块。然后，每个块都会应用一次 MD5 处理。第一个块从初始的 128 位开始，后续每个块都从前一个块生成的哈希码开始。通过这种方式，我们可以将本书的整个文本、一个音频文件、一个视频文件或任何其他数字文件都通过该函数，得到一个单一的
    128 位哈希码作为返回值。这个哈希码将成为该文件的签名。
- en: 'Why does a file need a signature? Suppose you have decided to download FreeWrite,
    a (fictional) freeware word processor application. You’re wary, though, because
    of a bad experience in which you downloaded a freeware program that turned out
    to be bogus and riddled with malware. To avoid this, you want to be sure the FreeWrite
    file that you download is the same file that the developers uploaded. The developers
    could hash the file with MD5 and post the resulting hash code—the file signature—on
    their website, [freewrite.com](http://freewrite.com). This allows you to run the
    file through an MD5 hash program and compare the result to the code on the developer
    site. If the new result doesn’t match the signature, something has changed: the
    file, the signature, or both.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一个文件需要签名呢？假设你决定下载FreeWrite（一款虚构的免费文字处理软件）。不过，你心存疑虑，因为曾经有过一次糟糕的经历，你下载了一款免费的程序，结果它是假的，充满了恶意软件。为了避免这种情况，你希望确保下载的FreeWrite文件和开发者上传的文件是一样的。开发者可以用MD5对文件进行哈希处理，并将生成的哈希码——即文件签名——发布在他们的网站[freewrite.com](http://freewrite.com)上。这样，你就可以使用MD5哈希程序对文件进行处理，并将结果与开发者网站上的代码进行比对。如果结果不匹配，那么文件、签名或两者之一发生了变化。
- en: '***The Problem of Identity***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***身份问题***'
- en: Unfortunately, matching the posted hash code proves the FreeWrite file is legitimate
    only if the hash code was actually published by the developers. But what if an
    attacker copies the developer’s [freewrite.com](http://freewrite.com) site to
    a similarly named domain like [free-write.com](http://free-write.com), and then
    posts a compromised file along with the hash of that compromised file? A digital
    signature is only as trustworthy as its provider. We’ll explore this problem in
    further detail in [Chapter 3](ch03.html#ch03).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，匹配发布的哈希码只能证明FreeWrite文件是合法的，前提是该哈希码确实是开发者发布的。但如果攻击者复制了开发者的[freewrite.com](http://freewrite.com)网站，改用一个类似的域名，如[free-write.com](http://free-write.com)，然后发布了一个被篡改的文件以及该文件的哈希码呢？数字签名的可信度取决于其提供者。我们将在[第3章](ch03.html#ch03)中进一步探讨这个问题。
- en: '***Collision Attacks***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***碰撞攻击***'
- en: Even with a matching hash code from a legitimate source, though, a file might
    be trouble. Many different files will produce the same hash code, which means
    an attacker trying to modify a file for nefarious purposes can avoid detection
    if the new, modified file produces the same hash code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 即便来自合法来源的哈希码匹配，一个文件仍然可能存在问题。许多不同的文件会产生相同的哈希码，这意味着一个攻击者如果试图修改文件以进行恶意操作，只要修改后的文件产生相同的哈希码，就能避免被检测到。
- en: 'It’s not too difficult to produce two files with the same hash code, which
    is known as a *collision attack*: just randomly generate files until two hash
    codes match. Finding a second file to match the *particular* hash code of another
    file is much harder. To be of any real use to an attacker, the file with the matching
    code can’t be a bunch of random bytes; it has to be a program that does something
    malicious on the attacker’s behalf.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生成两个具有相同哈希码的文件并不难，这被称为*碰撞攻击*：只需随机生成文件，直到两个哈希码匹配。找到第二个与另一个文件的*特定*哈希码匹配的文件要难得多。为了对攻击者有实际用途，具有匹配哈希码的文件不能只是一些随机字节，它必须是一个能够为攻击者执行恶意操作的程序。
- en: Unfortunately, there are methods to produce a second file with the same MD5
    code that is very similar to the first file. The discovery of this flaw in the
    MD5 hash function has led researchers to suggest that other hash functions be
    used for signatures. These more advanced hash functions usually have longer hash
    codes (up to 512 bits), more hashing rounds, and more complicated binary math
    during each round. As with encryption, though, there are no guarantees that flaws
    won’t be discovered in the more complicated hash functions as well. Proper use
    of signatures means staying one step ahead of known design flaws because attackers
    will exploit flaws mercilessly. Digital security is a cat-and-mouse game in which
    the good guys are the mice, trying to avoid being eaten, never able to defeat
    the cats, and only hoping to stay alive a little longer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有方法可以生成第二个文件，它与第一个文件非常相似且具有相同的MD5哈希码。MD5哈希函数中发现的这一缺陷促使研究人员建议使用其他哈希函数来进行签名。这些更先进的哈希函数通常拥有更长的哈希码（最多512位），更多的哈希轮次，并且在每轮过程中进行更复杂的二进制运算。然而，就像加密一样，不能保证更复杂的哈希函数不会被发现存在缺陷。数字签名的正确使用意味着始终保持在已知设计缺陷之前，因为攻击者会无情地利用这些缺陷。数字安全就像一场猫捉老鼠的游戏，正义的一方是老鼠，尽力避免被吃掉，永远无法打败猫，只能希望活得稍微久一点。
- en: '**Passwords in Authentication Systems**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**身份验证系统中的密码**'
- en: Nowhere is this cat-and-mouse game more evident than in authentication systems.
    Every place where you enter your password has to have a list of passwords to compare
    against, and properly securing the list requires great care.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种猫捉老鼠的游戏在身份验证系统中尤为明显。每一个需要输入密码的地方都必须有一个密码列表用于对比，而妥善保护这个列表需要极大的小心。
- en: '***The Dangers of Password Tables***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码表的危险***'
- en: Let’s look at the most straightforward way passwords could be stored in a table.
    In this example, Northeast Money Bank (NEMB) stores the username and password
    of each of its customers, along with the account number and current balance. An
    excerpt from the password table is shown in [Table 2-1](ch02.html#ch2tab1).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下最直接的密码存储方式。在这个例子中，东北钱银银行（NEMB）存储了每个客户的用户名和密码，以及账户号码和当前余额。密码表的一部分如[表2-1](ch02.html#ch2tab1)所示。
- en: '**Table 2-1:** Poorly Designed Password Table'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 设计不当的密码表'
- en: '| **Username** | **Password** | **Account number** | **Balance** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **密码** | **账户号码** | **余额** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| richguy22 | ilikemoney | 21647365 | $27.21 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| richguy22 | ilikemoney | 21647365 | $27.21 |'
- en: '| mrgutman | falcon | 32846519 | $10,000.00 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| mrgutman | falcon | 32846519 | $10,000.00 |'
- en: '| squire | yes90125 | 70023193 | $145,398.44 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| squire | yes90125 | 70023193 | $145,398.44 |'
- en: '| burgomeister78 | taco999 | 74766333 | $732.23 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| burgomeister78 | taco999 | 74766333 | $732.23 |'
- en: Just as Kerckhoffs’s principle says we can’t rely on encryption methods remaining
    secret, we shouldn’t rely on the password list remaining a secret, either. A disgruntled
    employee in the NEMB information technology department might easily acquire the
    file containing the list, or determined attackers on the outside might worm their
    way through the company defenses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如凯尔科夫原理所说，我们不能依赖加密方法保持秘密，我们也不应当依赖密码列表保持秘密。NEMB信息技术部门的一名不满的员工可能轻易获取包含此列表的文件，或者外部的攻击者可能通过公司的防御渗透进去。
- en: This is what’s known as a *single point of defense*, meaning that once anyone
    lays eyes on this table, the game is over. First, this table shows the account
    numbers and balances of all of the customers, so at the very least, that’s a major
    loss of privacy. What’s even worse is that each password is stored in the form
    entered by the user. Accessing this password list will allow attackers to log
    on as any customer—a disaster in the making.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的*单点防御*，意味着一旦有人看到这个表格，游戏就结束了。首先，这个表格展示了所有客户的账户号码和余额，至少这就造成了隐私的重大损失。更糟糕的是，每个密码都以用户输入的原始形式存储。访问这个密码列表将允许攻击者以任何客户的身份登录——这是一场灾难的前兆。
- en: Fortunately, the problems with this storage system are easily remedied. Knowing
    that, and knowing how dangerous the system is, you would think that it would never
    be used. Sadly, you would be wrong. Real companies are storing user passwords
    just like this. Some extremely large companies that probably spent a great deal
    of money on their websites have been caught following this practice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种存储系统的问题可以很容易地得到修正。知道了这些问题，也了解系统的危险性，你可能会认为这种方式永远不会被使用。可惜，你错了。现实中的一些公司就这样存储用户的密码。有些非常大的公司，可能花费了大量资金来建设其网站，但却仍然在使用这种做法。
- en: '***Hashing Passwords***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈希密码***'
- en: If [Table 2-1](ch02.html#ch2tab1) shows the wrong thing to do, what’s the right
    thing to do? One improvement is leaving the password out of the table and instead
    storing the hash code of the password, as shown by [Table 2-2](ch02.html#ch2tab2).
    (In the examples that follow, I show hash codes as decimal numbers to keep their
    length manageable.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[表2-1](ch02.html#ch2tab1)展示了错误的做法，那么正确的做法是什么呢？一种改进方法是将密码从表格中移除，而是存储密码的哈希值，如[表2-2](ch02.html#ch2tab2)所示。（在接下来的示例中，为了便于管理，我将哈希值以十进制数字的形式展示。）
- en: '**Table 2-2:** Password Table with Hashed Passwords'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** 存储哈希密码的密码表'
- en: '| **Username** | **Hash of password** | **Account number** | **Balance** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **密码哈希值** | **账户号码** | **余额** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| richguy22 | 330,711,060,038,684,200,901,827,278,633,002,791,087 | 21647365
    | $27.21 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| richguy22 | 330,711,060,038,684,200,901,827,278,633,002,791,087 | 21647365
    | $27.21 |'
- en: '| mrgutman | 332,375,033,828,033,552,423,319,316,163,101,084,850 | 32846519
    | $10,000.00 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| mrgutman | 332,375,033,828,033,552,423,319,316,163,101,084,850 | 32846519
    | $10,000.00 |'
- en: '| squire | 295,149,488,455,763,164,542,524,060,437,757,020,453 | 70023193 |
    $145,398.44 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| squire | 295,149,488,455,763,164,542,524,060,437,757,020,453 | 70023193 |
    $145,398.44 |'
- en: '| burgomeister78 | 133,039,589,388,270,767,475,032,770,360,311,206,892 | 74766333
    | $732.23 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| burgomeister78 | 133,039,589,388,270,767,475,032,770,360,311,206,892 | 74766333
    | $732.23 |'
- en: When a user tries to log in, the submitted password is hashed and the result
    compared to the stored hash code. If they match, the user is logged in. Because
    the hash function isn’t reversible, getting access to the table isn’t the same
    as getting access to the passwords. An attacker can’t log on to an account with
    the hash code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试登录时，提交的密码会被哈希处理，并将结果与存储的哈希码进行比对。如果匹配，用户即可登录。由于哈希函数是不可逆的，因此获取表格并不等于获取密码。攻击者无法凭借哈希码登录账户。
- en: The account number and balance are still stored as plaintext, though, and it
    would be a good idea to encrypt them, making a table with only hash codes and
    ciphertext. The problem is if we used the hash of the password as our cipher key,
    then encrypting the data provides no additional protection because anyone who
    acquires this table will be able to decrypt the ciphertext.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，账号和余额仍然以明文形式存储，最好对它们进行加密，制作一个只包含哈希码和密文的表格。问题是，如果我们使用密码的哈希值作为加密密钥，那么加密数据就无法提供额外的保护，因为任何获取到此表格的人都能解密密文。
- en: There are several ways to solve this problem. One solution is to use one hash
    function to transform the password for authentication and another hash function
    to transform the password into a cipher key to encrypt the account number and
    balance. As long as the hash functions are not reversible, this solution would
    provide security for the account data even if an attacker got access to the table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方法。一个解决方案是使用一个哈希函数对密码进行认证处理，另一个哈希函数将密码转换为加密密钥，用来加密账号和余额。只要这些哈希函数是不可逆的，即便攻击者获得了表格，依然可以保护账户数据的安全。
- en: '***Dictionary Attacks***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字典攻击***'
- en: Hashing the passwords is a good defense against attackers, but it’s not enough.
    Authentication systems are still vulnerable to *dictionary attacks*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码进行哈希处理是防御攻击者的一种有效手段，但仅此还不够。认证系统仍然容易受到*字典攻击*的威胁。
- en: 'In a basic dictionary attack, the attacker has no access to the password table
    and must guess the password. The attacker could just try random jumbles of characters
    but will have much more success with a *dictionary*, which in the world of software
    is simply a list of words. In this case, the dictionary is a list of the most
    common passwords, and it begins something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的字典攻击中，攻击者无法访问密码表，只能猜测密码。攻击者可以尝试随机字符组合，但使用*字典*会更加成功，在软件领域中，字典就是一个单词列表。在这个案例中，字典包含了最常见的密码，类似如下：
- en: • password
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: • password
- en: • 123456
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: • 123456
- en: • football
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • football
- en: • mypassword
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: • mypassword
- en: • abcdef
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • abcdef
- en: To foil the basic dictionary attack, most sites count the number of failed logins
    and, after a certain number (perhaps as few as three), temporarily prevent further
    login attempts from a particular computer. This renders the attack impractical
    by increasing the time required to find the right password.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止基本的字典攻击，大多数网站会统计失败登录次数，在达到一定次数（可能是三次）后，暂时阻止来自特定计算机的进一步登录尝试。这通过增加找到正确密码所需的时间，使得攻击变得不切实际。
- en: A different form of dictionary attack is used when an attacker has acquired
    a copy of a hashed and encrypted password table. In this case, the attacker hashes
    each password in the dictionary and compares it to each of the hash codes in the
    stolen table. When a match is discovered, the attacker knows the password that
    generates that user’s hash code. To save time, the attacker can run all the passwords
    in the dictionary through a selected hash function once and store the results
    in a dictionary like in [Table 2-3](ch02.html#ch2tab3).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不同形式的字典攻击是攻击者获取了哈希并加密的密码表副本。在这种情况下，攻击者会对字典中的每个密码进行哈希处理，并将其与窃取到的表格中的每个哈希码进行比对。当发现匹配时，攻击者就知道了生成该用户哈希码的密码。为了节省时间，攻击者可以先将字典中的所有密码通过选定的哈希函数处理一次，并将结果存储在一个字典中，就像[表
    2-3](ch02.html#ch2tab3)那样。
- en: '**Table 2-3:** Dictionary with Hash Codes'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3:** 带有哈希码的字典'
- en: '| **Password** | **MD5 hash code** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **密码** | **MD5 哈希码** |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| password | 126,680,608,771,750,945,340,162,210,354,335,764,377 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| password | 126,680,608,771,750,945,340,162,210,354,335,764,377 |'
- en: '| 123456 | 299,132,688,689,127,175,738,334,524,183,350,839,358 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 123456 | 299,132,688,689,127,175,738,334,524,183,350,839,358 |'
- en: '| football | 74,046,754,153,250,065,911,729,167,268,259,247,040 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| football | 74,046,754,153,250,065,911,729,167,268,259,247,040 |'
- en: '| mypassword | 69,792,856,232,803,413,714,004,936,714,872,372,804 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| mypassword | 69,792,856,232,803,413,714,004,936,714,872,372,804 |'
- en: '| abcdef | 308,439,634,705,511,765,949,277,356,614,095,247,246 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| abcdef | 308,439,634,705,511,765,949,277,356,614,095,247,246 |'
- en: Dictionaries demonstrate why it is important for users to choose passwords that
    aren’t obvious. The more obscure a password, the less likely it will be in an
    attacker’s dictionary.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字典展示了为什么用户选择不明显的密码如此重要。密码越晦涩，它出现在攻击者字典中的可能性就越小。
- en: '***Hash Tables***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈希表***'
- en: Unfortunately, an attacker can dispense with the dictionary altogether and build
    a table of randomly generated passwords and their corresponding hash codes, which
    I’ll call a *precomputed hash table*. Of course, the number of potential passwords
    is enormous, so if the attacker wants a decent chance of getting a match, the
    hash table needs to be huge. Building a precomputed hash table takes a lot of
    computing power and time, but it only has to be built once, and then it can be
    used over and over again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，攻击者可以完全放弃字典，构建一个随机生成密码及其对应哈希值的表格，我称之为*预计算哈希表*。当然，潜在密码的数量是巨大的，因此如果攻击者想要有一个合理的匹配机会，哈希表需要非常庞大。构建预计算哈希表需要大量的计算能力和时间，但它只需要构建一次，之后可以反复使用。
- en: One weakness of the table is that its sheer size can make searching for a match
    extremely slow. When you consider how fast a word processor can find a particular
    word in a large document, this may seem surprising, but these precomputed tables
    are much larger than any file on your computer. Suppose an attacker has a table
    of all passwords composed of 10 or fewer uppercase and lowercase letters and digits.
    Even with these restrictions, the number of potential passwords is 62^(10), which
    is 839,299,365,868,340,224\. The precomputed hash table won’t need every one of
    these potential passwords as entries, but it would need to have a sizable fraction.
    The table would be so large, though, it couldn’t fit in a computer’s internal
    memory. It couldn’t even fit on a hard drive—or just to get to the point, it’s
    so big it might need to be split across a million hard drives. And that’s just
    the storage problem. Unless you have the distributed computing power of Google,
    it’s not practical to search a table that large. (And searching a huge mass of
    data isn’t easy even for Google; we’ll explore searching in detail in [Chapter
    7](ch07.html#ch07).)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格的一个弱点是其庞大的体积会使得查找匹配项变得非常缓慢。当你考虑到文字处理软件在大文档中查找特定单词的速度时，这似乎有些令人吃惊，但这些预计算的表格远大于你计算机上的任何文件。假设攻击者拥有一个包含10个或更少的大写字母、小写字母和数字的所有密码的表格。即使有这些限制，潜在密码的数量是62^(10)，也就是839,299,365,868,340,224。预计算哈希表不需要包含每一个潜在密码的条目，但它需要有相当一部分。尽管如此，这个表格也会如此庞大，以至于它无法装进计算机的内存中。它甚至无法放进硬盘——为了直说，它可能需要分布在一百万个硬盘上。而这仅仅是存储问题。如果没有谷歌那样的分布式计算能力，查找如此庞大的表格是不切实际的。（即使是谷歌，搜索海量数据也并不容易；我们将在[第7章](ch07.html#ch07)详细探讨搜索问题。）
- en: '***Hash Chaining***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈希链***'
- en: Because a precomputed hash table is too large to store and search, attackers
    use a clever technique called *hash chaining* to drastically reduce the number
    of entries in the table without reducing its effectiveness. This technique uses
    a different type of function called a *reduction function* that does the same
    sorts of mathematical gyrations as a hash function but with the opposite purpose.
    Instead of creating a hash code from a password, it creates a password from a
    hash code—not the password that produced the hash, but simply a sequence of characters
    with the form of a valid password.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预计算哈希表太大，无法存储和搜索，攻击者使用了一种巧妙的技术，称为*哈希链*，可以显著减少表格中的条目数，同时不降低其有效性。该技术使用一种称为*还原函数*的不同类型的函数，它执行与哈希函数类似的数学运算，但目的是相反的。它不是从密码创建哈希值，而是从哈希值创建密码——不是生成哈希值的密码，而是生成一个具有有效密码形式的字符序列。
- en: 'Here’s an example of hash chaining. When *glopp26taz* is hashed using MD5,
    it produces this hash code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是哈希链的一个示例。当*glopp26taz*使用MD5进行哈希时，它产生了这个哈希值：
- en: 22,964,925,579,257,552,835,515,378,304,344,866,835
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 22,964,925,579,257,552,835,515,378,304,344,866,835
- en: A reduction function transforms this hash code into another valid password,
    say, *7HGupp2tss*. This, in turn, is sent through the hash function, producing
    another hash code, which is sent through the reduction function to generate another
    password, and so on. An alternating series of passwords and hash codes, such as
    that shown in [Figure 2-7](ch02.html#ch2fig7), is a *hash chain*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还原函数将哈希码转化为另一个有效的密码，比如*7HGupp2tss*。然后，将其通过哈希函数处理，生成另一个哈希码，再将其通过还原函数生成下一个密码，以此类推。这样交替生成的密码和哈希码序列，如[图
    2-7](ch02.html#ch2fig7)所示，就是一个*哈希链*。
- en: '![image](graphics/f02-07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-07.jpg)'
- en: '*Figure 2-7: In a hash chain, a hash function (H) alternates with a reduction
    function (R) that produces an arbitrary password from a hash code.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：在哈希链中，哈希函数（H）与还原函数（R）交替使用，后者从哈希码生成任意密码。*'
- en: Instead of a table of passwords and hash codes, the attacker generates a series
    of hash chains, each of the same length, storing only the first and last links
    of each chain. The chain in [Figure 2-7](ch02.html#ch2fig7) is shown as the third
    entry in [Table 2-4](ch02.html#ch2tab4). This table has 5 entries, but each entry
    is a chain of 3 password/hash pairs, making this the equivalent of a plain table
    of 15 entries.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者不使用密码和哈希码的表格，而是生成一系列哈希链，每个链条长度相同，只存储每个链条的第一个和最后一个链接。[图 2-7](ch02.html#ch2fig7)中的链条在[表
    2-4](ch02.html#ch2tab4)中作为第三项显示。这个表格有5项，但每项都是由3对密码/哈希码组成的链条，因此相当于一个包含15项的普通表格。
- en: '**Table 2-4:** Hash Chain Table'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-4:** 哈希链表'
- en: '| **Start** | **End** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **Start** | **End** |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| sop3H4Yzai | 302,796,960,148,170,554,741,517,711,430,674,339,836 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| sop3H4Yzai | 302,796,960,148,170,554,741,517,711,430,674,339,836 |'
- en: '| 5jhfHTeu4y | 333,226,570,587,833,594,170,987,787,116,324,792,461 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 5jhfHTeu4y | 333,226,570,587,833,594,170,987,787,116,324,792,461 |'
- en: '| glopp26taz | 33,218,269,111,507,728,124,938,049,521,416,301,013 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| glopp26taz | 33,218,269,111,507,728,124,938,049,521,416,301,013 |'
- en: '| YYhs9j2a22 | 145,483,602,575,738,705,325,298,600,400,764,586,970 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| YYhs9j2a22 | 145,483,602,575,738,705,325,298,600,400,764,586,970 |'
- en: '| Pr2u912mn1 | 737,08,819,301,203,417,973,443,363,267,460,459,460 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Pr2u912mn1 | 737,08,819,301,203,417,973,443,363,267,460,459,460 |'
- en: '[Figure 2-8](ch02.html#ch2fig8) shows an example of using the table. Our attacker
    is trying to recover the password for the target hash code 117,182,660,124,686,473,
    413,705,332,853,526,309,255\. The attacker must determine which chain in the table,
    if any, contains the target hash code. First, the target code is compared against
    every number in the End column of the table. In this case, no match is found,
    so the attacker runs the target hash code through the reduction function to make
    a new password, runs that result through the hashing function, and then searches
    for this new hash code in the End column of the table. This process will continue
    until a match is found, or after the process is run three times (the length of
    the chains in this table).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-8](ch02.html#ch2fig8)展示了如何使用该表的一个示例。我们的攻击者正试图恢复目标哈希码117,182,660,124,686,473,
    413,705,332,853,526,309,255的密码。攻击者必须确定表中的哪个链条（如果有的话）包含目标哈希码。首先，目标哈希码与表中“End”列的每个数字进行比较。在这个案例中，没有找到匹配项，因此攻击者将目标哈希码通过还原函数转换为一个新的密码，将该结果通过哈希函数，再将新的哈希码搜索表格的“End”列。这个过程将持续进行，直到找到匹配项，或者在运行了三次后（表格中链条的长度）。'
- en: In this case, the initial target hash value is reduced to the password *pRh7T63y*,
    which, in turn, is hashed, and this new hash value appears in the third entry
    of the table, in the chain with the starting password *glopp26taz*. That identifies
    the hash chain in which the target password may appear, but the attacker must
    obtain the password by iterating through this chain. The starting password in
    that chain is hashed; the resulting hash value is not a match for the initial
    hash value, so it is reduced to a new password, *7HGupp2tss*, and hashed again.
    This hash code *does* match, which means *7HGupp2tss* is the password.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，初始目标哈希值被转换为密码*pRh7T63y*，然后进行哈希处理，新的哈希值出现在表格的第三项中，与起始密码*glopp26taz*形成链条。这标识了目标密码可能出现的哈希链，但攻击者必须通过迭代这个链条来获取密码。链条中的起始密码被哈希处理；所得哈希值与初始哈希值不匹配，因此它被转化为新的密码*7HGupp2tss*，并再次进行哈希处理。这个哈希值*匹配*，这意味着*7HGupp2tss*就是密码。
- en: Hash code chains dramatically shrink the table while still providing the same
    amount of searchable data. For example, if a chain has 100 passwords and 100 hash
    codes, then the password matching any of those hash codes can be indirectly retrieved
    using that chain, even though the chain has only one password and hash code in
    the table. Therefore, a table with chains that long has the power of a regular
    precomputed hash table 100 times larger.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希码链表显著缩小了表格的大小，同时仍然提供相同量的可搜索数据。例如，如果一个链表有100个密码和100个哈希码，那么匹配这些哈希码的密码可以通过该链表间接检索，尽管链表中只包含一个密码和一个哈希码。因此，具有如此长链表的表格，其功能相当于一个常规的预计算哈希表，大小是其100倍。
- en: There are some potential snags, though. For one, searching takes more computational
    effort with hash chains. Also, because of collisions—multiple passwords that produce
    the same hash code—a matching chain doesn’t necessarily contain the searched-for
    hash code and its matching password, a problem known as *chain merging*. These
    are small consolations for those of us worried about our data security, however.
    There are methods for reducing the chain merging problem, but even without them,
    it’s clear that effective precomputed tables can be made for particular hash functions,
    rendering the passwords that use them vulnerable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，也存在一些潜在的问题。首先，使用哈希链表进行搜索需要更多的计算工作。此外，由于碰撞—多个密码产生相同的哈希码—一个匹配的链表不一定包含所查找的哈希码及其对应的密码，这个问题被称为*链表合并*。然而，对于我们这些关心数据安全的人来说，这些问题仍然是一些安慰。虽然有方法可以减少链表合并的问题，但即使没有这些方法，显然对于特定的哈希函数，仍然可以制作有效的预计算表，从而使得使用这些哈希函数的密码变得脆弱。
- en: '![image](graphics/f02-08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-08.jpg)'
- en: '*Figure 2-8: Using a hash chain table to find a password that produces a particular
    hash code. Neither the password nor the hash code is listed in the table.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：使用哈希链表查找产生特定哈希值的密码。表中既不列出密码，也不列出哈希值。*'
- en: '***Iterative Hashing***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***迭代哈希***'
- en: One way to thwart the creation of precomputed hash tables is to apply the hash
    function more than once. Because the output of a hash function can itself be hashed,
    the original password can pass through the same hash function any number of times.
    This technique, unhelpfully, is also known as *hash chaining*, but to avoid confusion,
    I will refer to it as *iterative hashing*. [Figure 2-9](ch02.html#ch2fig9) shows
    a five-deep iterative hashing of the password *football*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 防止创建预计算哈希表的一种方法是多次应用哈希函数。由于哈希函数的输出本身也可以被哈希处理，原始密码可以经过相同的哈希函数任意次数。这个技术同样不太有帮助地被称为*哈希链*，但为了避免混淆，我将其称为*迭代哈希*。[图2-9](ch02.html#ch2fig9)展示了对密码*football*进行五次迭代哈希处理的过程。
- en: '![image](graphics/f02-09.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f02-09.jpg)'
- en: '*Figure 2-9: Applying a hash function repeatedly*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：重复应用哈希函数*'
- en: With this technique, passwords are repeatedly hashed when the password is stored
    and when the user logs in. To thwart this, the attacker has to produce a table
    based on the same idea, running the chosen hash code function the same number
    of times. From Kerchkoffs’s principle, we know that cryptographic systems shouldn’t
    depend on keeping their methods secret. The goal of iterative hashing isn’t to
    disguise how many times the password is hashed, but to make the creation of the
    attacker’s precomputed hash table as difficult as possible. In the example, the
    password runs through the hash function five times. That would multiply the time
    needed to create the attacker’s table by five as well. In real-world use, passwords
    can be run through hash functions hundreds or thousands of times. Is this enough
    to prevent the creation of useful precomputed hash tables? Maybe. Computers get
    faster every day. For the most part, this is wonderful, but the downside to ever-increasing
    computational power is that it keeps pushing the boundary of practical limitations,
    and so much of our information security is based on these practical limitations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术时，密码在存储时和用户登录时都会被反复进行哈希处理。为了破解这一点，攻击者必须基于相同的思想，制作一张表格，运行所选的哈希函数相同次数。根据凯尔克霍夫原则，我们知道加密系统不应依赖于保密其方法。迭代哈希的目标不是掩盖密码被哈希的次数，而是尽可能地增加攻击者预计算哈希表的创建难度。在这个示例中，密码会经过五次哈希处理。这将使得攻击者创建哈希表所需的时间增加五倍。现实世界中，密码可以通过哈希函数运行数百次甚至数千次。这足够防止创建有用的预计算哈希表吗？也许吧。计算机每天都在变得更快。这大多数情况下是件好事，但计算能力不断增强的副作用是，它不断推动实际限制的边界，因此我们的信息安全在很大程度上依赖于这些实际限制。
- en: Someone setting up a password system based on iterative hashing has to choose
    the number of iterations. It’s fairly easy to choose a number that provides good
    security today. What’s difficult is predicting the number of iterations required
    a year from now, or 2 years, or 10.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 设置基于迭代哈希的密码系统时，必须选择迭代次数。今天选择一个能提供良好安全性的数字相对容易。难的是预测一年的迭代次数，或者两年、十年后的情况。
- en: You might think the best choice is some impossibly large number to guard against
    the power of future computers. The problem is that today’s computers would have
    real trouble processing legitimate logins. Would you be willing to wait five minutes
    to access one of your online accounts?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，最好的选择是某个极大的数字来防止未来计算机的攻击。问题是，现在的计算机在处理合法登录时会遇到很大困难。你愿意等五分钟才能访问你的某个在线账户吗？
- en: '***Salting Passwords***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码加盐***'
- en: Authentication systems need a way to strengthen hashing without a performance-crushing
    number of hash iterations; that is, they need a method of storing passwords that
    requires an impractical time investment from attackers without creating an equally
    unrealistic time burden on legitimate access. That method is called *salt*. Salt
    is an apt term for this concept, and I commend whoever came up with it. In culinary
    usage, a pinch of salt profoundly changes the flavor of a dish. In cryptography,
    a small quantity of salt sprinkled on a password dramatically changes its hash
    code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 认证系统需要一种方法来加强哈希，但又不会因哈希迭代次数过多而影响性能；也就是说，它们需要一种存储密码的方法，能够让攻击者投入不切实际的时间，而不会对合法访问造成同样不现实的时间负担。这个方法叫做*盐*。盐这个词非常恰当，谁想出这个概念，我真是佩服。用在烹饪中，一小撮盐就能显著改变菜肴的味道。在密码学中，撒在密码上的少量盐会极大地改变其哈希值。
- en: 'Here’s how it works: when a new user signs up for an account and selects a
    username and password, the system automatically generates the salt for that account.
    The salt is a string of characters, like a short, random password, that is combined
    with the user’s password before hashing. For example, user *mrgutman* chooses
    *falcon* as his password, and the system generates *h38T2* as the salt.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的：当一个新用户注册账户并选择用户名和密码时，系统会自动为该账户生成盐。盐是一串字符，就像一个短的、随机的密码，它与用户的密码结合后再进行哈希。例如，用户*mrgutman*选择了*falcon*作为密码，系统生成了*h38T2*作为盐。
- en: The salt and password can be combined in various ways, but the simplest is appending
    the salt to the end of the password, resulting in *falconh38T2* in this example.
    This combination is then hashed, and the hash code stored in the authentication
    table along with the username and the salt, as shown in [Table 2-5](ch02.html#ch2tab5).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 盐和密码可以通过不同的方式结合，但最简单的方式是将盐附加到密码的末尾，在这个例子中就是*falconh38T2*。然后，这个组合被哈希，哈希值与用户名和盐一起存储在认证表中，如[表
    2-5](ch02.html#ch2tab5)所示。
- en: '**Table 2-5:** Password Table Using Salt'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-5：** 使用盐的密码表'
- en: '| **Username** | **Salt** | **Hash of password + salt** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **盐** | **密码+盐的哈希值** |'
- en: '| --- | --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| richguy22 | 7Pmnq | 106,736,954,704,360,738,602,545,963,558,770,944,412 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| richguy22 | 7Pmnq | 106,736,954,704,360,738,602,545,963,558,770,944,412 |'
- en: '| mrgutman | h38T2 | 142,858,562,082,404,032,402,440,010,972,328,251,653 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| mrgutman | h38T2 | 142,858,562,082,404,032,402,440,010,972,328,251,653 |'
- en: '| squire | 93ndy | 122,446,997,766,728,224,659,318,737,810,478,984,316 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| squire | 93ndy | 122,446,997,766,728,224,659,318,737,810,478,984,316 |'
- en: '| burgomeister78 | HuOw2 | 64,383,697,378,169,783,622,186,691,431,070,835,777
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| burgomeister78 | HuOw2 | 64,383,697,378,169,783,622,186,691,431,070,835,777
    |'
- en: Each time a user requests access, the salt is added to the end of the entered
    password before hashing. An attacker who acquires a copy of this authentication
    table can’t get much use out of a precomputed hash table. Although the table might
    have a password that hashes to the given code, that password won’t produce the
    right code when combined with the salt. Instead, the attacker would need to create
    a table for a specific salt. That could be done, but remember that the salt is
    randomly chosen. If there are, say, 100,000 users in a stolen authentication table,
    and the salts are numerous enough that no salt is duplicated in the table, the
    attacker will need to create 100,000 tables. At this point, we can’t even call
    them precomputed tables because the attacker is creating them for each attack.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户请求访问时，盐值都会添加到输入的密码末尾，再进行哈希处理。攻击者如果获取到这个认证表的副本，无法从预计算的哈希表中得到太多有用的信息。虽然表中可能有一个密码哈希值与给定的代码匹配，但当该密码与盐值结合时，结果不会产生正确的代码。相反，攻击者需要为特定的盐值创建一个表。虽然这可以做到，但请记住，盐值是随机选择的。如果说，在一个被盗的认证表中有10万个用户，并且盐值足够多，以至于没有盐值在表中重复，那么攻击者就需要创建10万个表。到这时，我们甚至不能再称它们为预计算的表，因为攻击者需要为每次攻击创建这些表。
- en: '***Are Password Tables Safe?***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码表安全吗？***'
- en: Salting and iterative hashing are typically used together, creating real headaches
    for an attacker. Iterative hashing increases the time requirement for creating
    a single precomputed hash table, and salting means an attacker has to make a multitude
    of tables. But is this combination enough?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 盐值和迭代哈希通常是一起使用的，这给攻击者带来了真正的麻烦。迭代哈希增加了创建一个预计算哈希表所需的时间，而盐值则意味着攻击者需要创建多个表。但这种组合足够安全吗？
- en: There is no definitive answer to that question. Cryptography researchers and
    security experts continue to develop new defenses against unauthorized access.
    At the same time, though, attackers continue to find new methods to penetrate
    defenses. Advances in computational power and programming theory help whichever
    side takes advantage of them first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题没有明确的答案。密码学研究人员和安全专家们继续开发新的防御措施以防止未经授权的访问。然而，与此同时，攻击者也在不断找到新的方法突破防御。计算能力和编程理论的进步有利于率先利用它们的一方。
- en: Perhaps the most important lesson of this discussion is that security is often
    out of the user’s hands. There will always be vulnerabilities, but there’s no
    way for a user to know if a particular site or service is employing the best security
    practices. The salt technique, for example, benefits only systems that use it,
    and not every system does.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 也许本次讨论最重要的教训就是，安全性往往超出了用户的控制范围。总是存在漏洞，但用户无法知道某个特定网站或服务是否采用了最佳的安全措施。例如，盐值技术只对使用它的系统有益，而并非所有系统都使用它。
- en: '**Password Storage Services**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**密码存储服务**'
- en: That’s how passwords are stored on remote authentication systems. What about
    on the user end? How do we safely store our passwords?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是密码在远程认证系统中的存储方式。那么在用户端呢？我们如何安全地存储我们的密码？
- en: A long time ago, I had so few passwords that I could safely entrust them to
    my memory, but eventually I knew I had to store passwords outside of my head.
    Writing the passwords on a piece of paper, though, is just a different kind of
    security liability. For a while, I had an elaborate homebrew solution involving
    a *.txt* file encrypted with AES and stored on a memory card that was kept in
    a metal box that was probably not 100 percent fireproof. This arrangement worked,
    except that every time I needed to look up a password, I had to go to the box,
    get the memory card, slot it into my computer, double-click the file, type the
    password (the one password I had to remember), and find the desired entry in my
    table.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，我的密码少得可以完全依赖记忆来保管，但最终我意识到我必须把密码存储在脑袋以外的地方。然而，把密码写在纸上又是一种不同的安全隐患。有一段时间，我采用了一种复杂的自制方案，其中涉及一个用AES加密的*.txt*文件，存储在一个存放在金属盒中的内存卡上，而这个金属盒可能并非百分之百防火。这个方案有效，唯一的问题是每次需要查找密码时，我都得去取盒子，把内存卡取出来插入电脑，双击文件，输入密码（唯一需要记住的密码），然后在表格中找到所需的条目。
- en: Eventually I threw in the towel and signed up for a web-based password storage
    service. When I created an account with the service, I chose a master password.
    I then stored all my other passwords and usernames on this website. This information
    is stored in a way that renders it of little use to anyone who gains access to
    the raw data, so if my password at Amazon is *chickenfat* (it isn’t), then the
    word *chickenfat* isn’t stored anywhere on the password storage server. Instead,
    the passwords are encrypted by a program on my browser before being sent to the
    password storage site, using my chosen master password to generate the encryption
    key. Therefore, even if the server were breached, the attacker wouldn’t be able
    to retrieve my individual passwords without the master password.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我放弃了，注册了一个基于网页的密码存储服务。当我创建该服务的账户时，我选择了一个主密码。然后我将所有其他的密码和用户名存储在这个网站上。这些信息的存储方式使得即使有人获得了原始数据，对他们也几乎没有用处。因此，如果我在亚马逊的密码是*chickenfat*（实际上不是），那么*chickenfat*这个词就不会存储在密码存储服务器上。相反，这些密码在发送到密码存储站点之前，会通过我浏览器中的程序加密，使用我选择的主密码生成加密密钥。因此，即使服务器被攻破，攻击者也无法在没有主密码的情况下恢复我的各个密码。
- en: The master password itself is not stored on the password storage site, either.
    When the encryption key is needed to encrypt or decrypt an individual login, the
    master password is salted and then hashed repeatedly, for as many iterations as
    I specify.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主密码本身也不会存储在密码存储网站上。当需要加密或解密某个具体登录信息时，主密码会被加盐然后进行多次哈希处理，哈希的次数由我指定。
- en: Although using a password storage service puts all of my eggs in one basket,
    so to speak, this frees me to use best practices for individual logins. Whereas
    previously I might have created passwords that were collages of words and numbers
    I thought I could remember, now my passwords are lengthy random jumbles. And they
    are all different because I no longer need to remember them all.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用密码存储服务把所有的“鸡蛋”都放在了一个篮子里，但这让我能够在个人登录中使用最佳实践。以前，我可能会创建一些由我认为能记住的单词和数字组合成的密码，而现在我的密码是长度随机的杂乱字符串。而且它们都不相同，因为我不再需要记住所有密码了。
- en: '**A Final Thought**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最后的思考**'
- en: In all of this talk about authentication systems, I’ve avoided a crucial detail.
    Authentication systems compare stored user passwords to passwords provided during
    logons, but how does the remote computer doing the authentication get the users’
    chosen passwords in the first place? Secure transmission requires encryption,
    which implies the users would have had to encrypt the passwords—but how could
    the remote system decrypt the encrypted passwords without having the passwords
    already? This brings us back to the shared key problem—none of what we talked
    about in this chapter can work unless that problem is solved. So that’s what we’ll
    do next.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论认证系统时，我忽略了一个至关重要的细节。认证系统将存储的用户密码与登录时提供的密码进行比较，但远程计算机如何在第一次进行认证时获得用户选择的密码呢？安全传输需要加密，这意味着用户必须加密密码——但远程系统如何在没有密码的情况下解密这些加密密码呢？这又回到了共享密钥的问题——如果这个问题没有解决，我们在本章讨论的内容都无法正常工作。所以，接下来我们就来解决这个问题。
