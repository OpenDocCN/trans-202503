- en: 'Chapter 22. Signals: Advanced Features'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第22章 信号：高级特性
- en: 'This chapter completes the discussion of signals that we began in [Chapter 20](ch20.html
    "Chapter 20. Signals: Fundamental Concepts"), covering a number of more advanced
    topics, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了我们在[第20章](ch20.html "第20章. 信号：基本概念")中开始讨论的信号部分，涵盖了一些更高级的主题，包括以下内容：
- en: core dump files;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心转储文件；
- en: special cases regarding signal delivery, disposition, and handling;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于信号传递、处理和处置的特殊情况；
- en: synchronous and asynchronous generation of signals;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号的同步和异步生成；
- en: when and in what order signals are delivered;
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号何时以及按什么顺序传递；
- en: interruption of system calls by signal handlers, and how to automatically restart
    interrupted system calls;
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序中断系统调用，以及如何自动重新启动被中断的系统调用；
- en: realtime signals;
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时信号；
- en: the use of *sigsuspend()* to set the process signal mask and wait for a signal
    to arrive;
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*sigsuspend()*设置进程的信号屏蔽并等待信号到达；
- en: the use of *sigwaitinfo()* (and *sigtimedwait()*) to synchronously wait for
    a signal to arrive;
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*sigwaitinfo()*（和*sigtimedwait()*）同步等待信号到达；
- en: the use of *signalfd()* to receive a signal via file descriptor; and
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*signalfd()*通过文件描述符接收信号；
- en: the older BSD and System V signal APIs.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较旧的BSD和System V信号API。
- en: Core Dump Files
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心转储文件
- en: Certain signals cause a process to create a core dump and terminate ([Table 20-1](ch20.html#linux_signals
    "Table 20-1. Linux signals"), page 396). A core dump is a file containing a memory
    image of the process at the time it terminated. (The term *core* derives from
    an old memory technology.) This memory image can be loaded into a debugger in
    order to examine the state of a program’s code and data at the moment when the
    signal arrived.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 某些信号会导致进程生成核心转储并终止（[表20-1](ch20.html#linux_signals "表20-1. Linux信号"), 第396页）。核心转储是一个包含进程在终止时内存映像的文件。（*core*一词源自一种旧的内存技术。）这个内存映像可以加载到调试器中，以检查程序代码和数据在信号到达时的状态。
- en: 'One way of causing a program to produce a core dump is to type the *quit* character
    (usually *Control-\*), which causes the `SIGQUIT` signal to be generated:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使程序生成核心转储的一种方法是输入*quit*字符（通常是*Control-\*），这会生成`SIGQUIT`信号：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the message *Quit (core dumped)* is printed by the shell, which
    detects that its child (the process running *sleep*) was killed by `SIGQUIT` and
    did a core dump.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，消息*Quit (core dumped)*由shell打印，shell检测到它的子进程（运行*sleep*的进程）被`SIGQUIT`信号终止并生成了核心转储。
- en: The core dump file was created in the working directory of the process, with
    the name `core`. This is the default location and name for a core dump file; shortly,
    we explain how these defaults can be changed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 核心转储文件在进程的工作目录中创建，文件名为`core`。这是核心转储文件的默认位置和名称；接下来，我们将解释如何更改这些默认设置。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Many implementations provide a tool (e.g., *gcore* on FreeBSD and Solaris) to
    obtain a core dump of a running process. Similar functionality is available on
    Linux by attaching to a running process using *gdb* and then using the *gcore*
    command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实现提供了一个工具（例如，在FreeBSD和Solaris上是*gcore*）来获取正在运行的进程的核心转储。在Linux上，通过使用*gdb*附加到正在运行的进程，并使用*gcore*命令来实现类似的功能。
- en: Circumstances in which core dump files are not produced
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不生成核心转储文件的情况
- en: 'A core dump is not produced in the following circumstances:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下不会生成核心转储：
- en: The process doesn’t have permission to write the core dump file. This could
    happen because the process doesn’t have write permission for the directory in
    which the core dump file is to be created, or because a file with the same name
    already exists and either is not writable or is not a regular file (e.g., it is
    a directory or a symbolic link).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程没有权限写入核心转储文件。这可能是因为进程没有对要创建核心转储文件的目录的写权限，或者因为同名的文件已经存在，并且该文件要么不可写，要么不是常规文件（例如，它是一个目录或符号链接）。
- en: A regular file with the same name already exists, and is writable, but there
    is more than one (hard) link to the file.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经存在同名的常规文件，并且该文件可写，但该文件有多个（硬）链接。
- en: The directory in which the core dump file is to be created doesn’t exist.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建核心转储文件的目录不存在。
- en: The process resource limit on the size of a core dump file is set to 0\. This
    limit, `RLIMIT_CORE`, is discussed in more detail in Section 36.3\. In the example
    above, we used the *ulimit* command (*limit* in the C shell) to ensure that there
    is no limit on the size of `core` files.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程资源限制中的核心转储文件大小被设置为 0。此限制 `RLIMIT_CORE` 在第 36.3 节中进行了详细讨论。在上述示例中，我们使用 *ulimit*
    命令（在 C shell 中为 *limit*）来确保没有核心文件大小的限制。
- en: The process resource limit on the size of a file that may be produced by the
    process is set to 0\. We describe this limit, `RLIMIT_FSIZE`, in Section 36.3.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程资源限制中，进程可能生成的文件大小被设置为 0。我们在第 36.3 节中描述了此限制 `RLIMIT_FSIZE`。
- en: The binary executable file that the process is executing doesn’t have read permission
    enabled. This prevents users from using a core dump to obtain a copy of the code
    of a program that they would otherwise be unable to read.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程正在执行的二进制可执行文件没有启用读取权限。这防止了用户通过核心转储获取程序代码的副本，而该代码原本是无法读取的。
- en: The file system on which the current working directory resides is mounted read-only,
    is full, or has run out of i-nodes. Alternatively, the user has reached their
    quota limit on the file system.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前工作目录所在的文件系统被挂载为只读、已满或已耗尽 i-node。或者，用户已达到文件系统上的配额限制。
- en: Set-user-ID (set-group-ID) programs executed by a user other than the file owner
    (group owner) don’t generate core dumps. This prevents malicious users from dumping
    the memory of a secure program and examining it for sensitive information such
    as passwords.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由非文件拥有者（非组拥有者）用户执行的设置用户ID（设置组ID）程序不会生成核心转储。这防止恶意用户转储安全程序的内存并检查其中的敏感信息，如密码。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `PR_SET_DUMPABLE` operation of the Linux-specific *prctl()* system
    call, we can set the *dumpable* flag for a process, so that when a set-user-ID
    (set-group-ID) program is run by a user other than the owner (group owner), a
    core dump can be produced. The `PR_SET_DUMPABLE` operation is available from Linux
    2.4 onward. See the *prctl(2)* manual page for further details. In addition, since
    kernel 2.6.13, the `/proc/sys/fs/suid_dumpable` file provides system-wide control
    over whether or not set-user-ID and set-group-ID processes produce core dumps.
    For details, see the *proc(5)* manual page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 特有的`PR_SET_DUMPABLE`操作，可以通过 *prctl()* 系统调用为进程设置 *dumpable* 标志，从而在非拥有者（非组拥有者）用户运行设置用户ID（设置组ID）程序时生成核心转储。`PR_SET_DUMPABLE`
    操作从 Linux 2.4 版本起可用。详情请参阅 *prctl(2)* 手册页。此外，从内核 2.6.13 起，`/proc/sys/fs/suid_dumpable`
    文件提供了对是否允许设置用户ID和设置组ID进程生成核心转储的全局控制。有关详情，请参阅 *proc(5)* 手册页。
- en: 'Since kernel 2.6.23, the Linux-specific `/proc/`*PID*`/coredump_filter` can
    be used on a per-process basis to determine which types of memory mappings are
    written to a core dump file. (We explain memory mappings in [Chapter 49](ch49.html
    "Chapter 49. Memory Mappings").) The value in this file is a mask of four bits
    corresponding to the four types of memory mappings: private anonymous mappings,
    private file mappings, shared anonymous mappings, and shared file mappings. The
    default value of the file provides traditional Linux behavior: only private anonymous
    and shared anonymous mappings are dumped. See the *core(5)* manual page for further
    details.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.23 起，Linux 特有的 `/proc/`*PID*`/coredump_filter` 可用于按进程级别确定哪些类型的内存映射被写入核心转储文件。（我们在
    [第49章](ch49.html "第49章 内存映射") 中解释了内存映射。）该文件中的值是四位掩码，对应于四种类型的内存映射：私有匿名映射、私有文件映射、共享匿名映射和共享文件映射。文件的默认值提供了传统的
    Linux 行为：仅转储私有匿名映射和共享匿名映射。有关详情，请参阅 *core(5)* 手册页。
- en: 'Naming the core dump file: `/proc/sys/kernel/core_pattern`'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 核心转储文件命名：`/proc/sys/kernel/core_pattern`
- en: Starting with Linux 2.6, the format string contained in the Linux-specific `/proc/sys/kernel/core_pattern`
    file controls the naming of all core dump files produced on the system. By default,
    this file contains the string *core*. A privileged user can define this file to
    include any of the format specifiers shown in [Table 22-1](ch22.html#format_specifiers_for_solidus_proc_solid
    "Table 22-1. Format specifiers for /proc/sys/kernel/core_pattern"). These format
    specifiers are replaced by the value indicated in the right column of the table.
    Additionally, the string may include slashes (`/`). In other words, we can control
    not just the name of the core file, but also the (absolute or relative) directory
    in which it is created. After all format specifiers have been replaced, the resulting
    pathname string is truncated to a maximum of 128 characters (64 characters before
    Linux 2.6.19).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.6开始，Linux特定的`/proc/sys/kernel/core_pattern`文件中包含的格式字符串控制着系统上生成的所有核心转储文件的命名。默认情况下，该文件包含字符串*core*。具有特权的用户可以定义该文件，以包含[表22-1](ch22.html#format_specifiers_for_solidus_proc_solid
    "表22-1. /proc/sys/kernel/core_pattern格式说明符")中显示的任何格式说明符。这些格式说明符将被替换为表格右列中指示的值。此外，该字符串可以包含斜杠（`/`）。换句话说，我们不仅可以控制核心文件的名称，还可以控制它被创建的（绝对或相对）目录。在所有格式说明符都被替换后，结果路径名字符串将被截断为最多128个字符（在Linux
    2.6.19之前为64个字符）。
- en: Since kernel 2.6.19, Linux supports an additional syntax in the `core_pattern`
    file. If this file contains a string starting with the pipe symbol (`|`), then
    the remaining characters in the file are interpreted as a program—with optional
    arguments that may include the `%` specifiers shown in [Table 22-1](ch22.html#format_specifiers_for_solidus_proc_solid
    "Table 22-1. Format specifiers for /proc/sys/kernel/core_pattern")—that is to
    be executed when a process dumps core. The core dump is written to the standard
    input of that program instead of to a file. See the *core(5)* manual page for
    further details.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本2.6.19开始，Linux支持在`core_pattern`文件中使用额外的语法。如果该文件包含以管道符号（`|`）开头的字符串，那么文件中的其余字符将被解释为一个程序——可以包含可选参数，参数中可能包括[表22-1](ch22.html#format_specifiers_for_solidus_proc_solid
    "表22-1. /proc/sys/kernel/core_pattern格式说明符")中显示的`%`格式说明符——该程序将在进程转储核心时执行。核心转储将写入该程序的标准输入，而不是写入文件。有关更多详细信息，请参阅*core(5)*手册页。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some other UNIX implementations provide facilities similar to `core_pattern`.
    For example, in BSD derivatives, the program name is appended to the filename,
    thus `core.`*progname*. Solaris provides a tool (*coreadm*) that allows the user
    to choose the filename and directory where core dump files are placed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他UNIX实现提供类似于`core_pattern`的功能。例如，在BSD衍生系统中，程序名称会附加到文件名，因此为`core.`*progname*。Solaris提供了一个工具（*coreadm*），允许用户选择核心转储文件存放的文件名和目录。
- en: Table 22-1. Format specifiers for `/proc/sys/kernel/core_pattern`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表22-1. `/proc/sys/kernel/core_pattern`格式说明符
- en: '| Specifier | Replaced by |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 说明符 | 被替换为 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%c` | Core file size soft resource limit (bytes; since Linux 2.6.24) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 核心文件大小软资源限制（字节；自Linux 2.6.24以来） |'
- en: '| `%e` | Executable filename (without path prefix) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `%e` | 可执行文件名（无路径前缀） |'
- en: '| `%g` | Real group ID of dumped process |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `%g` | 转储进程的真实组ID |'
- en: '| `%h` | Name of host system |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `%h` | 主机系统名称 |'
- en: '| `%p` | Process ID of dumped process |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | 转储进程的进程ID |'
- en: '| `%s` | Number of signal that terminated process |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 终止进程的信号数量 |'
- en: '| `%t` | Time of dump, in seconds since the Epoch |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `%t` | 转储时间，单位为自纪元以来的秒数 |'
- en: '| `%u` | Real user ID of dumped process |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 转储进程的真实用户ID |'
- en: '| `%%` | A single `%` character |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 单个`%`字符 |'
- en: Special Cases for Delivery, Disposition, and Handling
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递、处理和处理的特殊情况
- en: For certain signals, special rules apply regarding delivery, disposition, and
    handling, as described in this section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些信号，适用有关传递、处理和处理方式的特殊规则，如本节所述。
- en: '`SIGKILL` and `SIGSTOP`'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SIGKILL`和`SIGSTOP`'
- en: It is not possible to change the default action for `SIGKILL`, which always
    terminates a process, and `SIGSTOP`, which always stops a process. Both *signal()*
    and *sigaction()* return an error on attempts to change the disposition of these
    signals. These two signals also can’t be blocked. This is a deliberate design
    decision. Disallowing changes to the default actions of these signals means that
    they can always be used to kill or stop a runaway process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不能更改`SIGKILL`的默认操作，`SIGKILL`始终终止进程，`SIGSTOP`始终停止进程。在尝试更改这些信号的处理方式时，*signal()*和*sigaction()*都会返回错误。这两个信号也无法被阻塞。这是一个故意的设计决策。不允许更改这些信号的默认操作意味着它们始终可以用于杀死或停止失控的进程。
- en: '`SIGCONT` and stop signals'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SIGCONT`和停止信号'
- en: As noted earlier, the `SIGCONT` signal is used to continue a process previously
    stopped by one of the stop signals (`SIGSTOP`, `SIGTSTP`, `SIGTTIN`, and `SIGTTOU`).
    Because of their unique purpose, in certain situations the kernel deals with these
    signals differently from other signals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`SIGCONT`信号用于继续一个之前被停止信号（`SIGSTOP`、`SIGTSTP`、`SIGTTIN`和`SIGTTOU`）停止的进程。由于它们的独特目的，在某些情况下，内核会以不同于其他信号的方式处理这些信号。
- en: If a process is currently stopped, the arrival of a `SIGCONT` signal always
    causes the process to resume, even if the process is currently blocking or ignoring
    `SIGCONT`. This feature is necessary because it would otherwise be impossible
    to resume such stopped processes. (If the stopped process was blocking `SIGCONT`,
    and had established a handler for `SIGCONT`, then, after the process is resumed,
    the handler is invoked only when `SIGCONT` is later unblocked.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程当前已停止，`SIGCONT`信号的到来总是会导致该进程恢复，即使该进程当前阻塞或忽略`SIGCONT`信号。此功能是必要的，因为否则无法恢复这些已停止的进程。（如果停止的进程正在阻塞`SIGCONT`，并且已为`SIGCONT`设立了处理程序，那么在进程恢复后，只有当`SIGCONT`信号稍后解除阻塞时，处理程序才会被调用。）
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: If any other signal is sent to a stopped process, the signal is not actually
    delivered to the process until it is resumed via receipt of a `SIGCONT` signal.
    The one exception is `SIGKILL`, which always kills a process—even one that is
    currently stopped.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向一个已停止的进程发送任何其他信号，信号不会实际传递到该进程，直到进程通过接收到`SIGCONT`信号恢复。唯一的例外是`SIGKILL`，它始终会终止进程——即使该进程当前已停止。
- en: Whenever `SIGCONT` is delivered to a process, any pending stop signals for the
    process are discarded (i.e., the process never sees them). Conversely, if any
    of the stop signals is delivered to a process, then any pending `SIGCONT` signal
    is automatically discarded. These steps are taken in order to prevent the action
    of a `SIGCONT` signal from being subsequently undone by a stop signal that was
    actually sent beforehand, and vice versa.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`SIGCONT`信号发送到进程时，任何待处理的停止信号都会被丢弃（即，进程永远不会看到它们）。相反，如果任何停止信号发送到进程，则任何待处理的`SIGCONT`信号会被自动丢弃。采取这些步骤是为了防止`SIGCONT`信号的作用被之前发送的停止信号撤销，反之亦然。
- en: Don’t change the disposition of ignored terminal-generated signals
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要更改被忽略的终端生成信号的处理方式
- en: If, at the time it was execed, a program finds that the disposition of a terminal-generated
    signals has been set to `SIG_IGN` (ignore), then generally the program should
    not attempt to change the disposition of the signal. This is not a rule enforced
    by the system, but rather a convention that should be followed when writing applications.
    We explain the reasons for this in [Handling Job-Control Signals](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals"). The signals for which this convention is relevant
    are `SIGHUP`, `SIGINT`, `SIGQUIT`, `SIGTTIN`, `SIGTTOU`, and `SIGTSTP`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在程序执行时发现终端生成的信号的处理方式被设置为`SIG_IGN`（忽略），则通常程序不应尝试更改信号的处理方式。这不是系统强制执行的规则，而是在编写应用程序时应遵循的一种约定。我们在[处理作业控制信号](ch34.html#handling_job_control_signals
    "处理作业控制信号")中解释了这样做的原因。与此约定相关的信号包括`SIGHUP`、`SIGINT`、`SIGQUIT`、`SIGTTIN`、`SIGTTOU`和`SIGTSTP`。
- en: Interruptible and Uninterruptible Process Sleep States
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可中断和不可中断的进程休眠状态
- en: 'We need to add a proviso to our earlier statement that `SIGKILL` and `SIGSTOP`
    always act immediately on a process. At various times, the kernel may put a process
    to sleep, and two sleep states are distinguished:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对之前的声明添加一个附加说明，即`SIGKILL`和`SIGSTOP`总是立即作用于进程。在不同的时间，内核可能会让进程进入休眠状态，并且区分两种休眠状态：
- en: '`TASK_INTERRUPTIBLE`: The process is waiting for some event. For example, it
    is waiting for terminal input, for data to be written to a currently empty pipe,
    or for the value of a System V semaphore to be increased. A process may spend
    an arbitrary length of time in this state. If a signal is generated for a process
    in this state, then the operation is interrupted and the process is woken up by
    the delivery of a signal. When listed by *ps(1)*, processes in the `TASK_INTERRUPTIBLE`
    state are marked by the letter *S* in the STAT (process state) field.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TASK_INTERRUPTIBLE`：进程正在等待某个事件。例如，它正在等待终端输入、等待数据写入当前空的管道，或等待一个System V信号量的值被增加。进程可以在此状态下停留任意长度的时间。如果在此状态下为进程生成了信号，则该操作会被中断，并通过发送信号唤醒进程。在*ps(1)*中列出时，处于`TASK_INTERRUPTIBLE`状态的进程在STAT（进程状态）字段中标记为*S*。'
- en: '`TASK_UNINTERRUPTIBLE`: The process is waiting on certain special classes of
    event, such as the completion of a disk I/O. If a signal is generated for a process
    in this state, then the signal is not delivered until the process emerges from
    this state. Processes in the `TASK_UNINTERRUPTIBLE` state are listed by *ps(1)*
    with a *D* in the STAT field.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TASK_UNINTERRUPTIBLE`：进程在等待某些特殊事件的完成，如磁盘I/O的完成。如果在此状态下生成信号，则该信号不会被传递，直到进程退出此状态。处于`TASK_UNINTERRUPTIBLE`状态的进程会在*ps(1)*命令的STAT字段中显示为*D*。'
- en: Because a process normally spends only very brief periods in the `TASK_UNINTERRUPTIBLE`
    state, the fact that a signal is delivered only when the process leaves this state
    is invisible. However, in rare circumstances, a process may remain hung in this
    state, perhaps as the result of a hardware failure, an NFS problem, or a kernel
    bug. In such cases, `SIGKILL` won’t terminate the hung process. If the underlying
    problem can’t otherwise be resolved, then we must restart the system in order
    to eliminate the process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进程通常只在`TASK_UNINTERRUPTIBLE`状态下停留很短时间，因此信号只有在进程离开该状态时才会传递，这通常是不可见的。然而，在少数情况下，进程可能会在该状态下长时间挂起，可能是由于硬件故障、NFS问题或内核错误等原因。在这种情况下，`SIGKILL`无法终止挂起的进程。如果无法通过其他方式解决底层问题，那么我们必须重启系统以消除该进程。
- en: 'The `TASK_INTERRUPTIBLE` and `TASK_UNINTERRUPTIBLE` states are present on most
    UNIX implementations. Starting with kernel 2.6.25, Linux adds a third state to
    address the hanging process problem just described:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`TASK_INTERRUPTIBLE`和`TASK_UNINTERRUPTIBLE`状态存在于大多数UNIX实现中。从内核2.6.25开始，Linux增加了第三种状态，以解决上述挂起进程的问题：'
- en: '`TASK_KILLABLE`: This state is like `TASK_UNINTERRUPTIBLE`, but wakes the process
    if a fatal signal (i.e., one that would kill the process) is received. By converting
    relevant parts of the kernel code to use this state, various scenarios where a
    hung process requires a system restart can be avoided. Instead, the process can
    be killed by sending it a fatal signal. The first piece of kernel code to be converted
    to use `TASK_KILLABLE` was NFS.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TASK_KILLABLE`：此状态类似于`TASK_UNINTERRUPTIBLE`，但当接收到致命信号（即会终止进程的信号）时，会唤醒该进程。通过将内核代码的相关部分改为使用此状态，可以避免需要重启系统的挂起进程的多种情况。相反，可以通过发送致命信号来终止进程。第一个改为使用`TASK_KILLABLE`的内核代码是NFS。'
- en: Hardware-Generated Signals
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件生成的信号
- en: '`SIGBUS`, `SIGFPE`, `SIGILL`, and `SIGSEGV` can be generated as a consequence
    of a hardware exception or, less usually, by being sent by *kill()*. In the case
    of a hardware exception, SUSv3 specifies that the behavior of a process is undefined
    if it returns from a handler for the signal, or if it ignores or blocks the signal.
    The reasons for this are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGBUS`、`SIGFPE`、`SIGILL`和`SIGSEGV`可以作为硬件异常的结果生成，或者（较少）由*kill()*发送。在硬件异常的情况下，SUSv3规定，如果进程从信号处理程序返回，或者忽略或阻塞该信号，则该进程的行为是未定义的。原因如下：'
- en: '*Returning from the signal handler*: Suppose that a machine-language instruction
    generates one of these signals, and a signal handler is consequently invoked.
    On normal return from the handler, the program attempts to resume execution at
    the point where it was interrupted. But this is the very instruction that generated
    the signal in the first place, so the signal is generated once more. The consequence
    is usually that the program goes into an infinite loop, repeatedly calling the
    signal handler.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从信号处理程序返回*：假设机器语言指令生成了其中一个信号，并因此调用了信号处理程序。在正常返回处理程序时，程序尝试从中断的地方继续执行。但这正是最初生成信号的那条指令，因此信号会再次生成。结果通常是程序进入无限循环，反复调用信号处理程序。'
- en: '*Ignoring the signal*: It makes little sense to ignore a hardware-generated
    signal, as it is unclear how a program should continue execution after, say, an
    arithmetic exception. When one of these signals is generated as a consequence
    of a hardware exception, Linux forces its delivery, even if the program has requested
    that the signal be ignored.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*忽略信号*：忽略硬件生成的信号没有太大意义，因为在发生算术异常等情况下，程序如何继续执行并不明确。当这些信号作为硬件异常的结果生成时，Linux会强制传递该信号，即使程序已请求忽略该信号。'
- en: '*Blocking the signal*: As with the previous case, it makes little sense to
    block a hardware-generated signal, as it is unclear how a program should then
    continue execution. On Linux 2.4 and earlier, the kernel simply ignores attempts
    to block a hardware-generated signal; the signal is delivered to the process anyway,
    and then either terminates the process or is caught by a signal handler, if one
    has been established. Starting with Linux 2.6, if the signal is blocked, then
    the process is always immediately killed by that signal, even if the process has
    installed a handler for the signal. (The rationale for the Linux 2.6 change in
    the treatment of blocked hardware-generated signals was that the Linux 2.4 behavior
    hid bugs and could cause deadlocks in threaded programs.)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞信号*：与之前的情况一样，阻塞硬件生成的信号没有太大意义，因为不清楚程序在阻塞信号后应如何继续执行。在Linux 2.4及更早版本中，内核会简单地忽略对硬件生成信号的阻塞尝试；信号无论如何都会被传递给进程，然后要么终止进程，要么如果已安装信号处理程序，则会被该处理程序捕获。从Linux
    2.6开始，如果信号被阻塞，则进程会立即被该信号终止，即使该进程已经为该信号安装了处理程序。（Linux 2.6对阻塞硬件生成信号处理的变化原因是，Linux
    2.4的行为隐藏了BUG，并可能导致多线程程序中的死锁。）'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `signals/demo_SIGFPE.c` program in the source code distribution for this
    book can be used to demonstrate the results of ignoring or blocking `SIGFPE` or
    catching the signal with a handler that performs a normal return.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的源代码分发中的`signals/demo_SIGFPE.c`程序可以用来演示忽略或阻塞`SIGFPE`信号，或使用处理程序捕获信号并执行正常返回的结果。
- en: The correct way to deal with hardware-generated signals is either to accept
    their default action (process termination) or to write handlers that don’t perform
    a normal return. Other than returning normally, a handler can complete execution
    by calling *_exit()* to terminate the process or by calling *siglongjmp()* ([Performing
    a Nonlocal Goto from a Signal Handler](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "Performing a Nonlocal Goto from a Signal Handler")) to ensure that control passes
    to some point in the program other than the instruction that generated the signal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理硬件生成的信号的方法是接受其默认操作（进程终止），或编写不会执行正常返回的处理程序。除了正常返回，处理程序还可以通过调用*_exit()*来终止进程，或者通过调用*siglongjmp()*（[从信号处理程序执行非局部跳转](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "从信号处理程序执行非局部跳转")）来确保控制权转移到程序中生成信号的指令之外的某个位置。
- en: Synchronous and Asynchronous Signal Generation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和异步信号生成
- en: We have already seen that a process generally can’t predict when it will receive
    a signal. We now need to qualify this observation by distinguishing between *synchronous*
    and *asynchronous* signal generation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，进程通常无法预测何时会收到信号。现在，我们需要通过区分*synchronous*（同步）和*asynchronous*（异步）信号生成来进一步说明这一观察。
- en: The model we have implicitly considered so far is *asynchronous* signal generation,
    in which the signal is sent either by another process or generated by the kernel
    for an event that occurs independently of the execution of the process (e.g.,
    the user types the *interrupt* character or a child of this process terminates).
    For asynchronously generated signals, the earlier statement that a process can’t
    predict when the signal will be delivered holds true.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们隐式考虑的模型是*asynchronous*（异步）信号生成，其中信号是由另一个进程发送，或由内核为一个与进程执行无关的事件生成（例如，用户输入*中断*字符，或该进程的子进程终止）。对于异步生成的信号，前述进程无法预测何时接收信号的说法依然成立。
- en: 'However, in some cases, a signal is generated while the process itself is executing.
    We have already seen two examples of this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，信号是在进程执行时生成的。我们已经看到过两个这样的例子：
- en: The hardware-generated signals (`SIGBUS`, `SIGFPE`, `SIGILL`, `SIGSEGV`, and
    `SIGEMT`) described in [Hardware-Generated Signals](ch22.html#hardware-generated_signals
    "Hardware-Generated Signals") are generated as a consequence of executing a specific
    machine-language instruction that results in a hardware exception.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[硬件生成的信号](ch22.html#hardware-generated_signals "硬件生成的信号")（`SIGBUS`、`SIGFPE`、`SIGILL`、`SIGSEGV`和`SIGEMT`）是执行特定机器语言指令时由于硬件异常而生成的信号。'
- en: A process can use *raise()*, *kill()*, or *killpg()* to send a signal to itself.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以使用*raise()*、*kill()*或*killpg()*向自身发送信号。
- en: In these cases, the generation of the signal is *synchronous*—the signal is
    delivered immediately (unless it is blocked, but see [Hardware-Generated Signals](ch22.html#hardware-generated_signals
    "Hardware-Generated Signals") for a discussion of what happens when blocking hardware-generated
    signals). In other words, the earlier statement about the unpredictability of
    the delivery of a signal doesn’t apply. For synchronously generated signals, delivery
    is predictable and reproducible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，信号的生成是*同步的*——信号会立即传递（除非信号被阻塞，但请参见[硬件生成信号](ch22.html#hardware-generated_signals
    "硬件生成信号")，讨论当阻塞硬件生成信号时会发生什么）。换句话说，之前关于信号传递不可预测性的说法并不适用。对于同步生成的信号，传递是可预测且可重现的。
- en: Note that synchronicity is an attribute of how a signal is generated, rather
    than of the signal itself. All signals may be generated synchronously (e.g., when
    a process sends itself a signal using *kill()*) or asynchronously (e.g., when
    the signal is sent by another process using *kill()*).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同步性是信号生成的属性，而不是信号本身的属性。所有信号都可以同步生成（例如，当一个进程使用*kill()*向自己发送信号时）或异步生成（例如，当信号由另一个进程使用*kill()*发送时）。
- en: Timing and Order of Signal Delivery
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号传递的时机和顺序
- en: As the first topic of this section, we consider exactly when a pending signal
    is delivered. We then consider what happens if multiple pending blocked signals
    are simultaneously unblocked.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的第一个话题，我们将讨论待处理信号究竟何时被传递。然后我们将探讨如果多个待处理阻塞信号同时解封会发生什么。
- en: When is a signal delivered?
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 信号何时被传递？
- en: As noted in [Synchronous and Asynchronous Signal Generation](ch22.html#synchronous_and_asynchronous_signal_gene
    "Synchronous and Asynchronous Signal Generation"), synchronously generated signals
    are delivered immediately. For example, a hardware exception triggers an immediate
    signal, and when a process sends itself a signal using *raise()*, the signal is
    delivered before the *raise()* call returns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[同步与异步信号生成](ch22.html#synchronous_and_asynchronous_signal_gene "同步与异步信号生成")中提到的，同步生成的信号会立即传递。例如，硬件异常触发一个立即信号，当进程使用*raise()*向自己发送信号时，信号会在*raise()*调用返回之前传递。
- en: 'When a signal is generated asynchronously, there may be a (small) delay while
    the signal is pending between the time when it was generated and the time it is
    actually delivered, even if we have not blocked the signal. The reason for this
    is that the kernel delivers a pending signal to a process only at the next switch
    from kernel mode to user mode while executing that process. In practice, this
    means the signal is delivered at one of the following times:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号异步生成时，即使信号没有被阻塞，信号在生成与实际传递之间可能会有一个（小的）延迟。造成这种情况的原因是内核仅在进程从内核模式切换到用户模式时传递待处理信号。实际上，这意味着信号会在以下某个时刻传递：
- en: when the process is rescheduled after it earlier timed out (i.e., at the start
    of a time slice); or
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程在先前超时后重新调度时（即在时间片开始时）；或者
- en: at completion of a system call (delivery of the signal may cause a blocking
    system call to complete prematurely).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统调用完成时（信号的传递可能导致阻塞系统调用提前完成）。
- en: Order of delivery of multiple unblocked signals
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个解封信号的传递顺序
- en: If a process has multiple pending signals that are unblocked using *sigprocmask()*,
    then all of these signals are immediately delivered to the process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程有多个待处理信号通过*sigprocmask()*解封，那么所有这些信号会立即传递给该进程。
- en: As currently implemented, the Linux kernel delivers the signals in ascending
    order. For example, if pending `SIGINT` (signal 2) and `SIGQUIT` (signal 3) signals
    were both simultaneously unblocked, then the `SIGINT` signal would be delivered
    before `SIGQUIT`, regardless of the order in which the two signals were generated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前的实现，Linux 内核按升序传递信号。例如，如果待处理的`SIGINT`（信号 2）和`SIGQUIT`（信号 3）信号同时解封，那么`SIGINT`信号会在`SIGQUIT`之前传递，而不管这两个信号是以什么顺序生成的。
- en: We can’t, however, rely on (standard) signals being delivered in any particular
    order, since SUSv3 says that the delivery order of multiple signals is implementation-defined.
    (This statement applies only to standard signals. As we’ll see in [Realtime Signals](ch22.html#realtime_signals
    "Realtime Signals"), the standards governing realtime signals do provide guarantees
    about the order in which multiple unblocked realtime signals are delivered.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能依赖于（标准）信号按特定顺序传递，因为SUSv3规定，多个信号的传递顺序是由实现决定的。（此声明仅适用于标准信号。如我们将在[实时信号](ch22.html#realtime_signals
    "实时信号")中看到的，实时信号的标准确实提供了关于多个未阻塞的实时信号传递顺序的保证。）
- en: When multiple unblocked signals are awaiting delivery, if a switch between kernel
    mode and user mode occurs during the execution of a signal handler, then the execution
    of that handler will be interrupted by the invocation of a second signal handler
    (and so on), as shown in [Figure 22-1](ch22.html#delivery_of_multiple_unblocked_signals
    "Figure 22-1. Delivery of multiple unblocked signals").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个未阻塞的信号等待传递时，如果在执行信号处理程序期间发生从内核模式到用户模式的切换，那么该处理程序的执行将被第二个信号处理程序的调用中断（以此类推），如[图22-1](ch22.html#delivery_of_multiple_unblocked_signals
    "图22-1. 传递多个未阻塞的信号")所示。
- en: '![Delivery of multiple unblocked signals](figs/web/22-1_SIG-C-multisignals-scale90.png.jpg)Figure 22-1. Delivery
    of multiple unblocked signals'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![传递多个未阻塞的信号](figs/web/22-1_SIG-C-multisignals-scale90.png.jpg)图22-1. 传递多个未阻塞的信号'
- en: Implementation and Portability of *signal()*
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*signal()*的实现和可移植性'
- en: 'In this section, we show how to implement *signal()* using *sigaction()*. The
    implementation is straightforward, but needs to account for the fact that, historically
    and across different UNIX implementations, *signal()* has had different semantics.
    In particular, early implementations of signals were unreliable, meaning that:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们展示如何使用*sigaction()*实现*signal()*。实现过程非常简单，但需要考虑到历史上和不同的UNIX实现中，*signal()*具有不同的语义。特别是，早期的信号实现是不可靠的，这意味着：
- en: 'On entry to a signal handler, the disposition of the signal was reset to its
    default. (This corresponds to the `SA_RESETHAND` flag described in [Changing Signal
    Dispositions: *sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()").) In order to have the signal handler
    invoked again for a subsequent delivery of the same signal, the programmer needed
    to make a call to *signal()* from within the handler to explicitly reestablish
    the handler. The problem in this scenario is that there is a small window of time
    between entering the signal handler and reestablishment of the handler, during
    which, if the signal arrives a second time, it would be processed according to
    its default disposition.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入信号处理程序时，信号的处置被重置为默认值。（这对应于[改变信号处理：*sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "改变信号处理：sigaction()")中描述的`SA_RESETHAND`标志。）为了在同一信号再次传递时重新调用信号处理程序，程序员需要在处理程序内部调用*signal()*，显式地重新建立处理程序。在这种情况下的问题是，在进入信号处理程序和重新建立处理程序之间有一个小的时间窗口，在此期间，如果信号再次到达，它将按默认处置处理。
- en: 'Delivery of further occurrences of a signal was not blocked during execution
    of a signal handler. (This corresponds to the `SA_NODEFER` flag described in [Changing
    Signal Dispositions: *sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()").) This meant that if the signal was
    delivered again while the handler was still executing, then the handler would
    be recursively invoked. Given a sufficiently rapid stream of signals, the resulting
    recursive invocations of the handler could overflow the stack.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行信号处理程序期间，进一步的信号发生不会被阻塞。（这对应于[改变信号处理：*sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "改变信号处理：sigaction()")中描述的`SA_NODEFER`标志。）这意味着，如果信号在处理程序仍在执行时再次到达，那么处理程序将被递归调用。若信号流足够快速，信号处理程序的递归调用可能导致栈溢出。
- en: As well as being unreliable, early UNIX implementations did not provide automatic
    restarting of system calls (i.e., the behavior described for the `SA_RESTART`
    flag in [Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不可靠之外，早期的UNIX实现还没有提供系统调用的自动重启（即[中断与系统调用重启](ch21.html#interruption_and_restarting_of_system_ca
    "中断与系统调用重启")中描述的`SA_RESTART`标志的行为）。
- en: The 4.2BSD reliable signals implementation rectified these limitations, and
    several other UNIX implementations followed suit. However, the older semantics
    live on today in the System V implementation of *signal()*, and even contemporary
    standards such as SUSv3 and C99 leave these aspects of *signal()* deliberately
    unspecified.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2BSD可靠信号实现纠正了这些限制，其他几个UNIX实现也跟随其后。然而，较旧的语义仍然存在于System V实现的*signal()*中，即使是现代标准，如SUSv3和C99，仍然故意未指定*signal()*的这些方面。
- en: Tying the above information together, we implement *signal()* as shown in [Example 22-1](ch22.html#an_implementation_of_signal_open_parenth
    "Example 22-1. An implementation of signal()"). By default, this implementation
    provides the modern signal semantics. If compiled with *-DOLD_SIGNAL*, then it
    provides the earlier unreliable signal semantics and doesn’t enable automatic
    restarting of system calls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述信息结合起来，我们实现了*signal()*，如[示例22-1](ch22.html#an_implementation_of_signal_open_parenth
    "示例22-1. 实现signal()")所示。默认情况下，这个实现提供现代的信号语义。如果使用*-DOLD_SIGNAL*编译，则会提供较早的不可靠信号语义，并且不会启用系统调用的自动重启。
- en: Example 22-1. An implementation of *signal()*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例22-1. 实现*signal()*
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some *glibc* details
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一些*glibc*细节
- en: The *glibc* implementation of the *signal()* library function has changed over
    time. In newer versions of the library (*glibc 2* and later), the modern semantics
    are provided by default. In older versions of the library, the earlier unreliable
    (System V-compatible) semantics are provided.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc*对*signal()*库函数的实现随着时间的推移发生了变化。在库的较新版本（*glibc 2*及以后的版本）中，默认提供现代的语义。在库的较旧版本中，提供较早的不可靠（兼容System
    V）的语义。'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux kernel contains an implementation of *signal()* as a system call.
    This implementation provides the older, unreliable semantics. However, *glibc*
    bypasses this system call by providing a *signal()* library function that calls
    *sigaction()*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核包含一个作为系统调用实现的*signal()*。这个实现提供了较老、不可靠的语义。然而，*glibc*通过提供一个调用*sigaction()*的*signal()*库函数，绕过了这个系统调用。
- en: If we want to obtain unreliable signal semantics with modern versions of *glibc*,
    we can explicitly replace our calls to *signal()* with calls to the (nonstandard)
    *sysv_signal()* function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在*glibc*的现代版本中获得不可靠的信号语义，我们可以显式地将对*signal()*的调用替换为对（非标准的）*sysv_signal()*函数的调用。
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns previous signal disposition on success, or `SIG_ERR` on error
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回先前的信号处置，出错时返回`SIG_ERR`
- en: The *sysv_signal()* function takes the same arguments as *signal()*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*sysv_signal()*函数接受与*signal()*相同的参数。'
- en: If the `_BSD_SOURCE` feature test macro is not defined when compiling a program,
    *glibc* implicitly redefines all calls to *signal()* to be calls to *sysv_signal()*,
    meaning that *signal()* has unreliable semantics. By default, `_BSD_SOURCE` *is*
    defined, but it is disabled (unless also explicitly defined) if other feature
    test macros such as `_SVID_SOURCE` or `_XOPEN_SOURCE` are defined when compiling
    a program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译程序时未定义`_BSD_SOURCE`功能测试宏，*glibc*会隐式地将所有对*signal()*的调用重定义为对*sysv_signal()*的调用，这意味着*signal()*具有不可靠的语义。默认情况下，`_BSD_SOURCE`
    *是* 已定义的，但如果在编译程序时定义了其他功能测试宏，如`_SVID_SOURCE`或`_XOPEN_SOURCE`，则会禁用它（除非也显式定义）。
- en: '*sigaction()* is the preferred API for establishing a signal handler'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*sigaction()*是建立信号处理程序的首选API'
- en: Because of the System V versus BSD (and old versus recent *glibc*) portability
    issues described above, it is good practice always to use *sigaction()*, rather
    than *signal()*, to establish signal handlers. We follow this practice throughout
    the remainder of this book. (An alternative is to write our own version of *signal()*,
    probably similar to [Example 22-1](ch22.html#an_implementation_of_signal_open_parenth
    "Example 22-1. An implementation of signal()"), specifying exactly the flags that
    we require, and employ that version with our applications.) Note, however, that
    it is portable (and shorter) to use *signal()* to set the disposition of a signal
    to `SIG_IGN` or `SIG_DFL`, and we’ll often use *signal()* for that purpose.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述的System V与BSD（以及旧版与新版*glibc*）的移植性问题，良好的实践是始终使用*sigaction()*而不是*signal()*来建立信号处理程序。我们在本书的其余部分都遵循这一做法。（一种替代方法是编写我们自己的*signal()*版本，可能类似于[示例22-1](ch22.html#an_implementation_of_signal_open_parenth
    "示例22-1. 实现signal()")，精确指定我们需要的标志，并在我们的应用程序中使用该版本。）然而，请注意，使用*signal()*将信号的处置设置为`SIG_IGN`或`SIG_DFL`是可移植的（并且更简短），我们通常会为了这个目的使用*signal()*。
- en: Realtime Signals
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时信号
- en: 'Realtime signals were defined in POSIX.1b to remedy a number of limitations
    of standard signals. They have the following advantages over standard signals:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实时信号在POSIX.1b中定义，旨在解决标准信号的一些局限性。与标准信号相比，它们具有以下优点：
- en: 'Realtime signals provide an increased range of signals that can be used for
    application-defined purposes. Only two standard signals are freely available for
    application-defined purposes: `SIGUSR1` and `SIGUSR2`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时信号提供了一个更广泛的信号范围，可以用于应用程序自定义目的。只有两个标准信号可以自由地用于应用程序自定义目的：`SIGUSR1`和`SIGUSR2`。
- en: Realtime signals are queued. If multiple instances of a realtime signal are
    sent to a process, then the signal is delivered multiple times. By contrast, if
    we send further instances of a standard signal that is already pending for a process,
    that signal is delivered only once.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时信号是排队的。如果多个实时信号实例发送到一个进程，则该信号会被多次传递。相比之下，如果我们向一个进程发送已经待处理的标准信号的其他实例，该信号仅会传递一次。
- en: When sending a realtime signal, it is possible to specify data (an integer or
    pointer value) that accompanies the signal. The signal handler in the receiving
    process can retrieve this data.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送实时信号时，可以指定与信号一起发送的数据（一个整数或指针值）。接收进程中的信号处理程序可以检索这些数据。
- en: The order of delivery of different realtime signals is guaranteed. If multiple
    different realtime signals are pending, then the lowest-numbered signal is delivered
    first. In other words, signals are prioritized, with lower-numbered signals having
    higher priority. When multiple signals of the same type are queued, they are delivered—along
    with their accompanying data—in the order in which they were sent.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同实时信号的传递顺序是有保障的。如果多个不同的实时信号在等待处理，则最小编号的信号会首先传递。换句话说，信号是有优先级的，编号较小的信号具有更高的优先级。当多个相同类型的信号排队时，它们会按照发送的顺序传递——连同它们的附带数据。
- en: SUSv3 requires that an implementation provide a minimum of `_POSIX_RTSIG_MAX`
    (defined as 8) different realtime signals. The Linux kernel defines 32 different
    realtime signals, numbered from 32 to 63\. The `<signal.h>` header file defines
    the constant `RTSIG_MAX` to indicate the number of available realtime signals,
    and the constants `SIGRTMIN` and `SIGRTMAX` to indicate the lowest and highest
    available realtime signal numbers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求实现提供至少`_POSIX_RTSIG_MAX`（定义为8）种不同的实时信号。Linux内核定义了32种不同的实时信号，编号从32到63。`<signal.h>`头文件定义了常量`RTSIG_MAX`来表示可用的实时信号数量，并且定义了常量`SIGRTMIN`和`SIGRTMAX`，分别表示可用的最小和最大实时信号编号。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On systems employing the LinuxThreads threading implementation, `SIGRTMIN` is
    defined as 35 (rather than 32) to allow for the fact that LinuxThreads makes internal
    use of the first three realtime signals. On systems employing the NPTL threading
    implementation, `SIGRTMIN` is defined as 34 to allow for the fact that NPTL makes
    internal use of the first two realtime signals.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用LinuxThreads线程实现的系统上，`SIGRTMIN`被定义为35（而不是32），以考虑到LinuxThreads内部使用前三个实时信号的事实。在使用NPTL线程实现的系统上，`SIGRTMIN`被定义为34，以考虑到NPTL内部使用前两个实时信号的事实。
- en: Realtime signals are not individually identified by different constants in the
    manner of standard signals. However, an application should not hard-code integer
    values for them, since the range used for realtime signals varies across UNIX
    implementations. Instead, a realtime signal number can be referred to by adding
    a value to `SIGRTMIN`; for example, the expression (*SIGRTMIN + 1*) refers to
    the second realtime signal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实时信号不像标准信号那样通过不同的常量单独标识。然而，应用程序不应为其硬编码整数值，因为实时信号使用的范围在不同的UNIX实现中有所不同。相反，可以通过将一个值添加到`SIGRTMIN`来引用实时信号的编号；例如，表达式（`SIGRTMIN
    + 1`）表示第二个实时信号。
- en: 'Be aware that SUSv3 doesn’t require `SIGRTMAX` and `SIGRTMIN` to be simple
    integer values. They may be defined as functions (as they are on Linux). This
    means that we can’t write code for the preprocessor such as the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SUSv3并不要求`SIGRTMAX`和`SIGRTMIN`是简单的整数值。它们可以被定义为函数（就像在Linux中一样）。这意味着我们不能为预处理器编写如下代码：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead, we must perform equivalent checks at run time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须在运行时执行等效的检查。
- en: Limits on the number of queued realtime signals
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排队的实时信号数量限制
- en: Queuing realtime signals (with associated data) requires that the kernel maintain
    data structures listing the signals queued to each process. Since these data structures
    consume kernel memory, the kernel places limits on the number of realtime signals
    that may be queued.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 排队实时信号（及其相关数据）要求内核维护列出排队到每个进程的信号的数据结构。由于这些数据结构消耗内核内存，内核对可以排队的实时信号数量设置了限制。
- en: 'SUSv3 allows an implementation to place an upper limit on the number of realtime
    signals (of all types) that may be queued to a process, and requires that this
    limit be at least `_POSIX_SIGQUEUE_MAX` (defined as 32). An implementation can
    define the constant `SIGQUEUE_MAX` to indicate the number of realtime signals
    it allows to be queued. It can also make this information available through the
    following call:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3允许实现对可以排队到进程的实时信号（所有类型）数量设置上限，并要求该上限至少为`_POSIX_SIGQUEUE_MAX`（定义为32）。实现可以定义常量`SIGQUEUE_MAX`来指示允许排队的实时信号数量。它还可以通过以下调用提供此信息：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On Linux, this call returns -1\. The reason for this is that Linux employs a
    different model for limiting the number of realtime signals that may be queued
    to a process. In Linux versions up to and including 2.6.7, the kernel enforces
    a system-wide limit on the total number of realtime signals that may be queued
    to all processes. This limit can be viewed and (with privilege) changed via the
    Linux-specific `/proc/sys/kernel/rtsig-max` file. The default value in this file
    is 1024\. The number of currently queued realtime signals can be found in the
    Linux-specific `/proc/sys/kernel/rtsig-nr` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，这个调用返回-1。原因在于Linux采用了不同的模型来限制可以排队到进程的实时信号数量。在Linux 2.6.7及之前的版本中，内核强制对可以排队到所有进程的实时信号总数实施系统范围的限制。这个限制可以通过Linux特有的`/proc/sys/kernel/rtsig-max`文件查看和（具有权限时）更改。此文件中的默认值是1024。目前排队的实时信号数量可以在Linux特有的`/proc/sys/kernel/rtsig-nr`文件中找到。
- en: Starting with Linux 2.6.8, this model was changed, and the aforementioned `/proc`
    interfaces were removed. Under the new model, the `RLIMIT_SIGPENDING` soft resource
    limit defines a limit on the number of signals that can be queued to all processes
    owned by a particular real user ID. We describe this limit further in Section
    36.3.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.6.8开始，这个模型发生了变化，之前的`/proc`接口被移除。在新模型下，`RLIMIT_SIGPENDING`软资源限制定义了一个限制，表示可以排队到所有由特定真实用户ID拥有的进程的信号数量。我们将在第36.3节进一步描述此限制。
- en: Using realtime signals
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用实时信号
- en: 'In order for a pair of processes to send and receive realtime signals, SUSv3
    requires the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一对进程能够发送和接收实时信号，SUSv3要求满足以下条件：
- en: The sending process sends the signal plus its accompanying data using the *sigqueue()*
    system call.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送进程通过使用*sigqueue()*系统调用发送信号及其附带数据。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A realtime signal can also be sent using *kill()*, *killpg()*, and *raise()*.
    However, SUSv3 leaves it as implementation-dependent whether realtime signals
    sent using these interfaces are queued. On Linux, these interfaces do queue realtime
    signals, but on many other UNIX implementations, they do not.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实时信号也可以使用*kill()*, *killpg()*和*raise()*发送。然而，SUSv3没有规定使用这些接口发送的实时信号是否会排队。在Linux中，这些接口会排队实时信号，但在许多其他UNIX实现中，它们不会。
- en: The receiving process establishes a handler for the signal using a call to *sigaction()*
    that specifies the `SA_SIGINFO` flag. This causes the signal handler to be invoked
    with additional arguments, one of which includes the data accompanying the realtime
    signal.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收进程通过调用*sigaction()*并指定`SA_SIGINFO`标志来建立信号处理程序。这会导致信号处理程序在调用时附带额外的参数，其中包括随实时信号一起传递的数据。
- en: Note
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, it is possible to queue realtime signals even if the receiving process
    doesn’t specify the `SA_SIGINFO` flag when establishing the signal handler (although
    it is not then possible to obtain the data associated with the signal in this
    case). However, SUSv3 doesn’t require implementations to guarantee this behavior,
    so we can’t portably rely on it.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux上，即使接收进程在建立信号处理程序时没有指定`SA_SIGINFO`标志，也可以排队实时信号（尽管在这种情况下无法获得与信号相关的数据）。然而，SUSv3并不要求实现保证这种行为，因此我们不能依赖它进行移植。
- en: Sending Realtime Signals
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送实时信号
- en: The *sigqueue()* system call sends the realtime signal specified by *sig* to
    the process specified by *pid*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigqueue()*系统调用将由*sig*指定的实时信号发送到由*pid*指定的进程。'
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'The same permissions are required to send a signal using *sigqueue()* as are
    required with *kill()* (see [Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")). A null signal (i.e., signal 0) can be sent, with
    the same meaning as for *kill()*. (Unlike *kill()*, we can’t use *sigqueue()*
    to send a signal to an entire process group by specifying a negative value in
    *pid*.)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*sigqueue()*发送信号所需的权限与使用*kill()*时所需的权限相同（参见[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")）。可以发送一个空信号（即信号0），其含义与*kill()*中的相同。（与*kill()*不同，我们不能通过在*pid*中指定负值，使用*sigqueue()*向整个进程组发送信号。）
- en: Example 22-2. Using *sigqueue()* to send realtime signals
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 示例22-2. 使用*sigqueue()*发送实时信号
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The *value* argument specifies the data to accompany the signal. This argument
    has the following form:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*value*参数指定与信号一起发送的数据。该参数具有以下形式：'
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interpretation of this argument is application-dependent, as is the choice
    of whether to set the *sival_int* or the *sival_ptr* field of the union. The *sival_ptr*
    field is seldom useful with *sigqueue()*, since a pointer value that is useful
    in one process is rarely meaningful in another process. However, this field is
    useful in other functions that employ *sigval* unions, as we’ll see when we consider
    POSIX timers in [POSIX Interval Timers](ch23.html#posix_interval_timers "POSIX
    Interval Timers") and POSIX message queue notification in Section 52.6.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数的解释依赖于应用程序，选择设置*union*中的*sival_int*还是*sival_ptr*字段也是如此。由于在一个进程中有用的指针值在另一个进程中很少有意义，因此*sival_ptr*字段在*sigqueue()*中很少使用。然而，在其他使用*sigval*联合的函数中，这个字段是有用的，正如我们在[POSIX定时器](ch23.html#posix_interval_timers
    "POSIX Interval Timers")和第52.6节中的POSIX消息队列通知中将看到的那样。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Several UNIX implementations, including Linux, define a *sigval_t* data type
    as a synonym for *union sigval*. However, this type is not specified in SUSv3
    and is not available on some implementations. Portable applications should avoid
    using it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现，包括Linux，将*sigval_t*数据类型定义为*union sigval*的同义词。然而，这种类型在SUSv3中并未指定，并且在一些实现中不可用。可移植的应用程序应避免使用它。
- en: A call to *sigqueue()* may fail if the limit on the number of queued signals
    has been reached. In this case, *errno* is set to `EAGAIN`, indicating that we
    need to send the signal again (at some later time when some of the currently queued
    signals have been delivered).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果达到队列信号的数量限制，调用*sigqueue()*可能会失败。在这种情况下，*errno*将被设置为`EAGAIN`，表示我们需要稍后重新发送信号（当一些当前排队的信号被传递之后）。
- en: 'An example of the use of *sigqueue()* is provided in [Example 22-2](ch22.html#using_sigqueue_open_parenthesis_close_pa
    "Example 22-2. Using sigqueue() to send realtime signals") (page 459). This program
    takes up to four arguments, of which the first three are mandatory: a signal number,
    a target process ID, and an integer value to accompany the realtime signal. If
    more than one instance of the specified signal is to be sent, the optional fourth
    argument specifies the number of instances; in this case, the accompanying integer
    data value is incremented by one for each successive signal. We demonstrate the
    use of this program in [Sending Realtime Signals](ch22.html#sending_realtime_signals
    "Sending Realtime Signals").'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigqueue()*的使用示例可以在[示例22-2](ch22.html#using_sigqueue_open_parenthesis_close_pa
    "示例22-2. 使用sigqueue()发送实时信号")（第459页）中找到。该程序最多接受四个参数，其中前三个是必需的：信号号、目标进程ID和附带实时信号的整数值。如果要发送多个实例的指定信号，第四个可选参数指定实例的数量；在这种情况下，附带的整数数据值会随着每个连续信号递增。我们在[发送实时信号](ch22.html#sending_realtime_signals
    "发送实时信号")中演示了该程序的使用。'
- en: Handling Realtime Signals
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理实时信号
- en: 'We can handle realtime signals just like standard signals, using a normal (single-argument)
    signal handler. Alternatively, we can handle a realtime signal using a three-argument
    signal handler established using the `SA_SIGINFO` flag ([The `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag
    "The SA_SIGINFO Flag")). Here is an example of using `SA_SIGINFO` to establish
    a handler for the sixth realtime signal:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理标准信号一样处理实时信号，使用普通的（单参数）信号处理程序。或者，我们可以使用`SA_SIGINFO`标志建立一个三参数信号处理程序来处理实时信号（参见[SA_SIGINFO标志](ch21.html#the_sa_underscore_siginfo_flag
    "SA_SIGINFO标志")）。下面是一个使用`SA_SIGINFO`为第六个实时信号建立处理程序的示例：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we employ the `SA_SIGINFO` flag, the second argument passed to the signal
    handler is a *siginfo_t* structure that contains additional information about
    the realtime signal. We described this structure in detail in Section 21.4\. For
    a realtime signal, the following fields are set in the *siginfo_t* structure:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `SA_SIGINFO` 标志时，传递给信号处理程序的第二个参数是一个 *siginfo_t* 结构，其中包含有关实时信号的附加信息。我们在第
    21.4 节中详细描述了该结构。对于实时信号，以下字段在 *siginfo_t* 结构中设置：
- en: The *si_signo* field is the same value as is passed in the first argument of
    the signal handler.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_signo* 字段与传递给信号处理程序的第一个参数中的值相同。'
- en: The *si_code* field indicates the source of the signal, and contains one of
    the values shown in [Table 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "Table 21-2. Values returned in the si_code field of the siginfo_t structure")
    (page 441). For a realtime signal sent via *sigqueue()*, this field always has
    the value `SI_QUEUE`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_code* 字段指示信号的来源，并包含 [表 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "表 21-2. si_code 字段中返回的值")（第 441 页）中显示的一个值。对于通过 *sigqueue()* 发送的实时信号，该字段始终具有值
    `SI_QUEUE`。'
- en: The *si_value* field contains the data specified in the *value* argument (the
    *sigval* union) by the process that sent the signal using *sigqueue()*. As noted
    already, the interpretation of this data is application-defined. (The *si_value*
    field doesn’t contain valid information if the signal was sent using *kill()*.)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_value* 字段包含由使用 *sigqueue()* 发送信号的进程在 *value* 参数（*sigval* 联合体）中指定的数据。如前所述，数据的解释由应用程序定义。
    （如果信号是通过 *kill()* 发送的，*si_value* 字段不包含有效信息。）'
- en: The *si_pid* and *si_uid* fields contain, respectively, the process ID and real
    user ID of the process sending the signal.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_pid* 和 *si_uid* 字段分别包含发送信号的进程的进程 ID 和真实用户 ID。'
- en: '[Example 22-3](ch22.html#handling_realtime_signals-id1 "Example 22-3. Handling
    realtime signals") provides an example of handling realtime signals. This program
    catches signals and displays various fields from the *siginfo_t* structure passed
    to the signal handler. The program takes two optional integer command-line arguments.
    If the first argument is supplied, the main program blocks all signals, and then
    sleeps for the number of seconds specified by this argument. During this time,
    we can queue multiple realtime signals to the process and observe what happens
    when the signals are unblocked. The second argument specifies the number of seconds
    that the signal handler should sleep before returning. Specifying a nonzero value
    (the default is 1 second) is useful for slowing down the program so that we can
    more easily see what is happening when multiple signals are handled.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-3](ch22.html#handling_realtime_signals-id1 "示例 22-3. 处理实时信号") 提供了处理实时信号的示例。此程序捕获信号并显示传递给信号处理程序的
    *siginfo_t* 结构中的各个字段。该程序接受两个可选的整数命令行参数。如果提供了第一个参数，主程序将屏蔽所有信号，然后按该参数指定的秒数休眠。在此期间，我们可以将多个实时信号排队到进程，并观察在解除屏蔽信号时发生了什么。第二个参数指定信号处理程序在返回之前应休眠的秒数。指定一个非零值（默认值为
    1 秒）对于减缓程序的速度非常有用，这样我们可以更容易地看到处理多个信号时发生的情况。'
- en: 'We can use the program in [Example 22-3](ch22.html#handling_realtime_signals-id1
    "Example 22-3. Handling realtime signals"), along with the program in [Example 22-2](ch22.html#using_sigqueue_open_parenthesis_close_pa
    "Example 22-2. Using sigqueue() to send realtime signals") (`t_sigqueue.c`) to
    explore the behavior of realtime signals, as shown in the following shell session
    log:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [示例 22-3](ch22.html#handling_realtime_signals-id1 "示例 22-3. 处理实时信号")
    中的程序，以及 [示例 22-2](ch22.html#using_sigqueue_open_parenthesis_close_pa "示例 22-2.
    使用 sigqueue() 发送实时信号") (`t_sigqueue.c`) 中的程序来探索实时信号的行为，如以下 shell 会话日志所示：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Eventually, the *catch_rtsigs* program completes sleeping, and displays messages
    as the signal handler catches various signals. (We see a shell prompt mixed with
    the next line of the program’s output because the *catch_rtsigs* program is writing
    output from the background.) We first observe that realtime signals are delivered
    lowest-numbered signal first, and that the *siginfo_t* structure passed to the
    handler includes the process ID and user ID of the process that sent the signal:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，*catch_rtsigs* 程序完成休眠，并显示消息，表示信号处理程序捕获了各种信号。（我们看到 shell 提示符与程序输出的下一行混合在一起，因为
    *catch_rtsigs* 程序正在从后台写输出。）我们首先观察到实时信号是按最小编号信号首先传递的，并且传递给处理程序的 *siginfo_t* 结构包括发送信号的进程的进程
    ID 和用户 ID：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The remaining output is produced by the three instances of the same realtime
    signal. Looking at the *si_value* values, we can see that these signals were delivered
    in the order they were sent:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的输出是由三个相同实时信号的实例产生的。通过查看 *si_value* 值，我们可以看到这些信号是按照它们发送的顺序被传递的：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We continue by using the shell *kill* command to send a signal to the *catch_rtsigs*
    program. As before, we see that the *siginfo_t* structure received by the handler
    includes the process ID and user ID of the sending process, but in this case,
    the *si_code* value is `SI_USER`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 shell *kill* 命令向 *catch_rtsigs* 程序发送信号。如前所述，我们可以看到处理程序接收到的 *siginfo_t*
    结构包含发送进程的进程 ID 和用户 ID，但在这种情况下，*si_code* 值为 `SI_USER`：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 22-3. Handling realtime signals
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 22-3. 处理实时信号
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Waiting for a Signal Using a Mask: *sigsuspend()*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用掩码等待信号：*sigsuspend()*
- en: 'Before we explain what *sigsuspend()* does, we first describe a situation where
    we need to use it. Consider the following scenario that is sometimes encountered
    when programming with signals:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释 *sigsuspend()* 的作用之前，首先描述一个需要使用它的情况。考虑以下在使用信号编程时有时会遇到的场景：
- en: We temporarily block a signal so that the handler for the signal doesn’t interrupt
    the execution of some critical section of code.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们暂时阻塞一个信号，以便信号的处理程序不会中断某些关键代码段的执行。
- en: We unblock the signal, and then suspend execution until the signal is delivered.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们解锁信号，然后暂停执行，直到信号被传递。
- en: In order to do this, we might try using code such as that shown in [Example 22-4](ch22.html#incorrectly_unblocking_and_waiting_for_a
    "Example 22-4. Incorrectly unblocking and waiting for a signal").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们可能会尝试使用像 [示例 22-4](ch22.html#incorrectly_unblocking_and_waiting_for_a
    "示例 22-4. 错误解锁并等待信号") 中展示的代码。
- en: Example 22-4. Incorrectly unblocking and waiting for a signal
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 22-4. 错误解锁并等待信号
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is a problem with the code in [Example 22-4](ch22.html#incorrectly_unblocking_and_waiting_for_a
    "Example 22-4. Incorrectly unblocking and waiting for a signal"). Suppose that
    the `SIGINT` signal is delivered after execution of the second *sigprocmask()*,
    but before the *pause()* call. (The signal might actually have been generated
    at any time during the execution of the critical section, and then be delivered
    only when it is unblocked.) Delivery of the `SIGINT` signal will cause the handler
    to be invoked, and after the handler returns and the main program resumes, the
    *pause()* call will block until a *second* instance of `SIGINT` is delivered.
    This defeats the purpose of the code, which was to unblock `SIGINT` and then wait
    for its *first* occurrence.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-4](ch22.html#incorrectly_unblocking_and_waiting_for_a "示例 22-4. 错误解锁并等待信号")
    中的代码存在问题。假设 `SIGINT` 信号在执行第二次 *sigprocmask()* 后传递，但在 *pause()* 调用之前传递。（信号实际上可能在执行关键代码段期间的任何时候生成，只有在解锁时才会被传递。）`SIGINT`
    信号的传递将导致处理程序被调用，并且在处理程序返回后，主程序恢复执行，*pause()* 调用将阻塞，直到传递一个 *第二次* 的 `SIGINT` 信号。这违背了代码的初衷，即解锁
    `SIGINT` 并等待它的 *第一次* 发生。'
- en: Even if the likelihood of `SIGINT` being generated between the start of the
    critical section (i.e., the first *sigprocmask()* call) and the *pause()* call
    is small, this nevertheless constitutes a bug in the above code. This time-dependent
    bug is an example of a race condition ([Atomicity and Race Conditions](ch05.html#atomicity_and_race_conditions
    "Atomicity and Race Conditions")). Normally, race conditions occur where two processes
    or threads share common resources. However, in this case, the main program is
    racing against its own signal handler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在关键代码段开始（即第一次 *sigprocmask()* 调用）和 *pause()* 调用之间生成 `SIGINT` 信号的可能性较小，但这仍然构成了上述代码中的一个
    bug。这种时间相关的 bug 是竞争条件（[原子性和竞争条件](ch05.html#atomicity_and_race_conditions "原子性和竞争条件"））的一个示例。通常，竞争条件发生在两个进程或线程共享公共资源的情况下。然而，在此情况下，主程序与其自身的信号处理程序发生了竞争。
- en: To avoid this problem, we require a means of *atomically* unblocking a signal
    and suspending the process. That is the purpose of the *sigsuspend()* system call.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要一种方法来 *原子地* 解锁信号并挂起进程。这就是 *sigsuspend()* 系统调用的目的。
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: (Normally) returns -1 with *errno* set to `EINTR`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （通常）返回 -1，并将 *errno* 设置为 `EINTR`。
- en: The *sigsuspend()* system call replaces the process signal mask by the signal
    set pointed to by *mask*, and then suspends execution of the process until a signal
    is caught and its handler returns. Once the handler returns, *sigsuspend()* restores
    the process signal mask to the value it had prior to the call.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling *sigsuspend()* is equivalent to atomically performing these operations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although restoring the old signal mask (i.e., the last step in the above sequence)
    may at first appear inconvenient, it is essential to avoid race conditions in
    situations where we need to repeatedly wait for signals. In such situations, the
    signals must remain blocked except during the *sigsuspend()* calls. If we later
    need to unblock the signals that were blocked prior to the *sigsuspend()* call,
    we can employ a further call to *sigprocmask()*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: When *sigsuspend()* is interrupted by delivery of a signal, it returns -1, with
    *errno* set to `EINTR`. If *mask* doesn’t point to a valid address, *sigsuspend()*
    fails with the error `EFAULT`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 22-5](ch22.html#using_sigsuspend_open_parenthesis_close "Example 22-5. Using
    sigsuspend()") demonstrates the use of *sigsuspend()*. This program performs the
    following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Display the initial value of the process signal mask using the *printSigMask()*
    function ([Example 20-4](ch20.html#functions_for_displaying_signal_sets "Example 20-4. Functions
    for displaying signal sets"), in [Example program](ch20.html#example_program-id22
    "Example program")) ![](figs/web/U001.png).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block `SIGINT` and `SIGQUIT`, and save the original process signal mask ![](figs/web/U002.png).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish the same handler for both `SIGINT` and `SIGQUIT` ![](figs/web/U003.png).
    This handler displays a message, and, if it was invoked via delivery of `SIGQUIT`,
    sets the global variable *gotSigquit*.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop until *gotSigquit* is set ![](figs/web/U004.png). Each loop iteration
    performs the following steps:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the current value of the signal mask using our *printSigMask()* function.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulate a critical section by executing a CPU busy loop for a few seconds.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the mask of pending signals using our *printPendingSigs()* function
    ([Example 20-4](ch20.html#functions_for_displaying_signal_sets "Example 20-4. Functions
    for displaying signal sets")).
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses *sigsuspend()* to unblock `SIGINT` and `SIGQUIT` and wait for a signal
    (if one is not already pending).
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *sigprocmask()* to restore the process signal mask to its original state
    ![](figs/web/U005.png), and then display the signal mask using *printSigMask()*![](figs/web/U006.png).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 22-5. Using *sigsuspend()*
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following shell session log shows an example of what we see when running
    the program in [Example 22-5](ch22.html#using_sigsuspend_open_parenthesis_close
    "Example 22-5. Using sigsuspend()"):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last line of output appeared when the program called *sigsuspend()*, which
    caused `SIGINT` to be unblocked. At that point, the signal handler was called
    and displayed that line of output.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The main program continues its loop:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, we typed *Control-\*, which caused the signal handler to set the
    *gotSigquit* flag, which in turn caused the main program to terminate its loop.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Synchronously Waiting for a Signal
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Waiting for a Signal Using a Mask: *sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "Waiting for a Signal Using a Mask: sigsuspend()"), we saw how to use a signal
    handler plus *sigsuspend()* to suspend execution of a process until a signal is
    delivered. However, the need to write a signal handler and to handle the complexities
    of asynchronous delivery makes this approach cumbersome for some applications.
    Instead, we can use the *sigwaitinfo()* system call to synchronously *accept*
    a signal.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns signal number on success, or -1 on error
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The *sigwaitinfo()* system call suspends execution of the process until one
    of the signals in the signal set pointed to by *set* is delivered. If one of the
    signals in *set* is already pending at the time of the call, *sigwaitinfo()* returns
    immediately. The delivered signal is removed from the process’s list of pending
    signals, and the signal number is returned as the function result. If the *info*
    argument is not `NULL`, then it points to a *siginfo_t* structure that is initialized
    to contain the same information provided to a signal handler taking a *siginfo_t*
    argument ([The `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag "The
    SA_SIGINFO Flag")).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The delivery order and queuing characteristics of signals accepted by *sigwaitinfo()*
    are the same as for signals caught by a signal handler; that is, standard signals
    are not queued, and realtime signals are queued and delivered lowest signal number
    first.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: As well as saving us the extra baggage of writing a signal handler, waiting
    for signals using *sigwaitinfo()* is somewhat faster than the combination of a
    signal handler plus *sigsuspend()* (see Exercise 22-3).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: It usually makes sense to use *sigwaitinfo()* only in conjunction with blocking
    the set of signals for which we were interested in waiting. (We can fetch a pending
    signal with *sigwaitinfo()* even while that signal is blocked.) If we fail to
    do this and a signal arrives before the first, or between successive calls to
    *sigwaitinfo()*, then the signal will be handled according to its current disposition.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: An example of the use of *sigwaitinfo()* is shown in [Example 22-6](ch22.html#synchronously_waiting_for_a_signal_with
    "Example 22-6. Synchronously waiting for a signal with sigwaitinfo()"). This program
    first blocks all signals, then delays for the number of seconds specified in its
    optional command-line argument. This allows signals to be sent to the program
    before *sigwaitinfo()*. The program then loops continuously using *sigwaitinfo()*
    to accept incoming signals, until `SIGINT` or `SIGTERM` is received.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *sigwaitinfo()* 的一个示例在 [示例 22-6](ch22.html#synchronously_waiting_for_a_signal_with
    "示例 22-6. 使用 sigwaitinfo() 同步等待信号") 中展示。该程序首先阻塞所有信号，然后根据其可选命令行参数延迟指定的秒数。这允许在调用
    *sigwaitinfo()* 之前向程序发送信号。然后，程序使用 *sigwaitinfo()* 持续循环，以接受传入的信号，直到接收到 `SIGINT`
    或 `SIGTERM` 信号。
- en: 'The following shell session log demonstrates the use of the program in [Example 22-6](ch22.html#synchronously_waiting_for_a_signal_with
    "Example 22-6. Synchronously waiting for a signal with sigwaitinfo()"). We run
    the program in the background, specifying that it should delay 60 seconds before
    calling *sigwaitinfo()*, and then send it two signals:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 shell 会话日志展示了 [示例 22-6](ch22.html#synchronously_waiting_for_a_signal_with
    "示例 22-6. 使用 sigwaitinfo() 同步等待信号") 中程序的使用。我们在后台运行该程序，指定它在调用 *sigwaitinfo()* 之前延迟
    60 秒，然后发送两个信号给它：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Eventually, the program completes its sleep interval, and the *sigwaitinfo()*
    loop accepts the queued signals. (We see a shell prompt mixed with the next line
    of the program’s output because the *t_sigwaitinfo* program is writing output
    from the background.) As with realtime signals caught with a handler, we see that
    signals are delivered lowest number first, and that the *siginfo_t* structure
    passed to the signal handler allows us to obtain the process ID and user ID of
    the sending process:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，程序完成了它的睡眠间隔，*sigwaitinfo()* 循环接受了排队的信号。（我们看到 shell 提示符和程序输出的下一行混合在一起，因为 *t_sigwaitinfo*
    程序正在从后台写入输出。）与使用处理程序捕获的实时信号一样，我们看到信号是按最小编号优先送达的，并且传递给信号处理程序的 *siginfo_t* 结构允许我们获取发送进程的进程
    ID 和用户 ID：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We continue, using the shell *kill* command to send a signal to the process.
    This time, we see that the *si_code* field is set to `SI_USER` (instead of `SI_QUEUE`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 shell *kill* 命令向进程发送信号。这次，我们看到 *si_code* 字段被设置为 `SI_USER`（而不是 `SI_QUEUE`）：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the output for the accepted `SIGUSR1` signal, we see that the *si_value*
    field has the value 100\. This is the value to which the field was initialized
    by the preceding signal that was sent using *sigqueue()*. We noted earlier that
    the *si_value* field contains valid information only for signals sent using *sigqueue()*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在已接受的 `SIGUSR1` 信号的输出中，我们看到 *si_value* 字段的值为 100。这是通过前一个使用 *sigqueue()* 发送的信号初始化该字段的值。我们之前提到过，*si_value*
    字段仅对于使用 *sigqueue()* 发送的信号包含有效信息。
- en: Example 22-6. Synchronously waiting for a signal with *sigwaitinfo()*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 22-6. 使用 *sigwaitinfo()* 同步等待信号
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The *sigtimedwait()* system call is a variation on *sigwaitinfo()*. The only
    difference is that *sigtimedwait()* allows us to specify a time limit for waiting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigtimedwait()* 系统调用是 *sigwaitinfo()* 的一种变体。唯一的区别是 *sigtimedwait()* 允许我们为等待指定时间限制。'
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns signal number on success, or -1 on error or timeout (`EAGAIN`)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回信号编号，出错或超时时返回 -1（`EAGAIN`）。
- en: 'The *timeout* argument specifies the maximum time that *sigtimedwait()* should
    wait for a signal. It is a pointer to a structure of the following type:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout* 参数指定了 *sigtimedwait()* 等待信号的最大时间。它是指向以下类型结构的指针：'
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The fields of the *timespec* structure are filled in to specify the maximum
    number of seconds and nanoseconds that *sigtimedwait()* should wait. Specifying
    both fields of the structure as 0 causes an immediate timeout—that is, a poll
    to check if any of the specified set of signals is pending. If the call times
    out without a signal being delivered, *sigtimedwait()* fails with the error `EAGAIN`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*timespec* 结构的字段被填充，用于指定 *sigtimedwait()* 应等待的最大秒数和纳秒数。如果将结构的两个字段都指定为 0，将会立即超时——即进行一次轮询以检查是否有指定信号集中的信号待处理。如果调用在没有信号被送达的情况下超时，则
    *sigtimedwait()* 会因错误 `EAGAIN` 而失败。'
- en: If the *timeout* argument is specified as `NULL`, then *sigtimedwait()* is exactly
    equivalent to *sigwaitinfo()*. SUSv3 leaves the meaning of a `NULL` *timeout*
    unspecified, and some UNIX implementations instead interpret this as a poll request
    that returns immediately.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *timeout* 参数被指定为 `NULL`，那么 *sigtimedwait()* 与 *sigwaitinfo()* 完全等价。SUSv3
    并没有明确指定 `NULL` *timeout* 的含义，而一些 UNIX 实现则将其解释为一个立即返回的轮询请求。
- en: Fetching Signals via a File Descriptor
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.22, Linux provides the (nonstandard) *signalfd()* system
    call, which creates a special file descriptor from which signals directed to the
    caller can be read. The *signalfd* mechanism provides an alternative to the use
    of *sigwaitinfo()* for synchronously accepting signals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The *mask* argument is a signal set that specifies the signals that we want
    to be able to read via the *signalfd* file descriptor. As with *sigwaitinfo()*,
    we should normally also block all of the signals in *mask* using *sigprocmask()*,
    so that the signals don’t get handled according to their default dispositions
    before we have a chance to read them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: If *fd* is specified as -1, then *signalfd()* creates a new file descriptor
    that can be used to read the signals in *mask*; otherwise, it modifies the mask
    associated with *fd*, which must be a file descriptor created by a previous call
    to *signalfd()*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial implementation, the *flags* argument was reserved for future
    use and had to be specified as 0\. However, since Linux 2.6.27, two flags are
    supported:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`SFD_CLOEXEC`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Set the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor. This
    flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()").
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`SFD_NONBLOCK`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Set the `O_NONBLOCK` flag on the underlying open file description, so that future
    reads will be nonblocking. This saves additional calls to *fcntl()* to achieve
    the same result.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created the file descriptor, we can then read signals from it using
    *read()*. The buffer given to *read()* must be large enough to hold at least one
    *signalfd_siginfo* structure, defined as follows in `<sys/signalfd.h>`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The fields in this structure return the same information as the similarly named
    fields in the traditional *siginfo_t* structure ([The `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag
    "The SA_SIGINFO Flag")).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Each call to *read()* returns as many *signalfd_siginfo* structures as there
    are signals pending and will fit in the supplied buffer. If no signals are pending
    at the time of the call, then *read()* blocks until a signal arrives. We can also
    use the *fcntl()* `F_SETFL` operation ([Open File Status Flags](ch05.html#open_file_status_flags
    "Open File Status Flags")) to set the `O_NONBLOCK` flag for the file descriptor,
    so that reads are nonblocking and will fail with the error `EAGAIN` if no signals
    are pending.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When a signal is read from a *signalfd* file descriptor, it is consumed and
    ceases to be pending for the process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-7. Using *signalfd()* to read signals
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A *signalfd* file descriptor can be monitored along with other descriptors using
    *select()*, *poll()*, and *epoll* (described in [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models")). Among other uses, this feature provides an alternative to the self-pipe
    trick described in [The Self-Pipe Trick](ch63.html#the_self-pipe_trick "The Self-Pipe
    Trick"). If signals are pending, then these techniques indicate the file descriptor
    as being readable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: When we no longer require a *signalfd* file descriptor, we should close it,
    in order to release the associated kernel resources.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 22-7](ch22.html#using_signalfd_open_parenthesis_close_pa "Example 22-7. Using
    signalfd() to read signals") (in [Interprocess Communication with Signals](ch22.html#interprocess_communication_with_signals
    "Interprocess Communication with Signals")) demonstrates the use of *signalfd()*.
    This program creates a mask of the signal numbers specified in its command-line
    arguments, blocks those signals, and then creates a *signalfd* file descriptor
    to read those signals. It then loops, reading signals from the file descriptor
    and displaying some of the information from the returned *signalfd_siginfo* structure.
    In the following shell session, we run the program in [Example 22-7](ch22.html#using_signalfd_open_parenthesis_close_pa
    "Example 22-7. Using signalfd() to read signals") in the background and send it
    a realtime signal with accompanying data using the program in [Example 22-2](ch22.html#using_sigqueue_open_parenthesis_close_pa
    "Example 22-2. Using sigqueue() to send realtime signals") (`t_sigqueue.c`):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Interprocess Communication with Signals
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From one viewpoint, we can consider signals as a form of interprocess communication
    (IPC). However, signals suffer a number of limitations as an IPC mechanism. First,
    by comparison with other methods of IPC that we examine in later chapters, programming
    with signals is cumbersome and difficult. The reasons for this are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous nature of signals means that we face various problems, including
    reentrancy requirements, race conditions, and the correct handling of global variables
    from signal handlers. (Most of these problems do not occur if we are using *sigwaitinfo()*
    or *signalfd()* to synchronously fetch signals.)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard signals are not queued. Even for realtime signals, there are upper
    limits on the number of signals that may be queued. This means that in order to
    avoid loss of information, the process receiving the signals must have a method
    of informing the sender that it is ready to receive another signal. The most obvious
    method of doing this is for the receiver to send a signal to the sender.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A further problem is that signals carry only a limited amount of information:
    the signal number, and in the case of realtime signals, a word (an integer or
    a pointer) of additional data. This low bandwidth makes signals slow by comparison
    with other methods of IPC such as pipes.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of the above limitations, signals are rarely used for IPC.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Earlier Signal APIs (System V and BSD)
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our discussion of signals has focused on the POSIX signal API. We now briefly
    look at the historical APIs provided by System V and BSD. Although all new applications
    should use the POSIX API, we may encounter these obsolete APIs when porting (usually
    older) applications from other UNIX implementations. Because Linux (like many
    other UNIX implementations) provides System V and BSD compatibility APIs, often
    all that is required to port programs using these older APIs is to recompile them
    on Linux.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The System V signal API
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, one important difference in the System V signal API is that
    when a handler is established with *signal()*, we get the older, unreliable signal
    semantics. This means that the signal is not added to the process signal mask,
    the disposition of the signal is reset to the default when the handler is called,
    and system calls are not automatically restarted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Below, we briefly describe the functions in the System V signal API. The manual
    pages provide full details. SUSv3 specifies all of these functions, but notes
    that the modern POSIX equivalents are preferred. SUSv4 marks these functions obsolete.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On success: returns the previous disposition of *sig*, or `SIG_HOLD` if *sig*
    was previously blocked; on error -1 is returned'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: To establish a signal handler with reliable semantics, System V provided the
    *sigset()* call (with a prototype similar to that of *signal()*). As with *signal()*,
    the *handler* argument for *sigset()* can be specified as `SIG_IGN, SIG_DFL`,
    or the address of a signal handler. Alternatively, it can be specified as `SIG_HOLD`,
    to add the signal to the process signal mask while leaving the disposition of
    the signal unchanged.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If *handler* is specified as anything other than `SIG_HOLD`, *sig* is removed
    from the process signal mask (i.e., if *sig* was blocked, it is unblocked).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always returns -1 with *errno* set to `EINTR`
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The *sighold()* function adds a signal to the process signal mask. The *sigrelse()*
    function removes a signal from the signal mask. The *sigignore()* function sets
    a signal’s disposition to *ignore*. The *sigpause()* function is similar to *sigsuspend()*,
    but removes just one signal from the process signal mask before suspending the
    process until the arrival of a signal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The BSD signal API
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The POSIX signal API drew heavily on the 4.2BSD API, so the BSD functions are
    mainly direct analogs of those in POSIX.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: As with the functions in the System V signal API described above, we present
    the prototypes of the functions in the BSD signal API, and briefly explain the
    operation of each function. Once again, the manual pages provide full details.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The *sigvec()* function is analogous to *sigaction()*. The *vec* and *ovec*
    arguments are pointers to structures of the following type:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The fields of the *sigvec* structure correspond closely with those of the *sigaction*
    structure. The first notable difference is that the *sv_mask* field (the analog
    of *sa_mask*) was an integer rather than a *sigset_t*, which meant that, on 32-bit
    architectures, there was a maximum of 31 different signals. The other difference
    is the use of the `SV_INTERRUPT` flag in the *sv_flags* field (the analog of *sa_flags*).
    Since system call restarting was the default on 4.2BSD, this flag was used to
    specify that slow system calls should be interrupted by signal handlers. (This
    contrasts with the POSIX API, where we must explicitly specify `SA_RESTART` in
    order to enable restarting of system calls when establishing a signal handler
    with *sigaction()*.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return previous signal mask
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always returns -1 with *errno* set to `EINTR`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns signal mask value with bit *sig* set
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The *sigblock()* function adds a set of signals to the process signal mask.
    It is analogous to the *sigprocmask()* `SIG_BLOCK` operation. The *sigsetmask()*
    call specifies an absolute value for the signal mask. It is analogous to the *sigprocmask()*
    `SIG_SETMASK` operation.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The *sigpause()* function is analogous to *sigsuspend()*. Note that this function
    is defined with different calling signatures in the System V and BSD APIs. The
    GNU C library provides the System V version by default, unless we specify the
    `_BSD_SOURCE` feature test macro when compiling a program.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'The *sigmask()* macro turns a signal number into the corresponding 32-bit mask
    value. Such bit masks can then be ORed together to create a set of signals, as
    in the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Certain signals cause a process to create a core dump and terminate. Core dumps
    contain information that can be used by a debugger to inspect the state of a process
    at the time that it terminated. By default, a core dump file is named `core`,
    but Linux provides the `/proc/sys/kernel/core_pattern` file to control the naming
    of core dump files.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A signal may be generated asynchronously or synchronously. Asynchronous generation
    occurs when a signal is sent a process by the kernel or by another process. A
    process can’t predict precisely when an asynchronously generated signal will be
    delivered. (We noted that asynchronous signals are normally delivered the next
    time the receiving process switches from kernel mode to user mode.) Synchronous
    generation occurs when the process itself executes code that directly generates
    the signal—for example, by executing an instruction that causes a hardware exception
    or by calling *raise()*. The delivery of a synchronously generated signal is precisely
    predictable (it occurs immediately).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Realtime signals are a POSIX addition to the original signal model, and differ
    from standard signals in that they are queued, have a specified delivery order,
    and can be sent with an accompanying piece of data. Realtime signals are designed
    to be used for application-defined purposes. A realtime signal is sent using the
    *sigqueue()* system call, and an additional argument (the *siginfo_t* structure)
    is supplied to the signal handler so that it can obtain the data accompanying
    the signal, as well as the process ID and real user ID of the sending process.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The *sigsuspend()* system call allows a program to atomically modify the process
    signal mask and suspend execution until a signal arrives, The atomicity of *sigsuspend()*
    is essential to avoid race conditions when unblocking a signal and then suspending
    execution until that signal arrives.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We can use *sigwaitinfo()* and *sigtimedwait()* to synchronously wait for a
    signal. This saves us the work of designing and writing a signal handler, which
    may be unnecessary if our only aim is to wait for the delivery of a signal.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Like *sigwaitinfo()* and *sigtimedwait()*, the Linux-specific *signalfd()* system
    call can be used to synchronously wait for a signal. The distinctive feature of
    this interface is that signals can be read via a file descriptor. This file descriptor
    can also be monitored using *select()*, *poll()*, and *epoll*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Although signals can be viewed as a method of IPC, many factors make them generally
    unsuitable for this purpose, including their asynchronous nature, the fact that
    they are not queued, and their low bandwidth. More usually, signals are used as
    a method of process synchronization and for a variety of other purposes (e.g.,
    event notification, job control, and timer expiration).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Although the fundamental signal concepts are straightforward, our discussion
    has stretched over three chapters, since there were many details to cover. Signals
    play an important role in various parts of the system call API, and we’ll revisit
    their use in several later chapters. In addition, various signal-related functions
    are specific to threads (e.g., *pthread_kill()* and *pthread_sigmask()*), and
    we defer discussion of these functions until Section 33.2.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See the sources listed in [Summary](ch20.html#summary-id19 "Summary").
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Special Cases for Delivery, Disposition, and Handling](ch22.html#special_cases_for_delivery_comma_disposi
    "Special Cases for Delivery, Disposition, and Handling") noted that if a stopped
    process that has established a handler for and blocked `SIGCONT` is later resumed
    as a consequence of receiving a `SIGCONT`, then the handler is invoked only when
    `SIGCONT` is unblocked. Write a program to verify this. Recall that a process
    can be stopped by typing the terminal *suspend* character (usually *Control-Z*)
    and can be sent a `SIGCONT` signal using the command *kill -CONT* (or implicitly,
    using the shell *fg* command).'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both a realtime and a standard signal are pending for a process, SUSv3 leaves
    it unspecified which is delivered first. Write a program that shows what Linux
    does in this case. (Have the program set up a handler for all signals, block signals
    for a period time so that you can send various signals to it, and then unblock
    all signals.)
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Synchronously Waiting for a Signal](ch22.html#synchronously_waiting_for_a_signal
    "Synchronously Waiting for a Signal") stated that accepting signals using *sigwaitinfo()*
    is faster than the use of a signal handler plus *sigsuspend()*. The program `signals/sig_speed_sigsuspend.c`,
    supplied in the source code distribution for this book, uses *sigsuspend()* to
    alternately send signals back and forward between a parent and a child process.
    Time the operation of this program to exchange one million signals between the
    two processes. (The number of signals to exchange is provided as a command-line
    argument to the program.) Create a modified version of the program that instead
    uses *sigwaitinfo()*, and time that version. What is the speed difference between
    the two programs?'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the System V functions *sigset()*, *sighold()*, *sigrelse()*, *sigignore()*,
    and *sigpause()* using the POSIX signal API.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
