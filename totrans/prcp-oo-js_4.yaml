- en: Chapter 4. Constructors and Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be able to get pretty far in JavaScript without understanding constructors
    and prototypes, but you won’t truly appreciate the language without a good grasp
    of them. Because JavaScript lacks classes, it turns to constructors and prototypes
    to bring a similar order to objects. But just because some of the patterns resemble
    classes doesn’t mean they behave the same way. In this chapter, you’ll explore
    constructors and prototypes in detail to see how JavaScript uses them to create
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *constructor* is simply a function that is used with `new` to create an object.
    Up to this point, you’ve seen several of the built-in JavaScript constructors,
    such as `Object`, `Array`, and `Function`. The advantage of constructors is that
    objects created with the same constructor contain the same properties and methods.
    If you want to create multiple similar objects, you can create your own constructors
    and therefore your own reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a constructor is just a function, you define it in the same way. The
    only difference is that constructor names should begin with a capital letter,
    to distinguish them from other functions. For example, look at the following empty
    `Person` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function is a constructor, but there is absolutely no syntactic difference
    between this and any other function. The clue that `Person` is a constructor is
    in the name—the first letter is capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the constructor is defined, you can start creating instances, like the
    following two `Person` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have no parameters to pass into your constructor, you can even omit
    the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the `Person` constructor doesn’t explicitly return anything, both
    `person1` and `person2` are considered instances of the new `Person` type. The
    `new` operator automatically creates an object of the given type and returns it.
    That also means you can use the `instanceof` operator to deduce an object’s type.
    The following code shows `instanceof` in action with the newly created objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because `person1` and `person2` were created with the `Person` constructor,
    `instanceof` returns `true` when it checks whether these objects are instances
    of the `Person` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the type of an instance using the `constructor` property.
    Every object instance is automatically created with a `constructor` property that
    contains a reference to the constructor function that created it. For *generic*
    objects (those created via an object literal or the `Object` constructor), `constructor`
    is set to `Object`; for objects created with a custom constructor, `constructor`
    points back to that constructor function instead. For example, `Person` is the
    `constructor` property for `person1` and `person2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `console.log` function outputs `true` in both cases, because both objects
    were created with the `Person` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this relationship exists between an instance and its constructor,
    you are still advised to use `instanceof` to check the type of an instance. This
    is because the `constructor` property can be overwritten and therefore may not
    be completely accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, an empty constructor function isn’t very useful. The whole point
    of a constructor is to make it easy to create more objects with the same properties
    and methods. To do that, simply add any properties you want to `this` inside of
    the constructor, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This version of the `Person` constructor accepts a single named parameter, `name`,
    and assigns it to the `name` property of the `this` object ❶. The constructor
    also adds a `sayName()` method to the object ❷. The `this` object is automatically
    created by `new` when you call the constructor, and it is an instance of the constructor’s
    type. (In this case, `this` is an instance of `Person`.) There’s no need to return
    a value from the function because the `new` operator produces the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the `Person` constructor to create objects with an initialized
    `name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each object has its own `name` property, so `sayName()` should return different
    values depending on the object on which you use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You can also explicitly call return inside of a constructor. If the returned
    value is an object, it will be returned instead of the newly created object instance.
    If the returned value is a primitive, the newly created object is used and the
    returned value is ignored.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors allow you to initialize an instance of a type in a consistent
    way, performing all of the property setup that is necessary before the object
    can be used. For example, you could also use `Object.defineProperty()` inside
    of a constructor to help initialize the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the `Person` constructor, the `name` property is an accessor
    property that uses the `name` parameter for storing the actual name. This is possible
    because named parameters act like local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to always call constructors with `new`; otherwise, you risk changing
    the global object instead of the newly created object. Consider what happens in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When `Person` is called as a function without `new`, the value of `this` inside
    of the constructor is equal to the global `this` object. The variable `person1`
    doesn’t contain a value because the `Person` constructor relies on `new` to supply
    a return value. Without `new`, `Person` is just a function without a `return`
    statement. The assignment to `this.name` actually creates a global variable called
    `name`, which is where the name passed to `Person` is stored. [Chapter 6](ch06.html
    "Chapter 6. Object Patterns") describes a solution to both this problem and more
    complex object composition patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*An error occurs if you call the Person constructor in strict mode without
    using new. This is because strict mode doesn’t assign this to the global object.
    Instead, this remains undefined, and an error occurs whenever you attempt to create
    a property on undefined.*'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors allow you to configure object instances with the same properties,
    but constructors alone don’t eliminate code redundancy. In the example code thus
    far, each instance has had its own `sayName()` method even though `sayName()`
    doesn’t change. That means if you have 100 instances of an object, then there
    are 100 copies of a function that do the exact same thing, just with different
    data.
  prefs: []
  type: TYPE_NORMAL
- en: It would be much more efficient if all of the instances shared one method, and
    then that method could use `this.name` to retrieve the appropriate data. This
    is where prototypes come in.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can think of a *prototype* as a recipe for an object. Almost every function
    (with the exception of some built-in functions) has a `prototype` property that
    is used during the creation of new instances. That prototype is shared among all
    of the object instances, and those instances can access properties of the prototype.
    For example, the `hasOwnProperty()` method is defined on the generic `Object`
    prototype, but it can be accessed from any object as if it were an own property,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even though there is no definition for `hasOwnProperty()` on `book`, that method
    can still be accessed as `book.hasOwnProperty()` because the definition does exist
    on `Object.prototype`. Remember that the `in` operator returns `true` for both
    prototype properties *and* own properties.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a Prototype Property
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine whether a property is on the prototype by using a function
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the property is `in` an object but `hasOwnProperty()` returns `false`, then
    the property is on the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: The [[Prototype]] Property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance keeps track of its prototype through an internal property called
    `[[Prototype]]`. This property is a pointer back to the prototype object that
    the instance is using. When you create a new object using `new`, the constructor’s
    `prototype` property is assigned to the `[[Prototype]]` property of that new object.
    [Figure 4-1](ch04.html#left_square_bracketleft_square_br "Figure 4-1. The [[Prototype]]
    properties for person1 and person2 point to the same prototype.") shows how the
    `[[Prototype]]` property lets multiple instances of an object type refer to the
    same prototype, which can reduce code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: '![The [[Prototype]] properties for person1 and person2 point to the same prototype.](figs/web/oojs04_01.png)Figure 4-1. The
    `[[Prototype]]` properties for `person1` and `person2` point to the same prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read the value of the `[[Prototype]]` property by using the `Object.getPrototypeOf()`
    method on an object. For example, the following code checks the `[[Prototype]]`
    of a generic, empty object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For any generic object like this one ❶, `[[Prototype]]` is always a reference
    to `Object.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some JavaScript engines also support a property called __proto__ on all objects.
    This property allows you to both read from and write to the [[Prototype]] property.
    Firefox, Safari, Chrome, and Node.js all support this property, and __proto__
    is on the path for standardization in ECMAScript 6.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test to see if one object is a prototype for another by using
    the `isPrototypeOf()` method, which is included on all objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because `object` is just a generic object, its prototype should be `Object.prototype`,
    meaning `isPrototypeOf()` should return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When a property is read on an object, the JavaScript engine first looks for
    an own property with that name. If the engine finds a correctly named own property,
    it returns that value. If no own property with that name exists on the target
    object, JavaScript searches the `[[Prototype]]` object instead. If a prototype
    property with that name exists, the value of that property is returned. If the
    search concludes without finding a property with the correct name, `undefined`
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following, in which an object is first created without any own
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `toString()` method comes from the prototype and returns
    `"[object Object]"` ❶ by default. If you then define an own property called `toString()`,
    that own property is used whenever `toString()` is called on the object again
    ❷. The own property *shadows* the prototype property, so the prototype property
    of the same name is no longer used. The prototype property is used again only
    if the own property is deleted from the object ❸. (Keep in mind that you can’t
    delete a prototype property from an instance because the `delete` operator acts
    only on own properties.) [Figure 4-2](ch04.html#object_with_no_own_properties_left_paren
    "Figure 4-2. An object with no own properties (top) has only the methods of its
    prototype. Adding a toString() property to the object (middle) replaces the prototype
    property until you delete it (bottom).") shows what is happening in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example also highlights an important concept: You cannot assign a value
    to a prototype property from an instance. As you can see in the middle section
    of [Figure 4-2](ch04.html#object_with_no_own_properties_left_paren "Figure 4-2. An
    object with no own properties (top) has only the methods of its prototype. Adding
    a toString() property to the object (middle) replaces the prototype property until
    you delete it (bottom)."), assigning a value to `toString` creates a new own property
    on the instance, leaving the property on the prototype untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: '![An object with no own properties (top) has only the methods of its prototype.
    Adding a toString() property to the object (middle) replaces the prototype property
    until you delete it (bottom).](figs/web/oojs04_02.png.jpg)Figure 4-2. An object
    with no own properties (top) has only the methods of its prototype. Adding a `toString()`
    property to the object (middle) replaces the prototype property until you delete
    it (bottom).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Prototypes with Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shared nature of prototypes makes them ideal for defining methods once for
    all objects of a given type. Because methods tend to do the same thing for all
    instances, there’s no reason each instance needs its own set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s much more efficient to put the methods on the prototype and then use `this`
    to access the current instance. For example, consider the following new `Person`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the `Person` constructor, `sayName()` is defined on the prototype
    ❶ instead of in the constructor. The object instances work exactly the same as
    the example from earlier in this chapter, even though `sayName()` is now a prototype
    property instead of an own property. Because `person1` and `person2` are each
    base references for their calls to `sayName()`, the `this` value is assigned to
    `person1` and `person2`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also store other types of data on the prototype, but be careful when
    using reference values. Because these values are shared across instances, you
    might not expect one instance to be able to change values that another instance
    will access. This example shows what can happen when you don’t watch where your
    reference values are pointing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `favorites` property ❶ is defined on the prototype, which means `person1.favorites`
    and `person2.favorites` point to the *same array*. Any values you add to either
    person’s `favorites` will be elements in that array on the prototype. That may
    not be the behavior that you actually want, so it’s important to be very careful
    about what you define on the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though you can add properties to the prototype one by one, many developers
    use a more succinct pattern that involves replacing the prototype with an object
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines two methods on the prototype, `sayName()` ❶ and `toString()`
    ❷. This pattern has become quite popular because it eliminates the need to type
    `Person.prototype` multiple times. There is, however, one side effect to be aware
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the object literal notation to overwrite the prototype changed the `constructor`
    property so that it now points to `Object` ❶ instead of `Person`. This happened
    because the `constructor` property exists on the prototype, not on the object
    instance. When a function is created, its `prototype` property is created with
    a `constructor` property equal to the function. This pattern completely overwrites
    the prototype object, which means that `constructor` will come from the newly
    created (generic) object that was assigned to `Person.prototype`. To avoid this,
    restore the `constructor` property to a proper value when overwriting the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `constructor` property is specifically assigned on the
    prototype ❶. It’s good practice to make this the first property on the prototype
    so you don’t forget to include it.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most interesting aspect of the relationships among constructors,
    prototypes, and instances is that there is no direct link between the instance
    and the constructor. There is, however, a direct link between the instance and
    the prototype and between the prototype and the constructor. [Figure 4-3](ch04.html#instance_and_its_constructor_are_linked
    "Figure 4-3. An instance and its constructor are linked via the prototype.") illustrates
    this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '![An instance and its constructor are linked via the prototype.](figs/web/oojs04_03.png.jpg)Figure 4-3. An
    instance and its constructor are linked via the prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: This nature of this relationship means that any disruption between the instance
    and the prototype will also create a disruption between the instance and the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Prototypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because all instances of a particular type reference a shared prototype, you
    can augment all of those objects together at any time. Remember, the `[[Prototype]]`
    property just contains a pointer to the prototype, and any changes to the prototype
    are immediately available on any instance referencing it. That means you can literally
    add new members to a prototype at any point and have those changes reflected on
    existing instances, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `Person` type starts out with only two methods, `sayName()`
    ❶ and `toString()` ❷. Two instances of `Person` are created ❸, and then the `sayHi()`
    ❹ method is added to the prototype. After that point, both instances can now access
    `sayHi()` ❺. The search for a named property happens each time that property is
    accessed, so the experience is seamless.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to modify the prototype at any time has some interesting repercussions
    for sealed and frozen objects. When you use `Object.seal()` or `Object.freeze()`
    on an object, you are acting *solely* on the object instance and the own properties.
    You can’t add new own properties or change existing own properties on frozen objects,
    but you can certainly still add properties on the prototype and continue extending
    those objects, as demonstrated in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there are two instances of `Person`. The first (`person1`)
    is frozen ❶, while the second is a normal object. When you add `sayHi()` to the
    prototype ❷, both `person1` and `person2` attain a new method, seemingly contradicting
    `person1`’s frozen status. The `[[Prototype]]` property is considered an own property
    of the instance, and while the property itself is frozen, the value (an object)
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In practice, you probably won’t use prototypes this way very often when developing
    in JavaScript. However, it’s important to understand the relationships that exist
    between objects and their prototype, and strange examples like this help to illuminate
    the concepts.*'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Object Prototypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you might wonder if prototypes also allow you to modify the built-in
    objects that come standard in the JavaScript engine. The answer is yes. All built-in
    objects have constructors, and therefore, they have prototypes that you can change.
    For instance, adding a new method for use on all arrays is as simple as modifying
    `Array.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This example creates a method called `sum()` on `Array.prototype` that simply
    adds up all of the items in the array and returns the result. The `numbers` array
    automatically has access to that method through the prototype. Inside of `sum()`,
    `this` refers to `numbers`, which is an instance of `Array`, so the method is
    free to use other array methods such as `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that strings, numbers, and Booleans all have built-in primitive
    wrapper types that are used to access primitive values as if they were objects.
    If you modify the primitive wrapper type prototype as in this example, you can
    actually add more functionality to those primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new method called `capitalize()` for strings. The `String`
    type is the primitive wrapper for strings, and modifying its prototype means that
    all strings automatically get those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While it may be fun and interesting to modify built-in objects to experiment
    with functionality, it’s not a good idea to do so in a production environment.
    Developers expect built-in objects to behave a certain way and have certain methods.
    Deliberately altering built-in objects violates those expectations and makes other
    developers unsure how the objects should work.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors are just normal functions that are called with the `new` operator.
    You can define your own constructors anytime you want to create multiple objects
    with the same properties. You can identify objects created from constructors using
    `instanceof` or by accessing their `constructor` property directly.
  prefs: []
  type: TYPE_NORMAL
- en: Every function has a `prototype` property that defines any properties shared
    by objects created with a particular constructor. Shared methods and primitive
    value properties are typically defined on prototypes, while all other properties
    are defined within the constructor. The `constructor` property is actually defined
    on the prototype because it is shared among object instances.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype of an object is stored internally in the `[[Prototype]]` property.
    This property is a reference, not a copy. If you change the prototype at any point
    in time, those changes will occur on all instances because of the way JavaScript
    looks up properties. When you try to access a property on an object, that object
    is searched for any own property with the name you specify. If an own property
    is not found, the prototype is searched. This searching mechanism means the prototype
    can continue to change, and object instances referencing that prototype will reflect
    those changes immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in objects also have prototypes that can be modified. While it’s not recommended
    to do this in production, it can be helpful for experimentation and proofs of
    concept for new functionality.
  prefs: []
  type: TYPE_NORMAL
