<html><head></head><body><section class="chapter" epub:type="chapter" id="capturing_traffic" title="Chapter&#xA0;7.&#xA0;Capturing Traffic"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Capturing Traffic</h2></div></div></div><p><a class="indexterm" id="iddle1163"/>Before we move on to exploitation, we’ll use the Wireshark monitoring tool, as well as other tools, to sniff and manipulate traffic to gain useful information from other machines on the local network. On an internal penetration test, when we’re simulating an insider threat or an attacker who has breached the perimeter, capturing traffic from other systems in the network can give us additional interesting information (perhaps even usernames and passwords) that can help us with exploitation. The trouble is that capturing traffic can produce a massive amount of potentially useful data. Capturing all traffic on just your home network could quickly fill several Wireshark screens, and discovering which traffic is useful for a pentest can be difficult. In this chapter, we’ll look at several ways to manipulate a network to get access to traffic we have no business being able to see.</p><div class="sect1" title="Networking for Capturing Traffic"><div class="titlepage"><div><div><h2 class="title" id="networking_for_capturing_traffic" style="clear: both">Networking for Capturing Traffic</h2></div></div></div><p><a class="indexterm" id="iddle1166"/><a class="indexterm" id="iddle1487"/><a class="indexterm" id="iddle1819"/><a class="indexterm" id="iddle2001"/><a class="indexterm" id="iddle2271"/><a class="indexterm" id="iddle2383"/><a class="indexterm" id="iddle2514"/><a class="indexterm" id="iddle2515"/>If you find yourself in a network that uses hubs rather than switches, capturing traffic not intended for your machine will be easy, because when a network hub receives a packet, it rebroadcasts it on all ports, leaving it up to each device to decide whom the packet belongs to. In a hubbed network, capturing other systems’ traffic is as easy as selecting Use promiscuous mode on all interfaces in Wireshark. This tells our Network Interface Controller (NIC) to grab everything it sees, which in a hubbed network will be every packet.</p><p>Unlike hubs, switches send traffic only to the intended system, so on a switched network, we won’t be able to view, for example, all the traffic to and from the domain controller without fooling the network into sending us that traffic. Most networks you encounter on pentests will probably be switched networks; even some legacy network hardware that claims to be a hub may have the functionality of a switch.</p><p>Virtual networks seem to act like hubs, because all your virtual machines share one physical device. If you capture traffic in promiscuous mode in a virtual network, you may be able to see traffic from every virtual machine as well as the host machine, even if you are using a switch instead of a hub in your environment. To simulate a non-virtualized network, we’ll turn off Use promiscuous mode on all interfaces in Wireshark, which means we will have to work a little harder to capture traffic from our target virtual machines.</p></div><div class="sect1" title="Using Wireshark"><div class="titlepage"><div><div><h2 class="title" id="using_wireshark" style="clear: both">Using Wireshark</h2></div></div></div><p>Wireshark is a graphical network protocol analyzer that lets us take a deep dive into the individual packets moving around the network. Wireshark can be used to capture Ethernet, wireless, Bluetooth, and many other kinds of traffic. It can decode different protocols that it sees, so you could, for instance, reconstruct the audio of Voice over IP (VoIP) phone calls. Let’s take a look at the basics of using Wireshark to capture and analyze traffic.</p><div class="sect2" title="Capturing Traffic"><div class="titlepage"><div><div><h3 class="title" id="capturing_traffic-id00022">Capturing Traffic</h3></div></div></div><p>Let’s start by using Wireshark to capture traffic on our local network. Start Wireshark in Kali, as shown here. Click through any warnings about using Wireshark as root being dangerous.</p><a id="pro_id00087"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>wireshark</strong></span></pre><p>Tell Wireshark to capture on the local network interface (eth0) by selecting <span class="strong"><strong>Capture</strong></span> ▸ <span class="strong"><strong>Options</strong></span>, and selecting the <span class="strong"><strong>eth0</strong></span> option, as shown in <a class="xref" href="ch07.xhtml#starting_a_wireshark_capture" title="Figure 7-1. Starting a Wireshark capture">Figure 7-1</a>. Remember to uncheck the Use promiscuous mode on all interfaces option so that the results will be like those on a physical switched network rather than the VMware network. Exit the Options menu. Finally, click <span class="strong"><strong>Capture</strong></span> ▸ <span class="strong"><strong>Start</strong></span> to begin the traffic capture.</p><p><a class="indexterm" id="iddle1050"/><a class="indexterm" id="iddle1424"/>You should start to see traffic coming in, and you should be able to capture all traffic intended for the Kali machine as well as any broadcast traffic (traffic sent to the entire network).</p><div class="figure"><a id="starting_a_wireshark_capture"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00083"/><img alt="Starting a Wireshark capture" src="httpatomoreillycomsourcenostarchimages2030356.png.jpg"/></div></div><div class="figure-title">Figure 7-1. Starting a Wireshark capture</div></div><p>To illustrate the traffic we can capture in a switched network, let’s start by contacting our Windows XP target from our Kali machine over FTP. Log in as <span class="emphasis"><em>anonymous</em></span>, as shown in <a class="xref" href="ch07.xhtml#logging_in_via_ftp" title="Example 7-1. Logging in via FTP">Example 7-1</a>, to see the captured traffic in Wireshark. (In the previous chapter, we discovered that the <span class="emphasis"><em>anonymous</em></span> user is allowed on the Windows XP target. Although <span class="emphasis"><em>anonymous</em></span> requires that you enter a password, it doesn’t matter what it is. Traditionally, it is an email address, but the FTP server will accept whatever you would like to use.)</p><div class="example"><a id="logging_in_via_ftp"/><div class="example-title">Example 7-1. Logging in via FTP</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>ftp 192.168.20.10</strong></span>&#13;
Connected to 192.168.20.10.&#13;
220-FileZilla Server version 0.9.32 beta&#13;
220-written by Tim Kosse (Tim.Kosse@gmx.de)&#13;
220 Please visit http://sourceforge.net/projects/filezilla/&#13;
Name (192.168.20.10:root): <span class="strong"><strong>anonymous</strong></span>&#13;
331 Password required for anonymous&#13;
Password:&#13;
230 Logged on&#13;
Remote system type is UNIX.&#13;
ftp&gt;</pre></div></div><p><a class="indexterm" id="iddle2517"/>You should see packets in Wireshark from the system with IP address 192.168.20.9 to 192.168.20.10 and vice versa, with the Protocol field marked as FTP. Wireshark is capturing the traffic moving to and from our Kali machine.</p><p>Switch over to your Ubuntu Linux target machine, and log in to the FTP server on the Windows XP target. Looking back at Wireshark in Kali, you should see that no additional FTP packets have been captured. In our simulated switched network, any traffic not destined for our Kali machine will not be seen by the network interface and, thus, will not be captured by Wireshark. (We’ll learn how to rectify this situation and capture other systems’ traffic in <a class="xref" href="ch07.xhtml#arp_cache_poisoning" title="ARP Cache Poisoning">ARP Cache Poisoning</a>.)</p></div><div class="sect2" title="Filtering Traffic"><div class="titlepage"><div><div><h3 class="title" id="filtering_traffic">Filtering Traffic</h3></div></div></div><p>The sheer volume of network traffic captured by Wireshark can be a bit overwhelming because, in addition to our FTP traffic, every other packet to or from the Kali system is captured. To find specific interesting packets, we can use Wireshark filters. The Filter field is located at the top left of the Wireshark GUI. As a very simple first Wireshark filtering example, let’s look for all traffic that uses the FTP protocol. Enter <span class="strong"><strong><code class="literal">ftp</code></strong></span> in the Filter field and click <span class="strong"><strong>Apply</strong></span>, as shown in <a class="xref" href="ch07.xhtml#filtering_traffic_in_wireshark" title="Figure 7-2. Filtering traffic in Wireshark">Figure 7-2</a>.</p><div class="figure"><a id="filtering_traffic_in_wireshark"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00084"/><img alt="Filtering traffic in Wireshark" src="httpatomoreillycomsourcenostarchimages2030358.png.jpg"/></div></div><div class="figure-title">Figure 7-2. Filtering traffic in Wireshark</div></div><p>As expected, Wireshark filters the captured packets to show only those that use the FTP protocol. We can see our entire FTP conversation, including our login information, in plaintext.</p><p><a class="indexterm" id="iddle2284"/><a class="indexterm" id="iddle2518"/>We can use more advanced filters to further fine-tune the packets returned. For example, we can use the filter <span class="emphasis"><em>ip.dst==192.168.20.10</em></span> to return only packets with the destination IP address 192.168.20.10. We can even chain filters together, such as using the filter <span class="emphasis"><em>ip.dst==192.168.20.10 and ftp</em></span> to find only FTP traffic destined for 192.168.20.10.</p></div><div class="sect2" title="Following a TCP Stream"><div class="titlepage"><div><div><h3 class="title" id="following_a_tcp_stream">Following a TCP Stream</h3></div></div></div><p>Even after filtering traffic, there may be multiple FTP connections captured during the same time frame, so it could still be difficult to tell what’s going on. But once we find an interesting packet, such as the beginning of an FTP login, we can dig deeper into the conversation by right-clicking the packet and selecting <span class="strong"><strong>Follow TCP Stream</strong></span>, as shown in <a class="xref" href="ch07.xhtml#following_the_tcp_stream_in_wireshark" title="Figure 7-3. Following the TCP stream in Wireshark">Figure 7-3</a>.</p><div class="figure"><a id="following_the_tcp_stream_in_wireshark"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00085"/><img alt="Following the TCP stream in Wireshark" src="httpatomoreillycomsourcenostarchimages2030360.png.jpg"/></div></div><div class="figure-title">Figure 7-3. Following the TCP stream in Wireshark</div></div><p>The resulting screen will show us the full contents of our FTP connection, including its credentials in plaintext, as shown in <a class="xref" href="ch07.xhtml#ftp_login_conversation" title="Example 7-2. FTP login conversation">Example 7-2</a>.</p><div class="example"><a id="ftp_login_conversation"/><div class="example-title">Example 7-2. FTP login conversation</div><div class="example-contents"><pre class="programlisting">220-FileZilla Server version 0.9.32 beta&#13;
220-written by Tim Kosse (Tim.Kosse@gmx.de)&#13;
220 Please visit http://sourceforge.net/projects/filezilla/&#13;
USER anonymous&#13;
331 Password required for anonymous&#13;
PASS georgia@bulbsecurity.com&#13;
230 Logged on&#13;
SYST&#13;
215 UNIX emulated by FileZilla</pre></div></div></div><div class="sect2" title="Dissecting Packets"><div class="titlepage"><div><div><h3 class="title" id="dissecting_packets">Dissecting Packets</h3></div></div></div><p><a class="indexterm" id="iddle1070"/><a class="indexterm" id="iddle1164"/><a class="indexterm" id="iddle1222"/><a class="indexterm" id="iddle1661"/><a class="indexterm" id="iddle2516"/>By selecting a specific captured packet, we can get more information about the captured data, as shown in <a class="xref" href="ch07.xhtml#packet_details_in_wireshark" title="Figure 7-4. Packet details in Wireshark">Figure 7-4</a>. At the bottom of the Wireshark screen, you can see details of the selected packet. With a little guidance, Wireshark will break down the data for you. For example, we can easily find the TCP destination port by selecting the TCP entry and looking for Destination port, as highlighted in the figure. When we select this field, the entry in the raw bytes of the packet is highlighted as well.</p><div class="figure"><a id="packet_details_in_wireshark"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00086"/><img alt="Packet details in Wireshark" src="httpatomoreillycomsourcenostarchimages2030362.png"/></div></div><div class="figure-title">Figure 7-4. Packet details in Wireshark</div></div></div></div><div class="sect1" title="ARP Cache Poisoning"><div class="titlepage"><div><div><h2 class="title" id="arp_cache_poisoning" style="clear: both">ARP Cache Poisoning</h2></div></div></div><p>While it is nice to see the details of our own traffic, for pentesting purposes, it would be preferable to see the traffic that wasn’t intended for our Kali system. Perhaps we’ll be able to capture another user’s login session that uses an account other than <span class="emphasis"><em>anonymous</em></span> to log in; that would give us working credentials for the FTP server, as well as a set of credentials that might be reused elsewhere in the environment.</p><p>To capture traffic not intended for the Kali system, we need to find some way to have the relevant data sent to our Kali system. Because the network switch will send only packets that belong to us, we need to trick our target machine or the switch (or ideally both) into believing the traffic belongs to us. We will perform a so-called man-in-the-middle attack, which <a class="indexterm" id="iddle1015"/><a class="indexterm" id="iddle1069"/><a class="indexterm" id="iddle1558"/><a class="indexterm" id="iddle1649"/><a class="indexterm" id="iddle1669"/><a class="indexterm" id="iddle1676"/>will allow us to redirect and intercept traffic between two systems (other than our own system) before forwarding packets on to the correct destination. One tried-and-true technique for masquerading as another device on the network is called <span class="emphasis"><em>Address Resolution Protocol (ARP) cache poisoning</em></span> (also known as <span class="emphasis"><em>ARP spoofing</em></span>).</p><div class="sect2" title="ARP Basics"><div class="titlepage"><div><div><h3 class="title" id="arp_basics">ARP Basics</h3></div></div></div><p>When we connect to another machine on our local network, we usually use its hostname, fully qualified domain name, or IP address. (We’ll look at domain name server cache poisoning in <a class="xref" href="ch07.xhtml#dns_cache_poisoning" title="DNS Cache Poisoning">DNS Cache Poisoning</a>.) Before a packet can be sent from our Kali machine to the Windows XP target, Kali must map the IP address of the XP target machine to the Media Access Control (MAC) address of the network interface card (NIC) so Kali knows where on the network to send the packet. To do this, it uses ARP to broadcast “Who has IP address 192.168.20.10?” on the local network. The machine with the IP address 192.168.20.10 writes back, “I have 192.168.20.10, and my MAC address is 00:0c:29:a9:ce:92.” In our case this will be the Windows XP target. Our Kali system will store the mapping from IP address 192.168.20.10 to the MAC address 00:0c:29:a9:ce:92 in its ARP cache.</p><p>When it sends the next packet, our machine will first look to its ARP cache for an entry for 192.168.20.10. If it finds one, it will use that entry as the address of the target rather than sending another ARP broadcast. (ARP cache entries are flushed out regularly because network topology may change at any time.) Thus, systems will regularly be sending ARP broadcasts as their caches are flushed. This process will come in handy when we perform ARP cache poisoning in the next section. The ARP process is illustrated in <a class="xref" href="ch07.xhtml#arp_resolution_process" title="Figure 7-5. ARP resolution process">Figure 7-5</a>.</p><div class="figure"><a id="arp_resolution_process"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00087"/><img alt="ARP resolution process" src="httpatomoreillycomsourcenostarchimages2030364.png.jpg"/></div></div><div class="figure-title">Figure 7-5. ARP resolution process</div></div><p>To view the ARP cache in our Kali machine, enter <span class="strong"><strong><code class="literal">arp</code></strong></span>. Currently, the only IP address–to–MAC address mappings that it knows are 192.168.20.1, the default gateway, as well as 192.168.20.10, the Windows XP machine we engaged in the last exercise.</p><a id="pro_id00088"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>arp</strong></span>&#13;
Address                  HWtype  HWaddress           Flags Mask            Iface&#13;
192.168.20.1             ether   00:23:69:f5:b4:29   C                     eth0&#13;
192.168.20.10            ether   00:0c:29:05:26:4c   C                     eth0</pre><p>Now restart the Wireshark capture, and use the <span class="emphasis"><em>anonymous</em></span> login to interact with the Ubuntu target’s FTP server again. Next, use the <span class="emphasis"><em>arp</em></span> filter, as shown in <a class="xref" href="ch07.xhtml#arp_broadcast_and_reply" title="Figure 7-6. ARP broadcast and reply">Figure 7-6</a>, to see the ARP broadcast from the Kali machine and the reply from the Ubuntu target with its MAC address.</p><div class="figure"><a id="arp_broadcast_and_reply"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00088"/><img alt="ARP broadcast and reply" src="httpatomoreillycomsourcenostarchimages2030366.png.jpg"/></div></div><div class="figure-title">Figure 7-6. ARP broadcast and reply</div></div><p>Check your Kali Linux’s ARP cache again. You should see an entry for 192.168.20.10.</p><a id="pro_id00089"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>arp</strong></span>&#13;
Address                  HWtype  HWaddress           Flags Mask            Iface&#13;
192.168.20.1             ether   00:23:69:f5:b4:29   C                     eth0&#13;
192.168.20.10            ether   00:0c:29:05:26:4c   C                     eth0&#13;
192.168.20.11            ether   80:49:71:14:97:2b   C                     eth0</pre><p>The trouble with relying on ARP for addressing is that there’s no guarantee that the IP address–to–MAC address answer you get is correct. Any machine can reply to an ARP request for 192.168.20.11, even if that machine is really at 192.168.20.12 or some other IP address. The target machine will accept the reply, regardless.</p><p><a class="indexterm" id="iddle1262"/><a class="indexterm" id="iddle1287"/><a class="indexterm" id="iddle1561"/>That’s ARP cache poisoning in a nutshell. We send out a series of ARP replies that tell our target that we are another machine on the network. Thus, when the target sends traffic intended for that machine, it will instead send the packets straight to us to be picked up by our traffic sniffer, as shown in <a class="xref" href="ch07.xhtml#arp_cache_poisoning_redirects_traffic_th" title="Figure 7-7. ARP cache poisoning redirects traffic through Kali.">Figure 7-7</a>.</p><p>Recall from <a class="xref" href="ch07.xhtml" title="Chapter 7. Capturing Traffic">Chapter 7</a> that we initiated an FTP connection from our Ubuntu target to the Windows XP target, but the traffic flowing through that connection was not captured by Wireshark on our Kali system. Using an ARP cache poisoning attack, we can trick the two systems into sending their traffic to our Kali machine instead, to be captured in Wireshark.</p><div class="figure"><a id="arp_cache_poisoning_redirects_traffic_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00089"/><img alt="ARP cache poisoning redirects traffic through Kali." src="httpatomoreillycomsourcenostarchimages2030368.png.jpg"/></div></div><div class="figure-title">Figure 7-7. ARP cache poisoning redirects traffic through Kali.</div></div></div><div class="sect2" title="IP Forwarding"><div class="titlepage"><div><div><h3 class="title" id="ip_forwarding">IP Forwarding</h3></div></div></div><p>But before we can trick the Linux target into sending credentials for the FTP server to us instead, we need to turn on IP forwarding to tell our Kali machine to forward any extraneous packets it receives to their proper destination. Without IP forwarding, we’ll create a <span class="emphasis"><em>denial-of-service (DoS)</em></span> condition on our network, where legitimate clients are unable to access services. For example, if we were to use ARP cache poisoning without IP forwarding to redirect traffic from the Linux target, intended for the Windows XP target, to our Kali machine, the FTP server on the Windows XP machine would never receive the packets from the Linux machine and vice versa.</p><p>The setting for IP forwarding on Kali is in <span class="emphasis"><em>/proc/sys/net/ipv4/ip_forward</em></span>. We need to set this value to <span class="strong"><strong><code class="literal">1</code></strong></span>.</p><a id="pro_id00090"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</strong></span></pre><p><a class="indexterm" id="iddle1071"/><a class="indexterm" id="iddle1076"/>Before we start ARP cache poisoning, note the entry for the Windows XP target (192.168.20.10) in the Linux target’s ARP cache. This value will change to the MAC address of the Kali machine after we commence ARP cache poisoning.</p><a id="pro_id00091"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>arp -a</strong></span>&#13;
? (192.168.20.1) at 00:23:69:f5:b4:29 [ether] on eth2&#13;
? (192.168.20.10) at 00:0c:29:05:26:4c [ether] on eth0&#13;
? (192.168.20.9) at 70:56.81:b2:f0:53 [ether] on eth2</pre></div><div class="sect2" title="ARP Cache Poisoning with Arpspoof"><div class="titlepage"><div><div><h3 class="title" id="arp_cache_poisoning_with_arpspoof">ARP Cache Poisoning with Arpspoof</h3></div></div></div><p>One easy-to-use tool for ARP cache poisoning is Arpspoof. To use Arpspoof, we tell it which network interface to use, the target of our ARP cache poisoning attack, and the IP address we would like to masquerade as. (If you leave out the target, you’ll poison the entire network.) For our example, to fool the Linux target into thinking we are the Windows XP machine, I set the <span class="strong"><strong><code class="literal">-i</code></strong></span> option as eth0 to specify the interface, the <span class="strong"><strong><code class="literal">-t</code></strong></span> option as 192.168.20.11 to specify the target as the Linux box, and 192.168.20.10 as the Windows XP machine I want to pretend to be.</p><a id="pro_id00092"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>arpspoof -i eth0 -t 192.168.20.11 192.168.20.10</strong></span></pre><p>Arpspoof immediately starts sending ARP replies to the Linux target, informing it that the Windows XP machine is located at the Kali machine’s MAC address. (ARP cache entries are updated at varying times among different implementations, but one minute is a safe length of time to wait.)</p><p>To capture the other side of the conversation, we need to fool the Windows XP machine into sending traffic intended for the Linux target to the Kali machine as well. Start another instance of Arpspoof, and this time set the target as the Windows XP machine and the recipient as the Linux machine.</p><a id="pro_id00093"/><pre class="programlisting">root@kali:~#  <span class="strong"><strong>arpspoof -i eth0 -t 192.168.20.10 192.168.20.11</strong></span></pre><p>Once you start ARP cache poisoning, check your Linux target’s ARP cache again. Notice that the MAC address associated with the Windows XP target has changed to 70:56:81:b2:f0:53. The Linux target should send all traffic intended for the Windows XP target to the Kali machine, where we can capture it in Wireshark.</p><a id="pro_id00094"/><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>arp -a</strong></span>&#13;
? (192.168.20.1) at 00:23:69:f5:b4:29 [ether] on eth0&#13;
? (192.168.20.10) at 70:56:81:b2:f0:53 [ether] on eth0</pre><p><a class="indexterm" id="iddle1073"/><a class="indexterm" id="iddle1254"/><a class="indexterm" id="iddle1425"/><a class="indexterm" id="iddle2340"/>Now log in to the Windows XP target’s FTP server from the Linux target using another account (see <a class="xref" href="ch07.xhtml#logging_in_to_ftp_on_windows_xp_from_the" title="Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user account">Example 7-3</a>). (The credentials <span class="emphasis"><em>georgia:password</em></span> will work if you followed my instructions in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>. If you set your credentials as something else, use those instead.)</p><div class="example"><a id="logging_in_to_ftp_on_windows_xp_from_the"/><div class="example-title">Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user account</div><div class="example-contents"><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>ftp 192.168.20.10</strong></span>&#13;
Connected to 192.168.20.10.&#13;
220-FileZilla Server version 0.9.32 beta&#13;
220-written by Tim Kosse (Tim.Kosse@gmx.de)&#13;
220 Please visit http://sourceforge.net/projects/filezilla/&#13;
Name (192.168.20.10:georgia): georgia&#13;
331 Password required for georgia&#13;
Password:&#13;
230 Logged on&#13;
Remote system type is UNIX.</pre></div></div><p>Because we have IP forwarding turned on, everything appears to work normally as far as our user is concerned. Returning to Wireshark, we see that this time we were able to capture the FTP traffic and read the plaintext login credentials. The Wireshark output shown in <a class="xref" href="ch07.xhtml#wireshark_captures_the_login_information" title="Figure 7-8. Wireshark captures the login information.">Figure 7-8</a> confirms that our Kali machine is forwarding the FTP traffic between the two targets. After each FTP packet, there is a retransmission packet.</p><div class="figure"><a id="wireshark_captures_the_login_information"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00090"/><img alt="Wireshark captures the login information." src="httpatomoreillycomsourcenostarchimages2030370.png.jpg"/></div></div><div class="figure-title">Figure 7-8. Wireshark captures the login information.</div></div></div><div class="sect2" title="Using ARP Cache Poisoning to Impersonate the Default Gateway"><div class="titlepage"><div><div><h3 class="title" id="using_arp_cache_poisoning_to_impersonate">Using ARP Cache Poisoning to Impersonate the Default Gateway</h3></div></div></div><p>We can also use ARP cache poisoning to impersonate the default gateway on a network and access traffic entering and leaving the network, including traffic destined for the Internet. Stop the Arpspoof processes you have <a class="indexterm" id="iddle1072"/><a class="indexterm" id="iddle2030"/>running, and try tricking the Linux target into routing all traffic to the gateway through the Kali machine by impersonating the default gateway, as shown here.</p><a id="pro_id00095"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>arpspoof -i eth0 -t 192.168.20.11 192.168.20.1</strong></span></pre><a id="pro_id00096"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>arpspoof -i eth0 -t 192.168.20.1 192.168.20.11</strong></span></pre><p>If we start to browse the Internet from the Linux target, we should see HTTP packets being captured by Wireshark. Even if sensitive information is encrypted with HTTPS, we’ll still be able to see where users are going and any other information sent over HTTP. For example, if we run a Google query, the plaintext of the query will be captured in Wireshark, as shown in <a class="xref" href="ch07.xhtml#query_captured_in_wireshark" title="Figure 7-9. Query captured in Wireshark">Figure 7-9</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p>If you use ARP cache poisoning to trick a large network into thinking your pentest machine is the default gateway, you may unwittingly cause networking issues. All the traffic in a network going through one laptop (or worse, one virtual machine) can slow things down to the point of denial of service in some cases.</p></div><div class="figure"><a id="query_captured_in_wireshark"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00091"/><img alt="Query captured in Wireshark" src="httpatomoreillycomsourcenostarchimages2030372.png.jpg"/></div></div><div class="figure-title">Figure 7-9. Query captured in Wireshark</div></div></div></div><div class="sect1" title="DNS Cache Poisoning"><div class="titlepage"><div><div><h2 class="title" id="dns_cache_poisoning" style="clear: both">DNS Cache Poisoning</h2></div></div></div><p><a class="indexterm" id="iddle1165"/><a class="indexterm" id="iddle1276"/><a class="indexterm" id="iddle1285"/><a class="indexterm" id="iddle1557"/><a class="indexterm" id="iddle1850"/>In addition to ARP cache poisoning, we can also poison Domain Name Service (DNS) cache entries (mappings from domain names to IP addresses) to route traffic intended for another website to one we control. Just as ARP resolves IP to MAC addresses to properly route traffic, DNS maps (or resolves) domain names such as <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> to IP addresses.</p><p>To reach another system on the Internet or local network, our machine needs to know the IP address to connect to. It is easy to remember the URL <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> if we want to visit our web mail account, but it’s difficult to remember a bunch of IP addresses, which may even change regularly. DNS resolution translates the human-readable domain name into an IP address. For example, we can use the tool Nslookup to translate <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> into an IP address, as shown in <a class="xref" href="ch07.xhtml#nslookup_dns_resolution" title="Example 7-4. Nslookup DNS resolution">Example 7-4</a>.</p><div class="example"><a id="nslookup_dns_resolution"/><div class="example-title">Example 7-4. Nslookup DNS resolution</div><div class="example-contents"><pre class="programlisting">root@kali~# <span class="strong"><strong>nslookup www.gmail.com</strong></span>&#13;
Server: 75.75.75.75&#13;
Address: 75.75.75.75#53&#13;
&#13;
Non-authoritative answer:&#13;
www.gmail.com canonical name = mail.google.com.&#13;
mail.google.com canonical name = googlemail.l.google.com.&#13;
Name:     googlemail.l.google.com&#13;
Address: 173.194.37.85&#13;
Name:     googlemail.l.google.com&#13;
Address: 173.194.37.86</pre></div></div><p>As you can see, Nslookup translates <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> to a number of IP addresses, including 173.194.37.85 and 173.194.37.86, all of which we can use to reach Gmail. To perform DNS resolution (<a class="xref" href="ch07.xhtml#dns_resolution" title="Figure 7-10. DNS resolution">Figure 7-10</a>), our system queries its local DNS server for information about a specific domain name, such as <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span>. If the DNS server has a cache entry for the address, it gives our system the correct IP address. If not, it contacts other DNS servers on the Internet looking for the correct information.</p><p>When the correct IP address is returned, the DNS server writes back to our machine with the correct IP address resolution for <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span>, and our system then translates <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> into 173.194.37.85, as shown in <a class="xref" href="ch07.xhtml#nslookup_dns_resolution" title="Example 7-4. Nslookup DNS resolution">Example 7-4</a>. Users can then access <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> by name without having to use the IP address.</p><div class="figure"><a id="dns_resolution"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00092"/><img alt="DNS resolution" src="httpatomoreillycomsourcenostarchimages2030374.png.jpg"/></div></div><div class="figure-title">Figure 7-10. DNS resolution</div></div><div class="sect2" title="Getting Started"><div class="titlepage"><div><div><h3 class="title" id="getting_started">Getting Started</h3></div></div></div><p>DNS cache poisoning works like ARP cache poisoning: We send a bunch of bogus DNS resolution replies pointing to the wrong IP address for a domain name.</p><p>Now make sure the Apache server is running with the command <code class="literal">service apache2 start</code>.</p><a id="pro_id00097"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>service apache2 start</strong></span>&#13;
 * Starting web server apache2                                           [ OK ]</pre><p>Before we use a DNS cache poisoning tool, we need to create a file that specifies which DNS names we would like to spoof and where to send traffic. For example, let’s tell any system that runs a DNS resolution for <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com" target="_top">www.gmail.com</a></em></span> that that domain’s IP address is our Kali machine by adding the entry <a class="indexterm" id="iddle1062"/><a class="indexterm" id="iddle1277"/><code class="literal">192.168.20.9 www.gmail.com</code> to a new file called <span class="emphasis"><em>hosts.txt</em></span>. (You can name the file anything you like.)</p><a id="pro_id00098"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat hosts.txt</strong></span>&#13;
192.168.20.9 www.gmail.com</pre></div><div class="sect2" title="Using Dnsspoof"><div class="titlepage"><div><div><h3 class="title" id="using_dnsspoof">Using Dnsspoof</h3></div></div></div><p>Restart Arpspoof between the Linux target and the default gateway and vice versa as discussed in <a class="xref" href="ch07.xhtml#using_arp_cache_poisoning_to_impersonate" title="Using ARP Cache Poisoning to Impersonate the Default Gateway">Using ARP Cache Poisoning to Impersonate the Default Gateway</a>. Now we can start sending DNS cache poisoning attempts using the Dnsspoof DNS spoofing tool, as shown here.</p><a id="pro_id00099"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>dnsspoof -i eth0</strong></span>❶ <span class="strong"><strong>-f hosts.txt</strong></span>❷&#13;
dnsspoof: listening on eth0 [udp dst port 53 and not src 192.168.20.9]&#13;
192.168.20.11 &gt; 75.75.75.75.53:  46559+ A? www.gmail.com</pre><p>We specify the network interface ❶ to use, and point Dnsspoof to the file (<span class="emphasis"><em>hosts.txt</em></span>) we just created ❷ telling it which values to spoof.</p><p>Once Dnsspoof is running, when we run the <code class="literal">nslookup</code> command from our Linux target, the IP address returned should be our Kali machine’s, as shown in <a class="xref" href="ch07.xhtml#nslookup_after_attack" title="Example 7-5. Nslookup after attack">Example 7-5</a>. This is clearly not the real IP address for Gmail.</p><div class="example"><a id="nslookup_after_attack"/><div class="example-title">Example 7-5. Nslookup after attack</div><div class="example-contents"><pre class="programlisting">georgia@ubuntu:~$ <span class="strong"><strong>nslookup www.gmail.com</strong></span>&#13;
Server: 75.75.75.75&#13;
Address: 75.75.75.75#53&#13;
&#13;
Non-authoritative answer:&#13;
Name:     www.gmail.com&#13;
Address: 192.168.20.9</pre></div></div><p>To demonstrate this attack, set up a website to direct traffic to. The Apache server in Kali will by default serve an “It Works” page to anyone who visits it. We can change the contents of the <span class="emphasis"><em>index.html</em></span> file in the folder <span class="emphasis"><em>/var/www</em></span>, but the default “It Works” text is fine for our purposes.</p><p>Now if we browse to <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com/" target="_top">http://www.gmail.com/</a></em></span> from the Ubuntu target, the URL bar should say <span class="emphasis"><em><a class="ulink" href="http://www.gmail.com/" target="_top">http://www.gmail.com/</a></em></span>, but we’re actually at our Kali machine’s web server, as shown in <a class="xref" href="ch07.xhtml#this_isnapostrophet_gmaildot" title="Figure 7-11. This isn’t Gmail.">Figure 7-11</a>. We can even make this attack more interesting by cloning the actual Gmail website (or any other site the attacker chooses) so the user won’t notice the difference.</p><div class="figure"><a id="this_isnapostrophet_gmaildot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00093"/><img alt="This isn’t Gmail." src="httpatomoreillycomsourcenostarchimages2030376.png.jpg"/></div></div><div class="figure-title">Figure 7-11. This isn’t Gmail.</div></div></div></div><div class="sect1" title="SSL Attacks"><div class="titlepage"><div><div><h2 class="title" id="ssl_attacks" style="clear: both">SSL Attacks</h2></div></div></div><p><a class="indexterm" id="iddle2116"/><a class="indexterm" id="iddle2222"/>So far, we’ve been able to intercept encrypted traffic, but we haven’t been able to get any sensitive information out of the encrypted connection. For this next attack, we’ll rely on a user’s willingness to click past an SSL certificate warning to perform a man-in-the-middle attack and get the plaintext out of a Secure Sockets Layer (SSL) connection, which encrypts traffic to protect it from being read by an eavesdropper.</p><div class="sect2" title="SSL Basics"><div class="titlepage"><div><div><h3 class="title" id="ssl_basics">SSL Basics</h3></div></div></div><p>The goal of SSL is to provide reasonable assurance that any sensitive information (such as credentials or credit card numbers) transmitted between a user’s browser and a server is secure—unable to be read by a malicious entity along the way. To prove that the connection is secure, SSL uses certificates. When you browse to an SSL-enabled site, your browser asks the site to identify itself with its SSL certificate. The site presents its certificate, which your browser verifies. If your browser accepts the certificate, it informs the server, the server returns a digitally signed acknowledgment, and SSL-secured communication begins.</p><p><a class="indexterm" id="iddle1156"/><a class="indexterm" id="iddle1174"/><a class="indexterm" id="iddle1347"/><a class="indexterm" id="iddle1663"/><a class="indexterm" id="iddle2300"/><a class="indexterm" id="iddle2363"/>An SSL certificate includes an encryption key pair as well as identifying information, such as the domain name and the name of the company that owns the site. A server’s SSL certificate is generally vouched for by a certificate authority (CA) such as VeriSign or Thawte. Browsers come preinstalled with a list of trusted CAs, and if a server’s SSL certificate is vouched for by a trusted CA, the browser can create a secure connection. If the certificate is untrusted, the user will be presented with a warning that basically says, “The connection might be secure, but it might not be. Proceed at your own risk.”</p></div><div class="sect2" title="Using Ettercap for SSL Man-in-the-Middle Attacks"><div class="titlepage"><div><div><h3 class="title" id="using_ettercap_for_ssl_man-in-the-middle">Using Ettercap for SSL Man-in-the-Middle Attacks</h3></div></div></div><p>In our ARP cache poisoning attack, we man-in-the-middled the traffic between our Windows XP and Ubuntu targets (as well as the Ubuntu target and the Internet). These systems were still able to communicate with each other, but our Kali system was able to capture the traffic. We can do the same thing to attack SSL traffic. We can break the secure SSL connection by redirecting traffic to and from <span class="emphasis"><em><a class="ulink" href="http://www.facebook.com" target="_top">www.facebook.com</a></em></span> to our Kali system so we can intercept sensitive information.</p><p>For this example, we’ll use Ettercap, a multifunction suite for man-in-the-middle attacks that, in addition to SSL attacks, can also complete all of the attacks we have performed so far with Arpspoof and Dnsspoof. Turn off any other spoofing tools before starting Ettercap. See <a class="xref" href="ch01.xhtml#ettercap" title="Ettercap">Ettercap</a> for configuration instructions.</p><p>Ettercap has multiple interfaces, but we will use the <code class="literal">-T</code> option for the text-based interface in this example. Use the <code class="literal">-M</code> option with <code class="literal">arp:remote /</code> <span class="emphasis"><em><code class="literal">gateway</code></em></span><code class="literal">/ /</code><span class="emphasis"><em><code class="literal">target</code></em></span><code class="literal">/</code> to set up an ARP cache poisoning attack between the default gateway and the Linux target, as shown next. The actual attack will work the same way as our previous exercise with Arpspoof.</p><a id="pro_id00100"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>ettercap -Ti eth0 -M arp:remote /192.168.20.1/ /192.168.20.11/</strong></span></pre><p>With Ettercap running, we just wait for users to start interacting with SSL-based web servers. Switch over to your Linux target, and attempt to log in to a website using SSL. You should be greeted with a certificate warning like the one in <a class="xref" href="ch07.xhtml#facebook_cannot_be_verifieddot" title="Figure 7-12. Facebook cannot be verified.">Figure 7-12</a>.</p><p>Because this is a man-in-the-middle attack, the SSL session’s security cannot be verified. The certificate Ettercap presents isn’t valid for <span class="emphasis"><em><a class="ulink" href="http://www.facebook.com" target="_top">www.facebook.com</a></em></span>, so the trust is broken, as illustrated in <a class="xref" href="ch07.xhtml#ssl_man-in-the-middle_attack" title="Figure 7-13. SSL man-in-the-middle attack">Figure 7-13</a>.</p><p>But security warnings don’t stop all users. If we click through the warning and enter our credentials, Ettercap will grab them in plaintext before forwarding them on to the server, as shown here:</p><a id="pro_id00101"/><pre class="programlisting">HTTP : 31.13.74.23:443 -&gt; USER: georgia  PASS: password  INFO: https://www.facebook.com/</pre><div class="figure"><a id="facebook_cannot_be_verifieddot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00094"/><img alt="Facebook cannot be verified." src="httpatomoreillycomsourcenostarchimages2030378.png.jpg"/></div></div><div class="figure-title">Figure 7-12. Facebook cannot be verified.</div></div><div class="figure"><a id="ssl_man-in-the-middle_attack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00095"/><img alt="SSL man-in-the-middle attack" src="httpatomoreillycomsourcenostarchimages2030380.png.jpg"/></div></div><div class="figure-title">Figure 7-13. SSL man-in-the-middle attack</div></div></div></div><div class="sect1" title="SSL Stripping"><div class="titlepage"><div><div><h2 class="title" id="ssl_stripping" style="clear: both">SSL Stripping</h2></div></div></div><p><a class="indexterm" id="iddle1392"/><a class="indexterm" id="iddle1794"/><a class="indexterm" id="iddle2117"/><a class="indexterm" id="iddle2130"/><a class="indexterm" id="iddle2191"/><a class="indexterm" id="iddle2223"/><a class="indexterm" id="iddle2225"/>Of course, the trouble with SSL man-in-the-middle attacks is that users have to click through the SSL certificate warning. Depending on the browser, this can be an involved process that is difficult, if not impossible, for a user to ignore. Most readers can probably think of a time they clicked through a security warning and continued to the page despite their better judgment. (Case in point: Our default Nessus install uses Tenable’s self-signed certificate, which throws a certificate error when you browse to the web interface. If you chose to follow along with that example, you most likely decided to click through the warning.)</p><p>It is difficult to say how effective certificate warnings are at stopping users from visiting HTTPS sites without valid certificates. I have run social-engineering tests that employed self-signed SSL certificates, and the success rate has been significantly lower than those with valid certificates or those that don’t use HTTPS. Though some users did click through and visit the sites, a more sophisticated attack would allow us to capture information in plaintext without triggering those obvious warnings that the SSL connection is compromised.</p><p>With SSL stripping, we man-in-the-middle the HTTP connection before it is redirected to SSL and add SSL functionality before sending the packets on to the web server. When the web server replies, SSL stripping again intercepts the traffic and removes the HTTPS tags before sending the packets to the client. This technique is illustrated in <a class="xref" href="ch07.xhtml#ssl_stripping_attack" title="Figure 7-14. SSL stripping attack">Figure 7-14</a>.</p><div class="figure"><a id="ssl_stripping_attack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00096"/><img alt="SSL stripping attack" src="httpatomoreillycomsourcenostarchimages2030382.png.jpg"/></div></div><div class="figure-title">Figure 7-14. SSL stripping attack</div></div><p>Moxie Marlinspike, the author of SSLstrip, called certificate warnings <span class="emphasis"><em>negative feedback</em></span>, as opposed to <span class="emphasis"><em>positive feedback</em></span> that a session is valid, such as seeing HTTPS in the browser URL bar. Avoiding this negative feedback is <a class="indexterm" id="iddle1220"/><a class="indexterm" id="iddle1485"/><a class="indexterm" id="iddle1946"/>much more important to an attack’s success than including positive feedback because users are naturally less likely to notice that a URL says HTTP instead of HTTPS than they are a giant certificate warning they have to actively click through. SSL stripping avoids the certificate warning by again man-in-the-middling the connection.</p><p>Users typically encounter HTTPS either through clicking links or through HTTP 302 redirects. Most users don’t enter <span class="emphasis"><em><a class="ulink" href="https://www.facebook.com" target="_top">https://www.facebook.com</a></em></span> or even <span class="emphasis"><em><a class="ulink" href="http://www.facebook.com" target="_top">http://www.facebook.com</a></em></span> into their browsers; they type <span class="emphasis"><em><a class="ulink" href="http://www.facebook.com" target="_top">www.facebook.com</a></em></span> or sometimes just <span class="emphasis"><em>facebook.com.</em></span> And that’s why this attack is possible. SSLstrip adds the HTTPS itself and thus the SSL connection between Facebook and Kali is valid. SSLstrip just turns the connection back to HTTP to send to the original requester. There is no certificate warning.</p><div class="sect2" title="Using SSLstrip"><div class="titlepage"><div><div><h3 class="title" id="using_sslstrip">Using SSLstrip</h3></div></div></div><p>The tool SSLstrip implements SSL stripping. Before we start it, we need to set an Iptables rule to pass traffic that is headed to port 80 through SSLstrip. We’ll run SSLstrip on port 8080, as shown next, then restart Arpspoof and spoof the default gateway. (For instructions, jump back to <a class="xref" href="ch07.xhtml#using_arp_cache_poisoning_to_impersonate" title="Using ARP Cache Poisoning to Impersonate the Default Gateway">Using ARP Cache Poisoning to Impersonate the Default Gateway</a>.)</p><a id="pro_id00102"/><pre class="programlisting">root@kali:# <span class="strong"><strong>iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</strong></span></pre><p>Now start SSLstrip, and tell it to listen on port 8080 with the <code class="literal">-l</code> flag.</p><a id="pro_id00103"/><pre class="programlisting">root@kali:# <span class="strong"><strong>sslstrip -l 8080</strong></span></pre><p>Next, browse to a site that uses SSL (try any Internet site that requires login credentials) from your Linux target, like the Twitter login page shown in <a class="xref" href="ch07.xhtml#twitter_login_page_with_sslstrip_running" title="Figure 7-15. Twitter login page with SSLstrip running">Figure 7-15</a>. As you can see, HTTP has replaced HTTPS in the address bar.</p><p>When you log in, your credentials will be reported in plaintext by SSLstrip. (No, my Twitter password isn’t really “password.”)</p><p>This attack is more sophisticated than a straight SSL man-in-the-middle attack. We are able to avoid the certificate warning because the server is completing an SSL connection with SSLstrip rather than the browser.</p><a id="pro_id00104"/><pre class="programlisting">2015-12-28 19:16:35,323 SECURE POST Data (twitter.com):&#13;
session%5Busername_or_email%5D=georgiaweidman&amp;session%5Bpassword%5D=password&amp;scribe_log=&amp;redirect_after_login=%2F&amp;authenticity_token=a26a0faf67c2e11e6738053c81beb4b8ffa45c6a</pre><p>As you can see, SSLstrip reports the entered credentials (<span class="emphasis"><em>georgiaweidman: password</em></span>) in plaintext.</p><div class="figure"><a id="twitter_login_page_with_sslstrip_running"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00097"/><img alt="Twitter login page with SSLstrip running" src="httpatomoreillycomsourcenostarchimages2030384.png.jpg"/></div></div><div class="figure-title">Figure 7-15. Twitter login page with SSLstrip running</div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00023" style="clear: both">Summary</h2></div></div></div><p>In this chapter we’ve fiddled with network traffic to create some interesting results. Using various tools and techniques, we were able to intercept traffic that we had no business seeing in a switched network. We used ARP cache poisoning to redirect traffic in a switched network to our Kali system and DNS cache poisoning to redirect users to our web servers. We used Ettercap to automate an SSL man-in-the-middle attack and (assuming that the user clicks through a warning) capture sensitive information in plaintext. Finally, we made the attack even more sophisticated by avoiding an invalid certificate warning using SSL stripping.</p><p>Capturing traffic from the local network can glean useful information for our pentest. For example, we were able to capture valid credentials for the FTP server for use in exploitation.</p><p>Speaking of exploitation, let’s get started.</p></div></section></body></html>