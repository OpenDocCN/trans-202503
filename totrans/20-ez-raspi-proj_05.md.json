["```\n  #import the necessary libraries\n➊ from gpiozero import Button, MotionSensor\n  from picamera import PiCamera\n  from time import sleep\n  from signal import pause\n\n  #create objects that refer to a button,\n  #a motion, sensor, and the PiCamera\n➋ button = Button(2)\n  pir = MotionSensor(4)\n  camera = PiCamera()\n\n  #start the camera\n  camera.rotation = 180\n➌ camera.start_preview()\n\n  #create image names\n➍ i = 0\n\n  #stop the camera when the pushbutton is pressed\n➎ def stop_camera():\n      camera.stop_preview()\n      #exit the program\n      exit()\n\n  #take a photo when motion is detected\n➏ def take_photo():\n      global i\n      i = i + 1\n      camera.capture('/home/pi/Desktop/image_%s.jpg' % i)\n      print('A photo has been taken')\n➐    sleep(10)\n\n  #assign a function that runs when the button is pressed\n➑ button.when_pressed = stop_camera\n  #assign a function that runs when motion is detected\n➒ pir.when_motion = take_photo\n\n  pause()\n```", "```\n➊ import picamera\n\n➋ camera = picamera.PiCamera()\n\n➌ camera.resolution = (640, 480)\n➍ camera.start_recording('videotest.h264')\n➎ camera.wait_recording(60)\n➏ camera.stop_recording()\n\n  print('Finished recording')\n```", "```\npi@raspberrypi:~ $ cd ~/Desktop/Projects/Cameras\npi@raspberrypi:~/Desktop/Projects/Cameras $ omxplayer videotest.h264\n```", "```\n  import io\n  import picamera\n  import logging\n  import socketserver\n  from threading import Condition\n  from http import server\n\n➊ PAGE=\"\"\"\\\n  <html>\n  <head>\n  <title>Raspberry Pi - Surveillance Camera</title>\n  </head>\n  <body>\n  <center><h1>Raspberry Pi - Surveillance Camera</h1></center>\n  <center><img src=\"stream.mjpg\" width=\"640\" height=\"480\"></center>\n  </body>\n  </html>\n  \"\"\"\n\n  class StreamingOutput(object):\n      def __init__(self):\n          self.frame = None\n          self.buffer = io.BytesIO()\n          self.condition = Condition()\n\n      def write(self, buf):\n          if buf.startswith(b'\\xff\\xd8'):\n              #new frame, copy the existing buffer's content and\n              #notify all clients it's available\n              self.buffer.truncate()\n              with self.condition:\n                  self.frame = self.buffer.getvalue()\n                  self.condition.notify_all()\n              self.buffer.seek(0)\n          return self.buffer.write(buf)\n\n  class StreamingHandler(server.BaseHTTPRequestHandler):\n      def do_GET(self):\n          if self.path == '/':\n              self.send_response(301)\n              self.send_header('Location', '/index.html')\n              self.end_headers()\n          elif self.path == '/index.html':\n              content = PAGE.encode('utf-8')\n              self.send_response(200)\n              self.send_header('Content-Type', 'text/html')\n              self.send_header('Content-Length', len(content))\n              self.end_headers()\n              self.wfile.write(content)\n          elif self.path == '/stream.mjpg':\n              self.send_response(200)\n              self.send_header('Age', 0)\n              self.send_header('Cache-Control', 'no-cache, private')\n              self.send_header('Pragma', 'no-cache')\n              self.send_header('Content-Type', \n  'multipart/x-mixed-replace; boundary=FRAME')\n              self.end_headers()\n              try:\n                  while True:\n                      with output.condition:\n                          output.condition.wait()\n                          frame = output.frame\n                      self.wfile.write(b'--FRAME\\r\\n')\n                      self.send_header('Content-Type', 'image/jpeg')\n                      self.send_header('Content-Length', len(frame))\n                      self.end_headers()\n                      self.wfile.write(frame)\n                      self.wfile.write(b'\\r\\n')\n              except Exception as e:\n                  logging.warning(\n                      'Removed streaming client %s: %s',\n                      self.client_address, str(e))\n          else:\n              self.send_error(404)\n              self.end_headers()\n\n  class StreamingServer(socketserver.ThreadingMixIn,\n  server.HTTPServer):\n      allow_reuse_address = True\n      daemon_threads = True\n\n➋ with picamera.PiCamera(resolution='640x480', framerate=24) as\n  camera:\n      output = StreamingOutput()\n      camera.start_recording(output, format='mjpeg')\n      try:\n          address = ('', 8000)\n          server = StreamingServer(address, StreamingHandler)\n          server.serve_forever()\n      finally:\n          camera.stop_recording()\n```", "```\npi@raspberrypi:~ $ hostname -I\n```"]