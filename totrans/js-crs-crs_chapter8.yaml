- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVENT-BASED
    PROGRAMMING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">基于事件的编程</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: 'When a user clicks a button, scrolls, or simply moves the mouse within a web
    page, that action creates an *event*. An event is the browser’s way of signaling
    that an action happened in the DOM. Events allow us to create interactive web
    applications that respond to the user’s actions. We do this by writing *handlers*
    for specific events: functions that are called when an event occurs. Using event
    handlers, we can change the color of an element when the user clicks it, move
    an element around the screen when the user presses a certain key, and much more.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮、滚动页面或只是简单地在网页内移动鼠标时，这些操作会生成一个 *事件*。事件是浏览器向 JavaScript 发出的信号，表明在 DOM
    中发生了某个操作。事件使我们能够创建响应用户操作的互动网页应用程序。我们通过为特定事件编写 *处理程序* 来实现这一点：这些函数会在事件发生时被调用。通过事件处理程序，我们可以在用户点击某个元素时改变该元素的颜色，按下特定键时将元素移到屏幕上的不同位置，等等。
- en: In this chapter you’ll learn how to write event handlers to respond to some
    common DOM events. In this way, you’ll add interactivity to your web pages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何编写事件处理程序来响应一些常见的 DOM 事件。通过这种方式，你将为网页添加交互功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Event Handlers</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">事件处理程序</samp>
- en: Events are how the browser tells JavaScript that something has occurred in the
    DOM. It’s almost as if every time the mouse moves over the window, or a key is
    pressed, the browser is shouting, “Hey, the mouse moved! A key was pressed!” These
    shouts happen all the time, but your JavaScript code can respond to them only
    if you explicitly tell it to listen for them. You do this by writing a JavaScript
    event handler that will perform some action when a certain type of event occurs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是浏览器告诉 JavaScript 在 DOM 中发生了某些事情的方式。几乎就像每次鼠标移动到窗口上，或者按下某个键时，浏览器都在大喊：“嘿，鼠标动了！按下了一个键！”这些大喊发生得非常频繁，但只有在你明确告诉
    JavaScript 监听这些事件时，它的代码才会作出响应。你可以通过编写一个 JavaScript 事件处理程序，在特定类型的事件发生时执行某些操作。
- en: An *event handler* is a function triggered by a specific event type on a specific
    element. For example, you could attach a handler to a particular h1 element that
    handles clicks on that element. Let’s try that out now. We’ll create a simple
    web page with a heading and use an event handler to log a message to the console
    when the heading is clicked.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件处理程序* 是由特定事件类型触发的函数，通常是针对特定元素。例如，你可以将一个事件处理程序附加到某个特定的 h1 元素上，以处理该元素上的点击事件。现在我们来尝试一下。我们将创建一个简单的网页，包含一个标题，并使用事件处理程序在点击标题时将一条信息记录到控制台。'
- en: First, you’ll need an HTML file. Create a new directory called *chapter8* and
    make a new file in that directory called *index.html*. Enter the content shown
    in [Listing 8-1](#Lis8-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个 HTML 文件。创建一个名为 *chapter8* 的新目录，并在该目录下创建一个名为 *index.html* 的新文件。输入[清单
    8-1](#Lis8-1)中所示的内容。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring event handlers</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-1：用于探索事件处理程序的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: As usual, our HTML file has a single html element containing a head with some
    metadata and a body with some content. Specifically, the body contains an h1 element
    with an ID of main-heading, and part of the heading text is wrapped in an em element
    (short for *emphasis*), which by default italicizes that portion of the text.
    It also contains a script element with a link to the file *script.js*. In a moment,
    that’s where we’ll write the code for our event handler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们的 HTML 文件包含一个 html 元素，里面包含一个带有一些元数据的 head 部分，以及一些内容的 body 部分。具体来说，body
    部分包含一个 ID 为 main-heading 的 h1 元素，部分标题文本被包裹在一个 em 元素中（*emphasis* 的缩写），默认情况下该部分文本会以斜体显示。它还包含一个
    script 元素，链接到文件 *script.js*。稍后我们将在这里编写事件处理程序的代码。
- en: 'Overall, this file is very similar to the *index.html* file we created in [Chapter
    7](chapter7.xhtml), with one important difference: the script element is inside
    the body element, not the head element. This is a bit of a cheat to get around
    a problem with how web browsers read web pages. As described in the previous chapter,
    the browser builds a model of the page called the DOM. It builds the DOM incrementally
    by reading through the HTML file from top to bottom. Anytime the browser reaches
    a script element, it executes the whole script before continuing. That means that
    if we had our script element in the head, and we looked up the h1 element in that
    script, the h1 element wouldn’t be in the DOM yet! By placing the script element
    at the end of the body, we can be sure that all the page content has been loaded
    into the DOM *before* we run our JavaScript.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个文件与我们在[第7章](chapter7.xhtml)中创建的*index.html*文件非常相似，唯一的重要区别是：script元素位于body元素内部，而不是head元素中。这是为了绕过网页浏览器解析网页时遇到的问题。如前一章所述，浏览器构建了一个页面模型，称为DOM。它通过从上到下读取HTML文件逐步构建DOM。每当浏览器遇到一个script元素时，它会执行整个脚本后再继续。这意味着如果我们把script元素放在head中，并且在脚本中查找h1元素，那么h1元素还没有被加载到DOM中！通过将script元素放在body的末尾，我们可以确保在运行JavaScript之前，页面的所有内容都已经加载到DOM中。
- en: Now create a file called *script.js* in the same directory as the HTML code,
    and enter the script shown in [Listing 8-2](#Lis8-2). This script adds an event
    handler for when the user clicks the h1 element.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在与HTML代码相同的目录中创建一个名为*script.js*的文件，并输入[清单 8-2](#Lis8-2)中显示的脚本。此脚本为用户点击h1元素时添加事件处理程序。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Creating an event
    handler in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-2：在</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>中创建事件处理程序
- en: Using the DOM API’s querySelector method, we get the element with the ID main-heading
    and save it as the variable heading. You may recall from [Chapter 7](chapter7.xhtml)
    that this method returns the first element to match the selector. In our case,
    there’s only one main-heading element, so we know this method will select the
    element we want. We then use the addEventListener method on the heading element
    to attach an event handler to that element. addEventListener tells JavaScript
    to watch for a particular event happening on the element, and to execute some
    function when it does.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DOM API的querySelector方法，我们获取ID为main-heading的元素并将其保存为变量heading。你可能还记得在[第7章](chapter7.xhtml)中，这个方法返回匹配选择器的第一个元素。在我们的例子中，只有一个main-heading元素，因此我们知道该方法会选择我们想要的元素。然后，我们在heading元素上使用addEventListener方法为该元素附加事件处理程序。addEventListener告诉JavaScript监听元素上发生的特定事件，并在事件发生时执行某个函数。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Although the DOM API uses the term* listener*, the term* handler *is more
    commonly used to describe a function that reacts to an event.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然DOM API使用术语*监听器*，但术语*处理程序*更常用于描述响应事件的函数。*'
- en: The addEventListener method has two required arguments. The first is the event
    type. This is a string representing the type of event to respond to, such as "click"
    (for mouse clicks), "keydown" (for keyboard key presses), or "scroll" (for window
    scrolling). We’ve specified "click". The second argument is the function to execute
    when the specified event happens. This function is the event handler. It will
    be called anytime the event happens on the element addEventListener was called
    on. In this case, the function, which logs a message to the console, will be called
    anytime someone clicks the heading element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: addEventListener方法有两个必需的参数。第一个是事件类型。这是一个表示响应事件类型的字符串，例如"click"（鼠标点击）、"keydown"（键盘按键按下）或"scroll"（窗口滚动）。我们指定了"click"。第二个参数是当指定的事件发生时执行的函数。这个函数就是事件处理程序。每当事件在addEventListener所调用的元素上发生时，它都会被调用。在这个例子中，该函数会在有人点击heading元素时被调用，并在控制台中记录一条消息。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*As explained in [Chapter 5](chapter5.xhtml), when a function is passed as
    an argument to another function, it’s known as a* callback function*, or simply
    a* callback*. All event handlers are callback functions, since they’re passed
    as arguments to the addEventListener method.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*如[第5章](chapter5.xhtml)所解释的，当一个函数作为参数传递给另一个函数时，它被称为*回调函数*，或者简单地说是*回调*。所有事件处理程序都是回调函数，因为它们作为参数传递给addEventListener方法。*'
- en: 'Open *index.html* in your browser and open the console. When you click the
    heading, you should see the message "You clicked the heading!" printed to the
    console. Congratulations: you’ve made your first interactive web page!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开*index.html*并打开控制台。当你点击标题时，你应该会看到消息 "You clicked the heading!" 输出到控制台。恭喜：你已经制作了你的第一个互动网页！
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Event Bubbling</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事件冒泡</samp>
- en: When an event is triggered on an element, it also gets triggered on all the
    element’s ancestors (that is, the parent of the element, the parent’s parent,
    and so on). For instance, when you clicked the h1 element in the previous example,
    you were also technically clicking the body element that contains the h1 element.
    This makes sense intuitively; if you click some text in a box, you’re also clicking
    the box. Therefore, if you had a separate handler attached to the body element,
    it would also receive the click event. This progression of events from children
    to ancestors is known as *event bubbling*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当在某个元素上触发事件时，它也会在该元素的所有祖先元素上触发（即该元素的父元素、父元素的父元素，以此类推）。例如，当你在前面的例子中点击`h1`元素时，实际上你也在点击包含`h1`元素的`body`元素。这是符合直觉的；如果你点击一个框中的文字，你也在点击这个框。因此，如果你在`body`元素上附加了一个单独的处理程序，它也会接收到点击事件。从子元素到祖先元素的事件传播过程被称为*事件冒泡*。
- en: Let’s harness bubbling by adding event handlers to the em and body elements
    in our web page. Like our h1 event handler, these new handlers will log a message
    to the console when their elements are clicked. Since em is a child of h1 and
    h1 is a child of body, a single click on em should trigger the handlers attached
    to all three elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向网页中的`em`和`body`元素添加事件处理程序来利用事件冒泡。与我们之前的`h1`事件处理程序一样，这些新的处理程序将在点击其元素时向控制台日志输出一条消息。由于`em`是`h1`的子元素，而`h1`是`body`的子元素，所以单击`em`应该会触发附加到这三个元素的处理程序。
- en: Add the code in [Listing 8-3](#Lis8-3) to the end of *script.js*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 8-3](#Lis8-3)中的代码添加到*script.js*的末尾。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Adding more handlers
    to</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-3: 向</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>
    添加更多处理程序'
- en: 'This snippet adds two handlers, one to the em element and one to the body element,
    but we do it slightly differently from how we created the main-heading handler
    in [Listing 8-2](#Lis8-2). Instead of saving each element to a variable, we just
    call addEventListener directly on the result of the document.querySelector method.
    This technique of calling a method directly on the return value of another method
    is known as *method chaining*: we chain multiple method calls together, so that
    the result of the first link in the chain is used as the object for the next method
    call. I used the longer technique for [Listing 8-2](#Lis8-2) because it makes
    it more explicit that addEventListener is being called on an element, but the
    chaining technique is often preferred because of its terseness.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段添加了两个处理程序，一个给`em`元素，另一个给`body`元素，但我们做法稍微不同于在[示例 8-2](#Lis8-2)中创建主要标题处理程序的方式。我们没有将每个元素保存到变量中，而是直接在`document.querySelector`方法的结果上调用`addEventListener`。这种直接在另一个方法返回值上调用方法的技术被称为*方法链*：我们将多个方法调用串联起来，使得第一个链条的结果作为下一个方法调用的对象。我在[示例
    8-2](#Lis8-2)中使用了更长的方法，因为它更清楚地表示`addEventListener`是在一个元素上被调用的，但链式调用通常因为简洁而更受欢迎。
- en: 'Reload *index.html* and open the console. When you click the word *World!*
    you should see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载*index.html*并打开控制台。当你点击*World!*时，你应该会看到以下输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you click the em element, the handler function on that element is the first
    to get called. After that, the handler function on the h1 element is called, followed
    by the one on the body element. This is because the event “bubbles up” through
    the DOM, from the innermost element to the outermost element. If you click the
    non-italic part of the heading, you’ll see just the main-heading and body handlers
    triggered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击`em`元素时，该元素上的处理程序是第一个被调用的。接下来，会调用`h1`元素上的处理程序，然后是`body`元素上的处理程序。这是因为事件通过DOM“冒泡”，从最内层的元素传递到最外层的元素。如果你点击的是标题中非斜体的部分，你将只看到主要标题和`body`处理程序被触发。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Event Delegation</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">事件委托</samp>
- en: One of the more common uses for event bubbling is *event delegation*, a technique
    where you use a single handler to respond to events on multiple child or other
    descendant elements. For example, imagine you have a list of words, where each
    list item is a separate HTML element, and you want to handle clicks on each item
    in the same way. By adding a single handler to the list items’ parent element,
    you can catch events on each item with only a few lines of code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事件冒泡的一个常见用途是 *事件委托*，这是一种通过使用单一的事件处理函数来响应多个子元素或其他后代元素上的事件的技术。例如，假设你有一个单词列表，每个列表项是一个独立的
    HTML 元素，而你希望以相同的方式处理每个项的点击事件。通过将一个事件处理函数添加到列表项的父元素，你可以用几行代码捕捉到每个项的事件。
- en: To illustrate event delegation, we’ll write a simple application that builds
    up and displays a sentence based on words that you click in a list. First, we’ll
    update our HTML file to include a list of words and an empty p element that we’ll
    populate dynamically with the words of your choice. Then, we’ll write the necessary
    event handler with JavaScript to take clicked words and add them to the p element
    for display. Finally, we’ll add some CSS rules to make the application easier
    to interact with.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明事件委托，我们将编写一个简单的应用程序，根据你点击的列表中的单词来构建并显示一个句子。首先，我们更新 HTML 文件，包含一个单词列表和一个空的
    p 元素，之后我们会动态地将你选择的单词填充到这个 p 元素中。然后，我们将编写必要的事件处理函数，使用 JavaScript 获取被点击的单词，并将它们添加到
    p 元素中进行显示。最后，我们将添加一些 CSS 规则，使得这个应用程序更容易交互。
- en: 'There are two types of lists in HTML: ordered (numbered) lists and unordered
    (bulleted) lists. We’ll use an unordered list, which is created with the ul (*unordered
    list*) element. Each individual item in the list is wrapped in an li (*list item*)
    element. Therefore, the event resulting from a click on any li element will bubble
    up to the parent ul element.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 中有两种类型的列表：有序（编号）列表和无序（项目符号）列表。我们将使用无序列表，它是通过 ul（*无序列表*）元素创建的。列表中的每个项目都被包含在
    li（*列表项*）元素中。因此，点击任何 li 元素所产生的事件将冒泡到父级 ul 元素。
- en: Update *index.html* as shown in [Listing 8-4](#Lis8-4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 [列表 8-4](#Lis8-4) 所示更新 *index.html*。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Adding a list
    to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-4：添加列表到</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>
- en: This adds an unordered list of words to the document, as well as an empty p
    element, which we’ll be modifying with JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向文档中添加一个无序单词列表，并且添加一个空的 p 元素，我们将使用 JavaScript 修改这个元素。
- en: Next, we’ll write an event handler for the ul element to handle clicks on any
    of the list items. The handler will take the word that was clicked and add it
    to the p element, allowing you to build up a sentence one word at a time. Delete
    all the code in *script.js* and replace it with [Listing 8-5](#Lis8-5).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 ul 元素编写一个事件处理函数，处理点击任何列表项的事件。该处理函数将获取被点击的单词，并将其添加到 p 元素中，允许你逐个单词地构建一个句子。删除
    *script.js* 中的所有代码，并将其替换为 [列表 8-5](#Lis8-5)。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Delegating events</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-5：委托事件</samp>
- en: 'First we look up the two elements we care about using document.query Selector:
    the ul with the word list, and the empty p element. Next, we add a click handler
    to the ul element. This example is a little different from our previous handlers
    because the callback function has a parameter, which we’re calling event ❶. If
    we give a handler function a single parameter (in this case, event, but the exact
    name isn’t important), the parameter represents an object through which the DOM
    API passes information about the event that just happened. That information, which
    includes the element that was clicked, the element’s text content, and so on,
    then becomes available for use within the callback function.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 document.querySelector 查找我们关心的两个元素：带有单词列表的 ul 元素和空的 p 元素。接下来，我们为 ul
    元素添加一个点击事件处理函数。这个示例与我们之前的事件处理函数有些不同，因为回调函数有一个参数，我们称之为 event ❶。如果我们给事件处理函数传递一个参数（在这个例子中是
    event，但参数名并不重要），该参数表示一个对象，DOM API 会通过这个对象传递有关刚刚发生的事件的信息。这些信息包括被点击的元素、元素的文本内容等，随后就可以在回调函数中使用这些信息。
- en: In our example, we use the event object to determine what word was clicked and
    store it in the variable word ❷. We find out which specific element was clicked
    with the event object’s target property. When you click one of the li elements,
    event.target will be the li element you clicked, not the ul (the ul element is
    available with the currentTarget property). Then we use the textContent property,
    which returns the text of that element. Putting it together, if you were to click
    on the first li element, then event.target.textContent would return the string
    "The", and that string would become the value of the variable word.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用事件对象来确定点击了哪个单词，并将其存储在变量 word ❷ 中。我们通过事件对象的 target 属性找出点击的是哪个具体元素。当你点击某个
    li 元素时，event.target 就是你点击的 li 元素，而不是 ul（ul 元素可以通过 currentTarget 属性访问）。然后，我们使用
    textContent 属性，该属性返回该元素的文本内容。把这些结合起来，如果你点击第一个 li 元素，那么 event.target.textContent
    会返回字符串 "The"，这个字符串会成为变量 word 的值。
- en: Now that we have the word the user clicked, we can add it to the sentence. We
    use the += operator to append the word to the text content of the sentence element.
    You may recall that sentence.textContent += word; essentially converts to sentence.textContent
    = sentence.textContent + word;. In other words, we’re taking the sentence element’s
    existing text content, adding the string stored in word to the end, and reassigning
    that text to the element’s text content. Then, after adding the word to the sentence,
    we use the same += trick to append a space to the end of the sentence in preparation
    for the next word that gets added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了用户点击的单词，可以将它添加到句子中。我们使用 += 运算符将单词附加到句子元素的文本内容中。你可能记得，sentence.textContent
    += word; 本质上等同于 sentence.textContent = sentence.textContent + word;。换句话说，我们将句子元素现有的文本内容与存储在
    word 中的字符串拼接起来，并将其重新赋值给该元素的文本内容。然后，在将单词添加到句子后，我们使用相同的 += 技巧在句子末尾追加一个空格，为下一个要添加的单词做好准备。
- en: Open *index.html* again in your browser. You should see the list of words. You
    won’t see the empty p element because it doesn’t have any content yet. As you
    click words from the list, you should see them being added to the p element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开 *index.html*。你应该能看到单词列表。你不会看到空的 p 元素，因为它还没有任何内容。当你点击列表中的单词时，应该会看到它们被添加到
    p 元素中。
- en: 'To finish off our application, we need to add a small amount of CSS. JavaScript
    and CSS often go hand in hand because the styling can give helpful tips to the
    user that certain elements are interactive. In this case we’ll add two hints via
    CSS: we’ll modify the list items to change the mouse pointer to a finger when
    it hovers over them, so they look more “clickable,” and we’ll give the element
    that’s currently under the mouse pointer an underline so it’s easier to tell which
    word you’re about to click (which isn’t always obvious when the mouse is in the
    vertical space between words).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的应用程序，我们需要添加少量的 CSS。JavaScript 和 CSS 通常是配合使用的，因为样式可以向用户提供提示，表明某些元素是可以交互的。在这种情况下，我们通过
    CSS 添加了两个提示：我们将修改列表项，以便当鼠标悬停时，光标变为手指形状，这样它们看起来更“可点击”；并且我们会为当前鼠标指针下的元素添加下划线，这样就更容易知道你即将点击哪个单词（当鼠标位于单词之间的垂直空间时，这点通常不太明显）。
- en: Create a new CSS file called *style.css* and add the two CSS declarations shown
    in [Listing 8-6](#Lis8-6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *style.css* 的新 CSS 文件，并添加[清单 8-6](#Lis8-6)中显示的两个 CSS 声明。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Adding styling
    in</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-6：在</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    中添加样式
- en: 'To change the cursor for li elements, we use cursor: pointer. This changes
    the cursor from the default arrow to a hand with a finger when it is over an li
    element, as happens when you hover over a link on a web page. The li:hover selector
    uses the :hover pseudo-class. A *pseudo-class* is a kind of selector that applies
    only when an element is in a certain state: li:hover matches any li element that
    the mouse is currently hovering over. When the pointer is over an li element,
    we use text-decoration: underline to underline the text of that element.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '为了更改 li 元素的光标，我们使用 cursor: pointer。这会将光标从默认的箭头更改为手指形状，就像当你将鼠标悬停在网页上的链接时那样。li:hover
    选择器使用了 :hover 伪类。*伪类* 是一种只在元素处于某种状态时应用的选择器：li:hover 匹配任何当前鼠标悬停的 li 元素。当鼠标指针悬停在
    li 元素上时，我们使用 text-decoration: underline 为该元素的文本添加下划线。'
- en: To include this CSS on the page, add a link element to the head of the *index.html*
    file, as shown in [Listing 8-7](#Lis8-7).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在页面中包含这个 CSS，请向 *index.html* 文件的 head 部分添加一个 link 元素，如 [清单 8-7](#Lis8-7) 所示。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Including</samp>
    <samp class="SANS_Futura_Std_Book_11">style.css</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-7：包含</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>
- en: Now when you hover over one of the list items, the cursor will change, and the
    currently hovered word will be underlined, as shown in [Figure 8-1](chapter8.xhtml#fig8-1).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你将鼠标悬停在某个列表项上时，光标会发生变化，当前悬停的单词会被下划线标记，正如 [图 8-1](chapter8.xhtml#fig8-1)
    所示。
- en: '![](../images/Figure_8-1.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_8-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Using CSS to give
    hints to users</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：使用 CSS 给用户提示</samp>
- en: With that styling, our sentence-building application is complete! Event delegation
    simplified the JavaScript we wrote by letting us attach a single event handler,
    rather than using a separate handler for each list item.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种样式，我们的句子构建应用就完成了！事件委托通过让我们只附加一个事件处理程序，而不是为每个列表项使用单独的处理程序，简化了我们写的 JavaScript
    代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mouse Movement Events</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">鼠标移动事件</samp>
- en: The DOM produces events when the mouse moves, with the event name mousemove.
    These mousemove events are triggered on an element while the mouse moves over
    that element, and we can listen for them with the addEventListener method, just
    as we did for mouse clicks. Let’s set up a simple mousemove handler to see it
    in action. The handler will log the mouse’s position to the console as the mouse
    moves around the web page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标移动时，DOM 会产生名为 mousemove 的事件。这些 mousemove 事件会在鼠标移动到该元素上时触发，我们可以像处理鼠标点击事件一样，使用
    addEventListener 方法来监听它们。让我们设置一个简单的 mousemove 事件处理程序来查看它是如何工作的。这个处理程序会在鼠标移动时将鼠标的位置记录到控制台。
- en: Still working within your *chapter8* project folder, add the code in [Listing
    8-8](#Lis8-8) to the end of *script.js*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在你的 *chapter8* 项目文件夹中，将 [清单 8-8](#Lis8-8) 中的代码添加到 *script.js* 文件的末尾。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: A mousemove event
    handler</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-8：一个 mousemove 事件处理程序</samp>
- en: In this listing, we add a mousemove event handler to the html element. Since
    the html element encompasses the entire web page, this handler will respond to
    movements of the mouse anywhere in the browser window. The handler logs a message
    to the console including the clientX and clientY properties of the event, which
    tell us the x- and y-coordinates of the mouse relative to the browser window.
    In this example I’m using the shorter name e for the event parameter, rather than
    event, as in [Listing 8-5](#Lis8-5). Remember, the name of the parameter doesn’t
    matter; if the event handler callback function has a single parameter, that parameter
    will carry information about the event.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，我们为 html 元素添加了一个 mousemove 事件处理程序。由于 html 元素涵盖了整个网页，因此该处理程序会响应浏览器窗口中任何地方的鼠标移动。处理程序会将一条消息记录到控制台，其中包括事件的
    clientX 和 clientY 属性，告诉我们鼠标相对于浏览器窗口的 x 和 y 坐标。在这个例子中，我使用事件参数的简短名称 e，而不是像在 [清单
    8-5](#Lis8-5) 中那样使用 event。请记住，参数的名称并不重要；如果事件处理程序的回调函数只有一个参数，那么该参数将携带关于事件的信息。
- en: 'Refresh *index.html* in your browser and move the mouse pointer over the page.
    You should see messages similar to the following logged to the console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新浏览器中的 *index.html*，并将鼠标指针移动到页面上。你应该能在控制台中看到类似以下的消息：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are two important things to note as you watch the console. First, the
    coordinates start at 0 in the top-left corner of the browser window, increasing
    as you go across and down. The x-coordinate increases as you move right, and the
    y-coordinate increases as you move down. This follows the standard convention
    for computer graphics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察控制台时，有两件重要的事情需要注意。首先，坐标从浏览器窗口的左上角的0开始，随着你向右和向下移动而增加。x坐标随着向右移动而增加，y坐标随着向下移动而增加。这遵循了计算机图形学的标准约定。
- en: Second, there are “gaps,” or locations that the mouse appears to jump over.
    This is because mousemove events aren’t triggered continuously, but some limited
    number of times per second. The exact number depends on the mouse, the browser,
    and the computer, but it tends to be in the low hundreds. Therefore, if you move
    the mouse fast enough, there will be locations on the screen that the mouse seems
    to skip over, because the events weren’t triggering fast enough.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，会出现一些“间隙”或鼠标似乎跳过的位置。这是因为 mousemove 事件不是持续触发的，而是每秒触发有限的次数。确切的次数取决于鼠标、浏览器和计算机，但通常是在几百次的低频率。因此，如果你移动鼠标的速度足够快，屏幕上会有一些位置鼠标似乎跳过了，因为事件没有足够快地触发。
- en: Now that you’ve seen mousemove events in action, we can try to do something
    slightly more interesting with them. In this next example, we’ll make a box move
    around the page, following your cursor. To do that we’ll need to modify our HTML,
    CSS, and JavaScript files. The HTML change is simple. Add the new line in [Listing
    8-9](#Lis8-9) to *index.html*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 mousemove 事件的实际应用，我们可以尝试用它们做一些稍微更有趣的事情。在接下来的例子中，我们将让一个盒子在页面上移动，跟随你的鼠标光标。为此，我们需要修改
    HTML、CSS 和 JavaScript 文件。HTML 的修改很简单。请将新的一行添加到 [Listing 8-9](#Lis8-9) 中的 *index.html*
    文件里。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: Adding a div to</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: 添加一个 div 到</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
- en: Here we’re using a new HTML element called div, short for *content division*.
    It will become the movable box on our page. The div element is HTML’s generic
    container element. This means that it’s an element that can contain other elements,
    but by default has no appearance and no specific *meaning* (unlike ul, which means
    a list, or h1, which means a heading). We’ll use CSS to give the div element an
    appearance next. Add the contents of [Listing 8-10](#Lis8-10) to the end of *style.css*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一个新的 HTML 元素叫做 div，代表 *内容分区*。它将成为我们页面上可移动的盒子。div 元素是 HTML 中的通用容器元素。这意味着它是一个可以包含其他元素的元素，但默认情况下没有外观，也没有特定的
    *含义*（不像 ul 表示列表，或者 h1 表示标题）。接下来我们将使用 CSS 为 div 元素赋予样式。请将 [Listing 8-10](#Lis8-10)
    的内容添加到 *style.css* 的末尾。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Styling the div
    with CSS</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: 用 CSS 为 div 添加样式</samp>'
- en: 'Here we’re using #box to select the element with the ID box. There are a number
    of declarations within this ruleset. The first, position: fixed, tells the browser
    to put this element at the position specified next, by the left and top declarations.
    We indicate 0px for both, which tells the browser to put the element at the very
    top-left corner of the browser *viewport*, the part of the browser that shows
    the content. We specify the width and height of the element to be 10 pixels each.
    Finally, we give our 10×10 box a background color that’s sure to jump out: hot
    pink.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们使用 #box 来选择 ID 为 box 的元素。这个规则集里有几个声明。第一个，position: fixed，告诉浏览器将该元素放置在接下来的
    left 和 top 声明指定的位置。我们将两者都设为 0px，这告诉浏览器将元素放置在浏览器的左上角 *视口* 里，视口指的是浏览器显示内容的区域。我们将元素的宽度和高度都设为
    10 像素。最后，我们给这个 10×10 的盒子指定一个背景色，选择了非常显眼的亮粉色。'
- en: Refresh the page now, and you’ll see a small pink square appear in the top-left
    corner. Now it’s time to write an event handler so you can move the square with
    your mouse. Modify *script.js* as shown in [Listing 8-11](#Lis8-11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新页面，你会看到一个小的粉色方块出现在左上角。现在是时候编写一个事件处理程序，让你可以用鼠标移动这个方块了。请修改 *script.js* 文件，按照
    [Listing 8-11](#Lis8-11) 中所示进行修改。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Moving the div
    with JavaScript</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: 用 JavaScript
    移动 div</samp>'
- en: The first addition here is to find the box using document.querySelector and
    save a reference to the element in the variable box. Next, we modify the mousemove
    event handler we wrote earlier. In order to move the box around, we’re modifying
    its style property, which is an object representing the CSS applied to the element.
    For example, setting a value for box.style.left has the same effect as updating
    the value of left in the CSS file. In our handler, we set both the left and top
    values using the current position of the mouse.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个新增部分是使用 document.querySelector 查找 box 元素，并将该元素的引用保存到变量 box 中。接着，我们修改了之前写的
    mousemove 事件处理程序。为了让盒子移动，我们需要修改它的 style 属性，style 是一个代表应用于该元素的 CSS 的对象。例如，设置 box.style.left
    就和在 CSS 文件中更新 left 的值效果相同。在我们的事件处理程序中，我们使用当前鼠标的位置设置 left 和 top 的值。
- en: As mentioned in [Chapter 7](chapter7.xhtml), numeric values in CSS require a
    unit. We can’t just assign a number, like box.style.left = 10. Instead, we have
    to provide a string including the units, like box.style.left = "10px". This is
    why we include + "px" at the end of each statement in our event handler. If e.clientX
    is 50, then e.clientX + "px" will give the string "50px", which gets assigned
    to the box.style.left property, updating the left position of the box. As the
    mouse moves, this handler will be called with e.clientX and e.clientY set to the
    current position of the mouse, and so the pink box will move around as your mouse
    moves. Refresh the page and give it a try!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 7 章](chapter7.xhtml)所述，CSS 中的数值需要一个单位。我们不能仅仅赋值一个数字，比如 box.style.left = 10。相反，我们必须提供一个包含单位的字符串，例如
    box.style.left = "10px"。这就是为什么我们在事件处理器的每个语句末尾都要加上 + "px"。如果 e.clientX 为 50，那么
    e.clientX + "px" 会得到字符串 "50px"，它会被赋值给 box.style.left 属性，从而更新盒子的位置。随着鼠标的移动，这个处理器会被调用，e.clientX
    和 e.clientY 将设置为当前鼠标的位置，这样粉色的盒子就会随着鼠标的移动而移动。刷新页面并试试看！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Keyboard Events</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">键盘事件</samp>
- en: Keyboard events are triggered when keys are pressed on the keyboard. We’ll focus
    on one keyboard event, called keydown, which is triggered when a key is pressed
    down. (As you might expect, there’s a corresponding event called keyup that is
    triggered when a key is released.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘事件是在键盘上按下键时触发的。我们将关注一个键盘事件，叫做 keydown，它会在按下某个键时触发。（正如你所预料的，实际上还有一个对应的事件叫做
    keyup，它会在释放某个键时触发。）
- en: We’ll add a handler to our web page that simply logs keydown events to the console
    as they happen. Add the code in [Listing 8-12](#Lis8-12) to the end of *script.js*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为网页添加一个处理器，它简单地将 keydown 事件记录到控制台。将[清单 8-12](#Lis8-12)中的代码添加到 *script.js*
    的末尾。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Logging keydown
    events</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-12：记录 keydown 事件</samp>
- en: As in [Listing 8-11](#Lis8-11), we’re adding an event handler to the html element,
    meaning it will apply to the entire web page, but this time we’re handling the
    keydown event. This event will be triggered whenever you press down a key on your
    keyboard. Our handler logs e to the console, meaning the entire event object will
    be logged when a key is pressed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 8-11](#Lis8-11)所示，我们将一个事件处理器添加到 html 元素上，意味着它会应用于整个网页，但这次我们处理的是 keydown
    事件。每当你按下键盘上的一个键时，这个事件就会被触发。我们的处理器会将 e 输出到控制台，这意味着每当按键时，整个事件对象都会被打印出来。
- en: 'Try reloading the page to see the handler in action. You’ll need to open the
    console, then click inside the document to give it *focus*. This just means that
    the key presses will get sent to your web page, instead of to the console’s text
    input. As long as everything’s set up correctly, you should see events being logged
    to the console as you type, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新加载页面，查看事件处理器的实际效果。你需要打开控制台，然后点击文档内部，使其获得*焦点*。这意味着按键事件将发送到你的网页，而不是控制台的文本输入框。只要一切设置正确，你应该能看到在你输入时事件会被记录到控制台，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click the arrow next to one of the events to see the properties each event has.
    As you’ll see, there are a lot, but we mostly care about which key was pressed,
    which we can find with the key property. We’ll use this information next to move
    the pink box around using the keyboard.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点击某个事件旁边的箭头，查看该事件拥有的属性。如你所见，有很多属性，但我们主要关心的是哪个键被按下，这可以通过 key 属性找到。接下来我们将使用这些信息来通过键盘移动粉色的盒子。
- en: In order to move the box around, we’ll create two new variables to keep track
    of its x- and y-positions. Then we’ll update those variables with an event handler
    when specific keys are pressed. Update *script.js* as shown in [Listing 8-13](#Lis8-13).
    (Note that the mousemove handler has been removed in this listing.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动这个盒子，我们将创建两个新的变量来跟踪它的 x 和 y 坐标。然后，当特定的按键被按下时，我们将通过事件处理器更新这些变量。按照[清单 8-13](#Lis8-13)中所示更新*script.js*。（注意，在这个清单中，mousemove
    事件处理器已经被移除。）
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Using keydown
    events to move the box</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-13：使用 keydown 事件移动盒子</samp>
- en: We create two variables called currentX and currentY to store the location of
    the box. Then we modify our keydown handler to include an if…else statement that
    checks to see if the event’s key property matches any of "w", "a", "s", or "d".
    If so, that indicates one of those four keys has been pressed (I’m using these
    keys as they’re typically used for movement in games). Depending on which key
    has been pressed, we add or subtract 5 to or from currentX or currentY, corresponding
    to the box moving 5 pixels up, down, left, or right. After we update the appropriate
    variable, we update the style of the box with box.style.left and box.style.top,
    as we did in [Listing 8-11](#Lis8-11). This time, however, we use the values of
    currentX and currentY to change the CSS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个变量，分别叫做currentX和currentY，用来存储方块的位置。然后我们修改了keydown事件处理程序，加入了一个if…else语句，用来检查事件的key属性是否匹配"w"、"a"、"s"或"d"中的任何一个。如果匹配，说明这四个按键中的一个被按下（我使用这些按键是因为它们通常用于游戏中的移动）。根据按下的是哪个按键，我们会向currentX或currentY添加或减去5，表示方块向上、向下、向左或向右移动5像素。更新完相应的变量后，我们使用box.style.left和box.style.top更新方块的样式，就像我们在[列表8-11](#Lis8-11)中做的那样。不过这一次，我们使用currentX和currentY的值来改变CSS。
- en: When you reload the page, try pressing and holding down S or D to make the box
    move down or to the right. You should notice that holding the key down results
    in the box continuing to move, as the keyboard sends repeated keydown events.
    This is the normal behavior of a computer keyboard when you hold down a key. The
    exact repeat speed is controlled by your operating system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面时，尝试按住S或D键，让方块向下或向右移动。你应该会注意到，按住键不放时，方块会继续移动，因为键盘会发送重复的keydown事件。这是计算机键盘的正常行为，当你按住一个键时。重复的速度由操作系统控制。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned the basics of DOM events and event handling. DOM
    events are how the browser tells your code that something happened on your page.
    You can respond to these events with event handlers, JavaScript functions that
    are executed when a certain event happens to a certain DOM element. Event handlers
    allow you to create web pages that respond interactively to the user’s actions.
    In particular, you saw how to write event handlers triggered by clicks, mouse
    movements, and key presses.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了DOM事件和事件处理的基础知识。DOM事件是浏览器通知代码页面上发生了某些事情的方式。你可以通过事件处理器来响应这些事件，事件处理器是当特定事件发生在特定的DOM元素上时执行的JavaScript函数。事件处理器让你能够创建响应用户操作的互动网页。特别地，你看到了如何编写由点击、鼠标移动和按键触发的事件处理器。
