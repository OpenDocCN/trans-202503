- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVENT-BASED
    PROGRAMMING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When a user clicks a button, scrolls, or simply moves the mouse within a web
    page, that action creates an *event*. An event is the browser’s way of signaling
    that an action happened in the DOM. Events allow us to create interactive web
    applications that respond to the user’s actions. We do this by writing *handlers*
    for specific events: functions that are called when an event occurs. Using event
    handlers, we can change the color of an element when the user clicks it, move
    an element around the screen when the user presses a certain key, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn how to write event handlers to respond to some
    common DOM events. In this way, you’ll add interactivity to your web pages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Event Handlers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Events are how the browser tells JavaScript that something has occurred in the
    DOM. It’s almost as if every time the mouse moves over the window, or a key is
    pressed, the browser is shouting, “Hey, the mouse moved! A key was pressed!” These
    shouts happen all the time, but your JavaScript code can respond to them only
    if you explicitly tell it to listen for them. You do this by writing a JavaScript
    event handler that will perform some action when a certain type of event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: An *event handler* is a function triggered by a specific event type on a specific
    element. For example, you could attach a handler to a particular h1 element that
    handles clicks on that element. Let’s try that out now. We’ll create a simple
    web page with a heading and use an event handler to log a message to the console
    when the heading is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll need an HTML file. Create a new directory called *chapter8* and
    make a new file in that directory called *index.html*. Enter the content shown
    in [Listing 8-1](#Lis8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring event handlers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, our HTML file has a single html element containing a head with some
    metadata and a body with some content. Specifically, the body contains an h1 element
    with an ID of main-heading, and part of the heading text is wrapped in an em element
    (short for *emphasis*), which by default italicizes that portion of the text.
    It also contains a script element with a link to the file *script.js*. In a moment,
    that’s where we’ll write the code for our event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, this file is very similar to the *index.html* file we created in [Chapter
    7](chapter7.xhtml), with one important difference: the script element is inside
    the body element, not the head element. This is a bit of a cheat to get around
    a problem with how web browsers read web pages. As described in the previous chapter,
    the browser builds a model of the page called the DOM. It builds the DOM incrementally
    by reading through the HTML file from top to bottom. Anytime the browser reaches
    a script element, it executes the whole script before continuing. That means that
    if we had our script element in the head, and we looked up the h1 element in that
    script, the h1 element wouldn’t be in the DOM yet! By placing the script element
    at the end of the body, we can be sure that all the page content has been loaded
    into the DOM *before* we run our JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Now create a file called *script.js* in the same directory as the HTML code,
    and enter the script shown in [Listing 8-2](#Lis8-2). This script adds an event
    handler for when the user clicks the h1 element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Creating an event
    handler in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using the DOM API’s querySelector method, we get the element with the ID main-heading
    and save it as the variable heading. You may recall from [Chapter 7](chapter7.xhtml)
    that this method returns the first element to match the selector. In our case,
    there’s only one main-heading element, so we know this method will select the
    element we want. We then use the addEventListener method on the heading element
    to attach an event handler to that element. addEventListener tells JavaScript
    to watch for a particular event happening on the element, and to execute some
    function when it does.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although the DOM API uses the term* listener*, the term* handler *is more
    commonly used to describe a function that reacts to an event.*'
  prefs: []
  type: TYPE_NORMAL
- en: The addEventListener method has two required arguments. The first is the event
    type. This is a string representing the type of event to respond to, such as "click"
    (for mouse clicks), "keydown" (for keyboard key presses), or "scroll" (for window
    scrolling). We’ve specified "click". The second argument is the function to execute
    when the specified event happens. This function is the event handler. It will
    be called anytime the event happens on the element addEventListener was called
    on. In this case, the function, which logs a message to the console, will be called
    anytime someone clicks the heading element.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As explained in [Chapter 5](chapter5.xhtml), when a function is passed as
    an argument to another function, it’s known as a* callback function*, or simply
    a* callback*. All event handlers are callback functions, since they’re passed
    as arguments to the addEventListener method.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open *index.html* in your browser and open the console. When you click the
    heading, you should see the message "You clicked the heading!" printed to the
    console. Congratulations: you’ve made your first interactive web page!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Event Bubbling</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When an event is triggered on an element, it also gets triggered on all the
    element’s ancestors (that is, the parent of the element, the parent’s parent,
    and so on). For instance, when you clicked the h1 element in the previous example,
    you were also technically clicking the body element that contains the h1 element.
    This makes sense intuitively; if you click some text in a box, you’re also clicking
    the box. Therefore, if you had a separate handler attached to the body element,
    it would also receive the click event. This progression of events from children
    to ancestors is known as *event bubbling*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s harness bubbling by adding event handlers to the em and body elements
    in our web page. Like our h1 event handler, these new handlers will log a message
    to the console when their elements are clicked. Since em is a child of h1 and
    h1 is a child of body, a single click on em should trigger the handlers attached
    to all three elements.
  prefs: []
  type: TYPE_NORMAL
- en: Add the code in [Listing 8-3](#Lis8-3) to the end of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Adding more handlers
    to</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet adds two handlers, one to the em element and one to the body element,
    but we do it slightly differently from how we created the main-heading handler
    in [Listing 8-2](#Lis8-2). Instead of saving each element to a variable, we just
    call addEventListener directly on the result of the document.querySelector method.
    This technique of calling a method directly on the return value of another method
    is known as *method chaining*: we chain multiple method calls together, so that
    the result of the first link in the chain is used as the object for the next method
    call. I used the longer technique for [Listing 8-2](#Lis8-2) because it makes
    it more explicit that addEventListener is being called on an element, but the
    chaining technique is often preferred because of its terseness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload *index.html* and open the console. When you click the word *World!*
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you click the em element, the handler function on that element is the first
    to get called. After that, the handler function on the h1 element is called, followed
    by the one on the body element. This is because the event “bubbles up” through
    the DOM, from the innermost element to the outermost element. If you click the
    non-italic part of the heading, you’ll see just the main-heading and body handlers
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Event Delegation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the more common uses for event bubbling is *event delegation*, a technique
    where you use a single handler to respond to events on multiple child or other
    descendant elements. For example, imagine you have a list of words, where each
    list item is a separate HTML element, and you want to handle clicks on each item
    in the same way. By adding a single handler to the list items’ parent element,
    you can catch events on each item with only a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate event delegation, we’ll write a simple application that builds
    up and displays a sentence based on words that you click in a list. First, we’ll
    update our HTML file to include a list of words and an empty p element that we’ll
    populate dynamically with the words of your choice. Then, we’ll write the necessary
    event handler with JavaScript to take clicked words and add them to the p element
    for display. Finally, we’ll add some CSS rules to make the application easier
    to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of lists in HTML: ordered (numbered) lists and unordered
    (bulleted) lists. We’ll use an unordered list, which is created with the ul (*unordered
    list*) element. Each individual item in the list is wrapped in an li (*list item*)
    element. Therefore, the event resulting from a click on any li element will bubble
    up to the parent ul element.'
  prefs: []
  type: TYPE_NORMAL
- en: Update *index.html* as shown in [Listing 8-4](#Lis8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Adding a list
    to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This adds an unordered list of words to the document, as well as an empty p
    element, which we’ll be modifying with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write an event handler for the ul element to handle clicks on any
    of the list items. The handler will take the word that was clicked and add it
    to the p element, allowing you to build up a sentence one word at a time. Delete
    all the code in *script.js* and replace it with [Listing 8-5](#Lis8-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Delegating events</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we look up the two elements we care about using document.query Selector:
    the ul with the word list, and the empty p element. Next, we add a click handler
    to the ul element. This example is a little different from our previous handlers
    because the callback function has a parameter, which we’re calling event ❶. If
    we give a handler function a single parameter (in this case, event, but the exact
    name isn’t important), the parameter represents an object through which the DOM
    API passes information about the event that just happened. That information, which
    includes the element that was clicked, the element’s text content, and so on,
    then becomes available for use within the callback function.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we use the event object to determine what word was clicked and
    store it in the variable word ❷. We find out which specific element was clicked
    with the event object’s target property. When you click one of the li elements,
    event.target will be the li element you clicked, not the ul (the ul element is
    available with the currentTarget property). Then we use the textContent property,
    which returns the text of that element. Putting it together, if you were to click
    on the first li element, then event.target.textContent would return the string
    "The", and that string would become the value of the variable word.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the word the user clicked, we can add it to the sentence. We
    use the += operator to append the word to the text content of the sentence element.
    You may recall that sentence.textContent += word; essentially converts to sentence.textContent
    = sentence.textContent + word;. In other words, we’re taking the sentence element’s
    existing text content, adding the string stored in word to the end, and reassigning
    that text to the element’s text content. Then, after adding the word to the sentence,
    we use the same += trick to append a space to the end of the sentence in preparation
    for the next word that gets added.
  prefs: []
  type: TYPE_NORMAL
- en: Open *index.html* again in your browser. You should see the list of words. You
    won’t see the empty p element because it doesn’t have any content yet. As you
    click words from the list, you should see them being added to the p element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off our application, we need to add a small amount of CSS. JavaScript
    and CSS often go hand in hand because the styling can give helpful tips to the
    user that certain elements are interactive. In this case we’ll add two hints via
    CSS: we’ll modify the list items to change the mouse pointer to a finger when
    it hovers over them, so they look more “clickable,” and we’ll give the element
    that’s currently under the mouse pointer an underline so it’s easier to tell which
    word you’re about to click (which isn’t always obvious when the mouse is in the
    vertical space between words).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new CSS file called *style.css* and add the two CSS declarations shown
    in [Listing 8-6](#Lis8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Adding styling
    in</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the cursor for li elements, we use cursor: pointer. This changes
    the cursor from the default arrow to a hand with a finger when it is over an li
    element, as happens when you hover over a link on a web page. The li:hover selector
    uses the :hover pseudo-class. A *pseudo-class* is a kind of selector that applies
    only when an element is in a certain state: li:hover matches any li element that
    the mouse is currently hovering over. When the pointer is over an li element,
    we use text-decoration: underline to underline the text of that element.'
  prefs: []
  type: TYPE_NORMAL
- en: To include this CSS on the page, add a link element to the head of the *index.html*
    file, as shown in [Listing 8-7](#Lis8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Including</samp>
    <samp class="SANS_Futura_Std_Book_11">style.css</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you hover over one of the list items, the cursor will change, and the
    currently hovered word will be underlined, as shown in [Figure 8-1](chapter8.xhtml#fig8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_8-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Using CSS to give
    hints to users</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With that styling, our sentence-building application is complete! Event delegation
    simplified the JavaScript we wrote by letting us attach a single event handler,
    rather than using a separate handler for each list item.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mouse Movement Events</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DOM produces events when the mouse moves, with the event name mousemove.
    These mousemove events are triggered on an element while the mouse moves over
    that element, and we can listen for them with the addEventListener method, just
    as we did for mouse clicks. Let’s set up a simple mousemove handler to see it
    in action. The handler will log the mouse’s position to the console as the mouse
    moves around the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Still working within your *chapter8* project folder, add the code in [Listing
    8-8](#Lis8-8) to the end of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: A mousemove event
    handler</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we add a mousemove event handler to the html element. Since
    the html element encompasses the entire web page, this handler will respond to
    movements of the mouse anywhere in the browser window. The handler logs a message
    to the console including the clientX and clientY properties of the event, which
    tell us the x- and y-coordinates of the mouse relative to the browser window.
    In this example I’m using the shorter name e for the event parameter, rather than
    event, as in [Listing 8-5](#Lis8-5). Remember, the name of the parameter doesn’t
    matter; if the event handler callback function has a single parameter, that parameter
    will carry information about the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh *index.html* in your browser and move the mouse pointer over the page.
    You should see messages similar to the following logged to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are two important things to note as you watch the console. First, the
    coordinates start at 0 in the top-left corner of the browser window, increasing
    as you go across and down. The x-coordinate increases as you move right, and the
    y-coordinate increases as you move down. This follows the standard convention
    for computer graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Second, there are “gaps,” or locations that the mouse appears to jump over.
    This is because mousemove events aren’t triggered continuously, but some limited
    number of times per second. The exact number depends on the mouse, the browser,
    and the computer, but it tends to be in the low hundreds. Therefore, if you move
    the mouse fast enough, there will be locations on the screen that the mouse seems
    to skip over, because the events weren’t triggering fast enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen mousemove events in action, we can try to do something
    slightly more interesting with them. In this next example, we’ll make a box move
    around the page, following your cursor. To do that we’ll need to modify our HTML,
    CSS, and JavaScript files. The HTML change is simple. Add the new line in [Listing
    8-9](#Lis8-9) to *index.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: Adding a div to</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re using a new HTML element called div, short for *content division*.
    It will become the movable box on our page. The div element is HTML’s generic
    container element. This means that it’s an element that can contain other elements,
    but by default has no appearance and no specific *meaning* (unlike ul, which means
    a list, or h1, which means a heading). We’ll use CSS to give the div element an
    appearance next. Add the contents of [Listing 8-10](#Lis8-10) to the end of *style.css*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Styling the div
    with CSS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we’re using #box to select the element with the ID box. There are a number
    of declarations within this ruleset. The first, position: fixed, tells the browser
    to put this element at the position specified next, by the left and top declarations.
    We indicate 0px for both, which tells the browser to put the element at the very
    top-left corner of the browser *viewport*, the part of the browser that shows
    the content. We specify the width and height of the element to be 10 pixels each.
    Finally, we give our 10×10 box a background color that’s sure to jump out: hot
    pink.'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page now, and you’ll see a small pink square appear in the top-left
    corner. Now it’s time to write an event handler so you can move the square with
    your mouse. Modify *script.js* as shown in [Listing 8-11](#Lis8-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Moving the div
    with JavaScript</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first addition here is to find the box using document.querySelector and
    save a reference to the element in the variable box. Next, we modify the mousemove
    event handler we wrote earlier. In order to move the box around, we’re modifying
    its style property, which is an object representing the CSS applied to the element.
    For example, setting a value for box.style.left has the same effect as updating
    the value of left in the CSS file. In our handler, we set both the left and top
    values using the current position of the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 7](chapter7.xhtml), numeric values in CSS require a
    unit. We can’t just assign a number, like box.style.left = 10. Instead, we have
    to provide a string including the units, like box.style.left = "10px". This is
    why we include + "px" at the end of each statement in our event handler. If e.clientX
    is 50, then e.clientX + "px" will give the string "50px", which gets assigned
    to the box.style.left property, updating the left position of the box. As the
    mouse moves, this handler will be called with e.clientX and e.clientY set to the
    current position of the mouse, and so the pink box will move around as your mouse
    moves. Refresh the page and give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Keyboard Events</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keyboard events are triggered when keys are pressed on the keyboard. We’ll focus
    on one keyboard event, called keydown, which is triggered when a key is pressed
    down. (As you might expect, there’s a corresponding event called keyup that is
    triggered when a key is released.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add a handler to our web page that simply logs keydown events to the console
    as they happen. Add the code in [Listing 8-12](#Lis8-12) to the end of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Logging keydown
    events</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 8-11](#Lis8-11), we’re adding an event handler to the html element,
    meaning it will apply to the entire web page, but this time we’re handling the
    keydown event. This event will be triggered whenever you press down a key on your
    keyboard. Our handler logs e to the console, meaning the entire event object will
    be logged when a key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try reloading the page to see the handler in action. You’ll need to open the
    console, then click inside the document to give it *focus*. This just means that
    the key presses will get sent to your web page, instead of to the console’s text
    input. As long as everything’s set up correctly, you should see events being logged
    to the console as you type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Click the arrow next to one of the events to see the properties each event has.
    As you’ll see, there are a lot, but we mostly care about which key was pressed,
    which we can find with the key property. We’ll use this information next to move
    the pink box around using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: In order to move the box around, we’ll create two new variables to keep track
    of its x- and y-positions. Then we’ll update those variables with an event handler
    when specific keys are pressed. Update *script.js* as shown in [Listing 8-13](#Lis8-13).
    (Note that the mousemove handler has been removed in this listing.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Using keydown
    events to move the box</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create two variables called currentX and currentY to store the location of
    the box. Then we modify our keydown handler to include an if…else statement that
    checks to see if the event’s key property matches any of "w", "a", "s", or "d".
    If so, that indicates one of those four keys has been pressed (I’m using these
    keys as they’re typically used for movement in games). Depending on which key
    has been pressed, we add or subtract 5 to or from currentX or currentY, corresponding
    to the box moving 5 pixels up, down, left, or right. After we update the appropriate
    variable, we update the style of the box with box.style.left and box.style.top,
    as we did in [Listing 8-11](#Lis8-11). This time, however, we use the values of
    currentX and currentY to change the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: When you reload the page, try pressing and holding down S or D to make the box
    move down or to the right. You should notice that holding the key down results
    in the box continuing to move, as the keyboard sends repeated keydown events.
    This is the normal behavior of a computer keyboard when you hold down a key. The
    exact repeat speed is controlled by your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned the basics of DOM events and event handling. DOM
    events are how the browser tells your code that something happened on your page.
    You can respond to these events with event handlers, JavaScript functions that
    are executed when a certain event happens to a certain DOM element. Event handlers
    allow you to create web pages that respond interactively to the user’s actions.
    In particular, you saw how to write event handlers triggered by clicks, mouse
    movements, and key presses.
  prefs: []
  type: TYPE_NORMAL
