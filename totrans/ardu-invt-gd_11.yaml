- en: 10 Tiny Electric Piano
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10个微型电子钢琴
- en: In this project, you’ll use a special touch sensor and a piezo buzzer to create
    an Arduino piano ([Figure 10-1](ch10.xhtml#ch10fig01)). Regardless of whether
    you have any musical talent, this will be a fun project!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用一种特殊的触摸传感器和一个压电蜂鸣器来制作一个Arduino钢琴（见[图10-1](ch10.xhtml#ch10fig01)）。无论你是否具备音乐才能，这都将是一个有趣的项目！
- en: '**FIGURE 10-1:** A completed Tiny Electric Piano'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-1：** 完成的微型电子钢琴'
- en: '![Image](../images/fig10_1.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_1.jpg)'
- en: '**MATERIALS TO GATHER**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**所需材料**'
- en: There are only a couple new parts in this project. One is the *soft potentiometer
    (SoftPot)*, which will act as your keyboard, and the other is the *piezo buzzer*,
    which will provide the sound. The supplies you’ll need are shown in [Figures 10-2](ch10.xhtml#ch10fig02)
    and [10-3](ch10.xhtml#ch10fig03). Grab your materials, and let’s get started.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中只有几个新部件。一个是*软电位器（SoftPot）*，它将作为你的键盘，另一个是*压电蜂鸣器*，它将提供声音。你需要的材料如[图10-2](ch10.xhtml#ch10fig02)和[图10-3](ch10.xhtml#ch10fig03)所示。准备好你的材料，我们开始吧。
- en: '**Electronic Parts**'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**电子部件**'
- en: • One SparkFun RedBoard (DEV-13975), Arduino Uno (DEV-11021), or any other Arduino-compatible
    board
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个SparkFun RedBoard（DEV-13975），Arduino Uno（DEV-11021），或任何兼容Arduino的开发板
- en: • One USB Mini-B cable (CAB-11301 or your board’s USB cable)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 一根USB Mini-B电缆（CAB-11301，或你的开发板USB电缆）
- en: • One solderless breadboard (PRT-12002)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个无焊面包板（PRT-12002）
- en: • One 10 kΩ resistor (COM-08374, or COM-11508 for a pack of 20)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个10 kΩ电阻（COM-08374，或20个装的COM-11508）
- en: • One 50 mm SoftPot membrane potentiometer (SEN-08680)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个50毫米SoftPot膜电位器（SEN-08680）
- en: • One piezo buzzer (COM-07950)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个压电蜂鸣器（COM-07950）
- en: • Male-to-male jumper wires (PRT-11026)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 公对公跳线（PRT-11026）
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All of the parts used in this project are standard in the SparkFun Inventor’s
    Kit.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*本项目中使用的所有部件均为SparkFun发明者套件中的标准部件。*'
- en: '**FIGURE 10-2:** Components for the Tiny Electric Piano'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-2：** 微型电子钢琴的组件'
- en: '![Image](../images/fig10_2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_2.jpg)'
- en: '**Other Materials and Tools**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**其他材料和工具**'
- en: • Pencil
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: • 铅笔
- en: • Craft knife
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: • 工艺刀
- en: • Metal ruler
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: • 金属尺
- en: • (Optional) Soldering iron
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: • （可选）电烙铁
- en: • Masking tape
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: • 遮蔽胶带
- en: • Cardboard or cardstock (about 4 × 5 inches) or a small cardboard box
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 硬纸板或卡纸（约4 × 5英寸）或一个小纸盒
- en: '**FIGURE 10-3:** Additional supplies'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-3：** 额外的材料'
- en: '![Image](../images/fig10_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_3.jpg)'
- en: '**NEW COMPONENTS**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**新组件**'
- en: 'As we mentioned, this project will introduce just two new parts. The first
    is a SoftPot touch sensor: a special kind of potentiometer that is similar to
    the one used in [Project 6](ch06.xhtml#ch06) but reacts to pressure. The second
    new part is a piezo buzzer. Let’s take a look at these two parts in more detail.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所述，本项目只引入两个新部件。第一个是SoftPot触摸传感器：一种特殊类型的电位器，类似于[项目6](ch06.xhtml#ch06)中使用的，但它会对压力做出反应。第二个新部件是压电蜂鸣器。让我们更详细地了解这两个部件。
- en: '**The SoftPot Membrane Potentiometer**'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SoftPot膜电位器**'
- en: In [Project 6](ch06.xhtml#ch06), we introduced a simple potentiometer with a
    knob that you could turn to control the Balance Beam. The SoftPot, shown in [Figure
    10-4](ch10.xhtml#ch10fig04), works similarly but reacts to pressure instead of
    knob rotation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[项目6](ch06.xhtml#ch06)中，我们介绍了一种简单的电位器，带有旋钮，可以用来控制平衡梁。SoftPot，如[图10-4](ch10.xhtml#ch10fig04)所示，工作原理相似，但它对压力做出反应，而不是旋转旋钮。
- en: '**FIGURE 10-4:** A 50 mm SoftPot'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-4：** 50毫米SoftPot'
- en: '![Image](../images/fig10_4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_4.jpg)'
- en: The SoftPot is a thin and flexible sensor that can detect where along its length
    pressure is applied. When you press down, the resistance between the middle pin
    and the closest end pin varies between 0 Ω and 10 kΩ, depending on how much pressure
    is detected. The SoftPot sensor has a thin membrane that separates the center
    pin connection from the outer ones. This sensor is very accurate and has a nearly
    infinite resolution. In industrial applications, the SoftPot is often used to
    identify the position of sliding parts, robot arms, and other components that
    make precision movements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot是一种薄而柔韧的传感器，可以检测沿其长度施加压力的位置。当你按压时，中间引脚和最接近的端引脚之间的电阻会在0Ω和10kΩ之间变化，具体取决于检测到的压力大小。SoftPot传感器有一层薄膜，将中间引脚连接与外侧引脚分开。该传感器非常精确，几乎具有无限的分辨率。在工业应用中，SoftPot常用于识别滑动部件、机器人手臂以及其他进行精确运动的部件的位置。
- en: In this project, you’re going to use this sensor as your piano keyboard. You’ll
    divide the length of the strip into eight sections or “keys” that you can use
    to play various notes. The SoftPot is effectively the same as a knob potentiometer
    used in earlier projects. In schematics and circuit diagrams, you may recognize
    the symbol as pictured in [Figure 10-5](ch10.xhtml#ch10fig05).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用这个传感器作为钢琴键盘。你将把条形的长度分成八个部分或“键”，用来演奏不同的音符。SoftPot 实际上与之前项目中使用的旋钮电位器相同。在电路图和示意图中，你可能会看到与[图
    10-5](ch10.xhtml#ch10fig05)相同的符号。
- en: '**FIGURE 10-5:** The schematic diagram for the SoftPot is identical to that
    of the regular potentiometer.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-5：** SoftPot 的电路图与常规电位器的电路图完全相同。'
- en: '![Image](../images/fig10_5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_5.jpg)'
- en: '**The Piezo Buzzer**'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**压电蜂鸣器**'
- en: The piezo buzzer ([Figure 10-6](ch10.xhtml#ch10fig06)) is similar to a speaker
    and produces an audible click when you apply a voltage to the two leads; these
    clicks happen very fast, several hundreds or even thousands of times per second,
    and their frequency creates a tone. Inside a typical piezo buzzer is a special
    crystal called a *piezo element* that deforms when voltage is applied. The crystal
    is connected to a round metal disc, and when the crystal deforms, the disc vibrates
    the air inside a small cylinder, producing the clicking sound.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 压电蜂鸣器（[图 10-6](ch10.xhtml#ch10fig06)）类似于扬声器，当你对两个引脚施加电压时，会产生可听见的“咔嗒”声；这些“咔嗒”声发生得非常快，每秒几百次甚至几千次，其频率产生了音调。在典型的压电蜂鸣器内部，有一个特殊的晶体，叫做*压电元件*，当施加电压时它会发生形变。晶体与一个圆形金属片连接，当晶体形变时，金属片会震动小圆柱内的空气，从而产生“咔嗒”声。
- en: '**FIGURE 10-6:** Piezo buzzer'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-6：** 压电蜂鸣器'
- en: '![Image](../images/fig10_6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_6.jpg)'
- en: '**NOTE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The buzzer that’s included in the SparkFun Inventor’s Kit actually uses a
    small magnetic coil instead of a piezo element, but it works the same. We still
    refer to it as a piezo buzzer.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*包含在 SparkFun 发明者套件中的蜂鸣器实际上使用的是一个小型磁性线圈，而不是压电元件，但它的工作原理是相同的。我们仍然称其为压电蜂鸣器。*'
- en: You’ve already seen how you can blink an LED at various rates with the Arduino.
    Now, if you “blink” the buzzer at a rate of hundreds of times per second, we can
    convert these clicks into tones! There are several different electrical symbols
    used to represent buzzers, speakers, and similar elements. The symbol we’ll use
    in this chapter is shown in [Figure 10-7](ch10.xhtml#ch10fig07).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用 Arduino 以不同的速度闪烁 LED 了。现在，如果你以每秒数百次的速率“闪烁”蜂鸣器，我们就可以将这些“咔嗒”声转换为音调！用于表示蜂鸣器、扬声器和类似元件的电气符号有几种不同的形式。我们在本章中使用的符号如[图
    10-7](ch10.xhtml#ch10fig07)所示。
- en: '**FIGURE 10-7:** Electrical symbol for a piezo buzzer'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-7：** 蜂鸣器的电气符号'
- en: '![Image](../images/fig10_7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_7.jpg)'
- en: '**BUILD THE CIRCUIT**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建电路**'
- en: 'This circuit uses only two electronic elements: the buzzer and the SoftPot,
    shown in [Figures 10-8](ch10.xhtml#ch10fig08) and [10-9](ch10.xhtml#ch10fig09).
    When inserting the buzzer into the breadboard, you may notice that the legs are
    slightly closer together than the holes of the board. Just gently bend the legs
    apart so that the pins line up with the holes and insert the buzzer. The legs
    should be three holes apart.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路只使用了两个电子元件：蜂鸣器和 SoftPot，分别如[图 10-8](ch10.xhtml#ch10fig08)和[图 10-9](ch10.xhtml#ch10fig09)所示。将蜂鸣器插入面包板时，你可能会注意到其引脚比面包板的孔稍微靠得更近。只需轻轻弯曲引脚，使其与孔对齐，然后插入蜂鸣器。引脚应该与三个孔的间距一致。
- en: The SoftPot has three legs like the potentiometer you used in [Project 6](ch06.xhtml#ch06).
    But unlike a regular potentiometer, the SoftPot requires a pull-down resistor
    to ensure that, when there is no input or pressure on the sensor, the SoftPot
    defaults to a nominal state of 0\. This will prevent the buzzer from making noise
    when you aren’t pressing on the sensor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot 有三个引脚，类似于你在[第 6 章](ch06.xhtml#ch06)中使用的电位器。但与常规电位器不同，SoftPot 需要一个下拉电阻，以确保当没有输入或没有施加压力时，SoftPot
    默认为 0 的状态。这将防止在没有按压传感器时蜂鸣器发出噪音。
- en: '**FIGURE 10-8:** Schematic diagram of the Tiny Electric Piano circuit'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-8：** 微型电子钢琴电路的示意图'
- en: '![Image](../images/fig10_8.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_8.jpg)'
- en: '**FIGURE 10-9:** Prototype of the Tiny Electric Piano circuit on the breadboard'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-9：** 微型电子钢琴电路在面包板上的原型'
- en: '![Image](../images/fig10_9.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_9.jpg)'
- en: Assemble the circuit as shown in the diagram. The circuit is fairly simple.
    First, connect 5 V and GND to the power and ground rails on the left side of the
    breadboard. Next, add the buzzer roughly 10 rows down from the top of the breadboard.
    Connect one leg of the buzzer to pin 9 of the Arduino and the other leg of the
    buzzer to the ground rail. Then, insert the SoftPot near the bottom of the breadboard.
    Connect the top pin of the SoftPot to the 5 V power rail, the lower pin to the
    ground rail, and the middle pin to the analog input pin A0 on the Arduino. Remember
    that the SoftPot requires a pull-down resistor between the wiper pin (middle pin)
    and the ground rail. Finally, add a 10 kΩ resistor between the middle pin and
    the ground rail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图示组装电路。电路相当简单。首先，将5V和GND连接到面包板左侧的电源和接地轨道。接着，把蜂鸣器大约放置在面包板顶部10行的位置。将蜂鸣器的一端连接到Arduino的引脚9，另一端连接到接地轨道。然后，将SoftPot插入面包板的底部。将SoftPot的顶部引脚连接到5V电源轨道，底部引脚连接到接地轨道，中间引脚连接到Arduino的模拟输入引脚A0。记住，SoftPot需要一个下拉电阻连接在滑动引脚（中间引脚）和接地轨道之间。最后，在中间引脚和接地轨道之间添加一个10
    kΩ的电阻。
- en: Once you have it built, it’s time to try a couple of code examples.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了搭建，就可以尝试几个代码示例了。
- en: '**PROGRAM THE TINY ELECTRIC PIANO**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程迷你电子钢琴**'
- en: First, you’ll test the build by having the buzzer make noises and recognizable
    tones, and then you’ll map those noises and tones to the SoftPot. Once you know
    how to get your code making sounds, we’ll show you how to add functionality so
    that you can play up to eight distinct notes, like a small piano.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将通过让蜂鸣器发出噪音和可识别的音调来测试构建，然后将这些噪音和音调映射到SoftPot上。一旦你了解了如何让代码发出声音，我们将向你展示如何添加功能，使你可以像玩一个小钢琴一样演奏多达八个不同的音符。
- en: You’ve already seen that the Arduino can generate really fast pulses and react
    to split-second button presses. With your circuit wired up, you’ll use these capabilities
    to make some fun sounds and test the frequency response of the buzzer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到Arduino能够生成非常快速的脉冲并响应瞬间的按钮按压。连接好电路后，你将利用这些功能来发出一些有趣的声音，并测试蜂鸣器的频率响应。
- en: '**Test the Buzzer**'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**测试蜂鸣器**'
- en: 'Arduino has a few commands that make playing notes really simple. There are
    two functions that control making sounds with Arduino: `tone()`, which tells the
    buzzer to play a frequency you specify, and `noTone()`, which tells the buzzer
    to stop the sound so you can control the length of the note. Here’s how you use
    these two functions.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino有一些命令，使得播放音符变得非常简单。控制Arduino发出声音的有两个函数：`tone()`，它让蜂鸣器播放你指定的频率，以及`noTone()`，它告诉蜂鸣器停止发声，以便你控制音符的时长。以下是如何使用这两个函数的说明。
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `tone()` function needs to be called with three parameters: the pin number
    the buzzer is connected to, a frequency you want to play, and the duration to
    play the note. When called, `tone()` creates a square wave at the frequency you
    provided on the defined pin for a specific duration. This square wave triggers
    the vibration of the disc inside the buzzer connected to this pin, creating a
    sound at that frequency. Once started, `tone()` continues for the duration specified
    or until you call either another `tone()` command with a different frequency or
    the `noTone()` command to stop the Arduino from playing.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`tone()`函数需要三个参数：蜂鸣器连接的引脚号、要播放的频率和播放音符的持续时间。调用时，`tone()`会在指定的引脚上生成一个你提供的频率的方波，持续指定的时间。这个方波触发了连接到该引脚的蜂鸣器内部的圆盘振动，从而发出该频率的声音。开始后，`tone()`会持续指定的时间，或者直到你调用另一个不同频率的`tone()`命令，或者调用`noTone()`命令停止Arduino播放声音。'
- en: Copy the code from [Listing 10-1](ch10.xhtml#ch10ex01) into the Arduino IDE
    or download the sketch from *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*.
    In this example, you’ll use the Serial Monitor to choose a frequency, and the
    buzzer will play that tone for half a second.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单10-1](ch10.xhtml#ch10ex01)中的代码复制到Arduino IDE中，或从* [https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*下载草图。在这个示例中，你将使用串口监视器来选择频率，蜂鸣器将在半秒钟内播放该音调。
- en: '**LISTING 10-1:** Serial tone test code'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 10-1：** 串口音调测试代码'
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s take a look at how this all works. In the `setup()`, the sketch sets the
    `pinMode` ➊ for the GPIO pin on the buzzer, initializes the serial communication
    on the Arduino, and prints a short message instructing the player on what to do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这一切是如何工作的。在`setup()`中，草图设置了蜂鸣器GPIO引脚的`pinMode` ➊，初始化了Arduino上的串口通信，并打印出一条简短的消息，指示玩家该做什么。
- en: 'Next, inside the `loop()`, the `if(Serial.available() > 0)` statement ➋ checks
    for data sent over serial communication like so: `Serial.available()` returns
    the number of bytes received from the Serial Monitor, and the `if()` statement
    compares that value to zero; if the number of bytes is greater than zero, it means
    data was received, and the script reads the data ➌. The `Serial.parseInt()` function
    converts the data into an integer, which is then stored in the variable `freq`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`loop()`中，`if(Serial.available() > 0)`语句➋检查是否有数据通过串口通信发送过来，代码如下：`Serial.available()`返回从串口监视器接收到的字节数，而`if()`语句将该值与零进行比较；如果字节数大于零，则意味着数据已接收，脚本会读取这些数据➌。`Serial.parseInt()`函数将数据转换为整数，并将其存储在变量`freq`中。
- en: 'The code plays the frequency stored in `freq` for 500 ms using the `tone()`
    function ➍ and then has a short `delay()` ➎. The `delay()` ensures that the note
    plays for the full 500 ms before starting another note. The `tone()` command is
    a *nonblocking function*: it executes and then continues to the next instruction
    without waiting.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`tone()`函数➍播放存储在`freq`中的频率500毫秒，然后有一个短暂的`delay()` ➎。`delay()`确保音符播放完500毫秒后才会开始下一个音符。`tone()`命令是一个*非阻塞函数*：它执行完后会继续执行下一条指令，而不需要等待。
- en: After uploading this sketch to your device, open the Serial Monitor (CTRL-SHIFT-M
    or **Tools ▸ Serial Monitor**). Then, click the line-ending-character drop-down
    list ([Figure 10-10](ch10.xhtml#ch10fig10)), and select **No line ending**. When
    you send data between digital devices, an invisible *end-of-line (EOL)* character
    is sometimes used to indicate the end of a message. The two most commonly used
    EOL characters are the *new line (NL)* and *carriage return (CR)*. While the character
    may appear to be invisible, to the Arduino this character still reads in as a
    value. Selecting this option makes sure that it doesn’t send any extra characters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此草图上传到你的设备后，打开串口监视器（CTRL-SHIFT-M 或 **工具 ▸ 串口监视器**）。然后，点击行结束符下拉列表（[图10-10](ch10.xhtml#ch10fig10)），并选择**无行结束符**。当你在数字设备之间发送数据时，有时会使用一个不可见的*行结束符（EOL）*字符来表示消息的结束。最常用的两个EOL字符是*换行符（NL）*和*回车符（CR）*。虽然该字符可能看起来是不可见的，但对于Arduino来说，这个字符仍然会被读取为一个值。选择此选项可以确保它不会发送任何额外的字符。
- en: Now, in the box at the very top, you can type any number and press ENTER, and
    the buzzer will play that note for half a second (500 ms). The range of human
    hearing is about 20 Hz to 20,000 Hz, so play around with some different frequencies,
    but keep them within that range.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在最上方的框中，你可以输入任意数字并按回车，蜂鸣器会播放该音符半秒钟（500毫秒）。人类的听觉范围大约是20 Hz到20,000 Hz，所以可以尝试不同的频率，但要保持在这个范围内。
- en: '**FIGURE 10-10:** Open the Serial Monitor, and change this option to **No line
    ending**.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-10：** 打开串口监视器，将该选项更改为**无行结束符**。'
- en: '![Image](../images/fig10_10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig10_10.jpg)'
- en: The serial communication on the Arduino has a buffer 64 bytes long. A *buffer*
    is like a waiting line for the data as it goes into the device, and in this case
    it allows you to send several notes at a time using the Serial Monitor. For example,
    you can play the song “Twinkle, Twinkle, Little Star” by typing in the following
    numbers, separated by commas without spaces. The last comma is important, too.
    The `Serial.parseInt()` command looks for numeric characters that are separated
    by non-numeric characters like commas. The Arduino needs to see that last token
    (the final comma) to parse out the final note.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino上的串口通信有一个64字节长的缓冲区。*缓冲区*就像是数据进入设备时的等待队列，在这种情况下，它允许你通过串口监视器一次发送多个音符。例如，你可以通过输入以下数字来播放《小星星》这首歌，数字之间用逗号分隔且不包含空格。最后一个逗号也很重要。`Serial.parseInt()`命令会寻找由非数字字符（如逗号）分隔的数字字符。Arduino需要看到最后一个符号（最终的逗号），以解析出最后一个音符。
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure to omit the spaces here. Each character is equal to 1 byte of data,
    and if you try to send more than the maximum 64 bytes at a time, the last few
    pieces of data will get cut off.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要在这里输入空格。每个字符等于1字节数据，如果你试图一次发送超过最大64字节的数据，最后几项数据将会被截断。
- en: 'Lastly, the buzzer is optimized at 2,047 Hz. You may notice that when you try
    this frequency the buzzer is very, *very* loud and can be annoying, so be warned:
    people around you may not appreciate the high-pitched tones that come out of this
    buzzer at 2,047 Hz!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，蜂鸣器的频率被优化为2,047 Hz。你可能会注意到，当你尝试这个频率时，蜂鸣器非常、*非常*响，可能会让人觉得烦人，所以请注意：你周围的人可能不太喜欢2,047
    Hz频率下蜂鸣器发出的高频声音！
- en: '**Create Specific Notes**'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建特定音符**'
- en: If you want to try something more traditional, you can correlate actual musical
    notes to frequencies. Many instruments use a reference point of middle C, which
    has a frequency of about 262 Hz. [Table 10-1](ch10.xhtml#ch10tab01) shows a short
    table of frequencies for an octave of the C major scale.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一些更传统的方式，可以将实际的音乐音符与频率关联起来。许多乐器以中央 C 为参考点，中央 C 的频率大约为 262 Hz。[表 10-1](ch10.xhtml#ch10tab01)
    显示了 C 大调音阶一个八度的频率简表。
- en: '**TABLE 10-1:** Notes and frequencies of the C major scale'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** C 大调音阶的音符和频率'
- en: '| **NOTE** | **APPROXIMATE FREQUENCY** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **注意** | **大约频率** |'
- en: '| C | 262 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| C | 262 |'
- en: '| D | 294 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| D | 294 |'
- en: '| E | 330 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| E | 330 |'
- en: '| F | 349 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| F | 349 |'
- en: '| G | 392 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| G | 392 |'
- en: '| A | 440 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| A | 440 |'
- en: '| B | 494 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| B | 494 |'
- en: '| C | 524 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| C | 524 |'
- en: Experiment and see if you can play a song. To start you off, “Twinkle, Twinkle,
    Little Star” begins with the notes CC, GG, AA, GG, FF, EE, DD, CC. You may notice
    that the sounds the Arduino makes aren’t the most melodic. This is because the
    Arduino can only turn the pin either `HIGH` (on) or `LOW` (off). This creates
    a square wave, which has a tinny pitch. There are some tricks you can do using
    capacitors to create a noise filter to soften this sound, but that’s a topic for
    another book!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实验看看能不能演奏一首歌。为了帮助你入门，“小星星”从音符 CC、GG、AA、GG、FF、EE、DD、CC 开始。你可能会注意到，Arduino 发出的声音不是最有旋律的。这是因为
    Arduino 只能将引脚设置为 `HIGH`（开）或 `LOW`（关）。这会生成一个方波，产生刺耳的音调。你可以使用电容器做一些技巧来创建噪音过滤器，从而柔化这个声音，但那是另一本书的内容！
- en: '**Generate Sound with the SoftPot**'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用 SoftPot 生成声音**'
- en: Making music with frequencies is fun, but typing them over and over gets really
    tedious. Instead, you can use the SoftPot as a sensor whose values will correspond
    to frequencies for the buzzer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用频率制作音乐很有趣，但一次又一次地输入它们非常繁琐。相反，你可以使用 SoftPot 作为一个传感器，它的值会对应蜂鸣器的频率。
- en: The SoftPot is wired up with a simple voltage divider so that a pressure on
    the length of the strip will be translated into a voltage from 0 to 5 V. Remember
    that the Arduino can translate an analog voltage from 0 to 5 V to a value of `0`
    to `1023` using the `analogRead()` function. Using the simple sketch in [Listing
    10-2](ch10.xhtml#ch10ex02), you can send frequencies to the buzzer by pressing
    the SoftPot. When the SoftPot is not pressed, the value defaults to `0` because
    of the pull-down resistor, so no sound is produced.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot 通过一个简单的电压分压器连接，这样对软条的压力就会转化为从 0 到 5 V 的电压。记住，Arduino 可以通过 `analogRead()`
    函数将 0 到 5 V 的模拟电压转换为 `0` 到 `1023` 的数值。使用 [清单 10-2](ch10.xhtml#ch10ex02) 中的简单草图，你可以通过按压
    SoftPot 向蜂鸣器发送频率。当 SoftPot 没有被按压时，由于下拉电阻的作用，值默认为 `0`，因此不会发出声音。
- en: Start a new Arduino sketch, copy the code example from Listing 10-2, and upload
    it to your device.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的 Arduino 草图，复制清单 10-2 中的代码示例，并将其上传到您的设备。
- en: '**LISTING 10-2:** Noisemaker example code'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 10-2：** 发声器示例代码'
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s take a look at what’s going on in this sketch. You again start by declaring
    a variable to store the raw sensor reading ➊. In the loop, the `analogRead()`
    function reads the voltage on pin A0 ➋ and assigns this value to the variable
    `sensorValue`. This value will be 0 V when no pressure is applied. You use an
    `if()` statement ➌ to check if the input value is greater than `0`, and if it
    is, the sketch prints the raw sensor value ➍ and uses the `tone()` command ➎ to
    play the value stored in `sensorValue`. If the sketch is getting stuck playing
    a note, try changing the `0` in the `if()` statement to a larger number like `10`
    or `20` ➌. This is a technique called *setting a deadband range*. Some sensors
    don’t always go back to a zero value, so this deadband sets a range of values
    that the program can still consider to be zero. Each sensor may be slightly different.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个草图是怎么工作的。你首先声明一个变量来存储原始的传感器读取值 ➊。在循环中，`analogRead()` 函数读取 A0 引脚上的电压
    ➋，并将该值赋给变量 `sensorValue`。当没有施加压力时，该值将为 0 V。你使用 `if()` 语句 ➌ 来检查输入值是否大于 `0`，如果是，草图就会打印出原始的传感器值
    ➍，并使用 `tone()` 命令 ➎ 播放 `sensorValue` 中存储的值。如果草图在播放音符时卡住了，尝试将 `if()` 语句中的 `0` 改为更大的数字，比如
    `10` 或 `20` ➌。这个技术叫做 *设置死区范围*。有些传感器并不总是返回零值，因此这个死区范围设定了一个值范围，程序仍然可以将其视为零。每个传感器可能略有不同。
- en: Notice that in this example we changed the duration the `tone()` is played ➏
    and the `delay()` ➐ to `50` ms. This will allow you to create faster changes in
    notes. Otherwise, you would only be able to play notes that were half a second
    long! Finally, you want to make sure that the Arduino only plays a tone when the
    SoftPot is pressed. To do this, you use the `else()` statement to detect when
    the SoftPot is not being pressed ➑ and the `noTone()` command to turn the buzzer
    off.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，我们改变了`tone()`播放的持续时间➏和`delay()`的时间➐，将其设置为`50`毫秒。这将允许你更快速地更改音符。否则，你只能播放半秒长的音符！最后，你需要确保Arduino只在按下SoftPot时才播放音调。为此，你可以使用`else()`语句来检测SoftPot是否未被按下➑，并使用`noTone()`命令来关闭蜂鸣器。
- en: Now, instead of using a frequency sent from the Serial Monitor, the Arduino
    uses the raw sensor value from the SoftPot. To play around, simply squeeze the
    SoftPot between your thumb and index finger, applying pressure at different points
    along the sensor. As you slide your fingers up and down the SoftPot, you can generate
    tones from 1 Hz to 1,023 Hz. What do you hear? Does it sound like aliens are landing?
    Pretty cool—now you have your very own special effects generator! Can you play
    anything that resembles a song? If not, take a look at the next example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用从串口监视器发送的频率，而是Arduino使用SoftPot的原始传感器值。要进行尝试，只需用拇指和食指夹住SoftPot，在传感器的不同点施加压力。当你上下滑动手指时，可以产生从1赫兹到1,023赫兹的音调。你听到了什么？听起来像外星人降临吗？相当酷吧——现在你有了自己的特效生成器！你能演奏出类似歌曲的东西吗？如果不能，看看下一个示例。
- en: '**Play a Song**'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**演奏一首歌**'
- en: Now that you have a feel for how the Arduino can make sounds, it’s time to map
    the sensor readings of the SoftPot to real notes so you can make actual music.
    You’ll break the sensor up into eight distinct sections (or keys) and map these
    to an index that you can use to play notes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Arduino如何发出声音，接下来是将SoftPot的传感器读取值映射到真实音符的过程，这样你就可以演奏真正的音乐了。你将把传感器分成八个不同的部分（或键），并将这些部分映射到一个索引，用来播放音符。
- en: Copy the sketch in [Listing 10-3](ch10.xhtml#ch10ex03) into the Arduino IDE,
    and upload it to your device.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单10-3](ch10.xhtml#ch10ex03)中的草图复制到Arduino IDE中，并将其上传到你的设备。
- en: '**LISTING 10-3:** Tiny Electric Piano sketch'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单10-3：** 微型电子钢琴草图'
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s look at the code. First, you declare a data structure referred to as an
    array. An *array* is a kind of variable that represents a list of values rather
    than just a single value. Arrays can be of any standard data type, including bytes,
    ints, longs, and floats, and you declare the data type before the array name.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码。首先，你声明了一个数据结构，称为数组。*数组*是一种表示多个值的变量，而不仅仅是一个单一的值。数组可以是任何标准数据类型，包括字节、整数、长整型和浮点型，并且你需要在数组名称之前声明数据类型。
- en: 'Declaring an array is similar to declaring a variable except that the array
    name is followed by two square brackets, `[ ]`. When you initialize an array,
    you define the list inside two curly brackets, `{ }`, and use commas to separate
    each value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个数组类似于声明一个变量，只不过数组名称后面跟着两个方括号`[ ]`。当你初始化数组时，你需要在两个大括号`{ }`内定义列表，并使用逗号分隔每个值：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Listing 10-3](ch10.xhtml#ch10ex03) declares an integer (`int`) array named
    `frequencies[]` that stores a list of eight values for the frequencies of the
    musical notes ➊. You can access the values in the array using the index number
    of the value, placed between square brackets. The first value is referenced as
    `frequencies[0]`, the second is referenced as `frequencies[1]`, and so on. Notice,
    as usual, that the index starts at 0 rather than 1, as shown in [Figure 10-11](ch10.xhtml#ch10fig11).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单10-3](ch10.xhtml#ch10ex03)声明了一个名为`frequencies[]`的整数（`int`）数组，用于存储八个音符频率的值➊。你可以通过方括号中的索引号来访问数组中的值。第一个值被称为`frequencies[0]`，第二个值是`frequencies[1]`，以此类推。请注意，和往常一样，索引从0开始，而不是从1开始，正如[图10-11](ch10.xhtml#ch10fig11)所示。'
- en: '**FIGURE 10-11:** The `frequencies[]` array elements'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-11：** `frequencies[]`数组元素'
- en: '![Image](../images/fig10_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_11.jpg)'
- en: The sketch then declares an index variable named `note` ➋. The array has only
    eight values, so you can declare this variable as a `byte` since it uses less
    memory space than an integer. Next, the sketch uses the `map()` function ➌ to
    translate the raw `sensorValue` reading in the range 0–1,023 to a 0–8 scale.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，草图声明了一个名为`note`的索引变量➋。数组只有八个值，因此你可以将该变量声明为`byte`，因为它比整数占用更少的内存空间。接下来，草图使用`map()`函数➌将原始的`sensorValue`读取值从0–1,023范围映射到0–8的范围。
- en: 'The `map()` function is a great tool for converting from one range of values
    to another. You pass it the input value, the range of the input, and the desired
    range, and it will scale your input value to the desired range, like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是将一个值范围转换到另一个值范围的一个好工具。你传入输入值、输入的范围和目标范围，它会将你的输入值缩放到目标范围，如下所示：'
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The sketch assigns this scaled value to the variable `note`. This will be the
    index to reference the array. But while the `map()` function scales the 0–1,023
    range to a range of 0–8, the `frequencies[]` array actually has only eight values
    and is indexed from 0 to 7.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将这个缩放后的值赋给变量`note`。这个值将作为索引来引用数组。但是，虽然`map()`函数将0–1,023的范围映射到0–8的范围，但`frequencies[]`数组实际上只有八个值，且索引从0到7。
- en: We do this because `map()` rounds down when it scales from one range to another
    range, so to get eight equally spaced values, we actually need to give it nine
    values. Value 8 is produced only when the input is equal to 1,023\. Because value
    8 (the ninth value) is not a valid index for the array, we correct this using
    another command, `constrain()` ➍. This function constrains the value to a range
    of 0 to 7\. Any value that is below 0 is constrained to a minimum value of 0,
    and any value greater than 7 is constrained to a maximum value of 7\. The `constrain()`
    function is often used in conjunction with `map()` to scale and limit a value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为`map()`在从一个范围映射到另一个范围时会向下舍入，因此，为了获得八个均匀间隔的值，我们实际上需要提供九个值。只有当输入等于1,023时，才会产生值8。由于值8（第九个值）不是数组的有效索引，我们使用另一个命令`constrain()`
    ➍来修正这个问题。此函数将值限制在0到7的范围内。任何低于0的值都被限制为最小值0，而任何大于7的值都被限制为最大值7。`constrain()`函数通常与`map()`一起使用，用于缩放和限制值。
- en: 'The `constrain()` function is used like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`constrain()`函数的使用方法如下：'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, the sketch prints the frequency of the current note being triggered
    to the Serial Monitor ➎ and uses the `tone()` function ➏ to play the note.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序将当前触发音符的频率输出到串行监视器 ➎，并使用`tone()`函数 ➏来播放这个音符。
- en: To test it out, press or squeeze the SoftPot. As you move your finger up and
    down the length of the sensor, you’ll hear the different notes. See what songs
    you can play.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时，按压或挤压SoftPot。当你上下移动手指沿着传感器的长度时，你会听到不同的音符。试试你能弹奏出什么歌曲。
- en: Now, let’s turn this prototype into a finished piano!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个原型制作成一个完成的钢琴！
- en: '**BUILD THE PIANO**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**制作钢琴**'
- en: To convert the prototype into a more functional piano, you just need to apply
    it to a flat surface and mark out the eight keys.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将原型转换成一个更实用的钢琴，你只需要将其应用到一个平面表面上，并标出八个键位。
- en: Unfortunately, the pins on this sensor are not long enough or thick enough to
    simply insert into the male-to-female jumper wires, so if you want to remove it
    from the breadboard, we suggest that you solder three male-to-male jumper wires
    from the Inventor’s Kit to the ends of the SoftPot, as shown in [Figure 10-12](ch10.xhtml#ch10fig12).
    Alternatively, you *can* use male-to-female jumpers, but you’ll need to crimp
    the ends using a set of needle-nose pliers. If you do this, insert the sensor
    pins into a set of male-to-female jumper wires and crush the plastic casing around
    the sensor pins. Make sure that the wires are in contact with the pins of the
    sensor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个传感器的引脚既不够长也不够粗，无法直接插入公对母跳线，因此，如果你想将其从面包板上取下，我们建议你从发明者套件中焊接三根公对公跳线到SoftPot的两端，如[图10-12](ch10.xhtml#ch10fig12)所示。或者，你*可以*使用公对母跳线，但需要使用一把尖嘴钳压紧两端。如果你这么做，将传感器引脚插入一组公对母跳线并压碎传感器引脚周围的塑料外壳。确保导线与传感器的引脚接触。
- en: '**FIGURE 10-12:** Soldering wires to the SoftPot'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-12：** 将导线焊接到SoftPot'
- en: '![Image](../images/fig10_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_12.jpg)'
- en: The SoftPot has adhesive backing designed to be placed flat on a hard surface,
    so with the wires attached, apply the sensor to any portable hard surface ([Figure
    10-13](ch10.xhtml#ch10fig13)), like a small piece of cardboard or even the breadboard
    holder itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot具有粘性背面，设计用于平放在硬表面上，因此，连接好导线后，将传感器粘贴到任何便携的硬表面上（如[图10-13](ch10.xhtml#ch10fig13)所示），比如一小块纸板，甚至是面包板支架本身。
- en: '**FIGURE 10-13:** Options for mounting the SoftPot'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-13：** SoftPot安装选项'
- en: '![Image](../images/fig10_13.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_13.jpg)'
- en: The SoftPot sensor is 50 mm long (approximately 2 inches). You need to divide
    the length of the sensor into eight keys, which means each key should be roughly
    a quarter inch wide. Using a piece of masking tape or a sheet of paper, mark off
    eight quarter-inch keys, as shown in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot 传感器长 50 毫米（约 2 英寸）。你需要将传感器的长度划分成八个键位，也就是说每个键大约应有四分之一英寸宽。使用遮蔽胶带或纸张，按照[图
    10-14](ch10.xhtml#ch10fig14)的示例标出八个四分之一英寸宽的键。
- en: '**FIGURE 10-14:** Marking off the keys'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-14：** 标记键位'
- en: '![Image](../images/fig10_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig10_14.jpg)'
- en: Next, position the masking tape or paper on top of the SoftPot to give you a
    guide for playing the notes. The completed keyboard should look like [Figure 10-15](ch10.xhtml#ch10fig15).
    If you like, you can label the keys with the notes matching the frequencies in
    your code to help you play from sheet music.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将遮蔽胶带或纸张放在 SoftPot 上，以便为演奏音符提供指导。完成的键盘应类似于[图 10-15](ch10.xhtml#ch10fig15)。如果你愿意，你可以在键上标注与代码中的频率匹配的音符，帮助你从乐谱中演奏。
- en: '**FIGURE 10-15:** The finished Tiny Electric Piano keyboard'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-15：** 完成的微型电动钢琴键盘'
- en: '![Image](../images/fig10_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig10_15.jpg)'
- en: '**GOING FURTHER**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**深入探索**'
- en: In this project, we introduced you to the piezo buzzer and SoftPot. Now that
    you know how to make some fun sounds, here are a few ideas for taking this project
    further.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们介绍了压电蜂鸣器和 SoftPot。现在你已经知道如何发出一些有趣的声音，下面是一些扩展此项目的想法。
- en: '**Hack**'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**破解**'
- en: Play around with the code and see what other fun tones you can create. If you
    want to play a song in a different key or using a different scale, for example,
    you could change the frequencies in the array. [Table 10-2](ch10.xhtml#ch10tab02)
    shows frequencies you can use to change the key of your piano. C major and G major
    are the two most common scales used in music. Find some sheet music online or
    just mess around. Can you play “Twinkle, Twinkle, Little Star” on your new SoftPot
    piano?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改代码，看看能创造出哪些有趣的音调。例如，如果你想用不同的调或音阶演奏一首歌，你可以改变数组中的频率。[表 10-2](ch10.xhtml#ch10tab02)显示了可以用来改变钢琴调性的频率。C
    大调和 G 大调是音乐中最常用的两种音阶。你可以在线查找一些乐谱，或者随便试试。你能用你的新 SoftPot 钢琴演奏《小星星》吗？
- en: '**TABLE 10-2:** Selected approximate frequencies for notes across three octaves'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** 选定的三重八度音符大致频率'
- en: '| **NOTE** | **APPROX. FREQ.** | **NOTE** | **APPROX. FREQ.** | **NOTE** |
    **APPROX. FREQ.** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **音符** | **大致频率** | **音符** | **大致频率** | **音符** | **大致频率** |'
- en: '| C[3] | 131 | C[4] | 262 | C[5] | 524 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| C[3] | 131 | C[4] | 262 | C[5] | 524 |'
- en: '| C^♯[3]/D^♭[3] | 139 | C^♯[4]/D^♭[4] | 277 | C^♯[5]/D^♭[5] | 554 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| C^♯[3]/D^♭[3] | 139 | C^♯[4]/D^♭[4] | 277 | C^♯[5]/D^♭[5] | 554 |'
- en: '| D[3] | 147 | D[4] | 294 | D[5] | 587 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| D[3] | 147 | D[4] | 294 | D[5] | 587 |'
- en: '| D^♯[3]/E^♭[3] | 156 | D^♯[4]/E^♭[4] | 311 | D^♯[5]/E^♭[5] | 622 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| D^♯[3]/E^♭[3] | 156 | D^♯[4]/E^♭[4] | 311 | D^♯[5]/E^♭[5] | 622 |'
- en: '| E[3] | 165 | E[4] | 330 | E[5] | 659 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| E[3] | 165 | E[4] | 330 | E[5] | 659 |'
- en: '| F[3] | 175 | F[4] | 349 | F[5] | 698 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| F[3] | 175 | F[4] | 349 | F[5] | 698 |'
- en: '| F^♯[3]/G^♭[3] | 185 | F^♯[4]/G^♭[4] | 370 | F^♯[5]/G^♭[5] | 740 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| F^♯[3]/G^♭[3] | 185 | F^♯[4]/G^♭[4] | 370 | F^♯[5]/G^♭[5] | 740 |'
- en: '| G[3] | 196 | G[4] | 392 | G[5] | 784 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| G[3] | 196 | G[4] | 392 | G[5] | 784 |'
- en: '| G^♯[3]/A^♭[3] | 208 | G^♯[4]/A^♭[4] | 415 | G^♯[5]/A^♭[5] | 831 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| G^♯[3]/A^♭[3] | 208 | G^♯[4]/A^♭[4] | 415 | G^♯[5]/A^♭[5] | 831 |'
- en: '| A[3] | 220 | A[4] | 440 | A[5] | 880 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| A[3] | 220 | A[4] | 440 | A[5] | 880 |'
- en: '| A^♯[3]/B^♭[3] | 233 | A^♯[4]/B^♭[4] | 466 | A^♯[5]/B^♭[5] | 932 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| A^♯[3]/B^♭[3] | 233 | A^♯[4]/B^♭[4] | 466 | A^♯[5]/B^♭[5] | 932 |'
- en: '| B[3] | 247 | B[4] | 494 | B[5] | 988 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| B[3] | 247 | B[4] | 494 | B[5] | 988 |'
- en: '**Modify**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**修改**'
- en: To make things more interesting, add a *distortion pedal* to this piano project.
    This button will switch up octaves to give you 16 notes for the price of 8\. Connect
    a button to pin 2 on your Arduino as shown in [Figure 10-16](ch10.xhtml#ch10fig16).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更加有趣，将一个*失真踏板*添加到这个钢琴项目中。这个按钮将切换音阶，给你8个音符的价格换来16个音符。按照[图 10-16](ch10.xhtml#ch10fig16)所示，将按钮连接到
    Arduino 的第 2 引脚。
- en: The sketch needs just few extra lines of code for the pedal, which will cycle
    a multiplier variable each time the button is pressed. This is known as a *state
    machine*, because each time the button is pressed, the state of a variable is
    changed. The code for this modification is in the book’s resources at *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*
    in the file *P10_TinyPiano_v2.ino*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图只需要为踏板添加几行额外的代码，每次按下按钮时，乘数变量将循环变化。这被称为*状态机*，因为每次按下按钮时，变量的状态都会改变。这个修改的代码在本书的资源中，位于*[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*，文件名为*P10_TinyPiano_v2.ino*。
- en: '**FIGURE 10-16:** Adding a button to pin 2 for octave control'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-16：** 为八度控制添加按钮到引脚 2'
- en: '![Image](../images/fig10_16.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_16.jpg)'
- en: The new code lines declare a state variable, `octaveMultiplier`, and then add
    a `pinMode()` command to set up pin 2 as an `INPUT`. When the button is pressed,
    the state variable, `octaveMultiplier`, is incremented, altering the frequency
    so that the note goes up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行声明了一个状态变量 `octaveMultiplier`，然后添加了一个 `pinMode()` 命令来设置引脚 2 为 `INPUT`。当按钮被按下时，状态变量
    `octaveMultiplier` 会递增，从而改变频率，使得音符升高。
- en: Try it out. When you press the button, the notes should all go up by an octave.
    You now can play up to 16 notes with this simple Arduino instrument!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。当您按下按钮时，音符应该都会升高一个八度。现在，您可以使用这个简单的 Arduino 乐器演奏最多 16 个音符！
- en: '**Bonus Project: Binary Trumpet**'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**附加项目：二进制小号**'
- en: The SoftPot is a nice touch, but as a bonus we’ve built an Arduino instrument
    that uses actual buttons as keys instead of the SoftPot. This last project is
    called the Binary Trumpet. It uses three buttons to specify which note to play
    and the fourth button to play the note, like blowing on a trumpet. With three
    buttons, you can specify up to eight different combinations using the keypresses
    shown in [Table 10-3](ch10.xhtml#ch10tab03).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SoftPot 是一个不错的设计，但作为额外奖励，我们构建了一个 Arduino 乐器，使用实际的按钮作为键，而不是 SoftPot。这个最后的项目叫做二进制小号。它使用三个按钮来指定播放的音符，第四个按钮用于播放音符，就像吹小号一样。通过三个按钮，您可以使用[表
    10-3](ch10.xhtml#ch10tab03)中显示的按键组合来指定最多八种不同的组合。
- en: '**TABLE 10-3:** Binary trumpet button sequences'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-3：** 二进制小号按钮序列'
- en: '| **BUTTON 1** | **BUTTON 2** | **BUTTON 3** | **NOTE TO PLAY** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **按钮 1** | **按钮 2** | **按钮 3** | **播放的音符** |'
- en: '| Up | Up | Up | C (262 Hz) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 上 | 上 | 上 | C (262 Hz) |'
- en: '| Up | Up | Down | D (294 Hz) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 上 | 上 | 下 | D (294 Hz) |'
- en: '| Up | Down | Up | E (330 Hz) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 上 | 下 | 上 | E (330 Hz) |'
- en: '| Up | Down | Down | F (349 Hz) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 上 | 下 | 下 | F (349 Hz) |'
- en: '| Down | Up | Up | G (392 Hz) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 下 | 上 | 上 | G (392 Hz) |'
- en: '| Down | Up | Down | A (440 Hz) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 下 | 上 | 下 | A (440 Hz) |'
- en: '| Down | Down | Up | B (494 Hz) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 下 | 下 | 上 | B (494 Hz) |'
- en: '| Down | Down | Down | C (524 Hz) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 下 | 下 | 下 | C (524 Hz) |'
- en: You may recognize this pattern as a binary sequence. It counts in the order
    000, 001, 010, 011, 100, 101, 110, and 111.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认出这个模式是一个二进制序列。它按照 000、001、010、011、100、101、110 和 111 的顺序计数。
- en: To make room for the four buttons on the breadboard, move the buzzer up a little
    and then add those buttons, as shown in [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在面包板上腾出位置放置四个按钮，将蜂鸣器稍微上移一点，然后按照[图 10-17](ch10.xhtml#ch10fig17)所示添加这些按钮。
- en: '**FIGURE 10-17:** Binary Trumpet wiring diagram'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-17：** 二进制小号接线图'
- en: '![Image](../images/fig10_17.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig10_17.jpg)'
- en: The complete code for this modification is in the book’s resources at *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*
    in the file *P10_TinyBinaryTrumpet.ino*. Playing notes using the Binary Trumpet
    will take a bit of getting used to, but the sequence of presses in [Table 10-3](ch10.xhtml#ch10tab03)
    should help you as you pick it up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此修改的完整代码可以在书籍资源中的 *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*
    网站上找到，文件名为 *P10_TinyBinaryTrumpet.ino*。使用二进制小号演奏音符需要一些时间来适应，但[表 10-3](ch10.xhtml#ch10tab03)中的按键序列应该能帮助您快速掌握。
- en: As it turns out, with four buttons, you can actually play up to 16 different
    notes. Can you figure out how to modify the example to do this? Take a look at
    the book’s resources to see how.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，使用四个按钮，您实际上可以演奏最多 16 个不同的音符。您能找出如何修改示例以实现这一点吗？查看书籍资源以了解如何操作。
- en: Whether you use the Tiny Electric Piano or the Binary Trumpet, we hope this
    helps you on your way to a future career in making music. Now go forth and find
    an audience to show off your newest skills!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用小型电子钢琴还是二进制小号，我们都希望这对您未来从事音乐创作的职业有所帮助。现在，去找到一个观众，展示您的最新技能吧！
