<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>2 SETTING UP YOUR HARDWARE AND TOOLS</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch2">
<span class="CN"><span aria-label=" Page 13. " epub:type="pagebreak" id="pg_13" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SETTING UP YOUR HARDWARE AND TOOLS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">This chapter walks you through the process of choosing an FPGA development board and setting up the associated software tools that you’ll need to translate your Verilog or VHDL code into physical circuits on your FPGA. You’ll learn about the features to look for in a board, download and install the tools you need to work with it, and test them out by designing your first FPGA project to target your development board. This project will also give you an overview of the main steps in the FPGA development process.</p>
<p class="TX">An FPGA development board isn’t strictly required to use this book. You can still learn from the projects without a board, and you can always test your Verilog or VHDL code by running it through a free online FPGA simulator tool like EDA Playground (a topic we’ll cover in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>). <span aria-label=" Page 14. " epub:type="pagebreak" id="pg_14" role="doc-pagebreak"/>However, there’s something satisfying about writing some code, programming it to a development board, and seeing the results in action—even when it does something as simple as blinking an LED. For this reason, I highly recommend that you have an FPGA development board on hand when learning about FPGAs.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-14"/><samp class="SANS_Futura_Std_Bold_B_11">Choosing an FPGA Development Board</samp></h2>
<p class="TNI1">An FPGA development board (or <i>dev board</i>) is a printed circuit board (PCB) with an FPGA on it that allows you to program the FPGA with your Verilog or VHDL code and test it out. The board may also have peripherals on it that are connected to the FPGA, such as LEDs, switches, and connectors for linking the FPGA to other devices. FPGA development boards range from devices the size of a pack of gum that cost less than $100 to laptop-size devices that cost thousands of dollars. With such a wide range of options, there are many factors you should consider when choosing a development board, including price, ease of use, and enjoyability:</p>
<p class="ListHead"><b>Cost</b></p>
<p class="ListPlainFirst">For an FPGA beginner, I recommend starting off with an inexpensive development board. Larger, more expensive boards often have many extra features, like SerDes and DDR memory, that are unnecessary and potentially overwhelming for new users. You can always invest in one of these more sophisticated boards as your skills mature and you grow out of your first board.</p>
<p class="ListHead"><b>Simplicity</b></p>
<p class="ListPlainFirst">The board you start out with and the software required to work with it should be simple to use. It’s challenging enough to learn how an FPGA works; if you also have to learn how to use a complicated design tool, the process becomes even more difficult. I recommend focusing on boards built around Lattice Semiconductor’s iCE40 family of FPGAs, since these FPGAs are compatible with a lightweight and simple set of software tools: iCEcube2 and Diamond Programmer. These programs are streamlined to do the minimum required to build your FPGA, without all the bells and whistles of more advanced programs. You’ll learn how to use both of them in this chapter.</p>
<p class="ListHead"><b>Fun</b></p>
<p class="ListPlainFirst">An FPGA development board should be fun to use, with peripherals like LEDs, push buttons, and seven-segment displays that you can take advantage of in different projects. Some cheaper boards cut costs by removing peripherals; they just have an FPGA and nothing else. FPGA development is much more fun and interesting when you can interface the FPGA with other devices.</p>
<p class="TX">Keep these factors in mind as you consider the development boards available on the market.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-15"/><span aria-label=" Page 15. " epub:type="pagebreak" id="pg_15" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Requirements for the Book</samp></h2>
<p class="TNI1">You’ll get the most value out of this book if you follow along with the projects and program your own development board. To go through the projects exactly as written, you’ll need your development board to have the following features (<span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span> lists a few boards that meet these requirements, or can meet them with a few modifications):</p>
<p class="ListHead"><b>Lattice iCE40 FPGA</b></p>
<p class="ListPlainFirst">iCE40 FPGAs have emerged as the best option for FPGA beginners. They’ve been available for many years at affordable prices, while providing enough resources to support interesting projects. The iCE40 architecture is relatively simple, with few distracting bells and whistles, so you can focus on what’s important. As I mentioned earlier, iCE40 FPGAs are compatible with the free, easy-to-use iCEcube2 and Diamond Programmer software tools, which we’ll explore in this chapter. The iCE40 family is also compatible with open source FPGA tools, if you want to avoid proprietary software altogether.</p>
<p class="ListHead"><b>USB</b></p>
<p class="ListPlainFirst">Your development board should have a USB interface to power and program the board. This way, all you need is one USB cable and you’re ready to go. Older FPGA development boards often require an external programmer (a separate piece of hardware that can itself cost hundreds of dollars), so make sure simple built-in USB programming is possible with the board you choose.</p>
<p class="ListHead"><b>LEDs</b></p>
<p class="ListPlainFirst">The book’s projects assume that your board has four LEDs. These are a convenient way to get output from the FPGA. For example, our first project later this chapter will involve lighting up the LEDs, which allows you to get immediate feedback that you’ve successfully programmed the FPGA. There’s nothing more satisfying than getting that first LED to light up!</p>
<p class="ListHead"><b>Switches</b></p>
<p class="ListPlainFirst">For each of the four LEDs, you’ll need a corresponding push-button switch. These switches provide input to the FPGA, allowing you to easily change the state of the board.</p>
<p class="ListHead"><b>Seven-Segment Display</b></p>
<p class="ListPlain">Your board will need one seven-segment display to implement the memory game project in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. This kind of display provides a fun way to output data. Lighting up individual LEDs is one thing, but lighting up numbers and letters on a seven-segment display is much more engaging.</p>
<p class="BodyContinued">If your development board doesn’t meet all these requirements, don’t worry: you can still work through this book’s projects with a few <span aria-label=" Page 16. " epub:type="pagebreak" id="pg_16" role="doc-pagebreak"/>adjustments. For example, if you’d prefer to work with a board built around a different kind of FPGA, you can. As we’ll discuss in later chapters, there are advanced features that vary from one FPGA to another, but the code for this book’s projects is general enough that it should work on any modern FPGA. That’s part of the beauty of Verilog and VHDL: they’re FPGA-agnostic.</p>
<p class="TX">Do be aware that if you aren’t working with an iCE40 FPGA, however, you’ll need to use a different set of software tools than the ones discussed in this chapter. Each FPGA company provides its own tools specifically aimed at its FPGAs. For example, AMD (Xilinx) has Vivado, and Intel (Altera) has Quartus. If your board has an FPGA from one of these companies, look online for resources about using the appropriate software.</p>
<p class="TX">If you don’t have all the necessary peripherals for the projects in this book, you have a few options. First, you can modify the projects’ Verilog or VHDL code to use fewer LEDs and switches. This will work in most cases, although the memory game project in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> will be less satisfying the fewer LEDs and switches you use.</p>
<p class="TX">Alternatively, many FPGA development boards, including some of the boards discussed in <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span>, have connection points for wiring up your own peripherals. In particular, look for a development board with a Pmod (peripheral module) connector. Pmod is a standard connector made famous by Digilent for attaching accessory boards with extra peripherals— not just the ones used in this book, but also devices like temperature sensors, accelerometers, audio jacks, microSD cards, and more. If you’ve ever worked with Arduino Shields, it’s the same concept. If your board has a Pmod connector, that will greatly expand the range of projects you can work on with your FPGA.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h-16"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up Your Development Environment</samp></h2>
<p class="TNI1">To use the iCE40 FPGA on your development board, you’ll need to install two software tools on your computer: iCEcube2 and Diamond Programmer. These free tools from Lattice Semiconductor are designed specifically for working with iCE40 FPGAs. This section walks you through the process of setting them up. If you’re on Windows, you’ll have the easiest time, since the tools are designed for the Windows operating system. For Linux or macOS users, I recommend creating a Windows virtual machine on your computer, then running the Lattice tools in that. There are many tutorials online for setting up a Windows virtual machine using VirtualBox or a similar product.</p>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">iCEcube2</samp></h3>
<p class="TNI1">iCEcube2 is Lattice’s free integrated development environment (IDE) for turning the VHDL or Verilog code you write on your computer into a file that the FPGA can be programmed with. It’s much easier to use than other IDEs like Vivado, Quartus, or even Lattice Diamond (not to be confused <span aria-label=" Page 17. " epub:type="pagebreak" id="pg_17" role="doc-pagebreak"/>with Diamond Programmer), Lattice’s tool for working with more sophisticated FPGAs. Their compatibility with iCEcube2 is part of what makes iCE40 FPGAs an especially good choice for beginners. Those other programs are all several gigabytes in size and extremely complicated. They have many bells and whistles, most of which you won’t need when you’re getting started. By contrast, iCEcube2 is more streamlined, making it a more straightforward tool for learning about FPGAs.</p>
<p class="TX">To download and install iCEcube2, follow these steps:</p>
<p class="NLF2">1.  Visit <a href="https://latticesemi.com/icecube2"><i>https://<wbr/>latticesemi<wbr/>.com<wbr/>/icecube2</i></a> or search the internet for “iCEcube2 download.”</p>
<p class="NLM2">2.  Find the download link for the latest Windows version of iCEcube2, whether you’re running Windows natively or in a virtual machine. If you’re a Linux user, you may be tempted to download the Linux version instead, but I wouldn’t recommend it. That version is buggy; you might have success, or you might not.</p>
<p class="NLM2">3.  When you click the download link, you’ll be asked to create an account on the Lattice website. You must create an account to get a license for this tool. Make sure to use a real email address, as they’ll email you the free license. Once you create an account, you should be able to download the software.</p>
<p class="NLM2">4.  As the software is downloading, find the <b>iCECube2 Software Free License</b> link on the download page and click it to request a license.</p>
<p class="NLL2">5.  You’ll need your computer’s MAC address to obtain the license. To find it on Windows, open a command prompt by clicking the Start button and searching for “cmd.” Then enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ipconfig /all</samp> at the command line. You should see something like this:</p>
<pre><code>C:\&gt; <b>ipconfig /all</b>
<var>--snip--</var>
Ethernet adapter Local Area Connection:
   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel(R) Ethernet Connection I217-V
   Physical Address. . . . . . . . . : 38-D3-21-F5-A3-09
   DHCP Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes</code></pre>
<p class="NLF2">6.  Your MAC address is the 12-digit hexadecimal number next to <samp class="SANS_TheSansMonoCd_W5Regular_11">Physical Address</samp>. Copy this into the Lattice license request form and submit the form to have a license file sent to your email address.</p>
<p class="NLL2">7.  Launch the iCEcube2 installer once it finishes downloading and point it to your license file.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If you already installed iCEcube2 before obtaining the license, you can use the program</i> <span class="Roman">LicenseSetup.exe</span> <i>in the same folder where you installed the tool to point it at your license file.</i></p>
<p class="TX"><span aria-label=" Page 18. " epub:type="pagebreak" id="pg_18" role="doc-pagebreak"/>When it’s done installing, launch iCEcube2. The main window will look something like <a href="#fig2-1">Figure 2-1</a>.</p>
<figure class="IMG"><img alt="" class="img80" id="fig2-1" src="../images/Figure2-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The iCEcube2 main window</samp></p></figcaption>
</figure>
<p class="TX">Click around to get a feel for the program. We’ll explore it in more detail later in this chapter with a project that will take you through the entire FPGA build process.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Diamond Programmer</samp></h3>
<p class="TNI1">Diamond Programmer is a free standalone programming tool from Lattice that takes the output of iCEcube2 and uses it to program your FPGA via your development board’s USB connection. More sophisticated software tools like Vivado and Quartus have a built-in programmer, so you don’t need to download a separate program. It’s unfortunate that iCEcube2 doesn’t have one built in, but such is the life of an iCE40 FPGA designer! Here’s how to install Diamond Programmer:</p>
<p class="NLF2">1.  Go to <a href="https://latticesemi.com/programmer"><i>https://<wbr/>latticesemi<wbr/>.com<wbr/>/programmer</i></a> or search the internet for “lattice diamond software” to locate the download page.</p>
<p class="NLL2">2.  The Diamond Programmer page has many download links to choose from. Find and click the link for the latest version of Programmer Standalone 64-bit for Windows.</p>
<p class="Warning"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp></span></p>
<p class="NOTE-TXT"><i>Be sure to download Programmer Standalone and not the Programmer Standalone Encryption Pack. The latter isn’t needed.</i></p>
<p class="NL2">3.  Diamond Programmer doesn’t require a license, so simply run the installer once it downloads.</p>
<p class="TX">You’re now ready to dive into your first FPGA project, where you’ll learn how to work with these tools and program your FPGA.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h-19"/><span class="NoteHead"><span aria-label=" Page 19. " epub:type="pagebreak" id="pg_19" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #1: Wiring Switches to LEDs</samp></span></h2>
<p class="TNI1">In this project, you’ll get familiar with the build process by creating a simple FPGA design: when you press one of the push-button switches on your FPGA development board, one of the LEDs should light up. The project assumes that you have four switches and four LEDs, so you’ll design and program your FPGA to wire up each switch to one of the LEDs. (As mentioned earlier, you can adapt the project to use fewer switches and LEDs if needed.) <a href="#fig2-2">Figure 2-2</a> shows a diagram of what we want to do.</p>
<figure class="IMG"><img alt="" class="img40" id="fig2-2" src="../images/Figure2-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The Project #1 block diagram</samp></p></figcaption>
</figure>
<p class="TX">On the left we have the board’s four switches, labeled SW1 through SW4. By default, these will be open (not connected), meaning the corresponding input pin of the FPGA will have a low voltage when the switch isn’t pressed, due to an onboard pull-down resistor. When you press a switch down, the FPGA will see a high voltage present at the input pin connected to that switch. On the output side we have four LEDs, labeled D1 through D4. We want to create an FPGA that will connect the switches and LEDs such that, for example, when the user presses SW1, the D1 LED illuminates. We’ll literally be creating a physical wired connection between the SW1 input and the D1 output using our FPGA. In other words, with FPGAs you’re programming at such a low level that you’re creating wires between pins, throughout your device.</p>
<p class="TX">To implement this project, we’ll go through four main steps. These steps, summarized in <a href="#fig2-3">Figure 2-3</a>, form the main phases of the FPGA build process.</p>
<figure class="IMG"><img alt="" class="img100" id="fig2-3" src="../images/Figure2-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The FPGA build process</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 20. " epub:type="pagebreak" id="pg_20" role="doc-pagebreak"/>You’ll familiarize yourself with the steps at a high level through this project. Then you’ll expand your knowledge of each step throughout the book. The four steps are:</p>
<p class="NLF2">1.  <b>Design.</b> In this step, you write the Verilog or VHDL code that describes how the FPGA will function. You might also write tests to ensure that your code will work as you intend, a concept we’ll discuss in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>
<p class="NLM2">2.  <b>Synthesis.</b> The synthesis process is what turns your code into low-level components that perform the actual functionality on your FPGA. It’s similar to how a compiler in a programming language like C turns your C code into Assembly instructions. In this book, we’ll use iCEcube2 as a synthesis tool.</p>
<p class="NLM2">3.  <b>Place and route.</b> This process will take your synthesized design and map it to the physical layout of your specific FPGA. It will wire up (route) the connections between components, including connecting the input and output pins to the inner FPGA components. Creating links between pins and signals in your code is one of the purposes of the <i>physical constraints file</i>. You’ll see how to write a constraint file in this project. iCEcube2 handles the place and route step at the same time that it handles synthesis.</p>
<p class="NLL2">4.  <b>Programming.</b> This is where you take the output of the previous steps and load it onto your physical FPGA. The programming file literally creates wired connections between pins and FPGA components, and within the FPGA itself. This project will simply create wires between pins, but in future projects we’ll use other FPGA components as well. The programming step happens within Diamond Programmer.</p>
<p class="TX">All the projects in this book will follow this same basic process. As you work on later projects, refer back to this section if you need a refresher on using iCEcube2 and Diamond Programmer.</p>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp></h3>
<p class="TNI1">Let’s design an FPGA that links the switch inputs to the LED outputs using Verilog or VHDL. Hopefully by this point you’ve chosen which language you want to learn; I suggest focusing on just one for now, but you can always pick up the other later. All of this book’s code examples are shown in both languages, so you can compare and contrast the code as well.</p>
<p class="TX">I’ve had success writing FPGA code with Visual Studio Code (VS Code), a free tool from Microsoft. You can download extensions that will enable Verilog or VHDL syntax highlighting and other useful features, like the ability to tie to GitHub repositories directly from the code editor. You could also write your code directly in iCEcube2, but I wouldn’t recommend it, as it doesn’t have syntax highlighting.</p>
<p class="TX">Whatever tool you choose, enter the following Verilog or VHDL code and save it on your computer. Take note of the filename and location, as you’ll need it later. All of the code in this book is also available in the book’s GitHub repository, <a href="https://github.com/nandland/getting-started-with-fpgas"><i>https://<wbr/>github<wbr/>.com<wbr/>/nandland<wbr/>/getting<wbr/>-started<wbr/>-with<wbr/>-fpgas</i></a>.</p>
<p class="Label"><span aria-label=" Page 21. " epub:type="pagebreak" id="pg_21" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> module Switches_To_LEDs
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>  (input  i_Switch_1,
  input  i_Switch_2,
  input  i_Switch_3,
  input  i_Switch_4,
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> output o_LED_1,
  output o_LED_2,
  output o_LED_3,
  output o_LED_4);
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> assign o_LED_1 = i_Switch_1;
  assign o_LED_2 = i_Switch_2;
  assign o_LED_3 = i_Switch_3;
  assign o_LED_4 = i_Switch_4;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> entity Switches_To_LEDs is
  port (
  <span aria-label="annotation2" class="CodeAnnotationCode1">❷</span> i_Switch_1 : in std_logic;
     i_Switch_2 : in std_logic;
     i_Switch_3 : in std_logic;
     i_Switch_4 : in std_logic;
  <span aria-label="annotation3" class="CodeAnnotationCode1">❸</span> o_LED_1    : out std_logic;
     o_LED_2    : out std_logic;
     o_LED_3    : out std_logic;
     o_LED_4    : out std_logic);
end entity Switches_To_LEDs;
architecture RTL of Switches_To_LEDs is
begin
<span aria-label="annotation4" class="CodeAnnotationCode1">❹</span> o_LED_1 &lt;= i_Switch_1;
   o_LED_2 &lt;= i_Switch_2;
   o_LED_3 &lt;= i_Switch_3;
   o_LED_4 &lt;= i_Switch_4;
end RTL;</code></pre>
<p class="TX">Let’s consider broadly how this code is structured, since all our projects will follow this same general format. The design for an FPGA is encapsulated inside one or more <i>modules</i> (in Verilog) or <i>entities</i> (in VHDL). These modules/entities define the interface to a block of code. The interface has signals, which can be inputs or outputs. At the highest level of your FPGA, these signals will connect to physical pins on your device, thereby creating the interfaces to other components, such as switches and LEDs.</p>
<p class="TX">To create a module in Verilog, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp> keyword and provide a descriptive name—in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Switches_To_LEDs</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Inside the module, the first thing you do is declare all the input <span aria-label="annotation2" class="CodeAnnotation">❷</span> and output <span aria-label="annotation3" class="CodeAnnotation">❸</span> signals, enclosed <span aria-label=" Page 22. " epub:type="pagebreak" id="pg_22" role="doc-pagebreak"/>in a set of parentheses. Then comes the code for what you want the module to actually do, which we’ll discuss in detail momentarily, followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">endmodule</samp> keyword.</p>
<p class="TX">Looking at the VHDL version, the first thing you might notice is that it’s a bit longer than the Verilog version. This is typical; VHDL generally takes more typing to accomplish the same task compared to Verilog. Some of the extra length comes at the very beginning of the listing, where we specify which VHDL library and package we’ll be using. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_1164</samp> package from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ieee</samp> library. We need this to get access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp> data type, which is commonly used to represent binary values (0, 1) within your FPGA. Get used to including this library and package. You’ll need it for every VHDL design you create.</p>
<p class="TX">Whereas in Verilog you declare the inputs and outputs and code the actual logic of the module as part of the same code block, in VHDL you do this with two separate code blocks. This is another reason why the VHDL version is longer. First, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">entity</samp> keyword to declare the VHDL entity <span aria-label="annotation1" class="CodeAnnotation">❶</span>, giving it a name and specifying its inputs <span aria-label="annotation2" class="CodeAnnotation">❷</span> and outputs <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Then, in a separate code block, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">architecture</samp> keyword to declare the <i>architecture</i> of the entity, which is the code that defines the entity’s functionality. You’ll almost always have a single entity/architecture pair in a VHDL file, with the entity describing the input/output interface and the architecture describing the functionality.</p>
<p class="TX">Now that we’ve covered the structure of the code, let’s look at the specifics. In both the Verilog and VHDL versions, we define the four input signals <span aria-label="annotation2" class="CodeAnnotation">❷</span> corresponding to the four switches: <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_3</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_4</samp>. In Verilog, these inputs will be defined as 1 bit wide (a single 0 or 1) by default, whereas in VHDL we explicitly define them as <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>, which is a 1-bit-wide data type. We similarly define the four outputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp>, for the four LEDs <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Notice that I like to precede my input signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp> and my output signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp>. This helps me to keep track of which direction each signal is going in.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>You can define your inputs and outputs in any order, but it’s customary to put inputs first.</i></p>
<p class="TX">Finally, we define the logic of the design—the code that actually does the work—by <i>assigning</i> the inputs to the outputs <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. For example, we take the value on input <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> and assign it to the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. When the FPGA is built, this will create a physical wire between these two pins. In Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp> keyword, which requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for the actual signal assignment. In VHDL, we can just use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> assignment to create the wire between the input and the output.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a New iCEcube2 Project</samp></h3>
<p class="TNI1">Once you have the coding done, it’s time to bring the design into iCEcube2 so you can build it. Open iCEcube2 and select <b>File</b><span class="MenuArrow"></span><b>New Project</b>. You’ll be <span aria-label=" Page 23. " epub:type="pagebreak" id="pg_23" role="doc-pagebreak"/>taken to a window asking for information about your FPGA board, as shown in <a href="#fig2-4">Figure 2-4</a>. Let’s review the settings in this window.</p>
<figure class="IMG"><img alt="" class="img50" id="fig2-4" src="../images/Figure2-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The iCEcube2 New Project window</samp></p></figcaption>
</figure>
<p class="TX">For the Project Name, give your project whatever name you like, and for the Project Directory, choose where on your computer you want it saved. Next, you need to tell the tool which FPGA you’re using. It needs to know how many resources the FPGA has, which pins go where, and everything about how it works to properly turn your code into something compatible with your specific device. To do this, select <b>iCE40</b> from the Device Family drop-down, then choose your FPGA’s specific device name and package from the Device and Device Package drop-downs. For example, if you were using the Nandland Go Board (one of the boards discussed in <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span>), you would choose HX1K for the device and VQ100 for the package, then select 3.3 from the topBank, leftBank, bottomBank, and rightBank drop-downs. This tells the tool that all the pins on the device operate at 3.3 volts. Everything else in the window can remain at the default settings. Click <b>Next</b> when you’re done.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>You’ll use these same settings for every single project, so you can refer back to this section each time you create a new project.</i></p>
<p class="TX">You’ll be taken to another dialog that prompts you to add the Verilog or VHDL source file that you created previously. Go ahead and add your file, or click <b>Finish</b> to skip this step for now. If you choose to skip adding <span aria-label=" Page 24. " epub:type="pagebreak" id="pg_24" role="doc-pagebreak"/>your file from the dialog, you can do so later by expanding the Synthesis Tool menu on the left side of the main iCEcube2 project window, right-clicking Design Files, and selecting Add Files, as shown in <a href="#fig2-5">Figure 2-5</a>.</p>
<figure class="IMG"><img alt="" class="img30" id="fig2-5" src="../images/Figure2-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: Adding Verilog or VHDL source files to your project</samp></p></figcaption>
</figure>
<p class="TX">This Design Files menu also makes it possible to add additional files to an existing project after it’s been created, or to remove and replace files that you’ve added previously.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-22"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Pin Constraints</samp></h3>
<p class="TNI1">The next step in the build process is to add the pin constraints to your project. These constraints, which you declare in a <i>.pcf (physical constraints file)</i> file (sometimes referred to as pin constraint file), tell the tool which signals in your Verilog or VHDL code will be connected to which physical pins on your FPGA. This information is critical to the place and route stage of the build process, when the output of the synthesis process is mapped to the physical resources on your FPGA. The tool needs to know which pins are connected to the switches and LEDs so all the wires in the design can be routed to where they need to go.</p>
<p class="TX">Each FPGA manufacturer has its own keywords for writing constraints. To declare a pin constraint for Lattice’s iCEcube2, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_io</samp> keyword, followed by the name of one of the signals in your design, followed by the corresponding pin number on the FPGA itself. Here’s an example of what the physical constraint file should look like for this project, but keep in mind that the actual pin numbers will vary depending on your development board. As an example, these pin numbers would work for the Nandland Go Board:</p>
<pre><code># LED pins:
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> set_io o_LED_1 56
set_io o_LED_2 57
set_io o_LED_3 59
set_io o_LED_4 60
# Push-button switches:
set_io i_Switch_1 53
set_io i_Switch_2 51
set_io i_Switch_3 54
set_io i_Switch_4 52</code></pre>
<p class="TX"><span aria-label=" Page 25. " epub:type="pagebreak" id="pg_25" role="doc-pagebreak"/>Each line maps one of the signals in our code to one of the pins on the FPGA. For example, we set the Verilog/VHDL signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp> to be connected to pin <samp class="SANS_TheSansMonoCd_W5Regular_11">56</samp> on the FPGA <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The signal names you use in the physical constraint file must match the signal names in your Verilog/VHDL code exactly. If the names don’t match, the tool won’t know which signal goes to which physical pin on the device.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Notice that comments in the physical constraint file are preceded with a # symbol—an octothorpe, pound sign, or hashtag, depending on your age.</i></p>
<p class="TX">When setting your pin constraints, you’ll need to look at the reference schematic for your FPGA development board. The schematic contains the wiring diagram for the circuit board. It tells you which pin of the FPGA is connected to which LED, button, connector pin, or other device. Learning how to read this basic schematic information is a critical skill for an FPGA designer, as setting pin constraints is a common task.</p>
<p class="TX">To add the physical constraint file to your project, find the P&amp;R Flow section in the menu on the left side of the iCEcube2 project window, expand <b>Add P&amp;R Files</b>, and right-click <b>Constraint Files</b>. Then click <b>Add Files</b> and select your <i>.pcf</i> file. Once you do this, you’ll see the file listed under Constraint Files.</p>
<p class="TX">Forgetting to add a physical constraint file is a common mistake when working with FPGAs. If you don’t add one, the tool won’t warn you about it. Instead, they’ll just connect the signals in your code to randomly chosen pins on your device. This will almost certainly be wrong, and your design won’t work as you expect.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-23"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Build</samp></h3>
<p class="TNI1">You’re now ready to run the build in iCEcube2. To do this, simply click <b>Tool</b><span class="MenuArrow"></span><b>Run All</b>. This will execute both the synthesis and place and route processes, creating the FPGA image file that you’ll use to program the FPGA. iCEcube2 generates a report for each of these steps, visible under the Reports section. You’re welcome to explore these reports to see what type of information they contain; we’ll dive into the details in future chapters.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting Your Development Board</samp></h3>
<p class="TNI1">You now need to connect your board to your computer to program the FPGA. Take a minute to make sure this connection works and that your computer recognizes the device. With the board unplugged, open up Device Manager in Windows and expand the Ports (COM &amp; LPT) section. Now go ahead and plug in the board via USB. You should see two devices labeled “USB Serial Port (COM<i>X</i>)” pop up, as shown in <a href="#fig2-6">Figure 2-6</a>. The specific COM port index numbers don’t matter. If this works for you, then your board is connected to your computer and you’re ready to go.</p>
<span aria-label=" Page 26. " epub:type="pagebreak" id="pg_26" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img40" id="fig2-6" src="../images/Figure2-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: Viewing the board connection in Device Manager</samp></p></figcaption>
</figure>
<p class="TX">If you don’t see the USB serial ports in Device Manager, there are a few troubleshooting techniques to try. First, check if your board has a power LED for indicating when it’s on. If it does, but that LED isn’t illuminated, you don’t have power, so check that the USB cable is firmly plugged into the board and into your computer. If the LED <i>is</i> illuminated, then the next most likely issue is the USB cable itself. Some Micro-USB cables are “charge only,” meaning they don’t have the wires that allow for data transfer. Get another cable that you know works to transfer data to and from a computer.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-25"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Programming the FPGA</samp></h3>
<p class="TNI1">The final step in the process is to program your design to your FPGA using Diamond Programmer. An FPGA development board typically features an integrated circuit that turns its USB connection into the SPI interface, which Diamond Programmer uses to program a flash memory chip installed on the board. Once that’s done, the FPGA will boot up from the flash, and you’ll see the fruits of your labor!</p>
<p class="TX">With your board connected, open up Diamond Programmer to get started. You’ll be greeted with the dialog shown in <a href="#fig2-7">Figure 2-7</a>. Click <b>OK</b> to create a new project.</p>
<figure class="IMG"><img alt="" class="img60" id="fig2-7" src="../images/Figure2-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The Diamond Programmer dialog</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 27. " epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/>Once you click OK, the tool will try to scan the board to automatically identify which FPGA is connected. It will fail. That’s fine; we can manually tell Diamond Programmer which FPGA to target from the next screen, which is shown in <a href="#fig2-8">Figure 2-8</a>.</p>
<figure class="IMG"><img alt="" class="img70" id="fig2-8" src="../images/Figure2-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The Diamond Programmer device selection screen</samp></p></figcaption>
</figure>
<p class="TX">Set the Device Family to <b>iCE40</b> and choose your specific FPGA from the Device drop-down, as shown in <a href="#fig2-8">Figure 2-8</a>. Next, double-click the field under Operation. You’ll be greeted with a new window, shown in <a href="#fig2-9">Figure 2-9</a>. Note that you may need to change the access mode to SPI Flash Programming to see the contents shown here.</p>
<figure class="IMG"><img alt="" class="img50" id="fig2-9" src="../images/Figure2-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: The Diamond Programmer Device Properties window</samp></p></figcaption>
</figure>
<p class="TX">This window lets you tell Diamond Programmer how to program your FPGA. In the Device Operation section, set the access mode to <b>SPI Flash</b> <span aria-label=" Page 28. " epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/><b>Programming</b>. For the SPI Flash Options section, you’ll have to consult the programming guide for your development board to determine which SPI flash device is used. For the Go Board, for example, you’d set the family to SPI Serial Flash, the vendor to Micron, and the device to M25P10, as shown in <a href="#fig2-9">Figure 2-9</a>.</p>
<p class="TX">Finally, in the Programming Options section, click the three dots next to the Programming File box and choose the <i>.bin</i> file to program to the FPGA. This is the file you generated using iCEcube2, located in the <i>/&lt;Project_Name&gt;_Implmnt/sbt/outputs/bitmap/</i> subdirectory inside the directory where you saved your iCEcube2 project. Leave all the other settings on their defaults, and click <b>OK</b> to close this window. Now you’re ready to program.</p>
<p class="TX">Open the <b>Design</b> menu and select <b>Program</b>. If everything was done correctly, you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">INFO — Operation: successful</samp> after a few seconds. This means that your SPI flash has been programmed and your FPGA is running! Try pushing each switch on your board. You should see the corresponding LED light up when the button is held down. Congratulations, you’ve built your first FPGA project!</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>I recommend saving your Diamond Programmer project so you can reuse the settings for the other projects in the book. All you’ll have to do is select a different</i> <span class="Roman">.bin</span> <i>file to program to the FPGA.</i></p>
<p class="TX">If the programming fails, you might get a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHECK_ID</samp> error like this:</p>
<pre><code>ERROR — Programming failed.
ERROR — Function:CHECK_ID
Data Expected: h10   Actual: hFF
ERROR — Operation: unsuccessful.</code></pre>
<p class="TX">If you see this error, go to the Cable Settings section in the right pane of Diamond Programmer and change your port from FTUSB-0 to <b>FTUSB-1</b>, as shown in <a href="#fig2-10">Figure 2-10</a>.</p>
<figure class="IMG"><img alt="" class="img30" id="fig2-10" src="../images/Figure2-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: Troubleshooting a CHECK_ID error</samp></p></figcaption>
</figure>
<p class="TX">Once you make the change, try to program your device again. This time it should work.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h2 class="H1" id="sec13"><span id="h-26"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter, you created an FPGA development environment and learned how to work with a development board. Through your first project, you <span aria-label=" Page 29. " epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>learned about the main steps in the FPGA development process: design, where you write code for the FPGA using Verilog or VHDL; synthesis, where you translate that code into FPGA components; place and route, where you map the synthesized design to the resources on your specific FPGA; and programming, where the design is physically transferred to the FPGA. We’ll explore these concepts in more detail later in the book, but as you work through other projects, remember that you can refer back to this chapter if you need a refresher on the basics of using your FPGA tools.</p>
</section>
</section>
</body>
</html>