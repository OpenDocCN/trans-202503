<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="91" id="Page_91"/>5</span><br/>
<span class="ChapterTitle">Creating User Interfaces and Widgets</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c05-0001" class="HeadProject"><span><span epub:type="pagebreak" title="92" id="Page_92"/>Sketch 42: A Button</span></h2>
<p class="BodyFirst">After text from the console or a file and basic mouse gestures, the simple button is the third most popular user input method. It is ubiquitous on web pages, game screens, and any system that requires on/off or yes/no choices from a user. It is, of course, based on the old-fashioned push button that has existed for a long time as an electrical device, and it works in a natural way: push the button and something happens.</p>
<p>Graphically, a button is really just a rectangle. It is usually filled with a color and has a text label or image to indicate its function. When the user clicks the mouse button while the cursor is within the button, the task assigned to the button is executed, usually by calling some function. Properties that a button has include its <em>position</em> (the x- and y-coordinates of the upper left corner of the button), <em>size</em> (the width and height of the button), <em>label</em> (the string that is written in the button), and a <em>color</em> or<em> image</em> that will appear in the button.</p>
<p>A button is said to be <span class="KeyTerm">armed</span> when the mouse cursor lies within it. When armed, a mouse click will execute the function of the button. Sometimes the button is drawn with a different color or font when it is armed to indicate the activation to the user.</p>
<p>The button implemented in this sketch causes the background color of the sketch window to change. It is armed when the mouse enters the rectangle <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>if ( (mouseX&gt;=bx) &amp;&amp; (mouseX&lt;bx+bw) &amp;&amp; (mouseY&gt;=by) &amp;&amp; (mouseY&lt;by+bh) )</code></pre>
<p class="BodyContinued">where (<code>bx</code>, <code>by</code>) is the position and (<code>bw</code>, <code>bh</code>) is the size of the button. </p>
<p>The <code>buttonArmed()</code> function returns true when this <code>if</code> condition is true. The <code>drawButton()</code> function draws and fills the rectangle and draws the text <span class="CodeAnnotation" aria-label="annotation1">1</span>. When the button is armed, <code>drawButton()</code> also changes the fill color to green from red. And, of course, the <code>mousePressed()</code> function determines whether the button was armed when the mouse button was pressed and changes the background color if so <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>Because this sketch only implements a single button, it doesn’t use much code. It is common for an application to have many buttons, as you’ll see in the next sketch. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Instead of drawing and filling a rectangle, you can draw an image to represent the button, using the <code>image(</code><code>)</code> function instead of <code>rect()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. In this case, the unarmed and armed images would also be properties of the button. The test of the mouse coordinates is against the numeric values of the rectangle or image size and is independent of whether anything is actually drawn. The graphical rendition of the button is for the convenience of the user.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>color bgcolor = color (200, 200, 200);
int bx=10, by=260, bw=60, bh=30;

void setup ()
{
  size (250, 300);
}

void draw ()
{
  background (bgcolor);
  drawButton ();
}

  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> void drawButton ()
{
  if (buttonArmed()) fill (20, 200, 40);
    else fill (200, 60, 80);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> rect (bx, by, bw, bh);
  fill (0);
  text ("Button", bx+13, by+19);
}

boolean buttonArmed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if ( (mouseX&gt;=bx) &amp;&amp; (mouseX&lt;bx+bw) &amp;&amp;
       (mouseY&gt;=by) &amp;&amp; (mouseY&lt;by+bh) ) return true;
  return false;
}

void mousePressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (buttonArmed())
    bgcolor = color(random(128,255), random(128,255), random(128,255));
}</code></pre>
<span epub:type="pagebreak" title="93" id="Page_93"/><figure class="graphic"><img src="Images/g042001.png" alt="g042001" width="313" height="376"/></figure>
<figure class="graphic"><img src="Images/g042002.png" alt="g042002" width="313" height="376"/></figure>
<figure class="graphic"><img src="Images/g042003.png" alt="g042003" width="314" height="376"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c05-0002" class="HeadProject"><span><span epub:type="pagebreak" title="94" id="Page_94"/>Sketch 43: The Class Object—Multiple Buttons</span></h2>
<p class="BodyFirst">This sketch will create and display three buttons, one for each color component: red, green, and blue. When a button is clicked, the corresponding components of the background color will change randomly.</p>
<p>If an application needs many buttons, the scheme presented in Sketch 42 becomes awkward. What we want is a type, like <code>PImage</code> or <code>PFont</code>, that represents a button, so we can declare button variables or an array of buttons. The new <code>button</code> type should contain within it all of the properties of a button along with all of the code, written as functions, that performs the legal button operations. </p>
<p>Making a custom type with associated functions is done using a feature called a class. A <span class="KeyTerm">class</span> is a way to enclose some variables and functions and give them a name.  The <code>button</code> class would look like this:</p>
<pre><code>class button
{
  <var>your code here</var>
}</code></pre>
<p>Inside the braces, we declare the variables used by the button: <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>, <code>label</code>, and so on. The functions <code>drawButton()</code> and <code>buttonArmed()</code> go inside the class too, along with something called a <span class="KeyTerm">constructor</span>: a function that is called automatically each time a new button (or, in general, a class object) is created. The <code>class</code> statement and what follows inside the braces declares the class as a custom type, and when you declare a variable of that class, you create an <span class="KeyTerm">instance</span>, one specific object that has the class variables and functions within it.</p>
<p>A variable of class <code>button</code> is declared just like a <code>PImage</code> variable:</p>
<pre><code>button b1, b2, b3;</code></pre>
<p>The next step, as with a <code>PImage</code> or <code>PFont</code>, is to create an instance of the <code>button</code> class using <code>new</code> and assign it to a variable:</p>
<pre><code>b1 = new  button (100, 150, 90, 30, "Button");</code></pre>
<p>When you use <code>new</code>, Processing calls the constructor for the class. The constructor accepts parameters, such as position or size, and saves them for later use in drawing the button. The constructor function has the same name as does the class <span class="CodeAnnotation" aria-label="annotation2">2</span> (in this case, <code>button</code>), and it has no function type—it is not preceded by <code>void</code> or a type name. The constructor itself has no return value, but the <code>new</code> operator will return a new instance of the class. If you define more than one constructor, Processing calls the one that matches the type and number of parameters given in the <code>new</code> statement. The constructor then returns a new instance of the class. You can create as many instances as your computer memory allows. </p>
<p>You access variables and functions in a class variable using <span class="KeyTerm">dot notation</span>. For the <code>button</code> class instance <code>bred</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, the <em>x</em> position is <code>bred.bx</code>, and to draw it, you’d call <code>bred.draw()</code>. The main draw function must call <code>draw()</code> for each of the buttons, or they won’t be displayed, and the <code>mousePressed()</code> function in the main program must check each button to see if it was clicked (that is, if the mouse cursor is inside the button) using the <code>armed()</code> function in each button.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>color bgcolor = color (200, 200, 200);
button bred, bgreen, bblue;
void setup()
{
  size (450, 300);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> bred = new button (10, 200, 50, 30, "Red");
  bgreen = new button (220, 200, 50, 30, "Green");
  bblue = new button (300, 200, 50, 30, "Blue");
}

void draw ()
{
  background (bgcolor);
  bred.draw(); 
  bgreen.draw(); 
  bblue.draw();
}

void mousePressed ()
{
  if (bred.armed()) bgcolor = color(random(128,255), 
           green(bgcolor), blue(bgcolor));
  if (bgreen.armed()) bgcolor = color(red(bgcolor), 
           random(128,255), blue(bgcolor));
  if (bblue.armed()) bgcolor = color(red(bgcolor), 
           green(bgcolor), random(128,255));
}
class button
{
  int bx, by, bw, bh;
  color armedColor= color(20,200,20);
  color unarmedColor = color (200,200,40);
  String label;

  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> button (int x, int y, int w, int h, String s)
  {
    bx = x;  by = y; bw = w;  bh = h;
    label = s;
  }

  void draw ()
  {
    if (armed()) fill (20, 200, 40);
      else fill (200, 60, 80);
    rect (bx, by, bw, bh);
    fill (0); text (label, bx+13, by+19);
  }

  boolean armed ()
  {
    if ( (mouseX&gt;=bx) &amp;&amp; (mouseX&lt;bx+bw) &amp;&amp;
         (mouseY&gt;=by) &amp;&amp; (mouseY&lt;by+bh) ) return true;
    return false;
  }
}
</code></pre>
<span epub:type="pagebreak" title="95" id="Page_95"/><figure class="graphic"><img src="Images/g043001.png" alt="g043001" width="394" height="262"/></figure>
<figure class="graphic"><img src="Images/g043002.png" alt="g043002" width="394" height="262"/></figure>
<figure class="graphic"><img src="Images/g043003.png" alt="g043003" width="394" height="262"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c05-0003" class="HeadProject"><span><span epub:type="pagebreak" title="96" id="Page_96"/>Sketch 44: A Slider</span></h2>
<p class="BodyFirst">A <span class="KeyTerm">slider</span> is a user interface widget that allows the user to move a small object (a <span class="KeyTerm">cursor</span>) along a linear path, either horizontally or vertically. The relative position of the cursor along the path represents a number. The cursor in one extreme position corresponds to the minimum value, and the cursor in the other extreme position represents the maximum. If the cursor is halfway between the min and max positions, the value associated with the slider is halfway between the min and max values. </p>
<p>This widget can be used to position a large image in a small window or a lot of text within a smaller area, and we call it a scroll bar in those cases. The purpose of a slider is, more generally, to allow the user to select a number geometrically by sliding a cursor between two limits, rather than typing it. It is a natural idea to choose a number as a fraction of a total, or as a part of a range of values. If we define <code>sliderPos</code> as the position of the cursor in pixels from the start of the slider, <code>sliderWidth</code> as the width of the slider in pixels, and <code>sliderMax</code> and <code>sliderMin</code> as the numerical values associated with the min and max cursor positions, this is the selected value <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code><code>value = (int)(((float)sliderPos/sliderWidth)*sliderMax + sliderMin);</code></code></pre>
<p>This expression is based on the fact that the slider position is a fraction of the total possible set of positions, and this represents the same fraction of the range between the <code>sliderMin</code> and <code>sliderMax</code><b> </b>values (see <a href="#figure44-1" id="figureanchor44-1">Figure 44-1</a>). </p>
<figure>
<img src="Images/f044001.png" alt="f044001" class="" width="504" height="405"/>
<figcaption><p><a id="figure44-1">Figure 44-1</a>: A slider</p></figcaption>
</figure>
<p>A slider can be represented graphically in many different ways. In this sketch, the widget is a horizontal rectangle with a circular cursor, and the current numerical value is drawn to the right. However, the cursor can be rectangular, elliptical, triangular, a pointer, or other shapes.</p>
<p>The <code>drawSlider()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> draws the rectangle and positions the cursor using the <code>sliderPos</code> variable, which is set when the user selects the cursor with the mouse and then moves (slides) it between the ends of the rectangle. To build a slider class, you would make class variables for the position, size, current cursor position and value, and class functions to draw the slider and position the cursor (which you’d then call as, for example, <code>slider.drawSlider()</code> or <code>slider.draw()</code>). </p>
<p>A common use for sliders is as a way to display an image. Often an image will not fit into a particular window, or into any window; some images are very large. Rather than <span epub:type="pagebreak" title="97" id="Page_97"/>resize the image, it is common to have a slider at the bottom and the right side of the window, and to use the cursor to position the window over the image so that various parts can be seen. The values selected with the sliders represent the (<em>x</em>, <em>y</em>) location of the window over top of the larger image.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <code>mouseDragged(</code><code>)</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> is called once every time the mouse moves while a mouse button is pressed. Also, note that mouse and keyboard events only work when a program has a <code>dra</code><code>w</code><code>(</code><code>)</code> function, even if that function does not do anything.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int sliderX=10, sliderY=100, sliderWidth=100, sliderHeight=8;
color sliderColor = color(128,128,128);
int sliderPos=0, sliderMin=0, sliderMax=1000;
int value=0;

void setup ()
{
  size(600,300);
}

void draw ()
{
  background (200);
  drawSlider ();
}

  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> void drawSlider ()
{
  fill (sliderColor);    // The bar part
  rect (sliderX, sliderY, sliderWidth, sliderHeight);
  fill (200,40,40);      // Slider partl
  ellipse (sliderX+sliderPos, sliderY+sliderHeight/2,12,12);
  fill (0);
  line (sliderX+sliderPos, sliderY, sliderX+sliderPos, sliderY+sliderHeight); 
  text (value, sliderX+sliderWidth+7, sliderY+sliderHeight);
}

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> void mouseDragged()
{
  if ((mouseY&lt;sliderY) || (mouseY&gt;sliderY+sliderHeight)) 
    return;
  if ((mouseX&gt;=sliderX) &amp;&amp; (mouseX&lt;=sliderX+sliderWidth))
    sliderPos = mouseX - sliderX;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> value = (int)(((float)sliderPos/sliderWidth)*sliderMax + sliderMin);
}</code></pre>
<figure class="graphic"><img src="Images/g044001-r.png" alt="g044001-r" width="299" height="313"/></figure>
<figure class="graphic"><img src="Images/g044002-r.png" alt="g044002-r" width="302" height="313"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c05-0004" class="HeadProject"><span><span epub:type="pagebreak" title="98" id="Page_98"/>Sketch 45: A Gauge Display</span></h2>
<p class="BodyFirst">The obvious way for a computer to display a numeric result is to simply display the number, but sometimes a more analog approach is easier for people to deal with. Some people like digital clocks, and some prefer the old kind with hands. The analog display can be faster for a human to process. A common kind of display is a <span class="KeyTerm">gauge</span>, where a pointer of some kind rotates and points to a number. Most older speedometers are displays of this type, for example. <a href="#figure45-1" id="figureanchor45-1">Figure 45-1</a> illustrates a gauge as a graphic and shows a simple abstraction of the situation.</p>
<figure>
<img src="Images/f045001.png" alt="f045001" class="" width="413" height="167"/>
<figcaption><p><a id="figure45-1">Figure 45-1</a>: A gauge showing a value near 0 (left), and the angles that are involved in the display (right)</p></figcaption>
</figure>
<p>A gauge can display values between a minimum and a maximum numeric value. The minimum value corresponds to the minimum angle the pointer can have (labeled α in the figure), and the maximum value corresponds to the maximum angle the pointer can have (labeled β). In this sketch, angles map directly onto values so that a difference of one degree always represents the same amount of change. To display a value, we calculate the angle that corresponds to that value, named <code>theta</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> in the sketch, and draw the pointer at that angle. </p>
<p>One way to look at this is as a <em>slider</em> that is shaped like a curve. Although the <em>gauge</em> is only a display, the mathematics of where to place the pointer is the same as for a slider, except we use angles instead of straight-line distances, and it is reorganized to provide a value for the position. <a href="#figure45-2" id="figureanchor45-2">Figure 45-2</a> shows how the slider situation converts into what we need for a gauge, and shows the formula for finding where to draw the pointer. This formula is really the same as the one used for the slider.</p>
<figure>
<img src="Images/f045002.png" alt="f045002" class="" width="378" height="394"/>
<figcaption><p><a id="figure45-2">Figure 45-2</a>: The gauge is like a bent slider. The equation shown here determines a position value (angle) given a numerical value, but it is otherwise the same as the one we used for the slider.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="99" id="Page_99"/>We do need to understand that 0 degrees is horizontal, and we convert the starting (α) and ending (β) angles so they are relative to 0. Starting at α, we decrease the angle of the pointer as the value increases toward the maximum. If α is 140, then β should be −45 rather than the equivalent angle, 315, so that β &lt; α. </p>
<p>The <code>gauge()</code> function draws the pointer at the angle specified by the equation in <a href="#figure45-2">Figure 45-2</a> given a data value, <code>v</code>. Don’t forget that angles in Processing need to be given as radians, so <code>pos</code> has to be converted from degrees.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int val = 0;
int dv  = -1;
int count = 0;
float dtor = 180.0/3.14159;
PImage background_image;   // Rendered gauge
int dataMin=0, dataMax=100;
float alpha=230, beta=-40; 

void setup ()
{
  size (170, 108);
  background_image = loadImage
                 ("data/gauge.png");
  frameRate( 30 );
  background (255);
}

/* Test main for a gauge widget */
void draw ()
{
  image (background_image, 0, 0);
  gauge (119, 55, val, 25);
  val = val + dv;
  if (val &gt; dataMax)    
  { val = dataMax; dv = -dv; }
  else if (val &lt; dataMin)
  { val = dataMin; dv = -dv; }
}

void gauge (int x, int y, int v, int dial_length)
{
  float theta;
  int xx, yy;
// Calculate rotation angle of pointer  
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> theta = radians (((v-dataMin)*(beta-alpha))/(dataMax-dataMin) + alpha);
  stroke (0, 0, 0);     
  yy = int(dial_length * sin(theta));  // x-coordinate of rotated pointer end
  xx = int(dial_length * cos(theta));  // y-coordinate of rotated pointer end
  yy = y-yy; xx = xx + x;
  line (x, y, xx, yy);
}</code></pre>
<figure class="graphic"><img src="Images/g045001.png" alt="g045001" width="331" height="213"/></figure>
<figure class="graphic"><img src="Images/g045002.png" alt="g045002" width="331" height="211"/></figure>
<figure class="graphic"><img src="Images/g045003.png" alt="g045003" width="331" height="211"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c05-0005" class="HeadProject"><span><span epub:type="pagebreak" title="100" id="Page_100"/>Sketch 46: A Likert Scale</span></h2>
<p class="BodyFirst">A <span class="KeyTerm">Likert scale</span> is a rating scale for answering questions, commonly used in questionnaires. The person being asked the question selects one of the answers from a set of choices (often five) ranging from “Strongly Disagree” to “Strongly Agree.” The idea is to collect standard answers upon which statistics can be computed.</p>
<p>This sketch poses a question by drawing it near the top of the screen <span class="CodeAnnotation" aria-label="annotation2">2</span>. The possible answers are numbered from 1 (Strongly Disagree) to 5 (Strongly Agree), and each answer corresponds to a circle. To select an answer, the user clicks on a circle, and the circle gets filled in <span class="CodeAnnotation" aria-label="annotation3">3</span>. When the user has answered to their satisfaction, then they type any key and the sketch asks another question.</p>
<p>The questions reside in a text file named <em>questions.txt</em> that is opened within <code>setup()</code>. We assume that there are multiple questions, and each is one line of text in the file. The <code>loadStrings()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function reads them all into an array named <code>question</code>, the length of which is the number of questions. Each question is asked (displayed) according to its index variable, <code>questionNo</code>, which iterates from 0 to the number of questions. The user selects an answer, one of five possible, by clicking the mouse within one of the five circles. That answer is chosen as the current selection (using a variable named <code>select</code>) in the <code>mouseReleased()</code> function.</p>
<p>When the user types a key, <code>keyPressed()</code> is called, and the selection will be written to a file named <em>save.txt</em> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Then the <code>questionNo</code> variable will be incremented, resulting in the next question being displayed. When all questions have been asked (that is, when <code>questionNo &gt; question.length</code>), the file is closed and the program ends. The answers chosen by the user to all questions are now stored in the <em>save.txt</em> file.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	There is only one output file, but there may be many users. We can prompt users for their name or an ID number, and that could be used as the basis for a filename, so that many distinct sets of answers could be saved. Another option would be to create filenames that end in consecutive numbers. When the program begins, it could try to open files until it arrived at one that did not exist; that would be the next usable filename.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int questionNo = 0;
String [] question;
int select = 0;
String list[];

void setup ()
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> question = loadStrings("questions.txt");
  list = new String[question.length];
  size (600, 300);
}

void draw ()
{
  background(200);
  drawGraphic();
  fill (0);
  textSize (20);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> text ((questionNo+1)+". "+question[questionNo], 20, 70);
}

void drawGraphic ()
{
  text ("Strongly Disagree      1   2   3   4   5      Strongly Agree",
          20, 140);
  noFill();
  if (select==1) fill(0); else noFill();
  ellipse (230, 180, 15, 15);
  if (select==2) fill(0); else noFill(); 
  ellipse (260, 180, 15, 15);
  if (select==3) fill(0); else noFill(); 
  ellipse (290, 180, 15, 15);
  if (select==4) fill(0); else noFill(); 
  ellipse (320, 180, 15, 15);
  if (select==5) fill(0); else noFill(); 
  ellipse (352, 180, 15, 15);
}

void mouseReleased ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (mouseY&lt;173 || mouseY &gt; 188) return;
  if (mouseX&gt;=223&amp;&amp;mouseX&lt;=238) select = 1; 
  if (mouseX&gt;=253&amp;&amp;mouseX&lt;=268) select = 2; 
  if (mouseX&gt;=283&amp;&amp;mouseX&lt;=298) select = 3; 
  if (mouseX&gt;=313&amp;&amp;mouseX&lt;=328) select = 4; 
  if (mouseX&gt;=345&amp;&amp;mouseX&lt;=360) select = 5; 
}
void keyPressed ()
{
  list[questionNo] = "Question  "+str(questionNo+1)+"  "+str(select);
  questionNo = questionNo + 1;
  if (questionNo &gt;= question.length) 
  {
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> saveStrings("save.txt", list);
    exit();
  }
}</code></pre>
<span epub:type="pagebreak" title="101" id="Page_101"/><figure class="graphic"><img src="Images/g046001.png" alt="g046001" width="458" height="229"/></figure>
<figure class="graphic"><img src="Images/g046002.png" alt="g046002" width="261" height="191"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c05-0006" class="HeadProject"><span><span epub:type="pagebreak" title="102" id="Page_102"/>Sketch 47: A Thermometer</span></h2>
<p class="BodyFirst">The original thermometer, made of glass with a colored fluid inside, had a design imposed by its function, but it was also an excellent way to display numeric data. It represents a number as the height of a colored line or rectangle. It is easy to see how tall a rectangle is and easy to compare it to others. This idea has been used in many places, most noticeably on sound equipment to show volume.</p>
<p>The representation on a computer is straightforward. A colored rectangle grows and shrinks as a function of how large a numeric variable is. Such a variable has a minimum and maximum value, and the rectangle has a minimum (usually 0) and maximum height. The mapping between the number and the height can be done as it was for the slider (Sketch 44) and the dial gauge (Sketch 45). In this sketch, it is implemented a bit differently, but it is computed in the same way.</p>
<p>This sketch computes how much taller the rectangle gets for each increase in the variable <span class="CodeAnnotation" aria-label="annotation1">1</span>. If the rectangle’s height can go from <code>ystart</code> to <code>yend</code>, and the range of data values is from <code>dataMin</code> to <code>dataMax</code>, then the change in rectangle height for each data increment is as follows:</p>
<pre><code>delta = (float)(ystart-yend)/(float)(dataMax-dataMin);</code></pre>
<p>Then for any data value, <code>data</code>, the height of the rectangle relative to <code>ystart</code> is the following:</p>
<pre><code>val = ystart-(int)(data*delta);</code></pre>
<p>This process only draws a rectangle, which is not very exciting, so we’ll add a background image (created specifically for this program) that contains an image of a glass thermometer and gradations that allow the user to interpret the height as a number. The coordinates of the rectangle have to be mapped specifically onto the image so that the rectangle aligns with the thermometer column, using a similar process as in Sketch 45.</p>
<p>This example generates a random numeric value for display. After starting arbitrarily at <code>data = 15</code>, the value changes by a small random amount each frame.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage thermo;               // Thermometer image
int xpos=100, ypos=50;       // Position of upper left
int ystart = 240;            // Position of Y lowest point
int yend = 44;               // Position of Y highest point
int xstart = 32;             // Left of red column
int xend = 50;               // Right of red column
int dataMin=0, dataMax=90;   // Range of data values
float delta = 1;
float data = 15.0;

void setup ()
{
  size (400, 400);                        // Window size
  thermo = loadImage ("thermo.gif");      // Read button images
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> delta = (float)(ystart-yend)/(float)(dataMax-dataMin);
  rectMode (CORNERS);
  noStroke();
}

void draw ()
{
  int val;
  
  background (200);                                      // White background
  image(thermo, xpos, ypos);                             // Draw the basic thermometer
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> val = ystart-(int)(data*delta);                        // Scale data to Y range
  fill (140, 4, 20);                                     // Fill with red
  rect (xstart+xpos, val+ypos, xend+xpos, ystart+ypos);  // Draw red
  text (""+(int)data, xstart+xpos, ystart+ypos+30);      // Draw data value
  data = data + random(2) - 1;                           // Modify data for display purposes
  if (data &gt; dataMax) data = dataMax;
  else if (data &lt; dataMin) data = dataMin;
}</code></pre>
<span epub:type="pagebreak" title="103" id="Page_103"/><figure class="graphic"><img src="Images/g047001.png" alt="g047001" width="433" height="432"/></figure>
<figure class="graphic"><img src="Images/g047002.png" alt="g047002" width="433" height="433"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>