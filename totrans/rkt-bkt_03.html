<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_13"/><strong><span class="big">2</span><br/>FESTI ROOTKIT: THE MOST ADVANCED SPAM AND DDOS BOT</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">This chapter is devoted to one of the most advanced spam and distributed denial of service (DDoS) botnets discovered—the Win32/Festi botnet, which we’ll refer to simply as Festi from now on. Festi has powerful spam delivery and DDoS capabilities, as well as interesting rootkit functionality that allows it to stay under the radar by hooking into the filesystem and system registry. Festi also conceals its presence by actively counteracting dynamic analysis with debugger and sandbox evasion techniques.</p>
<p class="indent">From a high-level point of view, Festi has a well-designed modular architecture implemented entirely in the kernel-mode driver. Kernel-mode programming is, of course, fraught with danger: a single error in the code can cause the system to crash and render it unusable, potentially leading <span epub:type="pagebreak" id="page_14"/>the user to reinstall the system afresh, wiping the malware. For this reason, it’s rare for spam-sending malware to rely heavily on kernel-mode programming. The fact that Festi was able to inflict so much damage is indicative of the solid technical skills of its developer(s) and their in-depth understanding of the Windows system. Indeed, they came up with several interesting architectural decisions, which we’ll cover in this chapter.</p>
<h3 class="h3" id="ch02lev1sec1"><strong>The Case of Festi Botnet</strong></h3>
<p class="noindent">The Festi botnet was first discovered in the fall of 2009, and by May 2012, it was one of the most powerful and active botnets for sending spam and performing DDoS attacks. The botnet was initially available to anyone for lease, but after early 2010, it was restricted to major spam partners, like Pavel Vrublebsky, one of the actors who used the Festi botnet for criminal activities as detailed in the book <em>Spam Nation</em> by Brian Krebs (Sourcebooks, 2014).</p>
<p class="indent">According to statistics from M86 Security Labs (currently Trustwave) for 2011, shown in <a href="ch02.xhtml#ch02fig01">Figure 2-1</a>, Festi was one of the three most active spam botnets in the world in the reported period.</p>
<div class="image"><a id="ch02fig01"/><img src="../images/02fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-1: The most prevalent spam botnets according to M86 Security Labs</em></p>
<p class="indent">Festi’s rise in popularity stemmed from a particular attack on Assist, a payment-processing company.<sup><a id="ch02fn1a" href="footnotes.xhtml#ch02fn1">1</a></sup> Assist was one of the companies bidding for a contract with Aeroflot, Russia’s largest airline, but a few weeks before Aeroflot was due to make its decision, cybercriminals used Festi to launch a massive DDoS attack against Assist. The attack rendered the processing system unusable for an extended period of time, eventually forcing Aeroflot to award another company the contract. This event is a prime example of how rootkits may be used in real-world crime.</p>
<h3 class="h3" id="ch02lev1sec2"><span epub:type="pagebreak" id="page_15"/><strong>Dissecting the Rootkit Driver</strong></h3>
<p class="noindent">The Festi rootkit is distributed mainly through a PPI scheme similar to the TDL3 rootkit discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>. The dropper’s rather simple functionality installs into the system a kernel-mode driver that implements the main logic of the malware. The kernel-mode component is registered as a “system start” kernel-mode driver with a randomly generated name, meaning the malicious driver is loaded and executed at system bootup during initialization.</p>
<div class="sidebar">
<p class="sidebart"><strong>DROPPER INFECTOR</strong></p>
<p class="spara">A <em>dropper</em> is a special type of infector. Droppers carry a payload to the victim system within itself. The payload is frequently compressed and encrypted or obfuscated. Once executed, a dropper extracts the payload from its image and installs it on a victim system (that is, drops it on the system—thus the name for this type of infector). Unlike droppers, <em>downloaders</em>—another type of infector—don’t carry payloads within themselves but rather download it from a remote server.</p>
</div>
<p class="indent">The Festi botnet targets only the Microsoft Windows x86 platform and does not have a kernel-mode driver for 64-bit platforms. This was fine at the time of its distribution, as there were still many 32-bit operating systems in use, but now means the rootkit has largely been rendered obsolete as 64-bit systems have outnumbered 32-bit systems.</p>
<p class="indent">The kernel-mode driver has two main duties: requesting configuration information from the command and control (C&amp;C) server and downloading and executing malicious modules in the form of plug-ins (illustrated in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a>). Each plug-in is dedicated to a certain job, such as performing DDoS attacks against a specified network resource or sending spam to an email list provided by the C&amp;C server.</p>
<div class="image"><a id="ch02fig02"/><img src="../images/02fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-2: Operation of the Festi rootkit</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_16"/>Interestingly, the plug-ins aren’t stored on the system hard drive but instead in volatile memory, meaning that when the infected computer is powered off or rebooted, the plug-ins vanish from system memory. This makes forensic analysis of the malware significantly harder since the only file stored on the hard drive is the main kernel-mode driver, which contains neither the payload nor any information on attack targets.</p>
<h4 class="h4" id="ch02lev2sec1"><strong><em>Festi Configuration Information for C&amp;C Communication</em></strong></h4>
<p class="noindent">To enable it to communicate with C&amp;C server, Festi is distributed with three pieces of predefined configuration information: the domain names of C&amp;C servers, the key to encrypt data transmitted between the bot and C&amp;C, and the bot version information</p>
<p class="indent">This configuration information is hardcoded into the driver’s binary. <a href="ch02.xhtml#ch02fig03">Figure 2-3</a> shows a section table of the kernel-mode driver with a writable section named <span class="literal">.cdata</span>, which stores the configuration data as well as strings that are used to perform the malicious activity.</p>
<div class="image"><a id="ch02fig03"/><img src="../images/02fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-3: Section table of Festi kernel-mode driver</em></p>
<p class="indent">The malware obfuscates the contents with a simple algorithm that XORs the data with a 4-byte key. The <span class="literal">.cdata</span> section in decrypted at the very beginning of the driver initialization.</p>
<p class="indent">The strings within the <span class="literal">.cdata</span> section, listed in <a href="ch02.xhtml#ch02tab01">Table 2-1</a>, can garner the attention of security software, so obfuscating them helps the bot evade detection.</p>
<p class="tabcap" id="ch02tab01"><strong>Table 2-1:</strong> Encrypted Strings in the Festi Configuration Data Section</p>
<table class="topbot-d">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>String</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Purpose</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">\Device\Tcp</span></p>
<p class="taba"><span class="literal">\Device\Udp</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Names of device objects used by the malware to send and receive data over the network</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">\REGISTRY\MACHINE\SYSTEM\ CurrentControlSet\Services\ SharedAccess\Parameters\FirewallPolicy\ StandardProfile\GloballyOpenPorts\List</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Path to the registry key with the parameters of the Windows firewall, used by the malware to disable the local firewall</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">ZwDeleteFile, ZwQueryInformationFile, ZwLoadDriver, KdDebuggerEnabled, ZwDeleteValueKey, ZwLoadDriver</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Names of system services used by the malware</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch02lev2sec2"><span epub:type="pagebreak" id="page_17"/><strong><em>Festi’s Object-Oriented Framework</em></strong></h4>
<p class="noindent">Unlike many kernel-mode drivers, which are usually written in plain C using the procedural programming paradigm, the Festi driver has an object-oriented architecture. The main components (classes) of the architecture implemented by the malware are:</p>
<p class="hangt"><strong>Memory manager</strong> Allocates and releases memory buffers</p>
<p class="hang"><strong>Network sockets</strong> Send and receive data over the network</p>
<p class="hang"><strong>C&amp;C protocol parser</strong> Parses C&amp;C messages and executes received commands</p>
<p class="hangb"><strong>Plug-in manager</strong> Manages downloaded plug-ins</p>
<p class="indent">The relationships among these components are illustrated in <a href="ch02.xhtml#ch02fig04">Figure 2-4</a>.</p>
<div class="image"><a id="ch02fig04"/><img src="../images/02fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-4: Architecture of the Festi kernel-mode driver</em></p>
<p class="indent">As you can see, the memory manager is the central component used by all other components.</p>
<p class="indent">This object-oriented approach allows the malware to be easily ported to other platforms, like Linux. To do so, an attacker would need to change only system-specific code (like the code that calls system services for memory management and network communication) that is isolated by the component’s interface. Downloaded plug-ins, for instance, rely almost completely on the interfaces provided by the main module; they rarely use routines provided by the system to do system-specific operations.</p>
<h4 class="h4" id="ch02lev2sec3"><strong><em>Plug-in Management</em></strong></h4>
<p class="noindent">Plug-ins downloaded from the C&amp;C server are loaded and executed by the malware. To manage the downloaded plug-ins efficiently, Festi maintains an array of pointers to a specially defined <span class="literal">PLUGIN_INTERFACE</span> structure. Each structure corresponds to a particular plug-in in memory and provides the bot with specific entry points—routines responsible for handling data received from C&amp;C, as shown in <a href="ch02.xhtml#ch02fig05">Figure 2-5</a>. This way, Festi keeps track of all the malicious plug-ins loaded in memory.</p>
<div class="image"><span epub:type="pagebreak" id="page_18"/><a id="ch02fig05"/><img src="../images/02fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-5: Layout of the array of pointers to <span class="literal">PLUGIN_INTERFACE</span> structures</em></p>
<p class="indent"><a href="ch02.xhtml#ch02list01">Listing 2-1</a> shows the layout of the <span class="literal">PLUGIN_INTERFACE</span> structure.</p>
<p class="programs">struct PLUGIN_INTERFACE<br/>
{<br/>
  // Initialize plug-in<br/>
  PVOID Initialize;<br/>
  // Release plug-in, perform cleanup operations<br/>
  PVOID Release;<br/>
  // Get plug-in version information<br/>
  PVOID GetVersionInfo_1;<br/>
  // Get plug-in version information<br/>
  PVOID GetVersionInfo_2;<br/>
  // Write plug-in-specific information into tcp stream<br/>
  PVOID WriteIntoTcpStream;<br/>
  // Read plug-in specific information from tcp stream and parse data<br/>
  PVOID ReadFromTcpStream;<br/>
  // Reserved fields<br/>
  PVOID Reserved_1;<br/>
  PVOID Reserved_2;<br/>
};</p>
<p class="listing" id="ch02list01"><em>Listing 2-1: Defining the <span class="literal">PLUGIN_INTERFACE</span> structure</em></p>
<p class="indent">The first two routines, <span class="literal">Initialize</span> and <span class="literal">Release</span>, are intended for plug-in initialization and termination, respectively. The following two routines, <span class="literal">GetVersionInfo_1</span> and <span class="literal">GetVersionInfo_2</span>, are used to obtain version information for the plug-in in question.</p>
<p class="indent">The routines <span class="literal">WriteIntoTcpStream</span> and <span class="literal">ReadFromTcpStream</span> are used to exchange data between the plug-in and the C&amp;C server. When Festi transmits data to the C&amp;C server, it runs through the array of pointers to the plug-in interfaces and executes the <span class="literal">WriteIntoTcpStream</span> routine of each registered plug-in, passing a pointer to a TCP stream object as a parameter. The TCP stream object implements the functionality of the network communication interface.</p>
<p class="indent"><span epub:type="pagebreak" id="page_19"/>On receiving data from the C&amp;C server, the bot executes the plug-ins’ <span class="literal">ReadFromTcpStream</span> routine, so that the registered plug-ins can get parameters and plug-in-specific configuration information from the network stream. As a result, every loaded plug-in can communicate with the C&amp;C server independently of all other plug-ins, which means plug-ins can be developed independently of one another, increasing the efficiency of their development and the stability of the architecture.</p>
<h4 class="h4" id="ch02lev2sec4"><strong><em>Built-in Plug-ins</em></strong></h4>
<p class="noindent">Upon installation, the main malicious kernel-mode driver implements two built-in plug-ins: the <em>configuration information manager</em> and the <em>bot plug-in manager</em>.</p>
<h5 class="h5" id="ch02lev3sec1"><strong>Configuration Information Manager</strong></h5>
<p class="noindent">The configuration information manager plug-in is responsible for requesting configuration information and downloading plug-ins from the C&amp;C server. This simple plug-in periodically connects to the C&amp;C server to download the data. The delay between two consecutive requests is specified by the C&amp;C server itself, likely to avoid static patterns that security software can use to detect infections. We describe the network communication protocol between the bot and the C&amp;C server in “<a href="ch02.xhtml#ch02lev1sec3">The Festi Network Communication Protocol</a>” on <a href="ch02.xhtml#page_26">page 26</a>.</p>
<h5 class="h5" id="ch02lev3sec2"><strong>Bot Plug-in Manager</strong></h5>
<p class="noindent">The bot plug-in manager is responsible for maintaining the array of downloaded plug-ins. It receives remote commands from the C&amp;C server and loads and unloads specific plug-ins, delivered in compressed form, onto the system. Each plug-in has a default entry point—<span class="literal">DriverEntry</span>—and exports the two routines <span class="literal">CreateModule</span> and <span class="literal">DeleteModule</span>, as shown in <a href="ch02.xhtml#ch02fig06">Figure 2-6</a>.</p>
<div class="image"><a id="ch02fig06"/><img src="../images/02fig06.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-6: Export Address table of a Festi plug-in</em></p>
<p class="indent">The <span class="literal">CreateModule</span> routine is executed upon plug-in initialization and returns a pointer to the <span class="literal">PLUGIN_INTERFACE</span> structure, as described back in <a href="ch02.xhtml#ch02list01">Listing 2-1</a>. It takes as a parameter a pointer to several interfaces provided by the main module, such as the memory manager and network interface.</p>
<p class="indent">The <span class="literal">DeleteModule</span> routine is executed when the plug-in is unloaded and frees all the previously allocated resources. <a href="ch02.xhtml#ch02fig07">Figure 2-7</a> shows the plug-in manager’s algorithm for loading the plug-in.</p>
<div class="image"><span epub:type="pagebreak" id="page_20"/><a id="ch02fig07"/><img src="../images/02fig07.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-7: Plug-in manager algorithm</em></p>
<p class="indent">The malware first decompresses the plug-in into the memory buffer and then maps it into the kernel-mode address space as a PE image. The plug-in manager initializes the Import Address table (IAT) and relocates it to the mapped image. In this algorithm, Festi also emulates a typical operating system’s runtime loader and dynamic linker of OS modules.</p>
<p class="indent">Depending on whether the plug-in is being loaded or unloaded, the plug-in manager executes either the <span class="literal">CreateModule</span> or <span class="literal">DeleteModule</span> routine. If the plug-in is being loaded, the plug-in manager obtains the plug-in’s ID and version information, then registers it to the <span class="literal">PLUGIN_INTERFACE</span> structures.</p>
<p class="indent">If the plug-in is being unloaded, the malware releases all memory previously allocated to the plug-in image.</p>
<h4 class="h4" id="ch02lev2sec5"><strong><em>Anti–Virtual Machine Techniques</em></strong></h4>
<p class="noindent">Festi has techniques for detecting whether it is running inside a VMware virtual machine in order to evade sandboxes and automated malware analysis environments. It attempts to obtain the version of any existent VMWare software by executing the code shown in <a href="ch02.xhtml#ch02list02">Listing 2-2</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_21"/>mov eax, 'VMXh'<br/>
mov ebx, 0<br/>
mov ecx, 0Ah<br/>
mov edx, 'VX'<br/>
in eax, dx</p>
<p class="listing" id="ch02list02"><em>Listing 2-2: Obtaining the VMWare software version</em></p>
<p class="indent">Festi checks the <span class="literal">ebx</span> register, which will contain the value <span class="literal">VMX</span> if the code is being executed in a VMware virtual environment and <span class="literal">0</span> if not.</p>
<p class="indent">Interestingly, if Festi detects the presence of a virtual environment, it doesn’t immediately terminate execution but proceeds as if it were being executed on the physical computer. When the malware requests plug-ins from the C&amp;C server, it submits certain information that reveals whether it’s being executed in the virtual environment; if it is, the C&amp;C server may not return any plug-ins.</p>
<p class="indent">This is likely a technique for evading dynamic analysis: Festi doesn’t terminate communication with the C&amp;C server in an effort to trick the automatic analysis system into thinking Festi hasn’t noticed it, while in fact the C&amp;C server is aware of being monitored and so won’t provide any commands or plug-ins. It’s common for malware to terminate execution once it detects that it’s running under a debugger or in a sandbox environment in order to avoid revealing the configuration information and payload modules.</p>
<p class="indent">However, malware researchers are savvy to this behavior: if the malware promptly terminates without performing any malicious activity, it can draw the attention of an analyst, who will likely then perform a deeper analysis to find out why it didn’t work, eventually discovering the data and code the malware is trying to conceal. By not terminating its execution when a sandbox is detected, Festi attempts to avoid these consequences, but it does instruct its C&amp;C to not provide the sandbox with malicious modules and configuration data.</p>
<p class="indent">Festi also checks for the presence of network traffic monitoring software on the system, which may indicate that the malware has been executed in a malware analysis and monitoring environment. Festi looks for the kernel-mode driver <em>npf.sys</em> (network packet filter). This driver belongs to the Windows packet capture library, WinPcap, which is frequently used by network monitoring software like Wireshark to gain access to the data link network layer. The presence of the <em>npf.sys</em> driver indicates that there are network monitoring tools installed on the system, meaning it is unsafe for the malware.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_22"/><strong>WINPCAP</strong></p>
<p class="spara">The <em>Windows packet capture library</em> (WinPcap) allows applications to capture and transmit network packets, bypassing the protocol stack. It provides functionality for kernel-level network packet filtering and monitoring. This library is used extensively as a filtering engine by many open source and commercial network tools, like protocol analyzers, network monitors, network intrusion detection systems, and sniffers, including widely known tools such as Wireshark, Nmap, Snort, and ntop.</p>
</div>
<h4 class="h4" id="ch02lev2sec6"><strong><em>Antidebugging Techniques</em></strong></h4>
<p class="noindent">Festi also checks for the presence of a kernel debugger in the system by examining the <span class="literal">KdDebuggerEnabled</span> variable exported from the operating system kernel image. If a system debugger is attached to the operating system, this variable contains the value <span class="literal">TRUE</span>; otherwise, it contains <span class="literal">FALSE</span>.</p>
<p class="indent">Festi actively counteracts the system debugger by periodically zeroing the debugging registers <span class="literal">dr0</span> through <span class="literal">dr3</span>. These registers are used to store addresses for breakpoints, and removing the hardware breakpoints hinders the debugging process. The code for clearing the debugging registers is shown in <a href="ch02.xhtml#ch02list03">Listing 2-3</a>.</p>
<p class="programs">char _thiscall ProtoHandler_1(STRUCT_4_4 *this, PKEVENT a1)<br/>
{<br/>
<span class="codestrong1">__writedr(0, 0); // mov dr0, 0</span><br/>
<span class="codestrong1">__writedr(1u, 0); // mov dr1, 0</span><br/>
<span class="codestrong1">__writedr(2u, 0); // mov dr2, 0</span><br/>
<span class="codestrong1">__writedr(3ut 0); // mov dr3, 0</span><br/>
  return _ProtoHandler(&amp;this-&gt;struct43, a1);<br/>
}</p>
<p class="listing" id="ch02list03"><em>Listing 2-3: Clearing debugging registers in Festi code</em></p>
<p class="indent">The highlighted <span class="literal">writedr</span> instructions perform write operations on the debugging registers. As you can see, Festi writes zeros to these registers before executing the <span class="literal">_ProtoHandler</span> routine, which is responsible for handling the communication protocol between the malware and C&amp;C servers.</p>
<h4 class="h4" id="ch02lev2sec7"><strong><em>The Method for Hiding the Malicious Driver on Disk</em></strong></h4>
<p class="noindent">To protect and conceal the image of the malicious kernel-mode driver stored on the hard drive, Festi hooks the filesystem driver so that it can intercept and modify all requests sent to the filesystem driver to exclude evidence of its presence.</p>
<p class="indent"><span epub:type="pagebreak" id="page_23"/>A simplified version of the routine for installing the hook is shown in <a href="ch02.xhtml#ch02list04">Listing 2-4</a>.</p>
<p class="programs">NTSTATUS __stdcall SetHookOnSystemRoot(PDRIVER_OBJECT DriverObject,<br/>
                                       int **HookParams)<br/>
{<br/>
  RtlInitUnicodeString(&amp;DestinationString, L"\\SystemRoot");<br/>
  ObjectAttributes.Length = 24;<br/>
  ObjectAttributes.RootDirectory = 0;<br/>
  ObjectAttributes.Attributes = 64;<br/>
  ObjectAttributes.ObjectName = &amp;DestinationString;<br/>
  ObjectAttributes.SecurityDescriptor = 0;<br/>
  ObjectAttributes.SecurityQualityOfService = 0;<br/>
<br/>
<span class="ent">➊</span> NTSTATUS Status = IoCreateFile(&amp;hSystemRoot, 0x80000000, &amp;ObjectAttributes,<br/>
                                 &amp;IoStatusBlock, 0, 0, 3u, 1u, 1u, 0, 0, 0, 0,<br/>
                                 0x100u);<br/>
  if (Status &lt; 0 )<br/>
    return Status;<br/>
<br/>
<span class="ent">➋</span> Status = ObReferenceObjectByHandle(hSystemRoot, 1u, 0, 0,<br/>
                                     &amp;SystemRootFileObject, 0);<br/>
  if (Status &lt; 0 )<br/>
    return Status;<br/>
<br/>
<span class="ent">➌</span> PDEVICE_OBJECT TargetDevice = IoGetRelatedDeviceObject(SystemRootFileObject);<br/>
  if ( !_ TargetDevice )<br/>
      return STATUS_UNSUCCESSFUL;<br/>
<br/>
  ObfReferenceObject(TargetDevice);<br/>
  Status = IoCreateDevice(DriverObject, 0xCu, 0, TargetDev-&gt;DeviceType,<br/>
                          TargetDevice-&gt;Characteristics, 0, &amp;SourceDevice);<br/>
  if (Status &lt; 0 )<br/>
    return Status;<br/>
<br/>
<span class="ent">➍</span> PDEVICE_OBJECT DeviceAttachedTo = IoAttachDeviceToDeviceStack(SourceDevice,<br/>
                                                                TargetDevice);<br/>
  if ( ! DeviceAttachedTo )<br/>
  {<br/>
    IoDeleteDevice(SourceDevice);<br/>
    return STATUS_UNSUCCESSFUL;<br/>
  }<br/>
<br/>
  return STATUS_SUCCESS;<br/>
}</p>
<p class="listing" id="ch02list04"><em>Listing 2-4: Hooking the filesystem device driver stack</em></p>
<p class="indent">The malware first tries to obtain a handle to the special system file <span class="literal">SystemRoot</span>, which corresponds to the Windows installation directory <span class="ent">➊</span>. Then, by executing the <span class="literal">ObReferenceObjectByHandle</span> system routine <span class="ent">➋</span>, Festi obtains a pointer to the <span class="literal">FILE_OBJECT</span> that corresponds to the handle for <span class="literal">SystemRoot</span>. The <span class="literal">FILE_OBJECT</span> is a special data structure used by the operating system to manage access to device objects and so contains a pointer <span epub:type="pagebreak" id="page_24"/>to the related device object. In our case, since we opened a handle for <span class="literal">SystemRoot</span>, the <span class="literal">DEVICE_OBJECT</span> is related to the operating system filesystem driver. The malware obtains the pointer to the <span class="literal">DEVICE_OBJECT</span> by executing the <span class="literal">IoGetRelatedDeviceObject</span> system routine <span class="ent">➌</span>, then creates a new device object and attaches it to the acquired device object pointer by calling <span class="literal">IoAttachDeviceToDeviceStack</span> <span class="ent">➍</span>, as shown in the layout of the filesystem device stack in <a href="ch02.xhtml#ch02fig08">Figure 2-8</a>. Festi’s malicious device object is located on top of the stack, meaning the I/O requests intended for the filesystem are rerouted to the malware. This allows Festi to conceal itself by altering request and return data to and from the filesystem driver.</p>
<div class="image"><a id="ch02fig08"/><img src="../images/02fig08.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-8: Layout of the filesystem device stack hooked by Festi</em></p>
<p class="indent">At the very bottom of <a href="ch02.xhtml#ch02fig08">Figure 2-8</a>, you can see the filesystem driver object and the corresponding device object that handles OS filesystem requests. Some additional filesystem filters might be attached here too. Toward the top of the figure, you can see the Festi driver attached to the filesystem device stack.</p>
<p class="indent">This design uses and closely follows the Windows stacked I/O driver design, reproducing the design pattern of the native OS. By now, you probably see the trend: the rootkit aims to blend with the OS cleanly and reliably, emulating winning OS design patterns for its own modules. In fact, you can learn a lot about OS internals from analyzing aspects of rootkits, such as Festi’s handling of input/output requests.</p>
<p class="indent">In Windows, a filesystem I/O request is represented as an IRP, which goes through the stack from top to bottom. Every driver in the stack can observe and modify the request or returned data. This means that, as shown in <a href="ch02.xhtml#ch02fig08">Figure 2-8</a>, Festi can modify IRP requests addressed to the filesystem driver and any corresponding returned data.</p>
<p class="indent"><span epub:type="pagebreak" id="page_25"/>Festi monitors the IRPs using the <span class="literal">IRP_MJ_DIRECTORY_CONTROL</span> request code, used to query the contents of the directory, watching for queries related to where the malware’s kernel-mode driver is located. If it detects such a request, Festi modifies the returned data from the filesystem driver to exclude any entry corresponding to the malicious driver file.</p>
<h4 class="h4" id="ch02lev2sec8"><strong><em>The Method for Protecting the Festi Registry Key</em></strong></h4>
<p class="noindent">Festi also hides a registry key corresponding to the registered kernel-mode driver using a similar method. Located in <em>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</em>, the registry key contains Festi’s driver type and the path to the driver’s image on the filesystem. This makes it vulnerable to detection by security software, so Festi must hide the key.</p>
<p class="indent">To do so, Festi first hooks the <span class="literal">ZwEnumerateKey</span>, a system service that queries information on a specified registry key and returns all of its subkeys, by modifying the <em>System Service Descriptor Table (SSDT)</em>, a special data structure in the operating system kernel that contains addresses of the system service handlers. Festi replaces the address of the original <span class="literal">ZwEnumerateKey</span> handler with the address of the hook.</p>
<div class="sidebar">
<p class="sidebart"><strong>WINDOWS KERNEL PATCH PROTECTION</strong></p>
<p class="spara">It’s worth mentioning that this hooking approach—modifying SSDT—works only on 32-bit Microsoft Windows operating systems. As mentioned in <a href="ch01.xhtml#ch01">Chapter 1</a>, the 64-bit editions of Windows implement <em>Kernel Patch Protection</em> (also known as PatchGuard) technology to prevent software from patching certain system structures, including SSDT. If PatchGuard detects a modification of any of the monitored data structures, it crashes the system.</p>
</div>
<p class="indent">The <span class="literal">ZwEnumerateKey</span> hook monitors requests addressed to the <em>HKLM\System\CurrentControlSet\Service</em> registry key, which contains subkeys related to kernel-mode drivers installed on the system, including the Festi driver. Festi modifies the list of subkeys in the hook to exclude the entry corresponding to its driver. Any software that relies on <span class="literal">ZwEnumerateKey</span> to obtain the list of installed kernel-mode drivers will not notice the presence of Festi’s malicious driver.</p>
<p class="indent">If the registry is discovered by security software and removed during shutdown, Festi is also capable of replacing the registry key. In this case, Festi first executes the system routine <span class="literal">IoRegisterShutdownNotification</span> in order to receive shutdown notifications when the system is turned off. It checks the shutdown notification handler to see if the malicious driver and the corresponding registry key are present in the system, and if they’re not (that is, if they’ve been removed), it restores them, guaranteeing that it will persist through reboot.</p>
<h3 class="h3" id="ch02lev1sec3"><span epub:type="pagebreak" id="page_26"/><strong>The Festi Network Communication Protocol</strong></h3>
<p class="noindent">To communicate with C&amp;C servers and perform its malicious activities, Festi employs a custom network communication protocol that it must protect against eavesdropping. In the course of our investigation of the Festi botnet,<sup><a id="ch02fn2a" href="footnotes.xhtml#ch02fn2">2</a></sup> we obtained a list of C&amp;C servers it communicates with and found that while some focused on sending spam and others performed DDoS attacks, both types implemented a single communication protocol. The Festi communication protocol consists of two phases: the initialization phase, when it obtains C&amp;C IP addresses, and the work phase, when it requests a job description from C&amp;C.</p>
<h4 class="h4" id="ch02lev2sec9"><strong><em>Initialization Phase</em></strong></h4>
<p class="noindent">During the initialization phase, the malware obtains the IP addresses of the C&amp;C server, whose domain names are stored in the bot’s binary. What’s interesting about this process is that the malware manually resolves the C&amp;C IP address from the C&amp;C server domain names. Specifically, it constructs a DNS request packet to resolve the C&amp;C server domain name and sends the packet to one of two hosts, 8.8.8.8 or 8.8.4.4 at port 53, both of which are Google DNS servers. In reply, Festi receives an IP address it can use in subsequent communication.</p>
<p class="indent">Manually resolving domain names makes the botnet more resilient to takedown attempts. If Festi had to rely on a local ISP’s DNS servers for resolving domain names, it would be possible for the ISP to block access to the C&amp;C servers by modifying DNS information on them—say, if a law enforcement agency issued a warrant to block those domain names. By manually crafting DNS requests and sending them to Google servers, however, the malware bypasses an ISP’s DNS infrastructure and makes a takedown more difficult.</p>
<h4 class="h4" id="ch02lev2sec10"><strong><em>Work Phase</em></strong></h4>
<p class="noindent">The work phase is when Festi requests information from the C&amp;C server on what tasks it is to perform. Communication with the C&amp;C servers is performed over the TCP protocol. The layout of the network packet request sent to the C&amp;C server, shown in <a href="ch02.xhtml#ch02fig09">Figure 2-9</a>, consists of a message header and an array of plug-in-specific data.</p>
<div class="image"><a id="ch02fig09"/><img src="../images/02fig09.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-9: Layout of the network packet sent to the C&amp;C server</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_27"/>The message header is generated by the configuration manager plug-in and contains the following information:</p>
<ul>
<li class="noindent">Festi version information</li>
<li class="noindent">Whether a system debugger is present</li>
<li class="noindent">Whether virtualization software (VMWare) is present</li>
<li class="noindent">Whether network traffic monitoring software (WinPcap) is present</li>
<li class="noindent">Operating system version information</li>
</ul>
<p class="noindent">The plug-in-specific data consists of an array of <em>tag-value-term</em> entries:</p>
<p class="hangt"><strong>Tag</strong> A 16-bit integer specifying a type of value that follows the tag</p>
<p class="hang"><strong>Value</strong> Specific data in the form of a byte, word, dword, null-terminated string, or binary array</p>
<p class="hangb"><strong>Term</strong> The terminating word, 0xABDC, signifying the end of the entry</p>
<p class="indent">The tag-value-term scheme provides a convenient way for malware to serialize plug-in-specific data into a network request to the C&amp;C server.</p>
<p class="indent">The data is obfuscated with a simple encryption algorithm before being sent over the network. The Python implementation of the encryption algorithm is shown in <a href="ch02.xhtml#ch02list05">Listing 2-5</a>.</p>
<p class="programs">key = (0x17, 0xFB, 0x71,0x5C) <span class="ent">➊</span><br/>
def decr_data(data):<br/>
  for ix in xrange(len(data)):<br/>
    data[ix] ^= key[ix % 4]</p>
<p class="listing" id="ch02list05"><em>Listing 2-5: Python implementation of the network encryption algorithm</em></p>
<p class="indent">The malware uses a rolling XOR algorithm with a fixed 4-byte key <span class="ent">➊</span>.</p>
<h3 class="h3" id="ch02lev1sec4"><strong>Bypassing Security and Forensics Software</strong></h3>
<p class="noindent">In order to communicate over the network with C&amp;C servers, send spam, and perform DDoS attacks while eluding security software, Festi relies on a TCP/IP stack implemented in kernel mode in Windows.</p>
<p class="indent">To send and receive packets, the malware opens a handle to the <em>\Device\Tcp</em> or <em>\Device\Udp</em> devices depending on the protocol type being used, employing a rather interesting technique to acquire the handle without drawing the attention of security software. In designing this technique, Festi’s authors again demonstrated a superb understanding of Windows system internals.</p>
<p class="indent">In order to control access to the network on the host, some security software monitors access to these devices by intercepting <span class="literal">IRP_MJ_CREATE</span> requests, which are sent to the transport driver when someone tries to open a handle to communicate with the device object. This allows the security software <span epub:type="pagebreak" id="page_28"/>to determine which process is trying to communicate over the network. Generally speaking, the most common ways for security software to monitor access to the device objects are:</p>
<ul>
<li class="noindent">Hooking the <span class="literal">ZwCreateFile</span> system service handler to intercept all attempts to open the devices</li>
<li class="noindent">Attaching to <em>\Device\Tcp</em> or <em>\Device\Udp</em> in order to intercept all IRP requests sent</li>
</ul>
<p class="indent">Festi cleverly bypasses both techniques to establish a connection with a remote host over the network.</p>
<p class="indent">First, instead of using the system implementation of the <span class="literal">ZwCreateFile</span> system service, Festi implements its own system service with almost the same functionality as the original one. <a href="ch02.xhtml#ch02fig10">Figure 2-10</a> shows the custom implementation of the <span class="literal">ZwCreateFile</span> routine.</p>
<div class="image"><a id="ch02fig10"/><img src="../images/02fig10.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-10: Custom implementation of <span class="literal">ZwCreateFile</span> routine</em></p>
<p class="indent">You can see that Festi manually creates a file object to communicate with the device being opened and sends an <span class="literal">IRP_MJ_CREATE</span> request directly to the transport driver. Thus, all the devices attached to <em>\Device\Tcp</em> or <em>\Device\Udp</em> will miss the request, and the operation goes unnoticed by security software, as illustrated in <a href="ch02.xhtml#ch02fig11">Figure 2-11</a>.</p>
<p class="indent">On the left side of the figure, you can see how an IRP is normally processed. The IRP packet goes through the complete driver stack, and all the drivers hooked within it—including the security software—receive the IRP packet and inspect its contents. The right side of the figure shows how Festi instead sends the IRP packet directly to the target driver, bypassing all the intermediate ones.</p>
<div class="image"><span epub:type="pagebreak" id="page_29"/><a id="ch02fig11"/><img src="../images/02fig11.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-11: Bypassing network monitoring security software</em></p>
<p class="indent">Festi sidesteps the second security software technique just as deftly. To send a request directly to <em>\Device\Tcp</em> or <em>\Device\Udp</em>, the malware requires pointers to the corresponding device objects. The fragment of code responsible for this maneuver is presented in <a href="ch02.xhtml#ch02list06">Listing 2-6</a>.</p>
<p class="programs">
   RtlInitUnicodeString(&amp;DriverName, L"\\Driver\\Tcpip");<br/>
   RtlInitUnicodeString(&amp;tcp_name, L"\\Device\\Tcp");<br/>
   RtlInitUnicodeString(&amp;udp_name, L"\\Device\\Udp");<br/>
<br/>
<span class="ent">➊</span> if (!ObReferenceObjectByName(&amp;DriverName,64,0,0x1F01FF,<br/>
                                IoDriverObjectType,0,0,&amp;TcpipDriver))<br/>
   {<br/>
     DevObj = TcpipDriver-&gt;DeviceObject;<br/>
  <span class="ent">➋</span> while ( DevObj )                          // iterate through DEVICE_OBJECT<br/>
     {                                         // linked list<br/>
       if ( !ObQueryNameString(DevObj, &amp;Objname, 256, &amp;v8) )<br/>
       {<br/>
<br/>
      <span class="ent">➌</span> if ( RtlCompareUnicodeString(&amp;tcp_name, &amp;Objname, 1u) )<br/>
         {<br/>
<br/>
       <span class="ent">➍</span>  if ( !RtlCompareUnicodeString(&amp;udp_name, &amp;Objname, 1u) )<br/>
           {<br/>
             ObfReferenceObject(DevObj);<br/>
             this-&gt;DeviceUdp = DevObj;        // Save pointer to \Device\Udp<br/>
           }<br/>
         } else<br/>
         {<br/>
           ObfReferenceObject(DevObj);<br/>
           this-&gt;DeviceTcp = DevObj;          // Save pointer to \Device\Tcp<br/>
         }<br/>
       }<br/>
       DevObj = DevObj-&gt;NextDevice;       // get pointer to next DEVICE_OBJECT<br/>
                                          // in the list<br/>
     }<br/>
<span epub:type="pagebreak" id="page_30"/>     ObfDereferenceObject(TcpipDriver);<br/>
   }</p>
<p class="listing" id="ch02list06"><em>Listing 2-6: Implementing the network monitoring security software bypassing technique</em></p>
<p class="indent">Festi obtains a pointer to the <em>tcpip.sys</em> driver object by executing the <span class="literal">ObReferenceObjectByName</span> routine <span class="ent">➊</span>, an undocumented system routine, and passing as a parameter a pointer to a Unicode string with the target driver’s name. Then the malware iterates through the list of device objects <span class="ent">➋</span> corresponding to the driver object and compares its names with <em>\Device\Tcp</em> <span class="ent">➌</span> and <em>\Device\Udp</em> <span class="ent">➍</span>.</p>
<p class="indent">When the malware obtains a handle for the opened device in this way, it uses the handle to send and receive data over the network. Though Festi is able to avoid security software, it’s possible to see packets it sends by using network traffic filters operating at a lower level (for instance, at the Network Driver Interface Specification, or NDIS, level) than Festi.</p>
<h3 class="h3" id="ch02lev1sec5"><strong>The Domain Generation Algorithm for C&amp;C Failure</strong></h3>
<p class="noindent">Another of Festi’s remarkable features is its implementation of a domain name generation algorithm (DGA), used as a fallback mechanism when the C&amp;C servers’ domain names in the bot’s configuration data are unreachable. This can happen, for instance, if a law enforcement agency takes down the domain names of Festi C&amp;C servers and the malware is unable to download plug-ins and commands. The algorithm takes the current date as input and outputs a domain name.</p>
<p class="indent"><a href="ch02.xhtml#ch02tab02">Table 2-2</a> lists the DGA-based domain names for a Festi sample. As you can see, all the generated domain names are pseudorandom, which is a characteristic of DGA-generated domain names.</p>
<p class="tabcap" id="ch02tab02"><strong>Table 2-2:</strong> List of DGA Domain Names Generated by Festi</p>
<table class="topbot-d">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Date</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>DGA domain name</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">07/11/2012</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>fzcbihskf.com</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">08/11/2012</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>pzcaihszf.com</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">09/11/2012</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>dzcxifsff.com</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">10/11/2012</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><em>azcgnfsmf.com</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba">11/11/2012</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba"><em>bzcfnfsif.com</em></p></td>
</tr>
</tbody>
</table>
<p class="indent">Implementing DGA functionality makes the botnet resilient to takedown attempts. Even if law enforcement managed to disable the primary C&amp;C server domains, the botnet master could still regain control of the botnet by falling back on DGA.</p>
<h3 class="h3" id="ch02lev1sec6"><span epub:type="pagebreak" id="page_31"/><strong>Malicious Functionality</strong></h3>
<p class="noindent">Now that we’ve covered the rootkit functionality, let’s look at the malicious plug-ins downloaded from the C&amp;C servers. In the course of our investigation, we obtained a sample of these plug-ins and have identified three types:</p>
<ul>
<li class="noindent"><em>BotSpam.sys</em> for sending spam emails</li>
<li class="noindent"><em>BotDos.sys</em> for performing DDoS attacks</li>
<li class="noindent"><em>BotSocks.sys</em> to provide proxy services</li>
</ul>
<p class="indent">We found that different C&amp;C servers tend to provide different types of plug-ins: some C&amp;C servers provide only bots with spam plug-ins while others deal only in DDoS plug-ins, indicating that the malicious functionality of the malware depends on the C&amp;C servers it reports to. The Festi botnet is not a monolith but rather comprises subbotnets dedicated to different targets.</p>
<h4 class="h4" id="ch02lev2sec11"><strong><em>The Spam Module</em></strong></h4>
<p class="noindent">The <em>BotSpam.sys</em> plug-in is responsible for sending junk emails. The C&amp;C server sends it a spam template and a list of recipient email addresses. <a href="ch02.xhtml#ch02fig12">Figure 2-12</a> illustrates the workflow for the spam plug-ins.</p>
<div class="image"><a id="ch02fig12"/><img src="../images/02fig12.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 2-12: Workflow diagram of Festi spam plug-in</em></p>
<p class="indent">First, the plug-in initiates an encrypted connection with its C&amp;C server to download a list of email addresses with sender parameters and the actual spam templates. It then distributes the spam letters to the recipients. Meanwhile, the malware reports the status to the C&amp;C server and requests updates for the email list and spam templates.</p>
<p class="indent">The plug-in then checks the status of sent emails by scanning responses from an SMTP server for specific strings that signify problems—for instance, if there is no recipient with the specified address, an email wasn’t received, or an email was classified as junk. If any of these strings is found in the <span epub:type="pagebreak" id="page_32"/>responses from the SMTP server, the plug-in gracefully terminates its session with the SMTP server and fetches the next address in the list. This precautionary step helps the malware to avoid an SMTP server blacklisting the infected machine’s IP address as a spam sender and preventing the malware from sending any more spam.</p>
<h4 class="h4" id="ch02lev2sec12"><strong><em>The DDoS Engine</em></strong></h4>
<p class="noindent">The <em>BotDos.sys</em> plug-in allows the bot to perform DDoS attacks against specified hosts. The plug-in supports several types of DDoS attacks against remote hosts, covering a variety of architectures and hosts with different software installed. The types of attacks depend on the configuration data received from the C&amp;C and include TCP flood, UDP flood, DNS flood, and HTTP flood attacks.</p>
<h5 class="h5" id="ch02lev3sec3"><strong>TCP Flood</strong></h5>
<p class="noindent">In the case of TCP flooding, the bot initiates a large number of connections to a port on the target machine. Every time Festi connects to a target port on a server, the server allocates resources to handle the incoming connection. Soon the server runs out of resources and stops responding to clients.</p>
<p class="indent">The default port is the HTTP port, port 80, but this can be changed with corresponding configuration information from the C&amp;C server, allowing the malware to attack HTTP servers that listen on ports other than 80.</p>
<h5 class="h5" id="ch02lev3sec4"><strong>UDP Flood</strong></h5>
<p class="noindent">In a UDP flood, the bot sends UDP packets of randomly generated lengths, filled with random data. The length of a packet can be anywhere from 256 to 1,024 bytes. The target port is also randomly generated and is therefore unlikely to be open. As a result, the attack causes the target host to generate an enormous number of ICMP Destination Unreachable packets in reply, and the target machine becomes unavailable.</p>
<h5 class="h5" id="ch02lev3sec5"><strong>DNS Flood</strong></h5>
<p class="noindent">The bot is also able to perform DNS flood attacks by sending high volumes of UDP packets to port 53 (DNS service) on the target host. The packets contain requests to resolve a randomly generated domain name in the <em>.com</em> domain zone.</p>
<h5 class="h5" id="ch02lev3sec6"><strong>HTTP Flood</strong></h5>
<p class="noindent">In HTTP flood attacks against web servers, the bot’s binary contains many different user-agent strings, which are used to create a large number of HTTP sessions with the web server, overloading the remote host. <a href="ch02.xhtml#ch02list07">Listing 2-7</a> contains the code for assembling the HTTP request that’s sent.</p>
<p class="programs"><span epub:type="pagebreak" id="page_33"/>int __thiscall BuildHttpHeader(_BYTE *this, int a2)<br/>
{<br/>
<br/>
<span class="ent">➊</span> user_agent_idx = get_rnd() % 0x64u;<br/>
  str_cpy(http_header, "GET ");<br/>
  str_cat(http_header, &amp;v4[204 * *(_DWORD *)(v2 + 4) + 2796]);<br/>
  str_cat(http_header, " HTTP/1.0\r\n");<br/>
  if ( v4[2724] &amp; 2 )<br/>
  {<br/>
    str_cat(http_header, "Accept: */*\r\n");<br/>
    str_cat(http_header, "Accept-Language: en-US\r\n");<br/>
    str_cat(http_header, "User-Agent: ");<br/>
<br/>
  <span class="ent">➋</span> str_cat(http_header, user_agent_strings[user_agent_idx]);<br/>
    str_cat(http_header, "\r\n");<br/>
  }<br/>
  str_cat(http_header, "Host: ");<br/>
  str_cat(http_header, &amp;v4[204 * *(_DWORD *)(v2 + 4) + 2732]);<br/>
  str_cat(http_header, "\r\n");<br/>
  if ( v4[2724] &amp; 2 )<br/>
    str_cat(http_header, "Connection: Keep-Alive\r\n");<br/>
  str_cat(http_header, "\r\n");<br/>
  result = str_len(http_header);<br/>
  *(_DWORD *)(v2 + 16) = result;<br/>
  return result;<br/>
}</p>
<p class="listing" id="ch02list07"><em>Listing 2-7: Fragment of Festi DDoS plug-in assembling an HTTP request</em></p>
<p class="indent">At <span class="ent">➊</span> the code generates a value that’s then used at <span class="ent">➋</span> as an index in the array of user-agent strings.</p>
<h4 class="h4" id="ch02lev2sec13"><strong><em>Festi Proxy Plug-in</em></strong></h4>
<p class="noindent">The <em>BotSocks.sys</em> plug-in provides remote proxy service to the attacker by implementing the SOCKS server over the TCP and UDP protocols. The SOCKS server establishes a network connection to another target server on behalf of a client, then routes all the traffic back and forth between the client and the target server.</p>
<p class="indent">As a result a Festi-infected machine becomes a proxy server that allows attackers to connect to remote servers through the infected machine. Cybercriminals may use such a service for anonymization—that is, to conceal the attacker’s IP address. Since the connection happens via the infected host, the remote server can see the victim’s IP address but not that of the attacker.</p>
<p class="indent">Festi’s <em>BotSocks.sys</em> plug-in doesn’t use any reverse-connect proxy mechanisms to bypass NAT (Network Address Translation), which enables multiple computers in the network to share a single externally visible IP address. Once the malware has loaded the plug-in, it opens a network port and starts listening for incoming connections. The port number is chosen at random in a range from 4000 to 65536. The plug-in sends the port number it’s listening on to the C&amp;C server so that an attacker could establish a network <span epub:type="pagebreak" id="page_34"/>connection with the victim computer. The NAT would normally prevent such incoming connections (unless port forwarding is configured for the target port).</p>
<p class="indent">The <em>BotSocks.sys</em> plug-in also attempts to bypass the Windows firewall, which may otherwise prevent the port from being opened. The plug-in modifies the registry key <em>SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile\GloballyOpenPorts\List</em>, which contains a list of ports that may be opened in the Windows firewall profile. The malware adds two subkeys in this registry key to enable incoming TCP and UDP connections from any destination accordingly.</p>
<div class="sidebar">
<p class="sidebart"><strong>SOCKS</strong></p>
<p class="spara"><em>Socket Secure (SOCKS)</em> is an internet protocol that exchanges network packets between a client and server through a proxy server. A SOCKS server proxies TCP connections from a SOCKS client to an arbitrary IP address and provides a means for UDP packets to be forwarded. The SOCKS protocol is often used by cybercriminals as a circumvention tool that allows traffic to bypass internet filtering to access content that’s otherwise blocked.</p>
</div>
<h3 class="h3" id="ch02lev1sec7"><strong>Conclusion</strong></h3>
<p class="noindent">You should now have a complete picture of what the Festi rootkit is and what it can do. Festi is an interesting piece of malware with well-designed architecture and carefully crafted functionality. Every technical aspect of the malware accords with its design principles: be stealthy and be resilient to automated analysis, monitoring systems, and forensic analysis.</p>
<p class="indent">The volatile malicious plug-ins downloaded from C&amp;C servers don’t leave any trace on the hard drive of the infected machine. Using encryption to protect the network communication protocol that connects it with C&amp;C servers makes it hard to detect Festi in the network traffic, and advanced usage of kernel-mode network sockets allows Festi to bypass certain Host Intrusion Prevention Systems (HIPS) and personal firewalls.</p>
<p class="indent">The bot eludes security software by implementing rootkit functionality that hides its main module and the corresponding registry key in the system. These methods were effective against security software at the height of Festi’s popularity, but they also constitute one of its major flaws: it targets 32-bit systems only. The 64-bit editions of the Windows operating systems implement modern security features, such as PatchGuard, that render Festi’s intrusive arsenal ineffective. The 64-bit versions also require kernel-mode drivers to have a valid digital signature, which is obviously not an easy option for malicious software. As mentioned in <a href="ch01.xhtml#ch01">Chapter 1</a>, the solution malware developers came up with to circumvent this limitation was to implement bootkit technology, which we’ll cover in detail in <a href="part02.xhtml#part02">Part 2</a>.</p>
</body></html>