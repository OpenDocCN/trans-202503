["```\n11111111111111111111111111111111\n```", "```\nint main(void) {\n    int x = 0;\n    int *ptr = &x;\n    *ptr = 4;\n    return *ptr;\n}\n```", "```\nint *null = 0;\n```", "```\nint x = 0;\nint *ptr = x;\n```", "```\nint *ptr1 = 3;\nint *ptr2 = 0x7ffeee67b938;\n```", "```\ndouble *d = 0;\nlong *l = d;\n```", "```\ndouble negative_zero = -0.0;\ndouble *d = &negative_zero;\n❶ unsigned long *l = (unsigned long *) d;\n```", "```\nint *ptr = &var;\nint *ptr2 = &*ptr;\n```", "```\nint *null_ptr = 0;\nint *ptr2 = &*null_ptr;\n```", "```\nint *null_ptr = 0;\nint *ptr2 = null_ptr;\n```", "```\ntype = Int | Long | UInt | ULong | Double\n     | FunType(type* params, type ret)\n     **| Pointer(type referenced)**\n```", "```\nexp = `--snip--`\n    | Dereference(exp)\n    | AddrOf(exp)\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, exp? init, type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\ntype = Int | Long | UInt | ULong | Double\n     | FunType(type* params, type ret)\n     **| Pointer(type referenced)**\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\n    **| Dereference(exp)**\n    **| AddrOf(exp)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int)\n      | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double)\n```", "```\n<unop> ::= \"-\" | \"~\" | \"!\" **| \"*\" | \"&\"**\n```", "```\nint var;\n```", "```\nint *(var);\n```", "```\nint *var;\n```", "```\nint *(*(var));\n```", "```\nint foo(void);\n```", "```\nint ((foo)(void));\n```", "```\nint foo(int a, int *b);\n```", "```\nint arr[3];\n```", "```\nint *arr[3];\n```", "```\nint *(arr[3]);\n```", "```\nint (*arr)[3];\n```", "```\nint (*fptr)(int a);\n```", "```\n<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"\n```", "```\n<direct-declarator> ::= <simple-declarator> [<param-list>]\n<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"\n<param> ::= {<type-specifier>}+ <declarator>\n```", "```\n<declarator> ::= \"*\" <declarator> | <direct-declarator>\n```", "```\nint (*arr)[3];\n```", "```\ndeclarator = Ident(identifier)\n           | PointerDeclarator(declarator)\n           | FunDeclarator(param_info* params, declarator)\nparam_info = Param(type, declarator)\n```", "```\nprocess_declarator(declarator, base_type):\n    match declarator with\n    | Ident(name) -> return (name, base_type, []) ❶\n    | PointerDeclarator(d) -> ❷\n        derived_type = Pointer(base_type)\n        return process_declarator(d, derived_type)\n | FunDeclarator(params, d) -> ❸\n        match d with\n        | Ident(name) -> ❹\n            param_names = []\n            param_types = []\n            for Param(p_base_type, p_declarator) in params: ❺\n                param_name, param_t, _ = process_declarator(p_declarator, p_base_type)\n                if param_t is a function type:\n                    fail(\"Function pointers in parameters aren't supported\")\n                param_names.append(param_name)\n                param_types.append(param_t)\n\n            derived_type = FunType(param_types, base_type)\n            return (name, derived_type, param_names)\n        | _ -> fail(\"Can't apply additional type derivations to a function type\")\n```", "```\nparse_declaration(tokens):\n    specifiers = parse_specifier_list(tokens)\n    base_type, storage_class = parse_type_and_storage_class(specifiers)\n    declarator = parse_declarator(tokens)\n    name, decl_type, params = process_declarator(declarator, base_type)\n    if decl_type is a function type:\n `<construct function_declaration>`\n    else:\n `<construct variable_declaration>`\n```", "```\nint *result_of_cast = (int *) exp;\n```", "```\n(int ***) exp;\n```", "```\n(int (*)) exp;\n```", "```\n(int *(*)) exp;\n```", "```\n(int *[3]) exp;\n```", "```\n(int (*)[3]) exp;\n```", "```\n<abstract-declarator> ::= \"*\" [<abstract-declarator>]\n                        | <direct-abstract-declarator>\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\"\n```", "```\nabstract_declarator = AbstractPointer(abstract_declarator)\n                    | AbstractBase\n```", "```\n<factor> ::= `--snip--`\n           | \"(\" {<type-specifier>}+ **[<abstract-declarator>]** \")\" <factor>\n           | `--snip--`\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ **<declarator>** [\"=\" <exp>] \";\"\n<function-declaration> ::= {<specifier>}+ **<declarator>** (<block> | \";\")\n**<declarator> ::= \"*\" <declarator> | <direct-declarator>**\n**<direct-declarator> ::= <simple-declarator> [<param-list>]**\n**<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"**\n**<param> ::= {<type-specifier>}+ <declarator>**\n**<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"**\n<type-specifier> ::= \"int\" | \"long\" | \"unsigned\" | \"signed\" | \"double\"\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= <const> | <identifier>\n           | \"(\" {<type-specifier>}+ **[<abstract-declarator>]** \")\" <factor>\n           | <unop> <factor> | \"(\" <exp> \")\"\n           | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n**<abstract-declarator> ::= \"*\" [<abstract-declarator>]**\n **| <direct-abstract-declarator>**\n**<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\"**\n<unop> ::= \"-\" | \"~\" | \"!\" **| \"*\" | \"&\"**\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | <uint> | <ulong> | <double>\n<identifier> ::= ? An identifier token ?\n<int> ::= ? An int token ?\n<long> ::= ? An int or long token ?\n<uint> ::= ? An unsigned int token ?\n<ulong> ::= ? An unsigned int or unsigned long token ?\n<double> ::= ? A floating-point constant token ?\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Dereference(inner) ->\n        typed_inner = typecheck_exp(inner, symbols)\n        match get_type(typed_inner) with\n        | Pointer(referenced_t) ->\n            deref_exp = Dereference(typed_inner)\n            return set_type(deref_exp, referenced_t)\n        | _ -> fail(\"Cannot dereference non-pointer\")\n```", "```\n | AddrOf(inner) ->\n        if inner is an lvalue:\n            typed_inner = typecheck_exp(inner, symbols)\n            referenced_t = get_type(typed_inner)\n            addr_exp = AddrOf(typed_inner)\n            return set_type(addr_exp, Pointer(referenced_t))\n        else:\n            fail(\"Can't take the address of a non-lvalue!\")\n```", "```\ndouble *d = get_pointer();\nreturn d == 0;\n```", "```\nis_null_pointer_constant(e):\n    match e with\n    | Constant(c) ->\n        match c with\n        | ConstInt(0) -> return True\n        | ConstUInt(0) -> return True\n        | ConstLong(0) -> return True\n        | ConstULong(0) -> return True\n        | _ -> return False\n    | _ -> return False\n```", "```\nget_common_pointer_type(e1, e2):\n    e1_t = get_type(e1)\n    e2_t = get_type(e2)\n    if e1_t == e2_t:\n        return e1_t\n else if is_null_pointer_constant(e1):\n        return e2_t\n    else if is_null_pointer_constant(e2):\n        return e1_t\n    else:\n        fail(\"Expressions have incompatible types\")\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Binary(Equal, e1, e2) ->\n        typed_e1 = typecheck_exp(e1, symbols)\n        typed_e2 = typecheck_exp(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 or t2 is a pointer type:\n          ❶ common_type = get_common_pointer_type(typed_e1, typed_e2)\n        else:\n          ❷ common_type = get_common_type(t1, t2)\n        converted_e1 = convert_to(typed_e1, common_type)\n        converted_e2 = convert_to(typed_e2, common_type)\n        equality_exp = Binary(Equal, converted_e1, converted_e2)\n        return set_type(equality_exp, Int)\n```", "```\nconvert_by_assignment(e, target_type):\n    if get_type(e) == target_type:\n        return e\n    if get_type(e) is arithmetic and target_type is arithmetic:\n        return convert_to(e, target_type)\n    if is_null_pointer_constant(e) and target_type is a pointer type:\n        return convert_to(e, target_type)\n    else:\n        fail(\"Cannot convert type for assignment\")\n```", "```\nint *d = 2.0;\n```", "```\nint *bad_pointer(void) {\n    return 2.0;\n}\n```", "```\nstatic int *ptr = 0;\n```", "```\nstatic int a;\nstatic int *a_ptr = &a;\n```", "```\nGetAddress(val src, val dst)\n```", "```\nLoad(val src_ptr, val dst)\nStore(val src, val dst_ptr)\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, static_init init)\ninstruction = Return(val)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            | ZeroExtend(val src, val dst)\n | DoubleToInt(val src, val dst)\n            | DoubleToUInt(val src, val dst)\n            | IntToDouble(val src, val dst)\n            | UIntToDouble(val src, val dst)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            **| GetAddress(val src, val dst)**\n            **| Load(val src_ptr, val dst)**\n            **| Store(val src, val dst_ptr)**\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\n`<instructions for exp>`\nptr = `<result of exp>`\nresult = Load(ptr)\n```", "```\n`<instructions for left>`\nptr = `<result of left>`\n`<instructions for right>`\nresult = `<result of right>`\nStore(result, ptr)\n```", "```\nresult = GetAddress(var)\n```", "```\nexp_result = PlainOperand(val) | DereferencedPointer(val)\n```", "```\nemit_tacky(e, instructions, symbols):\n    match e with\n  | `--snip--`\n    | Unary(op, inner) ->\n        src = **emit_tacky_and_convert**(inner, instructions, symbols)\n        dst = make_tacky_variable(get_type(e), symbols)\n        tacky_op = convert_unop(op)\n        instructions.append(Unary(tacky_op, src, dst))\n        return **PlainOperand**(dst)\n```", "```\n | Dereference(inner) ->\n        result = emit_tacky_and_convert(inner, instructions, symbols)\n        return DereferencedPointer(result)\n```", "```\n | Assignment(left, right) ->\n      ❶ lval = emit_tacky(left, instructions, symbols)\n      ❷ rval = emit_tacky_and_convert(right, instructions, symbols)\n        match lval with\n        | PlainOperand(obj) ->\n          ❸ instructions.append(Copy(rval, obj))\n            return lval\n        | DereferencedPointer(ptr) ->\n          ❹ instructions.append(Store(rval, ptr))\n            return PlainOperand(rval)\n```", "```\n | AddrOf(inner) ->\n      ❶ v = emit_tacky(inner, instructions, symbols)\n        match v with\n        | PlainOperand(obj) ->\n            dst = make_tacky_variable(get_type(e), symbols)\n          ❷ instructions.append(GetAddress(obj, dst))\n            return PlainOperand(dst)\n        | DereferencedPointer(ptr) ->\n          ❸ return PlainOperand(ptr)\n```", "```\nemit_tacky_and_convert(e, instructions, symbols):\n    result = emit_tacky(e, instructions, symbols)\n    match result with\n    | PlainOperand(val) -> return val\n    | DereferencedPointer(ptr) ->\n        dst = make_tacky_variable(get_type(e), symbols)\n        instructions.append(Load(ptr, dst))\n        return dst\n```", "```\nmovq    (%rax), %rcx\n```", "```\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | **BP** | `--snip--`\n```", "```\n operand = Imm(int) | Reg(reg) | Pseudo(identifier) | **Memory(reg, int)** | Data(identifier)\n```", "```\nLoad(ptr, dst)\n```", "```\nMov(Quadword, ptr, Reg(AX))\nMov(`<dst type>`, Memory(AX, 0), dst)\n```", "```\nStore(src, ptr)\n```", "```\nMov(Quadword, ptr, Reg(AX))\nMov(`<src type>`, src, Memory(AX, 0))\n```", "```\nlea    x(%rip), %rax\n```", "```\nGetAddress(src, dst)\n```", "```\nLea(src, dst)\n```", "```\nprogram = Program(top_level*)\nassembly_type = Longword | Quadword | Double\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, static_init init)\n          | StaticConstant(identifier name, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(operand src, operand dst)\n            | MovZeroExtend(operand src, operand dst)\n            **| Lea(operand src, operand dst)**\n            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)\n            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            | Div(assembly_type, operand)\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\n\nunary_operator = Neg | Not | Shr\nbinary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | **Memory(reg, int)** | Data(identifier)\ncond_code = E | NE | G | GE | L | LE | A | AE | B | BE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | **BP**\n    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name, global, params,\n          instructions)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name, global,</samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">       </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">[Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first int param type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(DI),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first int param>)</samp>,\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second int param type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(SI),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second int param>),\n           <copy next four integer parameters from registers>,</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(Double, Reg(XMM0),</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first double param></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),\n          Mov(Double, Reg(XMM1),</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second double param></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next six double parameters from registers>,</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first stack param type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp>\n <samp class=\"SANS_Futura_Std_Heavy_B_11\">Memory(BP, 16)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">               <first stack param>)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,          Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second stack param type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp>\n <samp class=\"SANS_Futura_Std_Heavy_B_11\">Memory(BP, 24),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second stack param></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy remaining parameters from stack></samp><samp class=\"SANS_Futura_Std_Book_11\">]</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">+\n         instructions)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><dst type></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, 0), dst)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src type></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, src, Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, 0))</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Lea(src, dst)</samp>\n```", "```\npushq   %xmm0\n```", "```\nsubq    $8, %rsp\nmovsd   %xmm0, (%rsp)\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">leaq</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst></samp>\n```"]