["```\n//Header holds the first UINT64 (Magic Bytes)\ntype Header struct {\n    Header uint64\n}\n```", "```\n//Chunk represents a data byte chunk segment\ntype Chunk struct {\n    Size uint32\n    Type uint32\n    Data []byte\n    CRC  uint32\n}\n```", "```\n//PreProcessImage reads to buffer from file handle\nfunc PreProcessImage(dat *os.File) (*bytes.Reader, error) {\n ❶ stats, err := dat.Stat()\n    if err != nil {\n        return nil, err\n    }\n\n ❷ var size = stats.Size()\n    b := make([]byte, size)\n\n ❸ bufR := bufio.NewReader(dat)\n    _, err = bufR.Read(b)\n    bReader := bytes.NewReader(b)\n\n    return bReader, err\n}\n```", "```\nfunc (mc *MetaChunk) validate(b *bytes.Reader) {\n    var header Header\n\n    if err := binary.Read(b, binary.BigEndian, &header.Header)❶; err != nil {\n        log.Fatal(err)\n    }\n\n    bArr := make([]byte, 8)\n    binary.BigEndian.PutUint64(bArr, header.Header)❷\n\n    if string(bArr[1:4])❸ != \"PNG\" {\n        log.Fatal(\"Provided file is not a valid PNG format\")\n } else {\n        fmt.Println(\"Valid PNG so let us continue!\")\n    }\n}\n```", "```\nfunc (mc *MetaChunk) ProcessImage(b *bytes.Reader, c *models.CmdLineOpts)❶ {\n// Snip code for brevity (Only displaying relevant lines from code block)\n      count := 1 //Start at 1 because 0 is reserved for magic byte\n    ❷ chunkType := \"\"\n    ❸ endChunkType := \"IEND\" //The last TYPE prior to EOF\n    ❹ for chunkType != endChunkType {\n          fmt.Println(\"---- Chunk # \" + strconv.Itoa(count) + \" ----\")\n          offset := chk.getOffset(b)\n          fmt.Printf(\"Chunk Offset: %#02x\\n\", offset)\n          chk.readChunk(b)\n chunkType = chk.chunkTypeToString()\n          count++\n      }\n}\n```", "```\nfunc (mc *MetaChunk) getOffset(b *bytes.Reader) {\n    offset, _ := b.Seek(0, 1)❶\n    mc.Offset = offset\n}\n```", "```\nfunc (mc *MetaChunk) readChunk(b *bytes.Reader) {\n    mc.readChunkSize(b)\n    mc.readChunkType(b)\n    mc.readChunkBytes(b, mc.Chk.Size) ❶\n    mc.readChunkCRC(b)\n}\nfunc (mc *MetaChunk) readChunkSize(b *bytes.Reader) {\n    if err := binary.Read(b, binary.BigEndian, &mc.Chk.Size); err != nil { ❷\n        log.Fatal(err)\n    }\n}\nfunc (mc *MetaChunk) readChunkType(b *bytes.Reader) {\n    if err := binary.Read(b, binary.BigEndian, &mc.Chk.Type); err != nil {\n        log.Fatal(err)\n    }\n}\nfunc (mc *MetaChunk) readChunkBytes(b *bytes.Reader, cLen uint32) {\n    mc.Chk.Data = make([]byte, cLen) ❸\n    if err := binary.Read(b, binary.BigEndian, &mc.Chk.Data); err != nil {\n        log.Fatal(err)\n    }\n}\nfunc (mc *MetaChunk) readChunkCRC(b *bytes.Reader) {\n    if err := binary.Read(b, binary.BigEndian, &mc.Chk.CRC); err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```\nfunc (mc *MetaChunk) ProcessImage(b *bytes.Reader, c *models.CmdLineOpts) ❶ {\n    --snip--\n  ❷ var m MetaChunk\n  ❸ m.Chk.Data = []byte(c.Payload)\n    m.Chk.Type = m.strToInt(c.Type)❹\n    m.Chk.Size = m.createChunkSize()❺\n    m.Chk.CRC = m.createChunkCRC()❻\n    bm := m.marshalData()❼\n    bmb := bm.Bytes()\n    fmt.Printf(\"Payload Original: % X\\n\", []byte(c.Payload))\n    fmt.Printf(\"Payload: % X\\n\", m.Chk.Data)\n  ❽ utils.WriteData(b, c, bmb)\n}\n```", "```\npackage models\n\n//CmdLineOpts represents the cli arguments\ntype CmdLineOpts struct {\n    Input    string\n    Output   string\n    Meta     bool\n    Suppress bool\n    Offset   string\n    Inject   bool\n    Payload  string\n    Type     string\n    Encode   bool\n    Decode   bool\n    Key      string\n}\n```", "```\nfunc (mc *MetaChunk) strToInt(s string)❶ uint32 {\n    t := []byte(s)\n ❷ return binary.BigEndian.Uint32(t)\n}\n```", "```\nfunc (mc *MetaChunk) createChunkSize() uint32 {\n        return uint32(len(mc.Chk.Data)❷)❶\n}\n```", "```\nfunc (mc *MetaChunk) createChunkCRC() uint32 {\n    bytesMSB := new(bytes.Buffer) ❶\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Type); err != nil { ❷\n    log.Fatal(err)\n    }\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Data); err != nil { ❸\n        log.Fatal(err)\n    }\n    return crc32.ChecksumIEEE(bytesMSB.Bytes()) ❹\n}\n```", "```\nfunc (mc *MetaChunk) marshalData() *bytes.Buffer {\n    bytesMSB := new(bytes.Buffer) ❶\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Size); err != nil { ❷\n        log.Fatal(err)\n    }\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Type); err != nil { ❸\n        log.Fatal(err)\n    }\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Data); err != nil { ❹\n        log.Fatal(err)\n    }\n    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.CRC); err != nil { ❺\n        log.Fatal(err)\n    }\n\n    return bytesMSB\n}\n```", "```\n//WriteData writes new Chunk data to offset\nfunc WriteData(r *bytes.Reader❶, c *models.CmdLineOpts❷, b []byte❸) {\n  ❹ offset, _ := strconv.ParseInt(c.Offset, 10, 64)\n  ❺ w, err := os.Create(c.Output)\n     if err != nil {\n         log.Fatal(\"Fatal: Problem writing to the output file!\")\n     }\n     defer w.Close()\n  ❻ r.Seek(0, 0)\n ❼ var buff = make([]byte, offset)\n     r.Read(buff)\n  ❽ w.Write(buff)\n  ❾ w.Write(b)\n\n  ❿ _, err = io.Copy(w, r)\n     if err == nil {\n         fmt.Printf(\"Success: %s created\\n\", c.Output)\n     }\n}\n```", "```\n$ go run main.go -i images/battlecat.png -o newPNGfile --inject -offset \\\n    0x85258 --payload 1234243525522552522452355525\n```", "```\nfunc encodeDecode(input []byte❶, key string❷) []byte {\n  ❸ var bArr = make([]byte, len(input))\n    for i := 0; i < len(input); i++ {\n     ❹ bArr[i] += input[i] ^ key[i%len(key)]\n    }\n    return bArr\n}\n```", "```\n   // XorEncode returns encoded byte array\n❶ func XorEncode(decode []byte, key string) []byte {\n    ❷ return encodeDecode(decode, key)\n   }\n\n   // XorDecode returns decoded byte array\n❶ func XorDecode(encode []byte, key string) []byte {\n    ❷ return encodeDecode(encode, key)\n   }\n```", "```\n// Encode Block\nif (c.Offset != \"\") && c.Encode {\n    var m MetaChunk\n ❶ m.Chk.Data = utils.XorEncode([]byte(c.Payload), c.Key)\n    m.Chk.Type = chk.strToInt(c.Type)\n    m.Chk.Size = chk.createChunkSize()\n    m.Chk.CRC = chk.createChunkCRC()\n    bm := chk.marshalData()\n    bmb := bm.Bytes()\n    fmt.Printf(\"Payload Original: % X\\n\", []byte(c.Payload))\n    fmt.Printf(\"Payload Encode: % X\\n\", chk.Data)\n    utils.WriteData(b, c, bmb)\n}\n```", "```\n   $ go run main.go -i images/battlecat.png --inject --offset 0x85258 --encode \\\n   --key gophers --payload 1234243525522552522452355525 --output encodePNGfile\n   Valid PNG so let us continue!\n❶ Payload Original: 31 32 33 34 32 34 33 35 32 35 35 32 32 35 35 32 35 32 32\n   34 35 32 33 35 35 35 32 35\n❷ Payload Encode: 56 5D 43 5C 57 46 40 52 5D 45 5D 57 40 46 52 5D 45 5A 57 46\n   46 55 5C 45 5D 50 40 46\n   Success: encodePNGfile created\n```", "```\n//Decode Block\nif (c.Offset != \"\") && c.Decode {\n    var m MetaChunk\n  ❶ offset, _ := strconv.ParseInt(c.Offset, 10, 64)\n  ❷ b.Seek(offset, 0)\n  ❸ m.readChunk(b)\n     origData := m.Chk.Data\n  ❹ m.Chk.Data = utils.XorDecode(m.Chk.Data, c.Key)\n     m.Chk.CRC = m.createChunkCRC()\n  ❺ bm := m.marshalData()\n     bmb := bm.Bytes()\n     fmt.Printf(\"Payload Original: % X\\n\", origData)\n     fmt.Printf(\"Payload Decode: % X\\n\", m.Chk.Data)\n  ❻ utils.WriteData(b, c, bmb)\n}\n```", "```\n   $  go run main.go -i encodePNGfile -o decodePNGfile --offset 0x85258 -decode \\\n   --key gophersValid PNG so let us continue!\n❶ Payload Original: 56 5D 43 5C 57 46 40 52 5D 45 5D 57 40 46 52 5D 45 5A 57\n   46 46 55 5C 45 5D 50 40 46\n❷ Payload Decode: 31 32 33 34 32 34 33 35 32 35 35 32 32 35 35 32 35 32 32 34\n   35 32 33 35 35 35 32 35\n   Success: decodePNGfile created\n```", "```\n//WriteData writes new data to offset\nfunc WriteData(r *bytes.Reader, c *models.CmdLineOpts, b []byte) {\n    offset, err := strconv.ParseInt(c.Offset, 10, 64)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    w, err := os.OpenFile(c.Output, os.O_RDWR|os.O_CREATE, 0777)\n    if err != nil {\n        log.Fatal(\"Fatal: Problem writing to the output file!\")\n   }\n   r.Seek(0, 0)\n\n   var buff = make([]byte, offset)\n   r.Read(buff)\n   w.Write(buff)\n   w.Write(b)\n❶ if c.Decode {\n    ❷ r.Seek(int64(len(b)), 1)\n   }\n❸ _, err = io.Copy(w, r)\n   if err == nil {\n       fmt.Printf(\"Success: %s created\\n\", c.Output)\n  }\n}\n```"]