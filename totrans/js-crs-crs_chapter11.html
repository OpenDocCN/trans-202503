<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch11" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch11">
<span class="CN"><span aria-label=" Page 189. " epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">OBJECT-ORIENTED PONG</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">In the previous chapter we built our own version of the game <i>Pong</i>. Earlier, in <span class="chapterintro_Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, you learned about classes and object-oriented programming in JavaScript. You might be wondering why we didn’t use any classes for our implementation of <i>Pong</i>. The main reason was that I wanted to keep the game code as simple as possible, without including any unnecessary concepts, to make it easier to see what the actual game is doing. As programs get larger and more complex, however, it helps to give them more structure, and one common way to do that is to use object-oriented programming.</p>
<p class="TX">To help you get a better understanding of how to design software in an object-oriented style, in this chapter we’ll walk through an object-oriented <span aria-label=" Page 190. " epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>version of <i>Pong</i>. There won’t be any changes to the logic of the game, but the structure and organization of the code will be different. For example, the code for handling the ball will all live in a class called <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span>. We’ll use this class to keep track of the ball’s position and to determine how the ball should bounce when it hits a wall or paddle. Similarly, all the code for handling the paddles will live in a class called <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span>. We’ll be able to easily share common code that applies to both balls and paddles by making the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> classes inherit from a shared superclass.</p>
<p class="TX">This chapter will explore the general structure of the object-oriented <i>Pong</i> program, but we won’t go into every single detail of the code; you should already have a pretty good idea of how it works from the last chapter. With that in mind, instead of building up the game incrementally, in this chapter we’ll step through the full code in order, section by section. Because of that, the code won’t run correctly or really <i>do</i> anything until you’ve entered it all. But before we get to the code itself, let’s first look more broadly at how to approach designing an object-oriented computer program.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-63"/><samp class="SANS_Futura_Std_Bold_B_11">Object-Oriented Design</samp></h3>
<p class="TNI1">Writing code in an object-oriented way adds structure to computer programs by organizing the code into classes representing the various aspects of the program. This structure makes it easier for other programmers (and even a later version of you) to understand how your code works. A complete treatment of object-oriented design techniques would be beyond the scope of this book, but in this section we’ll look at a few key principles at the heart of object-oriented programming.</p>
<p class="TX">An important first step in object-oriented design is modeling your domain, or the world of your program. What are the different elements in the program, what do they need to be able to do, and how do they relate to and interact with each other? In this case, the domain is the game <i>Pong</i>, and there are several visible elements in the game: the ball, the paddles, and the scores. While there are two paddles, they mostly behave in the same way, so we can create a single <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> class with two customized instances. Meanwhile, the ball is distinct enough to deserve its own class. We also have to model how these elements interact. For example, how do we model the ball colliding with a paddle? That code has to live somewhere. As you’ll see, in my design, I decided that the code should live in the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> class. In other words, the ball should “know” how to bounce off the paddles and the walls when it collides with them.</p>
<p class="TX">Another important aspect of object-oriented programming is <i>encapsulation</i>. This means hiding the inner details of a class from the rest of the program, and providing a simple interface for it to use to interact with the class. Encapsulating these details makes it easier to change them later without affecting the rest of the program. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> class doesn’t need to expose its speed or position to the rest of the program. If we decide to change how the speed is represented (for example, using <span class="SANS_TheSansMonoCd_W5Regular_11">angle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">speed</span> <span aria-label=" Page 191. " epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>instead of <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>), we shouldn’t have to change how any other part of the program works.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Technically, xSpeed and ySpeed will be accessible outside of the Ball class, but we won’t be accessing them, so we can treat them as encapsulated details. JavaScript does have a way to declare properties as</i> <span class="note_Italic">private</span><i>, meaning they can’t be accessed outside of the class, but at the time of this writing it’s a new feature and isn’t available in all browsers.</i></p>
<p class="TX">A final key aspect of object-oriented programming is <i>polymorphism</i>, the idea that if a method expects to receive objects of a certain class, then it can also receive objects that are instances of subclasses of that class. For example, in this chapter you’ll see an <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> class that has a <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method and two subclasses: <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span>. In keeping with polymorphism, any code that uses the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method should be able to receive any kind of <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> as an argument, without caring about whether we pass it a <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> or a <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span>.</p>
<p class="TX">In the end, object-oriented design is more of an art than a science, and there are a lot of different ways to do it. You should treat the design in this chapter as one possible way to approach the problem, rather than “the right way” to do things. With that in mind, let’s dive into our object-oriented <i>Pong</i> code.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-64"/><samp class="SANS_Futura_Std_Bold_B_11">The File Structure</samp></h3>
<p class="TNI1">The HTML for the object-oriented version of <i>Pong</i> is exactly the same as in the previous chapter, but the JavaScript is completely different. If you want, you can make a copy of the <i>tennjs</i> directory, remove the <i>script.js</i> file, and create a new <i>script.js</i> file with the code shown in the following sections. Alternatively, you can just delete all the code in the <i>script.js</i> file in your existing <i>tennjs</i> directory and replace it with the new object-oriented code. Either way, the updated <i>script.js</i> file will consist of a series of class declarations, followed by some extra code to set the game in motion. We’ll look at each section of the code in sequence.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="h1-65"/><samp class="SANS_Futura_Std_Bold_B_11">The GameView Class</samp></h3>
<p class="TNI1">The first class we’ll declare is called <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span>. This class is responsible for the player’s view of the game, or how the game is displayed. Because the game uses a canvas for rendering, the <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> class is responsible for the canvas and drawing context. This class is also responsible for drawing things to the canvas, such as the ball and paddles, and for displaying the “GAME OVER” text. See <a href="#Lis11-1">Listing 11-1</a> for the code.</p>
<span id="Lis11-1"/>
<pre><code>class GameView {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> constructor() {
    let canvas = document.querySelector("#canvas");
    this.ctx = canvas.getContext("2d");
<span aria-label=" Page 192. " epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>    this.width = canvas.width;
    this.height = canvas.height;
    this.offsetTop = canvas.offsetTop;
  }

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> draw(…entities) {
    // Fill the canvas with black
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.width, this.height);

  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> entities.forEach(entity =&gt; entity.draw(this.ctx));
    }

<span aria-label="annotation4" class="CodeAnnotationCode">❹</span> drawScores(scores) {
    this.ctx.fillStyle = "white";
    this.ctx.font = "30px monospace";
    this.ctx.textAlign = "left";
    this.ctx.fillText(scores.leftScore.toString(), 50, 50);
    this.ctx.textAlign = "right";
    this.ctx.fillText(scores.rightScore.toString(), this.width - 50, 50);
  }

<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> drawGameOver() {
    this.ctx.fillStyle = "white";
    this.ctx.font = "30px monospace";
    this.ctx.textAlign = "center";
    this.ctx.fillText("GAME OVER", this.width / 2, this.height / 2);
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: The GameView class</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> constructor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> gets a reference to the canvas and its drawing context and saves these as properties called <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ctx</span>, respectively. It also stores some values that will be used for drawing: the width and height of the canvas, and the offset of the canvas from the top of the browser viewport.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> uses rest parameters, introduced in <a href="chapter5.xhtml">Chapter 5</a>. This way, you can pass multiple arguments to <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span>, and all the arguments will be collected into a single array called <span class="SANS_TheSansMonoCd_W5Regular_11">entities</span>. Each argument will be an object representing one of the elements in the game: the ball and the two paddles. The method first draws a black rectangle to clear the canvas and then goes through the array of elements, calling each element’s own <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method in turn <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and passing the drawing context as an argument. This will work only if every object passed to <span class="SANS_TheSansMonoCd_W5Regular_11">GameView.draw</span> has its own <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method; we’ll see how that’s implemented in the next section. The <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> has the ultimate responsibility for drawing to the canvas with each repetition of the game loop, but it delegates responsibility for actually drawing the game elements to the objects representing those elements. In effect, each element in the game “knows” how to draw itself, and <span class="SANS_TheSansMonoCd_W5Regular_11">GameView.draw</span> just orchestrates the calls.</p>
<p class="TX"><span aria-label=" Page 193. " epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">drawScores</span> method <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> takes an object containing the two scores and draws them to the canvas. It’s much the same as the score drawing code from the previous chapter. The main difference is that instead of relying on a global variable for the width of the canvas, it’s able to use the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> property from the <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> class by referring to <span class="SANS_TheSansMonoCd_W5Regular_11">this.width</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">drawGameOver</span> method <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> is also mostly the same as the equivalent function in the previous chapter, but again, it gets the width and height from <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> rather than from global variables.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-66"/><samp class="SANS_Futura_Std_Bold_B_11">The Game Elements</samp></h3>
<p class="TNI1">Next we’ll implement classes representing the three main game elements: the two paddles and the ball. We’ll begin with a superclass called <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> that will be a parent to the subclasses <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> class exists to share the general code common to both the paddles and the ball. This includes code for keeping track of the sizes and positions of the elements, calculating the boundaries of the elements for collision detection, and drawing the elements. Since all the game elements are rectangles, all this code is the same whether we’re dealing with a paddle or the ball. This shows the beauty of object-oriented programming: we can write all the common code once in the superclass, and let the subclasses inherit it.</p>
<p class="TX"><a href="#Lis11-2">Listing 11-2</a> contains the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> class.</p>
<span id="Lis11-2"/>
<pre><code>class Entity {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    }

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> boundingBox() {
    return {
      left: this.x,
      right: this.x + this.width,
      top: this.y,
      bottom: this.y + this.height
    };
  }

<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> draw(ctx) {
    ctx.fillStyle = "white";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The Entity class</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> constructor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> takes an x- and a y-coordinate for the top-left corner of the entity, and a width and height for its size. These are saved as properties.</p>
<p class="TX"><span aria-label=" Page 194. " epub:type="pagebreak" id="pg_194" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">boundingBox</span> method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> returns an object with the left, right, top, and bottom bounds of the entity. In the previous chapter, we manually created these objects for each entity in the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function. The <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> superclass gives us a convenient way of generalizing this common calculation for both the ball and the paddles.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> takes a drawing context and draws a white rectangle using the properties defined in the constructor. The objects passed into the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> will all be subclasses of <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span>, and it’s the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> that will be called for each item.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Paddles</samp></h4>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> class extends the <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> class. It’s declared in <a href="#Lis11-3">Listing 11-3</a>.</p>
<span id="Lis11-3"/>
<pre><code>class Paddle extends Entity {
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> static WIDTH = 5;
  static HEIGHT = 20
  static OFFSET = 10;

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> constructor(x, y) {
    super(x, y, Paddle.WIDTH, Paddle.HEIGHT);
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The Paddle class</samp></p>
<p class="TX">This class includes three <i>static properties</i>, which are properties assigned to the class itself rather than to an individual instance of the class. A static property’s value will be shared across all instances of the class. In this case, while each instance of <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> needs its own x- and y-coordinates, every <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> object should have the same width and height, as well as the same offset from the left or right edge of the canvas. Thus, we define those values as the static properties <span class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">HEIGHT</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">OFFSET</span>, which correspond to the <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_WIDTH</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_HEIGHT</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_OFFSET</span> constants from the previous chapter.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>There’s no straightforward way to define static constants in classes, which is why the constants from the previous chapter are now technically variables. Their names are in all caps to indicate that they should be treated as constants.</i></p>
<p class="TX">You declare a static property using the <span class="SANS_TheSansMonoCd_W5Regular_11">static</span> keyword. For example, we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</span> static property using <span class="SANS_TheSansMonoCd_W5Regular_11">static WIDTH = 5</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Static properties are accessed using dot notation, as with an instance’s properties, except that you use the class name on the left side of the dot, rather than <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> or the name of the instance. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.WIDTH</span> accesses the <span class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</span> static property.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> constructor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> has only two parameters: <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. It uses <span class="SANS_TheSansMonoCd_W5Regular_11">super</span> to call the constructor of its superclass (<span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span>), passing through the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> parameters as well as <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.WIDTH</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> parameter and <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.HEIGHT</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> parameter.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-66"/><span aria-label=" Page 195. " epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Ball</samp></h4>
<p class="TNI1">Next comes the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> class. This is similar to the <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> class in that it extends <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span>, but <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> has its own logic for updating its position based on its speed, and for collision detection. <a href="#Lis11-4">Listing 11-4</a> shows the first part of the code for this class.</p>
<span id="Lis11-4"/>
<pre><code>class Ball extends Entity {
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> static SIZE = 5;

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> constructor() {
    super(0, 0, Ball.SIZE, Ball.SIZE);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> this.init();
  }

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> init() {
    this.x = 20;
    this.y = 30;
    this.xSpeed = 4;
    this.ySpeed = 2;
  }

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> update() {
    this.x += this.xSpeed;
    this.y += this.ySpeed;
    }

<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> adjustAngle(distanceFromTop, distanceFromBottom) {
    if (distanceFromTop &lt; 0) {
      // If ball hit near top of paddle, reduce ySpeed
      this.ySpeed -= 0.5;
    } else if (distanceFromBottom &lt; 0) {
      // If ball hit near bottom of paddle, increase ySpeed
      this.ySpeed += 0.5;
    }
  }
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: The beginning of the Ball class</samp></p>
<p class="TX">This class has a static property called <span class="SANS_TheSansMonoCd_W5Regular_11">SIZE</span> that defines the width and height of the ball <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next comes its constructor method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Like the <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> constructor, the first thing the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> constructor does is call the constructor of its superclass, <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span>, this time passing <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> parameters and <span class="SANS_TheSansMonoCd_W5Regular_11">Ball.SIZE</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> parameters. The <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>s are just placeholders; in fact, the ball starts each point at the same position, (20, 30). This positioning is handled by the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">init</span> method, which is called for the first time from the constructor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">init</span> method itself is defined to set the initial position and speed of the ball <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, just like the <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function from the previous chapter. This method will be called whenever the ball needs to be reset to its initial position (after a point is scored).</p>
<p class="TX">The next method, <span class="SANS_TheSansMonoCd_W5Regular_11">update</span>, uses the ball’s current speed to update its x- and y-position <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. It’s followed by the <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> method <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, equivalent to the <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> function described in the previous chapter. It changes the <span aria-label=" Page 196. " epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/>ball’s vertical speed (the angle of the bounce) depending on where the ball hits the paddle.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> class definition continues in <a href="#Lis11-5">Listing 11-5</a> with the methods for collision detection.</p>
<span id="Lis11-5"/>
<pre><code><span class="gray">class Ball extends Entity {</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">--snip--</span>
  checkPaddleCollision(paddle, xSpeedAfterBounce) {
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let ballBox = this.boundingBox();
    let paddleBox = paddle.boundingBox();

    // Check if the ball and paddle overlap vertically and horizontally
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let collisionOccurred = (
      ballBox.left<b>   </b>&lt; paddleBox.right &amp;&amp;
      ballBox.right  &gt; paddleBox.left &amp;&amp;
      ballBox.top<b>    </b>&lt; paddleBox.bottom &amp;&amp;
      ballBox.bottom &gt; paddleBox.top
    );

    if (collisionOccurred) {
      let distanceFromTop = ballBox.top - paddleBox.top;
      let distanceFromBottom = paddleBox.bottom - ballBox.bottom;
    <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> this.adjustAngle(distanceFromTop, distanceFromBottom);
    <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> this.xSpeed = xSpeedAfterBounce;
    }
  }

  checkWallCollision(width, height, scores) {
    let ballBox = this.boundingBox();

    // Hit left wall
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (ballBox.left &lt; 0) {
      scores.rightScore++;
      this.init();
    }
    // Hit right wall
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> if (ballBox.right &gt; width) {
      scores.leftScore++;
      this.init();
    }
    // Hit top or bottom walls
    if (ballBox.top &lt; 0 || ballBox.bottom &gt; height) {
    <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> this.ySpeed = -this.ySpeed;
    }
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: The rest of the Ball class</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span> method has some overlap with the <span class="SANS_TheSansMonoCd_W5Regular_11">check Collision</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span> functions from the previous chapter. The method takes two parameters: an object representing one of the paddles, and <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeedAfterBounce</span>. The latter represents the new value we should set <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> to if a bounce off one of the paddles occurs, and it lets us <span aria-label=" Page 197. " epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/>configure whether the ball is expected to always bounce to the right (from the left paddle) or to the left (from the right paddle). As in the previous chapter, we enforce that a collision with the left paddle makes the ball bounce right and vice versa to avoid weirdness where the ball could bounce around “inside” the paddle.</p>
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">boundingBox</span> method from the parent <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span> class to get the bounding boxes of the ball and the paddle <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, storing them as <span class="SANS_TheSansMonoCd_W5Regular_11">ballBox</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">paddleBox</span>. Next, we compare the various bounding box edges to determine if a collision has taken place between the ball and the paddle, saving the result in the Boolean variable <span class="SANS_TheSansMonoCd_W5Regular_11">collisionOccurred</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">collisionOccurred</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> method with the appropriate distances as determined from the bounding boxes <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, then set the ball’s <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeedAfterBounce</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">checkWallCollision</span> method checks to see if a collision has occurred between the ball and a wall. It takes the width and height of the playing area and an object representing the scores as parameters. If the ball hits the left wall <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> or right wall <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, the appropriate score is incremented, and the ball is reset with a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">init</span> method. If it hits the top or bottom wall, it bounces <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-67"/><samp class="SANS_Futura_Std_Bold_B_11">The Scores and Computer Classes</samp></h3>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">Scores</span> class is a simple container for keeping track of the current scores. The <span class="SANS_TheSansMonoCd_W5Regular_11">Computer</span> class contains the logic for following the ball. The code for these two classes is in <a href="#Lis11-6">Listing 11-6</a>.</p>
<span id="Lis11-6"/>
<pre><code>class Scores {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> constructor() {
    this.leftScore = 0;
    this.rightScore = 0;
   }
}

class Computer {
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> static followBall(paddle, ball) {
    const MAX_SPEED = 2;
    let ballBox = ball.boundingBox();
    let paddleBox = paddle.boundingBox();

    if (ballBox.top &lt; paddleBox.top) {
      paddle.y -= MAX_SPEED;
    } else if (ballBox.bottom &gt; paddleBox.bottom) {
      paddle.y += MAX_SPEED;
    }
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: The Scores and Computer classes</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Scores</span> constructor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> sets the scores for the left and right players to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. We could just use a plain object for the scores, but using a class keeps the structure of the code more consistent.</p>
<p class="TX"><span aria-label=" Page 198. " epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">Computer</span> class has a single method called <span class="SANS_TheSansMonoCd_W5Regular_11">followBall</span>, which updates the left paddle’s position based on the ball’s position. It’s a <i>static method</i>, meaning it doesn’t need an instance of the class to be called. We declare it as static using the <span class="SANS_TheSansMonoCd_W5Regular_11">static</span> keyword <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, similar to declaring a static property. Static methods are called using the class name rather than the instance name, like this: <span class="SANS_TheSansMonoCd_W5Regular_11">Computer.followBall(leftPaddle, ball)</span>.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>We create instances of a class when there are properties specific to that instance that need to be stored. The Computer class doesn’t have any properties, so we don’t need to create an instance of it. Since the Computer class is never instantiated, it also doesn’t need a constructor.</i></p>
<p class="TX">We could just as easily have created a standalone function to move the left paddle, but as with the <span class="SANS_TheSansMonoCd_W5Regular_11">Scores</span> class, keeping the code as part of a <span class="SANS_TheSansMonoCd_W5Regular_11">Computer</span> class maintains consistency.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="h1-68"/><samp class="SANS_Futura_Std_Bold_B_11">The Game Class</samp></h3>
<p class="TNI1">We finally come to the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class, which is where all the other classes get instantiated (where applicable) and are stitched together and orchestrated. See <a href="#Lis11-7">Listing 11-7</a> for the first part of the code.</p>
<span id="Lis11-7"/>
<pre><code>class Game {
  constructor() {
    this.gameView = new GameView();
    this.ball = new Ball();
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> this.leftPaddle = new Paddle(Paddle.OFFSET, 10);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> this.rightPaddle = new Paddle(
      this.gameView.width - Paddle.OFFSET - Paddle.WIDTH,
      30
    );

  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> this.scores = new Scores();
    this.gameOver = false;

  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> document.addEventListener("mousemove", e =&gt; {
    this.rightPaddle.y = e.y - this.gameView.offsetTop;
    });
  }

  draw() {
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> this.gameView.draw(
      this.ball,
      this.leftPaddle,
      this.rightPaddle
    );

  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> this.gameView.drawScores(this.scores);
  }
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: The first part of the Game class</samp></p>
<p class="TX"><span aria-label=" Page 199. " epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> constructor first instantiates the <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> classes. The <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddle</span> instance is created with <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.OFFSET</span> for its x-coordinate <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The right one uses <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.OFFSET</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle.WIDTH</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">this .gameView.width</span> to determine its x-coordinate <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, similar to how we calculated the position of the right paddle in the previous chapter.</p>
<p class="TX">Instantiating other classes inside a class is a common feature of object-oriented code. This technique is called <i>composition</i>, because we’re composing instances inside other instances</p>
<section aria-labelledby="sec9" epub:type="division">
<aside aria-label="box-35" class="box" id="sec9">
<h4 class="BH" id="box-35"><samp class="SANS_Dogma_OT_Bold_B_11">COMPOSITION AND INHERITANCE</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Composition and inheritance both add structure to object-oriented programs. Composition is a way of modeling a “has a” relationship, as in the sentence “</samp><span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">has a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span><samp class="SANS_Futura_Std_Book_11">.” Inheritance, meanwhile, models an “is a” relationship, as in “</samp><span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> <samp class="SANS_Futura_Std_Book_11">is an</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Entity</span><samp class="SANS_Futura_Std_Book_11">.”</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">For these two examples, it’s pretty intuitive whether to use composition or inheritance—we know that the game has a ball, and that the ball is an entity—but the choice isn’t always so clear. For example, you could argue that the methods in</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> <samp class="SANS_Futura_Std_Book_11">are core to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">class, and make</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">inherit from</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span><samp class="SANS_Futura_Std_Book_11">. It’s a bit of a stretch to say that “</samp><span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">is a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span><samp class="SANS_Futura_Std_Book_11">,” but if you renamed</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> <samp class="SANS_Futura_Std_Book_11">to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ViewableGame</span> <samp class="SANS_Futura_Std_Book_11">it might make more sense.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">When faced with a choice between composition and inheritance, a commonly followed design principle says to favor composition. This leads to greater flexibility and greater encapsulation. For example, if</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">extended</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span><samp class="SANS_Futura_Std_Book_11">, then all of the properties of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span><samp class="SANS_Futura_Std_Book_11">, like</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ctx</span><samp class="SANS_Futura_Std_Book_11">, would also be present in</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span><samp class="SANS_Futura_Std_Book_11">. With the code as it’s written now, these properties are confined to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> <samp class="SANS_Futura_Std_Book_11">class itself, which encapsulates the logic better and increases flexibility: it’s easier to make internal changes to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> <samp class="SANS_Futura_Std_Book_11">class without having to worry about breaking the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> <samp class="SANS_Futura_Std_Book_11">class.</samp></p>
</aside>
<p class="TX">Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> constructor instantiates <span class="SANS_TheSansMonoCd_W5Regular_11">Scores</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and sets the <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> Boolean to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>. Finally, it sets up a <span class="SANS_TheSansMonoCd_W5Regular_11">mousemove</span> event listener <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> to update the right paddle’s position when the user moves the mouse. An event listener set up in a class constructor works just like the other event listeners we’ve seen in the book: it will be available as long as the application is running, and it triggers its handler function whenever the event is detected.</p>
<p class="TX">After the constructor is the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method, which has the top-level responsibility for drawing all the visual aspects of the game. First the method calls <span class="SANS_TheSansMonoCd_W5Regular_11">this.gameView.draw</span> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, passing the three main game elements, <span class="SANS_TheSansMonoCd_W5Regular_11">this.ball</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">this.leftPaddle</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">this.rightPaddle</span>. This is a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> class we saw in <a href="#Lis11-1">Listing 11-1</a>, which took a variable number of objects as arguments and called the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method on each one. The net result is that <span class="SANS_TheSansMonoCd_W5Regular_11">game.draw</span> calls <span class="SANS_TheSansMonoCd_W5Regular_11">gameView.draw</span>, which calls <span class="SANS_TheSansMonoCd_W5Regular_11">ball.draw</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddle.draw</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddle.draw</span>. It may seem a bit roundabout, but you’ll often find cases like this in object-oriented code, where keeping the <span aria-label=" Page 200. " epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/>code in its logical place requires jumping through some hoops. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">game.draw</span> is responsible for knowing <i>which</i> objects get drawn (because the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class keeps track of all the game elements); <span class="SANS_TheSansMonoCd_W5Regular_11">gameView.draw</span> is responsible for the drawing context, clearing the canvas, and calling the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> methods on the elements; and the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method on each game element is responsible for knowing how to draw itself.</p>
<p class="TX">After it has drawn all the entities, the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> method calls <span class="SANS_TheSansMonoCd_W5Regular_11">this.gameView .drawScores</span>, passing the <span class="SANS_TheSansMonoCd_W5Regular_11">this.scores</span> object <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class continues with the rest of its methods in <a href="#Lis11-8">Listing 11-8</a>.</p>
<span id="Lis11-8"/>
<pre><code><span class="gray">class Game {</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">--snip--</span>
  checkCollision() {
    this.ball.checkPaddleCollision(this.leftPaddle,
                                 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> Math.abs(this.ball.xSpeed));
    this.ball.checkPaddleCollision(this.rightPaddle,
                                 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> -Math.abs(this.ball.xSpeed));

  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> this.ball.checkWallCollision(
      this.gameView.width,
      this.gameView.height,
      this.scores
    );

  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if (this.scores.leftScore &gt; 9 || this.scores.rightScore &gt; 9) {
      this.gameOver = true;
    }
  }

<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> update() {
    this.ball.update();
    Computer.followBall(this.leftPaddle, this.ball);
  }

<span aria-label="annotation6" class="CodeAnnotationCode">❻</span> loop() {
    this.draw();
    this.update();
    this.checkCollision();

  <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> if (this.gameOver) {
      this.draw();
      this.gameView.drawGameOver();
    } else {
      // Call this method again after a timeout
    <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> setTimeout(() =&gt; this.loop(), 30);
    }
  }
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: The rest of the Game class</samp></p>
<p class="TX"><span aria-label=" Page 201. " epub:type="pagebreak" id="pg_201" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> method coordinates all the collision detection logic. First it calls the ball’s <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span> method twice, to check for collisions between the ball and each of the paddles. Recall from <a href="#Lis11-5">Listing 11-5</a> that this method takes two arguments: a <span class="SANS_TheSansMonoCd_W5Regular_11">Paddle</span> object and a new, post-bounce value for <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span>. For the left paddle, we know that we want the ball to bounce right, so we make the new <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> positive by taking the <span class="SANS_TheSansMonoCd_W5Regular_11">Math.abs</span> of the current <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. For the right paddle we want the ball to bounce left, so we make the new <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> negative by negating the result of <span class="SANS_TheSansMonoCd_W5Regular_11">Math.abs(xSpeed)</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> method calls <span class="SANS_TheSansMonoCd_W5Regular_11">ball.checkWallCollision</span> to handle wall collisions <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This method takes the width and height (because the <span class="SANS_TheSansMonoCd_W5Regular_11">Ball</span> object doesn’t know how big the playing area is) and the scores (so they can be incremented if a side wall is hit). Finally, the method checks to see if either score has exceeded the threshold <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and, if so, sets <span class="SANS_TheSansMonoCd_W5Regular_11">this.gameOver</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> method <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> controls the changes of state between each repetition of the game loop. It calls the ball’s <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> method to move the ball, then tells the computer to move the left paddle based on the ball’s new position using the <span class="SANS_TheSansMonoCd_W5Regular_11">Computer.followBall</span> static method.</p>
<p class="TX">The last method of the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class, <span class="SANS_TheSansMonoCd_W5Regular_11">loop</span>, defines the game loop <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. We call <span class="SANS_TheSansMonoCd_W5Regular_11">this.draw</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">this.update</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">this.checkCollision</span> in sequence. Then we check to see if <span class="SANS_TheSansMonoCd_W5Regular_11">this.gameOver</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. If so <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, we call <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> again to render the final score, and we call <span class="SANS_TheSansMonoCd_W5Regular_11">gameView.drawGameOver</span> to render the “GAME OVER” text. Otherwise, we use <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> to call the <span class="SANS_TheSansMonoCd_W5Regular_11">loop</span> method again after 30 ms <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, continuing the game.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-69"/><samp class="SANS_Futura_Std_Bold_B_11">Starting the Game</samp></h3>
<p class="TNI1">The very last thing we have to do is start the game by instantiating the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class and kicking off the game loop, as shown in <a href="#Lis11-9">Listing 11-9</a>.</p>
<span id="Lis11-9"/>
<pre><code>let game = new Game();
game.loop();
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: Starting the game</samp></p>
<p class="TX">We must create the instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class at the top level of the program, outside any of the class definitions. All the other required objects are instantiated by the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class’s constructor, so creating a <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> object automatically creates all the other objects as well. We could also have had the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> constructor call the <span class="SANS_TheSansMonoCd_W5Regular_11">loop</span> method to set the game in motion as part of the <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> class instantiation. However, placing the first call to <span class="SANS_TheSansMonoCd_W5Regular_11">game.loop</span> at the top level of the program makes it easier to see exactly where the game gets going.</p>
<p class="TX">With this final listing, we now have all the code for the object-oriented version of our game! As long as you’ve entered all the code in order, it should now work, and gameplay should be exactly the same as in the version from the previous chapter.</p>
<section aria-labelledby="sec11" epub:type="division">
<aside aria-label="box-36" class="box" id="sec11">
<h4 class="BH" id="box-36"><span aria-label=" Page 202. " epub:type="pagebreak" id="pg_202" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">11-1.</samp><samp class="SANS_Futura_Std_Book_11">  If you made any of the changes suggested in the previous chapter, such as altering the speed of the game loop or of the opponent, resizing the paddles, or adding a second ball, try making them again in this version of the code. Which version is easier to modify?</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="h1-70"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter you created an object-oriented version of your <i>Pong</i> program, learning some strategies for object-oriented software design in the process. None of the game’s logic from the previous chapter changed; only the code’s organization differs. You may find one or the other of these two versions easier to read and understand, depending on your preferences and experience with object-oriented code.</p>
<p class="TX">Object-oriented design is a complex field, and it can take a lot of practice to decompose programs into individual objects that make sense on their own. Even in this simple game, there are many ways you could split up the game’s components into objects and methods. For example, you might decide that the <span class="SANS_TheSansMonoCd_W5Regular_11">GameView</span> class is unnecessary and that <span class="SANS_TheSansMonoCd_W5Regular_11">Game</span> can keep track of the canvas, avoiding the need for the complex dance where <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> calls <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> calls <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span>. The main thing is to arrange your code in a way that makes sense and is easy for you and other programmers to understand and modify.</p>
</section>
</section>
</body>
</html>