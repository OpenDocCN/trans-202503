["```\n[-1, 0, -1, 1, 2, 4, 5]\n```", "```\nstatic int snowflakes[SIZE][6];\nstatic int heads[SIZE];\nstatic int nodes[SIZE];\n```", "```\nvoid identify_identical(int snowflakes[][6], int heads[],\n                        int nodes[]) {\n  int i, node1, node2;\n  for (i = 0; i < SIZE; i++) {\n    node1 = heads[i];\n    while (node1 != -1) {\n   ➊ node2 = nodes[node1];\n      while (node2 != -1) {\n        if (are_identical(snowflakes[node1], snowflakes[node2])) {\n          printf(\"Twin snowflakes found.\\n\");\n          return;\n        }\n     ➋ node2 = nodes[node2];\n     }\n   ➌ node1 = nodes[node1];\n   }\n  }\n  printf(\"No two snowflakes are alike.\\n\");\n}\n```", "```\nint main(void) {\n  static int snowflakes[SIZE][6];\n  static int heads[SIZE];\n  static int nodes[SIZE];\n  int n;\n  int i, j, snowflake_code;\n  for (i = 0; i < SIZE; i++) {\n    heads[i] = -1;\n    nodes[i] = -1;\n  }\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < 6; j++)\n      scanf(\"%d\", &snowflakes[i][j]);\n    snowflake_code = code(snowflakes[i]);\n  ➊ nodes[i] = heads[snowflake_code];\n  ➋ heads[snowflake_code] = i;\n  }\n  identify_identical(snowflakes, heads, nodes);\n  return 0;\n}\n```", "```\n4 9 15\n```", "```\n2 2\nEat a 4-minute burger\nEat a 9-minute burger\n```", "```\nvoid reconstruct(int m, int n, int dp[], int minutes)\n```", "```\nvoid reconstruct(int m, int n, int dp[], int minutes) {\n  int first, second;\n  while (minutes > 0) {\n    first = -1;\n    second = -1;\n    if (minutes >= m)\n      first = dp[minutes - m];\n    if (minutes >= n)\n      second = dp[minutes - n];\n    if (first >= second) {\n      printf(\"Eat a %d-minute burger\\n\", m);\n      minutes = minutes - m;\n    } else {\n      printf(\"Eat a %d-minute burger\\n\", n);\n minutes = minutes - n;\n    }\n  }\n}\n```", "```\nreconstruct(m, n, dp, t);\n```", "```\nreconstruct(m, n, dp, i);\n```", "```\nadd_position(from_row, from_col, from_row + 1, from_col + 2,\n             num_rows, num_cols, new_positions,\n             &num_new_positions, min_moves);\n```", "```\nadd_position(from_row, from_col, from_row + 1, from_col - 2,\n             num_rows, num_cols, new_positions,\n             &num_new_positions, min_moves);\n```", "```\nint row_dif[8] = {1, 1, -1, -1, 2, 2, -2, -2};\n```", "```\nint col_dif[8] = {2, -2, 2, -2, 1, -1, 1, -1};\n```", "```\nfor (m = 0; m < 8; m++)\n  add_position(from_row, from_col,\n               from_row + row_dif[m], from_col + col_dif[m],\n               num_rows, num_cols, new_positions,\n               &num_new_positions, min_moves);\n```", "```\ntypedef struct heap_element {\n  int cell;\n  int time;\n} heap_element;\n```", "```\nint find_time(edge *adj_list[], int num_cells,\n              int from_cell, int exit_cell) {\n  static int done[MAX_CELLS + 1];\n  static int min_times[MAX_CELLS + 1];\n➊ static heap_element min_heap[MAX_CELLS * MAX_CELLS + 1];\n  int i;\n  int min_time, min_time_index, old_time;\n  edge *e;\n  int num_min_heap = 0;\n  for (i = 1; i <= num_cells; i++) {\n    done[i] = 0;\n    min_times[i] = -1;\n  }\n  min_times[from_cell] = 0;\n  min_heap_insert(min_heap, &num_min_heap, from_cell, 0);\n\n ➋ while (num_min_heap > 0) {\n      min_time_index = min_heap_extract(min_heap, &num_min_heap).cell;\n      if (done[min_time_index])\n      ➌ continue;\n      min_time = min_times[min_time_index];\n done[min_time_index] = 1;\n\n   e = adj_list[min_time_index];\n ➍ while (e) {\n      old_time = min_times[e->to_cell];\n      if (old_time == -1 || old_time> min_time + e->length) {\n        min_times[e->to_cell] = min_time + e->length;\n     ➎ min_heap_insert(min_heap, &num_min_heap,\n                e->to_cell, min_time + e->length);\n      }\n      e = e->next;\n    }\n  }\n  return min_times[exit_cell];\n}\n```", "```\nint find(int p, int parent[]) {\n  return p == parent[p] ? p : (parent[p] = find(parent[p], parent));\n}\n```", "```\nreturn x >= 10 ? \"big\" : \"small\";\n```", "```\nint find(int p, int parent[]) {\n  if (p == parent[p])\n    return p;\n  else\n    return parent[p] = find(parent[p], parent);\n}\n```", "```\nint x;\nprintf(\"%d\\n\", x = 5);\n```", "```\na = b = c = 5;\n```", "```\nint find(int p, int parent[]) {\n  int community;\n  if (p == parent[p])\n    return p;\n  else {\n    community = find(parent[p], parent);\n parent[p] = community;\n    return community;\n  }\n}\n```", "```\ncommunity = find(parent[p], parent);\n```", "```\nparent[p] = community;\n```", "```\n#define MAX_N 10000\n\nvoid swap(int *x, int *y) {\n  int temp = *x;\n *x = *y;\n    *y = temp;\n  }\n\n  int random_value(int left, int width) {\n    return (rand() % width) + left;\n  }\n\n➊ void solve(int cap_nums[], int bottle_nums[], int left, int right) {\n    int border, cap_index, cap_num, i, result, matching_bottle;\n    if (right < left)\n      return;\n\n    border = left;\n  ➋ cap_index = random_value(left, right - left + 1);\n     cap_num = cap_nums[cap_index];\n\n     i = left;\n     while (i < right) {\n       printf(\"0 %d %d\\n\", cap_num, bottle_nums[i]);\n       scanf(\"%d\", &result);\n     ➌ if (result == 0) {\n         swap(&bottle_nums[i], &bottle_nums[right]);\n    ➍ } else if (result == 1) {\n      ➎ swap(&bottle_nums[border], &bottle_nums[i]);\n         border++;\n         i++;\n } else {\n         i++;\n       }\n    }\n\n    matching_bottle = bottle_nums[right];\n ➏ printf(\"1 %d %d\\n\", cap_num, matching_bottle);\n\n    border = left;\n\n    i = left;\n    while (i < right) {\n      printf(\"0 %d %d\\n\", cap_nums[i], matching_bottle);\n      scanf(\"%d\", &result);\n      if (result == 0) {\n        swap(&cap_nums[i], &cap_nums[right]);\n      } else if (result == -1) {\n        swap(&cap_nums[border], &cap_nums[i]);\n        border++;\n        i++;\n      } else {\n        i++;\n      }\n   }\n\n➐ solve(cap_nums, bottle_nums, left, border - 1);\n➑ solve(cap_nums, bottle_nums, border, right - 1);\n}\n\nint main(void) {\n  int n, i;\n  int cap_nums[MAX_N], bottle_nums[MAX_N];\n  srand((unsigned) time(NULL));\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    cap_nums[i] = i + 1;\n    bottle_nums[i] = i + 1;\n  }\n  solve(cap_nums, bottle_nums, 0, n - 1);\n  return 0;\n}\n```"]