- en: 'Chapter 56. Sockets: Introduction'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第56章. 套接字：简介
- en: Sockets are a method of IPC that allow data to be exchanged between applications,
    either on the same host (computer) or on different hosts connected by a network.
    The first widespread implementation of the sockets API appeared with 4.2BSD in
    1983, and this API has been ported to virtually every UNIX implementation, as
    well as most other operating systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是IPC（进程间通信）的一种方法，允许在同一主机（计算机）或通过网络连接的不同主机之间交换数据。套接字API的首次广泛实现出现在1983年的4.2BSD中，该API已被移植到几乎所有UNIX实现中，以及大多数其他操作系统。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sockets API is formally specified in POSIX.1g, which was ratified in 2000
    after spending about a decade as a draft standard. This standard has been superseded
    by SUSv3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字API在POSIX.1g中进行了正式规定，POSIX.1g于2000年批准，此前作为草案标准存在了约十年。该标准已被SUSv3所取代。
- en: 'This chapter and the following chapters describe the use of sockets, as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及随后的章节描述了套接字的使用，具体如下：
- en: This chapter provides a general introduction to the sockets API. The following
    chapters assume an understanding of the general concepts presented here. We don’t
    present any example code in this chapter. Code examples in the UNIX and Internet
    domains are presented in the following chapters.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章提供了套接字API的一般介绍。以下章节假定读者已理解本章介绍的基本概念。本章不提供示例代码。UNIX和互联网领域的代码示例将在后续章节中提供。
- en: '[Chapter 57](ch57.html "Chapter 57. Sockets: UNIX Domain") describes UNIX domain
    sockets, which allow communication between applications on the same host system.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第57章](ch57.html "第57章. 套接字：UNIX域")描述了UNIX域套接字，它允许在同一主机系统上的应用程序之间进行通信。'
- en: '[Chapter 58](ch58.html "Chapter 58. Sockets: Fundamentals of TCP/IP Networks")
    introduces various computer networking concepts and describes key features of
    the TCP/IP networking protocols. It provides background needed for the next chapters.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第58章](ch58.html "第58章. 套接字：TCP/IP网络基础")介绍了各种计算机网络概念，并描述了TCP/IP网络协议的关键特性。它为接下来的章节提供了所需的背景知识。'
- en: '[Chapter 59](ch59.html "Chapter 59. Sockets: Internet Domains") describes Internet
    domain sockets, which allow applications on different hosts to communicate via
    a TCP/IP network.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第59章](ch59.html "第59章. 套接字：互联网域")描述了互联网域套接字，它允许不同主机上的应用程序通过TCP/IP网络进行通信。'
- en: '[Chapter 60](ch60.html "Chapter 60. Sockets: Server Design") discusses the
    design of servers that use sockets.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第60章](ch60.html "第60章. 套接字：服务器设计")讨论了使用套接字的服务器设计。'
- en: '[Chapter 61](ch61.html "Chapter 61. Sockets: Advanced Topics") covers a range
    of advanced topics, including additional features for socket I/O, a more detailed
    look at the TCP protocol, and the use of socket options to retrieve and modify
    various attributes of sockets.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第61章](ch61.html "第61章. 套接字：高级主题")涵盖了一系列高级主题，包括套接字I/O的附加特性、更详细的TCP协议分析，以及使用套接字选项来检索和修改套接字的各种属性。'
- en: These chapters merely aim to give the reader a good grounding in the use of
    sockets. Sockets programming, especially for network communication, is an enormous
    topic in its own right, and forms the subject of entire books. Sources of further
    information are listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节仅旨在为读者提供使用套接字的基础知识。套接字编程，特别是用于网络通信，是一个庞大的主题，足以写成整本书。更多信息来源请参见[进一步信息](ch59.html#further_information-id81
    "进一步信息")。
- en: Overview
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'In a typical client-server scenario, applications communicate using sockets
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的客户端-服务器场景中，应用程序通过以下方式使用套接字进行通信：
- en: Each application creates a socket. A socket is the “apparatus” that allows communication,
    and both applications require one.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序都会创建一个套接字。套接字是允许通信的“装置”，并且两个应用程序都需要一个。
- en: The server binds its socket to a well-known address (name) so that clients can
    locate it.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将其套接字绑定到一个众所周知的地址（名称），以便客户端能够找到它。
- en: 'A socket is created using the *socket()* system call, which returns a file
    descriptor used to refer to the socket in subsequent system calls:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*socket()*系统调用创建套接字，该调用返回一个文件描述符，用于在后续的系统调用中引用该套接字：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We describe socket domains and types in the following paragraphs. For all applications
    described in this book, *protocol* is always specified as 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的段落中描述套接字域和类型。对于本书中描述的所有应用程序，*协议*始终指定为0。
- en: Communication domains
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通信域
- en: 'Sockets exist in a *communication domain*, which determines:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字存在于*通信域*中，通信域决定了：
- en: the method of identifying a socket (i.e., the format of a socket “address”);
    and
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字的标识方法（即，套接字“地址”的格式）；和
- en: the range of communication (i.e., either between applications on the same host
    or between applications on different hosts connected via a network).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信范围（即，应用程序之间的通信可能发生在同一主机上，也可能发生在通过网络连接的不同主机之间）。
- en: 'Modern operating systems support at least the following domains:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统至少支持以下几种域：
- en: The *UNIX* (`AF_UNIX`) domain allows communication between applications on the
    same host. (POSIX.1g used the name `AF_LOCAL` as a synonym for `AF_UNIX`, but
    this name is not used in SUSv3.)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UNIX* (`AF_UNIX`) 域允许在同一主机上的应用程序之间进行通信。（POSIX.1g 使用 `AF_LOCAL` 作为 `AF_UNIX`
    的同义词，但该名称在 SUSv3 中未使用。）'
- en: The *IPv4* (`AF_INET`) domain allows communication between applications running
    on hosts connected via an Internet Protocol version 4 (IPv4) network.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPv4* (`AF_INET`) 域允许在通过 Internet 协议第四版（IPv4）网络连接的主机上运行的应用程序之间进行通信。'
- en: The *IPv6* (`AF_INET6`) domain allows communication between applications running
    on hosts connected via an Internet Protocol version 6 (IPv6) network. Although
    IPv6 is designed as the successor to IPv4, the latter protocol is currently still
    the most widely used.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPv6* (`AF_INET6`) 域允许在通过 Internet 协议第六版（IPv6）网络连接的主机上运行的应用程序之间进行通信。虽然 IPv6
    被设计为 IPv4 的继任者，但后者协议目前仍是使用最广泛的协议。'
- en: '[Table 56-1](ch56.html#socket_domains "Table 56-1. Socket domains") summarizes
    the characteristics of these socket domains.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 56-1](ch56.html#socket_domains "表 56-1. 套接字域") 总结了这些套接字域的特点。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some code, we may see constants with names such as `PF_UNIX` instead of `AF_UNIX`.
    In this context, `AF` stands for “address family” and `PF` stands for “protocol
    family.” Initially, it was conceived that a single protocol family might support
    multiple address families. In practice, no protocol family supporting multiple
    address families has ever been defined, and all existing implementations define
    the `PF_` constants to be synonymous with the corresponding `AF_` constants. (SUSv3
    specifies the `AF_` constants, but not the `PF_` constants.) In this book, we
    always use the `AF_` constants. Further information about the history of these
    constants can be found in [Universality of I/O](ch04.html#universality_of_i_solidus_o
    "Universality of I/O") of [Stevens et al., 2004].
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些代码中，我们可能会看到类似 `PF_UNIX` 而不是 `AF_UNIX` 的常量。在这种情况下，`AF` 代表“地址族”，而 `PF` 代表“协议族”。最初，设想一个协议族可能支持多个地址族。但实际上，从未定义过支持多个地址族的协议族，所有现有的实现都将
    `PF_` 常量视为与相应的 `AF_` 常量同义。（SUSv3 指定了 `AF_` 常量，但未指定 `PF_` 常量。）在本书中，我们始终使用 `AF_`
    常量。关于这些常量历史的更多信息，可以参考 [I/O 的通用性](ch04.html#universality_of_i_solidus_o "I/O 的通用性")，出自
    [Stevens 等人，2004 年]。
- en: Table 56-1. Socket domains
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 56-1. 套接字域
- en: '| Domain | Communication performed | Communication between applications | Address
    format | Address structure |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 域 | 执行的通信 | 应用程序间通信 | 地址格式 | 地址结构 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `AF_UNIX` | within kernel | on same host | pathname | *sockaddr_un* |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `AF_UNIX` | 内核内 | 在同一主机上 | 文件路径名 | *sockaddr_un* |'
- en: '| `AF_INET` | via IPv4 | on hosts connected via an IPv4 network | 32-bit IPv4
    address + 16-bit port number | *sockaddr_in* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `AF_INET` | 通过 IPv4 | 在通过 IPv4 网络连接的主机上 | 32 位 IPv4 地址 + 16 位端口号 | *sockaddr_in*
    |'
- en: '| `AF_INET6` | via IPv6 | on hosts connected via an IPv6 network | 128-bit
    IPv6 address + 16-bit port number | *sockaddr_in6* |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `AF_INET6` | 通过 IPv6 | 在通过 IPv6 网络连接的主机上 | 128 位 IPv6 地址 + 16 位端口号 | *sockaddr_in6*
    |'
- en: Socket types
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 套接字类型
- en: 'Every sockets implementation provides at least two types of sockets: stream
    and datagram. These socket types are supported in both the UNIX and the Internet
    domains. [Table 56-2](ch56.html#socket_types_and_their_properties "Table 56-2. Socket
    types and their properties") summarizes the properties of these socket types.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每种套接字实现至少提供两种类型的套接字：流式套接字和数据报套接字。这些套接字类型在 UNIX 域和 Internet 域中都得到支持。[表 56-2](ch56.html#socket_types_and_their_properties
    "表 56-2. 套接字类型及其属性") 总结了这些套接字类型的属性。
- en: Table 56-2. Socket types and their properties
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 56-2. 套接字类型及其属性
- en: '| Property | Socket type |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 套接字类型 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Stream | Datagram |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 流式 | 数据报 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Reliable delivery? | Y | N |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 可靠交付？ | Y | N |'
- en: '| Message boundaries preserved? | N | Y |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 消息边界是否保留？ | N | Y |'
- en: '| Connection-oriented? | Y | N |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 面向连接？ | Y | N |'
- en: '*Stream sockets* (`SOCK_STREAM`) provide a reliable, bidirectional, byte-stream
    communication channel. By the terms in this description, we mean the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*流套接字*（`SOCK_STREAM`）提供可靠的、双向的字节流通信通道。根据这个描述中的术语，我们指的是以下内容：'
- en: '*Reliable* means that we are guaranteed that either the transmitted data will
    arrive intact at the receiving application, exactly as it was transmitted by the
    sender (assuming that neither the network link nor the receiver crashes), or that
    we’ll receive notification of a probable failure in transmission.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠*意味着我们可以保证，传输的数据要么会完整地到达接收应用程序，完全按照发送方的原样（假设网络连接和接收方没有崩溃），要么我们会收到关于传输失败的通知。'
- en: '*Bidirectional* means that data may be transmitted in either direction between
    two sockets.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向*意味着数据可以在两个套接字之间双向传输。'
- en: '*Byte-stream* means that, as with pipes, there is no concept of message boundaries
    (refer to [Overview](ch44.html#overview-id11 "Overview")).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字节流*意味着，就像管道一样，数据传输没有消息边界的概念（参见[概述](ch44.html#overview-id11 "Overview")）。'
- en: A stream socket is similar to using a pair of pipes to allow bidirectional communication
    between two applications, with the difference that (Internet domain) sockets permit
    communication over a network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字类似于使用一对管道允许两个应用程序之间的双向通信，区别在于（互联网域）套接字允许通过网络进行通信。
- en: Stream sockets operate in connected pairs. For this reason, stream sockets are
    described as *connection-oriented*. The term *peer socket* refers to the socket
    at the other end of a connection; *peer address* denotes the address of that socket;
    and *peer application* denotes the application utilizing the peer socket. Sometimes,
    the term *remote* (or *foreign*) is used synonymously with *peer*. Analogously,
    sometimes the term *local* is used to refer to the application, socket, or address
    for this end of the connection. A stream socket can be connected to only one peer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字以连接对的形式工作。因此，流套接字被描述为*面向连接*的。术语*对等套接字*指的是连接另一端的套接字；*对等地址*表示该套接字的地址；*对等应用程序*表示使用该对等套接字的应用程序。有时，*远程*（或*外部*）一词与*对等*互换使用。类比地，有时*本地*一词用来指代连接这一端的应用程序、套接字或地址。一个流套接字只能连接一个对等。
- en: '*Datagram sockets* (`SOCK_DGRAM`) allow data to be exchanged in the form of
    messages called *datagrams*. With datagram sockets, message boundaries are preserved,
    but data transmission is not reliable. Messages may arrive out of order, be duplicated,
    or not arrive at all.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据报套接字*（`SOCK_DGRAM`）允许以名为*数据报*的消息形式交换数据。使用数据报套接字时，消息边界被保留，但数据传输不可靠。消息可能会乱序、重复，或者根本没有到达。'
- en: Datagram sockets are an example of the more generic concept of a *connectionless*
    socket. Unlike a stream socket, a datagram socket doesn’t need to be connected
    to another socket in order to be used. (In [Using *connect()* with Datagram Sockets](ch56.html#using_connect_open_parenthesis_close_par
    "Using connect() with Datagram Sockets"), we’ll see that datagram sockets may
    be connected with one another, but this has somewhat different semantics from
    connected stream sockets.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报套接字是*无连接*套接字这一更通用概念的一个例子。与流套接字不同，数据报套接字不需要连接到另一个套接字就能使用。（在[使用*connect()*与数据报套接字](ch56.html#using_connect_open_parenthesis_close_par
    "Using connect() with Datagram Sockets")中，我们将看到数据报套接字可以互相连接，但这与连接的流套接字语义上有所不同。）
- en: In the Internet domain, datagram sockets employ the User Datagram Protocol (UDP),
    and stream sockets (usually) employ the Transmission Control Protocol (TCP). Instead
    of using the terms *Internet domain datagram socket* and *Internet domain stream
    socket*, we’ll often just use the terms *UDP socket* and *TCP socket*, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网域中，数据报套接字使用用户数据报协议（UDP），而流套接字（通常）使用传输控制协议（TCP）。我们通常使用*UDP套接字*和*TCP套接字*这两个术语，而不是使用*互联网域数据报套接字*和*互联网域流套接字*。
- en: Socket system calls
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 套接字系统调用
- en: 'The key socket system calls are the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的套接字系统调用如下：
- en: The *socket()* system call creates a new socket.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*socket()*系统调用创建一个新的套接字。'
- en: The *bind()* system call binds a socket to an address. Usually, a server employs
    this call to bind its socket to a well-known address so that clients can locate
    the socket.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bind()*系统调用将套接字绑定到一个地址。通常，服务器使用此调用将其套接字绑定到一个知名地址，以便客户端可以定位该套接字。'
- en: The *listen()* system call allows a stream socket to accept incoming connections
    from other sockets.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*listen()*系统调用允许流套接字接受来自其他套接字的传入连接。'
- en: The *accept()* system call accepts a connection from a peer application on a
    listening stream socket, and optionally returns the address of the peer socket.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*accept()*系统调用接受监听流套接字上来自对等应用程序的连接，并可选择返回对等套接字的地址。'
- en: The *connect()* system call establishes a connection with another socket.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*connect()*系统调用与另一个套接字建立连接。'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On most Linux architectures (the exceptions include Alpha and IA-64), all of
    the sockets system calls are actually implemented as library functions multiplexed
    through a single system call, *socketcall()*. (This is an artifact of the original
    development of the Linux sockets implementation as a separate project.) Nevertheless,
    we refer to all of these functions as system calls in this book, since this is
    what they were in the original BSD implementation, as well as in many other contemporary
    UNIX implementations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 架构上（例外包括 Alpha 和 IA-64），所有套接字系统调用实际上都是通过单个系统调用*socketcall()*复用的库函数实现的（这是
    Linux 套接字实现作为单独项目的原始开发遗留的结果）。尽管如此，在本书中我们将所有这些函数称为系统调用，因为这是它们在原始 BSD 实现中以及许多其他当代
    UNIX 实现中的称呼。
- en: Socket I/O can be performed using the conventional *read()* and *write()* system
    calls, or using a range of socket-specific system calls (e.g., *send()*, *recv()*,
    *sendto()*, and *recvfrom()*). By default, these system calls block if the I/O
    operation can’t be completed immediately. Nonblocking I/O is also possible, by
    using the *fcntl()* `F_SETFL` operation ([Open File Status Flags](ch05.html#open_file_status_flags
    "Open File Status Flags")) to enable the `O_NONBLOCK` open file status flag.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用传统的*read()*和*write()*系统调用执行套接字 I/O，也可以使用一系列特定于套接字的系统调用（例如*send()*、*recv()*、*sendto()*和*recvfrom()*）。默认情况下，如果
    I/O 操作无法立即完成，这些系统调用将阻塞。也可以通过使用*fcntl()*的`F_SETFL`操作（[打开文件状态标志](ch05.html#open_file_status_flags
    "打开文件状态标志")）来启用`O_NONBLOCK`打开文件状态标志来进行非阻塞 I/O。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, we can call *ioctl(fd, FIONREAD, &cnt)* to obtain the number of unread
    bytes available on the stream socket referred to by the file descriptor *fd*.
    For a datagram socket, this operation returns the number of bytes in the next
    unread datagram (which may be zero if the next datagram is of zero length), or
    zero if there are no pending datagrams. This feature is not specified in SUSv3.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，我们可以调用*ioctl(fd, FIONREAD, &cnt)*来获取由文件描述符*fd*引用的流套接字上的未读字节数。对于数据报套接字，此操作返回下一个未读数据报中的字节数（如果下一个数据报长度为零，则可能为零），如果没有待处理的数据报则返回零。此功能未在
    SUSv3 中指定。
- en: 'Creating a Socket: *socket()*'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建套接字：*socket()*
- en: The *socket()* system call creates a new socket.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*socket()*系统调用创建一个新的套接字。'
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回-1。
- en: The *domain* argument specifies the communication domain for the socket. The
    *type* argument specifies the socket type. This argument is usually specified
    as either `SOCK_STREAM`, to create a stream socket, or `SOCK_DGRAM`, to create
    a datagram socket.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*domain*参数指定套接字的通信域。*type*参数指定套接字类型。此参数通常指定为`SOCK_STREAM`，以创建流套接字，或指定为`SOCK_DGRAM`，以创建数据报套接字。'
- en: The *protocol* argument is always specified as 0 for the socket types we describe
    in this book. Nonzero *protocol* values are used with some socket types that we
    don’t describe. For example, *protocol* is specified as `IPPROTO_RAW` for raw
    sockets (`SOCK_RAW`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*protocol*参数对于本书中描述的套接字类型总是指定为 0。非零的*protocol*值用于我们不描述的某些套接字类型。例如，对于原始套接字（`SOCK_RAW`），*protocol*指定为`IPPROTO_RAW`。'
- en: On success, *socket()* returns a file descriptor used to refer to the newly
    created socket in later system calls.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*socket()*返回用于在后续系统调用中引用新创建套接字的文件描述符。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.27, Linux provides a second use for the *type* argument,
    by allowing two nonstandard flags to be ORed with the socket type. The `SOCK_CLOEXEC`
    flag causes the kernel to enable the close-on-exec flag (`FD_CLOEXEC`) for the
    new file descriptor. This flag is useful for the same reasons as the *open()*
    `O_CLOEXEC` flag described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The SOCK_NONBLOCK flag causes the
    kernel to set the `O_NONBLOCK` flag on the underlying open file description, so
    that future I/O operations on the socket will be nonblocking. This saves additional
    calls to *fcntl()* to achieve the same result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.27 开始，Linux 为 *type* 参数提供了第二种用途，允许两个非标准标志与套接字类型进行按位或操作。`SOCK_CLOEXEC`
    标志使内核为新的文件描述符启用关闭时执行标志（`FD_CLOEXEC`）。这个标志的作用与 *open()* 中的 `O_CLOEXEC` 标志相同，详见[文件描述符号返回值
    *open()*](ch04.html#file_descriptor_number_returned_by-id1 "文件描述符号返回值 open()")。SOCK_NONBLOCK
    标志使内核为底层的打开文件描述符设置 `O_NONBLOCK` 标志，这样对套接字的未来 I/O 操作将变为非阻塞。这样就避免了额外调用 *fcntl()*
    来实现相同的效果。
- en: 'Binding a Socket to an Address: *bind()*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将套接字绑定到地址：*bind()*
- en: The *bind()* system call binds a socket to an address.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*bind()* 系统调用将一个套接字绑定到一个地址。'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *sockfd* argument is a file descriptor obtained from a previous call to
    *socket()*. The *addr* argument is a pointer to a structure specifying the address
    to which this socket is to be bound. The type of structure passed in this argument
    depends on the socket domain. The *addrlen* argument specifies the size of the
    address structure. The *socklen_t* data type used for the *addrlen* argument is
    an integer type specified by SUSv3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*sockfd* 参数是通过之前调用 *socket()* 获取的文件描述符。*addr* 参数是指向结构体的指针，该结构体指定了此套接字要绑定的地址。传入该参数的结构体类型取决于套接字的域。*addrlen*
    参数指定地址结构的大小。*socklen_t* 数据类型用于 *addrlen* 参数，是由 SUSv3 指定的整数类型。'
- en: Typically, we bind a server’s socket to a well-known address—that is, a fixed
    address that is known in advance to client applications that need to communicate
    with that server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将服务器的套接字绑定到一个著名地址——也就是说，绑定到一个客户端应用程序提前知道的固定地址，这样客户端才能与服务器进行通信。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other possibilities than binding a server’s socket to a well-known
    address. For example, for an Internet domain socket, the server could omit the
    call to *bind()* and simply call *listen()*, which causes the kernel to choose
    an ephemeral port for that socket. (We describe ephemeral ports in [Port Numbers](ch58.html#port_numbers
    "Port Numbers").) Afterward, the server can use *getsockname()* ([Retrieving Socket
    Addresses](ch61.html#retrieving_socket_addresses "Retrieving Socket Addresses"))
    to retrieve the address of its socket. In this scenario, the server must then
    publish that address so that clients know how to locate the server’s socket. Such
    publication could be done by registering the server’s address with a centralized
    directory service application that clients then contact in order to obtain the
    address. (For example, Sun RPC solves this problem using its *portmapper* server.)
    Of course, the directory service application’s socket must reside at a well-known
    address.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将服务器的套接字绑定到一个著名地址外，还有其他选择。例如，对于一个互联网域套接字，服务器可以省略对 *bind()* 的调用，直接调用 *listen()*，这会使内核为该套接字选择一个临时端口。（我们在[端口号](ch58.html#port_numbers
    "端口号")中描述了临时端口。）然后，服务器可以使用 *getsockname()*（[获取套接字地址](ch61.html#retrieving_socket_addresses
    "获取套接字地址")）来检索其套接字的地址。在这种情况下，服务器必须发布该地址，以便客户端能够找到服务器的套接字。此类发布可以通过将服务器地址注册到一个集中的目录服务应用程序来实现，客户端可以联系该服务来获取地址。（例如，Sun
    RPC 使用其 *portmapper* 服务器来解决这个问题。）当然，目录服务应用程序的套接字必须位于一个著名地址。
- en: 'Generic Socket Address Structures: *struct sockaddr*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用套接字地址结构：*struct sockaddr*
- en: 'The *addr* and *addrlen* arguments to *bind()* require some further explanation.
    Looking at [Table 56-1](ch56.html#socket_domains "Table 56-1. Socket domains"),
    we see that each socket domain uses a different address format. For example, UNIX
    domain sockets use pathnames, while Internet domain sockets use the combination
    of an IP address plus a port number. For each socket domain, a different structure
    type is defined to store a socket address. However, because system calls such
    as *bind()* are generic to all socket domains, they must be able to accept address
    structures of any type. In order to permit this, the sockets API defines a generic
    address structure, *struct sockaddr*. The only purpose for this type is to cast
    the various domain-specific address structures to a single type for use as arguments
    in the socket system calls. The *sockaddr* structure is typically defined as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*bind()*的*addr*和*addrlen*参数需要进一步解释。查看[表56-1](ch56.html#socket_domains "表56-1.
    套接字域")，我们可以看到每个套接字域使用不同的地址格式。例如，UNIX域套接字使用路径名，而互联网域套接字使用IP地址加端口号的组合。对于每个套接字域，定义了不同的结构类型来存储套接字地址。然而，由于像*bind()*这样的系统调用是通用的，适用于所有套接字域，因此它们必须能够接受任何类型的地址结构。为了实现这一点，套接字API定义了一个通用的地址结构*struct
    sockaddr*。该类型的唯一目的是将各种特定领域的地址结构转换为单一类型，以便在套接字系统调用中作为参数使用。*sockaddr*结构通常定义如下：'
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This structure serves as a template for all of the domain-specific address structures.
    Each of these address structures begins with a *family* field corresponding to
    the *sa_family* field of the *sockaddr* structure. (The *sa_family_t* data type
    is an integer type specified in SUSv3.) The value in the *family* field is sufficient
    to determine the size and format of the address stored in the remainder of the
    structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构作为所有特定领域地址结构的模板。每个地址结构都以*family*字段开始，该字段对应于*sockaddr*结构中的*sa_family*字段。（*sa_family_t*数据类型是SUSv3中指定的整数类型。）*family*字段中的值足以确定结构中其余部分存储的地址的大小和格式。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations also define an additional field in the *sockaddr*
    structure, *sa_len*, that specifies the total size of the structure. SUSv3 doesn’t
    require this field, and it is not present in the Linux implementation of the sockets
    API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现还在*sockaddr*结构中定义了一个附加字段*sa_len*，该字段指定了结构的总大小。SUSv3并不要求此字段，而且在Linux实现的套接字API中并不存在该字段。
- en: If we define the `_GNU_SOURCE` feature test macro, then *glibc* prototypes the
    various socket system calls in `<sys/socket.h>` using a *gcc* extension that eliminates
    the need for the *(struct sockaddr *)* cast. However, reliance on this feature
    is nonportable (it will result in compilation warnings on other systems).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义了`_GNU_SOURCE`特性测试宏，那么*glibc*会使用*gcc*扩展原型化各种套接字系统调用，在`<sys/socket.h>`中消除了*(struct
    sockaddr *)*类型转换的需要。然而，依赖于此特性是不可移植的（它会在其他系统上产生编译警告）。
- en: Stream Sockets
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式套接字
- en: 'The operation of stream sockets can be explained by analogy with the telephone
    system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 流式套接字的操作可以通过与电话系统类比来解释：
- en: The *socket()* system call, which creates a socket, is the equivalent of installing
    a telephone. In order for two applications to communicate, each of them must create
    a socket.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*socket()*系统调用用于创建一个套接字，相当于安装一部电话。为了让两个应用程序能够通信，每个应用程序都必须创建一个套接字。'
- en: 'Communication via a stream socket is analogous to a telephone call. One application
    must connect its socket to another application’s socket before communication can
    take place. Two sockets are connected as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过流式套接字的通信类似于电话通话。一个应用程序必须将它的套接字连接到另一个应用程序的套接字，才能进行通信。两个套接字的连接方式如下：
- en: One application calls *bind()* in order to bind the socket to a well-known address,
    and then calls *listen()* to notify the kernel of its willingness to accept incoming
    connections. This step is analogous to having a known telephone number and ensuring
    that our telephone is turned on so that people can call us.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个应用程序调用*bind()*来将套接字绑定到一个已知地址，然后调用*listen()*通知内核它愿意接受传入的连接。这个步骤类似于拥有一个已知的电话号码，并确保我们的电话处于开启状态，以便别人可以给我们打电话。
- en: The other application establishes the connection by calling *connect()*, specifying
    the address of the socket to which the connection is to be made. This is analogous
    to dialing someone’s telephone number.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个应用程序通过调用*connect()*建立连接，指定要连接的套接字地址。这相当于拨打某人的电话号码。
- en: The application that called *listen()* then accepts the connection using *accept()*.
    This is analogous to picking up the telephone when it rings. If the *accept()*
    is performed before the peer application calls *connect()*, then the *accept()*
    blocks (“waiting by the telephone”).
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*listen()*的应用程序随后使用*accept()*接受连接。这类似于接起电话当它响起。如果*accept()*在对端应用程序调用*connect()*之前执行，那么*accept()*会阻塞（“在电话旁等”）。
- en: Once a connection has been established, data can be transmitted in both directions
    between the applications (analogous to a two-way telephone conversation) until
    one of them closes the connection using *close()*. Communication is performed
    using the conventional *read()* and *write()* system calls or via a number of
    socket-specific system calls (such as *send()* and *recv()*) that provide additional
    functionality.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦建立了连接，数据可以在两个应用程序之间双向传输（类似于双向电话交谈），直到其中一个通过*close()*关闭连接。通信可以通过传统的*read()*和*write()*系统调用进行，或者通过一些特定于套接字的系统调用（如*send()*和*recv()*）来提供额外的功能。
- en: '[Figure 56-1](ch56.html#overview_of_system_calls_used_with_strea "Figure 56-1. Overview
    of system calls used with stream sockets") illustrates the use of the system calls
    used with stream sockets.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 56-1](ch56.html#overview_of_system_calls_used_with_strea "图 56-1. 流套接字使用的系统调用概览")展示了流套接字使用的系统调用。'
- en: Active and passive sockets
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主动套接字和被动套接字
- en: 'Stream sockets are often distinguished as being either active or passive:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字通常被区分为主动套接字和被动套接字：
- en: By default, a socket that has been created using *socket()* is *active*. An
    active socket can be used in a *connect()* call to establish a connection to a
    passive socket. This is referred to as performing an *active open*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，通过*socket()*创建的套接字是*主动*的。主动套接字可以在*connect()*调用中用于与被动套接字建立连接。这称为执行*主动打开*。
- en: A *passive* socket (also called a *listening* socket) is one that has been marked
    to allow incoming connections by calling *listen()*. Accepting an incoming connection
    is referred to as performing a *passive open*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*被动*套接字（也叫*监听*套接字）是通过调用*listen()*标记为允许传入连接的套接字。接受传入连接的过程称为执行*被动打开*。
- en: In most applications that employ stream sockets, the server performs the passive
    open, and the client performs the active open. We presume this scenario in subsequent
    sections, so that instead of saying “the application that performs the active
    socket open,” we’ll often just say “the client.” Similarly, we’ll equate “the
    server” with “the application that performs the passive socket open.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数使用流套接字的应用程序中，服务器执行被动打开，客户端执行主动打开。我们在后续章节中假定这种场景，因此我们会经常说“客户端”而不是“执行主动套接字打开的应用程序”。同样，我们将“服务器”与“执行被动套接字打开的应用程序”视为等同。
- en: '![Overview of system calls used with stream sockets](figs/web/56-1_SOCKINTRO-stream-overview-scale90.png.jpg)Figure 56-1. Overview
    of system calls used with stream sockets'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![流套接字使用的系统调用概览](figs/web/56-1_SOCKINTRO-stream-overview-scale90.png.jpg)图
    56-1. 流套接字使用的系统调用概览'
- en: 'Listening for Incoming Connections: *listen()*'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听传入连接：*listen()*
- en: The *listen()* system call marks the stream socket referred to by the file descriptor
    *sockfd* as *passive*. The socket will subsequently be used to accept connections
    from other (active) sockets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*listen()*系统调用将由文件描述符*sockfd*引用的流套接字标记为*被动*。该套接字随后将用于接受来自其他（主动）套接字的连接。'
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: We can’t apply *listen()* to a connected socket--that is, a socket on which
    a *connect()* has been successfully performed or a socket returned by a call to
    *accept()*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将*listen()*应用于一个已连接的套接字——即，已经成功执行过*connect()*的套接字，或者是通过*accept()*调用返回的套接字。
- en: To understand the purpose of the *backlog* argument, we first observe that the
    client may call *connect()* before the server calls *accept()*. This could happen,
    for example, because the server is busy handling some other client(s). This results
    in a *pending connection*, as illustrated in [Figure 56-2](ch56.html#a_pending_socket_connection
    "Figure 56-2. A pending socket connection").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解*backlog*参数的目的，我们首先观察到客户端可能会在服务器调用*accept()*之前调用*connect()*。例如，这种情况可能发生在服务器忙于处理其他客户端时。这就导致了一个*待处理连接*，如[图
    56-2](ch56.html#a_pending_socket_connection "图 56-2. 待处理的套接字连接")所示。
- en: '![A pending socket connection](figs/web/56-2_SOCKINTRO-unaccepted-connect-scale90.png.jpg)Figure 56-2. A
    pending socket connection'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![待处理的套接字连接](figs/web/56-2_SOCKINTRO-unaccepted-connect-scale90.png.jpg)图 56-2.
    待处理的套接字连接'
- en: The kernel must record some information about each pending connection request
    so that a subsequent *accept()* can be processed. The *backlog* argument allows
    us to limit the number of such pending connections. Connection requests up to
    this limit succeed immediately. (For TCP sockets, the story is a little more complicated,
    as we’ll see in [TCP Connection Establishment](ch61.html#tcp_connection_establishment
    "TCP Connection Establishment").) Further connection requests block until a pending
    connection is accepted (via *accept()*), and thus removed from the queue of pending
    connections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 内核必须记录每个待处理连接请求的一些信息，以便后续的 *accept()* 调用能够处理该请求。*backlog* 参数允许我们限制待处理连接的数量。直到此限制的连接请求会立即成功。（对于
    TCP 套接字，情况稍微复杂一些，正如我们在 [TCP 连接建立](ch61.html#tcp_connection_establishment "TCP
    连接建立") 中将看到的。）更多的连接请求会被阻塞，直到一个待处理连接被接受（通过 *accept()*），从而将其从待处理连接队列中移除。
- en: SUSv3 allows an implementation to place an upper limit on the value that can
    be specified for *backlog*, and permits an implementation to silently round *backlog*
    values down to this limit. SUSv3 specifies that the implementation should advertise
    this limit by defining the constant `SOMAXCONN` in `<sys/socket.h>`. On Linux,
    this constant is defined with the value 128\. However, since kernel 2.4.25, Linux
    allows this limit to be adjusted at run time via the Linux-specific `/proc/sys/net/core/somaxconn`
    file. (In earlier kernel versions, the `SOMAXCONN` limit is immutable.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 允许实现对 *backlog* 参数指定的值施加上限，并允许实现将 *backlog* 值默默地向下舍入到这个上限。SUSv3 规定实现应通过在
    `<sys/socket.h>` 中定义常量 `SOMAXCONN` 来声明这一限制。在 Linux 上，这个常量的值为 128。然而，自内核版本 2.4.25
    起，Linux 允许通过 Linux 特定的 `/proc/sys/net/core/somaxconn` 文件在运行时调整这个上限。（在早期内核版本中，`SOMAXCONN`
    限制是不可变的。）
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the original BSD sockets implementation, the upper limit for *backlog* was
    5, and we may see this number specified in older code. All modern implementations
    allow higher values of *backlog*, which are necessary for network servers employing
    TCP sockets to serve large numbers of clients.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 BSD 套接字实现中，*backlog* 的上限为 5，且我们可能会在旧代码中看到这个值。所有现代实现都允许更高的 *backlog* 值，这对于使用
    TCP 套接字的网络服务器来说是必要的，以便服务大量客户端。
- en: 'Accepting a Connection: *accept()*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受连接：*accept()*
- en: The *accept()* system call accepts an incoming connection on the listening stream
    socket referred to by the file descriptor *sockfd*. If there are no pending connections
    when *accept()* is called, the call blocks until a connection request arrives.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*accept()* 系统调用接受通过文件描述符 *sockfd* 引用的监听流套接字上的传入连接。如果在调用 *accept()* 时没有待处理的连接，请求会被阻塞，直到有连接请求到达。'
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1
- en: The key point to understand about *accept()* is that it creates a *new* socket,
    and it is this new socket that is connected to the peer socket that performed
    the *connect()*. A file descriptor for the connected socket is returned as the
    function result of the *accept()* call. The listening socket (*sockfd*) remains
    open, and can be used to accept further connections. A typical server application
    creates one listening socket, binds it to a well-known address, and then handles
    all client requests by accepting connections via that socket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 *accept()* 的关键点是，它创建了一个*新的*套接字，并且正是这个新套接字与执行了 *connect()* 的对等方套接字建立了连接。连接的套接字的文件描述符作为
    *accept()* 调用的返回结果返回。监听套接字 (*sockfd*) 保持打开状态，可以用来接受进一步的连接。一个典型的服务器应用会创建一个监听套接字，将其绑定到一个已知的地址，然后通过该套接字处理所有客户端请求。
- en: The remaining arguments to *accept()* return the address of the peer socket.
    The *addr* argument points to a structure that is used to return the socket address.
    The type of this argument depends on the socket domain (as for *bind()*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*accept()* 的其余参数返回对等方套接字的地址。*addr* 参数指向一个结构，用于返回套接字地址。该参数的类型取决于套接字域（如同 *bind()*）。'
- en: The *addrlen* argument is a value-result argument. It points to an integer that,
    prior to the call, must be initialized to the size of the buffer pointed to by
    *addr*, so that the kernel knows how much space is available to return the socket
    address. Upon return from *accept()*, this integer is set to indicate the number
    of bytes of data actually copied into the buffer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*addrlen* 参数是一个值-结果参数。它指向一个整数，在调用之前，必须初始化为 *addr* 所指向的缓冲区的大小，以便内核知道可用空间的大小以返回套接字地址。在从
    *accept()* 返回时，这个整数会被设置为实际复制到缓冲区的数据字节数。'
- en: If we are not interested in the address of the peer socket, then *addr* and
    *addrlen* should be specified as `NULL` and 0, respectively. (If desired, we can
    retrieve the peer’s address later using the *getpeername()* system call, as described
    in Section 61.5.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关心对等套接字的地址，则应将*addr*和*addrlen*分别指定为`NULL`和0。（如果需要，我们可以稍后使用*getpeername()*系统调用获取对等地址，如第61.5节所述。）
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Starting with kernel 2.6.28, Linux supports a new, nonstandard system call,
    *accept4()*. This system call performs the same task as *accept()*, but supports
    an additional argument, *flags*, that can be used to modify the behavior of the
    system call. Two flags are supported: `SOCK_CLOEXEC` and `SOCK_NONBLOCK`. The
    `SOCK_CLOEXEC` flag causes the kernel to enable the close-on-exec flag (`FD_CLOEXEC`)
    for the new file descriptor returned by the call. This flag is useful for the
    same reasons as the *open()* `O_CLOEXEC` flag described in [File descriptor number
    returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1 "File descriptor
    number returned by open()"). The `SOCK_NONBLOCK` flag causes the kernel to enable
    the `O_NONBLOCK` flag on the underlying open file description, so that future
    I/O operations on the socket will be nonblocking. This saves additional calls
    to *fcntl()* to achieve the same result.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本2.6.28开始，Linux支持一种新的非标准系统调用，*accept4()*。该系统调用执行与*accept()*相同的任务，但支持一个额外的参数*flags*，可以用来修改系统调用的行为。支持两个标志：`SOCK_CLOEXEC`和`SOCK_NONBLOCK`。`SOCK_CLOEXEC`标志使内核为由该调用返回的新文件描述符启用close-on-exec标志（`FD_CLOEXEC`）。该标志与在[*open()*返回的文件描述符编号](ch04.html#file_descriptor_number_returned_by-id1
    "open()返回的文件描述符编号")中描述的*open()* `O_CLOEXEC`标志有相同的作用。`SOCK_NONBLOCK`标志使内核在底层打开的文件描述上启用`O_NONBLOCK`标志，从而使套接字的未来I/O操作为非阻塞。这避免了多次调用*fcntl()*来实现相同的效果。
- en: 'Connecting to a Peer Socket: *connect()*'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到对等套接字：*connect()*
- en: The *connect()* system call connects the active socket referred to by the file
    descriptor *sockfd* to the listening socket whose address is specified by *addr*
    and *addrlen*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*connect()*系统调用将由文件描述符*sockfd*引用的活动套接字连接到由*addr*和*addrlen*指定的监听套接字。'
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1
- en: The *addr* and *addrlen* arguments are specified in the same way as the corresponding
    arguments to *bind()*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*addr*和*addrlen*参数的指定方式与*bind()*的相应参数相同。'
- en: If *connect()* fails and we wish to reattempt the connection, then SUSv3 specifies
    that the portable method of doing so is to close the socket, create a new socket,
    and reattempt the connection with the new socket.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*connect()*失败，并且我们希望重新尝试连接，那么SUSv3指定的便捷方法是关闭套接字，创建一个新套接字，并使用新套接字重新尝试连接。
- en: I/O on Stream Sockets
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流套接字的I/O
- en: A pair of connected stream sockets provides a bidirectional communication channel
    between the two endpoints. [Figure 56-3](ch56.html#unix_domain_stream_sockets_provide_a_bid
    "Figure 56-3. UNIX domain stream sockets provide a bidirectional communication
    channel") shows what this looks like in the UNIX domain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一对连接的流套接字提供了一个在两个端点之间的双向通信通道。[图56-3](ch56.html#unix_domain_stream_sockets_provide_a_bid
    "图56-3. UNIX域流套接字提供双向通信通道")展示了在UNIX域中这种结构的样子。
- en: '![UNIX domain stream sockets provide a bidirectional communication channel](figs/web/56-3_SOCKINTRO-unix-connected-scale90.png.jpg)Figure 56-3. UNIX
    domain stream sockets provide a bidirectional communication channel'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![UNIX域流套接字提供双向通信通道](figs/web/56-3_SOCKINTRO-unix-connected-scale90.png.jpg)图56-3.
    UNIX域流套接字提供双向通信通道'
- en: 'The semantics of I/O on connected stream sockets are similar to those for pipes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 连接流套接字的I/O语义类似于管道的I/O：
- en: 'To perform I/O, we use the *read()* and *write()* system calls (or the socket-specific
    *send()* and *recv()*, which we describe in [Socket-Specific I/O System Calls:
    *recv()* and *send()*](ch61.html#socket-specific_i_solidus_o_system_calls "Socket-Specific
    I/O System Calls: recv() and send()")). Since sockets are bidirectional, both
    calls may be used on each end of the connection.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行I/O操作，我们使用*read()*和*write()*系统调用（或特定于套接字的*send()*和*recv()*，这些我们在[套接字特定的I/O系统调用：*recv()*和*send()*](ch61.html#socket-specific_i_solidus_o_system_calls
    "套接字特定的I/O系统调用：recv()和send()")中描述）。由于套接字是双向的，因此可以在连接的两端使用这两种调用。
- en: A socket may be closed using the *close()* system call or as a consequence of
    the application terminating. Afterward, when the peer application attempts to
    read from the other end of the connection, it receives end-of-file (once all buffered
    data has been read). If the peer application attempts to write to its socket,
    it receives a `SIGPIPE` signal, and the system call fails with the error `EPIPE`.
    As we noted in [Creating and Using Pipes](ch44.html#creating_and_using_pipes "Creating
    and Using Pipes"), the usual way of dealing with this possibility is to ignore
    the `SIGPIPE` signal and find out about the closed connection via the `EPIPE`
    error.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用*close()*系统调用关闭套接字，或者由于应用程序终止而关闭套接字。之后，当对端应用程序尝试从连接的另一端读取数据时，它会收到文件结束标志（当所有缓冲数据已被读取时）。如果对端应用程序尝试向其套接字写入数据，则会收到`SIGPIPE`信号，系统调用将以`EPIPE`错误失败。如我们在[创建和使用管道](ch44.html#creating_and_using_pipes
    "创建和使用管道")中所述，通常处理这种情况的方法是忽略`SIGPIPE`信号，并通过`EPIPE`错误获知连接已关闭。
- en: 'Connection Termination: *close()*'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接终止：*close()*
- en: The usual way of terminating a stream socket connection is to call *close()*.
    If multiple file descriptors refer to the same socket, then the connection is
    terminated when all of the descriptors are closed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 终止流套接字连接的通常方法是调用*close()*。如果多个文件描述符引用同一个套接字，则当所有描述符关闭时，连接将被终止。
- en: Suppose that, after we close a connection, the peer application crashes or otherwise
    fails to read or correctly process the data that we previously sent to it. In
    this case, we have no way of knowing that an error occurred. If we need to ensure
    that the data was successfully read and processed, then we must build some type
    of acknowledgement protocol into our application. This normally consists of an
    explicit acknowledgement message passed back to us from the peer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们关闭连接后，对端应用程序崩溃或未能正确读取或处理我们之前发送的数据。在这种情况下，我们无法知道发生了错误。如果我们需要确保数据已成功读取和处理，那么我们必须在应用程序中构建某种类型的确认协议。通常，这包括从对端返回的显式确认消息。
- en: In [The *shutdown()* System Call](ch61.html#the_shutdown_open_parenthesis_close_pare
    "The shutdown() System Call"), we describe the *shutdown()* system call, which
    provides finer control of how a stream socket connection is closed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*shutdown()*系统调用](ch61.html#the_shutdown_open_parenthesis_close_pare "shutdown()
    系统调用")中，我们描述了*shutdown()*系统调用，它提供了更精细的控制方式，来关闭流套接字连接。
- en: Datagram Sockets
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据报套接字
- en: 'The operation of datagram sockets can be explained by analogy with the postal
    system:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报套接字的操作可以通过与邮政系统的类比来解释：
- en: The *socket()* system call is the equivalent of setting up a mailbox. (Here,
    we assume a system like the rural postal service in some countries, which both
    picks up letters from and delivers letters to the mailbox.) Each application that
    wants to send or receive datagrams creates a datagram socket using *socket()*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*socket()*系统调用相当于设置一个邮箱。（这里，我们假设一个类似某些国家农村邮政服务的系统，它既能从邮箱中取信，也能将信投递到邮箱。）每个想要发送或接收数据报的应用程序都使用*socket()*创建一个数据报套接字。'
- en: In order to allow another application to send it datagrams (letters), an application
    uses *bind()* to bind its socket to a well-known address. Typically, a server
    binds its socket to a well-known address, and a client initiates communication
    by sending a datagram to that address. (In some domains--notably the UNIX domain--the
    client may also need to use *bind()* to assign an address to its socket if it
    wants to receive datagrams sent by the server.)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让另一个应用程序发送数据报（信件）到该应用程序，应用程序使用*bind()*将其套接字绑定到一个知名地址。通常，服务器将其套接字绑定到一个知名地址，而客户端则通过向该地址发送数据报来启动通信。（在某些领域——特别是UNIX领域——如果客户端希望接收服务器发送的数据报，它可能也需要使用*bind()*为其套接字分配一个地址。）
- en: To send a datagram, an application calls *sendto()*, which takes as one of its
    arguments the address of the socket to which the datagram is to be sent. This
    is analogous to putting the recipient’s address on a letter and posting it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送数据报，应用程序调用*sendto()*，它的一个参数是数据报将被发送到的套接字地址。这类似于在信件上写上收件人的地址并邮寄出去。
- en: In order to receive a datagram, an application calls *recvfrom()*, which may
    block if no datagram has yet arrived. Because *recvfrom()* allows us to obtain
    the address of the sender, we can send a reply if desired. (This is useful if
    the sender’s socket is bound to an address that is not well known, which is typical
    of a client.) Here, we stretch the analogy a little, since there is no requirement
    that a posted letter is marked with the sender’s address.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了接收数据报，应用程序调用*recvfrom()*，如果没有数据报到达，它可能会阻塞。因为*recvfrom()*允许我们获取发送方的地址，我们可以根据需要发送回复。（如果发送方的套接字绑定到一个不常见的地址，这通常发生在客户端中，便非常有用。）这里我们稍微扩展了一下类比，因为没有要求投递的信件上必须标明发送方的地址。
- en: When the socket is no longer needed, the application closes it using *close()*.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不再需要套接字时，应用程序使用*close()*关闭它。
- en: 'Just as with the postal system, when multiple datagrams (letters) are sent
    from one address to another, there is no guarantee that they will arrive in the
    order they were sent, or even arrive at all. Datagrams add one further possibility
    not present in the postal system: since the underlying networking protocols may
    sometimes retransmit a data packet, the same datagram could arrive more than once.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像邮政系统一样，当从一个地址发送多个数据报（信件）到另一个地址时，并不能保证它们按发送顺序到达，甚至可能完全无法到达。数据报还增加了邮政系统中不存在的一种可能性：由于底层的网络协议有时会重新传输数据包，同一个数据报可能会到达多次。
- en: '[Figure 56-4](ch56.html#overview_of_system_calls_used_with_datag "Figure 56-4. Overview
    of system calls used with datagram sockets") illustrates the use of the system
    calls employed with datagram sockets.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图56-4](ch56.html#overview_of_system_calls_used_with_datag "图56-4. 使用数据报套接字的系统调用概览")展示了与数据报套接字一起使用的系统调用。'
- en: '![Overview of system calls used with datagram sockets](figs/web/56-4_SOCKINTRO-datagram-overview-scale90.png.jpg)Figure 56-4. Overview
    of system calls used with datagram sockets'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用数据报套接字的系统调用概览](figs/web/56-4_SOCKINTRO-datagram-overview-scale90.png.jpg)图56-4.
    使用数据报套接字的系统调用概览'
- en: 'Exchanging Datagrams: *recvfrom()* and *sendto()*'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交换数据报：*recvfrom()*和*sendto()*
- en: The *recvfrom()* and *sendto()* system calls receive and send datagrams on a
    datagram socket.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*recvfrom()*和*sendto()*系统调用用于在数据报套接字上接收和发送数据报。'
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes received, 0 on EOF, or -1 on error
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 返回接收到的字节数，EOF时返回0，错误时返回-1。
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes sent, or -1 on error
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回发送的字节数，错误时返回-1。
- en: The return value and the first three arguments to these system calls are the
    same as for *read()* and *write()*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用的返回值和前三个参数与*read()*和*write()*相同。
- en: The fourth argument, *flags*, is a bit mask controlling socket-specific I/O
    features. We cover these features when we describe the *recv()* and *send()* system
    calls in Section 61.3\. If we don’t require any of these features, we can specify
    *flags* as 0.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个参数*flags*是一个位掩码，用于控制特定于套接字的I/O特性。我们将在第61.3节描述*recv()*和*send()*系统调用时详细介绍这些特性。如果不需要这些特性，可以将*flags*指定为0。
- en: The *src_addr* and *addrlen* arguments are used to obtain or specify the address
    of the peer socket with which we are communicating.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*src_addr*和*addrlen*参数用于获取或指定与我们通信的对等方套接字的地址。'
- en: For *recvfrom()*, the *src_addr* and *addrlen* arguments return the address
    of the remote socket used to send the datagram. (These arguments are analogous
    to the *addr* and *addrlen* arguments of *accept()*, which return the address
    of a connecting peer socket.) The *src_addr* argument is a pointer to an address
    structure appropriate to the communication domain. As with *accept()*, *addrlen*
    is a value-result argument. Prior to the call, *addrlen* should be initialized
    to the size of the structure pointed to by *src_addr*; upon return, it contains
    the number of bytes actually written to this structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*recvfrom()*，*src_addr*和*addrlen*参数返回用于发送数据报的远程套接字地址。（这些参数类似于*accept()*的*addr*和*addrlen*参数，后者返回连接的对等方套接字的地址。）*src_addr*参数是指向适用于通信域的地址结构的指针。与*accept()*一样，*addrlen*是一个值结果参数。在调用之前，*addrlen*应初始化为*src_addr*所指向结构的大小；返回时，它包含实际写入该结构的字节数。
- en: If we are not interested in the address of the sender, then we specify both
    *src_addr* and *addrlen* as `NULL`. In this case, *recvfrom()* is equivalent to
    using *recv()* to receive a datagram. We can also use *read()* to read a datagram,
    which is equivalent to using *recv()* with a *flags* argument of 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关心发送方的地址，那么我们可以将*src_addr*和*addrlen*都指定为`NULL`。在这种情况下，*recvfrom()*等同于使用*recv()*接收数据报。我们也可以使用*read()*来读取数据报，这等同于使用*recv()*并将*flags*参数设置为0。
- en: Regardless of the value specified for *length*, *recvfrom()* retrieves exactly
    one message from a datagram socket. If the size of that message exceeds *length*
    bytes, the message is silently truncated to *length* bytes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 *length* 的值指定为何，*recvfrom()* 都会从数据报套接字中检索到一个消息。如果该消息的大小超过 *length* 字节，消息会被默默地截断为
    *length* 字节。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we employ the *recvmsg()* system call ([The *sendmsg()* and *recvmsg()* System
    Calls](ch61.html#the_sendmsg_open_parenthesis_close_paren "The sendmsg() and recvmsg()
    System Calls")), then it is possible to find out about a truncated datagram via
    the `MSG_TRUNC` flag returned in the *msg_flags* field of the returned *msghdr*
    structure. See the *recvmsg(2)* manual page for details.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 *recvmsg()* 系统调用（[*sendmsg()* 和 *recvmsg()* 系统调用](ch61.html#the_sendmsg_open_parenthesis_close_paren
    "The sendmsg() and recvmsg() System Calls")），则可以通过返回的 *msghdr* 结构中的 *msg_flags*
    字段中的 `MSG_TRUNC` 标志来得知一个被截断的数据报。详细信息请参见 *recvmsg(2)* 手册页。
- en: For *sendto()*, the *dest_addr* and *addrlen* arguments specify the socket to
    which the datagram is to be sent. These arguments are employed in the same manner
    as the corresponding arguments to *connect()*. The *dest_addr* argument is an
    address structure suitable for this communication domain. It is initialized with
    the address of the destination socket. The *addrlen* argument specifies the size
    of *addr*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *sendto()*，*dest_addr* 和 *addrlen* 参数指定要发送数据报的套接字。这些参数的使用方式与 *connect()*
    的对应参数相同。*dest_addr* 参数是一个适用于此通信域的地址结构。它初始化为目标套接字的地址。*addrlen* 参数指定 *addr* 的大小。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, it is possible to use *sendto()* to send datagrams of length 0\. However,
    not all UNIX implementations permit this.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，使用 *sendto()* 可以发送长度为 0 的数据报。然而，并不是所有 UNIX 实现都允许这样做。
- en: Using *connect()* with Datagram Sockets
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 *connect()* 与数据报套接字
- en: Even though datagram sockets are connectionless, the *connect()* system call
    serves a purpose when applied to datagram sockets. Calling *connect()* on a datagram
    socket causes the kernel to record a particular address as this socket’s peer.
    The term *connected datagram socket* is applied to such a socket. The term *unconnected
    datagram socket* is applied to a datagram socket on which *connect()* has not
    been called (i.e., the default for a new datagram socket).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据报套接字是无连接的，*connect()* 系统调用在应用于数据报套接字时仍然有其作用。在数据报套接字上调用 *connect()* 会导致内核记录一个特定的地址作为该套接字的对等方。此时，称该套接字为
    *连接数据报套接字*。对于未调用 *connect()* 的数据报套接字（即新建数据报套接字的默认状态），则称其为 *未连接数据报套接字*。
- en: 'After a datagram socket has been connected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据报套接字连接后：
- en: Datagrams can be sent through the socket using *write()* (or *send()*) and are
    automatically sent to the same peer socket. As with *sendto()*, each *write()*
    call results in a separate datagram.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过套接字使用 *write()*（或 *send()*）发送数据报，并且数据会自动发送到同一对等方套接字。与 *sendto()* 一样，每次调用
    *write()* 都会生成一个独立的数据报。
- en: Only datagrams sent by the peer socket may be read on the socket.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有通过对等方套接字发送的数据报可以在该套接字上读取。
- en: Note that the effect of *connect()* is asymmetric for datagram sockets. The
    above statements apply only to the socket on which *connect()* has been called,
    not to the remote socket to which it is connected (unless the peer application
    also calls *connect()* on its socket).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*connect()* 对数据报套接字的作用是非对称的。上述语句仅适用于调用了 *connect()* 的套接字，而不适用于其连接的远程套接字（除非对等方应用程序也在其套接字上调用了
    *connect()*）。
- en: We can change the peer of a connected datagram socket by issuing a further *connect()*
    call. It is also possible to dissolve the peer association altogether by specifying
    an address structure in which the address family (e.g., the *sun_family* field
    in the UNIX domain) is specified as `AF_UNSPEC`. Note, however, that many other
    UNIX implementations don’t support the use of `AF_UNSPEC` for this purpose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出进一步的 *connect()* 调用来更改已连接数据报套接字的对等方。还可以通过指定一个地址结构，在该结构中地址族（例如 UNIX 域中的
    *sun_family* 字段）指定为 `AF_UNSPEC`，完全解除对等方关联。然而，请注意，许多其他 UNIX 实现不支持将 `AF_UNSPEC`
    用于此目的。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 was somewhat vague about dissolving peer associations, stating that a
    connection can be reset by making a *connect()* call that specifies a “null address,”
    without defining that term. SUSv4 explicitly specifies the use of `AF_UNSPEC`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 对解除对等方关联的描述较为模糊，指出可以通过调用指定“空地址”的 *connect()* 来重置连接，但没有定义该术语。SUSv4 明确指定了使用
    `AF_UNSPEC`。
- en: The obvious advantage of setting the peer for a datagram socket is that we can
    use simpler I/O system calls when transmitting data on the socket. We no longer
    need to use *sendto()* with *dest_addr* and *addrlen* arguments, but can instead
    use *write()*. Setting the peer is useful primarily in an application that needs
    to send multiple datagrams to a single peer (which is typical of some datagram
    clients).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 datagram 套接字的对等地址的明显优势是，在通过套接字传输数据时，我们可以使用更简单的 I/O 系统调用。我们不再需要使用带有 *dest_addr*
    和 *addrlen* 参数的 *sendto()*，而可以使用 *write()*。设置对等地址主要用于需要向单个对等体发送多个 datagram 的应用程序（这在某些
    datagram 客户端中很常见）。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On some TCP/IP implementations, connecting a datagram socket to a peer yields
    a performance improvement ([Stevens et al., 2004]). On Linux, connecting a datagram
    socket makes little difference to performance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 TCP/IP 实现中，将 datagram 套接字连接到对等体可以提高性能（[Stevens et al., 2004]）。在 Linux 上，连接
    datagram 套接字对性能几乎没有影响。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Sockets allow communication between applications on the same host or on different
    hosts connected via a network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字允许同一主机或通过网络连接的不同主机之间进行通信。
- en: A socket exists within a communication domain, which determines the range of
    communication and the address format used to identify the socket. SUSv3 specifies
    the UNIX (`AF_UNIX`), IPv4 (`AF_INET`), and IPv6 (`AF_INET6`) communication domains.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字存在于一个通信域内，该域决定了通信的范围和用于标识套接字的地址格式。SUSv3 定义了 UNIX（`AF_UNIX`）、IPv4（`AF_INET`）和
    IPv6（`AF_INET6`）通信域。
- en: 'Most applications use one of two socket types: stream or datagram. Stream sockets
    (`SOCK_STREAM`) provide a reliable, bidirectional, byte-stream communication channel
    between two endpoints. Datagram sockets (`SOCK_DGRAM`) provide unreliable, connectionless,
    message-oriented communication.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用两种套接字类型之一：流套接字或 datagram 套接字。流套接字（`SOCK_STREAM`）提供一个可靠的、双向的字节流通信通道，连接两个端点。Datagram
    套接字（`SOCK_DGRAM`）提供不可靠的、无连接的、面向消息的通信。
- en: A typical stream socket server creates its socket using *socket()*, and then
    binds the socket to a well-known address using *bind()*. The server then calls
    *listen()* to allow connections to be received on the socket. Each client connection
    is then accepted on the listening socket using *accept()*, which returns a file
    descriptor for a new socket that is connected to the client’s socket. A typical
    stream socket client creates a socket using *socket()*, and then establishes a
    connection by calling *connect()*, specifying the server’s well-known address.
    After two stream sockets are connected, data can be transferred in either direction
    using *read()* and *write()*. Once all processes with a file descriptor referring
    to a stream socket endpoint have performed an implicit or explicit *close()*,
    the connection is terminated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的流套接字服务器使用 *socket()* 创建套接字，然后使用 *bind()* 将套接字绑定到一个知名地址。服务器接着调用 *listen()*
    来允许接收连接。每个客户端连接随后通过 *accept()* 在监听套接字上被接受，该调用返回一个文件描述符，该描述符对应一个与客户端套接字连接的新套接字。一个典型的流套接字客户端使用
    *socket()* 创建一个套接字，然后通过调用 *connect()* 建立连接，指定服务器的知名地址。两者的流套接字连接后，可以使用 *read()*
    和 *write()* 双向传输数据。一旦所有引用流套接字端点的文件描述符的进程都执行了隐式或显式的 *close()*，连接就会终止。
- en: A typical datagram socket server creates a socket using *socket()*, and then
    binds it to a well-known address using *bind()*. Because datagram sockets are
    connectionless, the server’s socket can be used to receive datagrams from any
    client. Datagrams can be received using *read()* or using the socket-specific
    *recvfrom()* system call, which returns the address of the sending socket. A datagram
    socket client creates a socket using *socket()*, and then uses *sendto()* to send
    a datagram to a specified (i.e., the server’s) address. The *connect()* system
    call can be used with a datagram socket to set a peer address for the socket.
    After doing this, it is no longer necessary to specify the destination address
    for outgoing datagrams; a *write()* call can be used to send a datagram.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 datagram 套接字服务器使用 *socket()* 创建一个套接字，然后使用 *bind()* 将其绑定到一个知名地址。由于 datagram
    套接字是无连接的，服务器的套接字可以用来接收来自任何客户端的 datagram。可以通过 *read()* 或使用特定于套接字的 *recvfrom()*
    系统调用来接收 datagram，后者返回发送套接字的地址。一个 datagram 套接字客户端使用 *socket()* 创建一个套接字，然后使用 *sendto()*
    向指定的（即服务器的）地址发送 datagram。*connect()* 系统调用可以与 datagram 套接字一起使用，为套接字设置对等地址。完成此操作后，不再需要为传出的
    datagram 指定目标地址；可以使用 *write()* 调用发送 datagram。
- en: Further information
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[进一步信息](ch59.html#further_information-id81 "Further Information")中列出的相关资料来源。
