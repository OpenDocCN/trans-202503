- en: 'Chapter 56. Sockets: Introduction'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sockets are a method of IPC that allow data to be exchanged between applications,
    either on the same host (computer) or on different hosts connected by a network.
    The first widespread implementation of the sockets API appeared with 4.2BSD in
    1983, and this API has been ported to virtually every UNIX implementation, as
    well as most other operating systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sockets API is formally specified in POSIX.1g, which was ratified in 2000
    after spending about a decade as a draft standard. This standard has been superseded
    by SUSv3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter and the following chapters describe the use of sockets, as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a general introduction to the sockets API. The following
    chapters assume an understanding of the general concepts presented here. We don’t
    present any example code in this chapter. Code examples in the UNIX and Internet
    domains are presented in the following chapters.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 57](ch57.html "Chapter 57. Sockets: UNIX Domain") describes UNIX domain
    sockets, which allow communication between applications on the same host system.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 58](ch58.html "Chapter 58. Sockets: Fundamentals of TCP/IP Networks")
    introduces various computer networking concepts and describes key features of
    the TCP/IP networking protocols. It provides background needed for the next chapters.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 59](ch59.html "Chapter 59. Sockets: Internet Domains") describes Internet
    domain sockets, which allow applications on different hosts to communicate via
    a TCP/IP network.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 60](ch60.html "Chapter 60. Sockets: Server Design") discusses the
    design of servers that use sockets.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 61](ch61.html "Chapter 61. Sockets: Advanced Topics") covers a range
    of advanced topics, including additional features for socket I/O, a more detailed
    look at the TCP protocol, and the use of socket options to retrieve and modify
    various attributes of sockets.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These chapters merely aim to give the reader a good grounding in the use of
    sockets. Sockets programming, especially for network communication, is an enormous
    topic in its own right, and forms the subject of entire books. Sources of further
    information are listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a typical client-server scenario, applications communicate using sockets
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Each application creates a socket. A socket is the “apparatus” that allows communication,
    and both applications require one.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server binds its socket to a well-known address (name) so that clients can
    locate it.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A socket is created using the *socket()* system call, which returns a file
    descriptor used to refer to the socket in subsequent system calls:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We describe socket domains and types in the following paragraphs. For all applications
    described in this book, *protocol* is always specified as 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Communication domains
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sockets exist in a *communication domain*, which determines:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: the method of identifying a socket (i.e., the format of a socket “address”);
    and
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the range of communication (i.e., either between applications on the same host
    or between applications on different hosts connected via a network).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modern operating systems support at least the following domains:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The *UNIX* (`AF_UNIX`) domain allows communication between applications on the
    same host. (POSIX.1g used the name `AF_LOCAL` as a synonym for `AF_UNIX`, but
    this name is not used in SUSv3.)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *IPv4* (`AF_INET`) domain allows communication between applications running
    on hosts connected via an Internet Protocol version 4 (IPv4) network.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *IPv6* (`AF_INET6`) domain allows communication between applications running
    on hosts connected via an Internet Protocol version 6 (IPv6) network. Although
    IPv6 is designed as the successor to IPv4, the latter protocol is currently still
    the most widely used.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 56-1](ch56.html#socket_domains "Table 56-1. Socket domains") summarizes
    the characteristics of these socket domains.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some code, we may see constants with names such as `PF_UNIX` instead of `AF_UNIX`.
    In this context, `AF` stands for “address family” and `PF` stands for “protocol
    family.” Initially, it was conceived that a single protocol family might support
    multiple address families. In practice, no protocol family supporting multiple
    address families has ever been defined, and all existing implementations define
    the `PF_` constants to be synonymous with the corresponding `AF_` constants. (SUSv3
    specifies the `AF_` constants, but not the `PF_` constants.) In this book, we
    always use the `AF_` constants. Further information about the history of these
    constants can be found in [Universality of I/O](ch04.html#universality_of_i_solidus_o
    "Universality of I/O") of [Stevens et al., 2004].
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Table 56-1. Socket domains
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '| Domain | Communication performed | Communication between applications | Address
    format | Address structure |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `AF_UNIX` | within kernel | on same host | pathname | *sockaddr_un* |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `AF_INET` | via IPv4 | on hosts connected via an IPv4 network | 32-bit IPv4
    address + 16-bit port number | *sockaddr_in* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `AF_INET6` | via IPv6 | on hosts connected via an IPv6 network | 128-bit
    IPv6 address + 16-bit port number | *sockaddr_in6* |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: Socket types
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every sockets implementation provides at least two types of sockets: stream
    and datagram. These socket types are supported in both the UNIX and the Internet
    domains. [Table 56-2](ch56.html#socket_types_and_their_properties "Table 56-2. Socket
    types and their properties") summarizes the properties of these socket types.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Table 56-2. Socket types and their properties
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Socket type |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| Stream | Datagram |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| Reliable delivery? | Y | N |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| Message boundaries preserved? | N | Y |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| Connection-oriented? | Y | N |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '*Stream sockets* (`SOCK_STREAM`) provide a reliable, bidirectional, byte-stream
    communication channel. By the terms in this description, we mean the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '*Reliable* means that we are guaranteed that either the transmitted data will
    arrive intact at the receiving application, exactly as it was transmitted by the
    sender (assuming that neither the network link nor the receiver crashes), or that
    we’ll receive notification of a probable failure in transmission.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bidirectional* means that data may be transmitted in either direction between
    two sockets.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Byte-stream* means that, as with pipes, there is no concept of message boundaries
    (refer to [Overview](ch44.html#overview-id11 "Overview")).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stream socket is similar to using a pair of pipes to allow bidirectional communication
    between two applications, with the difference that (Internet domain) sockets permit
    communication over a network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Stream sockets operate in connected pairs. For this reason, stream sockets are
    described as *connection-oriented*. The term *peer socket* refers to the socket
    at the other end of a connection; *peer address* denotes the address of that socket;
    and *peer application* denotes the application utilizing the peer socket. Sometimes,
    the term *remote* (or *foreign*) is used synonymously with *peer*. Analogously,
    sometimes the term *local* is used to refer to the application, socket, or address
    for this end of the connection. A stream socket can be connected to only one peer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '*Datagram sockets* (`SOCK_DGRAM`) allow data to be exchanged in the form of
    messages called *datagrams*. With datagram sockets, message boundaries are preserved,
    but data transmission is not reliable. Messages may arrive out of order, be duplicated,
    or not arrive at all.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Datagram sockets are an example of the more generic concept of a *connectionless*
    socket. Unlike a stream socket, a datagram socket doesn’t need to be connected
    to another socket in order to be used. (In [Using *connect()* with Datagram Sockets](ch56.html#using_connect_open_parenthesis_close_par
    "Using connect() with Datagram Sockets"), we’ll see that datagram sockets may
    be connected with one another, but this has somewhat different semantics from
    connected stream sockets.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In the Internet domain, datagram sockets employ the User Datagram Protocol (UDP),
    and stream sockets (usually) employ the Transmission Control Protocol (TCP). Instead
    of using the terms *Internet domain datagram socket* and *Internet domain stream
    socket*, we’ll often just use the terms *UDP socket* and *TCP socket*, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Socket system calls
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The key socket system calls are the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The *socket()* system call creates a new socket.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *bind()* system call binds a socket to an address. Usually, a server employs
    this call to bind its socket to a well-known address so that clients can locate
    the socket.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *listen()* system call allows a stream socket to accept incoming connections
    from other sockets.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *accept()* system call accepts a connection from a peer application on a
    listening stream socket, and optionally returns the address of the peer socket.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *connect()* system call establishes a connection with another socket.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On most Linux architectures (the exceptions include Alpha and IA-64), all of
    the sockets system calls are actually implemented as library functions multiplexed
    through a single system call, *socketcall()*. (This is an artifact of the original
    development of the Linux sockets implementation as a separate project.) Nevertheless,
    we refer to all of these functions as system calls in this book, since this is
    what they were in the original BSD implementation, as well as in many other contemporary
    UNIX implementations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Socket I/O can be performed using the conventional *read()* and *write()* system
    calls, or using a range of socket-specific system calls (e.g., *send()*, *recv()*,
    *sendto()*, and *recvfrom()*). By default, these system calls block if the I/O
    operation can’t be completed immediately. Nonblocking I/O is also possible, by
    using the *fcntl()* `F_SETFL` operation ([Open File Status Flags](ch05.html#open_file_status_flags
    "Open File Status Flags")) to enable the `O_NONBLOCK` open file status flag.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, we can call *ioctl(fd, FIONREAD, &cnt)* to obtain the number of unread
    bytes available on the stream socket referred to by the file descriptor *fd*.
    For a datagram socket, this operation returns the number of bytes in the next
    unread datagram (which may be zero if the next datagram is of zero length), or
    zero if there are no pending datagrams. This feature is not specified in SUSv3.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Socket: *socket()*'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *socket()* system call creates a new socket.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The *domain* argument specifies the communication domain for the socket. The
    *type* argument specifies the socket type. This argument is usually specified
    as either `SOCK_STREAM`, to create a stream socket, or `SOCK_DGRAM`, to create
    a datagram socket.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The *protocol* argument is always specified as 0 for the socket types we describe
    in this book. Nonzero *protocol* values are used with some socket types that we
    don’t describe. For example, *protocol* is specified as `IPPROTO_RAW` for raw
    sockets (`SOCK_RAW`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: On success, *socket()* returns a file descriptor used to refer to the newly
    created socket in later system calls.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.27, Linux provides a second use for the *type* argument,
    by allowing two nonstandard flags to be ORed with the socket type. The `SOCK_CLOEXEC`
    flag causes the kernel to enable the close-on-exec flag (`FD_CLOEXEC`) for the
    new file descriptor. This flag is useful for the same reasons as the *open()*
    `O_CLOEXEC` flag described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The SOCK_NONBLOCK flag causes the
    kernel to set the `O_NONBLOCK` flag on the underlying open file description, so
    that future I/O operations on the socket will be nonblocking. This saves additional
    calls to *fcntl()* to achieve the same result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.27 开始，Linux 为 *type* 参数提供了第二种用途，允许两个非标准标志与套接字类型进行按位或操作。`SOCK_CLOEXEC`
    标志使内核为新的文件描述符启用关闭时执行标志（`FD_CLOEXEC`）。这个标志的作用与 *open()* 中的 `O_CLOEXEC` 标志相同，详见[文件描述符号返回值
    *open()*](ch04.html#file_descriptor_number_returned_by-id1 "文件描述符号返回值 open()")。SOCK_NONBLOCK
    标志使内核为底层的打开文件描述符设置 `O_NONBLOCK` 标志，这样对套接字的未来 I/O 操作将变为非阻塞。这样就避免了额外调用 *fcntl()*
    来实现相同的效果。
- en: 'Binding a Socket to an Address: *bind()*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将套接字绑定到地址：*bind()*
- en: The *bind()* system call binds a socket to an address.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*bind()* 系统调用将一个套接字绑定到一个地址。'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *sockfd* argument is a file descriptor obtained from a previous call to
    *socket()*. The *addr* argument is a pointer to a structure specifying the address
    to which this socket is to be bound. The type of structure passed in this argument
    depends on the socket domain. The *addrlen* argument specifies the size of the
    address structure. The *socklen_t* data type used for the *addrlen* argument is
    an integer type specified by SUSv3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*sockfd* 参数是通过之前调用 *socket()* 获取的文件描述符。*addr* 参数是指向结构体的指针，该结构体指定了此套接字要绑定的地址。传入该参数的结构体类型取决于套接字的域。*addrlen*
    参数指定地址结构的大小。*socklen_t* 数据类型用于 *addrlen* 参数，是由 SUSv3 指定的整数类型。'
- en: Typically, we bind a server’s socket to a well-known address—that is, a fixed
    address that is known in advance to client applications that need to communicate
    with that server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将服务器的套接字绑定到一个著名地址——也就是说，绑定到一个客户端应用程序提前知道的固定地址，这样客户端才能与服务器进行通信。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other possibilities than binding a server’s socket to a well-known
    address. For example, for an Internet domain socket, the server could omit the
    call to *bind()* and simply call *listen()*, which causes the kernel to choose
    an ephemeral port for that socket. (We describe ephemeral ports in [Port Numbers](ch58.html#port_numbers
    "Port Numbers").) Afterward, the server can use *getsockname()* ([Retrieving Socket
    Addresses](ch61.html#retrieving_socket_addresses "Retrieving Socket Addresses"))
    to retrieve the address of its socket. In this scenario, the server must then
    publish that address so that clients know how to locate the server’s socket. Such
    publication could be done by registering the server’s address with a centralized
    directory service application that clients then contact in order to obtain the
    address. (For example, Sun RPC solves this problem using its *portmapper* server.)
    Of course, the directory service application’s socket must reside at a well-known
    address.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将服务器的套接字绑定到一个著名地址外，还有其他选择。例如，对于一个互联网域套接字，服务器可以省略对 *bind()* 的调用，直接调用 *listen()*，这会使内核为该套接字选择一个临时端口。（我们在[端口号](ch58.html#port_numbers
    "端口号")中描述了临时端口。）然后，服务器可以使用 *getsockname()*（[获取套接字地址](ch61.html#retrieving_socket_addresses
    "获取套接字地址")）来检索其套接字的地址。在这种情况下，服务器必须发布该地址，以便客户端能够找到服务器的套接字。此类发布可以通过将服务器地址注册到一个集中的目录服务应用程序来实现，客户端可以联系该服务来获取地址。（例如，Sun
    RPC 使用其 *portmapper* 服务器来解决这个问题。）当然，目录服务应用程序的套接字必须位于一个著名地址。
- en: 'Generic Socket Address Structures: *struct sockaddr*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用套接字地址结构：*struct sockaddr*
- en: 'The *addr* and *addrlen* arguments to *bind()* require some further explanation.
    Looking at [Table 56-1](ch56.html#socket_domains "Table 56-1. Socket domains"),
    we see that each socket domain uses a different address format. For example, UNIX
    domain sockets use pathnames, while Internet domain sockets use the combination
    of an IP address plus a port number. For each socket domain, a different structure
    type is defined to store a socket address. However, because system calls such
    as *bind()* are generic to all socket domains, they must be able to accept address
    structures of any type. In order to permit this, the sockets API defines a generic
    address structure, *struct sockaddr*. The only purpose for this type is to cast
    the various domain-specific address structures to a single type for use as arguments
    in the socket system calls. The *sockaddr* structure is typically defined as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This structure serves as a template for all of the domain-specific address structures.
    Each of these address structures begins with a *family* field corresponding to
    the *sa_family* field of the *sockaddr* structure. (The *sa_family_t* data type
    is an integer type specified in SUSv3.) The value in the *family* field is sufficient
    to determine the size and format of the address stored in the remainder of the
    structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some UNIX implementations also define an additional field in the *sockaddr*
    structure, *sa_len*, that specifies the total size of the structure. SUSv3 doesn’t
    require this field, and it is not present in the Linux implementation of the sockets
    API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: If we define the `_GNU_SOURCE` feature test macro, then *glibc* prototypes the
    various socket system calls in `<sys/socket.h>` using a *gcc* extension that eliminates
    the need for the *(struct sockaddr *)* cast. However, reliance on this feature
    is nonportable (it will result in compilation warnings on other systems).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Stream Sockets
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operation of stream sockets can be explained by analogy with the telephone
    system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The *socket()* system call, which creates a socket, is the equivalent of installing
    a telephone. In order for two applications to communicate, each of them must create
    a socket.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Communication via a stream socket is analogous to a telephone call. One application
    must connect its socket to another application’s socket before communication can
    take place. Two sockets are connected as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One application calls *bind()* in order to bind the socket to a well-known address,
    and then calls *listen()* to notify the kernel of its willingness to accept incoming
    connections. This step is analogous to having a known telephone number and ensuring
    that our telephone is turned on so that people can call us.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The other application establishes the connection by calling *connect()*, specifying
    the address of the socket to which the connection is to be made. This is analogous
    to dialing someone’s telephone number.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The application that called *listen()* then accepts the connection using *accept()*.
    This is analogous to picking up the telephone when it rings. If the *accept()*
    is performed before the peer application calls *connect()*, then the *accept()*
    blocks (“waiting by the telephone”).
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a connection has been established, data can be transmitted in both directions
    between the applications (analogous to a two-way telephone conversation) until
    one of them closes the connection using *close()*. Communication is performed
    using the conventional *read()* and *write()* system calls or via a number of
    socket-specific system calls (such as *send()* and *recv()*) that provide additional
    functionality.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 56-1](ch56.html#overview_of_system_calls_used_with_strea "Figure 56-1. Overview
    of system calls used with stream sockets") illustrates the use of the system calls
    used with stream sockets.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Active and passive sockets
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Stream sockets are often distinguished as being either active or passive:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: By default, a socket that has been created using *socket()* is *active*. An
    active socket can be used in a *connect()* call to establish a connection to a
    passive socket. This is referred to as performing an *active open*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *passive* socket (also called a *listening* socket) is one that has been marked
    to allow incoming connections by calling *listen()*. Accepting an incoming connection
    is referred to as performing a *passive open*.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most applications that employ stream sockets, the server performs the passive
    open, and the client performs the active open. We presume this scenario in subsequent
    sections, so that instead of saying “the application that performs the active
    socket open,” we’ll often just say “the client.” Similarly, we’ll equate “the
    server” with “the application that performs the passive socket open.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of system calls used with stream sockets](figs/web/56-1_SOCKINTRO-stream-overview-scale90.png.jpg)Figure 56-1. Overview
    of system calls used with stream sockets'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening for Incoming Connections: *listen()*'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *listen()* system call marks the stream socket referred to by the file descriptor
    *sockfd* as *passive*. The socket will subsequently be used to accept connections
    from other (active) sockets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We can’t apply *listen()* to a connected socket--that is, a socket on which
    a *connect()* has been successfully performed or a socket returned by a call to
    *accept()*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: To understand the purpose of the *backlog* argument, we first observe that the
    client may call *connect()* before the server calls *accept()*. This could happen,
    for example, because the server is busy handling some other client(s). This results
    in a *pending connection*, as illustrated in [Figure 56-2](ch56.html#a_pending_socket_connection
    "Figure 56-2. A pending socket connection").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![A pending socket connection](figs/web/56-2_SOCKINTRO-unaccepted-connect-scale90.png.jpg)Figure 56-2. A
    pending socket connection'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The kernel must record some information about each pending connection request
    so that a subsequent *accept()* can be processed. The *backlog* argument allows
    us to limit the number of such pending connections. Connection requests up to
    this limit succeed immediately. (For TCP sockets, the story is a little more complicated,
    as we’ll see in [TCP Connection Establishment](ch61.html#tcp_connection_establishment
    "TCP Connection Establishment").) Further connection requests block until a pending
    connection is accepted (via *accept()*), and thus removed from the queue of pending
    connections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 allows an implementation to place an upper limit on the value that can
    be specified for *backlog*, and permits an implementation to silently round *backlog*
    values down to this limit. SUSv3 specifies that the implementation should advertise
    this limit by defining the constant `SOMAXCONN` in `<sys/socket.h>`. On Linux,
    this constant is defined with the value 128\. However, since kernel 2.4.25, Linux
    allows this limit to be adjusted at run time via the Linux-specific `/proc/sys/net/core/somaxconn`
    file. (In earlier kernel versions, the `SOMAXCONN` limit is immutable.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the original BSD sockets implementation, the upper limit for *backlog* was
    5, and we may see this number specified in older code. All modern implementations
    allow higher values of *backlog*, which are necessary for network servers employing
    TCP sockets to serve large numbers of clients.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Accepting a Connection: *accept()*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *accept()* system call accepts an incoming connection on the listening stream
    socket referred to by the file descriptor *sockfd*. If there are no pending connections
    when *accept()* is called, the call blocks until a connection request arrives.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The key point to understand about *accept()* is that it creates a *new* socket,
    and it is this new socket that is connected to the peer socket that performed
    the *connect()*. A file descriptor for the connected socket is returned as the
    function result of the *accept()* call. The listening socket (*sockfd*) remains
    open, and can be used to accept further connections. A typical server application
    creates one listening socket, binds it to a well-known address, and then handles
    all client requests by accepting connections via that socket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The remaining arguments to *accept()* return the address of the peer socket.
    The *addr* argument points to a structure that is used to return the socket address.
    The type of this argument depends on the socket domain (as for *bind()*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The *addrlen* argument is a value-result argument. It points to an integer that,
    prior to the call, must be initialized to the size of the buffer pointed to by
    *addr*, so that the kernel knows how much space is available to return the socket
    address. Upon return from *accept()*, this integer is set to indicate the number
    of bytes of data actually copied into the buffer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If we are not interested in the address of the peer socket, then *addr* and
    *addrlen* should be specified as `NULL` and 0, respectively. (If desired, we can
    retrieve the peer’s address later using the *getpeername()* system call, as described
    in Section 61.5.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with kernel 2.6.28, Linux supports a new, nonstandard system call,
    *accept4()*. This system call performs the same task as *accept()*, but supports
    an additional argument, *flags*, that can be used to modify the behavior of the
    system call. Two flags are supported: `SOCK_CLOEXEC` and `SOCK_NONBLOCK`. The
    `SOCK_CLOEXEC` flag causes the kernel to enable the close-on-exec flag (`FD_CLOEXEC`)
    for the new file descriptor returned by the call. This flag is useful for the
    same reasons as the *open()* `O_CLOEXEC` flag described in [File descriptor number
    returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1 "File descriptor
    number returned by open()"). The `SOCK_NONBLOCK` flag causes the kernel to enable
    the `O_NONBLOCK` flag on the underlying open file description, so that future
    I/O operations on the socket will be nonblocking. This saves additional calls
    to *fcntl()* to achieve the same result.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting to a Peer Socket: *connect()*'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *connect()* system call connects the active socket referred to by the file
    descriptor *sockfd* to the listening socket whose address is specified by *addr*
    and *addrlen*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The *addr* and *addrlen* arguments are specified in the same way as the corresponding
    arguments to *bind()*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: If *connect()* fails and we wish to reattempt the connection, then SUSv3 specifies
    that the portable method of doing so is to close the socket, create a new socket,
    and reattempt the connection with the new socket.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: I/O on Stream Sockets
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pair of connected stream sockets provides a bidirectional communication channel
    between the two endpoints. [Figure 56-3](ch56.html#unix_domain_stream_sockets_provide_a_bid
    "Figure 56-3. UNIX domain stream sockets provide a bidirectional communication
    channel") shows what this looks like in the UNIX domain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![UNIX domain stream sockets provide a bidirectional communication channel](figs/web/56-3_SOCKINTRO-unix-connected-scale90.png.jpg)Figure 56-3. UNIX
    domain stream sockets provide a bidirectional communication channel'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of I/O on connected stream sockets are similar to those for pipes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform I/O, we use the *read()* and *write()* system calls (or the socket-specific
    *send()* and *recv()*, which we describe in [Socket-Specific I/O System Calls:
    *recv()* and *send()*](ch61.html#socket-specific_i_solidus_o_system_calls "Socket-Specific
    I/O System Calls: recv() and send()")). Since sockets are bidirectional, both
    calls may be used on each end of the connection.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A socket may be closed using the *close()* system call or as a consequence of
    the application terminating. Afterward, when the peer application attempts to
    read from the other end of the connection, it receives end-of-file (once all buffered
    data has been read). If the peer application attempts to write to its socket,
    it receives a `SIGPIPE` signal, and the system call fails with the error `EPIPE`.
    As we noted in [Creating and Using Pipes](ch44.html#creating_and_using_pipes "Creating
    and Using Pipes"), the usual way of dealing with this possibility is to ignore
    the `SIGPIPE` signal and find out about the closed connection via the `EPIPE`
    error.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connection Termination: *close()*'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usual way of terminating a stream socket connection is to call *close()*.
    If multiple file descriptors refer to the same socket, then the connection is
    terminated when all of the descriptors are closed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that, after we close a connection, the peer application crashes or otherwise
    fails to read or correctly process the data that we previously sent to it. In
    this case, we have no way of knowing that an error occurred. If we need to ensure
    that the data was successfully read and processed, then we must build some type
    of acknowledgement protocol into our application. This normally consists of an
    explicit acknowledgement message passed back to us from the peer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In [The *shutdown()* System Call](ch61.html#the_shutdown_open_parenthesis_close_pare
    "The shutdown() System Call"), we describe the *shutdown()* system call, which
    provides finer control of how a stream socket connection is closed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Datagram Sockets
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operation of datagram sockets can be explained by analogy with the postal
    system:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The *socket()* system call is the equivalent of setting up a mailbox. (Here,
    we assume a system like the rural postal service in some countries, which both
    picks up letters from and delivers letters to the mailbox.) Each application that
    wants to send or receive datagrams creates a datagram socket using *socket()*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to allow another application to send it datagrams (letters), an application
    uses *bind()* to bind its socket to a well-known address. Typically, a server
    binds its socket to a well-known address, and a client initiates communication
    by sending a datagram to that address. (In some domains--notably the UNIX domain--the
    client may also need to use *bind()* to assign an address to its socket if it
    wants to receive datagrams sent by the server.)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To send a datagram, an application calls *sendto()*, which takes as one of its
    arguments the address of the socket to which the datagram is to be sent. This
    is analogous to putting the recipient’s address on a letter and posting it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to receive a datagram, an application calls *recvfrom()*, which may
    block if no datagram has yet arrived. Because *recvfrom()* allows us to obtain
    the address of the sender, we can send a reply if desired. (This is useful if
    the sender’s socket is bound to an address that is not well known, which is typical
    of a client.) Here, we stretch the analogy a little, since there is no requirement
    that a posted letter is marked with the sender’s address.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the socket is no longer needed, the application closes it using *close()*.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just as with the postal system, when multiple datagrams (letters) are sent
    from one address to another, there is no guarantee that they will arrive in the
    order they were sent, or even arrive at all. Datagrams add one further possibility
    not present in the postal system: since the underlying networking protocols may
    sometimes retransmit a data packet, the same datagram could arrive more than once.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 56-4](ch56.html#overview_of_system_calls_used_with_datag "Figure 56-4. Overview
    of system calls used with datagram sockets") illustrates the use of the system
    calls employed with datagram sockets.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of system calls used with datagram sockets](figs/web/56-4_SOCKINTRO-datagram-overview-scale90.png.jpg)Figure 56-4. Overview
    of system calls used with datagram sockets'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Exchanging Datagrams: *recvfrom()* and *sendto()*'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *recvfrom()* and *sendto()* system calls receive and send datagrams on a
    datagram socket.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns number of bytes received, 0 on EOF, or -1 on error
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns number of bytes sent, or -1 on error
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The return value and the first three arguments to these system calls are the
    same as for *read()* and *write()*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The fourth argument, *flags*, is a bit mask controlling socket-specific I/O
    features. We cover these features when we describe the *recv()* and *send()* system
    calls in Section 61.3\. If we don’t require any of these features, we can specify
    *flags* as 0.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The *src_addr* and *addrlen* arguments are used to obtain or specify the address
    of the peer socket with which we are communicating.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For *recvfrom()*, the *src_addr* and *addrlen* arguments return the address
    of the remote socket used to send the datagram. (These arguments are analogous
    to the *addr* and *addrlen* arguments of *accept()*, which return the address
    of a connecting peer socket.) The *src_addr* argument is a pointer to an address
    structure appropriate to the communication domain. As with *accept()*, *addrlen*
    is a value-result argument. Prior to the call, *addrlen* should be initialized
    to the size of the structure pointed to by *src_addr*; upon return, it contains
    the number of bytes actually written to this structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: If we are not interested in the address of the sender, then we specify both
    *src_addr* and *addrlen* as `NULL`. In this case, *recvfrom()* is equivalent to
    using *recv()* to receive a datagram. We can also use *read()* to read a datagram,
    which is equivalent to using *recv()* with a *flags* argument of 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the value specified for *length*, *recvfrom()* retrieves exactly
    one message from a datagram socket. If the size of that message exceeds *length*
    bytes, the message is silently truncated to *length* bytes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we employ the *recvmsg()* system call ([The *sendmsg()* and *recvmsg()* System
    Calls](ch61.html#the_sendmsg_open_parenthesis_close_paren "The sendmsg() and recvmsg()
    System Calls")), then it is possible to find out about a truncated datagram via
    the `MSG_TRUNC` flag returned in the *msg_flags* field of the returned *msghdr*
    structure. See the *recvmsg(2)* manual page for details.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For *sendto()*, the *dest_addr* and *addrlen* arguments specify the socket to
    which the datagram is to be sent. These arguments are employed in the same manner
    as the corresponding arguments to *connect()*. The *dest_addr* argument is an
    address structure suitable for this communication domain. It is initialized with
    the address of the destination socket. The *addrlen* argument specifies the size
    of *addr*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, it is possible to use *sendto()* to send datagrams of length 0\. However,
    not all UNIX implementations permit this.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Using *connect()* with Datagram Sockets
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though datagram sockets are connectionless, the *connect()* system call
    serves a purpose when applied to datagram sockets. Calling *connect()* on a datagram
    socket causes the kernel to record a particular address as this socket’s peer.
    The term *connected datagram socket* is applied to such a socket. The term *unconnected
    datagram socket* is applied to a datagram socket on which *connect()* has not
    been called (i.e., the default for a new datagram socket).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'After a datagram socket has been connected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Datagrams can be sent through the socket using *write()* (or *send()*) and are
    automatically sent to the same peer socket. As with *sendto()*, each *write()*
    call results in a separate datagram.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only datagrams sent by the peer socket may be read on the socket.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the effect of *connect()* is asymmetric for datagram sockets. The
    above statements apply only to the socket on which *connect()* has been called,
    not to the remote socket to which it is connected (unless the peer application
    also calls *connect()* on its socket).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We can change the peer of a connected datagram socket by issuing a further *connect()*
    call. It is also possible to dissolve the peer association altogether by specifying
    an address structure in which the address family (e.g., the *sun_family* field
    in the UNIX domain) is specified as `AF_UNSPEC`. Note, however, that many other
    UNIX implementations don’t support the use of `AF_UNSPEC` for this purpose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 was somewhat vague about dissolving peer associations, stating that a
    connection can be reset by making a *connect()* call that specifies a “null address,”
    without defining that term. SUSv4 explicitly specifies the use of `AF_UNSPEC`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The obvious advantage of setting the peer for a datagram socket is that we can
    use simpler I/O system calls when transmitting data on the socket. We no longer
    need to use *sendto()* with *dest_addr* and *addrlen* arguments, but can instead
    use *write()*. Setting the peer is useful primarily in an application that needs
    to send multiple datagrams to a single peer (which is typical of some datagram
    clients).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some TCP/IP implementations, connecting a datagram socket to a peer yields
    a performance improvement ([Stevens et al., 2004]). On Linux, connecting a datagram
    socket makes little difference to performance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sockets allow communication between applications on the same host or on different
    hosts connected via a network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: A socket exists within a communication domain, which determines the range of
    communication and the address format used to identify the socket. SUSv3 specifies
    the UNIX (`AF_UNIX`), IPv4 (`AF_INET`), and IPv6 (`AF_INET6`) communication domains.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Most applications use one of two socket types: stream or datagram. Stream sockets
    (`SOCK_STREAM`) provide a reliable, bidirectional, byte-stream communication channel
    between two endpoints. Datagram sockets (`SOCK_DGRAM`) provide unreliable, connectionless,
    message-oriented communication.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A typical stream socket server creates its socket using *socket()*, and then
    binds the socket to a well-known address using *bind()*. The server then calls
    *listen()* to allow connections to be received on the socket. Each client connection
    is then accepted on the listening socket using *accept()*, which returns a file
    descriptor for a new socket that is connected to the client’s socket. A typical
    stream socket client creates a socket using *socket()*, and then establishes a
    connection by calling *connect()*, specifying the server’s well-known address.
    After two stream sockets are connected, data can be transferred in either direction
    using *read()* and *write()*. Once all processes with a file descriptor referring
    to a stream socket endpoint have performed an implicit or explicit *close()*,
    the connection is terminated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: A typical datagram socket server creates a socket using *socket()*, and then
    binds it to a well-known address using *bind()*. Because datagram sockets are
    connectionless, the server’s socket can be used to receive datagrams from any
    client. Datagrams can be received using *read()* or using the socket-specific
    *recvfrom()* system call, which returns the address of the sending socket. A datagram
    socket client creates a socket using *socket()*, and then uses *sendto()* to send
    a datagram to a specified (i.e., the server’s) address. The *connect()* system
    call can be used with a datagram socket to set a peer address for the socket.
    After doing this, it is no longer necessary to specify the destination address
    for outgoing datagrams; a *write()* call can be used to send a datagram.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
