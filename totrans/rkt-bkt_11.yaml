- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: 'BOOTKIT DYNAMIC ANALYSIS: EMULATION AND VIRTUALIZATION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引导木马动态分析：仿真与虚拟化**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: You saw in [Chapter 8](ch08.xhtml#ch08) that static analysis is a powerful tool
    for bootkit reverse engineering. In some situations, however, it can’t give you
    the information you’re looking for, so you’ll need to use *dynamic analysis* techniques
    instead. This is often true for bootkits that contain encrypted components for
    which decryption is problematic or for bootkits like Rovnix—covered in [Chapter
    11](ch11.xhtml#ch11)—that employ multiple hooks during execution to disable OS
    protection mechanisms. Static analysis tools can’t always tell which modules the
    bootkit tampers with, so dynamic analysis is more effective in these cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第8章](ch08.xhtml#ch08)中看到，静态分析是引导木马逆向工程中的一个强大工具。然而，在某些情况下，它无法提供你所需要的信息，因此你需要使用*动态分析*技术。这通常适用于包含加密组件且解密困难的引导木马，或者像Rovnix（在[第11章](ch11.xhtml#ch11)中讨论）那样的引导木马，它在执行过程中使用多个钩子来禁用操作系统保护机制。静态分析工具并不总是能够告诉你引导木马修改了哪些模块，因此在这些情况下，动态分析更加有效。
- en: Dynamic analysis generally relies on the debugging facilities of the platform
    being analyzed, but the preboot environment doesn’t provide conventional debugging
    facilities. Debugging in a preboot environment usually requires special equipment,
    software, and knowledge, making it a challenging task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析通常依赖于被分析平台的调试设施，但预启动环境并不提供常规的调试设施。在预启动环境中调试通常需要特殊的设备、软件和知识，这使得它成为一项具有挑战性的任务。
- en: To overcome this hurdle, we need an additional layer of software—either an emulator
    or a virtual machine (VM). Emulation and virtualization tools enable us to run
    boot code in the controlled preboot environment with conventional debugging interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一难题，我们需要额外的软件层——无论是仿真器还是虚拟机（VM）。仿真和虚拟化工具使我们能够在受控的预启动环境中运行引导代码，并提供常规的调试接口。
- en: In this chapter, we’ll explore both approaches to dynamic bootkit analysis—specifically,
    emulation with Bochs and virtualization with VMware Workstation. The two types
    of approaches are similar, and both allow researchers to observe the boot code’s
    behavior at the moment of execution, provide the same level of insight into the
    code being debugged, and permit the same access to the CPU registers and memory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索两种动态引导木马分析方法——具体来说是使用Bochs进行仿真和使用VMware Workstation进行虚拟化。这两种方法相似，且都允许研究人员观察引导代码在执行时的行为，提供相同的调试洞察，并允许访问相同的CPU寄存器和内存。
- en: The difference between the two methods lies in their implementation. The Bochs
    emulator interprets the code to emulate entirely on a virtual CPU, whereas VMware
    Workstation uses the real, physical CPU to execute most instructions of a guest
    OS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的区别在于它们的实现方式。Bochs仿真器通过解释代码在虚拟CPU上完全仿真执行，而VMware Workstation则使用真实的物理CPU来执行大部分来宾操作系统的指令。
- en: The bootkit components we’ll be using for the analysis in this chapter are available
    in the book’s resources at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
    You’ll need the MBR in the file *mbr.mbr* and the VBR and IPL in the file *partition0.data*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析中使用的引导木马组件可以在书籍资源的*([https://nostarch.com/rootkits/](https://nostarch.com/rootkits/))*中找到。你需要的MBR文件是*mbr.mbr*，而VBR和IPL文件在*partition0.data*中。
- en: '**Emulation with Bochs**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Bochs进行仿真**'
- en: Bochs (*[http://bochs.sourceforge.net/](http://bochs.sourceforge.net/)*), pronounced
    “box,” is an open source emulator for the Intel x86-64 platform capable of emulating
    an entire computer. Our primary interest in this tool is that it provides a debugging
    interface that can trace the code it emulates, so we can use it to debug modules
    executed in the preboot environment, such as the MBR and VBR/IPL. Bochs also runs
    as a single user-mode process, so there’s no need to install kernel-mode drivers
    or any special system services to support the emulated environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs (*[http://bochs.sourceforge.net/](http://bochs.sourceforge.net/)*), 发音为“box”，是一个开源仿真器，支持Intel
    x86-64平台，能够仿真整个计算机。我们对这个工具的主要兴趣在于它提供了一个调试接口，可以追踪它所仿真的代码，因此我们可以用它来调试在预启动环境中执行的模块，如MBR和VBR/IPL。Bochs还作为一个单用户模式进程运行，因此不需要安装内核模式驱动程序或任何特殊的系统服务来支持仿真环境。
- en: Other tools, like the open source emulator QEMU (*[http://wiki.qemu.org/Main_Page](http://wiki.qemu.org/Main_Page)*),
    provide the same functionality as Bochs and can also be used for bootkit analysis.
    But we chose Bochs over QEMU because in our extensive experience, Bochs has shown
    better integration with Hex-Rays IDA Pro for Microsoft Windows platforms. Bochs
    also has a more compact architecture that focuses on emulating only x86/x64 platforms,
    and it has an embedded debugging interface that we can use for boot code debugging
    without having to use IDA Pro—although its performance is enhanced when paired
    with IDA Pro, as we’ll demonstrate later in “[Combining Bochs with IDA](ch09.xhtml#ch09lev2sec5)”
    on [page 123](ch09.xhtml#page_123).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具，如开源仿真器QEMU（*[http://wiki.qemu.org/Main_Page](http://wiki.qemu.org/Main_Page)*），提供与Bochs相同的功能，也可用于bootkit分析。但我们选择Bochs而非QEMU，是因为根据我们丰富的经验，Bochs在与Hex-Rays
    IDA Pro集成方面，在Microsoft Windows平台上表现得更好。Bochs还具有更加紧凑的架构，专注于仿真仅限x86/x64平台，并且内嵌了一个调试接口，我们可以利用它进行引导代码调试，而无需使用IDA
    Pro——虽然将其与IDA Pro配合使用会提升性能，正如我们将在“[将Bochs与IDA结合使用](ch09.xhtml#ch09lev2sec5)”部分中展示的那样，位于[第123页](ch09.xhtml#page_123)。
- en: It’s worth noting that QEMU is more efficient and supports more architectures,
    including the Advanced RISC Machine (ARM) architecture. QEMU’s use of an internal
    GNU Debugger (GDB) interface also provides opportunities for debugging from early
    on in the VM booting process. So, if you want to explore debugging more after
    this chapter, QEMU may be worth trying out.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，QEMU效率更高，并且支持更多架构，包括高级RISC机器（ARM）架构。QEMU使用的内部GNU调试器（GDB）接口也提供了从虚拟机启动过程早期开始调试的机会。因此，如果你在本章之后希望更深入地探索调试，QEMU可能是一个值得尝试的选择。
- en: '***Installing Bochs***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装Bochs***'
- en: 'You can download the latest version of Bochs from *[https://sourceforge.net/projects/bochs/files/bochs/](https://sourceforge.net/projects/bochs/files/bochs/)*.
    You have two download options: the Bochs installer and a ZIP archive with Bochs
    components. The installer includes more components and tools—including the `bximage`
    tool we’ll discuss later—so we recommend downloading it instead of the ZIP archive.
    The installation is straightforward: just click through the steps and leave the
    default values for the parameters. Throughout the chapter, we’ll refer to the
    directory where Bochs has been installed as the *Bochs working directory*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*[https://sourceforge.net/projects/bochs/files/bochs/](https://sourceforge.net/projects/bochs/files/bochs/)*下载最新版本的Bochs。你有两种下载选项：Bochs安装程序和包含Bochs组件的ZIP归档文件。安装程序包含更多的组件和工具——包括我们稍后会讨论的`bximage`工具——所以我们推荐下载安装程序，而不是ZIP归档文件。安装过程很简单：只需点击完成步骤并保持默认的参数值。在本章中，我们将Bochs的安装目录称为*Bochs工作目录*。
- en: '***Creating a Bochs Environment***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建Bochs环境***'
- en: To use the Bochs emulator, we first need to create an environment for it, consisting
    of a Bochs configuration file and a disk image. The configuration file is a text
    file that contains all the essential information the emulator needs to execute
    the code (which disk image to use, the CPU parameters, and so forth), and the
    disk image contains the guest OS and boot modules to emulate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Bochs仿真器，我们首先需要为它创建一个环境，包含一个Bochs配置文件和一个磁盘映像文件。配置文件是一个文本文件，包含仿真器执行代码所需的所有基本信息（使用哪个磁盘映像、CPU参数等），而磁盘映像则包含要仿真的客体操作系统和引导模块。
- en: '**Creating the Configuration File**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建配置文件**'
- en: '[Listing 9-1](ch09.xhtml#ch09list01) demonstrates the most frequently used
    parameters for bootkit debugging, and we’ll use this as our Bochs configuration
    file throughout this chapter. Open a new text file and enter the contents of [Listing
    9-1](ch09.xhtml#ch09list01). Or, if you prefer, you can use the *bochsrc.bxrc*
    file provided in the book’s resources. You’ll need to save this file in the Bochs
    working directory and name it *bochsrc.bxrc*. The *.bxrc* extension means that
    the file contains configuration parameters for Bochs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9-1](ch09.xhtml#ch09list01)展示了调试bootkit时最常用的参数，我们将在本章中使用此文件作为Bochs配置文件。打开一个新的文本文件，并输入[列表9-1](ch09.xhtml#ch09list01)的内容。或者，如果你愿意，也可以使用本书资源中提供的*bochsrc.bxrc*文件。你需要将此文件保存在Bochs工作目录中，并命名为*bochsrc.bxrc*。*.bxrc*扩展名表示该文件包含Bochs的配置参数。'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Sample Bochs configuration file*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-1：示例Bochs配置文件*'
- en: 'The first parameter, `megs`, sets a RAM limit for the emulated environment
    in megabytes. For our boot code–debugging needs, 512MB is more than sufficient.
    The `romimage` parameter ➊ and `vgaromimage` parameter ➋ specify the paths to
    the BIOS and VGA-BIOS modules to be used in the emulated environment. Bochs comes
    with default BIOS modules, but you can use custom modules if necessary (for example,
    in the case of firmware development). Because our goal is to debug MBR and VBR
    code, we’ll use the default BIOS module. The `boot` option specifies the boot
    device sequence ➌. With the settings shown, Bochs will first attempt to boot from
    the CD-ROM device, and if that fails, it will proceed to the hard drive. The next
    option, `ata0-master`, specifies the type and characteristics of the hard drive
    to be emulated by Bochs ➍. It has several parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`megs`设置了仿真环境的RAM限制，单位为MB。对于我们的引导代码调试需求，512MB已经足够。`romimage`参数 ➊ 和 `vgaromimage`参数
    ➋ 指定了要在仿真环境中使用的BIOS和VGA-BIOS模块的路径。Bochs附带了默认的BIOS模块，但如果需要的话，你可以使用自定义模块（例如在固件开发的情况下）。由于我们的目标是调试MBR和VBR代码，我们将使用默认的BIOS模块。`boot`选项指定了启动设备的顺序
    ➌。根据这些设置，Bochs将首先尝试从CD-ROM设备启动，如果失败，则会转向硬盘。下一个选项`ata0-master`指定了Bochs仿真硬盘的类型和特性
    ➍。它有几个参数：
- en: type The type of device, either `disk` or `cdrom`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: type 设备的类型，可以是`disk`或`cdrom`。
- en: path The path to a file on the host filesystem with the disk image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: path 主机文件系统中磁盘镜像文件的路径。
- en: mode The type of image. This option is valid only for disk devices; we’ll discuss
    it in more detail in “[Combining Bochs with IDA](ch09.xhtml#ch09lev2sec5)” on
    [page 123](ch09.xhtml#page_123).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: mode 图像的类型。此选项仅对磁盘设备有效；我们将在[第123页](ch09.xhtml#page_123)的“[将Bochs与IDA结合使用](ch09.xhtml#ch09lev2sec5)”中详细讨论。
- en: cylinders The number of cylinders for the disk; this option defines the size
    of the disk.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: cylinders 磁盘的磁道数；此选项定义磁盘的大小。
- en: heads The number of heads for the disk; this option defines the size of the
    disk.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: heads 磁盘的磁头数量；此选项定义磁盘的大小。
- en: spt The number of sectors per track; this option defines the size of the disk.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: spt 每轨的扇区数；此选项定义磁盘的大小。
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the following section, you’ll see how to create a disk image using the
    bximage tool included with Bochs. Once it has created a new disk image, bximage
    outputs the parameters for you to provide in the ata0-master option.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*在接下来的部分中，你将看到如何使用Bochs附带的bximage工具创建磁盘镜像。一旦创建了新的磁盘镜像，bximage会输出你需要在ata0-master选项中提供的参数。*'
- en: The `mouse` parameter enables the use of a mouse in the guest OS ➎. The `cpu`
    option defines the parameters of the virtual CPU inside the Bochs emulator ➏.
    In our example, we use `ips` to specify the number of instructions to emulate
    per second. You can tweak this option to change performance characteristics; for
    example, for Bochs version 2.6.8 and a CPU with Intel Core i7, the typical `ips`
    value would be between 85 and 95 MIPS (millions of instructions per second), which
    is the case with the value we’re using here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouse` 参数启用在客操作系统中使用鼠标 ➎。`cpu` 选项定义了Bochs仿真器内虚拟CPU的参数 ➏。在我们的示例中，我们使用`ips`指定每秒仿真指令的数量。你可以调整此选项以改变性能特性；例如，对于Bochs版本2.6.8和Intel
    Core i7 CPU，典型的`ips`值大约在85到95 MIPS（百万条指令每秒）之间，这也是我们这里使用的值。'
- en: '**Creating the Disk Image**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建磁盘镜像**'
- en: To create a disk image for Bochs, you can use either the `dd` utility in Unix
    or the `bximage` tool provided with the Bochs emulator. We’ll choose `bximage`
    because we can use it on both Linux and Windows machines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Bochs创建磁盘镜像，你可以使用Unix中的`dd`工具或Bochs仿真器提供的`bximage`工具。我们将选择`bximage`，因为它可以在Linux和Windows机器上使用。
- en: Open the `bximage` disk image creation tool. When it starts, `bximage` provides
    a list of options, as shown in [Figure 9-1](ch09.xhtml#ch09fig01). Enter 1 to
    create a new image ➊.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`bximage`磁盘镜像创建工具。当它启动时，`bximage`会提供一个选项列表，如[图9-1](ch09.xhtml#ch09fig01)所示。输入1以创建一个新的镜像
    ➊。
- en: The tool then asks whether you want to make a floppy or hard disk image. In
    our case, we specify `hd` ➋ to create a hard disk image. Next, it asks what type
    of image to create. Generally, the type of disk image determines the layout of
    the disk image in the file. The tool can create multiple types of disk images;
    for a full list of supported types, refer to the Bochs documentation. We choose
    `flat` ➌ to produce a disk image in a single file with flat layout. This means
    the offset within the file disk image corresponds to the offset on the disk, which
    allows us to easily edit and modify the image.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 工具接着会询问你是否要创建软盘或硬盘映像。在我们的例子中，我们指定`hd` ➋来创建一个硬盘映像。接下来，它会询问要创建哪种类型的映像。通常，磁盘映像的类型决定了磁盘映像在文件中的布局。该工具可以创建多种类型的磁盘映像；有关支持的类型的完整列表，请参阅Bochs文档。我们选择`flat`
    ➌来生成一个具有平面布局的单文件磁盘映像。这意味着文件磁盘映像中的偏移量与磁盘上的偏移量相对应，这使我们可以轻松编辑和修改映像。
- en: '![image](../images/09fig01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Creating a Bochs disk image with the `bximage` tool*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：使用`bximage`工具创建Bochs磁盘映像*'
- en: Next, we need to specify the disk size in megabytes. The value you provide depends
    on what you’re using Bochs for. If you want to install an OS onto the disk image,
    the disk size needs to be large enough to store all the OS files. On the other
    hand, if you want to use the disk image only for debugging boot code, a disk size
    of 10MB ➍ is sufficient.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定磁盘大小（以兆字节为单位）。你提供的值取决于你使用Bochs的目的。如果你想在磁盘映像中安装操作系统，则磁盘大小需要足够大，以存储所有操作系统文件。另一方面，如果你只想将磁盘映像用于调试引导代码，10MB
    ➍的磁盘大小就足够了。
- en: Finally, `bximage` prompts for an image name—this is the path to the file on
    the host filesystem in which the image will be stored ➎. If you provide only the
    filename without the full path, the file will be stored in the same directory
    as Bochs. Once you enter the filename, Bochs creates the disk image and outputs
    a configuration string ➏ for you to enter in the `ata0-master` line of the Bochs
    configuration file ([Listing 9-1](ch09.xhtml#ch09list01)). To avoid confusion,
    either provide a full path to the image file in `bximage` or copy the newly created
    image file into the same directory as the configuration file. This ensures that
    Bochs can find and load the image file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bximage`会提示输入映像名称——这是映像将存储在主机文件系统中的文件路径 ➎。如果你只提供文件名而没有完整路径，文件将存储在Bochs所在的同一目录中。输入文件名后，Bochs会创建磁盘映像并输出一个配置字符串
    ➏，让你输入到Bochs配置文件中的`ata0-master`行中（[列表 9-1](ch09.xhtml#ch09list01)）。为避免混淆，可以在`bximage`中提供映像文件的完整路径，或者将新创建的映像文件复制到与配置文件相同的目录中。这确保了Bochs能够找到并加载映像文件。
- en: '***Infecting the Disk Image***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***感染磁盘映像***'
- en: 'Once you’ve created the disk image, we can proceed with infecting the disk
    with a bootkit. We can do so in one of two ways. The first option is to install
    a guest OS onto the Bochs disk image and then execute the bootkit infector into
    the guest environment. At execution, the malware will infect the disk image with
    the bootkit. This approach allows you to perform deeper malware analysis because
    the malware installs all the components onto the guest system, including the bootkit
    and the kernel-mode drivers. But it also has some drawbacks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了磁盘映像，我们就可以继续将引导程序感染到磁盘中。我们可以通过两种方式来实现这一点。第一种选择是将一个来宾操作系统安装到Bochs磁盘映像中，然后将引导程序感染器执行到来宾环境中。在执行时，恶意软件会将引导程序感染到磁盘映像中。这种方法允许你进行更深入的恶意软件分析，因为恶意软件将所有组件安装到来宾系统中，包括引导程序和内核模式驱动程序。但它也有一些缺点：
- en: The disk image we created earlier must be large enough to accommodate the OS.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前创建的磁盘映像必须足够大，以容纳操作系统。
- en: The emulation of the instructions during the OS installation and malware execution
    increases the execution time significantly.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统安装和恶意软件执行过程中，指令的仿真会显著增加执行时间。
- en: Some modern malware implements antiemulation functionality, meaning the malware
    detects when it is running in the emulator and exits without infecting the system.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些现代恶意软件实现了反仿真功能，意味着恶意软件可以检测到它在仿真器中运行并在不感染系统的情况下退出。
- en: 'For these reasons, we’ll use the second option: infecting the disk image by
    extracting the bootkit components (the MBR, VBR, and IPL) from the malware and
    writing them directly to the disk image. This approach requires a substantially
    smaller disk size, and it is usually much faster. But it also means we can’t observe
    and analyze other components of the malware, like kernel-mode drivers. This approach
    also requires some prior understanding of the malware and its architecture. So
    another reason we’re choosing it is that it gives us more insight into using Bochs
    in the context of dynamic analysis.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们将使用第二种选项：通过从恶意软件中提取启动工具组件（MBR、VBR 和 IPL），并直接将它们写入磁盘镜像来感染磁盘镜像。这种方法需要的磁盘大小显著较小，通常速度也更快。但这也意味着我们无法观察和分析恶意软件的其他组件，如内核模式驱动程序。这种方法还需要一些对恶意软件及其架构的先验了解。因此，我们选择这种方法的另一个原因是，它能让我们更深入地了解在动态分析环境中使用
    Bochs。
- en: '**Writing the MBR to the Disk Image**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 MBR 写入磁盘镜像**'
- en: Make sure you’ve downloaded and saved the *mbr.mbr* code from the resources
    at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*. [Listing
    9-2](ch09.xhtml#ch09list02) shows the Python code that writes the malicious MBR
    onto the disk image. Copy it into a text editor and save it as an external Python
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已从 *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)* 下载并保存
    *mbr.mbr* 代码。[清单 9-2](ch09.xhtml#ch09list02) 展示了将恶意 MBR 写入磁盘镜像的 Python 代码。将其复制到文本编辑器中并保存为外部
    Python 文件。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Writing the MBR code onto the disk image*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：将 MBR 代码写入磁盘镜像*'
- en: In this example, enter the file location for the MBR in place of path_to_mbr_file
    ➊, enter the disk image location in place of path_to_disk_image ➋, and then save
    the code into a file with the extension *.py*. Now, execute `python` path_to_the_script_file`.py`,
    and the Python interpreter will execute the code in Bochs. The MBR we’ve written
    ➌ onto the disk image contains only one active partition (0) in the partition
    table, as shown in [Table 9-1](ch09.xhtml#ch09tab01).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，将 MBR 的文件位置替换为 path_to_mbr_file ➊，将磁盘镜像的位置替换为 path_to_disk_image ➋，然后将代码保存为
    *.py* 扩展名的文件。现在，执行 `python path_to_the_script_file`.py`，Python 解释器将在 Bochs 中执行该代码。我们写入的
    MBR ➌ 仅包含分区表中的一个活动分区（0），如 [表 9-1](ch09.xhtml#ch09tab01) 所示。
- en: '**Table 9-1:** MBR Partition Table'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** MBR 分区表'
- en: '| **Partition number** | **Type** | **Starting sector** | **Partition size
    in sectors** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **分区编号** | **类型** | **起始扇区** | **分区大小（扇区）** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0x80 (bootable) | 0x10 ➊ | 0x200 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0x80（可启动） | 0x10 ➊ | 0x200 |'
- en: '| 1 | 0 (no partition) | 0 | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0（无分区） | 0 | 0 |'
- en: '| 2 | 0 (no partition) | 0 | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0（无分区） | 0 | 0 |'
- en: '| 3 | 0 (no partition) | 0 | 0 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0（无分区） | 0 | 0 |'
- en: Next, we need to write the VBR and IPL onto the disk image. Make sure you download
    and save the *partition0.data* code from the resources at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
    We need to write these modules at the offset ➊ specified in [Table 9-1](ch09.xhtml#ch09tab01),
    which corresponds to the starting offset of the active partition.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 VBR 和 IPL 写入磁盘镜像。确保你从 *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*
    下载并保存 *partition0.data* 代码。我们需要将这些模块写入 [表 9-1](ch09.xhtml#ch09tab01) 中指定的偏移量 ➊，该偏移量对应于活动分区的起始偏移。
- en: '**Writing the VBR and IPL to the Disk Image**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 VBR 和 IPL 写入磁盘镜像**'
- en: To write the VBR and IPL onto the disk image, enter the code presented in [Listing
    9-3](ch09.xhtml#ch09list03) in a text editor and save it as a Python script.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 VBR 和 IPL 写入磁盘镜像，将 [清单 9-3](ch09.xhtml#ch09list03) 中的代码复制到文本编辑器中，并将其保存为 Python
    脚本。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: Writing the VBR and IPL onto the disk image*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：将 VBR 和 IPL 写入磁盘镜像*'
- en: Again, as with [Listing 9-2](ch09.xhtml#ch09list02), replace path_to_vbr_file
    ➊ with the path to the file containing the VBR and replace path_to_disk_image
    ➋ with the image location before running the script.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与 [清单 9-2](ch09.xhtml#ch09list02) 相同，在运行脚本之前，将 path_to_vbr_file ➊ 替换为包含 VBR
    的文件路径，将 path_to_disk_image ➋ 替换为镜像位置。
- en: After executing the script, we have a disk image ready for debugging in Bochs.
    We’ve successfully written the malicious MBR and VBR/IPL onto the image, and we
    can analyze them in the Bochs debugger.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本后，我们就有了一个可以在 Bochs 中调试的磁盘镜像。我们已经成功地将恶意 MBR 和 VBR/IPL 写入了镜像，并可以在 Bochs 调试器中分析它们。
- en: '***Using the Bochs Internal Debugger***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Bochs 内部调试器***'
- en: 'The Bochs debugger is a stand-alone application, *bochsdbg.exe*, with a command
    line interface. We can use the functions supported by the Bochs debugger—such
    as breakpoint, memory manipulation, tracing, and code disassembly—to examine boot
    code for malicious activity or decrypt polymorphic MBR code. To start a debugging
    session, call the *bochsdbg.exe* application from the command line with a path
    to the Bochs configuration file *bochsrc.bxrc*, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bochs 调试器是一个独立的应用程序，*bochsdbg.exe*，具有命令行界面。我们可以使用 Bochs 调试器支持的功能——例如断点、内存操作、跟踪和代码反汇编——来检查启动代码中的恶意活动或解密多态
    MBR 代码。要开始调试会话，请从命令行调用 *bochsdbg.exe* 应用程序，并指定 Bochs 配置文件 *bochsrc.bxrc* 的路径，如下所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command starts a virtual machine and opens a debugging console. First,
    set a breakpoint at the beginning of the boot code so that the debugger stops
    the execution of the MBR code at the beginning, giving us an opportunity to analyze
    the code. The first MBR instruction is placed at address 0x7c00, so enter the
    command lb 0x7c00 to set the breakpoint at the beginning of the instructions.
    To commence execution, we apply the `c` command, as shown in [Figure 9-2](ch09.xhtml#ch09fig02).
    To see the disassembled instructions from the current address, we use the `u`
    debugger command; for example, [Figure 9-2](ch09.xhtml#ch09fig02) shows the first
    10 disassembled instructions with the command `u /10`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令启动虚拟机并打开调试控制台。首先，在启动代码的开头设置一个断点，使得调试器在执行 MBR 代码时停下来，从而给我们提供机会分析代码。第一个 MBR
    指令位于地址 0x7c00，因此输入命令 lb 0x7c00，将断点设置在指令的开头。要开始执行，我们使用 `c` 命令，如 [图 9-2](ch09.xhtml#ch09fig02)
    所示。要查看当前地址处的反汇编指令，我们使用 `u` 调试命令；例如，[图 9-2](ch09.xhtml#ch09fig02) 显示了使用命令 `u /10`
    获得的前 10 条反汇编指令。
- en: '![image](../images/09fig02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig02.jpg)'
- en: '*Figure 9-2: The command line Bochs debugger interface*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：命令行 Bochs 调试器界面*'
- en: 'You can get a full list of the debugger commands by entering `help` or visiting
    the documentation at *[http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html](http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html)*.
    Here are a few of the more useful ones:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`help`或者访问文档 *[http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html](http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html)*
    来获取完整的调试器命令列表。以下是一些更常用的命令：
- en: c Continue executing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: c 继续执行。
- en: s [count] Execute count instructions (step); the default value is `1`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: s [count] 执行 count 次指令（步进）；默认值为 `1`。
- en: q Quit the debugger and execution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: q 退出调试器并停止执行。
- en: '**CTRL-C** Stop execution and return to the command line prompt.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**CTRL-C** 停止执行并返回到命令行提示符。'
- en: lb addr Set a linear address instruction breakpoint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: lb addr 设置线性地址指令断点。
- en: info break Display the state of all current breakpoints.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: info break 显示所有当前断点的状态。
- en: bpe n Enable a breakpoint.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: bpe n 启用断点。
- en: bpd n Disable a breakpoint.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: bpd n 禁用断点。
- en: del n Delete a breakpoint.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: del n 删除断点。
- en: Although we can use the Bochs debugger on its own for basic dynamic analysis,
    we can do more when it’s bound with IDA, mainly because the code navigation in
    IDA is much more powerful than batch-mode debugging. In an IDA session, we can
    also continue with a static analysis of the created IDA Pro database file and
    use features like the decompiler.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以单独使用 Bochs 调试器进行基本的动态分析，但将其与 IDA 结合使用时，我们能做的更多，主要是因为 IDA 中的代码导航功能比批处理模式调试更强大。在
    IDA 会话中，我们还可以继续对创建的 IDA Pro 数据库文件进行静态分析，并使用反编译器等功能。
- en: '***Combining Bochs with IDA***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将 Bochs 与 IDA 结合使用***'
- en: Now that we have an infected disk image prepared, we’ll launch Bochs and start
    the emulation. Starting with version 5.4, IDA Pro provides a frontend for the
    DBG debugger, which we can use with Bochs to debug guest operating systems. To
    launch the Bochs debugger in IDA Pro, open IDA Pro and then go to **Debugger**▸**Run**▸**Local
    Bochs debugger**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好感染的磁盘镜像，将启动 Bochs 并开始仿真。从版本 5.4 开始，IDA Pro 提供了 DBG 调试器的前端，我们可以与 Bochs
    一起使用它来调试来宾操作系统。要在 IDA Pro 中启动 Bochs 调试器，打开 IDA Pro，然后转到 **调试器**▸**运行**▸**本地 Bochs
    调试器**。
- en: A dialog will open, asking for some options, as shown in [Figure 9-3](ch09.xhtml#ch09fig03).
    In the Application field, specify the path to the Bochs configuration file you
    created earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将会打开一个对话框，询问一些选项，如 [图 9-3](ch09.xhtml#ch09fig03) 所示。在应用程序字段中，指定你之前创建的 Bochs
    配置文件的路径。
- en: '![image](../images/09fig03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig03.jpg)'
- en: '*Figure 9-3: Specifying the path to the Bochs configuration file*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：指定 Bochs 配置文件的路径*'
- en: 'Next, we need to set some options. Click **Debug options** and then go to **Set
    specific options**. You’ll see a dialog like the one in [Figure 9-4](ch09.xhtml#ch09fig04),
    offering three options for the Bochs operation mode:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置一些选项。点击 **调试选项**，然后进入 **设置特定选项**。你会看到一个对话框，如[图 9-4](ch09.xhtml#ch09fig04)所示，提供了三种
    Bochs 操作模式的选项：
- en: '**Disk image** Launch Bochs and execute the disk image.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁盘镜像** 启动 Bochs 并执行磁盘镜像。'
- en: '**IDB** Emulate a selected part of the code inside Bochs.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDB** 模拟 Bochs 中选定部分的代码。'
- en: '**PE** Load and emulate the PE image inside Bochs.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**PE** 加载并在 Bochs 中仿真 PE 镜像。'
- en: '![image](../images/09fig04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig04.jpg)'
- en: '*Figure 9-4: Choosing the operation mode for Bochs*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：为 Bochs 选择操作模式*'
- en: For our case, we select **Disk image** ➊ to make Bochs load and execute the
    disk image we created and infected earlier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的情况，我们选择 **磁盘镜像** ➊，让 Bochs 加载并执行我们之前创建并感染的磁盘镜像。
- en: Next, IDA Pro launches Bochs with our specified parameters, and because we set
    the breakpoint earlier, it will break upon execution of the first instruction
    of the MBR at address 0000:7c00h. We can then use the standard IDA Pro debugger
    interface to debug the boot components (see [Figure 9-5](ch09.xhtml#ch09fig05)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，IDA Pro 会使用我们指定的参数启动 Bochs，并且由于我们之前设置了断点，它将在 MBR 的第一个指令执行时（地址 0000:7c00h）触发中断。然后，我们可以使用标准的
    IDA Pro 调试器界面来调试引导组件（见[图 9-5](ch09.xhtml#ch09fig05)）。
- en: '![image](../images/09fig05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig05.jpg)'
- en: '*Figure 9-5: Debugging MBR from IDA interface on a Bochs VM*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：在 Bochs 虚拟机中从 IDA 界面调试 MBR*'
- en: The interface presented in [Figure 9-5](ch09.xhtml#ch09fig05) is considerably
    more user-friendly than the command line interface the Bochs debugger provides
    (shown previously in [Figure 9-2](ch09.xhtml#ch09fig02)). You can see the disassembly
    of the boot code ➊, the contents of the CPU’s registers ➋, a memory dump ➌, and
    the CPU’s stack ➍ in a single window. This significantly simplifies the process
    of boot code debugging.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-5](ch09.xhtml#ch09fig05)中呈现的界面比 Bochs 调试器提供的命令行界面（如[图 9-2](ch09.xhtml#ch09fig02)所示）更为用户友好。你可以在一个窗口中看到引导代码的反汇编
    ➊、CPU 寄存器的内容 ➋、内存转储 ➌ 和 CPU 堆栈 ➍。这大大简化了引导代码调试的过程。
- en: '**Virtualization with VMware Workstation**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 VMware Workstation 虚拟化**'
- en: IDA Pro and Bochs are a powerful combination for boot code analysis. But debugging
    OS boot processes is sometimes unstable with Bochs, and there are some performance
    limitations to the emulation technique. For instance, performing an in-depth analysis
    of malware requires you to create a disk image with a preinstalled OS. This step
    can be time-consuming due to the nature of emulation. Bochs also lacks a convenient
    system for managing snapshots of an emulated environment—an indispensable feature
    in malware analysis.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 和 Bochs 是进行引导代码分析的强大组合。但是，有时使用 Bochs 调试操作系统引导过程不稳定，并且仿真技术存在一些性能限制。例如，进行恶意软件的深入分析需要你创建一个预安装操作系统的磁盘镜像。由于仿真的特性，这一步骤可能会非常耗时。Bochs
    还缺少一个方便的系统来管理仿真环境的快照，而这一功能在恶意软件分析中是不可或缺的。
- en: For something more stable and efficient, we can use VMware’s internal GDB debugging
    interface with IDA. In this section, we introduce the VMware GDB debugger and
    demonstrate how to set up a debugging session. We’ll discuss the specifics of
    debugging Microsoft Windows bootloaders over the next few chapters, which focus
    on MBR and VBR bootkits. We’ll also look at switching from real mode to protected
    mode from a debugging perspective.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更稳定和高效的调试，我们可以使用 VMware 的内部 GDB 调试接口与 IDA 结合使用。在这一部分，我们介绍 VMware GDB 调试器，并演示如何设置调试会话。接下来的几章将讨论调试
    Microsoft Windows 引导加载程序的具体方法，重点讲解 MBR 和 VBR 启动工具包。我们还将从调试的角度看如何从实模式切换到保护模式。
- en: VMware Workstation is a powerful tool for replicating operating systems and
    environments. It allows us to create virtual machines with guest operating systems
    and run them on the same machine as the host operating system. The guest and host
    operating systems will work without interfering with each other, as if they were
    running on two different physical machines. This is very useful for debugging
    because it makes it easy to run two programs—the debugger and the application
    being debugged—on the same host. In this regard, the VMware Workstation is quite
    similar to Bochs, except that the latter emulates CPU instructions, whereas VMware
    Workstation executes them on the physical CPU. As a result, the code executed
    in the VM runs faster than in Bochs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: VMware Workstation 是一个强大的工具，用于复制操作系统和环境。它允许我们创建具有客户操作系统的虚拟机，并在与主操作系统相同的机器上运行它们。客户操作系统和主操作系统将互不干扰，就像它们运行在两台不同的物理机器上一样。这对于调试非常有用，因为它使得在同一主机上运行两个程序——调试器和被调试的应用程序——变得容易。在这方面，VMware
    Workstation 与 Bochs 非常相似，区别在于后者模拟 CPU 指令，而 VMware Workstation 则在物理 CPU 上执行这些指令。因此，虚拟机中执行的代码比在
    Bochs 中执行的要快。
- en: The recent versions of VMware Workstation (version 6.5 onward) include a GDB
    stub for debugging VMs running inside VMware. This allows us to debug the VM from
    the very beginning of its execution, even before BIOS executes the MBR code. Starting
    from version 5.4, IDA Pro includes a debugger module that supports the GDB debug
    protocol, which we can use in conjunction with VMware.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最近版本的 VMware Workstation（6.5 版本及之后的版本）包括一个 GDB 存根，用于调试在 VMware 中运行的虚拟机。这使我们能够从虚拟机执行的最开始阶段进行调试，甚至在
    BIOS 执行 MBR 代码之前就可以开始调试。从 5.4 版本开始，IDA Pro 包括一个调试模块，支持 GDB 调试协议，我们可以与 VMware 一起使用它。
- en: 'At the time of writing this chapter, VMware Workstation is available in two
    versions: Professional (the commercial version) and Workstation Player (the free
    version). The Professional version offers extended functionality, including the
    ability to create and edit VMs, whereas Workstation Player allows users only to
    run VMs or to modify their configurations. But both versions include the GDB debugger,
    and we can use both for bootkit analysis. In this chapter, we’ll use the Professional
    version so we can create a VM.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章内容时，VMware Workstation 有两个版本可供选择：专业版（商业版）和 Workstation Player（免费版）。专业版提供扩展功能，包括创建和编辑虚拟机的能力，而
    Workstation Player 仅允许用户运行虚拟机或修改其配置。但两个版本都包括 GDB 调试器，我们可以使用这两者进行引导程序分析。本章中，我们将使用专业版，这样我们就可以创建虚拟机。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Before you can start using the VMware GBD debugger, you need to create a virtual
    machine instance using VMware Workstation and preinstall an operating system on
    it. The process of creating a VM is beyond the scope of this chapter, but you
    can find all the necessary information in the documentation at* [https://www.vmware.com/pdf/desktop/ws90-using.pdf](https://www.vmware.com/pdf/desktop/ws90-using.pdf).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*在你开始使用 VMware GDB 调试器之前，需要使用 VMware Workstation 创建一个虚拟机实例，并在其上预先安装操作系统。创建虚拟机的过程超出了本章的讨论范围，但你可以在文档中找到所有必要的信息，文档地址为*
    [https://www.vmware.com/pdf/desktop/ws90-using.pdf](https://www.vmware.com/pdf/desktop/ws90-using.pdf)。'
- en: '***Configuring the VMware Workstation***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 VMware Workstation***'
- en: Once you’ve created a virtual machine, VMware Workstation places the VM image
    and a configuration file in a user-specified directory, which we will refer to
    as the virtual machine’s directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了虚拟机，VMware Workstation 会将虚拟机镜像和配置文件放置在用户指定的目录中，我们将其称为虚拟机的目录。
- en: To enable VMware to work with GDB, you first need to specify certain configuration
    options in the virtual machine configuration file, shown in [Listing 9-4](ch09.xhtml#ch09list04).
    The virtual machine configuration file is a text file that should have the extension
    *.vmx*, and it is located in the virtual machine’s directory. Open it in the text
    editor of your choice and copy the parameters in [Listing 9-4](ch09.xhtml#ch09list04).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 VMware 与 GDB 一起工作，首先需要在虚拟机的配置文件中指定某些配置选项，配置文件如 [列表 9-4](ch09.xhtml#ch09list04)
    所示。虚拟机的配置文件是一个文本文件，扩展名为 *.vmx*，它位于虚拟机的目录中。用你喜欢的文本编辑器打开该文件，并复制 [列表 9-4](ch09.xhtml#ch09list04)
    中的参数。
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-4: Enabling a GDB stub in the VM*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4：在虚拟机中启用 GDB 存根*'
- en: The first option ➊ allows guest debugging from the local host. It enables the
    VMware GDB stub, which allows us to attach a debugger supporting the GDB protocol
    to the debugged VM. If our debugger and VM were running on different machines,
    we would instead need to enable remote debugging with the command `debugStub.listen.guest32.remote`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项 ➊ 允许从本地主机进行来宾调试。它启用了 VMware GDB 存根，允许我们将支持 GDB 协议的调试器附加到被调试的虚拟机。如果我们的调试器和虚拟机运行在不同的机器上，则需要启用远程调试，命令为`debugStub.listen.guest32.remote`。
- en: The second option ➋ enables the use of hardware breakpoints rather than software
    breakpoints. The hardware breakpoints employ CPU debugging facilities—namely,
    debugging registers `dr0` through `dr7`—whereas implementing software breakpoints
    usually involves executing the `int 3` instruction. In the context of malware
    debugging, this means hardware breakpoints are more resilient and more difficult
    to detect.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项 ➋ 启用使用硬件断点而不是软件断点。硬件断点使用 CPU 调试设施——即调试寄存器`dr0`到`dr7`——而实现软件断点通常涉及执行`int
    3`指令。在恶意软件调试的上下文中，这意味着硬件断点更具韧性，更难以被检测到。
- en: The last option ➌ instructs GDB to break the debugger upon executing the very
    first instruction from the CPU—that is, right after the VM is launched. If we
    skip this configuration option, VMware Workstation will start executing the boot
    code without breaking on it, and as a result, we won’t be able to debug it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项 ➌ 指示 GDB 在 CPU 执行第一条指令时中断调试器——即虚拟机启动后立即中断。如果跳过此配置选项，VMware Workstation
    将开始执行启动代码，而不会在其上中断，因此我们将无法调试它。
- en: '**DEBUGGING FOR 32-BIT OR 64-BIT**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**32 位或 64 位调试**'
- en: The suffix 32 in the options `debugStub.listen.guest32` and `debugStub.debugOnStartGuest32`
    indicates that 32-bit code is being debugged. If you need to debug a 64-bit OS,
    you can use the options `debugStub.listen.guest64` and `debugStub.debugOnStartGuest64`
    instead. However, for preboot code (MBR/VBR) running in 16-bit real mode, either
    of the 32-bit or 64-bit options would work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`debugStub.listen.guest32`和`debugStub.debugOnStartGuest32`中的后缀32表示正在调试32位代码。如果需要调试64位操作系统，可以使用`debugStub.listen.guest64`和`debugStub.debugOnStartGuest64`选项。然而，对于以16位实模式运行的预启动代码（MBR/VBR），32位或64位选项均可使用。
- en: '***Combining VMware GDB with IDA***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将 VMware GDB 与 IDA 结合使用***'
- en: After configuring the VM, we can proceed with launching the debugging session.
    First, to start the VM in VMware Workstation, go to the menu and choose **VM**▸**Power**▸**Power
    On**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完虚拟机后，我们可以继续启动调试会话。首先，在 VMware Workstation 中启动虚拟机，转到菜单并选择**虚拟机**▸**电源**▸**打开电源**。
- en: Next, we’ll run the IDA Pro debugger to attach to the VM. Select **Debugger**
    and go to **Attach**▸**Remote GDB debugger**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行 IDA Pro 调试器并附加到虚拟机。选择**调试器**并转到**附加**▸**远程 GDB 调试器**。
- en: Now we need to configure the debugging options. First, we specify the hostname
    and the port of the target it should attach to. We’re running the VM on the same
    host, so we specify localhost as the hostname (as shown in [Figure 9-6](ch09.xhtml#ch09fig06))
    and 8832 as the port. This is the port the GDB stub will listen to for incoming
    connections when we’re using `debugStub.listen.guest32` in the VM configuration
    file (when we’re using `debugStub.listen.guest64` in the configuration file, the
    port number is `8864`). We can leave the rest of debug parameters at their default
    values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要配置调试选项。首先，我们指定目标的主机名和端口。由于我们在同一主机上运行虚拟机，因此将主机名指定为 localhost（如[图 9-6](ch09.xhtml#ch09fig06)所示），端口号为
    8832。这是当我们在虚拟机配置文件中使用`debugStub.listen.guest32`时，GDB 存根将监听的端口（如果我们在配置文件中使用`debugStub.listen.guest64`，则端口号为`8864`）。其余调试参数可以保留默认值。
- en: '![image](../images/09fig06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig06.jpg)'
- en: '*Figure 9-6: Specifying GDB parameters*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：指定 GDB 参数*'
- en: Once all the options are set, IDA Pro attempts to attach to the target and suggests
    a list of processes it can attach to. Since we have already started debugging
    the preboot components, we should choose **<attach to the process started on target>**,
    as shown in [Figure 9-7](ch09.xhtml#ch09fig07).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项设置完毕后，IDA Pro 会尝试附加到目标，并建议一个可以附加的进程列表。由于我们已经开始调试预启动组件，应该选择**<附加到目标上启动的进程>**，如[图
    9-7](ch09.xhtml#ch09fig07)所示。
- en: '![image](../images/09fig07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig07.jpg)'
- en: '*Figure 9-7: Selecting the target process*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：选择目标进程*'
- en: At this point, IDA Pro attaches to the VM and breaks upon execution of the very
    first instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，IDA Pro 会附加到虚拟机并在执行第一条指令时中断。
- en: '**Configuring the Memory Segment**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置内存段**'
- en: Before going any further, we need to change the type of the memory segment the
    debugger has created for us. When we started the debugging session, IDA Pro created
    a 32-bit memory segment, something like [Figure 9-8](ch09.xhtml#ch09fig08).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要更改调试器为我们创建的内存段的类型。当我们开始调试会话时，IDA Pro 创建了一个 32 位的内存段，如[图 9-8](ch09.xhtml#ch09fig08)所示。
- en: '![image](../images/09fig08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig08.jpg)'
- en: '*Figure 9-8: Parameters of the memory segment in IDA Pro*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：IDA Pro 中内存段的参数*'
- en: In the preboot environment, the CPU operates in real mode, so in order to correctly
    disassemble the code, we need to change this segment from 32-bit to 16-bit. To
    do this, right-click the target segment and choose **Change segment attributes**.
    In the dialog that appears, select **16-bit** ➊ in the Segment bitness pane, as
    shown in [Figure 9-9](ch09.xhtml#ch09fig09).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在预启动环境中，CPU 以实模式运行，因此为了正确地反汇编代码，我们需要将该段从 32 位更改为 16 位。为此，右键单击目标段并选择 **更改段属性**。在出现的对话框中，在段位数面板中选择
    **16 位** ➊，如[图 9-9](ch09.xhtml#ch09fig09)所示。
- en: '![image](../images/09fig09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig09.jpg)'
- en: '*Figure 9-9: Changing the bitness of the memory segment*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：更改内存段的位数*'
- en: This will make the segment 16-bit, and all the instructions in the boot components
    will be correctly disassembled.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使该段变为 16 位，启动组件中的所有指令将会被正确地反汇编。
- en: '**Running the Debugger**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行调试器**'
- en: With all the correct options set, we can proceed with the MBR loading. Since
    the debugger was attached to the VM at the very beginning of the execution, the
    MBR code hasn’t yet been loaded. To load the MBR code, we set a breakpoint at
    the very start of the code at the address 0000:7c00h and then continue the execution.
    To set the breakpoint, go to address 0000:7c00h in the disassembly window and
    press F2\. This will display a dialog with the breakpoint parameters (see [Figure
    9-10](ch09.xhtml#ch09fig10)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好所有正确的选项后，我们可以继续进行 MBR 加载。由于调试器在执行开始时就已附加到虚拟机，因此 MBR 代码尚未加载。为了加载 MBR 代码，我们在代码开始处的地址
    0000:7c00h 设置断点，然后继续执行。要设置断点，进入反汇编窗口中的地址 0000:7c00h，然后按 F2。这将显示带有断点参数的对话框（见[图
    9-10](ch09.xhtml#ch09fig10)）。
- en: 'The Location text box ➊ specifies the address at which the breakpoint will
    be set: 0x7c00, which corresponds to virtual address 0000:7c00h. In the Settings
    area ➋, we select the Enabled and Hardware checkbox options. Checking the Enabled
    box means that the breakpoint is active, and once the execution flow reaches the
    address specified in the Location text box, the breakpoint is triggered. Checking
    the Hardware box means that the debugger will use the CPU’s debugging registers
    to set up the breakpoint, and it also activates the Hardware breakpoint mode options
    ➌, which specify the type of the breakpoint. In our case, we specify Execute to
    set up the breakpoint for executing an instruction at address 0000:7c00h. The
    other types of hardware breakpoints are for reading and writing memory at the
    specified location, which we don’t need here. The Size drop-down menu ➍ specifies
    the size of the controlled memory. We can leave the default value, 1, meaning
    that the breakpoint will control only 1 byte at address 0000:7c00h. Once these
    parameters are set, click **OK** and then resume execution by pressing F9.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Location 文本框 ➊ 指定将设置断点的地址：0x7c00，对应虚拟地址 0000:7c00h。在设置区域 ➋，我们选择启用和硬件复选框选项。选中启用框表示断点处于激活状态，一旦执行流程到达
    Location 文本框中指定的地址，断点就会被触发。选中硬件框表示调试器将使用 CPU 的调试寄存器来设置断点，并且它还会激活硬件断点模式选项 ➌，该选项指定断点的类型。在我们的情况下，我们选择执行来为地址
    0000:7c00h 设置一个执行指令的断点。其他类型的硬件断点用于在指定位置读取和写入内存，但在此不需要。Size 下拉菜单 ➍ 指定了控制的内存大小。我们可以保留默认值
    1，表示断点将仅控制地址 0000:7c00h 处的 1 字节内存。设置完这些参数后，点击 **确定**，然后按 F9 继续执行。
- en: '![image](../images/09fig10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig10.jpg)'
- en: '*Figure 9-10: The Breakpoint settings dialog*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-10：断点设置对话框*'
- en: Once the MBR is loaded and executed, the debugger breaks. The debugger window
    is shown in [Figure 9-11](ch09.xhtml#ch09fig11).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 MBR 加载并执行，调试器会中断。调试器窗口如[图 9-11](ch09.xhtml#ch09fig11)所示。
- en: '![image](../images/09fig11.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig11.jpg)'
- en: '*Figure 9-11: The IDA Pro debugger interface*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：IDA Pro 调试器界面*'
- en: At this point, we are at the very first instruction of the MBR code, as the
    instruction pointer register ➊ points to 0000:7c00h. We can see in the memory
    dump window and in the disassembly that the MBR has been successfully loaded.
    From here, we can continue the debugging process of the MBR code and execute each
    instruction, step by step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经来到了MBR代码的第一条指令，指令指针寄存器➊指向0000:7c00h。我们可以在内存转储窗口和反汇编中看到MBR已经成功加载。从这里开始，我们可以继续调试MBR代码，逐步执行每条指令。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The purpose of this section was simply to introduce you to the possibility
    of using the VMware Workstation GDB debugger with IDA Pro, so we aren’t going
    any deeper into using the GDB debugger in this chapter. You’ll find more information
    on its usage over the next few chapters, however, as we analyze the Rovnix bootkit.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节的目的是简单地向你介绍使用VMware Workstation GDB调试器与IDA Pro结合的可能性，因此我们不会在本章中深入探讨如何使用GDB调试器。你将在接下来的几章中找到更多关于它的使用信息，特别是在分析Rovnix引导工具包时。*'
- en: '**Microsoft Hyper-V and Oracle VirtualBox**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Microsoft Hyper-V和Oracle VirtualBox**'
- en: This chapter doesn’t cover the Hyper-V virtual machine manager, which is a component
    of Microsoft’s client operating systems since Windows 8, nor does it cover the
    VirtualBox open source virtual machine manager (VMM). This is because, at the
    time of this writing, neither program has a documented interface for debugging
    early enough in the VM boot process for the requirements of boot code malware
    analysis.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有涉及Hyper-V虚拟机管理器，它是微软自Windows 8以来的客户端操作系统的一部分，也没有涉及VirtualBox开源虚拟机管理器（VMM）。这是因为在撰写本书时，两个程序都没有提供足够早的调试接口，无法满足引导代码恶意软件分析的要求。
- en: At the time of publication, Microsoft Hyper-V is the only virtualization software
    that can support VMs with Secure Boot enabled, which may be one reason no debugging
    interface is provided for the early stages of the boot process. We’ll look more
    deeply at Secure Boot technology and its vulnerabilities in [Chapter 17](ch17.xhtml#ch17).
    We mention these two programs here because they are used extensively in malware
    analysis, but their lack of early boot process debugging interfaces is the main
    reason we prefer the VMware Workstation for debugging malicious bootstrap code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书发布时，微软的Hyper-V是唯一能够支持启用安全启动的虚拟机的虚拟化软件，这可能是没有为启动过程早期阶段提供调试接口的原因之一。我们将在[第17章](ch17.xhtml#ch17)中深入探讨安全启动技术及其漏洞。我们在这里提到这两个程序，是因为它们在恶意软件分析中被广泛使用，但它们缺乏早期启动过程的调试接口，这是我们偏好使用VMware
    Workstation进行恶意引导代码调试的主要原因。
- en: '**Conclusion**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: In this chapter, we demonstrated how to debug bootkit MBR and VBR code using
    the Bochs emulator and VMware Workstation. These techniques for dynamic analysis
    are useful to have in your arsenal when you need to take a deeper look inside
    malicious bootstrap code. They complement methods you might use in static analysis
    and help answer questions that static analysis can’t.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们演示了如何使用Bochs模拟器和VMware Workstation调试引导工具包的MBR和VBR代码。这些动态分析技巧对于深入了解恶意引导代码时非常有用，补充了你在静态分析中可能使用的方法，帮助回答静态分析无法解答的问题。
- en: We’ll use these tools and methods again in [Chapter 11](ch11.xhtml#ch11) to
    analyze the Rovnix bootkit, whose architecture and functionality is too elaborate
    for static analysis methods to be effective.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](ch11.xhtml#ch11)中再次使用这些工具和方法来分析Rovnix引导工具包，其架构和功能过于复杂，以至于静态分析方法无法有效。
- en: '**Exercises**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: We’ve provided a series of exercises for you to test out the skills you learned
    in this chapter. You’ll construct a Bochs image of a PC from an MBR, a VBR/IPL,
    and a New Technology File System (NTFS) partition and then perform dynamic analysis
    using the IDA Pro frontend for Bochs. First, you need to download the following
    resources at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为你提供了一系列练习，供你测试本章所学的技能。你将从一个MBR、一个VBR/IPL和一个新技术文件系统（NTFS）分区构建一个PC的Bochs镜像，然后使用IDA
    Pro的Bochs前端进行动态分析。首先，你需要在* [https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*
    下载以下资源。
- en: '***mbr.mbr*** A binary file containing an MBR'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '***mbr.mbr*** 一个包含MBR的二进制文件'
- en: '***partition0.data*** An NTFS partition image, containing a VBR and an IPL'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '***partition0.data*** 一个NTFS分区镜像，包含VBR和IPL'
- en: '***bochs.bochsrc*** The Bochs configuration file'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '***bochs.bochsrc*** Bochs配置文件'
- en: 'You’ll also need the IDA Pro disassembler, a Python interpreter, and the Bochs
    emulator. Using these tools and the information covered in this chapter, you should
    be able to complete the following exercises:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要IDA Pro反汇编器、Python解释器和Bochs模拟器。使用这些工具和本章中涵盖的信息，你应该能够完成以下练习：
- en: Create a Bochs image and adjust the values in the provided template configuration
    file *bochs.bochsrc* so it matches [Listing 9-1](ch09.xhtml#ch09list01). Use the
    `bximage` tool as described in “[Creating the Disk Image](ch09.xhtml#ch09lev3sec2)”
    on [page 118](ch09.xhtml#page_118) to create a 10MB flat image. Then store the
    image in a file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Bochs镜像并调整提供的模板配置文件*bochs.bochsrc*中的值，使其匹配[清单 9-1](ch09.xhtml#ch09list01)。使用“[创建磁盘镜像](ch09.xhtml#ch09lev3sec2)”中描述的`bximage`工具，在[第
    118 页](ch09.xhtml#page_118)上创建一个10MB的扁平镜像。然后将镜像存储在文件中。
- en: Edit the `ata0-master` option in the template configuration file to use the
    image in exercise 1\. Use the parameters provided in [Listing 9-1](ch09.xhtml#ch09list01).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑模板配置文件中的`ata0-master`选项，以使用练习 1 中的镜像。使用[清单 9-1](ch09.xhtml#ch09list01)中提供的参数。
- en: With your Bochs image ready, write the MBR and VBR bootkit components onto it.
    First, open the *mbr.mbr* file in IDA Pro and analyze it. Observe that the code
    of the MBR is encrypted. Locate the decryption routine and describe its algorithm.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好Bochs镜像后，将MBR和VBR启动工具组件写入镜像中。首先，在IDA Pro中打开*mbr.mbr*文件并进行分析。观察到MBR的代码是加密的。定位解密例程并描述其算法。
- en: 'Analyze the MBR’s partition table and try to answer the following questions:
    How many partitions are there? Which one is the active partition? Where is this
    active partition located on the hard drive? What is its offset from the beginning
    of the hard drive and its size in sectors?'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析MBR的分区表并尝试回答以下问题：有多少个分区？哪个是活动分区？该活动分区在硬盘的哪个位置？它从硬盘开始的位置偏移是多少，它的大小是多少扇区？
- en: After locating the active partition, write the *mbr.mbr* file onto the Bochs
    image using the Python script in [Listing 9-2](ch09.xhtml#ch09list02). Write the
    *partition0.data* file onto the Bochs image at the offset found at the previous
    exercise using the Python script in [Listing 9-3](ch09.xhtml#ch09list03). After
    completing this task, you’ll have an infected Bochs image that is ready to be
    emulated.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到活动分区后，使用[清单 9-2](ch09.xhtml#ch09list02)中的Python脚本将*mbr.mbr*文件写入Bochs镜像。使用[清单
    9-3](ch09.xhtml#ch09list03)中的Python脚本将*partition0.data*文件写入Bochs镜像，并放置在上一个练习中找到的偏移位置。完成此任务后，你将拥有一个感染了的Bochs镜像，准备好进行模拟。
- en: Launch the Bochs emulator with the newly edited *bochs.bochsrc* configuration,
    using the IDA Pro frontend described in “[Combining Bochs with IDA](ch09.xhtml#ch09lev2sec5)”
    on [page 123](ch09.xhtml#page_123). The IDA Pro debugger should break at execution.
    Set a breakpoint at the address 0000:7c00h, which corresponds to the address where
    the MBR code will be loaded.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新编辑的*bochs.bochsrc*配置启动Bochs模拟器，并使用[第 123 页](ch09.xhtml#page_123)上描述的IDA Pro前端，在“[将Bochs与IDA结合使用](ch09.xhtml#ch09lev2sec5)”中启动。IDA
    Pro调试器应该在执行时触发断点。设置断点在地址0000:7c00h处，该地址对应MBR代码将被加载的位置。
- en: When the breakpoint at address 0000:7c00h is hit, check that the MBR’s code
    is still encrypted. Set the breakpoint on the decryption routine identified earlier
    and resume execution. When the decryption routine breakpoint is hit, trace it
    until all the MBR’s code is completely decrypted. Dump the decrypted MBR into
    a file for further static analysis. (Refer to [Chapter 8](ch08.xhtml#ch08) for
    MBR static analysis techniques.)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命中地址 0000:7c00h 处的断点时，检查MBR的代码是否仍然是加密的。设置早前识别出的解密例程的断点并恢复执行。当解密例程的断点被触发时，追踪它直到所有MBR代码完全解密。将解密后的MBR转储到文件中，以便进一步的静态分析。（有关MBR静态分析技术，请参阅[第
    8 章](ch08.xhtml#ch08)）。
