- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 13 DNS MONITOR
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13 DNS 监控器
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, I’ll focus on the practicalities of building a deployable host-based
    network monitor capable of proxying and blocking DNS traffic from unrecognized
    processes or destined for untrusted domains.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将专注于构建一个可部署的基于主机的网络监控器的实际操作，能够代理并阻止来自未识别进程或指向不可信域的 DNS 流量。
- en: '[Chapter 7](chapter7.xhtml) covered the basic design of a DNS proxy capable
    of monitoring traffic via Apple’s *NetworkExtension* framework. There, however,
    I skipped over many of the steps required to build a deployable tool, including
    obtaining necessary entitlements and correctly bundling the extension within a
    host application. This chapter will discuss these tasks, as well as ways of extending
    a basic monitor, such as by parsing DNS queries and responses to block those found
    on a block list.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](chapter7.xhtml)介绍了一个基本的 DNS 代理设计，能够通过苹果的*NetworkExtension* 框架监控流量。然而，在那一章中，我跳过了许多构建可部署工具所需的步骤，包括获取必要的权限和正确地将扩展打包到主机应用程序中。本章将讨论这些任务，以及如何扩展一个基本的监控器，例如通过解析
    DNS 查询和响应来阻止那些出现在封锁列表中的查询。'
- en: You can find these capabilities and more in the open source DNSMonitor, which
    is part of Objective-See’s tool suite ([*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DNSMonitor*](https://github.com/objective-see/DNSMonitor)).
    I recommend that you download the project or reference the source code in the
    repository while reading the chapter, as the following discussions often omit
    parts of the code for brevity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在开源的 DNSMonitor 中找到这些能力和更多内容，DNSMonitor 是 Objective-See 工具套件的一部分（[*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DNSMonitor*](https://github.com/objective-see/DNSMonitor)）。我建议你在阅读本章时下载该项目或参考仓库中的源代码，因为接下来的讨论常常为了简洁起见省略了部分代码。
- en: '### Network Extension Deployment Prerequisites'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### 网络扩展部署先决条件'
- en: Modern networking monitors, including DNSMonitor, make use of the network extension
    framework. Because they’re packaged as system extensions and run as stand-alone
    processes with elevated privileges, Apple requires developers to entitle and bundle
    them in a very specific way. In [Chapter 11](chapter11.xhtml), we walked through
    the process of obtaining the Endpoint Security entitlement and then creating a
    provisioning profile for the tool in the Apple Developer portal. If you’re building
    a network extension, you’ll follow a similar process, with a few key differences.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络监控工具，包括 DNSMonitor，利用了网络扩展框架。因为它们作为系统扩展打包并以独立进程运行，具有提升的权限，苹果要求开发者以非常特定的方式授予权限并打包这些扩展。在[第11章](chapter11.xhtml)中，我们详细讲解了如何获取端点安全权限，并在
    Apple Developer 门户中为该工具创建配置文件。如果你正在构建一个网络扩展，你将遵循类似的流程，虽然有一些关键的不同之处。
- en: First, you’ll need to generate two provisioning profiles, one for the network
    extension and another for the application that contains and loads the extension.
    Follow the process described in [Chapter 11](chapter11.xhtml) to create an ID
    for each item on the Apple Developer site. When asked to select capabilities for
    the extension, check **Network Extensions**, which maps to the *com.apple .developer.networking.networkextension*
    entitlement. Any developer can use this entitlement (unlike the Endpoint Security
    entitlement, which requires explicit approval from Apple). For the application,
    select that same capability, as well as **System Extension**, which will allow
    the application to install, load, and manage the extension. Once you’ve created
    both IDs, create the two provisioning profiles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要生成两个配置文件，一个用于网络扩展，另一个用于包含并加载扩展的应用程序。按照[第11章](chapter11.xhtml)中描述的流程，在
    Apple Developer 网站上为每个项目创建一个 ID。当要求选择扩展的能力时，勾选**网络扩展**，这对应于*com.apple.developer.networking.networkextension*
    权限。任何开发者都可以使用这个权限（与端点安全权限不同，后者需要苹果的明确批准）。对于应用程序，选择相同的能力，以及**系统扩展**，这将允许应用程序安装、加载和管理扩展。一旦你创建了这两个
    ID，就可以创建这两个配置文件。
- en: 'Now you must install each provisioning profile in Xcode. If you look at the
    *DNSMonitor* project, you’ll see that it contains two targets: the extension and
    its host application. When you click either of these targets, the Signing and
    Capabilities tab should provide an option to specify the relevant provisioning
    profile. Apple’s developer documentation recommends enabling manual signing by
    leaving the Automatically Manage Signing option unchecked.^([1](#chapter13-1))'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The Signing and Capabilities tab will also show that the DNSMonitor project
    has enabled additional capabilities for both the extension and application that
    match those we specified when building the provisioning profile. The extension
    specifies the Network Extensions capability, while the app specifies both Network
    Extensions and System Extensions. If you’re building your own network extension,
    you’ll have to add these capabilities manually by clicking the + next to Capabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, adding these capabilities applies the relevant entitlements
    to each target’s *entitlements.plist*. Unfortunately, we must manually edit these
    *entitlements.plist* files. Adding the Network Extensions capability and checking
    DNS Proxy will add the entitlement with a value of dns-proxy, but we’ll need a
    value of dns-proxy-systemextension to deploy an extension signed with a developer
    ID.^([2](#chapter13-2)) [Listing 13-1](chapter13.xhtml#Lis13-1) shows this in
    the extension’s *entitlements .plist* file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: We must entitle network extensions and specify an extension type.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The file includes the network extension entitlement as a key, along with an
    array holding any extension types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the Extension
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any tool that uses a network extension must implement it as a system extension,
    then structure itself in a specific way so that macOS can validate and activate
    it. Specifically, Apple requires that any system extension be packaged within
    a bundle, such as an application, in the bundle’s *Contents/Library/SystemExtensions/*
    directory. A provisioning profile must also authorize the use of restricted entitlements,
    and we can’t embed provisioning profiles directly into a stand-alone binary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'For these reasons, DNSMonitor contains two components: a host application and
    a network extension.^([3](#chapter13-3)) To properly package the extension in
    Xcode, we specify the application component dependency on the extension under
    **Build Phases**. We set the destination to **System Extensions** so that macOS
    will copy the extension into the application’s *Contents/Library/SystemExtensions/*
    directory while building the application ([Figure 13-1](chapter13.xhtml#fig13-1)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The application contains a build step to embed the system extension.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to the extension’s *Info.plist* file ([Listing
    13-2](chapter13.xhtml#Lis13-2)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: The extension’s Info.plist file contains various key-value pairs
    specific to network extensions.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-2：扩展的 Info.plist 文件包含特定于网络扩展的各种键值对。
- en: We set CFBundlePackageType to a variable ❶ that the compiler will replace with
    the project’s type, systemextension. The NetworkExtension key holds a dictionary
    containing key and value pairs relevant to network extensions ❷. The NEMachServiceName
    key specifies the name of the Mach service the extension can use for XPC communications
    ❸. Also, note the NEProviderClasses key, which contains the network extension’s
    type and the name of the class within DNSMonitor that implements the required
    network extension logic ❹. In [Chapter 7](chapter7.xhtml), I mentioned that this
    class should implement NEDNSProxyProvider delegate methods. We must also link
    the extension component against the *NetworkExtension* framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 CFBundlePackageType 设置为一个变量 ❶，编译器会将其替换为项目的类型，systemextension。NetworkExtension
    键保存一个字典，其中包含与网络扩展相关的键值对 ❷。NEMachServiceName 键指定扩展可以用于 XPC 通信的 Mach 服务的名称 ❸。此外，请注意
    NEProviderClasses 键，其中包含网络扩展的类型以及在 DNSMonitor 中实现所需网络扩展逻辑的类名 ❹。在[第7章](chapter7.xhtml)中，我提到过这个类应该实现
    NEDNSProxyProvider 委托方法。我们还必须将扩展组件链接到 *NetworkExtension* 框架。
- en: The application’s *entitlements.plist* file, shown in [Listing 13-3](chapter13.xhtml#Lis13-3),
    is fairly similar to that of the extension.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 *entitlements.plist* 文件，如[Listing 13-3](chapter13.xhtml#Lis13-3)所示，与扩展的文件非常相似。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-3: The app’s entitlements.plist file also contains key-value pairs
    specific to network extensions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-3：应用程序的 entitlements.plist 文件还包含特定于网络扩展的键值对。
- en: One difference between the two is the addition of the *com.apple.developer .system-extension.install*
    entitlement, set to true. We indirectly added this entitlement to the app’s provisioning
    profile when we granted it the System Extension capability. The app needs this
    entitlement to install and activate the network extension.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 两者的一个区别是添加了 *com.apple.developer.system-extension.install* 权限，设置为 true。我们通过授予应用程序系统扩展功能间接将此权限添加到应用程序的配置文件中。应用程序需要此权限才能安装并激活网络扩展。
- en: Tool Design
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具设计
- en: Now that I’ve explained the components of DNSMonitor, let’s focus on how it
    operates, starting with launching the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经解释了 DNSMonitor 的组成部分，让我们关注它是如何工作的，从启动应用程序开始。
- en: The App
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序
- en: You can find the initialization logic for the app in the *DNSMonitor/App/main.m*
    file. After performing some basic argument parsing (for example, checking whether
    the user invoked the app with the -h flag to show the default usage), the app
    retrieves the responsible parent’s bundle ID. If this parent is the Finder or
    the Dock (the likely parents in scenarios where the user double-clicked the app
    icon), the app displays an informative alert explaining that DNSMonitor should
    run from the terminal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*DNSMonitor/App/main.m*文件中找到应用程序的初始化逻辑。经过一些基本的参数解析（例如，检查用户是否通过 -h 标志启动了应用程序以显示默认用法），应用程序会获取负责的父进程的
    bundle ID。如果这个父进程是 Finder 或 Dock（在用户双击应用程序图标的场景中，通常是这些父进程），应用程序会显示一个提示，说明 DNSMonitor
    应该从终端运行。
- en: 'Also, unless we run DNSMonitor from the *Applications* directory, when the
    OSSystemExtensionRequest request:didFailWithError: delegate method is invoked
    by the application to activate the extension, it will fail:^([4](#chapter13-4))'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，除非我们从 *Applications* 目录运行 DNSMonitor，否则当应用程序调用 OSSystemExtensionRequest
    request:didFailWithError: 委托方法来激活扩展时，它将失败：^([4](#chapter13-4))'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, when run from the terminal, DNSMonitor checks that it’s executing from the
    correct directory before loading the network extension component. If not, it prints
    an error message and exits ([Listing 13-4](chapter13.xhtml#Lis13-4)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当从终端运行时，DNSMonitor 会在加载网络扩展组件之前检查它是否从正确的目录执行。如果不是，它会打印错误信息并退出（[Listing 13-4](chapter13.xhtml#Lis13-4)）。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 13-4: Checking whether the monitor is running from the /Applications
    directory'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-4：检查监视器是否从 /Applications 目录运行
- en: To pass captured DNS traffic from the extension to the application so we can
    display it to the user, we use the system log. In [Listing 13-5](chapter13.xhtml#Lis13-5),
    the application initializes a custom log monitor with a predicate to match messages
    written to the log by the (soon-to-be-loaded) network extension. It then prints
    any received messages to the terminal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将捕获的 DNS 流量从扩展传递到应用程序，以便我们可以将其显示给用户，我们使用系统日志。在[Listing 13-5](chapter13.xhtml#Lis13-5)中，应用程序初始化了一个自定义日志监视器，并使用谓词匹配由（即将加载的）网络扩展写入日志的消息。然后它会将任何接收到的消息打印到终端。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 13-5: The app’s log monitor ingests DNS traffic captured in the extension.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-5：应用程序的日志监视器获取在扩展中捕获的 DNS 流量。
- en: In other cases, you might want to use a more robust mechanism, such as XPC,
    to pass data back and forth between the extension and the app, but for a simple
    command line tool, the universal logging subsystem suffices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能希望使用更强大的机制，如 XPC，来在扩展和应用程序之间来回传递数据，但对于一个简单的命令行工具，通用日志子系统已经足够。
- en: Before loading the network extension, the app sets up a signal handler for the
    interrupt signal (SIGINT). As a result, when the user presses CTRL-C, the app
    can unload the extension and gracefully exit ([Listing 13-6](chapter13.xhtml#Lis13-6)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载网络扩展之前，应用程序设置了一个中断信号（SIGINT）的信号处理器。因此，当用户按下 CTRL-C 时，应用程序可以卸载扩展并优雅地退出（[示例
    13-6](chapter13.xhtml#Lis13-6)）。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 13-6: Setting up a custom interrupt signal handler'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-6：设置自定义中断信号处理器
- en: First, the code ignores the default SIGINT action ❶. Then it creates a dispatch
    source for the interrupt signal ❷ and sets a custom handler with the dispatch_source_set_event_handler
    API ❸. The custom handler invokes a helper function, stopExtension, to unload
    and uninstall the network extension before exiting. Though not shown here, the
    monitor can be executed with a command line option to skip unloading the extension
    when it exits. This alleviates the need to restart, and thus reapprove, the extension
    each time the monitor is restarted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码忽略默认的 SIGINT 操作 ❶。然后，它为中断信号创建一个调度源 ❷，并使用 dispatch_source_set_event_handler
    API 设置一个自定义处理器 ❸。这个自定义处理器调用一个辅助函数 `stopExtension`，在退出之前卸载并移除网络扩展。虽然这里没有显示，但监视器可以通过命令行选项执行，以便在退出时跳过卸载扩展。这避免了每次重启监视器时都需要重新启动并重新批准扩展。
- en: Finally, the app installs and activates the network extension. Because I covered
    this process in full detail in [Chapter 7](chapter7.xhtml), I won’t repeat it
    here, other than to note that it involves making an OSSystemExtensionRequest request
    and configuring an NEDNSProxyManager object. You can find the full installation
    and activation code in DNSMonitor’s *App/Extension.m* file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序安装并激活了网络扩展。由于我在[第 7 章](chapter7.xhtml)中详细讲解了这个过程，因此在这里不再重复，只需要说明它涉及发出
    OSSystemExtensionRequest 请求并配置 NEDNSProxyManager 对象。你可以在 DNSMonitor 的 *App/Extension.m*
    文件中找到完整的安装和激活代码。
- en: With the network extension running, the app tells the current run loop to continue
    until it receives an interrupt signal from the user, as it needs to hang around
    to print out captured DNS traffic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络扩展运行时，应用程序告知当前的运行循环继续，直到接收到来自用户的中断信号，因为它需要保持运行以打印捕获的 DNS 流量。
- en: The Extension
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Behind the scenes, when an application invokes the APIs to install and activate
    a network extension, macOS copies the extension from the app’s *Contents/Library/SystemExtensions/*
    directory into a privileged directory, */Library/SystemExtensions/<UUID>/*, validates
    it, then executes it with root privileges. Run the ps command to show the activated
    network extension’s process information, such as its privilege level, process
    ID, and path:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，当一个应用程序调用 API 来安装和激活网络扩展时，macOS 会将扩展从应用程序的 *Contents/Library/SystemExtensions/*
    目录复制到一个特权目录，*/Library/SystemExtensions/<UUID>/*，对其进行验证，然后以 root 权限执行它。运行 `ps`
    命令以显示已激活的网络扩展进程信息，例如其权限级别、进程 ID 和路径：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once loaded, DNSMonitor’s extension opens a handle to the universal logging
    subsystem via the os_log_create API, as it passes captured DNS traffic to the
    app using log messages. The logging API takes two parameters that allow you to
    specify a subsystem and a category ([Listing 13-7](chapter13.xhtml#Lis13-7)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，DNSMonitor 的扩展通过 os_log_create API 打开一个通用日志子系统的句柄，因为它通过日志消息将捕获的 DNS 流量传递给应用程序。日志
    API 有两个参数，允许你指定子系统和类别（[示例 13-7](chapter13.xhtml#Lis13-7)）。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 13-7: Opening a log handle in the extension'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-7：在扩展中打开日志句柄
- en: By specifying a subsystem or a category, you can easily create predicates that
    return only certain messages, as we did in the application ([Listing 13-5](chapter13.xhtml#Lis13-5)).
    Next, the extension invokes the NEProvider class’s startSystemExtensionMode method,
    which you’ll recall will instantiate the class specified under the NEProviderClasses
    key in the extension’s *Info.plist* file. The extension uses its DNSProxyProvider
    class, which inherits from the NEDNSProxyProvider class ([Listing 13-8](chapter13.xhtml#Lis13-8)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个子系统或类别，你可以轻松创建只返回特定消息的谓词，正如我们在应用程序中所做的那样（[列表 13-5](chapter13.xhtml#Lis13-5)）。接下来，扩展调用
    NEProvider 类的 startSystemExtensionMode 方法，你可能记得该方法会实例化在扩展的*Info.plist* 文件中 NEProviderClasses
    键下指定的类。扩展使用它的 DNSProxyProvider 类，该类继承自 NEDNSProxyProvider 类（[列表 13-8](chapter13.xhtml#Lis13-8)）。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 13-8: The interface for the DNSProxyProvider class'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-8：DNSProxyProvider 类的接口
- en: In [Chapter 7](chapter7.xhtml), I described how a DNS monitor could implement
    the various NEDNSProxyProvider methods, such as the all-important handleNewFlow:,
    which will be automatically invoked for all new DNS flows. As such, I won’t cover
    this again here, though you can find the full code in the *Extension/DNSProxyProvider.m*
    file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](chapter7.xhtml)中，我描述了 DNS 监视器如何实现各种 NEDNSProxyProvider 方法，比如至关重要的 handleNewFlow:，该方法会自动为所有新的
    DNS 流调用。因此，我在这里不再详细讲解这一部分，尽管你可以在*Extension/DNSProxyProvider.m* 文件中找到完整的代码。
- en: Previous chapters didn’t cover how the extension sends the message to the app
    via the log, builds a DNS cache, and blocks specific requests or responses. Let’s
    explore these topics in more detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节没有讲解扩展如何通过日志将消息发送到应用程序，如何构建 DNS 缓存，以及如何阻止特定的请求或响应。接下来，我们将更详细地探讨这些主题。
- en: Interprocess Communication
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程间通信
- en: I mentioned that when DNSMonitor’s network extension receives a new DNS request
    or response, it uses the universal logging subsystem to send the message to the
    app’s log monitor, which prints it to the terminal. You can find the extension
    logic to handle the writing of DNS traffic to the log in a helper method named
    printPacket ([Listing 13-9](chapter13.xhtml#Lis13-9)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，当 DNSMonitor 的网络扩展接收到新的 DNS 请求或响应时，它会使用通用日志子系统将消息发送到应用程序的日志监视器，后者会将其打印到终端。你可以在一个名为
    printPacket 的辅助方法中找到处理将 DNS 流量写入日志的扩展逻辑（[列表 13-9](chapter13.xhtml#Lis13-9)）。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 13-9: Printing a DNS packet to the universal log'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-9：将 DNS 数据包打印到通用日志
- en: 'A helper function named getProcessInfo: creates a dictionary that describes
    the process responsible for generating the DNS traffic. The code then writes the
    dictionary to the log using the os_log API ❶.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '一个名为 getProcessInfo: 的辅助函数创建了一个字典，用于描述生成 DNS 流量的进程。然后，代码通过 os_log API ❶ 将字典写入日志。'
- en: Writing the bytes of the DNS packet is a bit more complicated, because the macOS
    dns_print_reply API, which formats raw DNS packets, expects to print to a file
    stream pointer (FILE *), such as stdout. On the other hand, universal logging
    APIs take an os_log_t instead of a FILE *. We circumvent this minor obstacle by
    having dns_print_reply indirectly write to a memory buffer, which we can log via
    os_log.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 DNS 数据包的字节稍微复杂一些，因为 macOS 的 dns_print_reply API（用于格式化原始 DNS 数据包）期望写入一个文件流指针（FILE
    *），例如 stdout。另一方面，通用日志 API 使用的是 os_log_t，而不是 FILE *。我们通过让 dns_print_reply 间接写入内存缓冲区来绕过这个小障碍，之后我们可以通过
    os_log 将其记录下来。
- en: To make dns_print_reply write to a buffer, we pass it a file handle that, unbeknownst
    to the function, is backed by a buffer, created thanks to the often-overlooked
    open_memstream API ❷. The dns_print_reply function formats the raw DNS packet
    and then happily writes it via the file handle ❸. After invoking fflush to ensure
    all buffered data is written out to the underlying memory ❹, we write the parsed
    DNS packet to the universal log with a second call to os_log. As I previously
    noted, the log monitor in the app component can now ingest the message and print
    it to the user’s terminal.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 dns_print_reply 写入缓冲区，我们传递给它一个文件句柄，该句柄背后是一个缓冲区，它是通过常常被忽视的 open_memstream
    API ❷ 创建的。dns_print_reply 函数格式化原始 DNS 数据包，然后通过文件句柄 ❸ 将其写入。调用 fflush 确保所有缓冲的数据被写入底层内存
    ❹ 后，我们通过第二次调用 os_log 将解析后的 DNS 数据包写入通用日志。正如我之前提到的，应用程序组件中的日志监视器现在可以接收该消息并将其打印到用户的终端。
- en: Building and Dumping DNS Caches
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和转储 DNS 缓存
- en: It always surprises me that macOS doesn’t provide a way to dump cached DNS resolutions,
    which contain the requested domains and resolved IP addresses. As you’ll see in
    this section, however, DNS cache dumping is easy enough to implement in a DNS
    monitor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: When the DNSMonitor network extension starts, it creates a global array to store
    dictionaries of the mappings between DNS requests (questions) and their responses
    (answers). It implements this logic in a helper method named cache:, which takes
    a parsed DNS response packet that contains both the questions and any answers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The majority of code within the cache: method is dedicated to extracting the
    questions and answers from the DNS response packet, which can contain multiples
    of both. We covered this process in [Chapter 7](chapter7.xhtml), so we won’t repeat
    it here, but you can find the method’s full code in *Extension/DNSProxyProvider.m*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve extracted all questions and answers from the DNS response packet,
    we add them to the global cache array, named dnsCache ([Listing 13-10](chapter13.xhtml#Lis13-10)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 13-10: Saving DNS questions and answers to a cache'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'As DNS responses can arrive and be processed asynchronously, we synchronize
    access to the global cache by wrapping it in a @synchronized block ❶. Before adding
    another entry, the code checks that the cache hasn’t grown too large. If it has,
    it rather bluntly prunes the first half to evict the oldest ones ❷. Finally, it
    adds an entry for each question and its answers ❸ using the NSMutableArray’s addObject:
    method. Note that the snippet of code @{question:answers} uses the Objective-C
    shorthand @{} to create a dictionary whose key is the question and whose value
    is a list of answers ❹.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the extension is caching DNS questions and answers. The entries
    generated by resolving NoStarch.com and Objective-See.org would look like the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To facilitate the dumping of this cache, the extension installs a signal handler
    for the signal SIGUSR1, otherwise known as *user signal 1* ([Listing 13-11](chapter13.xhtml#Lis13-11)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 13-11: Installing a signal handler for user signal 1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, any adequately privileged process on the system can send a SIGUSR1 to
    the extension. Here’s how to do this manually in the terminal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The kill shell command benignly sends a SIGUSR1 to the extension, whose process
    ID we find via pgrep. Because the extension is running with root privileges, we
    must elevate our privileges with sudo to deliver a signal.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: As the code in [Listing 13-11](chapter13.xhtml#Lis13-11) showed, the extension
    sets the handler for SIGUSR1 to a function named dumpDNSCache. Let’s take a look
    at this function. Shown in [Listing 13-12](chapter13.xhtml#Lis13-12), it straightforwardly
    writes each cache entry to the universal log.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 13-12: When the code receives a SIGUSR1 signal, it dumps the cache
    to the log.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In a for loop, the code iterates over all entries in its global DNS cache. Recall
    that this cache is an array of dictionaries. Each entry’s dictionary contains
    a single key representing the DNS question, and the code extracts it with the
    firstObject property of the allKeys array ❶. Then, using os_log, it writes the
    question and the corresponding answers ❷. Note the use of the public keyword,
    which tells the logging subsystem not to redact the cache data being logged.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环中，代码遍历其全局 DNS 缓存中的所有条目。回想一下，这个缓存是一个字典数组。每个条目的字典包含一个表示 DNS 问题的键，代码通过
    allKeys 数组的 firstObject 属性提取它 ❶。然后，使用 os_log，它将问题和相应的答案写入日志 ❷。请注意使用 public 关键字，这告诉日志子系统不要编辑正在记录的缓存数据。
- en: 'When you send a SIGUSR1 to the extension while the DNSMonitor application component
    is running, it will automatically ingest the log message containing the dumped
    cache and print it out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 DNSMonitor 应用组件运行时向扩展发送 SIGUSR1 信号，它会自动处理包含转储缓存的日志消息并打印出来：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because the extension writes the items in its cache to the universal log, you
    can also view these messages directly via the log command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为扩展将缓存中的条目写入通用日志，你也可以通过 log 命令直接查看这些消息：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I recommend specifying the filter predicate, however, because otherwise, you’ll
    be inundated with irrelevant log messages from the rest of the system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我建议指定过滤条件，因为如果不这样做，你会被系统其他部分的无关日志消息淹没。
- en: Blocking DNS Traffic
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻止 DNS 流量
- en: So far, we’ve focused on passive actions, such as printing DNS requests and
    responses and dumping an extension-built cache. But what if we wanted to extend
    the monitor to block certain traffic? [Chapter 7](chapter7.xhtml) covered Apple’s
    official way of blocking traffic using a network extension that implements a filter
    data provider to allow, drop, or pause network flows. Objective-See’s open source
    firewall LuLu takes this approach.^([5](#chapter13-5))
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们集中讨论了被动操作，比如打印 DNS 请求和响应以及转储扩展构建的缓存。但是，如果我们想扩展监控器来阻止某些流量呢？[第 7 章](chapter7.xhtml)介绍了苹果官方使用网络扩展来阻止流量的方法，该扩展实现了一个过滤数据提供者，用于允许、丢弃或暂停网络流。Objective-See
    的开源防火墙 LuLu 采用了这种方法。^([5](#chapter13-5))
- en: It turns out we can also block DNS traffic using an NEDNSProxyProvider object.
    Because we’re already proxying all DNS traffic, nothing stops us from closing
    any flow we so choose. A benefit of sticking with the NEDNSProxyProvider class
    is that the system routes only DNS traffic through the extension. Because we’re
    not interested in other types of traffic, this keeps our code efficient. On the
    other hand, a filter data provider would make us responsible for examining and
    responding to all network flows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们还可以使用 NEDNSProxyProvider 对象来阻止 DNS 流量。因为我们已经代理了所有 DNS 流量，所以没有什么能阻止我们关闭我们选择的任何流。坚持使用
    NEDNSProxyProvider 类的一个好处是，系统只会将 DNS 流量路由到扩展中。因为我们不关心其他类型的流量，这使我们的代码保持高效。另一方面，过滤数据提供者会让我们负责检查和响应所有网络流。
- en: One simple approach to specifying what DNS traffic to block is to use a block
    list. This block list could contain the domains and IP addresses of known malware
    command-and-control servers, unscrupulous internet service providers, or even
    servers that track users or display ads. Whenever an application attempts to resolve
    a domain, macOS will proxy the request through the extension, which can examine
    the request and block it if the domain is on the list. On the flip side, once
    a remote DNS server has processed a request and resolved the domain, macOS will
    proxy the response back through the extension before sending it to the application
    that made the original request. This gives the extension a chance to examine the
    response and block it if it contains a banned IP address.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止 DNS 流量的一种简单方法是使用阻止列表。这个阻止列表可以包含已知恶意软件指挥与控制服务器、不道德的互联网服务提供商，甚至是跟踪用户或展示广告的服务器的域名和
    IP 地址。每当应用程序尝试解析一个域名时，macOS 将通过扩展代理该请求，扩展可以检查该请求，并在域名在列表中时阻止它。反过来，一旦远程 DNS 服务器处理了请求并解析了域名，macOS
    将通过扩展将响应代理回应用程序，然后再发送给发起原始请求的应用程序。这给扩展一个机会来检查响应，如果响应包含被禁止的 IP 地址，则阻止它。
- en: You can find the logic to block a domain or IP address in the extension, in
    a method named shouldBlock:. This method accepts a parsed DNS packet of type dns_reply_t
    (used for both requests and responses) and returns a Boolean to indicate whether
    to block it. The method’s logic is rather involved, as it must handle both IPv4
    and IPv6, so I won’t show its entire code here. [Listing 13-13](chapter13.xhtml#Lis13-13)
    includes the part of the method that checks whether requests contain any domains
    on the block list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 13-13: Checking for domains to block'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The code first initializes a dns_header_t pointer to the header of the parsed
    DNS packet. Defined in Apple’s *dns_util.h* file, it contains flags (to indicate
    the type of DNS packet) and various counts, such as the number of questions and
    answers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code in [Listing 13-13](chapter13.xhtml#Lis13-13) checks the header’s flags
    member to see whether the DNS_FLAGS_QR_QUERY bit is set ❶. This flag indicates
    that the DNS packet is a query containing one or more domains to resolve. (You
    won’t find constants such as DNS_FLAGS_QR_QUERY in any header file, as Apple defines
    them in *dns_util.c*, so you might want to copy them directly into your own code.)
    Assuming the DNS packet contains a query, the code then iterates over each domain
    in the request ❷. The number of domains is stored in the qdcount member of the
    header structure, while each domain to be resolved can be found in the packet’s
    question array. The code extracts each domain and converts it to a more manageable
    Objective-C string object ❸ before checking whether it matches any of the items
    in the global block list ❹. If so, the code sets a flag, breaks, and returns.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Though not shown here, the code to check a response packet is similar. Response
    packets list the number of answers in the ancount member of the header structure
    and provide the answers themselves in the answer array. Apple defines the dns_resource_record_t
    structure to store these answers in the *dns_util.h* header file. This structure
    contains, among other things, a dnstype member, which specifies the answer’s type,
    such as A or CNAME. So, to extract an IPv4 address from a DNS A record into an
    Objective-C object, you might write code similar to [Listing 13-14](chapter13.xhtml#Lis13-14).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 13-14: Extracting an answer from a DNS A record'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'If a question or an answer matches an entry in DNSMonitor’s global block list,
    the shouldBlock: method returns YES, the Objective-C equivalent of true.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of the shouldBlock: method’s invocation dictates how the flow
    closes. For example, it’s easy to block a question, as DNSMonitor is really a
    proxy that is responsible for making the actual connection to the remote DNS server
    and thus we can close the local flow using the closeWriteWithError: method ([Listing
    13-15](chapter13.xhtml#Lis13-15)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 13-15: Closing a local flow'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To block an answer, we should make sure to also clean up the remote connection
    with the DNS server that provided the answer ([Listing 13-16](chapter13.xhtml#Lis13-16)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 13-16: Closing a remote flow'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: DNSMonitor uses the nw_connection_receive API to proxy responses. Thus, to block
    any responses, it first closes the flow and then calls nw_connection _cancel to
    cancel the connection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, I should mention that you could also handle DNS blocking by
    returning a response with the response code set to what is known as a *name error*
    or, more simply, NXDOMAIN. Such a response would tell the requestor that the domain
    wasn’t found, meaning the resolution failed. DNSMonitor takes this approach when
    executed with the -nx command line option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To generate such a response, you could take the DNS request or response packet
    and modify the flags in its header in the manner shown in [Listing 13-17](chapter13.xhtml#Lis13-17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 13-17: Crafting an NXDOMAIN response'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The code expects a DNS packet in a mutable data object. It first typecasts the
    packet’s bytes to a dns_header_t pointer. Next, it sets the QR bit of the flags
    field in the header to indicate that the packet is a response. Following this,
    it clears the RCODE (response code) bits before setting just the NXDOMAIN response
    code. You can read more about the DNS header and these fields in the RFP 1035
    that defines the technical specifications of DNS.^([6](#chapter13-6))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Classifying Endpoints
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using a hardcoded block list, a tool could determine whether to
    block DNS requests or responses heuristically, for example, by examining historical
    DNS records, WHOIS data, and any SSL/TLS certificates.^([7](#chapter13-7)) Let’s
    look at each of these techniques more closely, using the 3CX supply chain attack
    as an example. The *3cx.cloud* domain used in the attack is a legitimate part
    of 3CX’s infrastructure, but the attacker-controlled *msstorageboxes.com* domain,
    used by the malicious code introduced into the application, raises some red flags:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Historical DNS records** At the time of the 3CX supply chain attack in March
    2023, only one DNS record existed for the *msstorageboxes.com* domain, which had
    been registered just a few months prior. Trusted domains usually have a longer
    history and many DNS records. On the other hand, hackers often register domains
    for their command-and-control servers just before their attacks and tear them
    down shortly thereafter. Of course, hackers sometimes leverage previously legitimate
    domains that they either bought through standard domain procurement processes
    or obtained when domain registration lapsed. Again, you’ll see this activity reflected
    in the domain’s historical DNS records.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Redacted WHOIS data** The attackers redacted WHOIS data for the *msstorageboxes.com*
    domain for privacy reasons. It’s unusual for a large, well-established company
    to hide its identity. For example, the legitimate 3cx.cloud domain clearly shows
    that it’s registered to 3CX Software DMCC.'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Domain name registrar** The attackers registered the *msstorageboxes.com*
    domain via NameCheap. Well-established companies often choose more enterprise-focused
    domain registrars, such as CloudFlare.'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '### Conclusion'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: A DNS monitor capable of tracking all requests and responses is a powerful tool
    for malware detection. In this chapter, I built on [Chapter 7](chapter7.xhtml)
    to describe how you might implement such a monitor atop Apple’s *NetworkExtension*
    framework. I showed you how to add capabilities to the tool, such as a cache and
    blocking capabilities, to extend its functionality.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In the book’s final chapter, we’ll pit tools such as this DNS monitor against
    real-life Mac malware. Read on to see how each side fares!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter13_1).  “Network Extensions Entitlement,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/bundleresources<wbr>/entitlements<wbr>/com<wbr>_apple<wbr>_developer<wbr>_networking<wbr>_networkextension*](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_networking_networkextension).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter13_2).  psichel, “com.apple.developer.networking.networkextension
    Entitlements Don’t Match PP,” Apple Developer Forums, November 15, 2020, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/forums<wbr>/thread<wbr>/667045*](https://developer.apple.com/forums/thread/667045).'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter13_3).  “Signing a Daemon with a Restricted Entitlement,” Apple
    Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/signing<wbr>-a<wbr>-daemon<wbr>-with<wbr>-a<wbr>-restricted<wbr>-entitlement*](https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement).'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter13_4).  “Installing System Extensions and Drivers,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/installing<wbr>-system<wbr>-extensions<wbr>-and<wbr>-drivers<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc).'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter13_5).  See [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/LuLu*](https://github.com/objective-see/LuLu).'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter13_6).  See “Domain Names—Implementation and Specification,”
    RFC 1035, Internet Engineering Task Force, [*https://<wbr>datatracker<wbr>.ietf<wbr>.org<wbr>/doc<wbr>/html<wbr>/rfc1035*](https://datatracker.ietf.org/doc/html/rfc1035).'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter13_7).  Esteban Borges, “How to Perform Threat Hunting Using
    Passive DNS,” *Security Trails*, [*https://<wbr>securitytrails<wbr>.com<wbr>/blog<wbr>/threat<wbr>-hunting<wbr>-using<wbr>-passive<wbr>-dns*](https://securitytrails.com/blog/threat-hunting-using-passive-dns).'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter13_7).  Esteban Borges，“如何使用被动 DNS 进行威胁狩猎”，*Security Trails*，[*https://<wbr>securitytrails<wbr>.com<wbr>/blog<wbr>/threat<wbr>-hunting<wbr>-using<wbr>-passive<wbr>-dns*](https://securitytrails.com/blog/threat-hunting-using-passive-dns)。'
