["```\nInitialize swarm:\n**for i** = 0 .. < swarm size\n        **for j** = 0 .. < number of dimensions\n                **initialize** position to random values per Equation 9.1\n                **initialize** velocity to 0 per Equation 9.2\n        **end for**\n        **create** pBest[i] (with same position and fitness)\n        **create** swarm[i]\n        **if** fitness(swarm[i]) < fitness(gBest)\n                update gBest\n        **end if**\n**end for**\n\nIterate over a preset number of time steps:\n**for time step** = 0 .. < tmax\n        **update** w per Equation 9.4\n        **for i** = 0 .. < swarm size\n                **for j** = 0 .. < number of dimensions\n                        **update** velocity per Equation 9.3\n                        **check** velocity within bounds per Equation 9.5\n                        **update** position per Equation 9.7\n                        **check** position within bounds\n                **end for**\n                **update** fitness of swarm[i]\n                **if** fitness(swarm[i]) < fitness(pBest[i])\n                        **update** pBest[i]\n                **end if**\n                **if** fitness(swarm[i]) < fitness(gBest)\n                        **update** gBest\n                **end if**\n        **end for**\n**end for**\n```", "```\nimport kotlin.math.sin\nimport kotlin.math.pow\nimport kotlin.math.abs\nimport kotlin.math.sqrt\nimport kotlin.math.min\nimport kotlin.math.max\n\n❶ data class Solution(\n    var pos: DoubleArray,\n    var fitness: Double\n)\n\n❷ data class Particle(\n    val id: Int,\n    val pos: DoubleArray,\n    val vel: DoubleArray,\n    var fitness: Double,\n    val pBest: Solution\n)\n\n// problem definition\n❸ val getFitness = ::eggHolder\nval nDim = 2    // number of variables in the cost function\nval xBbounds = arrayOf(doubleArrayOf(-512.0, 512.0),\n                       doubleArrayOf(-512.0, 512.0))\nval xRange = doubleArrayOf(xBbounds[0][1] - xBbounds[0][0],\n                           xBbounds[1][1] - xBbounds[1][0])\nval lambda = 0.5\nval vMax = doubleArrayOf(lambda*xRange[0], lambda*xRange[1])\n\n// global parameters\nval TMAX = 50\nval SWARMSIZE = 30\nval wmax = 1.2\nval wmin = 0.5\nval wt = (wmax - wmin)/TMAX\nvar w = wmax\nval c1 = 2.0       // cognitive coefficient\nval c2 = 2.0       // social coefficient\n\n// global objects and collections\nval swarm = mutableListOf<Particle>()\nval BestSolution = Solution(doubleArrayOf(0.0, 0.0), Double.MAX_VALUE)\n```", "```\nfun initSwarm() {\n    println(\"\\nStarting initialization...\")\n\n  ❶ for (i in 0 until SWARMSIZE) {\n        // Define local objects.\n        val pos = DoubleArray(nDim)\n        val vel = DoubleArray(nDim)\n        val fitness: Double\n        val pBest: Solution\n\n // Set initial positions (random, within bounds).\n      ❷ for (j in 0 until nDim) {\n            pos[j] = xBbounds[j][0] + (xBbounds[j][1] - xBbounds[j][0]) *\n                         (0..1000).random() / 1000.0\n            vel[j] = 0.0\n        }\n\n       // Add new particles to the swarm.\n      ❸ fitness = getFitness(pos)\n        pBest = Solution(pos.copyOf(), fitness)\n      ❹ swarm += Particle(i, pos, vel, fitness, pBest)\n\n        // Update BestSolution.\n      ❺ if (fitness < BestSolution.fitness) {\n            BestSolution.pos = pos.copyOf()\n            BestSolution.fitness = fitness\n        }\n    }\n    println(\"\\nBest solution after initialization:\")\n    println(BestSolution.toString())\n}\n```", "```\nfun runPSO() {\n  ❶ for (timeStep in 0 until TMAX) {\n        // Update inertia factor as a function of time.\n        val w = wmax - timeStep * wt\n\n        // random coefficients for cognitive and social components\n        val r1 = (0..100).random()/100.0\n        val r2 = (0..100).random()/100.0\n\n // Iterate over each particle of the swarm.\n      ❷ for (i in swarm.indices) {\n            // Update velocity and position vectors.\n            for (j in 0 until nDim) {\n                // Update velocity vector, and implement bounds.\n                val C1 = w * swarm[i].vel[j]\n                val C2 = c1 * r1 * (swarm[i].pBest.pos[j]-swarm[i].pos[j])\n                val C3 = c2 * r2 * (BestSolution.pos[j] - swarm[i].pos[j])\n                val vel = C1 + C2 + C3\n\n                // Implement velocity bounds.\n                swarm[i].vel[j] = min(max(vel, -vMax[j]), vMax[j])\n\n                // Update position vector, and implement bounds.\n                swarm[i].pos[j] += swarm[i].vel[j]\n                swarm[i].pos[j] =\n                     min(max(swarm[i].pos[j], xBbounds[j][0]), xBbounds[j][1])\n            }\n\n            // Evaluate particle fitness.\n          ❸ swarm[i].fitness = getFitness(swarm[i].pos)\n\n            // Update the particle's best solution (pBest).\n          ❹ if (swarm[i].fitness < swarm[i].pBest.fitness) {\n                swarm[i].pBest.pos = swarm[i].pos.copyOf()\n                swarm[i].pBest.fitness = swarm[i].fitness\n            }\n\n            // Update the global best solution.\n          ❺ if (swarm[i].fitness < BestSolution.fitness) {\n                BestSolution.pos = swarm[i].pos.copyOf()\n                BestSolution.fitness = swarm[i].fitness\n            }\n        }\n    }\n}\n```", "```\nfun main() {\n    println(\"\\n*** Real-valued function optimization using PSO ***\\n\")\n    println(\"Function dimensions: $nDim\")\n    println(\"Swarm size: $SWARMSIZE, Max time steps: $TMAX\")\n    println(\"w_max: $wmax  w_min: $wmin\")\n    println(\"Cognitive factor (c1): $c1\")\n    println(\"Social factor (c2): $c2\")\n\n    // Initialize the swarm.\n    initSwarm()\n    // Run PSO algorithm.\n    runPSO()\n\n    // Print final results.\n    println(\"\\nBest solution after $TMAX iterations:\")\n    println(BestSolution.toString())\n}\n```", "```\n*** Real-valued function optimization using PSO ***\n\nFunction dimensions: 2\nSwarm size: 30, Max time steps: 50\nw_max: 1.2  w_min: 0.5\nCognitive factor (c1): 2.0\nSocial factor (c2): 2.0\n\nStarting initialization...\n\nBestSolution after initialization:\nSolution(pos=[-429.056, 374.784], fitness=-742.3993203916232)\n\nBestSolution after 50 iterations:\nSolution(pos=[512.0, 404.2263191597745], fitness=-959.640628508424)\n```", "```\n// preprocessing - read and initialize\n**read** nodes from file (name, number, coordinates)\n**calculate** edge lengths (Euclidian distance)\n**calculate** nearest-neighbor tour length (Cnn)\n**initialize** pheromone levels to τ0 = 1/(nCnn)\n\n// Iteratively apply ACS steps.\n**while** stopping condition not met:\n        **initialize** ants (assign id numbers and initial positions)\n        **for ant** = 0 .. < number of ants\n                **set** cities to visit for each ant\n                **while number** of cities to visit > 0:\n                        **construct tour** per Equation 9.8 & Equation 9.9\n                        **perform** local pheromone update per Equation 9.10\n                **end while**\n                // Complete the loop.\n                **return** to the start node\n                **update** ant properties\n                **perform** local pheromone update per Equation 9.10\n        **end for**\n        **update** best-so-far solution\n        **perform** global pheromone update per Equation 9.11\n**end while**\n\n// postprocessing\n**print** results\n```", "```\n// import block\nimport java.io.File\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\n// Input file location: change the datafile location as needed.\n❶ const val datafile = \"`berlin52.csv`\"\n\n❷ // global parameters\n\nval numCities = 52     // Set the number of cities.\nval numAnts = 30       // Typically set to 10-30.\nval rho = 0.1          // rho = 0.1 is recommended for ACS.\nvar pheromone0 = 0.0   // 1/(n*Cnn) for ACS\nval q0 = 0.8           // argmax parameter (0.5-0.9)\nval zeta = 0.005       // Set to a small value.\nval alpha = 1.0        // alpha = 1 for ACS.\nval beta = 2.0         // Set to 2-5.\nval iterMax = 300      // maximum number of iterations\nval maxRounds = 50     // number of times the entire process is repeated\n\n❸ // classes and collections\n\ndata class City(\n    val name: String,\n    val node: Int,\n    val x: Double,\n    val y:Double\n)\n\nclass Ant(val id: Int, val start: Int) {\n\n    var currentNode = start\n\n    val citiesToVisit = mutableListOf<Int>()\n    val pathNodes = ArrayList<Pair<Int, Int>>()\n    val pathSegments = mutableListOf<Double>()\n\n    // Set fitness to a very high value for function minimization.\n    var fitness = Double.POSITIVE_INFINITY\n\n    fun setCitiesToVisit() {\n        for (i in 0 until numCities) {\n            if (i != this.start)\n                this.citiesToVisit += i\n        }\n    }\n}\n\ndata class ArgMax(\n    val index: Int,\n    val value: Double\n)\n\ndata class Solution(\n    val iteration: Int,\n    val antID: Int,\n    val pathNodes: ArrayList<Pair<Int, Int>>,\n    val segments: List<Double>,\n    val fitness: Double\n)\n\nval cities = mutableListOf<City>()\nval ants = mutableListOf<Ant>()\nval antSolutions  = mutableListOf<Solution>()\nval bestSolutions = mutableListOf<Solution>()\n\nval edges = Array(numCities) {DoubleArray(numCities)}\nval pheromone = Array(numCities) {DoubleArray(numCities)}\nval prob = Array(numCities) {DoubleArray(numCities)}\nvar bestOverallTour = ArrayList<Pair<Int, Int>>()\n\nvar bestOverallFitness = Double.POSITIVE_INFINITY\nvar optimaCount = 0\n```", "```\nfun main() {\n    println(\"\\n*** Solving Berlin52 TSP Using the Ant Colony System ***\\n\")\n    // Conduct preprocessing.\n readCities()\n    calculateEdges()\n    calculatePheromone0()\n\n    // Repeat the process maxRounds number of times.\n\n  ❶ for (round in 1..maxRounds) {\n      ❷ initializePheromone()\n            runACS()\n        processInterimResults(round)\n        // Prepare for next iteration.\n      ❸ bestSolutions.clear()\n    }\n\n    // Print the best overall solution.\n    printBestOverallFitnessAndTour()\n    println(\"\\noptimaCount: $optimaCount\")\n}\n```", "```\nfun readCities() {\n    // Open input file and read location data.\n  ❶ val file = File(datafile)\n  ❷ val lines = file.readLines().filterNot{it.isEmpty()}\n\n    for (i in lines.indices) {\n      ❸ val items = lines[i].split(\",\")\n        if (i == 0) {\n            println(\"Reading data for \" + items[0] + \"-TSP\")\n        } else {\n            // Read Name, ID, x, y.\n          ❹ cities += City(\n                items[0],\n                items[1].trim().toInt(),\n                items[2].trim().toDouble(),\n                items[3].trim().toDouble()\n            )\n        }\n    }\n}\n```", "```\nfun calculateEdges() {\n    // Assume symmetry: edges[i][j] = edges[j][i].\n    for (i in 0 until cities.size) {\n        for (j in i until cities.size) {\n            if (i == j) {\n              ❶ edges[i][j] = 0.0\n            } else {\n ❷ edges[i][j] = sqrt((cities[i].x - cities[j].x).pow(2) +\n                      (cities[i].y - cities[j].y).pow(2))\n              ❸ edges[j][i] = edges[i][j]\n            }\n        }\n    }\n}\n```", "```\nfun calculatePheromone0() {\n    // Start at node 0 (first city in the dataset).\n  ❶ var i = 0 // Start node for the nearest-neighbor tour.\n    val citiesToVisitList = (1 until numCities).toMutableList()\n    var nearestNeighborTourLength = 0.0\n\n    // Build the nearest-neighbor tour.\n  ❷ while (citiesToVisitList.size > 0) {\n        // Set initial search parameters.\n        var nearestNode = -9999 // Use an unlikely value.\n        var nearestNodeDistance = Double.MAX_VALUE\n\n        for (j in citiesToVisitList) {\n            if (edges[i][j] < nearestNodeDistance) {\n                nearestNodeDistance = edges[i][j]\n                nearestNode = j\n            }\n        }\n\n      ❸ nearestNeighborTourLength += nearestNodeDistance\n      ❹ citiesToVisitList.remove(nearestNode)\n        i = nearestNode\n    }\n    // Add the edge connecting the last city visited and the starting city.\n  ❺ nearestNeighborTourLength += edges[i][0]\n\n    // Calculate initial pheromone value per ACS.\n  ❻ pheromone0 = 1.0/(numCities * nearestNeighborTourLength)\n}\n```", "```\nfun initializePheromone() {\n    // All edges have the same initial pheromone level.\n    for (i in 0 until numCities) {\n        for (j in i until numCities)\n            if (i != j) {\n                pheromone[i][j] = pheromone0\n                pheromone[j][i] = pheromone0\n            } else pheromone[i][j] = 0.0\n    }\n}\n```", "```\nfun runACS() {\n    var iter = 1\n    while(iter <= iterMax) {\n        // Create a new ant colony.\n      ❶ initializeAnts()\n\n        // Generate tours for all ants.\n        for (ant in ants) {\n          ❷ ant.setCitiesToVisit()\n          ❸ buildAntTour(ant)\n          ❹ antSolutions += Solution(\n                                iter,\n                                ant.id,\n                                ant.pathNodes,\n                                ant.pathSegments,\n ant.fitness)\n        }\n\n        // Get the solution with minimum fitness.\n      ❺ val bestAntSolution =\n            antSolutions.minWith(compareBy {it.fitness})\n      ❻ bestSolutions += bestAntSolution\n      ❼ globalPheromoneUpdate()\n\n        // Clear previously saved states of ants and solutions.\n        ants.clear()\n        antSolutions.clear()\n\n        // Advance the counter.\n      ❽ iter += 1\n    }\n}\n```", "```\nfun initializeAnts() {\n    // Create a list of nodes (cities) to set start nodes for ants.\n    val cityList = (0 until numCities).toList()\n    // While creating a new Ant, set its start node randomly.\n    for (i in 0 until numAnts) ants += Ant(i, cityList.random())\n}\n```", "```\nfun buildAntTour(ant: Ant) {\n\n  ❶ var i = ant.currentNode\n\n    while (ant.citiesToVisit.size > 0) {\n        // Find the next node to visit per ACS.\n      ❷ val nextNode = selectNodeToVisit(i, ant)\n\n        // edge-specific local pheromone update per ACS\n      ❸ pheromone[i][nextNode] =\n                 (1- zeta) * pheromone[i][nextNode] +\n                 (zeta * pheromone0)\n        ant.currentNode = nextNode\n        ant.pathNodes += Pair(i, nextNode)\n        ant.pathSegments += edges[i][nextNode]\n        i = ant.currentNode\n      ❹ ant.citiesToVisit.remove(nextNode)\n    }\n    // Close the loop by adding the last Pair() of nodes to the path\n    // and adding the last path segment to the tour.\n    ant.pathNodes += Pair(ant.currentNode, ant.start)\n    ant.pathSegments += edges[ant.currentNode][ant.start]\n\n    // Calculate the fitness of the entire loop (closed path).\n  ❺ ant.fitness = ant.pathSegments.sum()\n\n    // edge-specific local pheromone update for the last path segment\n  ❻ pheromone[ant.currentNode][ant.start] =\n        (1- zeta) * pheromone[ant.currentNode][ant.start] +\n        (zeta * pheromone0)\n}\n```", "```\nfun selectNodeToVisit(i: Int, ant: Ant): Int {\n\n    var chosenNode = -9999 // Use an unlikely value.\n    val argmaxList = mutableListOf<ArgMax>()\n\n    // Calculate edge probabilities and argMaxList elements.\n    var sum = 0.0\n  ❶ for (j in ant.citiesToVisit) {\n        prob[i][j] = (pheromone[i][j]).pow(alpha) /\n                     (edges[i][j]).pow(beta)\n        sum += prob[i][j]\n        argmaxList += ArgMax(j, prob[i][j])\n    }\n\n    // Calculate normalized values of the edge probabilities.\n  ❷ for (j in ant.citiesToVisit) {\n        prob[i][j] = prob[i][j] / sum\n    }\n\n    // Use argmax or roulette wheel scheme to select j.\n  ❸ val q = (0 until 1000).random()/1000.0\n\n    if (q <= q0) {\n        // Use accumulated experience more greedily per ACS.\n        val maxArgMax = argmaxList.maxWith(compareBy {it.value})\n      ❹ chosenNode = maxArgMax.index\n    } else {\n      ❺ // Use roulette wheel scheme.\n        val spin = (0 until 1000).random()/1000.0\n        var sumProb = 0.0\n        for (j in ant.citiesToVisit) {\n            sumProb += prob[i][j]\n          ❻ if (spin <= sumProb) {\n                chosenNode = j\n                break\n           }\n        }\n    }\n  ❼ return chosenNode\n}\n```", "```\nfun globalPheromoneUpdate() {\n    val bestSoFar =\n        bestSolutions.minWith(compareBy {it.fitness})\n    for (pair in bestSoFar.pathNodes) {\n        val (i,j) = pair\n        pheromone[i][j] = (1 - rho) * pheromone[i][j] + rho/bestSoFar.fitness\n    }\n}\n```", "```\nfun processInterimResults(round: Int) {\n  ❶ val bestSoFar =\n        bestSolutions.minWith(compareBy {it.fitness})\n  ❷ if (bestSoFar.fitness < bestOverallFitness) {\n        bestOverallFitness = bestSoFar.fitness\n bestOverallTour = bestSoFar.pathNodes\n    }\n\n  ❸ // Print interim results.\n    println(\"round: $round iter: ${bestSoFar.iteration}\" +\n            \"ant: ${bestSoFar.antID}\")\n    println(\"bestSoFar.fitness: ${bestSoFar.fitness}\")\n\n    // Count the number of times global optima are found.\n  ❹ if (bestSoFar.fitness - 7544.3659 < 0.0001)\n        optimaCount += 1\n    }\n```", "```\nfun printBestOverallFitnessAndTour() {\n    println(\"\\nbestOverallFitness:  $bestOverallFitness\")\n    println(\"\\nbestOverallTour: \")\n\n    for (i in bestOverallTour.indices) {\n        print(\"${bestOverallTour[i]}\".padEnd(10))\n        if ((i+1) % 5 == 0) println()\n    }\n    println()\n}\n```", "```\n*** Solving Berlin52 TSP Using the Ant Colony System ***\n\nReading data for Berlin52 TSP\n\nround: 1 iter: 245 ant: 11\nbestSoFar.fitness: 7994.43559098265\nround: 2 iter: 105 ant: 0\nbestSoFar.fitness: 7544.365901904086\nround: 3 iter: 270 ant: 2\nbestSoFar.fitness: 7842.717484844844\n\n`--snip--`\n\nround: 49 iter: 186 ant: 14\nbestSoFar.fitness: 7544.365901904086\nround: 50 iter: 226 ant: 9\nbestSoFar.fitness: 7721.297918696817\n\nbestOverallFitness:  7544.365901904086\n\nbestOverallTour:\n(14, 5)   (5, 3)    (3, 24)   (24, 11)  (11, 27)\n(27, 26)  (26, 25)  (25, 46)  (46, 12)  (12, 13)\n(13, 51)  (51, 10)  (10, 50)  (50, 32)  (32, 42)\n(42, 9)   (9, 8)    (8, 7)    (7, 40)   (40, 18)\n(18, 44)  (44, 31)  (31, 48)  (48, 0)   (0, 21)\n(21, 30)  (30, 17)  (17, 2)   (2, 16)   (16, 20)\n(20, 41)  (41, 6)   (6, 1)    (1, 29)   (29, 22)\n(22, 19)  (19, 49)  (49, 28)  (28, 15)  (15, 45)\n(45, 43)  (43, 33)  (33, 34)  (34, 35)  (35, 38)\n(38, 39)  (39, 36)  (36, 37)  (37, 47)  (47, 23)\n(23, 4)   (4, 14)\n\noptimaCount: 5\n```"]