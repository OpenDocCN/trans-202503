- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PERFORMANCE
    AND EFFICIENCY</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Few programmers set out to write inefficient code, but we don’t always have
    time to fine-tune an algorithm to extract the maximum possible performance. Nevertheless,
    it’s important to understand how some coding practices can hurt performance and
    how we can employ alternative approaches to make our code more efficient. In this
    chapter, we’ll put some common techniques and practices under the microscope to
    examine their performance and compare their characteristics with potential alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Where default code behavior may not be optimally efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why some common performance concerns are misconceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to evaluate code performance and target its bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making small optimizations may be worth the trouble
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring and Optimizing Performance</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term *optimization* is often used to mean altering code to make a program
    run more quickly, but we might want to optimize for many other outcomes: lower
    memory use, higher numeric calculation precision, increased data throughput, and
    ease of deployment, to name just a few. Sometimes we trade raw performance for
    code readability or even convenience. We may decide that making our code easy
    to test is more important than making the program run at maximum speed. However,
    optimizing for one area can often adversely affect one or more other areas of
    an application, so we must make sure that the potential benefits are worth the
    cost and that our efforts aren’t actually leading to *pessimization*: writing
    or using code that prevents a program from running efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest and most direct method for optimizing a program’s performance is
    to enable optimizations in the build configuration. A release build configuration
    has optimizations enabled by default. When building the debug configuration, the
    compiler generates code that closely matches the source code’s structure and logic,
    which allows for setting diagnostic features like breakpoints, step-by-step debugging,
    and inspecting variables. The optimizations enabled in a release build may change
    the code’s logical structure in subtle ways, making debugging much more difficult
    but potentially improving the code’s efficiency or reducing the program’s size.
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler itself performs very little in the way of optimizing the code,
    leaving the majority of that work to the JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The JIT Compiler</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C# compiler translates our C# code into CIL format, which in turn is translated
    to native machine code either ahead of time (AOT) by a tool such as the CrossGen
    utility or at run time by the JIT compiler, the latter being the default. In normal
    operation, the JIT compiler translates the program piecemeal; rather than producing
    the machine code for the entire program all at once before running it (as AOT
    tools do), the JIT compiler translates portions of the CIL to native format *just
    in time*. A portion would generally be a method, but in principle it could be
    part of a method, such as a loop or <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Because JIT compiler optimizations occur during a program’s execution, they’ll
    vary among platforms and run-time environments. While AOT compilation may improve
    a program’s startup time, the JIT compiler can take advantage of optimizations
    specific to a particular CPU, register set, operating system, and program state
    to produce efficient code on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: One common optimization is to inline the code within a method, avoiding the
    overhead of a method call. The JIT compiler may also be able to replace some method
    calls with native intrinsic CPU instructions, further improving performance. Once
    a block has been translated by the JIT compiler, its native code remains in memory,
    so it usually doesn’t need to be recompiled if the program runs it more than once.
  prefs: []
  type: TYPE_NORMAL
- en: In a debug build, the JIT compiler is much less aggressive in the optimizations
    it applies so that normal debugging operations are supported. When we’re trying
    to assess our code’s performance, it usually makes the most sense to base that
    assessment on a release build so it will account for all of the optimizations
    performed by the JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance Benchmarks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When our code runs more slowly than we expect, simply observing the running
    application may give us some insights, but measuring performance precisely will
    allow us to target our optimization efforts more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Recording the time it takes for code to run—whether it’s a complete end-to-end
    run or just a portion of a program—is known as *benchmarking*. More generally,
    a *benchmark* is a standard against which something is measured. By timing our
    code, we establish a benchmark with which to compare a new version, to determine
    whether our changes have made the code faster or slower, or have had no discernible
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Many unit-testing frameworks report how long it takes for the tests to run,
    and even the elapsed time taken for individual tests. Keeping an eye on these
    numbers is certainly worthwhile because a sudden increase can indicate that an
    efficiency problem has been introduced somewhere. This approach can be particularly
    valuable in an automated *continuous integration (CI)* service, in which changes
    from multiple contributors are automatically integrated into a program; we can
    set up a CI service to alert us if the timing of the unit tests begins to change.
    If a particular test that usually runs in a few hundred milliseconds starts taking
    considerably longer, we can focus on the piece of code being tested to see if
    further investigation is warranted.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more fine-grained and precise approach to measuring how fast a section of
    code runs is to instrument the code itself. The basic technique is simple in principle:
    just before running the code to be measured, we create a timer to record the elapsed
    time, and when the code has finished running, we record the timer’s measurement.
    [Listing 8-1](#list8-1) shows a simple but naïve benchmark using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp>
    class from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp>
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A simple benchmarking
    approach</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp> class is
    a lightweight high-resolution timer that records elapsed time with very high precision.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp> value
    is the number of ticks per second, so by multiplying the count of elapsed ticks
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp> before dividing
    by the frequency, we can report the time taken with millisecond granularity. This
    technique simply measures the elapsed time since the clock was started, so it
    can’t, for instance, determine whether the code being measured is actually running
    for all that time. The clock continues to tick even if the code is interrupted
    (for example, by switching to a different thread).
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting code with a timer and recording it in the log or another audit
    trail can be a useful way to measure code running in a live system. However, measuring
    and reporting the performance takes time too, so we must be sure to take the measurements
    at a relatively high level. For instance, measuring and reporting how long code
    takes to respond to an <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp>
    request or call a remote procedure probably wouldn’t significantly impact the
    application’s performance. On the other hand, using this technique in a tight
    loop might well introduce more overhead than the cost of the loop itself.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking is also a useful way to explore performance in a test environment,
    perhaps to compare alternative approaches to solving a specific problem. The technique
    in [Listing 8-1](#list8-1) is naïve in that it measures the code only once. A
    more accurate approach for measuring performance would run the code many times
    and report the average time. We could write our own framework based on [Listing
    8-1](#list8-1), although a few freely available libraries for C# will do the heavy
    lifting for us, producing a report of the recorded performance along with other
    useful statistics, such as margin for error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Profiler</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Benchmarking will tell us overall how quickly a piece of code runs, but to determine
    what the code does in detail, we need a *profiler*. Using a benchmarking tool
    in combination with profiling will give us the most accurate measurements. Among
    the several kinds of profiler available, the two most common are performance profilers
    and memory profilers.
  prefs: []
  type: TYPE_NORMAL
- en: A *memory profiler* will show us where our program allocates memory, how much
    is being used, and when it’s garbage collected. If we need to find out which parts
    of our code are using the most CPU time or which methods are being called most
    often, a *performance profiler* will give us precise measurements, allowing us
    to target specific hot spots in the code and optimize them if necessary. While
    optimizing memory usage is important, in this chapter we’ll focus on discovering
    bottlenecks in our code by using a performance profiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance profilers usually operate on a release build of a program and so
    take into account any optimizations applied by the compiler and JIT compiler.
    Measuring a debug build for its performance usually makes little sense, although
    sometimes it can be useful: comparing the results of profiling both a debug build
    and a release build of the same code, for instance, can provide insights into
    some of the optimizations the JIT compiler performs.'
  prefs: []
  type: TYPE_NORMAL
- en: While performance measurements can give us an idea of where bottlenecks may
    be slowing our code, it’s vital to keep in mind that a program’s performance is
    affected by many factors other than the code, including the version of the CLR
    or the version of the software development kit (SDK) we use. Even running the
    same program twice on the same machine can produce a different result, depending
    on how cache memory is allocated or how instructions are pipelined by the CPU’s
    scheduler. The JIT compiler may also apply different optimizations for each run,
    possibly further affecting the result. We must therefore be cautious of attaching
    too much importance to the absolute times in a profiler’s report, and instead
    look for trends or obvious anomalies, such as results differing by an order of
    magnitude or more.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use a performance profiler to selectively measure specific aspects of
    code and analyze the profiler’s results. Remember that the specific results shown
    in this chapter are particular to the machine on which the test was performed,
    but we’ll try multiple approaches, measuring each attempt so that we can identify
    some common, repeatable patterns in the results.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how this works, next we’ll examine how simply changing a field’s
    type can dramatically affect the performance of code that relies on using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring Basic Performance with Equals</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is an
    often neglected aspect of code optimization in C#. This method is a good candidate
    for performance measurement because it’s always available (since every type inherits
    it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class)
    but also customizable (as a virtual member of <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>).
    In this section, we measure the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for a simple value type so that we can compare the profiler’s results with the
    results from overriding <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    with our own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Struct types inherit a value-based equality comparison from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class, overriding the default implementation defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    universal base class. This ensures that when we copy an instance of a struct,
    the copy compares equal to the original by comparing the fields of each instance.
    We might be tempted to rely on this behavior, rather than implementing our own
    override of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    because it keeps our type definitions shorter and simpler, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct in [Listing 8-2](#list8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Defining a simple
    struct type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    that have the same property values will compare equal. Furthermore, like all structs,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> inherits a value-based
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, ensuring
    that two equal <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values
    always produce the same hash code. Additionally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is an immutable type, making it suitable for use as a key in a data structure
    that relies on hash codes for efficiency. In [Listing 8-3](#list8-3), we create
    many random <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances
    and then add them to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in a simple test that we can use to measure how well the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct performs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Generating a hashing
    collection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> class is the
    Standard Library’s *pseudorandom number generator*, the name for an algorithm
    that uses a deterministic process to produce a sequence of numbers that *appear*
    random. Notably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp>
    class will produce the same sequence if it’s initialized with the same *seed*—that
    is, the value used to calculate the first number of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Different versions of .NET (or .NET Core) may produce different sequences
    for a given seed.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-3](#list8-3), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    as the seed and create new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances using the numbers generated by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    on the random-number generator. Since we use the same seed each time, we’ll get
    the same sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances each time the code runs. This characteristic is most often considered
    a downside of pseudorandom numbers, but it suits our purpose perfectly because
    we can run this code multiple times, and the same values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances will be generated for each run. In turn, comparing the performance of
    different runs is fair in that each run will be comparing identical sequences
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values. We’re using
    a randomly generated sequence to ensure that the final <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    contains a reasonably realistic population of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-3](#list8-3), we create each <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance by masking off the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    values from each random number. The profiler output in [Table 8-1](#tab8-1) shows
    the performance of the hash table’s constructor. For this test, we’re simply measuring
    elapsed time, also called *CPU sampling*, for each method.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet''1..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor
    (IEnumerable, IEqualityComparer)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith
    (IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot
    Present(T, out Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: We’re focusing on the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    and ignoring everything else, including the random-number generation and creation
    of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects.
    Different profilers represent their reports differently, but the information presented
    is generally similar.
  prefs: []
  type: TYPE_NORMAL
- en: The indentation in the first column of this report shows the call stack being
    measured. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> constructor
    on the first line calls a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>,
    which in turn calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.
    This last method eventually calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. The leftmost value in the output shows the time spent by that method as
    a percentage of the test’s total time. In our test, creating the initial sequence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values takes up
    the remainder of the time but isn’t really relevant to testing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The next field is the simple name of the method, followed by the absolute time
    in milliseconds spent in that method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fully qualified name of the method indicates which specific method
    is being reported. Since our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct doesn’t provide its own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    is used to add unique keys to the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the actual times in milliseconds reported here could change
    based on a combination of many factors, so they shouldn’t be taken literally.
    However, they establish a baseline we can use to compare the results of other
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hidden Costs of Simplicity</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type uses three
    values for the RGB components. Although they’re being stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties, each one 4 bytes wide, we use only 1 byte for each value by masking
    off the lowest 8 bits of each argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    constructor. We might infer that we can save on storage space by storing the properties
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> fields rather than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. [Listing 8-4](#list8-4)
    shows the changed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Storing byte fields
    for color components</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still allow <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> arguments
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> constructor
    so that our users won’t have to explicitly cast the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    when creating <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.
    Casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values explicitly
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> has the same effect
    as the masking operations we used in [Listing 8-3](#list8-3): the value is truncated
    to just the lowest 8 bits. If we use this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in the test to produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    from [Listing 8-3](#list8-3), the results are quite different. [Table 8-2](#tab8-2)
    shows just the call tree for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Adding Objects with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    <samp class="SANS_Futura_Std_Book_11">Fields to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T, out Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">650</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [Thread suspended]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: We see a dramatic change in the execution profile of the code, with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> method taking well
    over seven full seconds to complete. Comparing this report to [Table 8-1](#tab8-1),
    we can see clearly that the main reason for the extra time is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some instances, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can perform a *very* fast bitwise comparison, but with several caveats: this comparison
    can’t be used if any field is a reference, a floating-point number, or a type
    that itself overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Two different reference values could refer to objects of a type with its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and a bitwise comparison
    would compare them as not equal, even if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    would return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. For the
    same reason, any value type with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method could use that method to compare some values with different bit patterns
    as equal. Two floating-point numbers with matching bit patterns aren’t necessarily
    equal; in particular, if both values are <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    they shouldn’t compare equal.'
  prefs: []
  type: TYPE_NORMAL
- en: Another condition for the fast comparison to be used is that a struct must be
    *tightly packed*, meaning its fields don’t require any padding to be properly
    aligned in memory. The three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields in the original implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    would automatically be aligned in memory. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    instead means the fields aren’t tightly packed, so we must use another, much slower
    comparison, with the substantial performance penalty shown in [Table 8-2](#tab8-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.Equals
    Method</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the fast bitwise comparison isn’t applicable, the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    is necessarily very general, because it must work for any struct type, regardless
    of the number of fields the struct has or their type. In addition to having fields
    of built-in primitive types, a struct can contain references to class instances
    and instances of other user-defined values, any of which may have its own custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    first must determine which fields need to be compared. It does this by using *reflection*—programmatically
    inspecting (or changing) the run-time structure of the program—to discover all
    the instance fields, which immediately comes with a quite significant run-time
    cost. Reflection isn’t usually associated with high-performance algorithms, and
    this certainly accounts for the reduction in performance caused by altering our
    struct’s <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields to use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> instead.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the array of fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    obtains each field’s value. If the field value isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is called with the value from the corresponding field in the struct being compared.
    As a result, every value type field in both structs will be boxed in order to
    perform the comparison, because using reflection to obtain the values means each
    value is accessed via an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference, adding further cost.
  prefs: []
  type: TYPE_NORMAL
- en: The root cause of our performance problem is that the change from using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    values means that the underlying backing fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    are no longer tightly packed. Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can’t use the fast bitwise comparison and instead employs reflection to discover
    the values to be compared. To address this issue, in [Listing 8-5](#list8-5) we
    override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    and provide our own implementation to compare the property values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Overriding the
    Equals method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The report in [Table 8-3](#tab8-3) from rerunning the test shows that while
    we’ve substantially improved its speed, we still have work to do.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">How
    the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method Performs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">588</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">236</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: Notice that our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is consuming a much smaller percentage of the overall time in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>,
    although this approach is still much slower than the test using our original version
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: This report tells us that the majority of the time was spent in the code of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> as opposed
    to any methods called by it. To discover why, we’ll use a different kind of profiling,
    sometimes known as *instrumentation profiling*, or *tracing*, which records the
    number of times each method is called in a program. Because this requires the
    profiler to intrusively measure a running program, the time measurements are often
    much higher; however, knowing which methods are being called most often is valuable
    information. [Table 8-4](#tab8-4) shows the tracing report for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>
    and the methods called within it, including the number of times each method was
    called.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-4:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Garbage
    collection]</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: This report has an extra column that shows the number of times each method was
    called during the program’s execution. The tracing report took significantly longer
    to run, but more importantly, it shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method being invoked a huge number of times. In fact, the number of invocations
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is suspiciously
    close to the triangular number of 25,000—the number of elements in the original
    sequence. The *triangular number* of some number *n* is the sum of the whole numbers
    from 1 to *n*. When *n* is 25,000, the triangular number is 312,512,500.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> class also uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> when adding or searching
    for a key, and our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type relies on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
    Let’s look at how this relates to the number of times <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called in our test.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.GetHashCode
    Method</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Chapter 5](chapter5.xhtml) explained, the elements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    are unique; every key in the table exists only once. A new object is added to
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> only if it doesn’t
    already exist in the table; otherwise, it’s ignored.
  prefs: []
  type: TYPE_NORMAL
- en: When we add an item to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in this example, the implementation uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to identify existing keys with the same hash code. The fact that the hash codes
    are the same doesn’t necessarily mean any of the existing keys have the same value
    as the new item. If no existing key has the same hash code as the new item, the
    new object is added to the table. If one or more existing keys have hash codes
    that match the new item’s hash code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used to determine whether the item should be added. Each key with the
    same hash code is compared with the new item in turn, and if no match is found,
    the new item is added to the table as a new key.
  prefs: []
  type: TYPE_NORMAL
- en: Having <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> being called
    so often in our test indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is producing
    hash codes that aren’t well distributed. When the first element is added to the
    hash table, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> isn’t
    called at all, because there’s nothing to compare with. If the second element
    has an identical hash code to the first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called to determine if they’re identical keys. This process will repeat for
    each subsequent element that has the same hash code as an existing key.
  prefs: []
  type: TYPE_NORMAL
- en: If all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects
    in the initial sequence of 25,000 elements produce identical hash codes but have
    different values, adding the final new element will require a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for all of the existing 24,999 keys.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    inherited by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct
    will likely produce many identical hash codes, regardless of whether the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances have different
    values. The reason is related to the poor performance of the implementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, and it explains why
    the number of calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is so close to the triangular number of the sequence length.
  prefs: []
  type: TYPE_NORMAL
- en: If instances of a struct can be compared using the fast bitwise comparison for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    method produces hash codes based on the bit pattern of the instance in memory.
    If, on the other hand, the struct isn’t eligible for the fast bitwise comparison,
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation
    considers only the first non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    instance field of the struct—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    property in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type—with
    the result that we can get a maximum of only 256 unique hash codes. We solve that
    problem by implementing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method to produce more unique hash codes, preferably so that each distinct <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value produces a unique hash
    code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HashCode.Combine
    Method</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 8-6](#list8-6), we add our own override of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct to complement
    our overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    and implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode.Combine</samp>
    method from the Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Overriding a GetHashCode
    method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Combine</samp> method produces
    well-distributed hash codes based on its inputs, and while we might be able to
    write our own carefully optimized replacement, doing so is far from trivial. Now
    when we run the test, we see that the combined effect of overriding both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    reduces the number of calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method by a considerable amount, as shown in [Table 8-5](#tab8-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-5:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% Combine</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.HashCode.Combine(T1, T2,
    T3)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.27% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">0.09</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">18</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  prefs: []
  type: TYPE_TB
- en: Even accounting for the overhead of counting the method calls, this report shows
    a vast improvement in speed compared with our previous results and demonstrates
    the close relationship between <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We pay a
    high cost in efficiency if we accept the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> provided
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> rather than
    implementing those methods ourselves in our custom struct types.
  prefs: []
  type: TYPE_NORMAL
- en: If we revisit the profile of our original struct that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields but no method overrides, we can see that even though that struct could
    be packed efficiently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is still invoked much more frequently than in our latest version (see [Table
    8-6](#tab8-6)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-6:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for a Packed Struct with No Overrides</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">85.6% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">30.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">36</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">1,219,104</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.54% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  prefs: []
  type: TYPE_TB
- en: We’d certainly notice a performance problem if we were to scale up the number
    of elements being added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, several
    other collection types rely on hash codes for efficiency, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Lookup</samp> types. Therefore,
    it’s essential that we override both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for
    any type that could be used as a key for hashing collections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Optimizing Equality</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While overriding both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> produces
    the most impressive performance improvements, we can do more to fine-tune equality
    comparisons. After all, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used in circumstances other than when we’re creating data structures
    that rely on hash codes.
  prefs: []
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is a relatively
    simple data type, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is already quite efficient. To probe the characteristics of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    we’ll make a much more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    value type, shown in [Listing 8-7](#list8-7). The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    struct overrides both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> with custom
    implementations but doesn’t yet implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. We’ll implement that interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    later to see how that affects the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Defining a more
    complex data type, Purchase</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type has
    three fields, one of which is another nontrivial type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>,
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> needs to do a little more
    work than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type back in
    [Listing 8-5](#list8-5). When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method must also ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    properties match, which involves a method call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Purchase type is quite large—40 bytes plus padding, assuming a 64-bit
    architecture—so we should expect copying instances around to be less efficient
    than for the smaller Color type. That won’t affect our profiling, though, as we’ll
    still be comparing reports for the same types. We’ll return to the cost of copying
    large struct instances in “Copying Large Instances” on [page 272](#sec18).*'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two very large lists of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, as shown in [Listing 8-8](#list8-8). This process will exercise the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, allowing us to measure
    its efficiency. To magnify the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compared to the cost of the surrounding code, we increase the number of elements
    to 10 million.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Testing to exercise
    equality</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method, we use digit separators, available since C# v7.0, to make the large literal
    number easy for human readers to parse. Digit separators make no difference to
    the compiler: the number we use for the length of the initial sequence is still
    a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    compares two sequences and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if they have the same elements in the same order. The algorithm obtains an element
    from each sequence and compares those elements by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> doesn’t
    try to optimize its result by checking if the two sequences are in fact the *same*
    sequence, so here we create only one sequence of 10 million elements and compare
    it with itself. [Table 8-7](#tab8-7) shows the profiler report for the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-7:</samp> <samp class="SANS_Futura_Std_Book_11">Exercising
    the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,227</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">49.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">781</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">24.3% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">384</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">168</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Object)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.75% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.38% Unbox</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Runtime.CompilerServices
    .CastHelpers.Unbox(Void*, Object)</samp> |'
  prefs: []
  type: TYPE_TB
- en: We can see that garbage collection contributes a significant portion of the
    time required by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance results
    in the argument being boxed, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a struct and the parameter type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, a reference
    type. Furthermore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>,
    which also requires its argument to be boxed. The consequence is that we’re allocating
    many boxed objects on the heap, placing the garbage collector under fairly significant
    pressure to keep memory usage under control.
  prefs: []
  type: TYPE_NORMAL
- en: In each <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    the parameter needs to be unboxed back to its original type so that its properties
    can be compared; the cost of unboxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter for each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods is tiny but has a measurable impact. We can avoid the costs of boxing,
    and much of the associated cost of garbage collection, by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Effect of IEquatable<T></samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    automatically selects the best (the most efficient) implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    available to perform the comparisons. Internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    helper class from [Chapter 5](chapter5.xhtml) to determine how to compare elements.
    If the element type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, it’s guaranteed
    to implement a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    and that overload will be called by <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface and provide our own type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>
    interface method by default, avoiding the need for boxing and then unboxing the
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. In turn,
    this reduces memory pressure because the arguments aren’t copied to the heap,
    resulting in fewer objects for the garbage collector to inspect. In our example,
    those reductions are considerable, so implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface should produce a measurable benefit. [Listing 8-9](#list8-9)
    shows the changes required in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: The IEquatable</samp><
    Purchase> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase
    other)</samp> overload to perform the comparisons between each of the property
    values. The original <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override still needs to unbox its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter in order to call the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    overload, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    because we’ve also changed the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    declaration to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. In [Listing 8-10](#list8-10), we make similar changes
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> so that calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method won’t require
    boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Implementing
    IEquatable</samp>< Product>'
  prefs: []
  type: TYPE_NORMAL
- en: The results of the test from [Listing 8-8](#list8-8), incorporating the changes
    from [Listings 8-9](#list8-9) and [8-10](#list8-10), still with 10 million <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> elements, are shown in
    [Table 8-8](#tab8-8).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-8:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Type-Safe</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">62.6% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">546</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">13.0% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">114</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.48% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.05% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Ordered</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Ordered()</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Comparing this report with [Table 8-7](#tab8-7), we can see that the total time
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> has been
    greatly reduced, but also that our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is significantly faster than the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type’s version without the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>. Much of the difference is thanks to the lack of garbage collection,
    but we’re also benefiting from removing the need to box and unbox the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Accesses</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase)</samp> method
    spends a measurable portion of its time accessing properties to compare them.
    All of the properties of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> are automatic
    properties, and every access to those properties is a method call—for example,
    the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Item</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Ordered</samp> shown in [Table
    8-8](#tab8-8). While the JIT compiler may often be able to optimize such calls
    away by inlining the underlying method, there’s no guarantee that it will. In
    [Listing 8-11](#list8-11), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    to introduce our own private fields and alter <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to compare the fields directly rather than accessing the property values for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Comparing fields
    rather than properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although not shown here, we also change <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to replace its automatic properties with private fields. [Table 8-9](#tab8-9)
    shows the results of comparing 10 million elements the same way we have previously.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-9:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    the Performance of Fields vs. Properties</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">51.2% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">442</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.73% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">84</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.47% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">30</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  prefs: []
  type: TYPE_TB
- en: Although replacing automatic properties with fields shows a small improvement,
    it’s an example of a micro-optimization. We’ve cut the time needed for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by more than half compared to the version that didn’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>, but we’re still talking about only a few hundred milliseconds
    in absolute time. We had to dramatically increase the size of the sequence to
    amplify the results enough to be observable, and most applications don’t routinely
    need to compare lists of 10 million elements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface is a much more important step. Not only do we benefit from
    an increase in speed, but our type makes much more efficient use of memory by
    not needing to box the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>
    for value types is more than a performance optimization; it establishes that our
    type follows that protocol, enabling certain library features to operate more
    efficiently and signaling efficiency to human readers too.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Equality Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final part of implementing a full set of equality comparisons for a type
    is to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    with its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>.
    [Listing 8-12](#list8-12) shows those operators implemented for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Implementing
    equality operators for Purchase</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we also add equality operators to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type (not shown), allowing us to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> by using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead of calling its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Each operator
    implementation simply forwards to our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, where the comparison is performed.
  prefs: []
  type: TYPE_NORMAL
- en: While we can write a test to call <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    in order to measure its performance characteristics, we can also arrange for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to call
    the operator rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    by providing our own equality comparer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Generic IEqualityComparer<T>
    Interface</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    doesn’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly
    on the sequence elements to compare them. Instead, it relies on an implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>,
    which is part of the Standard Library and declared in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic</samp>
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> requires an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method taking two parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter.
    The Standard Library provides some default implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, including one for instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    that implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface, which is what our uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    have relied upon thus far.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    has an overload that takes a second parameter whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, so we can provide our own implementation to be used instead of the
    default comparer. In [Listing 8-13](#list8-13), we create our own implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    interface, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as the generic parameter, and pass an instance of our custom comparer to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Creating a custom
    IEqualityComparer</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    Purchase></samp> defines its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to compare its two parameter values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    instead of the parameter type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. We don’t need a separate implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> member
    method in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> directly to compare the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values. Now, when we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to compare
    two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items, the algorithm will use <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the comparisons. [Table 8-10](#tab8-10) shows the profiler report for comparing
    10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-10:</samp> <samp class="SANS_Futura_Std_Book_11">How</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <samp class="SANS_Futura_Std_Book_11">Performs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">475</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">22.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">216</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer
    .Equals(Purchase, Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">9.28% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">90</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(Purchase,
    Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.28% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.53% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(Product,
    Product)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: When we define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for any type, the compiler translates it to a static method named <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>,
    shown in this profiler report. That method takes both of its parameters by value,
    so we’re making a lot of copies of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances. We
    can reduce the number of copies needed by changing the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Read-Only in Parameters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To reap the benefits of altering our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference rather than by value, we can use
    read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
    They are specifically intended for avoiding copies of large value type instances
    and are appropriate when we don’t need to mutate the parameter variables.
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn’t expect a huge improvement, however, because we can’t avoid all
    the copies being made when comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    elements in our sequence. In particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals</samp>
    method must take its parameters by value to match the signature defined in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as shown in [Listing 8-14](#list8-14), the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    itself takes its parameter by value according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, but we can add a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    and use the same mechanism to alter the equality operators to take all their parameters
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: Overloading using
    in parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter the
    main implementation and forward to it from the equality operators and the implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>.
    Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters are
    transparent to calling code, the rules for overloading will give preference to
    the method with no parameter modifiers, unless we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to the argument when calling the method. Therefore, we explicitly select
    the overload with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword
    to the argument we pass wherever we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Replacing value parameters with in parameters is a version-breaking change,
    requiring extra care if binary compatibility is a consideration.*'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to change the implementation of our <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp>
    to pass the arguments by reference, since our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    method doesn’t have an overload taking parameters by value. We can reuse the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp> from [Listing
    8-13](#list8-13) to run the test, with the results shown in [Table 8-11](#tab8-11).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-11:</samp> <samp class="SANS_Futura_Std_Book_11">Results
    of Passing by Reference to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">45.1% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">437</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.9% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">203</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.5% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.23% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(in
    Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(in
    Product, in Product)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(in
    Product)</samp> |'
  prefs: []
  type: TYPE_TB
- en: Comparing these results to [Table 8-10](#tab8-10), we can see the improvement
    is quite modest. While we certainly get some benefit from avoiding copying <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, that benefit
    is limited to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    actually being called. [Table 8-12](#tab8-12) shows a tracing report with counts
    of the number of method calls, showing that the JIT compiler is inlining all but
    a very few calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-12:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for Comparing</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.88% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,013</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    call</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">735</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10,000,000
    calls</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.08% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">82</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">126,402
    calls</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  prefs: []
  type: TYPE_TB
- en: While using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    in our definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    is free in that it requires no changes to calling code, we shouldn’t expect too
    much from it. We also shouldn’t simply apply <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters routinely, even when using them wouldn’t detract from a method’s readability.
    Passing small value types by reference may incur a penalty due to the extra level
    of indirection required to access the value itself via a by-reference variable.
    As with any optimization feature in the code, we should introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters only where our measurements show that they’re warranted.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Type Affects Performance</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our choice of types in an application can affect its overall performance in
    various ways. The types we use to represent values in an application are the most
    important part of that choice because the other types will usually be classes
    in any case. Values, on the other hand, can be represented as structs, classes,
    records, or record structs. In this section, we’ll examine some of the factors
    that can help us decide between using struct types and class types to implement
    those value types, and how much those factors affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: We often hear that structs, and therefore record structs, should be small because
    it’s expensive to copy large instances around in memory. With that in mind, we’ll
    start by attempting to isolate the cost of copying instances from the other factors
    affecting performance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Cost
    of Copying</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with our previous performance measurements, we need to establish a simple
    baseline against which we can compare further performance reports. Since we want
    to measure the cost of copying a large value type, first we have to measure the
    cost of copying a small, simple type, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct we create in [Listing 8-15](#list8-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Creating a simple
    struct with a single int field</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To exercise copying, we’ll again use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method, which copies elements from the sequences to compare them and will copy
    them again to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Equals</samp>
    method. Here, we return to using the default equality comparer, which will call
    our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    passing its argument by value. [Listing 8-16](#list8-16) shows the code we’ll
    use to produce our benchmark performance profile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: Testing simple
    copies</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For this test, we’ll profile a debug build of this code to try to minimize the
    effects of the method inlining performed by the JIT compiler. Method arguments
    are copied only if the method is invoked normally, and inlining would make measuring
    the cost of those copies unreliable; two different runs of the code could easily
    make a different number of copies. [Table 8-13](#tab8-13) shows the CPU sampling
    report for comparing two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    items in a debug build, which inhibits the JIT compiler from inlining method calls.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-13:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying a Simple Struct</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">57.0% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField.Equals(IntField)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> algorithm
    does little other than obtain an element from each sequence and compare one to
    the other with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The
    difference between the time taken by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and the total time spent in <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    here is all overhead, representing the time taken to obtain each pair of elements
    from the sequences and copy the arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Large Instances</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copying a simple struct type such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct in [Listing 8-15](#list8-15) is no more expensive than copying a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value; a simple test
    (not shown here) that compares two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values will confirm it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct in [Listing 8-17](#list8-17), which adds three entirely redundant <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> fields, is significantly larger
    than the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct.
    Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> is 16 bytes, making
    this struct somewhat larger than even the most generous recommended limit for
    the size of a value type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: Creating an extremely
    large struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note one subtlety in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    doesn’t consider any of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    fields of the type, because they’re always all identical in any case. The reason
    is that we’re trying to measure just the cost of copying, so this <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method performs precisely the same operations as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    type in [Listing 8-15](#list8-15). While the padding fields play no part in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method or any other
    operation, the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type is a struct and therefore copied by value, so *every* field will be copied.
    We run the same test from [Listing 8-16](#list8-16), with the results shown in
    [Table 8-14](#tab8-14).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-14:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying an Extra-Large Struct</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">52.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">228</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.71% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16.Equals(IntPlus3x16)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'Compare [Table 8-14](#tab8-14) with [Table 8-13](#tab8-13): the time spent
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical
    in both reports, although the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method has taken over twice as long to complete because of the extra overhead
    of copying the instances of the larger <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in
    both tests is performing the same operation, so the increase in time must be entirely
    due to the cost of copying instances.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighing Object Construction
    Costs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cost of copying a large struct is not the only aspect to consider when using
    a type with several fields. For one thing, equality comparisons will usually take
    every field or property into account, making those comparisons more costly than
    for a type with only one or two fields. Initializing an instance of a type with
    several fields also comes with a cost.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types in [Listing 8-18](#list8-18)
    are the positional record struct equivalents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> structs we defined
    earlier in [Listing 8-7](#list8-7). Because they’re record struct types, the compiler
    generates all the equality comparisons, making them much simpler to define than
    their struct counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Defining Product
    and Purchase as record structs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp>
    method shown in [Listing 8-19](#list8-19) to create a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances and record the performance. We return here to profiling a release build
    so that the results account for any optimizations afforded by the JIT (or AOT)
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Creating a sequence
    of randomly generated objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> method
    follows a pattern similar to that we’ve used previously to create a sequence and
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to
    compare the elements. For the purposes of making the performance report clear,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> as a
    method group argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    expression. That way, we can measure its performance directly, without introducing
    any overhead by using a lambda expression—something we’ll return to in “How Common
    Idioms and Practices Affect Performance” on [page 279](#sec23). [Table 8-15](#tab8-15)
    shows the profiler report for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-15:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    <samp class="SANS_Futura_Std_Book_11">Sequence</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">29.4% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">294</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.45% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.03% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  prefs: []
  type: TYPE_TB
- en: While the nested constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type increases the time taken to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, the majority of the time is spent within the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>, suggesting that initializing
    the instances and copying them around is the costlier factor. In particular, creating
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and then copying
    the instance to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    constructor is one copy we can avoid by making <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Type Performance</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we copy a reference variable, the object instance isn’t copied at all,
    making the copy inexpensive. Here we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a sealed record instead of a read-only record struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Records using this positional syntax are immutable reference types by default.
    For the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type, the
    compiler inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Price</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    properties, meaning that one instance can be safely and efficiently referenced
    by several containing objects. Since none of the properties has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, there’s no risk of inadvertent changes being made via aliasing references.
    More pertinently for our test, once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance is created, only the reference to it needs to be passed to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> constructor.
  prefs: []
  type: TYPE_NORMAL
- en: For this test, we leave the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type as a record struct, since we’re trying to avoid having to copy its nested
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. However, using a
    reference type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    introduces other overhead, as we can see in the profiler report in [Table 8-16](#tab8-16)
    for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-16:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating Reference Type Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.8% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1,409</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">34.9% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">632</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    is significantly slower than in [Table 8-15](#tab8-15), with the main culprit
    being garbage collection. Changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to be a record rather than a record struct has put considerable pressure on the
    garbage collector, which takes time even if it can’t collect any objects.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that the common advice to use value types for objects that
    are short-lived is at least partly related to memory pressure and the cost of
    garbage collection. Value type instances, because they aren’t allocated on the
    heap, don’t incur those costs. Copying even huge object instances isn’t always
    the most significant expense, so changing large value types to be reference types
    to avoid copying can, as in this example, have a detrimental effect on a program’s
    overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: We have other factors to consider. If, for instance, we expect many of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects in an application
    to have identical <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    values, we may benefit considerably by having all those <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances sharing the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance, making a reference type implementation much more attractive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Benefits of Reference Equality</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    from [Listing 8-19](#list8-19) that we’ve been using to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    object for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    object. In [Listing 8-20](#list8-20), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    so that rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    each time, we assign one of a small number of shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances to each new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    and therefore a reference type, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    will be shared by many <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Sharing references
    among objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a short list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances before creating any <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> reference
    is selected from this list according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    value used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Now that the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method isn’t creating any new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances, we’d expect it to run much more quickly, which the report in [Table
    8-17](#tab8-17) confirms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-17:</samp> <samp class="SANS_Futura_Std_Book_11">Assigning
    Preallocated</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    <samp class="SANS_Futura_Std_Book_11">Objects</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">17.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">86</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.38% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.18% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .get_Item(Int32)</samp> |'
  prefs: []
  type: TYPE_TB
- en: More significantly, comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality will now be much faster because so many of them share a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance. The implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for record types
    includes the simple optimization of starting with an identity comparison of the
    two references. When two <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    variables that are being compared both refer to the same instance in memory, there’s
    no need to continue checking the individual fields, since they must be identical.
    [Table 8-18](#tab8-18) shows the report for comparing sequence elements for 10
    million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-18:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Shared References</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">68.3% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">350</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">27.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">139</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11.7% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.52% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: If we run the same test by using a record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>—that
    is, assigning one of a few precreated instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>—we can compare
    the performance of sharing references versus copying each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>.
    [Table 8-19](#tab8-19) shows the report for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    for 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-19:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Copied Instances</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">59.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">591</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">126</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.01% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">89</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.22% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  prefs: []
  type: TYPE_TB
- en: Although the headline time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method is almost identical in each case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method using the record struct in [Table 8-19](#tab8-19) is considerably slower
    than for the record in [Table 8-18](#tab8-18). Record structs can’t take advantage
    of the simple reference identity optimization available to records, although many
    of the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>
    will have been inlined by the JIT compiler. The result is that we see the extra
    cost of having to copy the record struct values and compare their fields in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>, rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Compiler-Generated
    Equals Method</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The positional record struct syntax used in [Listing 8-18](#list8-18) for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    types makes their definition compact, but that comes with minor, although measurable,
    efficiency compromises. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for records and record structs is generated by the compiler,
    whether or not they use the positional syntax. While convenient, that’s not necessarily
    the most efficient implementation. When we’re working with many objects, it can
    be worth our while to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for record and record struct types, in which case the compiler won’t generate
    one for us.
  prefs: []
  type: TYPE_NORMAL
- en: You saw in [Chapter 5](chapter5.xhtml) that the compiler inserts code to obtain
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    object for each field. For example, [Listing 8-21](#list8-21) shows roughly the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method created by
    the compiler for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct in [Listing 8-18](#list8-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: A record struct’s
    Equals method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The real names of the backing fields assigned by the compiler are invalid in
    regular C#, so there’s no chance they could clash with any of our own identifiers;
    the names used here merely illustrate the idea. Despite using the backing fields
    directly rather than accessing the properties to perform the comparisons, obtaining
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    implementation for each field on *every call* to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    could impair efficiency. [Table 8-20](#tab8-20) shows the profiler output when
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two lists of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-20:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Record Struct Instances</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">55.7% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">558</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">138</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.58% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.80% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.Equals(Decimal)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Int32.Equals(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  prefs: []
  type: TYPE_TB
- en: While the JIT compiler may inline some or all of the uses of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Default</samp>
    property and the calls to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, there’s no guarantee that it will be able to do so. As we did earlier
    when replacing property accesses with fields, we can define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to directly compare the values without needing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp>. However, we can’t access the compiler-generated backing fields for
    the properties generated for a positional record struct. Instead, in [Listing
    8-22](#list8-22) we use a simple record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>,
    where we define our own private fields and a constructor to initialize them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Constructing
    a private field for the Purchase struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We also add our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to directly compare the fields we’ve defined. This custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    replaces the implementation that the compiler would have introduced had we not
    defined our own. We’d also need to add properties to expose the field values,
    although neither that nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type, which changes in a similar way, is shown here. Rerunning the code to compare
    two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items produces the report shown in [Table 8-21](#tab8-21).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-21:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Comparison Using Customized</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% SequenceEqual</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">440</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.18% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: By providing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, we’ve improved the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by around 20 percent compared with the results in [Table 8-20](#tab8-20), partly
    because our implementation may be giving the JIT compiler more effective opportunities
    for inlining code. Comparing larger sequences produces similar results, so if
    we’re particularly sensitive to performance and frequently compare many items,
    this kind of optimization may be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: The performance improvement we see here occurs primarily because <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a relatively complex type. A much simpler positional record struct—for example,
    one with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field—most
    likely wouldn’t benefit from the optimizations we made in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. The principal
    benefit of the positional record syntax is its simplicity, which makes it clear
    to any reader what the type represents. We sacrificed that simplicity for a small
    gain in raw performance, an improvement that was visible only with the help of
    a profiler. This example highlights the importance of measuring performance before
    trying to hand-optimize our code by second-guessing the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Common Idioms and Practices Affect
    Performance</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some common practices in C# draw undue criticism regarding performance. It’s
    natural and common to believe that a higher level of abstraction in source code
    comes with a cost in performance, and that’s true to some extent: C# is a *high-level*
    programming language, and our programs are ultimately translated to native machine
    code over multiple steps. We could handcraft our own machine code to perform the
    same task, but C# code is more portable, more easily maintained, considerably
    less error-prone, and much easier to read and write than machine code. Those benefits
    usually far outweigh any cost in performance.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not, however, universally true that high-level code results in performance
    penalties. In this section, we’ll investigate looping and pattern matching, two
    common C# features that enable us to succinctly express complex ideas in C# while
    providing performance comparable or even superior to their lower-level counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Looping and Iteration</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve used LINQ in its *fluent syntax* form several times for
    the purposes of creating sequences of objects. LINQ, which has been part of C#
    for many years, will be recognizable to most programmers with more than a passing
    familiarity for the language and its idioms. [Listing 8-23](#list8-23) shows an
    example of using the fluent syntax to create a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: LINQ fluent syntax</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ has an alternative *query syntax* that some C# programmers find more agreeable.
    [Listing 8-24](#list8-24) shows the equivalent query syntax for creating the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">items</samp> sequence in [Listing 8-23](#list8-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: LINQ query syntax</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler generates identical CIL for both [Listings 8-23](#list8-23) and
    [8-24](#list8-24), so the choice between them is primarily driven by which we
    find clearer to read. One optimization is possible, although it can be applied
    only to the fluent version: avoiding the lambda as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. That lambda needs to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable so the compiler will generate a closure object, which results in an extra
    level of indirection to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. To avoid the closure, we can instead pass <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    as a method group argument, as shown in [Listing 8-25](#list8-25).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: Optimizing LINQ
    by using a method group</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To compare the efficiency of each approach, first we profile the version from
    [Listing 8-23](#list8-23), which uses a lambda. [Table 8-22](#tab8-22) shows the
    report for creating a list of 10 million items.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-22:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Lambda</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">98.1% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">415</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .ToList(IEnumerable)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">36.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">152</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">31.3%</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><
    Closure>b__3_0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">132</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><>c.< Closure>b__3_0(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">31.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The identifier name <samp class="SANS_TheSansMonoCd_W5Regular_11"><> c</samp>
    is the closure object the compiler generates to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable, and one example of the compiler introducing names that would be illegal
    in our own code. The closure has an instance method, <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp>, which in turn calls our <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method makes two appearances in this report—both inside and outside the closure
    method—as a result of the JIT compiler inlining some calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: The report in [Table 8-23](#tab8-23) shows the performance when using the method
    group approach to create 10 million items.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-23:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Method Group</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">430</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.ToList(IEnumerable)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">71.9% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">309</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Somewhat counterintuitively, the version with the closure object was just slightly
    faster than that with the method group. We shouldn’t read too much into that,
    as the difference is well within the margin for error when comparing runs. However,
    it does tell us that no matter the absolute difference, using a lambda carries
    no significant performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: The closure object representing the lambda is created only once for the whole
    expression, not for every element produced for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. Even though the closure object represents an extra level of indirection
    for each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>,
    the JIT compiler inlines many of the calls to the closure’s <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and either calls <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly or inlines its contents too.
  prefs: []
  type: TYPE_NORMAL
- en: We could create a similar sequence in a few other ways. Let’s investigate two
    common approaches to see how their performance compares with using LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterator Approach</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Iterators* are a fundamental part of C# and underpin other higher-level features,
    including LINQ. In fact, LINQ has become so ubiquitous in modern C# that it can
    be easy to forget that it’s based on two system interfaces: the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface, which is an abstract view of a sequence of elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp> interface, which represents an iterator that can get each element of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> one at
    a time. The basic mechanics are that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface has a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">GetEnumerator</samp>
    that returns an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Both interfaces are largely hidden in modern code, although <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> remains important as the protocol for types that represent sequences
    and as the home of the extension methods, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>, that make up most
    of the LINQ system.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    also forms the basis for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, which is one way of enumerating the elements of a sequence that implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>. In [Listing
    8-26](#list8-26), we write our own simple <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method, which allows us to record its performance for comparison with the LINQ
    equivalents. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> to populate a list
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects and therefore
    depends on the iterator provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: Populating a
    list using foreach</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method
    with the LINQ version in [Listing 8-23](#list8-23), the first thing to notice
    is that we need to declare the target list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects before the loop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop obtains an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< int></samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>, and
    the body of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> block
    is run for each element in the iterator. We can see the basic mechanics when we
    look at the profiler’s report for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method in [Table 8-24](#tab8-24).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-24:</samp> <samp class="SANS_Futura_Std_Book_11">Profiling
    the Iterator Approach</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">638</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">41.2% AddWithResize</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">263</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .AddWithResize(T)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">243</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  prefs: []
  type: TYPE_TB
- en: This profile report shows the workings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    construct; the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Current</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MoveNext</samp> methods belong
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    and, as their names suggest, allow us to obtain the current element and move the
    iterator to the next item in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This report also shows that our handcrafted <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    is considerably slower than the LINQ version reported in [Table 8-22](#tab8-22),
    but we haven’t made optimal use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> facilities. Since we know in advance the number of items we need,
    we can avoid most of the expense of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddWithResize</samp>
    method and specify the list’s capacity in the constructor call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By explicitly requesting a capacity, we allocate enough memory for <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    items before adding new elements so that the list won’t need resizing when it
    runs out of space. If we rerun our profile test, as [Table 8-25](#tab8-25) shows,
    it’s much more in line with the previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-25:</samp> <samp class="SANS_Futura_Std_Book_11">Preallocating
    a List’s Capacity</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">426</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">63.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">268</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4.28% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Our tests demonstrate that using LINQ, at least for the reasonably simple task
    of generating a sequence of elements, is at least as efficient as using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. We can try one other
    approach, however: the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Loop Approach</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our method of creating a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects is based on creating a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values and translating them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method into a new sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. [Listing 8-27](#list8-27) shows how we achieve the same result with a
    basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, which doesn’t
    rely on iterators and merely runs the body of the loop the number of times specified
    in the loop condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: Using a simple
    for loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, we must create the target <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> before entering the loop, and we use the constructor to set its
    capacity. In the loop’s body, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as we have previously. [Table 8-26](#tab8-26) shows the profiler report for creating
    a list of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-26:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Direct</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">Loop
    Performance</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">417</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">67.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">281</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.70% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">24</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'Once again, there’s no significant difference between the performance of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop approach and that
    of the other approaches we’ve tried. The main difference between using LINQ and
    using either the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is one of style:
    the LINQ code is more direct and allows us to express our intent declaratively,
    whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loops are more procedural.
    The LINQ expression allows us to focus on the outcome we require, whereas both
    looping approaches focus on the steps or instructions to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pattern Matching
    and Selection</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common benefit of a declarative rather than procedural style is that we
    write less code to achieve the same result. While this saves on the amount of
    typing we do, that is just a side effect. The real benefit comes from having less
    syntax for a human reader to comprehend. Replacing explicit loops with LINQ-style
    functional expressions is one example. Many of the LINQ expressions are based
    on loops internally, but the loop constructs themselves are hidden from user code.
    Manually iterating sequences with loops and explicit conditions can be prone to
    errors, and complex loop constructs are generally harder for a human reader to
    follow than a call to a method like <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common application of declarative techniques is in selection code:
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements with pattern-matching expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the constructor in [Listing 8-28](#list8-28), which validates the parameter
    value by matching it against the rules specified by some patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: Pattern matching
    for validation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> constructor
    throws an exception if the argument given is <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>
    and also prohibits values that are less than <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroKelvin</samp>
    or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">PositiveInfinity</samp>.
    Values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">celsius</samp> parameter
    that don’t match either of those rules are assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field by the discard pattern, which is the final pattern in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Compare [Listing 8-28](#list8-28) with [Listing 8-29](#list8-29), which achieves
    exactly the same outcome but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>
    statements to test the incoming parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-29: Chaining if and
    else for validation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We could make this code less syntax-heavy by removing the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statements and allowing the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    blocks to fall through if the value doesn’t meet the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition. While doing so would make the code shorter, it’s more error-prone if
    new conditions are added.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative is to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, as shown in [Listing 8-30](#list8-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-30: Using a switch
    statement for validation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This version is closer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression in [Listing 8-28](#list8-28), and the two forms of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    can be easily confused. The principal difference is that here we assign the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field as part of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp> leg, whereas in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field is assigned the value of the whole expression.
  prefs: []
  type: TYPE_NORMAL
- en: In a departure from the rest of this chapter, we don’t need to run a performance
    profile to compare [Listings 8-28](#list8-28) through [8-30](#list8-30) because
    the compiler produces almost identical code for each—broadly, the same code as
    shown in [Listing 8-29](#list8-29). The compiler may change the order of the conditions
    in the CIL, but that doesn’t change the logic in any way.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We do not consider it as good engineering practice to consume a resource lavishly
    just because it happens to be cheap.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Niklaus Wirth, *Project Oberon: The Design of an Operating System, a Compiler,
    and a Computer*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code optimized by hand is often harder for a human reader to follow, usually
    because it frequently involves replacing simple idioms, such as loops and pattern
    matching, with lower-level constructs. When a program runs more slowly than we
    think it should, it can be tempting to dive straight in and change the parts of
    the code we suspect are bottlenecks. Programmers’ optimization instincts are,
    however, notoriously unreliable. We’re likely to make our code more difficult
    to read while failing to improve performance in any meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing code by hand is almost always an exercise in exchanging clarity and
    simplicity for performance. We can judge whether this is a reasonable trade only
    by measuring the performance before and after the change. Even when we improve
    performance in a section of code, we must still decide whether we’ve made the
    code less clear and, if so, whether the change is justified. We must also be certain
    that our optimizations haven’t changed the program’s behavior in any way. Slow,
    correct code is always preferable to incorrect code, however good its performance.
    That’s not to say that good enough can’t be correct—frequently a compromise is
    necessary between performance and accuracy or precision—but we need to know the
    point at which inaccurate really does mean incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: The use of well-known idioms and patterns helps human readers easily understand
    code. Correspondingly, when we depart from those common designs, we make our code
    harder to follow. Therefore, we must be selective in applying optimizations to
    the areas of code that will bring the greatest benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    isn’t difficult for the vast majority of types, but it adds an implementation
    detail that represents extra cognitive overhead for anyone who needs to *understand*
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using records to represent value-like types removes much of that added complexity
    because the compiler generates the correct implementations for us. However, even
    accepting that default behavior won’t necessarily yield the most efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: Careful code optimization, supported by evidence from a profiler, can yield
    better performance in both speed *and* memory use. Modern computers are fast and
    usually have more than enough memory, but that doesn’t mean we should waste either
    resource.
  prefs: []
  type: TYPE_NORMAL
