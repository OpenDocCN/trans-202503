- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PERFORMANCE
    AND EFFICIENCY</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">性能与效率</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Few programmers set out to write inefficient code, but we don’t always have
    time to fine-tune an algorithm to extract the maximum possible performance. Nevertheless,
    it’s important to understand how some coding practices can hurt performance and
    how we can employ alternative approaches to make our code more efficient. In this
    chapter, we’ll put some common techniques and practices under the microscope to
    examine their performance and compare their characteristics with potential alternatives.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有程序员故意编写低效的代码，但我们并不总是有时间对算法进行精细调整，以提取最大可能的性能。然而，了解某些编码实践如何影响性能，以及如何采取替代方法使代码更高效，依然非常重要。在本章中，我们将仔细分析一些常见的技术和实践，检查它们的性能，并将其特点与潜在的替代方案进行比较。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: Where default code behavior may not be optimally efficient
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪些情况下，默认的代码行为可能不是最优的
- en: Why some common performance concerns are misconceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么一些常见的性能问题其实是误解
- en: How to evaluate code performance and target its bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何评估代码性能并找出瓶颈
- en: When making small optimizations may be worth the trouble
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行小幅优化时，可能值得付出一定的努力
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring and Optimizing Performance</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">性能测量与优化</samp>
- en: 'The term *optimization* is often used to mean altering code to make a program
    run more quickly, but we might want to optimize for many other outcomes: lower
    memory use, higher numeric calculation precision, increased data throughput, and
    ease of deployment, to name just a few. Sometimes we trade raw performance for
    code readability or even convenience. We may decide that making our code easy
    to test is more important than making the program run at maximum speed. However,
    optimizing for one area can often adversely affect one or more other areas of
    an application, so we must make sure that the potential benefits are worth the
    cost and that our efforts aren’t actually leading to *pessimization*: writing
    or using code that prevents a program from running efficiently.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化* 这个术语通常指的是修改代码，使程序运行得更快，但我们可能还希望优化其他多种结果：更低的内存使用、更高的数值计算精度、更高的数据吞吐量以及更便捷的部署等。有时候，我们为了代码的可读性或便利性而牺牲纯粹的性能。我们可能会决定，让我们的代码更易于测试比让程序以最大速度运行更为重要。然而，优化某一领域往往会对应用程序的其他领域产生负面影响，因此我们必须确保潜在的收益值得成本，避免我们的努力实际上导致了*恶化*：编写或使用阻碍程序高效运行的代码。'
- en: The easiest and most direct method for optimizing a program’s performance is
    to enable optimizations in the build configuration. A release build configuration
    has optimizations enabled by default. When building the debug configuration, the
    compiler generates code that closely matches the source code’s structure and logic,
    which allows for setting diagnostic features like breakpoints, step-by-step debugging,
    and inspecting variables. The optimizations enabled in a release build may change
    the code’s logical structure in subtle ways, making debugging much more difficult
    but potentially improving the code’s efficiency or reducing the program’s size.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 优化程序性能的最简单直接方法是启用构建配置中的优化。发布版本构建配置默认启用优化。而在构建调试配置时，编译器生成的代码与源代码的结构和逻辑非常接近，这样可以设置诊断功能，如断点、逐步调试和检查变量。发布版本中启用的优化可能会以微妙的方式改变代码的逻辑结构，虽然会使调试变得更加困难，但有可能提高代码效率或减小程序体积。
- en: The C# compiler itself performs very little in the way of optimizing the code,
    leaving the majority of that work to the JIT compiler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器本身几乎不执行代码优化，而是将大部分工作留给 JIT 编译器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The JIT Compiler</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">JIT 编译器</samp>
- en: The C# compiler translates our C# code into CIL format, which in turn is translated
    to native machine code either ahead of time (AOT) by a tool such as the CrossGen
    utility or at run time by the JIT compiler, the latter being the default. In normal
    operation, the JIT compiler translates the program piecemeal; rather than producing
    the machine code for the entire program all at once before running it (as AOT
    tools do), the JIT compiler translates portions of the CIL to native format *just
    in time*. A portion would generally be a method, but in principle it could be
    part of a method, such as a loop or <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    block.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器将我们的 C# 代码转换为 CIL 格式，CIL 再通过像 CrossGen 工具这样的工具提前转换为本机机器代码（AOT），或者在运行时通过
    JIT 编译器转换，后者是默认方式。在正常操作中，JIT 编译器逐块翻译程序；它不会像 AOT 工具那样在运行程序之前一次性生成整个程序的机器代码，而是*及时*地将
    CIL 的部分内容翻译为本机格式。一个部分通常是一个方法，但原则上它也可以是方法的一部分，比如一个循环或 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    块。
- en: Because JIT compiler optimizations occur during a program’s execution, they’ll
    vary among platforms and run-time environments. While AOT compilation may improve
    a program’s startup time, the JIT compiler can take advantage of optimizations
    specific to a particular CPU, register set, operating system, and program state
    to produce efficient code on the fly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JIT 编译器的优化发生在程序执行期间，它们会因平台和运行时环境而异。虽然 AOT 编译可能改善程序的启动时间，但 JIT 编译器可以利用特定 CPU、寄存器集、操作系统和程序状态的优化，动态生成高效的代码。
- en: One common optimization is to inline the code within a method, avoiding the
    overhead of a method call. The JIT compiler may also be able to replace some method
    calls with native intrinsic CPU instructions, further improving performance. Once
    a block has been translated by the JIT compiler, its native code remains in memory,
    so it usually doesn’t need to be recompiled if the program runs it more than once.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的优化方法是将代码内联到方法中，避免方法调用的开销。JIT 编译器也可能能够用本机的内在 CPU 指令替换某些方法调用，从而进一步提高性能。一旦一个代码块被
    JIT 编译器翻译，它的本机代码就会保留在内存中，因此如果程序多次运行它，通常不需要重新编译。
- en: In a debug build, the JIT compiler is much less aggressive in the optimizations
    it applies so that normal debugging operations are supported. When we’re trying
    to assess our code’s performance, it usually makes the most sense to base that
    assessment on a release build so it will account for all of the optimizations
    performed by the JIT compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试版本中，JIT 编译器对其应用的优化要保守得多，以支持正常的调试操作。当我们尝试评估代码性能时，通常最合理的做法是基于发布版本进行评估，这样可以考虑到
    JIT 编译器所做的所有优化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance Benchmarks</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">性能基准</samp>
- en: When our code runs more slowly than we expect, simply observing the running
    application may give us some insights, but measuring performance precisely will
    allow us to target our optimization efforts more effectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码运行速度比预期慢时，仅仅观察正在运行的应用程序可能会给我们一些启示，但精确测量性能将使我们能够更有效地定位优化工作。
- en: Recording the time it takes for code to run—whether it’s a complete end-to-end
    run or just a portion of a program—is known as *benchmarking*. More generally,
    a *benchmark* is a standard against which something is measured. By timing our
    code, we establish a benchmark with which to compare a new version, to determine
    whether our changes have made the code faster or slower, or have had no discernible
    effect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码运行所需时间——无论是完整的端到端运行，还是程序的一部分——被称为*基准测试*。更一般来说，*基准*是用来衡量某物的标准。通过计时我们的代码，我们建立了一个基准，可以用来与新版本进行比较，从而判断我们的修改是让代码更快、更慢，还是没有明显效果。
- en: Many unit-testing frameworks report how long it takes for the tests to run,
    and even the elapsed time taken for individual tests. Keeping an eye on these
    numbers is certainly worthwhile because a sudden increase can indicate that an
    efficiency problem has been introduced somewhere. This approach can be particularly
    valuable in an automated *continuous integration (CI)* service, in which changes
    from multiple contributors are automatically integrated into a program; we can
    set up a CI service to alert us if the timing of the unit tests begins to change.
    If a particular test that usually runs in a few hundred milliseconds starts taking
    considerably longer, we can focus on the piece of code being tested to see if
    further investigation is warranted.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多单元测试框架会报告测试运行所需的时间，甚至单个测试的耗时。关注这些数字是非常有价值的，因为突如其来的增加可能表明某处引入了效率问题。这种方法在自动化的*持续集成
    (CI)* 服务中尤为重要，其中来自多个贡献者的更改会自动集成到程序中；我们可以设置 CI 服务，当单元测试的时间开始发生变化时给我们发出警报。如果一个通常在几百毫秒内完成的测试开始耗时更长，我们可以集中注意力查看正在测试的代码，看看是否需要进一步调查。
- en: 'A more fine-grained and precise approach to measuring how fast a section of
    code runs is to instrument the code itself. The basic technique is simple in principle:
    just before running the code to be measured, we create a timer to record the elapsed
    time, and when the code has finished running, we record the timer’s measurement.
    [Listing 8-1](#list8-1) shows a simple but naïve benchmark using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp>
    class from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp>
    namespace.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更加细粒度且精确的方法是对代码段本身进行计时。基本原理非常简单：在运行要测量的代码之前，我们创建一个计时器来记录经过的时间，当代码执行完毕时，我们记录计时器的测量值。[清单
    8-1](#list8-1)展示了一个简单但天真的基准测试，使用了来自<samp class="SANS_TheSansMonoCd_W5Regular_11">System.Diagnostics</samp>命名空间的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</sup>类。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A simple benchmarking
    approach</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-1：一种简单的基准测试方法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp> class is
    a lightweight high-resolution timer that records elapsed time with very high precision.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp> value
    is the number of ticks per second, so by multiplying the count of elapsed ticks
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp> before dividing
    by the frequency, we can report the time taken with millisecond granularity. This
    technique simply measures the elapsed time since the clock was started, so it
    can’t, for instance, determine whether the code being measured is actually running
    for all that time. The clock continues to tick even if the code is interrupted
    (for example, by switching to a different thread).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch</samp>类是一个轻量级的高分辨率计时器，能够以极高的精度记录经过的时间。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Stopwatch.Frequency</samp>值表示每秒的计时滴答数，因此通过将经过的滴答数乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1000.0</samp>，再除以频率，我们可以以毫秒为单位报告所花费的时间。这种技术仅仅是测量时钟开始后经过的时间，因此它无法确定所测量的代码是否在那段时间内一直在运行。例如，如果代码被中断（比如切换到其他线程），时钟依然会继续计时。
- en: Instrumenting code with a timer and recording it in the log or another audit
    trail can be a useful way to measure code running in a live system. However, measuring
    and reporting the performance takes time too, so we must be sure to take the measurements
    at a relatively high level. For instance, measuring and reporting how long code
    takes to respond to an <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp>
    request or call a remote procedure probably wouldn’t significantly impact the
    application’s performance. On the other hand, using this technique in a tight
    loop might well introduce more overhead than the cost of the loop itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中加入计时器并将其记录到日志或其他审计轨迹中，可以有效地测量在实时系统中运行的代码性能。然而，测量和报告性能本身也需要时间，因此我们必须确保在相对较高的层次进行测量。例如，测量和报告代码响应一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP</samp> 请求或调用远程过程的时间，可能不会显著影响应用程序的性能。另一方面，在紧密循环中使用这种技术，可能会带来比循环本身更大的开销。
- en: Benchmarking is also a useful way to explore performance in a test environment,
    perhaps to compare alternative approaches to solving a specific problem. The technique
    in [Listing 8-1](#list8-1) is naïve in that it measures the code only once. A
    more accurate approach for measuring performance would run the code many times
    and report the average time. We could write our own framework based on [Listing
    8-1](#list8-1), although a few freely available libraries for C# will do the heavy
    lifting for us, producing a report of the recorded performance along with other
    useful statistics, such as margin for error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试也是在测试环境中探索性能的一种有用方式，可能是用来比较解决特定问题的替代方法。[清单 8-1](#list8-1)中的技术是幼稚的，因为它只对代码进行了一次测量。更精确的性能测量方法是多次运行代码，并报告平均时间。我们可以基于[清单
    8-1](#list8-1)编写自己的框架，尽管一些免费的 C# 库可以帮助我们完成繁重的工作，生成包含记录的性能和其他有用统计数据（如误差范围）的报告。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Profiler</samp>
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分析器</samp>
- en: Benchmarking will tell us overall how quickly a piece of code runs, but to determine
    what the code does in detail, we need a *profiler*. Using a benchmarking tool
    in combination with profiling will give us the most accurate measurements. Among
    the several kinds of profiler available, the two most common are performance profilers
    and memory profilers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试将告诉我们代码运行的整体速度，但要确定代码的具体操作，我们需要一个*分析器*。将基准测试工具与分析结合使用将提供最准确的测量。在几种可用的分析器中，最常见的两种是性能分析器和内存分析器。
- en: A *memory profiler* will show us where our program allocates memory, how much
    is being used, and when it’s garbage collected. If we need to find out which parts
    of our code are using the most CPU time or which methods are being called most
    often, a *performance profiler* will give us precise measurements, allowing us
    to target specific hot spots in the code and optimize them if necessary. While
    optimizing memory usage is important, in this chapter we’ll focus on discovering
    bottlenecks in our code by using a performance profiler.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存分析器*将显示我们的程序在哪里分配内存，使用了多少内存，以及何时进行垃圾回收。如果我们需要找出哪些部分的代码使用了最多的 CPU 时间，或者哪些方法被调用得最频繁，*性能分析器*将提供精确的测量，帮助我们定位代码中的热点，并在必要时进行优化。虽然优化内存使用很重要，但在本章中，我们将重点通过使用性能分析器来发现代码中的瓶颈。'
- en: 'Performance profilers usually operate on a release build of a program and so
    take into account any optimizations applied by the compiler and JIT compiler.
    Measuring a debug build for its performance usually makes little sense, although
    sometimes it can be useful: comparing the results of profiling both a debug build
    and a release build of the same code, for instance, can provide insights into
    some of the optimizations the JIT compiler performs.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器通常在程序的发布版本上运行，因此会考虑编译器和 JIT 编译器所做的任何优化。测量调试版本的性能通常意义不大，尽管有时它可能会有用：例如，比较同一代码的调试版本和发布版本的分析结果，可以为我们提供
    JIT 编译器执行的一些优化的见解。
- en: While performance measurements can give us an idea of where bottlenecks may
    be slowing our code, it’s vital to keep in mind that a program’s performance is
    affected by many factors other than the code, including the version of the CLR
    or the version of the software development kit (SDK) we use. Even running the
    same program twice on the same machine can produce a different result, depending
    on how cache memory is allocated or how instructions are pipelined by the CPU’s
    scheduler. The JIT compiler may also apply different optimizations for each run,
    possibly further affecting the result. We must therefore be cautious of attaching
    too much importance to the absolute times in a profiler’s report, and instead
    look for trends or obvious anomalies, such as results differing by an order of
    magnitude or more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管性能测量可以让我们了解瓶颈可能会在哪些地方拖慢代码，但必须牢记，程序的性能受多种因素的影响，除了代码外，还包括我们使用的 CLR 版本或软件开发工具包（SDK）的版本。即使在同一台机器上运行相同的程序两次，也可能产生不同的结果，这取决于缓存内存的分配方式或
    CPU 调度器如何流水线处理指令。JIT 编译器还可能为每次运行应用不同的优化，这可能进一步影响结果。因此，我们必须小心不要过于看重性能分析报告中的绝对时间，而是要寻找趋势或明显的异常，例如结果相差一个数量级或更多。
- en: We’ll use a performance profiler to selectively measure specific aspects of
    code and analyze the profiler’s results. Remember that the specific results shown
    in this chapter are particular to the machine on which the test was performed,
    but we’ll try multiple approaches, measuring each attempt so that we can identify
    some common, repeatable patterns in the results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用性能分析器选择性地测量代码的特定方面，并分析分析器的结果。请记住，本章中显示的具体结果是针对执行测试的机器特定的，但我们会尝试多种方法，衡量每次尝试的结果，以便我们能够识别出结果中的一些常见、可重复的模式。
- en: To demonstrate how this works, next we’ll examine how simply changing a field’s
    type can dramatically affect the performance of code that relies on using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，接下来我们将研究如何仅仅改变字段类型就能显著影响依赖于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的代码性能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Measuring Basic Performance with Equals</samp>
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Equals 测量基本性能</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is an
    often neglected aspect of code optimization in C#. This method is a good candidate
    for performance measurement because it’s always available (since every type inherits
    it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class)
    but also customizable (as a virtual member of <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>).
    In this section, we measure the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for a simple value type so that we can compare the profiler’s results with the
    results from overriding <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    with our own implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法是 C# 中常被忽视的代码优化方面之一。该方法是性能测量的良好候选，因为它始终可用（因为每种类型都从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 基类继承它），同时也可以自定义（作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 的虚拟成员）。在本节中，我们将测量一个简单值类型的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的默认行为，以便将分析器的结果与通过我们自己的实现重写
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 后的结果进行比较。
- en: Struct types inherit a value-based equality comparison from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class, overriding the default implementation defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    universal base class. This ensures that when we copy an instance of a struct,
    the copy compares equal to the original by comparing the fields of each instance.
    We might be tempted to rely on this behavior, rather than implementing our own
    override of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    because it keeps our type definitions shorter and simpler, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct in [Listing 8-2](#list8-2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型继承自 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 类的基于值的相等性比较，并覆盖了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 通用基类中定义的默认实现。这确保了当我们复制结构体的实例时，复制品通过比较每个实例的字段与原始实例相等。我们可能会倾向于依赖这种行为，而不是实现我们自己的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法的重写，因为它使我们的类型定义更简短、更简单，就像
    [Listing 8-2](#list8-2) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    结构体一样。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Defining a simple
    struct type</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: 定义一个简单的结构体类型</samp>'
- en: Two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    that have the same property values will compare equal. Furthermore, like all structs,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> inherits a value-based
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, ensuring
    that two equal <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values
    always produce the same hash code. Additionally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is an immutable type, making it suitable for use as a key in a data structure
    that relies on hash codes for efficiency. In [Listing 8-3](#list8-3), we create
    many random <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances
    and then add them to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in a simple test that we can use to measure how well the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct performs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 两个属性值相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例会被认为相等。此外，像所有结构体一样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    继承了基于值的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 实现，确保两个相等的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值始终生成相同的哈希码。此外，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是不可变类型，适合用作依赖哈希码效率的数据结构的键。在
    [列表 8-3](#list8-3) 中，我们创建了许多随机的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    实例，然后将它们添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> 中，进行简单的测试，用以衡量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体的性能。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Generating a hashing
    collection</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-3：生成哈希集合</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> class is the
    Standard Library’s *pseudorandom number generator*, the name for an algorithm
    that uses a deterministic process to produce a sequence of numbers that *appear*
    random. Notably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp>
    class will produce the same sequence if it’s initialized with the same *seed*—that
    is, the value used to calculate the first number of the sequence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> 类是标准库的 *伪随机数生成器*，它是一个算法的名称，利用确定性过程生成一系列看似随机的数字。值得注意的是，如果使用相同的
    *种子* 初始化，<samp class="SANS_TheSansMonoCd_W5Regular_11">Random</samp> 类会生成相同的数字序列——即用于计算序列第一个数字的值。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Different versions of .NET (or .NET Core) may produce different sequences
    for a given seed.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*不同版本的 .NET（或 .NET Core）可能会为给定的种子生成不同的序列。*'
- en: In [Listing 8-3](#list8-3), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    as the seed and create new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances using the numbers generated by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    on the random-number generator. Since we use the same seed each time, we’ll get
    the same sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances each time the code runs. This characteristic is most often considered
    a downside of pseudorandom numbers, but it suits our purpose perfectly because
    we can run this code multiple times, and the same values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances will be generated for each run. In turn, comparing the performance of
    different runs is fair in that each run will be comparing identical sequences
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values. We’re using
    a randomly generated sequence to ensure that the final <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    contains a reasonably realistic population of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8-3](#list8-3) 中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    作为种子，并使用通过调用随机数生成器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Next</samp>
    方法生成的数字来创建新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例。由于我们每次都使用相同的种子，因此每次运行代码时都会生成相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例序列。这一特性通常被认为是伪随机数的缺点，但它完全符合我们的需求，因为我们可以多次运行此代码，并且每次运行都会生成相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例值。因此，在比较不同运行的性能时是公平的，因为每次运行都将比较相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值序列。我们使用随机生成的序列来确保最终的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> 包含一个合理真实的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    值集合。
- en: In [Listing 8-3](#list8-3), we create each <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance by masking off the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    values from each random number. The profiler output in [Table 8-1](#tab8-1) shows
    the performance of the hash table’s constructor. For this test, we’re simply measuring
    elapsed time, also called *CPU sampling*, for each method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8-3](#list8-3)中，我们通过从每个随机数中屏蔽掉<code>Red</code>、<code>Green</code>和<code>Blue</code>值来创建每个<code>Color</code>实例。[表
    8-1](#tab8-1)中的性能分析器输出显示了哈希表构造函数的性能。对于这个测试，我们只是简单地测量每个方法的经过时间，也称为*CPU采样*。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-1：</samp> <samp class="SANS_Futura_Std_Book_11">创建</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> <samp class="SANS_Futura_Std_Book_11">的性能报告</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet''1..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor
    (IEnumerable, IEqualityComparer)</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% HashSet''1..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1..ctor
    (IEnumerable, IEqualityComparer)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith
    (IEnumerable)</samp> |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% UnionWith</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.UnionWith
    (IEnumerable)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot
    Present(T, out Int32)</samp> |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">87.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1.AddIfNot
    Present(T, out Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">36.5% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">21</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp> |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">14.0% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7.9</samp> |  |'
- en: We’re focusing on the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    and ignoring everything else, including the random-number generation and creation
    of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects.
    Different profilers represent their reports differently, but the information presented
    is generally similar.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于<code>HashSet</code>的创建，并忽略其他所有内容，包括随机数生成和单个<code>Color</code>对象的创建。不同的性能分析器以不同的方式展示报告，但呈现的信息通常是相似的。
- en: The indentation in the first column of this report shows the call stack being
    measured. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> constructor
    on the first line calls a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>,
    which in turn calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.
    This last method eventually calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. The leftmost value in the output shows the time spent by that method as
    a percentage of the test’s total time. In our test, creating the initial sequence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values takes up
    the remainder of the time but isn’t really relevant to testing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The next field is the simple name of the method, followed by the absolute time
    in milliseconds spent in that method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 报告第一列的缩进显示了正在测量的调用栈。第一行中的<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>构造函数调用了一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnionWith</samp>的方法，该方法又调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>。最后这个方法最终调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法。输出中的最左边值显示了该方法所花费时间占测试总时间的百分比。在我们的测试中，创建初始的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>值序列占用了剩余的时间，但与测试<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的方法并不直接相关。接下来的字段是方法的简单名称，后面跟着该方法所用的绝对时间（以毫秒为单位）。
- en: Finally, the fully qualified name of the method indicates which specific method
    is being reported. Since our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct doesn’t provide its own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    is used to add unique keys to the hash table.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，方法的完全限定名表明了具体报告的是哪个方法。由于我们的简单<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体没有提供自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>实现，因此输出显示使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>来为哈希表添加唯一键。
- en: As noted earlier, the actual times in milliseconds reported here could change
    based on a combination of many factors, so they shouldn’t be taken literally.
    However, they establish a baseline we can use to compare the results of other
    tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，报告的实际毫秒数可能会基于多个因素的组合而有所变化，因此不应字面理解。然而，它们为我们提供了一个基准，可以用来比较其他测试的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hidden Costs of Simplicity</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简化的隐藏成本</samp>
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type uses three
    values for the RGB components. Although they’re being stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties, each one 4 bytes wide, we use only 1 byte for each value by masking
    off the lowest 8 bits of each argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    constructor. We might infer that we can save on storage space by storing the properties
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> fields rather than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. [Listing 8-4](#list8-4)
    shows the changed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型使用三个值表示RGB组件。虽然它们被存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>属性中，每个属性占4个字节，但我们通过将每个参数的最低8位掩码掉，使用了每个值仅占1个字节的方式来存储。我们可能会推测，通过将属性存储为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>字段，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，可以节省存储空间。[示例
    8-4](#list8-4)显示了修改后的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Storing byte fields
    for color components</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-4：存储颜色组件的字节字段</samp>
- en: 'We still allow <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> arguments
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> constructor
    so that our users won’t have to explicitly cast the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    when creating <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.
    Casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values explicitly
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> has the same effect
    as the masking operations we used in [Listing 8-3](#list8-3): the value is truncated
    to just the lowest 8 bits. If we use this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in the test to produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    from [Listing 8-3](#list8-3), the results are quite different. [Table 8-2](#tab8-2)
    shows just the call tree for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然允许<sup class="SANS_TheSansMonoCd_W5Regular_11">int</sup>类型的参数传递给<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>构造函数，以确保用户在创建<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>值时无需显式地将参数转换为<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>类型。将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">int</sup>值显式转换为<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>与我们在[清单8-3](#list8-3)中使用的掩码操作效果相同：值会被截断，只保留最低的8位。如果我们在测试中使用这种版本的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>来生成一个来自[清单8-3](#list8-3)的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</sup>，结果会大不相同。[表8-2](#tab8-2)仅显示了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</sup>的调用树。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp> <samp class="SANS_Futura_Std_Book_11">Profile
    Report of Adding Objects with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    <samp class="SANS_Futura_Std_Book_11">Fields to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-2：</samp> <samp class="SANS_Futura_Std_Book_11">使用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> <samp class="SANS_Futura_Std_Book_11">字段将对象添加到</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>的性能报告
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T, out Int32)</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">7,494</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T, out Int32)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">39.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2,967</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">650</samp> |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.66% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">650</samp> |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [Thread suspended]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.16% [线程挂起]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |  |'
- en: We see a dramatic change in the execution profile of the code, with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> method taking well
    over seven full seconds to complete. Comparing this report to [Table 8-1](#tab8-1),
    we can see clearly that the main reason for the extra time is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到代码的执行情况发生了显著变化，<samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>方法完成需要超过七秒钟。将此报告与[表8-1](#tab8-1)进行比较，我们可以清楚地看到额外时间的主要原因是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法，该方法由<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>类从<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</sup>基类继承。
- en: 'In some instances, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can perform a *very* fast bitwise comparison, but with several caveats: this comparison
    can’t be used if any field is a reference, a floating-point number, or a type
    that itself overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Two different reference values could refer to objects of a type with its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and a bitwise comparison
    would compare them as not equal, even if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    would return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. For the
    same reason, any value type with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method could use that method to compare some values with different bit patterns
    as equal. Two floating-point numbers with matching bit patterns aren’t necessarily
    equal; in particular, if both values are <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    they shouldn’t compare equal.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>可以执行*非常*快速的按位比较，但有几个注意事项：如果任何字段是引用类型、浮点数，或者是重写了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>的方法类型，那么这个比较就不能使用。两个不同的引用值可能指向具有自己<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法的对象，按位比较会将它们视为不相等，即使<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>会返回<sup class="SANS_TheSansMonoCd_W5Regular_11">true</sup>。出于同样的原因，任何具有自己<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法的值类型也可能会用该方法将具有不同位模式的值视为相等。两个具有匹配位模式的浮点数不一定相等；特别是如果两个值都是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">NaN</sup>，它们不应视为相等。
- en: Another condition for the fast comparison to be used is that a struct must be
    *tightly packed*, meaning its fields don’t require any padding to be properly
    aligned in memory. The three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields in the original implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    would automatically be aligned in memory. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    instead means the fields aren’t tightly packed, so we must use another, much slower
    comparison, with the substantial performance penalty shown in [Table 8-2](#tab8-2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速比较的另一个条件是，结构体必须是*紧凑打包的*，即其字段不需要额外填充就能在内存中正确对齐。在<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>原始实现中的三个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">int</sup>字段会自动在内存中对齐。然而，使用<sup class="SANS_TheSansMonoCd_W5Regular_11">byte</sup>代替意味着字段不再是紧凑打包的，因此必须使用另一种速度较慢的比较，这会带来显著的性能损失，见[表
    8-2](#tab8-2)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.Equals
    Method</samp>
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ValueType.Equals
    方法</samp>
- en: When the fast bitwise comparison isn’t applicable, the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    is necessarily very general, because it must work for any struct type, regardless
    of the number of fields the struct has or their type. In addition to having fields
    of built-in primitive types, a struct can contain references to class instances
    and instances of other user-defined values, any of which may have its own custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当快速的按位比较不可用时，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>中<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>的实现必然是非常通用的，因为它必须适用于任何结构体类型，无论结构体有多少个字段，或字段的类型是什么。除了拥有内建原始类型的字段，结构体还可以包含对类实例和其他用户定义值的引用，而这些值可能有自己的自定义<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>实现。
- en: The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    first must determine which fields need to be compared. It does this by using *reflection*—programmatically
    inspecting (or changing) the run-time structure of the program—to discover all
    the instance fields, which immediately comes with a quite significant run-time
    cost. Reflection isn’t usually associated with high-performance algorithms, and
    this certainly accounts for the reduction in performance caused by altering our
    struct’s <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields to use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> 方法的实现首先必须确定需要比较哪些字段。它通过使用
    *反射*——以编程方式检查（或修改）程序的运行时结构——来发现所有实例字段，这立即带来了相当显著的运行时开销。反射通常与高性能算法无关，这也确实解释了由于我们将结构中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 字段改为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>，导致的性能下降。
- en: After determining the array of fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    obtains each field’s value. If the field value isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is called with the value from the corresponding field in the struct being compared.
    As a result, every value type field in both structs will be boxed in order to
    perform the comparison, because using reflection to obtain the values means each
    value is accessed via an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference, adding further cost.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定字段数组之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    会获取每个字段的值。如果字段值不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 引用，则会调用其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，并使用来自与之比较的结构中的相应字段的值。因此，两个结构中每个值类型的字段都会进行装箱以执行比较，因为使用反射获取值意味着每个值都是通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 引用来访问的，这进一步增加了成本。
- en: The root cause of our performance problem is that the change from using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> properties to <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>
    values means that the underlying backing fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    are no longer tightly packed. Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    can’t use the fast bitwise comparison and instead employs reflection to discover
    the values to be compared. To address this issue, in [Listing 8-5](#list8-5) we
    override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    and provide our own implementation to compare the property values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们性能问题的根本原因是，从使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 属性改为使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp> 值意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    的底层字段不再紧密打包。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    无法使用快速的按位比较，而是使用反射来发现需要比较的值。为了解决这个问题，在 [Listing 8-5](#list8-5) 中，我们重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法，并提供了我们自己的实现来比较属性值。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Overriding the
    Equals method</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: 重写 Equals 方法</samp>'
- en: The report in [Table 8-3](#tab8-3) from rerunning the test shows that while
    we’ve substantially improved its speed, we still have work to do.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从重新运行测试的报告中，见 [Table 8-3](#tab8-3)，虽然我们已经大幅提高了速度，但仍然有进一步改进的空间。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">How
    the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method Performs</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">重写的</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">方法的性能</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间（毫秒）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,889</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .AddIfNotPresent(T,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">out Int32)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">588</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.4% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">588</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Object)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">236</samp> |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.15% [垃圾回收]</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">236</samp> |  |'
- en: Notice that our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is consuming a much smaller percentage of the overall time in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>,
    although this approach is still much slower than the test using our original version
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    properties.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重写的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法消耗的时间占总时间的比例远小于<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法的时间，尽管这种方式仍然比我们使用原始版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>（该版本使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>属性）时要慢得多。
- en: This report tells us that the majority of the time was spent in the code of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp> as opposed
    to any methods called by it. To discover why, we’ll use a different kind of profiling,
    sometimes known as *instrumentation profiling*, or *tracing*, which records the
    number of times each method is called in a program. Because this requires the
    profiler to intrusively measure a running program, the time measurements are often
    much higher; however, knowing which methods are being called most often is valuable
    information. [Table 8-4](#tab8-4) shows the tracing report for <samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp>
    and the methods called within it, including the number of times each method was
    called.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这份报告告诉我们，大部分时间花费在了<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法上，而不是它所调用的其他方法。为了发现原因，我们将使用另一种类型的性能分析，有时被称为*插装分析*，或*跟踪*，它记录程序中每个方法的调用次数。因为这要求分析工具以侵入性方式测量正在运行的程序，所以时间测量通常要高得多；然而，知道哪些方法被调用得最多是非常有价值的信息。[表
    8-4](#tab8-4)展示了<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">AddIfNotPresent</samp></sup>方法及其内部调用的跟踪报告，包括每个方法的调用次数。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-4:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-4:</samp> <samp class="SANS_Futura_Std_Book_11">Equals的跟踪报告</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">方法</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时间
    (毫秒)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">调用次数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">签名</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">99.9% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16,681</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">40.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6,724</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">312,222,485</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Garbage
    collection]</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp> |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.76%</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[垃圾回收]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">293</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,593</samp>
    |  |'
- en: This report has an extra column that shows the number of times each method was
    called during the program’s execution. The tracing report took significantly longer
    to run, but more importantly, it shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method being invoked a huge number of times. In fact, the number of invocations
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is suspiciously
    close to the triangular number of 25,000—the number of elements in the original
    sequence. The *triangular number* of some number *n* is the sum of the whole numbers
    from 1 to *n*. When *n* is 25,000, the triangular number is 312,512,500.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本报告有一个额外的列，显示程序执行过程中每个方法被调用的次数。跟踪报告运行时间显著较长，但更重要的是，它显示了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法被调用了大量次。事实上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的调用次数与25,000的三角形数字非常接近——这就是原始序列中的元素数量。某个数字*n*的*三角形数字*是从1到*n*的所有整数之和。当*n*为25,000时，三角形数字为312,512,500。
- en: While we’ve customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> class also uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> when adding or searching
    for a key, and our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type relies on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
    Let’s look at how this relates to the number of times <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called in our test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们为<Color>结构定制了<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>类在添加或查找键时也会使用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>，而我们的<Color>类型依赖于从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>继承的默认<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>实现。让我们看看这与在我们的测试中调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的次数有何关系。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The ValueType.GetHashCode
    Method</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ValueType.GetHashCode
    方法</samp>
- en: As [Chapter 5](chapter5.xhtml) explained, the elements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    are unique; every key in the table exists only once. A new object is added to
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> only if it doesn’t
    already exist in the table; otherwise, it’s ignored.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](chapter5.xhtml)所解释，<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中的元素是唯一的；表中的每个键只出现一次。只有当新对象在表中不存在时，才会将其添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>中；否则，它将被忽略。
- en: When we add an item to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>
    in this example, the implementation uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to identify existing keys with the same hash code. The fact that the hash codes
    are the same doesn’t necessarily mean any of the existing keys have the same value
    as the new item. If no existing key has the same hash code as the new item, the
    new object is added to the table. If one or more existing keys have hash codes
    that match the new item’s hash code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used to determine whether the item should be added. Each key with the
    same hash code is compared with the new item in turn, and if no match is found,
    the new item is added to the table as a new key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个例子中向<samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>添加一个项目时，实施方法使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>来识别具有相同哈希码的现有键。哈希码相同并不一定意味着任何现有键的值与新项相同。如果没有现有键的哈希码与新项相同，则新对象将被添加到表中。如果一个或多个现有键的哈希码与新项的哈希码匹配，则会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法来确定是否应该添加该项。每个与新项哈希码相同的键都会与新项逐一进行比较，如果没有找到匹配项，则将新项作为新键添加到表中。
- en: Having <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> being called
    so often in our test indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is producing
    hash codes that aren’t well distributed. When the first element is added to the
    hash table, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> isn’t
    called at all, because there’s nothing to compare with. If the second element
    has an identical hash code to the first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is called to determine if they’re identical keys. This process will repeat for
    each subsequent element that has the same hash code as an existing key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试中经常调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，这表明我们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法生成的哈希码分布不均匀。当第一个元素被添加到哈希表时，根本不会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，因为没有可比较的元素。如果第二个元素的哈希码与第一个元素相同，则会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 来确定它们是否是相同的键。如果随后的元素的哈希码与已存在的键相同，这个过程会重复进行。
- en: If all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> objects
    in the initial sequence of 25,000 elements produce identical hash codes but have
    different values, adding the final new element will require a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for all of the existing 24,999 keys.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始序列中的 25,000 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    对象生成相同的哈希码但值不同，那么添加最后一个新元素时，需要对所有现有的 24,999 个键调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>。
- en: In fact, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    inherited by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct
    will likely produce many identical hash codes, regardless of whether the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances have different
    values. The reason is related to the poor performance of the implementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, and it explains why
    the number of calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is so close to the triangular number of the sequence length.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    的默认实现被 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体继承时，可能会生成许多相同的哈希码，而不管
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例的值是否不同。原因与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> 提供的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    实现的性能较差有关，这也解释了为什么调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的次数接近于序列长度的三角数。
- en: If instances of a struct can be compared using the fast bitwise comparison for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp>
    method produces hash codes based on the bit pattern of the instance in memory.
    If, on the other hand, the struct isn’t eligible for the fast bitwise comparison,
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation
    considers only the first non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    instance field of the struct—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    property in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type—with
    the result that we can get a maximum of only 256 unique hash codes. We solve that
    problem by implementing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    method to produce more unique hash codes, preferably so that each distinct <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value produces a unique hash
    code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体的实例可以通过快速的位运算比较（使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>）进行比较，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.GetHashCode</samp> 方法将根据实例在内存中的位模式生成哈希码。另一方面，如果该结构体不适合进行快速的位运算比较，默认的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> 实现则只考虑结构体的第一个非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 实例字段——在我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类型中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp> 属性——因此最多只能生成 256
    个唯一的哈希码。我们通过实现自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    方法来解决这个问题，生成更多的唯一哈希码，最好是每个不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    值生成一个唯一的哈希码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HashCode.Combine
    Method</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HashCode.Combine
    方法</samp>
- en: In [Listing 8-6](#list8-6), we add our own override of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct to complement
    our overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    and implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode.Combine</samp>
    method from the Standard Library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Overriding a GetHashCode
    method</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Combine</samp> method produces
    well-distributed hash codes based on its inputs, and while we might be able to
    write our own carefully optimized replacement, doing so is far from trivial. Now
    when we run the test, we see that the combined effect of overriding both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    reduces the number of calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method by a considerable amount, as shown in [Table 8-5](#tab8-5).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-5:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for the Overridden</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% Combine</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.HashCode.Combine(T1, T2,
    T3)</samp> |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.27% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">0.09</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">18</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Color.Equals(Object)</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: Even accounting for the overhead of counting the method calls, this report shows
    a vast improvement in speed compared with our previous results and demonstrates
    the close relationship between <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We pay a
    high cost in efficiency if we accept the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> provided
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> rather than
    implementing those methods ourselves in our custom struct types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: If we revisit the profile of our original struct that had <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    fields but no method overrides, we can see that even though that struct could
    be packed efficiently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is still invoked much more frequently than in our latest version (see [Table
    8-6](#tab8-6)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-6:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for a Packed Struct with No Overrides</samp>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">85.6% AddIfNotPresent</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">25,000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">30.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">36</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">1,219,104</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">System.ValueType.Equals(Object)</samp>
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.54% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>
    |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.42% Resize</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.HashSet`1
    .Resize(Int32, Boolean)</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: We’d certainly notice a performance problem if we were to scale up the number
    of elements being added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, several
    other collection types rely on hash codes for efficiency, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Lookup</samp> types. Therefore,
    it’s essential that we override both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for
    any type that could be used as a key for hashing collections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Optimizing Equality</samp>
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While overriding both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> produces
    the most impressive performance improvements, we can do more to fine-tune equality
    comparisons. After all, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is used in circumstances other than when we’re creating data structures
    that rely on hash codes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is a relatively
    simple data type, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is already quite efficient. To probe the characteristics of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    we’ll make a much more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    value type, shown in [Listing 8-7](#list8-7). The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    struct overrides both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> with custom
    implementations but doesn’t yet implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. We’ll implement that interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    later to see how that affects the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Defining a more
    complex data type, Purchase</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> type has
    three fields, one of which is another nontrivial type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>,
    shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> needs to do a little more
    work than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type back in
    [Listing 8-5](#list8-5). When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method must also ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    properties match, which involves a method call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    类型中需要做比 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法更多的工作，如 [示例 8-5](#list8-5)
    所示。当我们比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例的相等性时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法还必须确保 <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    属性匹配，这涉及到对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>
    方法的调用。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The Purchase type is quite large—40 bytes plus padding, assuming a 64-bit
    architecture—so we should expect copying instances around to be less efficient
    than for the smaller Color type. That won’t affect our profiling, though, as we’ll
    still be comparing reports for the same types. We’ll return to the cost of copying
    large struct instances in “Copying Large Instances” on [page 272](#sec18).*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Purchase 类型相当大——假设是 64 位架构，则为 40 字节加上填充——因此我们应该预期复制实例的效率低于较小的 Color 类型。不过，这不会影响我们的性能分析，因为我们仍然会比较相同类型的报告。我们将在《复制大型实例》一节中返回讨论复制大型结构实例的成本，见
    [第 272 页](#sec18)。*'
- en: Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two very large lists of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, as shown in [Listing 8-8](#list8-8). This process will exercise the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, allowing us to measure
    its efficiency. To magnify the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compared to the cost of the surrounding code, we increase the number of elements
    to 10 million.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> 方法来比较两个非常大的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 对象列表，而不是使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>，如 [示例 8-8](#list8-8) 所示。此过程将测试
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，从而允许我们衡量它的效率。为了放大
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法与周围代码开销的性能对比，我们将元素数量增加到
    1000 万。
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Testing to exercise
    equality</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-8：测试以练习相等性</samp>
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method, we use digit separators, available since C# v7.0, to make the large literal
    number easy for human readers to parse. Digit separators make no difference to
    the compiler: the number we use for the length of the initial sequence is still
    a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp> 方法中，我们使用自
    C# v7.0 起提供的数字分隔符，使得大型字面量数字更易于人类阅读和解析。数字分隔符对编译器没有影响：我们用于初始序列长度的数字仍然是一个普通的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    compares two sequences and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if they have the same elements in the same order. The algorithm obtains an element
    from each sequence and compares those elements by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> doesn’t
    try to optimize its result by checking if the two sequences are in fact the *same*
    sequence, so here we create only one sequence of 10 million elements and compare
    it with itself. [Table 8-7](#tab8-7) shows the profiler report for the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-7:</samp> <samp class="SANS_Futura_Std_Book_11">Exercising
    the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> <samp class="SANS_Futura_Std_Book_11">Method</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1,227</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">49.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">781</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Object)</samp>
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">24.3% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">384</samp> |  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.6% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">168</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Object)</samp>
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.75% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.38% Unbox</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Runtime.CompilerServices
    .CastHelpers.Unbox(Void*, Object)</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: We can see that garbage collection contributes a significant portion of the
    time required by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instance results
    in the argument being boxed, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a struct and the parameter type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, a reference
    type. Furthermore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>,
    which also requires its argument to be boxed. The consequence is that we’re allocating
    many boxed objects on the heap, placing the garbage collector under fairly significant
    pressure to keep memory usage under control.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In each <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    the parameter needs to be unboxed back to its original type so that its properties
    can be compared; the cost of unboxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter for each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods is tiny but has a measurable impact. We can avoid the costs of boxing,
    and much of the associated cost of garbage collection, by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Effect of IEquatable<T></samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    automatically selects the best (the most efficient) implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    available to perform the comparisons. Internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    helper class from [Chapter 5](chapter5.xhtml) to determine how to compare elements.
    If the element type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>, it’s guaranteed
    to implement a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    and that overload will be called by <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: If we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface and provide our own type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>
    interface method by default, avoiding the need for boxing and then unboxing the
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. In turn,
    this reduces memory pressure because the arguments aren’t copied to the heap,
    resulting in fewer objects for the garbage collector to inspect. In our example,
    those reductions are considerable, so implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface should produce a measurable benefit. [Listing 8-9](#list8-9)
    shows the changes required in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: The IEquatable</samp><
    Purchase> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase
    other)</samp> overload to perform the comparisons between each of the property
    values. The original <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    override still needs to unbox its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameter in order to call the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    overload, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    because we’ve also changed the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    declaration to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp> interface. In [Listing 8-10](#list8-10), we make similar changes
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> so that calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp> from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp> method won’t require
    boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Implementing
    IEquatable</samp>< Product>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The results of the test from [Listing 8-8](#list8-8), incorporating the changes
    from [Listings 8-9](#list8-9) and [8-10](#list8-10), still with 10 million <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> elements, are shown in
    [Table 8-8](#tab8-8).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-8:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Type-Safe</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    <samp class="SANS_Futura_Std_Book_11">Method</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">62.6% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">546</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">13.0% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">114</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.48% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.05% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Ordered</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Ordered()</samp>
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.37% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.get_Item()</samp>
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: Comparing this report with [Table 8-7](#tab8-7), we can see that the total time
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> has been
    greatly reduced, but also that our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method is significantly faster than the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type’s version without the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>. Much of the difference is thanks to the lack of garbage collection,
    but we’re also benefiting from removing the need to box and unbox the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Accesses</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Purchase)</samp> method
    spends a measurable portion of its time accessing properties to compare them.
    All of the properties of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> are automatic
    properties, and every access to those properties is a method call—for example,
    the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Item</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Ordered</samp> shown in [Table
    8-8](#tab8-8). While the JIT compiler may often be able to optimize such calls
    away by inlining the underlying method, there’s no guarantee that it will. In
    [Listing 8-11](#list8-11), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    to introduce our own private fields and alter <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to compare the fields directly rather than accessing the property values for comparison.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Comparing fields
    rather than properties</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Although not shown here, we also change <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to replace its automatic properties with private fields. [Table 8-9](#tab8-9)
    shows the results of comparing 10 million elements the same way we have previously.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-9:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    the Performance of Fields vs. Properties</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">51.2% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">442</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.73% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">84</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.47% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">30</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.op_Equality(DateTime,
    DateTime)</samp> |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: Although replacing automatic properties with fields shows a small improvement,
    it’s an example of a micro-optimization. We’ve cut the time needed for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by more than half compared to the version that didn’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    Purchase></samp>, but we’re still talking about only a few hundred milliseconds
    in absolute time. We had to dramatically increase the size of the sequence to
    amplify the results enough to be observable, and most applications don’t routinely
    need to compare lists of 10 million elements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface is a much more important step. Not only do we benefit from
    an increase in speed, but our type makes much more efficient use of memory by
    not needing to box the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>
    for value types is more than a performance optimization; it establishes that our
    type follows that protocol, enabling certain library features to operate more
    efficiently and signaling efficiency to human readers too.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Equality Operators</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final part of implementing a full set of equality comparisons for a type
    is to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    with its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>.
    [Listing 8-12](#list8-12) shows those operators implemented for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Implementing
    equality operators for Purchase</samp>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Again, we also add equality operators to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type (not shown), allowing us to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> by using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead of calling its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Each operator
    implementation simply forwards to our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, where the comparison is performed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: While we can write a test to call <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    in order to measure its performance characteristics, we can also arrange for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method to call
    the operator rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    by providing our own equality comparer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Generic IEqualityComparer<T>
    Interface</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    doesn’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly
    on the sequence elements to compare them. Instead, it relies on an implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>,
    which is part of the Standard Library and declared in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic</samp>
    namespace.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> requires an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method taking two parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter.
    The Standard Library provides some default implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, including one for instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    that implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> interface, which is what our uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    have relied upon thus far.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    has an overload that takes a second parameter whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp>, so we can provide our own implementation to be used instead of the
    default comparer. In [Listing 8-13](#list8-13), we create our own implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp>
    interface, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as the generic parameter, and pass an instance of our custom comparer to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Creating a custom
    IEqualityComparer</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    Purchase></samp> defines its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to compare its two parameter values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    instead of the parameter type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. We don’t need a separate implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> member
    method in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> directly to compare the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> values. Now, when we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to compare
    two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items, the algorithm will use <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for the comparisons. [Table 8-10](#tab8-10) shows the profiler report for comparing
    10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> items.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-10:</samp> <samp class="SANS_Futura_Std_Book_11">How</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <samp class="SANS_Futura_Std_Book_11">Performs</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">48.8% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">475</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">22.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">216</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer
    .Equals(Purchase, Purchase)</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">9.28% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">90</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(Purchase,
    Purchase)</samp> |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.28% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.53% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(Product,
    Product)</samp> |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: When we define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    for any type, the compiler translates it to a static method named <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>,
    shown in this profiler report. That method takes both of its parameters by value,
    so we’re making a lot of copies of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instances. We
    can reduce the number of copies needed by changing the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference instead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Read-Only in Parameters</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To reap the benefits of altering our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    methods to take their parameters by reference rather than by value, we can use
    read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
    They are specifically intended for avoiding copies of large value type instances
    and are appropriate when we don’t need to mutate the parameter variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn’t expect a huge improvement, however, because we can’t avoid all
    the copies being made when comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    elements in our sequence. In particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals</samp>
    method must take its parameters by value to match the signature defined in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer< T ></samp> interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as shown in [Listing 8-14](#list8-14), the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    itself takes its parameter by value according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, but we can add a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    and use the same mechanism to alter the equality operators to take all their parameters
    by reference.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: Overloading using
    in parameters</samp>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter the
    main implementation and forward to it from the equality operators and the implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Purchase></samp>.
    Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters are
    transparent to calling code, the rules for overloading will give preference to
    the method with no parameter modifiers, unless we add an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to the argument when calling the method. Therefore, we explicitly select
    the overload with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword
    to the argument we pass wherever we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Replacing value parameters with in parameters is a version-breaking change,
    requiring extra care if binary compatibility is a consideration.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to change the implementation of our <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp>
    to pass the arguments by reference, since our <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    method doesn’t have an overload taking parameters by value. We can reuse the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer</samp> from [Listing
    8-13](#list8-13) to run the test, with the results shown in [Table 8-11](#tab8-11).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-11:</samp> <samp class="SANS_Futura_Std_Book_11">Results
    of Passing by Reference to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">45.1% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">437</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20.9% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">203</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.5% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.23% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(in
    Purchase)</samp> |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% op_Equality</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.op_Equality(in
    Product, in Product)</samp> |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.38% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">72</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(in
    Product)</samp> |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: Comparing these results to [Table 8-10](#tab8-10), we can see the improvement
    is quite modest. While we certainly get some benefit from avoiding copying <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects, that benefit
    is limited to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    actually being called. [Table 8-12](#tab8-12) shows a tracing report with counts
    of the number of method calls, showing that the JIT compiler is inlining all but
    a very few calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-12:</samp> <samp class="SANS_Futura_Std_Book_11">Tracing
    Report for Comparing</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    <samp class="SANS_Futura_Std_Book_11">Parameter Values</samp>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Number of calls</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.88% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2,013</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    call</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.SequenceEqual
    [...]</samp> |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.69% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">735</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10,000,000
    calls</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualsOperatorComparer.Equals(Purchase,
    Purchase)</samp> |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">[...]</samp> |  |  |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">0.08% op_Equality</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">82</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">126,402
    calls</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Purchase.op_Equality(in
    Purchase, in Purchase)</samp> |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: While using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    in our definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    is free in that it requires no changes to calling code, we shouldn’t expect too
    much from it. We also shouldn’t simply apply <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters routinely, even when using them wouldn’t detract from a method’s readability.
    Passing small value types by reference may incur a penalty due to the extra level
    of indirection required to access the value itself via a by-reference variable.
    As with any optimization feature in the code, we should introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters only where our measurements show that they’re warranted.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Type Affects Performance</samp>
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our choice of types in an application can affect its overall performance in
    various ways. The types we use to represent values in an application are the most
    important part of that choice because the other types will usually be classes
    in any case. Values, on the other hand, can be represented as structs, classes,
    records, or record structs. In this section, we’ll examine some of the factors
    that can help us decide between using struct types and class types to implement
    those value types, and how much those factors affect performance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We often hear that structs, and therefore record structs, should be small because
    it’s expensive to copy large instances around in memory. With that in mind, we’ll
    start by attempting to isolate the cost of copying instances from the other factors
    affecting performance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Cost
    of Copying</samp>
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with our previous performance measurements, we need to establish a simple
    baseline against which we can compare further performance reports. Since we want
    to measure the cost of copying a large value type, first we have to measure the
    cost of copying a small, simple type, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct we create in [Listing 8-15](#list8-15).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Creating a simple
    struct with a single int field</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: To exercise copying, we’ll again use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method, which copies elements from the sequences to compare them and will copy
    them again to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Equals</samp>
    method. Here, we return to using the default equality comparer, which will call
    our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method,
    passing its argument by value. [Listing 8-16](#list8-16) shows the code we’ll
    use to produce our benchmark performance profile.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: Testing simple
    copies</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: For this test, we’ll profile a debug build of this code to try to minimize the
    effects of the method inlining performed by the JIT compiler. Method arguments
    are copied only if the method is invoked normally, and inlining would make measuring
    the cost of those copies unreliable; two different runs of the code could easily
    make a different number of copies. [Table 8-13](#tab8-13) shows the CPU sampling
    report for comparing two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    items in a debug build, which inhibits the JIT compiler from inlining method calls.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-13:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying a Simple Struct</samp>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">57.0% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField.Equals(IntField)</samp>
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> algorithm
    does little other than obtain an element from each sequence and compare one to
    the other with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The
    difference between the time taken by <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and the total time spent in <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    here is all overhead, representing the time taken to obtain each pair of elements
    from the sequences and copy the arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Large Instances</samp>
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copying a simple struct type such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    struct in [Listing 8-15](#list8-15) is no more expensive than copying a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value; a simple test
    (not shown here) that compares two sequences of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values will confirm it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct in [Listing 8-17](#list8-17), which adds three entirely redundant <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> fields, is significantly larger
    than the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp> struct.
    Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp> is 16 bytes, making
    this struct somewhat larger than even the most generous recommended limit for
    the size of a value type.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: Creating an extremely
    large struct</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Note one subtlety in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    struct: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    doesn’t consider any of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    fields of the type, because they’re always all identical in any case. The reason
    is that we’re trying to measure just the cost of copying, so this <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method performs precisely the same operations as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntField</samp>
    type in [Listing 8-15](#list8-15). While the padding fields play no part in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method or any other
    operation, the <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type is a struct and therefore copied by value, so *every* field will be copied.
    We run the same test from [Listing 8-16](#list8-16), with the results shown in
    [Table 8-14](#tab8-14).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-14:</samp> <samp class="SANS_Futura_Std_Book_11">Measuring
    the Cost of Copying an Extra-Large Struct</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">52.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">228</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.71% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16.Equals(IntPlus3x16)</samp>
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: 'Compare [Table 8-14](#tab8-14) with [Table 8-13](#tab8-13): the time spent
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical
    in both reports, although the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method has taken over twice as long to complete because of the extra overhead
    of copying the instances of the larger <samp class="SANS_TheSansMonoCd_W5Regular_11">IntPlus3x16</samp>
    type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in
    both tests is performing the same operation, so the increase in time must be entirely
    due to the cost of copying instances.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighing Object Construction
    Costs</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cost of copying a large struct is not the only aspect to consider when using
    a type with several fields. For one thing, equality comparisons will usually take
    every field or property into account, making those comparisons more costly than
    for a type with only one or two fields. Initializing an instance of a type with
    several fields also comes with a cost.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> types in [Listing 8-18](#list8-18)
    are the positional record struct equivalents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> structs we defined
    earlier in [Listing 8-7](#list8-7). Because they’re record struct types, the compiler
    generates all the equality comparisons, making them much simpler to define than
    their struct counterparts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Defining Product
    and Purchase as record structs</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp>
    method shown in [Listing 8-19](#list8-19) to create a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances and record the performance. We return here to profiling a release build
    so that the results account for any optimizations afforded by the JIT (or AOT)
    compiler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Creating a sequence
    of randomly generated objects</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareSequences</samp> method
    follows a pattern similar to that we’ve used previously to create a sequence and
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> to
    compare the elements. For the purposes of making the performance report clear,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> as a
    method group argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    expression. That way, we can measure its performance directly, without introducing
    any overhead by using a lambda expression—something we’ll return to in “How Common
    Idioms and Practices Affect Performance” on [page 279](#sec23). [Table 8-15](#tab8-15)
    shows the profiler report for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-15:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    <samp class="SANS_Futura_Std_Book_11">Sequence</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">29.4% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">294</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.45% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.03% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: While the nested constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type increases the time taken to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects, the majority of the time is spent within the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>, suggesting that initializing
    the instances and copying them around is the costlier factor. In particular, creating
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and then copying
    the instance to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    constructor is one copy we can avoid by making <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a reference type.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Type Performance</samp>
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we copy a reference variable, the object instance isn’t copied at all,
    making the copy inexpensive. Here we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    a sealed record instead of a read-only record struct:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Records using this positional syntax are immutable reference types by default.
    For the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type, the
    compiler inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Price</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    properties, meaning that one instance can be safely and efficiently referenced
    by several containing objects. Since none of the properties has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, there’s no risk of inadvertent changes being made via aliasing references.
    More pertinently for our test, once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance is created, only the reference to it needs to be passed to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> constructor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: For this test, we leave the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type as a record struct, since we’re trying to avoid having to copy its nested
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. However, using a
    reference type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    introduces other overhead, as we can see in the profiler report in [Table 8-16](#tab8-16)
    for creating 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-16:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    Report for Creating Reference Type Values</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">77.8% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1,409</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">34.9% [Garbage collection]</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">632</samp> |  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Product..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product..ctor(Int32,
    Decimal, String)</samp> |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.33% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    is significantly slower than in [Table 8-15](#tab8-15), with the main culprit
    being garbage collection. Changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to be a record rather than a record struct has put considerable pressure on the
    garbage collector, which takes time even if it can’t collect any objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that the common advice to use value types for objects that
    are short-lived is at least partly related to memory pressure and the cost of
    garbage collection. Value type instances, because they aren’t allocated on the
    heap, don’t incur those costs. Copying even huge object instances isn’t always
    the most significant expense, so changing large value types to be reference types
    to avoid copying can, as in this example, have a detrimental effect on a program’s
    overall performance.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We have other factors to consider. If, for instance, we expect many of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects in an application
    to have identical <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    values, we may benefit considerably by having all those <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances sharing the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance, making a reference type implementation much more attractive.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Benefits of Reference Equality</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp> method
    from [Listing 8-19](#list8-19) that we’ve been using to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    object for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    object. In [Listing 8-20](#list8-20), we change <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    so that rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    each time, we assign one of a small number of shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances to each new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    and therefore a reference type, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    will be shared by many <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Sharing references
    among objects</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a short list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances before creating any <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> reference
    is selected from this list according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    value used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>.
    Now that the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method isn’t creating any new <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instances, we’d expect it to run much more quickly, which the report in [Table
    8-17](#tab8-17) confirms.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-17:</samp> <samp class="SANS_Futura_Std_Book_11">Assigning
    Preallocated</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    <samp class="SANS_Futura_Std_Book_11">Objects</samp>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">17.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">86</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2.38% Purchase..ctor</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase..ctor(Product,
    DateTime, Int32)</samp> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.18% get_Item</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5.9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .get_Item(Int32)</samp> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: More significantly, comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances for equality will now be much faster because so many of them share a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance. The implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for record types
    includes the simple optimization of starting with an identity comparison of the
    two references. When two <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    variables that are being compared both refer to the same instance in memory, there’s
    no need to continue checking the individual fields, since they must be identical.
    [Table 8-18](#tab8-18) shows the report for comparing sequence elements for 10
    million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-18:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Shared References</samp>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">68.3% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">350</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">27.1% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">139</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11.7% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">48</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.52% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: If we run the same test by using a record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>—that
    is, assigning one of a few precreated instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    to each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>—we can compare
    the performance of sharing references versus copying each <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>.
    [Table 8-19](#tab8-19) shows the report for <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    for 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a record
    struct.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-19:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Copied Instances</samp>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">59.5% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">591</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">126</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9.01% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">89</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.22% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: Although the headline time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>
    method is almost identical in each case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    method using the record struct in [Table 8-19](#tab8-19) is considerably slower
    than for the record in [Table 8-18](#tab8-18). Record structs can’t take advantage
    of the simple reference identity optimization available to records, although many
    of the calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals</samp>
    will have been inlined by the JIT compiler. The result is that we see the extra
    cost of having to copy the record struct values and compare their fields in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>, rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals</samp>.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring the Compiler-Generated
    Equals Method</samp>
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The positional record struct syntax used in [Listing 8-18](#list8-18) for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    types makes their definition compact, but that comes with minor, although measurable,
    efficiency compromises. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for records and record structs is generated by the compiler,
    whether or not they use the positional syntax. While convenient, that’s not necessarily
    the most efficient implementation. When we’re working with many objects, it can
    be worth our while to write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for record and record struct types, in which case the compiler won’t generate
    one for us.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: You saw in [Chapter 5](chapter5.xhtml) that the compiler inserts code to obtain
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    object for each field. For example, [Listing 8-21](#list8-21) shows roughly the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method created by
    the compiler for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct in [Listing 8-18](#list8-18).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: A record struct’s
    Equals method</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The real names of the backing fields assigned by the compiler are invalid in
    regular C#, so there’s no chance they could clash with any of our own identifiers;
    the names used here merely illustrate the idea. Despite using the backing fields
    directly rather than accessing the properties to perform the comparisons, obtaining
    the default <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp>
    implementation for each field on *every call* to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    could impair efficiency. [Table 8-20](#tab8-20) shows the profiler output when
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method
    to compare two lists of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    record struct objects.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-20:</samp> <samp class="SANS_Futura_Std_Book_11">Comparing
    Sequences with Record Struct Instances</samp>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">55.7% SequenceEqual</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">558</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">13.7% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">138</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10.2% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">102</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .GenericEqualityComparer`1.Equals(T, T)</samp> |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3.58% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.80% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.Equals(Decimal)</samp>
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Int32.Equals(Int32)</samp>
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.60% get_Default</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic
    .EqualityComparer`1.get_Default()</samp> |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: While the JIT compiler may inline some or all of the uses of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Default</samp>
    property and the calls to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, there’s no guarantee that it will be able to do so. As we did earlier
    when replacing property accesses with fields, we can define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to directly compare the values without needing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer<
    T ></samp>. However, we can’t access the compiler-generated backing fields for
    the properties generated for a positional record struct. Instead, in [Listing
    8-22](#list8-22) we use a simple record struct for <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>,
    where we define our own private fields and a constructor to initialize them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Constructing
    a private field for the Purchase struct</samp>'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We also add our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to directly compare the fields we’ve defined. This custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    replaces the implementation that the compiler would have introduced had we not
    defined our own. We’d also need to add properties to expose the field values,
    although neither that nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type, which changes in a similar way, is shown here. Rerunning the code to compare
    two sequences of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    items produces the report shown in [Table 8-21](#tab8-21).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-21:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Comparison Using Customized</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% SequenceEqual</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">440</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .SequenceEqual(IEnumerable, IEnumerable)</samp> |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12.3% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">54</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Equals(Purchase)</samp>
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8.18% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">36</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Product.Equals(Product)</samp>
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.36% Equals</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.DateTime.Equals(DateTime)</samp>
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: By providing our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, we’ve improved the performance of <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp>
    by around 20 percent compared with the results in [Table 8-20](#tab8-20), partly
    because our implementation may be giving the JIT compiler more effective opportunities
    for inlining code. Comparing larger sequences produces similar results, so if
    we’re particularly sensitive to performance and frequently compare many items,
    this kind of optimization may be beneficial.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The performance improvement we see here occurs primarily because <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a relatively complex type. A much simpler positional record struct—for example,
    one with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field—most
    likely wouldn’t benefit from the optimizations we made in <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>. The principal
    benefit of the positional record syntax is its simplicity, which makes it clear
    to any reader what the type represents. We sacrificed that simplicity for a small
    gain in raw performance, an improvement that was visible only with the help of
    a profiler. This example highlights the importance of measuring performance before
    trying to hand-optimize our code by second-guessing the compiler.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Common Idioms and Practices Affect
    Performance</samp>
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some common practices in C# draw undue criticism regarding performance. It’s
    natural and common to believe that a higher level of abstraction in source code
    comes with a cost in performance, and that’s true to some extent: C# is a *high-level*
    programming language, and our programs are ultimately translated to native machine
    code over multiple steps. We could handcraft our own machine code to perform the
    same task, but C# code is more portable, more easily maintained, considerably
    less error-prone, and much easier to read and write than machine code. Those benefits
    usually far outweigh any cost in performance.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: It’s not, however, universally true that high-level code results in performance
    penalties. In this section, we’ll investigate looping and pattern matching, two
    common C# features that enable us to succinctly express complex ideas in C# while
    providing performance comparable or even superior to their lower-level counterparts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Looping and Iteration</samp>
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve used LINQ in its *fluent syntax* form several times for
    the purposes of creating sequences of objects. LINQ, which has been part of C#
    for many years, will be recognizable to most programmers with more than a passing
    familiarity for the language and its idioms. [Listing 8-23](#list8-23) shows an
    example of using the fluent syntax to create a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: LINQ fluent syntax</samp>'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: LINQ has an alternative *query syntax* that some C# programmers find more agreeable.
    [Listing 8-24](#list8-24) shows the equivalent query syntax for creating the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">items</samp> sequence in [Listing 8-23](#list8-23).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: LINQ query syntax</samp>'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler generates identical CIL for both [Listings 8-23](#list8-23) and
    [8-24](#list8-24), so the choice between them is primarily driven by which we
    find clearer to read. One optimization is possible, although it can be applied
    only to the fluent version: avoiding the lambda as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. That lambda needs to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable so the compiler will generate a closure object, which results in an extra
    level of indirection to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. To avoid the closure, we can instead pass <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    as a method group argument, as shown in [Listing 8-25](#list8-25).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: Optimizing LINQ
    by using a method group</samp>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: To compare the efficiency of each approach, first we profile the version from
    [Listing 8-23](#list8-23), which uses a lambda. [Table 8-22](#tab8-22) shows the
    report for creating a list of 10 million items.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-22:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Lambda</samp>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">98.1% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">415</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable
    .ToList(IEnumerable)</samp> |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">36.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">152</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">31.3%</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><
    Closure>b__3_0</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">132</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><>c.< Closure>b__3_0(Int32)</samp>
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">31.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">132</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: The identifier name <samp class="SANS_TheSansMonoCd_W5Regular_11"><> c</samp>
    is the closure object the compiler generates to capture the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    variable, and one example of the compiler introducing names that would be illegal
    in our own code. The closure has an instance method, <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp>, which in turn calls our <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method makes two appearances in this report—both inside and outside the closure
    method—as a result of the JIT compiler inlining some calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The report in [Table 8-23](#tab8-23) shows the performance when using the method
    group approach to create 10 million items.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-23:</samp> <samp class="SANS_Futura_Std_Book_11">Performance
    of Creating a Sequence Using LINQ with a Method Group</samp>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">430</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable.ToList(IEnumerable)</samp>
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">71.9% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">309</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: Somewhat counterintuitively, the version with the closure object was just slightly
    faster than that with the method group. We shouldn’t read too much into that,
    as the difference is well within the margin for error when comparing runs. However,
    it does tell us that no matter the absolute difference, using a lambda carries
    no significant performance penalty.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The closure object representing the lambda is created only once for the whole
    expression, not for every element produced for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method. Even though the closure object represents an extra level of indirection
    for each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>,
    the JIT compiler inlines many of the calls to the closure’s <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    Closure>b__3_0</samp> method and either calls <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    directly or inlines its contents too.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We could create a similar sequence in a few other ways. Let’s investigate two
    common approaches to see how their performance compares with using LINQ.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterator Approach</samp>
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Iterators* are a fundamental part of C# and underpin other higher-level features,
    including LINQ. In fact, LINQ has become so ubiquitous in modern C# that it can
    be easy to forget that it’s based on two system interfaces: the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface, which is an abstract view of a sequence of elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp> interface, which represents an iterator that can get each element of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> one at
    a time. The basic mechanics are that the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> interface has a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">GetEnumerator</samp>
    that returns an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator<
    T ></samp>.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Both interfaces are largely hidden in modern code, although <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> remains important as the protocol for types that represent sequences
    and as the home of the extension methods, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>, that make up most
    of the LINQ system.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    also forms the basis for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, which is one way of enumerating the elements of a sequence that implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>. In [Listing
    8-26](#list8-26), we write our own simple <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method, which allows us to record its performance for comparison with the LINQ
    equivalents. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> to populate a list
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> objects and therefore
    depends on the iterator provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>
    method.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: Populating a
    list using foreach</samp>'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Comparing our <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp> method
    with the LINQ version in [Listing 8-23](#list8-23), the first thing to notice
    is that we need to declare the target list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects before the loop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop obtains an <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< int></samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Enumerable.Range</samp>, and
    the body of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> block
    is run for each element in the iterator. We can see the basic mechanics when we
    look at the profiler’s report for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    method in [Table 8-24](#tab8-24).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-24:</samp> <samp class="SANS_Futura_Std_Book_11">Profiling
    the Iterator Approach</samp>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">638</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">41.2% AddWithResize</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">263</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Collections.Generic.List`1
    .AddWithResize(T)</samp> |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">38.1% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">243</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">6.1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0.95% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: This profile report shows the workings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    construct; the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Current</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MoveNext</samp> methods belong
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerator< T ></samp> interface
    and, as their names suggest, allow us to obtain the current element and move the
    iterator to the next item in the sequence.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'This report also shows that our handcrafted <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>
    is considerably slower than the LINQ version reported in [Table 8-22](#tab8-22),
    but we haven’t made optimal use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> facilities. Since we know in advance the number of items we need,
    we can avoid most of the expense of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddWithResize</samp>
    method and specify the list’s capacity in the constructor call like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By explicitly requesting a capacity, we allocate enough memory for <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    items before adding new elements so that the list won’t need resizing when it
    runs out of space. If we rerun our profile test, as [Table 8-25](#tab8-25) shows,
    it’s much more in line with the previous tests.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-25:</samp> <samp class="SANS_Futura_Std_Book_11">Preallocating
    a List’s Capacity</samp>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">426</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">63.0% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">268</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4.28% MoveNext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+RangeIterator
    .MoveNext()</samp> |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1.41% get_Current</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6.0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Linq.Enumerable+Iterator`1
    .get_Current()</samp> |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: 'Our tests demonstrate that using LINQ, at least for the reasonably simple task
    of generating a sequence of elements, is at least as efficient as using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. We can try one other
    approach, however: the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Loop Approach</samp>
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our method of creating a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects is based on creating a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values and translating them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method into a new sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects. [Listing 8-27](#list8-27) shows how we achieve the same result with a
    basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, which doesn’t
    rely on iterators and merely runs the body of the loop the number of times specified
    in the loop condition.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: Using a simple
    for loop</samp>'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: As we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    loop, we must create the target <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Purchase></samp> before entering the loop, and we use the constructor to set its
    capacity. In the loop’s body, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase</samp>
    method to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    as we have previously. [Table 8-26](#tab8-26) shows the profiler report for creating
    a list of 10 million <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    objects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-26:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Direct</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_Futura_Std_Book_11">Loop
    Performance</samp>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Method</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Time
    (ms)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signature</samp> |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">100% ToList</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">417</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList(Int32)</samp>
    |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">67.3% MakePurchase</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">281</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MakePurchase(Int32)</samp>
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5.70% op_Implicit</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">24</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Decimal.op_Implicit(Int32)</samp>
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: 'Once again, there’s no significant difference between the performance of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop approach and that
    of the other approaches we’ve tried. The main difference between using LINQ and
    using either the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is one of style:
    the LINQ code is more direct and allows us to express our intent declaratively,
    whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loops are more procedural.
    The LINQ expression allows us to focus on the outcome we require, whereas both
    looping approaches focus on the steps or instructions to follow.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pattern Matching
    and Selection</samp>
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common benefit of a declarative rather than procedural style is that we
    write less code to achieve the same result. While this saves on the amount of
    typing we do, that is just a side effect. The real benefit comes from having less
    syntax for a human reader to comprehend. Replacing explicit loops with LINQ-style
    functional expressions is one example. Many of the LINQ expressions are based
    on loops internally, but the loop constructs themselves are hidden from user code.
    Manually iterating sequences with loops and explicit conditions can be prone to
    errors, and complex loop constructs are generally harder for a human reader to
    follow than a call to a method like <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ToList</samp>.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common application of declarative techniques is in selection code:
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements with pattern-matching expressions.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Consider the constructor in [Listing 8-28](#list8-28), which validates the parameter
    value by matching it against the rules specified by some patterns.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: Pattern matching
    for validation</samp>'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> constructor
    throws an exception if the argument given is <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>
    and also prohibits values that are less than <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroKelvin</samp>
    or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">PositiveInfinity</samp>.
    Values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">celsius</samp> parameter
    that don’t match either of those rules are assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field by the discard pattern, which is the final pattern in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Compare [Listing 8-28](#list8-28) with [Listing 8-29](#list8-29), which achieves
    exactly the same outcome but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>
    statements to test the incoming parameter value.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-29: Chaining if and
    else for validation</samp>'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: We could make this code less syntax-heavy by removing the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statements and allowing the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    blocks to fall through if the value doesn’t meet the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    condition. While doing so would make the code shorter, it’s more error-prone if
    new conditions are added.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative is to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, as shown in [Listing 8-30](#list8-30).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-30: Using a switch
    statement for validation</samp>'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: This version is closer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression in [Listing 8-28](#list8-28), and the two forms of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    can be easily confused. The principal difference is that here we assign the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> field as part of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">default</samp> leg, whereas in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field is assigned the value of the whole expression.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: In a departure from the rest of this chapter, we don’t need to run a performance
    profile to compare [Listings 8-28](#list8-28) through [8-30](#list8-30) because
    the compiler produces almost identical code for each—broadly, the same code as
    shown in [Listing 8-29](#list8-29). The compiler may change the order of the conditions
    in the CIL, but that doesn’t change the logic in any way.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We do not consider it as good engineering practice to consume a resource lavishly
    just because it happens to be cheap.*'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Niklaus Wirth, *Project Oberon: The Design of an Operating System, a Compiler,
    and a Computer*'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code optimized by hand is often harder for a human reader to follow, usually
    because it frequently involves replacing simple idioms, such as loops and pattern
    matching, with lower-level constructs. When a program runs more slowly than we
    think it should, it can be tempting to dive straight in and change the parts of
    the code we suspect are bottlenecks. Programmers’ optimization instincts are,
    however, notoriously unreliable. We’re likely to make our code more difficult
    to read while failing to improve performance in any meaningful way.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing code by hand is almost always an exercise in exchanging clarity and
    simplicity for performance. We can judge whether this is a reasonable trade only
    by measuring the performance before and after the change. Even when we improve
    performance in a section of code, we must still decide whether we’ve made the
    code less clear and, if so, whether the change is justified. We must also be certain
    that our optimizations haven’t changed the program’s behavior in any way. Slow,
    correct code is always preferable to incorrect code, however good its performance.
    That’s not to say that good enough can’t be correct—frequently a compromise is
    necessary between performance and accuracy or precision—but we need to know the
    point at which inaccurate really does mean incorrect.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The use of well-known idioms and patterns helps human readers easily understand
    code. Correspondingly, when we depart from those common designs, we make our code
    harder to follow. Therefore, we must be selective in applying optimizations to
    the areas of code that will bring the greatest benefits.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    isn’t difficult for the vast majority of types, but it adds an implementation
    detail that represents extra cognitive overhead for anyone who needs to *understand*
    our code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Using records to represent value-like types removes much of that added complexity
    because the compiler generates the correct implementations for us. However, even
    accepting that default behavior won’t necessarily yield the most efficient code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Careful code optimization, supported by evidence from a profiler, can yield
    better performance in both speed *and* memory use. Modern computers are fast and
    usually have more than enough memory, but that doesn’t mean we should waste either
    resource.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
