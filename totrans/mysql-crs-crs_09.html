<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="85" id="Page_85"/><a class="XrefDestination" id="7"/><span class="XrefDestination" id="xref-503007c07-001"/>7</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="Comparingvalues"/><span class="XrefDestination" id="xref-503007c07-002"/>Comparing Values</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">This chapter discusses comparing values in MySQL. You’ll practice checking whether values are equal, whether one value is greater or less than another value, and whether a value falls within a specific range or matches a pattern. You’ll also learn how to check that at least one condition in your queries is met.</p>
<p>Comparing values can be useful in a variety of scenarios. For example, you might want to check that an employee worked 40 or more hours, that a flight’s status is not canceled, or that the average temperature of a vacation destination is between 70 and 95 degrees Fahrenheit.</p>
<h2 id="h1-503007c07-0001"><a class="XrefDestination" id="ComparisonOperators"/><span class="XrefDestination" id="xref-503007c07-003"/>Comparison Operators</h2>
<p class="BodyFirst">You can use MySQL’s comparison operators, shown in <a href="#table7-1" id="tableanchor7-1">Table 7-1</a>, to compare values in your queries.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-1">Table 7-1</a>: MySQL Comparison Operators<span epub:type="pagebreak" title="86" id="Page_86"/></p></figcaption>
<table id="table-503007c07-0001" border="1">
<thead>
<tr>
<td><b>Symbol or keyword(s)</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>Equal</td>
</tr>
<tr>
<td><code>!=, &lt;&gt;</code></td>
<td>Not equal</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal to</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal to</td>
</tr>
<tr>
<td><code>is null</code></td>
<td>A null value</td>
</tr>
<tr>
<td><code>is not null</code></td>
<td>A non-null value</td>
</tr>
<tr>
<td><code>in</code></td>
<td>Matches a value in a list</td>
</tr>
<tr>
<td><code>not in</code></td>
<td>Doesn’t match a value in a list</td>
</tr>
<tr>
<td><code>between</code></td>
<td>Within a range</td>
</tr>
<tr>
<td><code>not between</code></td>
<td>Not within a range</td>
</tr>
<tr>
<td><code>like</code></td>
<td>Matches a pattern</td>
</tr>
<tr>
<td><code>not like</code></td>
<td>Does not match a pattern</td>
</tr>
</tbody>
</table>
</figure>
<p>These operators let you compare values in a database to other values. You can choose to select data if it meets the criteria you define using these comparison operators. Let’s discuss them in depth, using various databases as examples.</p>
<h3 id="h2-503007c07-0001"><a class="XrefDestination" id="Equal"/><span class="XrefDestination" id="xref-503007c07-004"/>Equal</h3>
<p class="BodyFirst">The equal operator, introduced in <a class="xref" href="c05.xhtml">Chapter 5</a>, lets you check that values are equal to each other to achieve specific results. For example, here you use <code>=</code> with the <code>wine</code> database table from <a class="xref" href="c06.xhtml">Chapter 6</a>:</p>
<pre><code>select  *
from    country
where   <b>country_id = 3</b>;</code></pre>
<p>This query selects all countries from the <code>country</code> table that have a <code>country_id</code> equal to <code>3</code>.</p>
<p>In the following query, you’re using <code>=</code> with a string, rather than a number:</p>
<pre><code>select  *
from    wine_type
where   <b>wine_type_name = 'Merlot'</b>;</code></pre>
<p>This query selects all wines from the <code>wine_type</code> table with the name Merlot—that is, a <code>wine_type_name</code> equal to <code>Merlot</code>.</p>
<p><span epub:type="pagebreak" title="87" id="Page_87"/>The following query is similar to what you saw in <a class="xref" href="c05.xhtml">Chapter 5</a> when you were learning how to join two tables. Here you’re using <code>=</code> to compare values that come from two tables with a common column name:</p>
<pre><code>select  c.country_name
from    country c
join    region r
  on    <b>c.country_id = r.country_id</b>;</code></pre>
<p>This query joins all equal values from the <code>region</code> and <code>country</code> tables’ <code>country_id</code> columns.</p>
<p>In each of these examples, the <code>=</code> syntax checks that the value on the left of the operator is the same as the value on the right of it. You can also use <code>=</code> with a subquery that returns one row:</p>
<pre><code>select *
from   region
where  <b>country_id =</b>
<b>(</b>
<b>    select country_id</b>
<b>    from   country</b>
<b>    where  country_name = 'USA'</b>
<b>);</b></code></pre>
<p>Using <code>=</code> in this way, you’re checking for rows in the outer query where the <code>country_id</code> column in the <code>region</code> table matches the results of an entire subquery.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Regardless of the comparison operator that you use, you should compare values that have the same data type. For example, you should avoid comparing an <code>int</code> with a <code>varchar</code> in your queries. In some cases, MySQL can perform automatic conversions, but this is not best practice.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-503007c07-0002"><a class="XrefDestination" id="NotEqual"/><span class="XrefDestination" id="xref-503007c07-005"/>Not Equal</h3>
<p class="BodyFirst">Not equal is expressed by the <code>&lt;&gt;</code> or <code>!=</code> symbols, where the <code>&lt;</code> symbol is <em>less than</em> and the <code>&gt;</code> symbol is <em>greater than </em>(so <code>&lt;&gt;</code> means less than or greater than), and the <code>!</code> symbol means<em> not </em>(so <code>!=</code> means not equal). The <code>!=</code> and <code>&lt;&gt;</code> operators do the same thing, so it doesn’t matter which syntax you use.</p>
<p>The not equal operator is useful for excluding certain data from the results of your queries. For example, maybe you’re a banjo player looking for fellow musicians to start a band. Since you play banjo, you can eliminate it from the list of instruments you want to see:</p>
<pre><code>select  *
from    musical_instrument
where   <b>instrument != 'banjo'</b>;</code></pre>
<p>Here you’ve used the <code>not equal</code> operator on the <code>musical_instrument</code> table to exclude the banjo from the list of instruments returned.</p>
<p><span epub:type="pagebreak" title="88" id="Page_88"/>Say you’re planning a wedding and you have a prior commitment on February 11, 2024, so you need to exclude that date:</p>
<pre><code>select  *
from    possible_wedding_date
where   <b>wedding_date &lt;&gt; '2024-02-11'</b>;</code></pre>
<p>Now you’ve excluded 2/11/2024 from a list of potential wedding dates in your <code>possible_wedding_date</code> table.</p>
<h3 id="h2-503007c07-0003"><a class="XrefDestination" id="GreaterThan"/><span class="XrefDestination" id="xref-503007c07-006"/>Greater Than</h3>
<p class="BodyFirst">The greater than operator checks that the value on the left is greater than the value on the right. It is expressed using the <code>&gt;</code> symbol. Say you’re looking for jobs that have a <code>salary</code> greater than $100,000 and a <code>start_date</code> after 1/20/2024. You can select jobs that match these requirements from the <code>job</code> table using the following query:</p>
<pre><code>select  *
from    job
where   <b>salary &gt; 100000</b>
and     <b>start_date &gt; '2024-01-20'</b>;</code></pre>
<p>In this query, only the jobs that meet both conditions will be returned.</p>
<h3 id="h2-503007c07-0004"><a class="XrefDestination" id="GreaterThanorEqualTo"/><span class="XrefDestination" id="xref-503007c07-007"/>Greater Than or Equal To</h3>
<p class="BodyFirst">Greater than or equal to is expressed using the <code>&gt;=</code> symbol. For example, you can edit your previous query to select all jobs where the <code>salary</code> is $100,000 or higher and that have a <code>start_date</code> of 1/20/2024 or later:</p>
<pre><code>select  *
from    job
where   <b>salary &gt;= 100000</b>
and     <b>start_date &gt;= '2024-01-20'</b>;</code></pre>
<p>The difference between <code>&gt;</code> and <code>&gt;=</code> is that <code>&gt;=</code> includes the value listed in its results. In the previous examples, a job with a <code>salary</code> of <em>exactly</em> $100,000 will be returned by <code>&gt;=</code> but not by <code>&gt;</code>.</p>
<h3 id="h2-503007c07-0005"><a class="XrefDestination" id="LessThan"/><span class="XrefDestination" id="xref-503007c07-008"/>Less Than</h3>
<p class="BodyFirst">Less than is expressed using the <code>&lt;</code> symbol. For example, to view all games starting before 10 PM, you can perform the following query:</p>
<pre><code>select *
from   team_schedule
where  <b>game_time &lt; '22:00'</b>;</code></pre>
<p>In MySQL, time is expressed in military format, which operates on a 24-hour clock.</p>
<h3 id="h2-503007c07-0006"><span epub:type="pagebreak" title="89" id="Page_89"/><a class="XrefDestination" id="LessThanorEqualTo"/><span class="XrefDestination" id="xref-503007c07-009"/>Less Than or Equal To</h3>
<p class="BodyFirst"><em>Less than or equal to</em> is expressed using the <code>&lt;=</code> symbol. You can expand the previous query to select all rows where the <code>game_time</code> is 10 PM or earlier:</p>
<pre><code>select *
from   team_schedule
where  <b>game_time &lt;= '22:00'</b>;</code></pre>
<p>If the <code>game_time</code> is exactly 22:00 (10 PM), a row will be returned when you use <code>&lt;=</code> but not when you use <code>&lt;</code>.</p>
<h3 id="h2-503007c07-0007"><a class="XrefDestination" id="isnull"/><span class="XrefDestination" id="xref-503007c07-010"/>is null</h3>
<p class="BodyFirst">As discussed in Chapters 2 and 3<span class="xref" itemid="xref_target_Chapters2and3"/>, <code>null</code> is a special value indicating that data is not applicable or not available. The <code>is null</code> syntax allows you to specify that you want only null values to be returned from a table. For example, say you want to query the <code>employee</code> table to see a list of employees who have not retired or set a retirement date:</p>
<pre><code>select  *
from    employee
where   <b>retirement_date</b> <b>is null</b>;</code></pre>
<p>Now only rows with a <code>retirement_date</code> of <code>null</code> are returned:</p>
<pre><code>emp_name   retirement_date
--------   ---------------
Nancy      null
Chuck      null
Mitch      null</code></pre>
<p>It’s only possible to check null values with the <code>is null</code> comparison operator. For example, using <code>= null</code> won’t work:</p>
<pre><code>select *
from   employee
where  retirement_date = null;</code></pre>
<p>Even though there are null values in the table, this syntax won’t return any rows. In this scenario, MySQL doesn’t throw an error, so you might not realize that the wrong data is being returned.</p>
<h3 id="h2-503007c07-0008"><a class="XrefDestination" id="isnotnull"/><span class="XrefDestination" id="xref-503007c07-011"/>is not null</h3>
<p class="BodyFirst">You can use <code>is not null</code> to check for values that are <em>not</em> null. Try reversing the logic of the previous example to check for employees who have retired or set a retirement date:</p>
<pre><code>select *
from   employee
where  <b>retirement_date</b> <b>is not null</b>;</code></pre>
<p><span epub:type="pagebreak" title="90" id="Page_90"/>Now, the query returns rows with a <code>retirement_date</code> that is not <code>null</code>:</p>
<pre><code>emp_name   retirement_date
--------   ---------------
Alfred     2034-01-08
Latasha    2029-11-17</code></pre>
<p>As with <code>is null</code>, you have to use the <code>is not null</code> syntax for this type of query. Using other syntax, like <code>!= null</code> or <code>&lt;&gt; null</code>, will not produce the correct results:</p>
<pre><code>select *
from   employee
where  retirement_date != null;</code></pre>
<p>As you saw earlier with <code>= null</code>, MySQL won’t return any rows when you try to use the <code>!= null</code> syntax, and won’t alert you with an error.</p>
<h3 id="h2-503007c07-0009"><a class="XrefDestination" id="in"/><span class="XrefDestination" id="xref-503007c07-012"/>in</h3>
<p class="BodyFirst">You can use the <code>in</code> keyword to specify a list of multiple values you want your query to return. For example, let’s revisit the <code>wine</code> database to return specific wines from the <code>wine_type</code> table:</p>
<pre><code>select  *
from    wine_type
where   <b>wine_type_name in ('Chardonnay', 'Riesling')</b>;</code></pre>
<p>This will return rows where the <code>wine_type_name</code> is Chardonnay or Riesling.</p>
<p>You can also use <code>in</code> with a subquery to select a list of wine types that are in another table:</p>
<pre><code>select  *
from    wine_type
where   <b>wine_type_name in</b>
<b>        (</b>
<b>        select  wine_type_name</b>
<b>        from    cheap_wine</b>
<b>        )</b>;</code></pre>
<p>Instead of providing a hardcoded list of wine types to return in your results, here you’re selecting all of the wine types from the <code>cheap_wine</code> table.</p>
<h3 id="h2-503007c07-0010"><a class="XrefDestination" id="notin"/><span class="XrefDestination" id="xref-503007c07-013"/>not in</h3>
<p class="BodyFirst">To reverse the previous example’s logic and exclude certain wine types, you can use <code>not in</code>:</p>
<pre><code>select  *
from    wine_type
where   <b>wine_type_name not in ('Chardonnay', 'Riesling')</b>;</code></pre>
<p><span epub:type="pagebreak" title="91" id="Page_91"/>This returns all rows where the <code>wine_type_name</code> is not Chardonnay or Riesling.</p>
<p>To select wines that are not from the <code>cheap_wine</code> table, you can use <code>not in</code> within a subquery as follows:</p>
<pre><code>select  *
from    wine_type
where   <b>wine_type_name not in</b>
<b>        (</b>
<b>        select  wine_type_name</b>
<b>        from    cheap_wine</b>
<b>        )</b>;</code></pre>
<p>This query excludes wine types from the <code>cheap_wine</code> table.</p>
<h3 id="h2-503007c07-0011"><a class="XrefDestination" id="between"/><span class="XrefDestination" id="xref-503007c07-014"/>between</h3>
<p class="BodyFirst">You can use the <code>between</code> operator to check that a value is within a specified range. For example, to list the millennials in a <code>customer</code> table, search for people who were born between 1981 and 1996:</p>
<pre><code>select  *
from    customer
where   <b>birthyear between 1981 and 1996</b>;</code></pre>
<p>The <code>between</code> keyword is <em>inclusive</em>. This means it checks for every <code>birthyear</code> within the range, <em>including</em> the years 1981 and 1996.</p>
<h3 id="h2-503007c07-0012"><a class="XrefDestination" id="notbetween"/><span class="XrefDestination" id="xref-503007c07-015"/>not between</h3>
<p class="BodyFirst">You can check that a value is not within a range by using the <code>not</code> <code>between</code> operator. Use the same table from the previous example to find customers who are <em>not</em> millennials:</p>
<pre><code>select  *
from    customer
where   <b>birthyear not between 1981 and 1996</b>;</code></pre>
<p>The <code>not between</code> operator returns the opposite list of customers that <code>between</code> did, and is <em>exclusive</em>. Customers born in 1981 or 1996 will be <em>excluded</em> by this query since they are part of the <code>between 1981 and 1996</code> group.</p>
<h3 id="h2-503007c07-0013"><a class="XrefDestination" id="like"/><span class="XrefDestination" id="xref-503007c07-016"/>like</h3>
<p class="BodyFirst">The <code>like</code> operator allows you to check if a string matches some pattern. For example, you can use <code>like</code> to find books from No Starch Press by checking if a book’s ISBN contains the No Starch publisher code, 59327.</p>
<p>To specify the pattern to match, you use one of two wildcard characters with the <code>like</code> operator: percent (<code>%</code>) or underscore (<code>_</code>).</p>
<h4 id="h3-503007c07-0001"><span epub:type="pagebreak" title="92" id="Page_92"/><a class="XrefDestination" id="The%Character"/><span class="XrefDestination" id="xref-503007c07-017"/>The % Character</h4>
<p class="BodyFirst">The percent wildcard character matches any number of characters. For example, to return a list of billionaires whose last name starts with the letter <em>M</em>, you can use the <code>%</code> wildcard character along with <code>like</code>:</p>
<pre><code>select  *
from    billionaire
where   <b>last_name</b> <b>like 'M%'</b>;</code></pre>
<p>Your query will find billionaires whose last name starts with an <em>M</em> followed by zero or more other characters. This means that <code>like 'M%'</code> would match only the letter <em>M</em> with no characters after it, or <em>M </em>followed by a few characters, like <code>Musk</code>, or <em>M</em> followed by many characters, like <code>Melnichenko</code>. The results of your query might look like this:</p>
<pre><code>first_name   last_name
----------   ---------
Elon         Musk
Jacqueline   Mars
John         Mars
Andrey       Melnichenko</code></pre>
<p>You can use two <code>%</code> characters to find a character located anywhere in the string, whether at the beginning, in the middle, or at the end. For example, the following query looks for billionaires whose last names contain the letter <em>e</em>:</p>
<pre><code>select  *
from    billionaire
where   <b>last_name like '%e%'</b>;</code></pre>
<p>The results might look like this:</p>
<pre><code>first_name   last_name
----------   ---------
Jeff         Bezos
Bill         Gates
Mark         Zuckerberg
Andrey       Melnichenko</code></pre>
<p>While the syntax <code>last_name like '%e%'</code> is handy, it can cause your query to run slower than normal. That’s because when you use the <code>%</code> wildcard at the beginning of a search pattern, MySQL can’t take advantage of any indexes on the <code>last_name</code> column. (Remember, indexes help MySQL optimize your queries; for a refresher, see the section <span class="xref" itemid="xref_target_“Indexes”">“Indexes”</span> in <a class="xref" href="c02.xhtml">Chapter 2</a>.)</p>
<h4 id="h3-503007c07-0002"><a class="XrefDestination" id="The_Character"/><span class="XrefDestination" id="xref-503007c07-018"/>The _ Character</h4>
<p class="BodyFirst">The underscore wildcard character matches any character. For example, say you need to find a contact and you can’t remember if her name was Jan or Jen. You might write a query to select names that start with <em>J</em>, followed by the wildcard character, followed by <em>n</em>.</p>
<p><span epub:type="pagebreak" title="93" id="Page_93"/>Here you use the underscore wildcard to return a list of three-letter terms that end in <em>at</em>:</p>
<pre><code>select  *
from    three_letter_term
where   <b>term</b> <b>like '_at';</b></code></pre>
<p>The results might look like this:</p>
<pre><code>term
----
cat
hat
bat</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxListNumberCustom1"><b>7-1.</b>	In the <code>band</code> database, the <code>musician</code> table contains the following data:</p>
<pre><code>musician_name     phone         musician_type
----------------  ------------  -------------
Diva DeLuca       615-758-7836  Opera Singer
Skeeter Sullivan  629-209-2332  Bluegrass Singer
Tex Macaroni      915-789-1721  Country Singer
Bronzy Bohannon   212-211-1216  Sax Player</code></pre>
<p class="ListBody">Write a query that finds all the singers from Nashville, Tennessee. Nashville has two area codes, <code>615</code> and <code>629</code>, so you’ll want to find phone numbers that start with those numbers. You can find singers by finding the text <code>Singer</code> somewhere in the <code>musician_type</code> column.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-503007c07-0014"><a class="XrefDestination" id="notlike"/><span class="XrefDestination" id="xref-503007c07-020"/>not like</h3>
<p class="BodyFirst">The<code> not like</code> operator can be used to find strings that do <em>not</em> match some pattern. It also uses the <code>%</code> and <code>_</code> wildcard characters. For example, to reverse your logic for the <code>like</code> example, enter the following:</p>
<pre><code>select  *
from    three_letter_term
where   <b>term</b> <b>not like '_at'</b>;</code></pre>
<p>The results are words in the <code>three_letter_term</code> table that do not end in <em>at</em>:</p>
<pre><code>term
----
dog
egg
ape</code></pre>
<p><span epub:type="pagebreak" title="94" id="Page_94"/>Similarly, you can find billionaires whose last names do not start with the letter <em>M </em>using this query:</p>
<pre><code>select  *
from    billionaire
where   <b>last_name</b> <b>not like 'M%'</b>;</code></pre>
<p>The results might look like this:</p>
<pre><code>first_name   last_name
----------   ---------
Jeff         Bezos
Bill         Gates
Mark         Zuckerberg</code></pre>
<h3 id="h2-503007c07-0015"><a class="XrefDestination" id="exists"/><span class="XrefDestination" id="xref-503007c07-021"/>exists</h3>
<p class="BodyFirst">The <code>exists</code> operator checks to see if a subquery returns at least one row. Here you go back to the <code>customer</code> table in the <code>not between</code> example and use <code>exists</code> to see whether the table has at least one millennial:</p>
<pre><code>select 'There is at least one millennial in this table'
where <b>exists</b>
<b>(</b>
<b>    select  *</b>
<b>    from    customer</b>
<b>    where   birthyear between 1981 and 1996</b>
<b>)</b>;</code></pre>
<p>There are millennials in the <code>customer</code> table, so your result is:</p>
<pre><code>There is at least one millennial in this table</code></pre>
<p>If there had been no customers born between 1981 and 1996, your query wouldn’t have returned any rows, and the text <code>There is at least one millennial in this table</code> would not have been shown.</p>
<p>You might see the same query written using <code>select 1</code> instead of <code>select *</code> in the subquery:</p>
<pre><code>select 'There is at least one millennial in this table'
where exists
(
    select  1
    from    customer
    where   birthyear between 1981 and 1996
);</code></pre>
<p>In this query, it doesn’t matter if you select <code>*</code> or <code>1</code> because you’re looking for at least one customer that matches your description. All you really care about is that the inner query returned <em>something</em>.</p>
<h2 id="h1-503007c07-0002"><span epub:type="pagebreak" title="95" id="Page_95"/><a class="XrefDestination" id="CheckingBooleans"/><span class="XrefDestination" id="xref-503007c07-022"/>Checking Booleans</h2>
<p class="BodyFirst">In <a class="xref" href="c04.xhtml">Chapter 4</a>, you learned that booleans can have one of two values: <code>true</code> or <code>false</code>. You can use special syntax, <code>is true</code> or <code>is false</code>, to return only results with one value or the other. In this example, you return a list of employed bachelors in the <code>bachelor</code> table by using the <code>is true</code> syntax in the <code>employed_flag</code> column:</p>
<pre><code>select  *
from    bachelor
where   <b>employed_flag is true</b>;</code></pre>
<p>This query causes MySQL to return only rows for bachelors who are employed.</p>
<p>To check bachelors whose <code>employed_flag</code> value is set to <code>false</code>, use <code>is false</code>:</p>
<pre><code>select  *
from    bachelor
where   <b>employed_flag is false</b>;</code></pre>
<p>Now MySQL returns only rows for bachelors who are unemployed.</p>
<p>You can check the value of boolean columns in other ways as well. These lines are all equivalent ways of checking for <code>true</code> values:</p>
<pre><code>employed_flag is true
employed_flag
employed_flag = true
employed_flag != false
employed_flag = 1
employed_flag != 0</code></pre>
<p>The following lines are all equivalent ways to check for <code>false</code> values:</p>
<pre><code>employed_flag is false
not employed_flag
employed_flag = false
employed_flag != true
employed_flag = 0
employed_flag != 1</code></pre>
<p>As you can see here, a value of <code>1</code> is equivalent to <code>true</code> and a value of <code>0</code> is equivalent to <code>false</code>.</p>
<h2 id="h1-503007c07-0003"><a class="XrefDestination" id="orConditions"/><span class="XrefDestination" id="xref-503007c07-023"/>or Conditions</h2>
<p class="BodyFirst">You can use MySQL’s <code>or</code> keyword to check that at least one of two conditions has been met.</p>
<p><span epub:type="pagebreak" title="96" id="Page_96"/>Consider this table called <code>applicant</code>, which contains information about job applicants.</p>
<pre><code>name          associates_degree_flag  bachelors_degree_flag  years_experience
------------  ----------------------  ---------------------  ----------------
Joe Smith               0                       1                   7
Linda Jones             1                       0                   2
Bill Wang               0                       1                   1
Sally Gooden            1                       0                   0
Katy Daly               0                       0                   0</code></pre>
<p>The <code>associates_degree_flag</code> and <code>bachelors_degree_flag</code> columns are booleans, where <code>0</code> represents <code>false</code> and <code>1</code> represents <code>true</code>.</p>
<p>In the following query, you select from the <code>applicant</code> table to get a list of qualified applicants for a job that requires a bachelor’s degree <em>or</em> two or more years of experience:</p>
<pre><code>select  *
from    applicant
where   <b>bachelors_degree_flag is true</b>
<b>or      years_experience &gt;= 2;</b></code></pre>
<p>The results are:</p>
<pre><code>name          associates_degree_flag  bachelors_degree_flag  years_experience
------------  ----------------------  ---------------------  ----------------
Joe Smith               0                       1                   7
Linda Jones             1                       0                   2
Bill Wang               0                       1                   1</code></pre>
<p>Say you need to write a query with both the <code>and</code> (both conditions must be met) and <code>or</code> (either condition must be met) keywords. In this case, you can use parentheses to group your conditions so that MySQL will return the correct results.</p>
<p>Let’s see how using parentheses can be beneficial. Here you create another query with the <code>applicant</code> table for a new job that requires applicants to have two or more years’ experience <em>and</em> either an associate’s degree <em>or</em> a bachelor’s degree:</p>
<pre><code>select  *
from    applicant
<b>where   years_experience &gt;= 2</b>
<b>and     associates_degree_flag is true</b>
<b>or      bachelors_degree_flag is true;</b></code></pre>
<p>The results of this query are not what you expected:</p>
<pre><code>name          associates_degree_flag  bachelors_degree_flag  years_experience
------------  ----------------------  ---------------------  ----------------
Joe Smith               0                      1                   7
Linda Jones             1                      0                   2
Bill Wang               0                      1                   1</code></pre>
<p><span epub:type="pagebreak" title="97" id="Page_97"/>Bill doesn’t have two or more years’ experience, so why did he appear in your result set?</p>
<p>The query uses both an <code>and</code> and an <code>or</code>. The <code>and</code> has a higher <em>operator precedence</em> than the <code>or</code>, which means <code>and</code> gets evaluated before <code>or</code>. This caused your query to find applicants that met at least one of the following two conditions:</p>
<ul class="disc">
<li>Two or more years’ experience <em>and</em> an associate’s degree</li>
</ul>
<p class="BodyContinued"><em>or</em></p>
<ul class="disc">
<li>A bachelor’s degree</li>
</ul>
<p>That’s not what you intended when you wrote the query. You can correct the problem by using parentheses to group your conditions:</p>
<pre><code>select  *
from    applicant
where   years_experience &gt;= 2
and     (
        associates_degree_flag is true
or      bachelors_degree_flag is true
        );</code></pre>
<p>Now the query finds applicants that meet these conditions:</p>
<ul class="disc">
<li>Two or more years’ experience</li>
</ul>
<p class="BodyContinued"><em>and</em></p>
<ul class="disc">
<li>An associate’s degree <em>or </em>a bachelor’s degree</li>
</ul>
<p>Your results should now be in line with your expectations:</p>
<pre><code>name          associates_degree_flag  bachelors_degree_flag  years_experience
------------  ----------------------  ---------------------  ----------------
Joe Smith               0                      1                   7
Linda Jones             1                      0                   2</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Even in cases where parentheses won’t change the results returned by your query, using them is a best practice because it makes your code more readable.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxListNumberCustom1"><b>7-2.</b>	In the <code>airport</code> database, the <code>boarding</code> table contains the following data:</p>
<pre><code>passenger_name  license_flag  student_id_flag  soc_sec_card_flag
--------------  -------------  --------------  -----------------
Frank Flyer           1               0               0
Rhonda Runway         0               0               1
Sam Suitcase          0               1               1
Pam Prepared          1               1               1</code></pre>
<p class="ListBody"><span epub:type="pagebreak" title="98" id="Page_98"/>In order to board a flight, a passenger must have a license, along with either a student ID or a Social Security card. The following query was written to identify passengers who are allowed to board:</p>
<pre><code>select  *
from    boarding
where   license_flag is true
and     student_id_flag is true
or      soc_sec_card_flag is true;</code></pre>
<p class="BoxBodyContinued">But it isn’t returning the correct results:</p>
<pre><code>passenger_name  license_flag  student_id_flag  soc_sec_card_flag
--------------  -------------  --------------  -----------------
Rhonda Runway         0               0               1
Sam Suitcase          0               1               1
Pam Prepared          1               1               1</code></pre>
<p class="BoxBodyContinued">Only <code>Pam Prepared</code> should be appearing in this list. How would you change the query to get the correct results?</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c07-0004"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-503007c07-025"/>Summary</h2>
<p class="BodyFirst">In this chapter, you learned various ways to compare values in MySQL through comparison operators, such as checking whether values are equal, null, or within a range, or if they match a pattern. You also learned how to check that at least one condition is met in your queries.</p>
<p>In the next chapter, you’ll take a look at using MySQL’s built-in functions, including those that deal with mathematics, dates, and strings. You’ll also learn about aggregate functions and how to use them for groups of values.</p>
</section>
</div>
</div>
</body></html>