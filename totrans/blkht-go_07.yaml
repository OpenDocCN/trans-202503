- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ABUSING DATABASES AND FILESYSTEMS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we’ve covered the majority of common network protocols used for active
    service interrogation, command and control, and other malicious activity, let’s
    switch our focus to an equally important topic: data pillaging.'
  prefs: []
  type: TYPE_NORMAL
- en: Although data pillaging may not be as exciting as initial exploitation, lateral
    network movement, or privilege escalation, it’s a critical aspect of the overall
    attack chain. After all, we often need data in order to perform those other activities.
    Commonly, the data is of tangible worth to an attacker. Although hacking an organization
    is thrilling, the data itself is often a lucrative prize for the attacker and
    a damning loss for the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which study you read, a breach in 2020 can cost an organization
    approximately $4 to $7 million. An IBM study estimates it costs an organization
    $129 to $355 per record stolen. Hell, a black hat hacker can make some serious
    coin off the underground market by selling credit cards at a rate of $7 to $80
    per card ([*http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf*](http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: The Target breach alone resulted in a compromise of 40 million cards. In some
    cases, the Target cards were sold for as much as $135 per card (*[http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/](http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/)*).
    That’s pretty lucrative. We, in no way, advocate that type of activity, but folks
    with a questionable moral compass stand to make a lot of money from data pillaging.
  prefs: []
  type: TYPE_NORMAL
- en: Enough about the industry and fancy references to online articles—let’s pillage!
    In this chapter, you’ll learn to set up and seed a variety of SQL and NoSQL databases
    and learn to connect and interact with those databases via Go. We’ll also demonstrate
    how to create a database and filesystem data miner that searches for key indicators
    of juicy information.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Databases with Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll install various database systems and then seed them
    with the data you’ll use in this chapter’s pillaging examples. Where possible,
    you’ll use Docker on an Ubuntu 18.04 VM. *Docker* is a software container platform
    that makes it easy to deploy and manage applications. You can bundle applications
    and their dependencies in a manner that makes their deployment straightforward.
    The container is compartmentalized from the operating system in order to prevent
    the pollution of the host platform. This is nifty stuff.
  prefs: []
  type: TYPE_NORMAL
- en: And for this chapter, you will use a variety of prebuilt Docker images for the
    databases you’ll be working with. If you don’t have it already, install Docker.
    You can find Ubuntu instructions at [*https://docs.docker.com/install/linux/docker-ce/ubuntu/*](https://docs.docker.com/install/linux/docker-ce/ubuntu/).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ve specifically chosen to omit details on setting up an Oracle instance.
    Although Oracle provides VM images that you can download and use to create a test
    database, we felt that it was unnecessary to walk you through these steps, since
    they’re fairly similar to the MySQL examples below. We’ll leave the Oracle-specific
    implementation as an exercise for you to do independently.*'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Seeding MongoDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*MongoDB* is the only NoSQL database that you’ll use in this chapter. Unlike
    traditional relational databases, MongoDB doesn’t communicate via SQL. Instead,
    MongoDB uses an easy-to-understand JSON syntax for retrieving and manipulating
    data. Entire books have been dedicated to explaining MongoDB, and a full explanation
    is certainly beyond the scope of this book. For now, you’ll install the Docker
    image and seed it with fake data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike traditional SQL databases, MongoDB is *schema-less*, which means that
    it doesn’t follow a predefined, rigid rule system for organizing table data. This
    explains why you’ll see only `insert` commands in [Listing 7-1](ch07.xhtml#ch7list1)
    without any schema definitions. First, install the MongoDB Docker image with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads the image named `mongo` from the Docker repository, spins
    up a new instance named `some-mongo`—the name you give the instance is arbitrary—and
    maps local port `27017` to the container port `27017`. The port mapping is key,
    as it allows us to access the database instance directly from our operating system.
    Without it, it would be inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the container started automatically by listing all the running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event your container doesn’t start automatically, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `start` command should get the container going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your container starts, connect to the MongoDB instance by using the `run`
    command—passing it the MongoDB client; that way, you can interact with the database
    to seed data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This magical command runs a disposable, second Docker container that has the
    MongoDB client binary installed—so you don’t have to install the binary on your
    host operating system—and uses it to connect to the `some-mongo` Docker container’s
    MongoDB instance. In this example, you’re connecting to a database named `test`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-1](ch07.xhtml#ch7list1), you insert an array of documents into
    the `transactions` collection. (All the code listings at the root location of
    / exist under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Inserting transactions into a MongoDB collection (*[/ch-7/db/seed-mongo.js](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-mongo.js)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve now created your MongoDB database instance and seeded it with
    a `transactions` collection that contains three fake documents for querying. You’ll
    get to the querying part in a bit, but first, you should know how to install and
    seed traditional SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Seeding PostgreSQL and MySQL Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*PostgreSQL* (also called *Postgres*) and *MySQL* are probably the two most
    common, well-known, enterprise-quality, open source relational database management
    systems, and official Docker images exist for both. Because of their similarity
    and the general overlap in their installation steps, we batched together installation
    instructions for both here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, much in the same way as for the MongoDB example in the previous section,
    download and run the appropriate Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After your containers are built, confirm they are running, and if they aren’t,
    you can start them via the docker start name command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can connect to the containers from the appropriate client—again, using
    the Docker image to prevent installing any additional files on the host—and proceed
    to create and seed the database. In [Listing 7-2](ch07.xhtml#ch7list2), you can
    see the MySQL logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Creating and initializing a MySQL database*'
  prefs: []
  type: TYPE_NORMAL
- en: The listing, like the one that follows, starts a disposable Docker shell that
    executes the appropriate database client binary. It creates and connects to the
    database named `store` and then creates a table named `transactions`. The two
    listings are identical, with the exception that they are tailored to different
    database systems.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-3](ch07.xhtml#ch7list3), you can see the Postgres logic, which
    differs slightly in syntax from MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Creating and initializing a Postgres database*'
  prefs: []
  type: TYPE_NORMAL
- en: In both MySQL and Postgres, the syntax is identical for inserting your transactions.
    For example, in [Listing 7-4](ch07.xhtml#ch7list4), you can see how to insert
    three documents into a MySQL `transactions` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Inserting transactions into MySQL databases (*[/ch-7/db/seed-pg-mysql.sql](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-pg-mysql.sql)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Try inserting the same three documents into your Postgres database.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Seeding Microsoft SQL Server Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In 2016, Microsoft began making major moves to open-source some of its core
    technologies. One of those technologies was Microsoft SQL (MSSQL) Server. It feels
    pertinent to highlight this information while demonstrating what, for so long,
    wasn’t possible—that is, installing MSSQL Server on a Linux operating system.
    Better yet, there’s a Docker image for it, which you can install with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That command is similar to the others you ran in the previous two sections,
    but per the documentation, the `SA_PASSWORD` value needs to be complex—a combination
    of uppercase letters, lowercase letters, numbers, and special characters—or you
    won’t be able to authenticate to it. Since this is just a test instance, the preceding
    value is trivial but minimally meets those requirements—just as we see on enterprise
    networks all the time!
  prefs: []
  type: TYPE_NORMAL
- en: With the image installed, start the container, create the schema, and seed the
    database, as in [Listing 7-5](ch07.xhtml#ch7list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: Creating and seeding an MSSQL database*'
  prefs: []
  type: TYPE_NORMAL
- en: The previous listing replicates the logic we demonstrated for MySQL and Postgres
    earlier. It uses Docker to connect to the service, creates and connects to the
    `store` database, and creates and seeds a `transactions` table. We’re presenting
    it separately from the other SQL databases because it has some MSSQL-specific
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and Querying Databases in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have a variety of test databases to work with, you can build the
    logic to connect to and query those databases from a Go client. We’ve divided
    this discussion into two topics—one for MongoDB and one for traditional SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Querying MongoDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Despite having an excellent standard SQL package, Go doesn’t maintain a similar
    package for interacting with NoSQL databases. Instead you’ll need to rely on third-party
    packages to facilitate this interaction. Rather than inspect the implementation
    of each third-party package, we’ll focus purely on MongoDB. We’ll use the `mgo`
    (pronounce *mango*) DB driver for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the `mgo` driver with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can now establish connectivity and query your `store` collection (the equivalent
    of a table), which requires even less code than the SQL sample code we’ll create
    later (see [Listing 7-6](ch07.xhtml#ch7list6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: Connecting to and querying a MongoDB database (*[/ch-7/db/mongo-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo-connect/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you define a type, `Transaction`, which will represent a single document
    from your `store` collection ❶. The internal mechanism for data representation
    in MongoDB is binary JSON. For this reason, use tagging to define any marshaling
    directives. In this case, you’re using tagging to explicitly define the element
    names to be used in the binary JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `main()` function ❷, call `mgo.Dial()` to create a session by establishing
    a connection to your database, testing to make sure no errors occurred, and deferring
    a call to close the session. You then use the `session` variable to query the
    `store` database ❸, retrieving all the records from the `transactions` collection.
    You store the results in a `Transaction` slice, named `results`. Under the covers,
    your structure tags are used to unmarshal the binary JSON to your defined type.
    Finally, loop over your result set and print them to the screen ❹. In both this
    case and the SQL sample in the next section, your output should look similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Querying SQL Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go contains a standard package, called `database/sql`, that defines an interface
    for interacting with SQL and SQL-like databases. The base implementation automatically
    includes functionality such as connection pooling and transaction support. Database
    drivers adhering to this interface automatically inherit these capabilities and
    are essentially interchangeable, as the API remains consistent between drivers.
    The function calls and implementation in your code are identical whether you’re
    using Postgres, MSSQL, MySQL, or some other driver. This makes it convenient to
    switch backend databases with minimal code change on the client. Of course, the
    drivers can implement database-specific capabilities and use different SQL syntax,
    but the function calls are nearly identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we’ll show you how to connect to just one SQL database—MySQL—and
    leave the other SQL databases as an exercise for you. You start by installing
    the driver with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can create a basic client that connects to the database and retrieves
    the information from your `transactions` table—using the script in [Listing 7-7](ch07.xhtml#ch7list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: Connecting to and querying a MySQL database (*[/ch-7/db/mysql-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql-connect/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: The code begins by importing Go’s `database/sql` package ❶. This allows you
    to utilize Go’s awesome standard SQL library interface to interact with the database.
    You also import your MySQL database driver ❷. The leading underscore indicates
    that it’s imported anonymously, which means its exported types aren’t included,
    but the driver registers itself with the `sql` package so that the MySQL driver
    itself handles the function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you call `sql.Open()` to establish a connection to our database ❸. The
    first parameter specifies which driver should be used—in this case, the driver
    is `mysql`—and the second parameter specifies your connection string. You then
    query your database, passing an SQL statement to select all rows from your `transactions`
    table ❹, and then loop over the rows, subsequently reading the data into your
    variables and printing the values ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all you need to do to query a MySQL database. Using a different backend
    database requires only the following minor changes to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the correct database driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the parameters passed to `sql.Open()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the SQL syntax to the flavor required by your backend database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Among the several database drivers available, many are pure Go, while a handful
    of others use `cgo` for some underlying interaction. Check out the list of available
    drivers at *[https://github.com/golang/go/wiki/SQLDrivers/](https://github.com/golang/go/wiki/SQLDrivers/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Database Miner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will create a tool that inspects the database schema (for
    example, column names) to determine whether the data within is worth pilfering.
    For instance, say you want to find passwords, hashes, social security numbers,
    and credit card numbers. Rather than building one monolithic utility that mines
    various backend databases, you’ll create separate utilities—one for each database—and
    implement a defined interface to ensure consistency between the implementations.
    This flexibility may be somewhat overkill for this example, but it gives you the
    opportunity to create reusable and portable code.
  prefs: []
  type: TYPE_NORMAL
- en: The interface should be minimal, consisting of a few basic types and functions,
    and it should require the implementation of a single method to retrieve database
    schema. [Listing 7-8](ch07.xhtml#ch7list8), called *dbminer.go*, defines the database
    miner’s interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: Database miner implementation (*[/ch-7/db/dbminer/dbminer.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/dbminer/dbminer.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: The code begins by defining an interface named `DatabaseMiner` ❶. A single method,
    called `GetSchema()`, is required for any types that implement the interface.
    Because each backend database may have specific logic to retrieve the database
    schema, the expectation is that each specific utility can implement the logic
    in a way that’s unique to the backend database and driver in use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you define a `Schema` type, which is composed of a few subtypes also defined
    here ❷. You’ll use the `Schema` type to logically represent the database schema—that
    is, databases, tables, and columns. You might have noticed that your `GetSchema()`
    function, within the interface definition, expects implementations to return a
    `*Schema`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you define a single function, called `Search()`, which contains the bulk
    of the logic. The `Search()` function expects a `DatabaseMiner` instance to be
    passed to it during the function call, and stores the miner value in a variable
    named `m` ❸. The function starts by calling `m.GetSchema()` to retrieve the schema
    ❹. The function then loops through the entire schema, searching against a list
    of regular expression (regex) values for column names that match ❺. If it finds
    a match, the database schema and matching field are printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, define a function named `getRegex()` ❻. This function compiles regex
    strings by using Go’s `regexp` package and returns a slice of these values. The
    regex list consists of case-insensitive strings that match against common or interesting
    field names such as `ccnum`, `ssn`, and `password`.
  prefs: []
  type: TYPE_NORMAL
- en: With your database miner’s interface in hand, you can create utility-specific
    implementations. Let’s start with the MongoDB database miner.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a MongoDB Database Miner
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The MongoDB utility program in [Listing 7-9](ch07.xhtml#ch7list9) implements
    the interface defined in [Listing 7-8](ch07.xhtml#ch7list8) while also integrating
    the database connectivity code you built in [Listing 7-6](ch07.xhtml#ch7list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9: Creating a MongoDB database miner (*[/ch-7/db/mongo/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: You start by importing the `dbminer` package that defines your `DatabaseMiner`
    interface ❶. Then you define a `MongoMiner` type that will be used to implement
    the interface ❷. For convenience, you define a `New()` function that creates a
    new instance of your `MongoMiner` type ❸, calling a method named `connect()` that
    establishes a connection to the database ❹. The entirety of this logic essentially
    bootstraps your code, connecting to the database in a fashion similar to that
    discussed in [Listing 7-6](ch07.xhtml#ch7list6).
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting portion of the code is your implementation of the `GetSchema()`
    interface method ❺. Unlike in the previous MongoDB sample code in [Listing 7-6](ch07.xhtml#ch7list6),
    you are now inspecting the MongoDB metadata, first retrieving database names ❻
    and then looping over those databases to retrieve each database’s collection names
    ❼. Lastly, the function retrieves the raw document that, unlike a typical MongoDB
    query, uses lazy unmarshaling ❽. This allows you to explicitly unmarshal the record
    into a generic structure so that you can inspect field names ❾. If not for lazy
    unmarshaling, you would have to define an explicit type, likely using `bson` tag
    attributes, in order to instruct your code how to unmarshal the data into a struct
    you defined. In this case, you don’t know (or care) about the field types or structure—you
    just want the field names (not the data)—so this is how you can unmarshal structured
    data without needing to know the structure of that data beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Your `main()` function expects the IP address of your MongoDB instance as its
    lone argument, calls your `New()` function to bootstrap everything, and then calls
    `dbminer.Search()`, passing to it your `MongoMiner` instance ❿. Recall that `dbminer.Search()`
    calls `GetSchema()` on the received `DatabaseMiner` instance; this calls your
    `MongoMiner` implementation of the function, which results in the creation of
    `dbminer.Schema` that is then searched against the regex list in [Listing 7-8](ch07.xhtml#ch7list8).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run your utility, you are blessed with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You found a match! It may not look pretty, but it gets the job done—successfully
    locating the database collection that has a field named `ccnum`.
  prefs: []
  type: TYPE_NORMAL
- en: With your MongoDB implementation built, in the next section, you’ll do the same
    for a MySQL backend database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a MySQL Database Miner
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make your MySQL implementation work, you’ll inspect the `information_schema.columns`
    table. This table maintains metadata about all the databases and their structures,
    including table and column names. To make the data the simplest to consume, use
    the following SQL query, which removes information about some of the built-in
    MySQL databases that are of no consequence to your pillaging efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The query produces results resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although using that query to retrieve schema information is pretty straightforward,
    the complexity in your code comes from logically trying to differentiate and categorize
    each row while defining your `GetSchema()` function. For example, consecutive
    rows of output may or may not belong to the same database or table, so associating
    the rows to the correct `dbminer.Database` and `dbminer.Table` instances becomes
    a somewhat tricky endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-10](ch07.xhtml#ch7list10) defines the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10: Creating a MySQL database miner (*[/ch-7/db/mysql/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: A quick glance at the code and you’ll probably realize that much of it is very,
    very similar to the MongoDB example in the preceding section. As a matter of fact,
    the `main()` function is identical.
  prefs: []
  type: TYPE_NORMAL
- en: The bootstrapping functions are also similar—you just change the logic to interact
    with MySQL rather than MongoDB. Notice that this logic connects to your `information_schema`
    database ❶, so that you can inspect the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the code’s complexity resides within the `GetSchema()` implementation.
    Although you are able to retrieve the schema information by using a single database
    query ❷, you then have to loop over the results ❸, inspecting each row so you
    can determine what databases exist, what tables exist in each database, and what
    columns exist for each table. Unlike in your MongoDB implementation, you don’t
    have the luxury of JSON/BSON with attribute tags to marshal and unmarshal data
    into complex structures; you maintain variables to track the information in your
    current row and compare it with the data from the previous row, in order to determine
    whether you’ve encountered a new database or table. Not the most elegant solution,
    but it gets the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you check whether the database name for your current row differs from
    your previous row ❹. If so, you create a new `miner.Database` instance. If it
    isn’t your first iteration of the loop, add the table and database to your `miner.Schema`
    instance. You use similar logic to track and add `miner.Table` instances to your
    current `miner.Database` ❺. Lastly, add each of the columns to our `miner.Table`
    ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the program against your Docker MySQL instance to confirm that it
    works properly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output should be almost indiscernible from your MongoDB output. This is
    because your `dbminer.Schema` isn’t producing any output—the `dbminer.Search()`
    function is. This is the power of using interfaces. You can have specific implementations
    of key features, yet still utilize a single, standard function to process your
    data in a predictable, usable manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll step away from databases and instead focus on pillaging
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Pillaging a Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll build a utility that walks a user-supplied filesystem
    path recursively, matching against a list of interesting filenames that you would
    deem useful as part of a post-exploitation exercise. These files may contain,
    among other things, personally identifiable information, usernames, passwords,
    system logins, and password database files.
  prefs: []
  type: TYPE_NORMAL
- en: The utility looks specifically at filenames rather than file contents, and the
    script is made much simpler by the fact that Go contains standard functionality
    in its `path/filepath` package that you can use to easily walk a directory structure.
    You can see the utility in [Listing 7-11](ch07.xhtml#ch7list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-11: Walking and searching a filesystem (*[/ch-7/filesystem/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/filesystem/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to your database-mining implementations, the filesystem pillaging
    setup and logic might seem a little too simple. Similar to the way you created
    your database implementations, you define a regex list for identifying interesting
    filenames ❶. To keep the code minimal, we limited the list to just a handful of
    items, but you can expand the list to accommodate more practical usage.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you define a function, named `walkFn()`, that accepts a file path and
    some additional parameters ❷. The function loops over your regular expression
    list and checks for matches ❸, displaying them to stdout. The `walkFn()` function
    ❹ is used in the `main()` function, and passed as a parameter to `filepath.Walk()`.
    The `Walk()` function expects two parameters—a root path and a function (in this
    case, `walkFn()`)—and recursively walks the directory structure starting at the
    value supplied as the root path, calling `walkFn()` for every directory and file
    it encounters.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your utility complete, navigate to your desktop and create the following
    directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your utility against this same `targetpath` directory produces the
    following output, confirming that your code works splendidly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That’s just about all there is to it. You can improve the sample code through
    the inclusion of additional or more-specific regular expressions. Further, we
    encourage you to improve the code by applying the regular expression check only
    to filenames, not directories. Another enhancement we encourage you to make is
    to locate and flag specific files with a recent modified or access time. This
    metadata can lead you to more important content, including files used as part
    of critical business processes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we dove into database interactions and filesystem walking,
    using both Go’s native packages and third-party libraries to inspect database
    metadata and filenames. For an attacker, these resources often contain valuable
    information, and we created various utilities that allow us to search for this
    juicy information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll take a look at practical packet processing. Specifically,
    you’ll learn how to sniff and manipulate network packets.
  prefs: []
  type: TYPE_NORMAL
