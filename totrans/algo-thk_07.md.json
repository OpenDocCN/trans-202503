["```\n6\n1 2 20 0\n1 3 50 0\n1 4 30 1\n4 5 50 0\n4 6 50 0\n-1 2 9 -1 7 8\n```", "```\n#define MAX_NODES 1000\n\ntypedef struct edge {\n  int to_node, percentage, superpipe;\n  struct edge *next;\n} edge;\n```", "```\nint main(void) {\n  static edge *adj_list[MAX_NODES + 1] = {NULL};\n  static int liquid_needed[MAX_NODES + 1];\n  int num_nodes, i;\n  int from_node, to_node, percentage, superpipe;\n  edge *e;\n  scanf(\"%d\", &num_nodes);\n\n  for (i = 0; i < num_nodes - 1; i++) {\n    scanf(\"%d%d%d%d\", &from_node, &to_node, &percentage, &superpipe);\n    e = malloc(sizeof(edge));\n    if (e == NULL) {\n      fprintf(stderr, \"malloc error\\n\");\n      exit(1);\n    }\n    e->to_node = to_node;\n    e->percentage = percentage;\n    e->superpipe = superpipe;\n    e->next = adj_list[from_node];\n  ➊ adj_list[from_node] = e;\n  }\n\n  for (i = 1; i <= num_nodes; i++)\n  ➋ scanf(\"%d\", &liquid_needed[i]);\n  solve(adj_list, liquid_needed);\n  return 0;\n}\n```", "```\nint can_feed(int node, double liquid,\n             edge *adj_list[], int liquid_needed[])\n```", "```\nif (liquid_needed[node] != -1)\n  return liquid >= liquid_needed[node];\n```", "```\nint can_feed(int node, double liquid,\n             edge *adj_list[], int liquid_needed[]) {\n  edge *e;\n  int ok;\n  double down_pipe;\n  if (liquid_needed[node] != -1)\n return liquid >= liquid_needed[node];\n  e = adj_list[node];\n➊ ok = 1;\n  while (e && ok) {\n    down_pipe = liquid * e->percentage / 100;\n    if (e->superpipe)\n   ➋ down_pipe = down_pipe * down_pipe;\n    if (!can_feed(e->to_node, down_pipe, adj_list, liquid_needed))\n   ➌ ok = 0;\n    e = e->next;\n }\n return ok;\n}\n```", "```\nprintf(\"%d\\n\", can_feed(1, 10, adj_list, liquid_needed));\n```", "```\nprintf(\"%d\\n\", can_feed(1, 20, adj_list, liquid_needed));\n```", "```\n#define HIGHEST 2000000000\n\nvoid solve(edge *adj_list[], int liquid_needed[]) {\n  double low, high, mid;\n  low = 0;\n  high = HIGHEST;\n➊ while (high - low > 0.00001) {\n  ➋ mid = (low + high) / 2;\n  ➌ if (can_feed(1, mid, adj_list, liquid_needed))\n high = mid;\n    else\n      low = mid;\n   }\n➍ printf(\"%.4lf\\n\", high);\n}\n```", "```\n12 2 1\n5\n8\n```", "```\n12 4 2\n1\n3\n8\n9\n```", "```\n12 4 2\n2\n4\n5\n8\n```", "```\n12 4 2\n2\n4\n5\n8\n```", "```\nint can_make_min_distance(int distance, int rocks[], int num_rocks,\n                          int num_remove, int length) {\n  int i;\n  int removed = 0, prev_rock_location = 0, cur_rock_location;\n  if (length < distance)\n    return 0;\n  for (i = 0; i < num_rocks; i++) {\n    cur_rock_location = rocks[i];\n ➊ if (cur_rock_location - prev_rock_location < distance)\n      removed++;\n    else\n      prev_rock_location = cur_rock_location;\n  }\n➋ if (length - prev_rock_location < distance)\n     removed++;\n return removed <= num_remove;\n}\n```", "```\nint main(void) {\n  int rocks[4] = {2, 4, 5, 8};\n  printf(\"%d\\n\", can_make_min_distance(6, rocks, 4, 2, 12));\n  return 0;\n}\n```", "```\n// bugged!\nvoid solve(int rocks[], int num_rocks,\n           int num_remove, int length) {\n  int low, high, mid;\n  low = 0;\n  high = length;\n  while (high - low > 1) {\n    mid = (low + high) / 2;\n ➊ if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))\n   ➋ low = mid;\n else\n   ➌ high = mid;\n  }\n  printf(\"%d\\n\", high);\n}\n```", "```\n12 4 2\n2\n4\n5\n8\n```", "```\n// bugged!\nvoid solve(int rocks[], int num_rocks,\n           int num_remove, int length) {\n  int low, high, mid;\n  low = 0;\n  high = length;\n  while (high - low > 1) {\n    mid = (low + high) / 2;\n    if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))\n      low = mid;\n    else\n      high = mid;\n  }\n  printf(\"%d\\n\", low);\n}\n```", "```\n12 0 0\n```", "```\nlow = 0;\nhigh = length;\n```", "```\nlow = 0;\nhigh = length + 1;\n```", "```\nvoid solve(int rocks[], int num_rocks,\n           int num_remove, int length) {\n  int low, high, mid;\n  low = 0;\n  high = length + 1;\n  while (high - low > 1) {\n    mid = (low + high) / 2;\n    if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))\n      low = mid;\n    else\n      high = mid;\n  }\n  printf(\"%d\\n\", low);\n}\n```", "```\n#define MAX_ROCKS 50000\n\nint compare(const void *v1, const void *v2) {\n  int num1 = *(const int *)v1;\n  int num2 = *(const int *)v2;\n  return num1 - num2;\n}\n\nint main(void) {\n  static int rocks[MAX_ROCKS];\n  int length, num_rocks, num_remove, i;\n  scanf(\"%d%d%d\", &length, &num_rocks, &num_remove);\n  for (i = 0; i < num_rocks; i++)\n    scanf(\"%d\", &rocks[i]);\n➊ qsort(rocks, num_rocks, sizeof(int), compare);\n  solve(rocks, num_rocks, num_remove, length);\n return 0;\n}\n```", "```\nint rectangle(int r, int c, int h, int w, int q[3001][3001])\n```", "```\n#define MAX_ROWS 3001\n#define MAX_COLS 3001\n\ntypedef int board[MAX_ROWS][MAX_COLS];\n```", "```\n int compare(const void *v1, const void *v2) {\n   int num1 = *(const int *)v1;\n   int num2 = *(const int *)v2;\n   return num1 - num2;\n }\n\n int median(int top_row, int left_col, int bottom_row, int right_col,\n            board q) {\n   static int cur_rectangle[MAX_ROWS * MAX_COLS];\n   int i, j, num_cur_rectangle;\n   num_cur_rectangle = 0;\n   for (i = top_row; i <= bottom_row; i++)\n     for (j = left_col; j <= right_col; j++) {\n       cur_rectangle[num_cur_rectangle] = q[i][j];\n       num_cur_rectangle++;\n     }\n➊ qsort(cur_rectangle, num_cur_rectangle, sizeof(int), compare);\n   return cur_rectangle[num_cur_rectangle / 2];\n }\n```", "```\n int rectangle(int r, int c, int h, int w, board q) {\n   int top_row, left_col, bottom_row, right_col;\n➊ int best = r * c + 1;\n   int result;\n   for (top_row = 0; top_row < r - h + 1; top_row++)\n     for (left_col = 0; left_col < c - w + 1; left_col++) {\n   ➋ bottom_row = top_row + h - 1;\n   ➌ right_col = left_col + w - 1;\n   ➍ result = median(top_row, left_col, bottom_row, right_col, q);\n      if (result < best)\n best = result;\n  }\n  return best;\n}\n```", "```\nint main(void) {\nstatic board q = {{48, 16, 15, 45, 40, 28, 8},\n                  {20, 11, 36, 19, 24, 6, 33},\n                  {22, 39, 30, 7, 9, 1, 18},\n                  {14, 35, 2, 13, 31, 12, 46},\n                  {32, 37, 21, 3, 41, 23, 29},\n                  {42, 49, 38, 10, 17, 47, 5},\n                  {43, 4, 34, 25, 26, 27, 44}};\n  int result = rectangle(7, 7, 5, 3, q);\n  printf(\"%d\\n\", result);\n  return 0;\n}\n```", "```\nint rectangle(int r, int c, int h, int w, board q) {\n  int low, high, mid;\n  low = 0;\n  high = r * c + 1;\n  while (high - low > 1) {\n    mid = (low + high) / 2;\n    if (can_make_quality(mid, r, c, h, w, q))\n      high = mid;\n    else\n      low = mid;\n  }\n return high;\n}\n```", "```\nint can_make_quality(int quality, int r, int c, int h, int w, board q)\n```", "```\nint can_make_quality(int quality, int r, int c, int h, int w, board q) {\n➊ static int zero_one[MAX_ROWS][MAX_COLS];\n  int i, j;\n  int top_row, left_col, bottom_row, right_col;\n  int total;\n for (i = 0; i < r; i++)\n    for (j = 0; j < c; j++)\n    ➋ if (q[i][j] <= quality)\n        zero_one[i][j] = -1;\n      else\n        zero_one[i][j] = 1;\n\n   for (top_row = 0; top_row < r - h + 1; top_row++)\n     for (left_col = 0; left_col < c - w + 1; left_col++) {\n       bottom_row = top_row + h - 1;\n       right_col = left_col + w - 1;\n       total = 0;\n       for (i = top_row; i <= bottom_row; i++)\n         for (j = left_col; j <= right_col; j++)\n         ➌ total = total + zero_one[i][j];\n        if (total <= 0)\n          return 1;\n      }\n    return 0;\n}\n```", "```\nsum[bottom_row][right_col] - sum[top_row - 1][right_col] -\n  sum[bottom_row][left_col - 1] + sum[top_row - 1][left_col - 1]\n```", "```\nint can_make_quality(int quality, int r, int c, int h, int w, board q) {\n  static int zero_one[MAX_ROWS][MAX_COLS];\n  static int sum[MAX_ROWS + 1][MAX_COLS + 1];\n  int i, j;\n  int top_row, left_col, bottom_row, right_col;\n  int total;\n\n➊ for (i = 0; i < r; i++)\n    for (j = 0; j < c; j++)\n      if (q[i][j] <= quality)\n        zero_one[i][j] = -1;\n      else\n        zero_one[i][j] = 1;\n\n   for (i = 0; i <= c; i++)\n     sum[0][i] = 0;\n   for (i = 0; i <= r; i++)\n     sum[i][0] = 0;\n➋ for (i = 1; i <= r; i++)\n     for (j = 1; j <= c; j++)\n       sum[i][j] = zero_one[i - 1][j - 1] + sum[i - 1][j] +\n                   sum[i][j - 1] - sum[i - 1][j - 1];\n\n➌ for (top_row = 1; top_row <= r - h + 1; top_row++)\n     for (left_col = 1; left_col <= c - w + 1; left_col++) {\n       bottom_row = top_row + h - 1;\n       right_col = left_col + w - 1;\n       total = sum[bottom_row][right_col] - sum[top_row - 1][right_col] -\n               sum[bottom_row][left_col - 1] + sum[top_row - 1][left_col - 1];\n       if (total <= 0)\n         return 1;\n    }\n  return 0;\n}\n```", "```\nvoid exploreCave(int n)\n```", "```\nint tryCombination(int switch_positions[])\n```", "```\nvoid answer(int switch_positions[], int door_for_switch[])\n```", "```\nvoid exploreCave(int n) {\n  int switch_positions[n], door_for_switch[n];\n  int i, result;\n  for (i = 0; i < n; i++) {\n ➊ switch_positions[i] = 0;\n ➋ door_for_switch[i] = i;\n  }\n\n  for (i = 0; i < n; i++) {\n  ➌ result = tryCombination(switch_positions);\n    if (result == i) // door i is closed\n    ➍ switch_positions[i] = 1;\n   }\n➎ answer(switch_positions, door_for_switch);\n}\n```", "```\nvoid exploreCave(int n) {\n  int switch_positions[n], door_for_switch[n];\n  int i;\n  for (i = 0; i < n; i++)\n➊ door_for_switch[i] = -1;\n for (i = 0; i < n; i++)\n ➋ set_a_switch(i, switch_positions, door_for_switch, n);\n  answer(switch_positions, door_for_switch);\n}\n```", "```\nvoid set_a_switch(int door, int switch_positions[],\n                  int door_for_switch[], int n) {\n  int i, result;\n  int found = 0;\n\n  for (i = 0; i < n; i++)\n    if (door_for_switch[i] == -1)\n    ➊ switch_positions[i] = 0;\n\n  result = tryCombination(switch_positions);\n  if (result != door) { // door is open\n    for (i = 0; i < n; i++)\n      if (door_for_switch[i] == -1)\n      ➋ switch_positions[i] = 1;\n  }\n\n  i = 0;\n  while (!found) {\n    if (door_for_switch[i] == -1) {\n   ➌ switch_positions[i] = 1 - switch_positions[i];\n      result = tryCombination(switch_positions);\n   ➍ if (result != door)\n        found = 1;\n      else\n        i++;\n    }\n else\n      i++;\n  }\n  door_for_switch[i] = door;\n}\n```", "```\nvoid set_a_switch(int door, int switch_positions[],\n                  int door_for_switch[], int n) {\n  int i, result;\n  int low = 0, high = n-1, mid;\n\n  for (i = 0; i < n; i++)\n    if (door_for_switch[i] == -1)\n      switch_positions[i] = 0;\n\n  result = tryCombination(switch_positions);\n  if (result != door) {\n    for (i = 0; i < n; i++)\n      if (door_for_switch[i] == -1)\n        switch_positions[i] = 1;\n  }\n\n➊ while (low != high) {\n    mid = (low + high) / 2;\n    for (i = low; i <= mid; i++)\n      if (door_for_switch[i] == -1)\n        switch_positions[i] = 1 - switch_positions[i];\n  ➋ result = tryCombination(switch_positions);\n     if (result != door) {\n       high = mid;\n       for (i = low; i <= mid; i++)\n         if (door_for_switch[i] == -1)\n           switch_positions[i] = 1 - switch_positions[i];\n    }\n else\n      low = mid + 1;\n  }\n  door_for_switch[low] = door;\n➌ switch_positions[low] = 1 - switch_positions[low];\n}\n```"]