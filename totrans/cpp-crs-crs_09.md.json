["```\nint step(int input) {\n  return input > 0 ? 1 : 0;\n}\n```", "```\nint step(int input) {\n  if (input > 0) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n```", "```\n#include <cstdio>\n\nint confusing(int &x) {\n  return x = 9, x++, x / 2;\n}\n\nint main() {\n  int x{}; ➊\n  auto y = confusing(x); ➋\n  printf(\"x: %d\\ny: %d\", x, y);\n}\n--------------------------------------------------------------------------\nx: 10\ny: 5\n```", "```\n#include <stdexcept>\n\nstruct CheckedInteger {\n  CheckedInteger(unsigned int value) : value{ value } ➊ { }\n\n  CheckedInteger operator+(unsigned int other) const { ➋\n    CheckedInteger result{ value + other }; ➌\n    if (result.value < value) throw std::runtime_error{ \"Overflow!\" }; ➍\n    return result;\n  }\n\n  const unsigned int value; ➎\n};\n```", "```\n#include <limits>\n#include <cstdio>\n#include <stdexcept>\n\nstruct CheckedInteger {\n  --snip--\n};\n\nint main() {\n  CheckedInteger a{ 100 }; ➊\n  auto b = a + 200; ➋\n  printf(\"a + 200 = %u\\n\", b.value);\n  try {\n    auto c = a + std::numeric_limits<unsigned int>::max(); ➌\n  } catch(const std::overflow_error& e) {\n    printf(\"(a + max) Exception: %s\\n\", e.what());\n  }\n}\n--------------------------------------------------------------------------\na + 200 = 300\n(a + max) Exception: Overflow!\n```", "```\n#include <cstddef>\n#include <new>\n\nstruct Bucket { ➊\n  const static size_t data_size{ 4096 };\n  std::byte data[data_size];\n};\n\nstruct Heap {\n  void* allocate(size_t bytes) { ➋\n    if (bytes > Bucket::data_size) throw std::bad_alloc{};\n    for (size_t i{}; i < n_heap_buckets; i++) {\n      if (!bucket_used[i]) {\n        bucket_used[i] = true;\n        return buckets[i].data;\n }\n    }\n    throw std::bad_alloc{};\n  }\n\n  void free(void* p) { ➌\n    for (size_t i{}; i < n_heap_buckets; i++) {\n      if (buckets[i].data == p) {\n        bucket_used[i] = false;\n        return;\n      }\n    }\n  }\n  static const size_t n_heap_buckets{ 10 };\n  Bucket buckets[n_heap_buckets]{}; ➍\n  bool bucket_used[n_heap_buckets]{}; ➎\n};\n```", "```\nHeap heap; ➊\n\nvoid* operator new(size_t n_bytes) {\n  return heap.allocate(n_bytes); ➋\n}\nvoid operator delete(void* p) {\n  return heap.free(p); ➌\n}\n```", "```\n#include <cstdio>\n--snip--\nint main() {\n  printf(\"Buckets:   %p\\n\", heap.buckets); ➊\n  auto breakfast = new unsigned int{ 0xC0FFEE };\n  auto dinner = new unsigned int { 0xDEADBEEF };\n  printf(\"Breakfast: %p 0x%x\\n\", breakfast, *breakfast); ➋\n  printf(\"Dinner:    %p 0x%x\\n\", dinner, *dinner); ➌\n  delete breakfast;\n  delete dinner;\n  try {\n    while (true) {\n      new char;\n      printf(\"Allocated a char.\\n\"); ➍\n    }\n  } catch (const std::bad_alloc&) {\n    printf(\"std::bad_alloc caught.\\n\"); ➎\n  }\n}\n--------------------------------------------------------------------------\nBuckets:   00007FF792EE3320 ➊\nBreakfast: 00007FF792EE3320 0xc0ffee ➋\nDinner:    00007FF792EE4320 0xdeadbeef ➌\nAllocated a char. ➍\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nAllocated a char.\nstd::bad_alloc caught. ➎\n```", "```\n#include <cstdio>\n#include <cstddef>\n#include <new>\n\nstruct Point {\n  Point() : x{}, y{}, z{} {\n    printf(\"Point at %p constructed.\\n\", this); ➊\n  }\n  ~Point() {\n    printf(\"Point at %p destructed.\\n\", this); ➋\n  }\n  double x, y, z;\n};\n\nint main() {\n  const auto point_size = sizeof(Point);\n  std::byte data[3 * point_size];\n  printf(\"Data starts at %p.\\n\", data); ➌\n  auto point1 = new(&data[0 * point_size]) Point{}; ➍\n  auto point2 = new(&data[1 * point_size]) Point{}; ➎\n  auto point3 = new(&data[2 * point_size]) Point{}; ➏\n  point1->~Point(); ➐\n point2->~Point(); ➑\n  point3->~Point(); ➒\n}\n--------------------------------------------------------------------------\nData starts at 0000004D290FF8E8\\. ➌\nPoint at 0000004D290FF8E8 constructed. ➍\nPoint at 0000004D290FF900 constructed. ➎\nPoint at 0000004D290FF918 constructed. ➏\nPoint at 0000004D290FF8E8 destructed. ➐\nPoint at 0000004D290FF900 destructed. ➑\nPoint at 0000004D290FF918 destructed. ➒\n```", "```\n*a++ + b * c\n```", "```\n(*(a++)) + (b * c)\n```", "```\n(stop() + drop()) + roll()\n```", "```\nauto result = stop();\nresult = result + drop();\nresult = result + roll();\n```", "```\nb = ++a + a;\n```", "```\n#include <cstdint>\n\nint main() {\n  auto x = 2.7182818284590452353602874713527L;\n  uint8_t y = x; // Silent truncation\n}\n```", "```\n#include <cstdint>\n\nint main() {\n auto x = 2.7182818284590452353602874713527L;\n  uint8_t y{ x }; // Bang!\n}\n```", "```\n#include <cstdint>\n#include <cstdio>\n\nint main() {\n  // 0b111111111 = 511\n  uint8_t x = 0b111111111; ➊// 255\n  int8_t y =  0b111111111; ➋// Implementation defined.\n  printf(\"x: %u\\ny: %d\", x, y);\n}\n--------------------------------------------------------------------------\nx: 255 ➊\ny: -1 ➋\n```", "```\n#include <limits>\n#include <cstdio>\n\nint main() {\n  double x = std::numeric_limits<float>::max(); ➊\n  long double y = std::numeric_limits<double>::max(); ➋\n  float z = std::numeric_limits<long double>::max(); ➌  // Undefined Behavior\n  printf(\"x: %g\\ny: %Lg\\nz: %g\", x, y, z);\n}\n--------------------------------------------------------------------------\nx: 3.40282e+38\ny: 1.79769e+308\nz: inf\n```", "```\n#include <cstdio>\n\nvoid print_addr(void* x) {\n  printf(\"0x%p\\n\", x);\n}\n\nint main() {\n  int x{};\n  print_addr(&x); ➊\n  print_addr(nullptr); ➋\n}\n--------------------------------------------------------------------------\n0x000000F79DCFFB74 ➊\n0x0000000000000000 ➋\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nint main() {\n  int32_t a = 100;\n  int64_t b{ a }; ➊\n  if (a == b) printf(\"Non-narrowing conversion!\\n\"); ➋\n  //int32_t c{ b }; // Bang! ➌\n}\n--------------------------------------------------------------------------\nNon-narrowing conversion! ➋\n```", "```\n#include <limits>\n#include <cstdio>\n#include <cstdint>\n\nint main() {\n  int64_t b = std::numeric_limits<int64_t>::max();\n  int32_t c(b); ➊ // The compiler abides.\n  if (c != b) printf(\"Narrowing conversion!\\n\"); ➋\n}\n--------------------------------------------------------------------------\nNarrowing conversion! ➋\n```", "```\n(desired-type)object-to-cast\n```", "```\n#include <cstdio>\n\nvoid trainwreck(const char* read_only) {\n  auto as_unsigned = (unsigned char*)read_only;\n  *as_unsigned = 'b'; ➊ // Crashes on Windows 10 x64\n}\n\nint main() {\n  auto ezra = \"Ezra\";\n  printf(\"Before trainwreck: %s\\n\", ezra);\n  trainwreck(ezra);\n  printf(\"After trainwreck: %s\\n\", ezra);\n}\n--------------------------------------------------------------------------\nBefore trainwreck: Ezra\n```", "```\n#include <cstdio>\n\nvoid trainwreck(const char* read_only) {\n  auto as_unsigned = reinterpret_cast<unsigned char*>(read_only); ➊\n  *as_unsigned = 'b'; // Crashes on Windows 10 x64\n}\n\nint main() {\n  auto ezra = \"Ezra\";\n  printf(\"Before trainwreck: %s\\n\", ezra);\n  trainwreck(ezra);\n  printf(\"After trainwreck: %s\\n\", ezra);\n}\n```", "```\nstruct MyType {\n  operator destination-type() const {\n    // return a destination-type from here.\n  --snip--\n  }\n}\n```", "```\nstruct ReadOnlyInt {\n  ReadOnlyInt(int val) : val{ val } { }\n  operator int() const { ➊\n    return val;\n  }\nprivate:\n  const int val;\n};\n```", "```\nstruct ReadOnlyInt {\n  --snip--\n};\nint main() {\n  ReadOnlyInt the_answer{ 42 };\n  auto ten_answers = the_answer * 10; // int with value 420\n}\n```", "```\nstruct ReadOnlyInt {\n  ReadOnlyInt(int val) : val{ val } { }\n  explicit operator int() const {\n    return val;\n  }\nprivate:\n  const int val;\n};\n```", "```\nstruct ReadOnlyInt {\n  --snip--\n};\nint main() {\n  ReadOnlyInt the_answer{ 42 };\n  auto ten_answers = static_cast<int>(the_answer) * 10;\n}\n```", "```\nstruct Color {\n  float H, S, V;\n};\n```", "```\n#include <cstdint>\nconstexpr uint8_t max(uint8_t a, uint8_t b) { ➊\n  return a > b ? a : b;\n}\nconstexpr uint8_t max(uint8_t a, uint8_t b, uint8_t c) { ➋\n  return max(max(a, b), max(a, c));\n}\nconstexpr uint8_t min(uint8_t a, uint8_t b) { ➌\n  return a < b ? a : b;\n}\nconstexpr uint8_t min(uint8_t a, uint8_t b, uint8_t c) { ➍\n  return min(min(a, b), min(a, c));\n}\nconstexpr float modulo(float dividend, float divisor) { ➎\n  const auto quotient = dividend / divisor; ➏\n  return divisor * (quotient - static_cast<uint8_t>(quotient));\n}\n```", "```\n--snip--\nconstexpr Color rgb_to_hsv(uint8_t r, uint8_t g, uint8_t b) {\n  Color c{}; ➊\n  const auto c_max = max(r, g, b);\n  c.V = c_max / 255.0f; ➋\n\n  const auto c_min = min(r, g, b);\n  const auto delta = c.V - c_min / 255.0f;\n  c.S = c_max == 0 ? 0 : delta / c.V; ➌\n\n  if (c_max == c_min) { ➍\n    c.H = 0;\n    return c;\n  }\n  if (c_max == r) {\n    c.H = (g / 255.0f - b / 255.0f) / delta;\n  } else if (c_max == g) {\n    c.H = (b / 255.0f - r / 255.0f) / delta + 2.0f;\n  } else if (c_max == b) {\n    c.H = (r / 255.0f - g / 255.0f) / delta + 4.0f;\n  }\n  c.H *= 60.0f;\n  c.H = c.H >= 0.0f ? c.H : c.H + 360.0f;\n  c.H = modulo(c.H, 360.0f); ➎\n  return c;\n}\n```", "```\n--snip--\nint main() {\n  auto black   = rgb_to_hsv(0,     0,   0);\n  auto white   = rgb_to_hsv(255, 255, 255);\n  auto red     = rgb_to_hsv(255,   0,   0);\n  auto green   = rgb_to_hsv(  0, 255,   0);\n  auto blue    = rgb_to_hsv(  0,   0, 255);\n  // TODO: Print these, output.\n}\n```", "```\nint foo(int& x) {\n  x = 10; ➊\n  x = 20; ➋\n  auto y = x; ➌\n  y = x; ➍\n  return y;\n}\n```", "```\nint foo(int& x) {\n  x = 20;\n  return x;\n}\n```", "```\nint foo(volatile int& x) {\n  x = 10;\n  x = 20;\n  auto y = x;\n  y = x;\n  return y;\n}\n```"]