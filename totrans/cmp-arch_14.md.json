["```\nLDA #$00  ; load to accumulator the constant 8-bit hex integer 00\nSTA $0200 ; store accumulator contents to 16-bit hex address 0200\nLDX $0200 ; load contents of address 0200 to register X\nSTX $0201 ; store contents of X into address 0201\nLDY #$03  ; load 8-bit constant hex 03 to register Y\nSTY $0202 ; store contents of Y to address 0202\n```", "```\nLDX #$01\nSTA $0200,X ; store the value of A at memory location $0201\n```", "```\nLDA ($c000) ; load to A from the address stored at address C000\n```", "```\nLDA ($01),Y\n```", "```\nLDA $12   ; single byte address assumed to be from page 0\n```", "```\nCLC       ; clear content of carry flag in status register\nLDA #$07  ; load constant 07 to accumulator\nSTA $0200 ; store content of accumulator to address 0200\nLDA #$03  ; load constant 03 to accumulator\nADC $0200 ; add with carry the content of 0200 into accumulator\n```", "```\nCLC\nLDA num1_low\nADC num2_low\nSTA result_low\nLDA num1_high\nADC num2_high\nSTA result_high\n```", "```\nSEC       ; set carry flag to 1 (needed to init subtraction)\nLDA #$03  ; load constant 3 to accumulator\nSTA $0200 ; store constant 3 to address 0200\nLDA #$07  ; load constant 7 to accumulator\nSBC $0200 ; subtract content of 0200 from accumulator\n```", "```\nLDX #$02\nLDY #$04\nINX\nDEY\nLDA #$07\nSTA $0200\nINC $0200\nDEC $0200\n```", "```\nLDX #$02\nmylabel:\n  INX\n  JMP mylabel\n```", "```\nLDX #$05\nmylabel:\n  DEX\n  CPX #$02\n  BNE mylabel\n```", "```\nLDA #$5    ; load first argument to accumulator\nSTA $0001  ; put it in address 1 for sub to pick up\nLDA #$4    ; load second argument to accumulator\nSTA $0002  ; put it in address 2 for sub to pick up\nJSR mysub  ; call the subroutine\nSTA $0200  ; use subroutine's result, is in accumulator\nBRK        ; halt\nmysub:\n  LDA #$00   ; reset the accumulator\n  CLC        ; reset the carry\n  ADC $0001  ; add in the first argument\n  ADC $0002  ; add in the second argument\n  RTS        ; return from subroutine\n```", "```\nscreenbeg = $0400           ; const, beginning of screen memorymap\nscreenend = $07E7           ; const, end of screen memorymap\nscreenpos = $8000           ; variable, current position in screen\nmain:\n    LDA #$02                ; black color code\n    STA $D020               ; I/O border color\n    STA $D021               ; I/O background color\n    STA screenpos           ; screen position\nloop:                       ; main game loop, once per frame\n    JSR $E544               ; ROM routine, clears screen\n    JSR drawframe           ; most of the work is done here\n    JSR check_keyboard\n    INC screenpos           ; increment current screen position\n    JMP loop                ; do the loop, forever\ndrawframe:\n    LDX #$00                ; regX tracks idx of char in the string\n    LDY screenpos           ; regY keeps scrolling screen position\n    CPY #$20                ; compare Y with constant 20\n    BCS resetscreenpos      ; branch if Y>20 (stored in carry bit)\ndrawmsgloop:                ; drop through to here if not branching\n    LDA msg,X               ; load the xth char of the message\n    BEQ return              ; exit when zero char (end of string)\n    AND #$3F                ; convert ASCII to PETSCII\n    STA screenbeg,Y         ; VDU: write char in A to memorymap offset Y\n    INX                     ; increment idx of char in message\n    INY                     ; increment location on screen\n    CPY #$20                ; are we trying to write offscreen?\n    BCS wraparound_y        ; if so, shift offset by screen width\n    JMP drawmsgloop         ; loop (until all chars are done)\nresetscreenpos:\n    LDY #$00\n    STY screenpos           ; reset the screenpos to 0\n    JMP drawmsgloop\nwraparound_y:               ; if Y trying to write off screen, wrap\n    TYA                     ; transfer Y to accumulator\n    SBC #$20                ; subtract with carry\n    TAY                     ; transfer accumulator to Y\n    JMP drawmsgloop\ncheck_keyboard:\n    JSR $FF9F               ; ROM SCANKEY IO, writes keybdmatrix to 00CB\n    JSR $FFE4               ; ROM GETIN, convert matrix to keycode in acc\n    CMP #65                 ; compare accumulator to ASCII 'A'\n    BNE return\n    BRK                     ; if 'A' pressed, quit\nreturn:\n    RTS\nmsg:\n    .byte \"HELLO C64!\\0\"    ; this is data, not an instruction\n```", "```\nmain:\n    LDA #$0F\n    STA $D418 ; I/O SID volume\n    LDA #$BE  ; attack duration = B, decay duration = E\n    STA $D405 ; I/O SID ch1 attack and decay byte\n    LDA #$F8  ; sustain level = F, release duration = 8\n    STA $D406 ; I/O SID ch1 sustain and release byte\n    LDA #$11  ; frequency high byte = 11\n    STA $D401 ; I/O SID ch1 frequency high byte\n    LDA #$25  ; frequency low byte = 25\n    STA $D400 ; I/O SID ch1 frequency low byte\n    LDA #$11  ; id for square wave waveform\n    STA $D404 ; I/O SID ch1 ctl register\nloop:\n    JMP loop\n```", "```\nmove.l d0, d1         ; copy from register d0 to register d1\nmove.l #$1a2, d1      ; copy hex constant $1a2 to register d1\nmove.l $0a3ff24, d1   ; load longword from address 0a3ff24 to d1\nmove.l d1, $0a3ff24   ; store longword from d1 to address 0a3ff24\n```", "```\nmove.b d0, d1\nmove.w $0a3ff24, d1\n```", "```\nmove.l ($0a3ff24), d1  ; load content from addr stored at addr 0a3ff24, to d1\n```", "```\nmove.l (pc, 2), d1      ; load content from program counter plus 2\nmove.l (a1, a2), d1     ; load content from addr formed as sum of regs a1+a2\nmove.l (a1, a2, 2), d1  ; load content from addr formed as sum of regs a1+a2+2\n```", "```\nmove.l (a1)+, d1        ; load content from addr stored in register a1, to d1,\n                        ; then increment a1 by number of bytes in a longword\nmove.l -(a1), d1        ; decrement a1 by number of bytes in a longword,\n                        ; then load content from addr stored in register a1\n```", "```\nmove.w (sp)+, d0       ; push from register d0 to stack\nmove.w d0, -(sp)       ; pop from stack to register d0\n```", "```\nlea (pc, 2), a1     ; put address of program counter +2 bytes into a1\nlea (a1, 2), a3     ; put address a1+2 into a3\nlea (a1, a2, 2), a3 ; put address a1+a2+2 into a3\n```", "```\nstart:\n   jsr mysub        ; jump to subroutine\n\n   cmp #2, d0       ; compare values\n   beq mylabel      ; branch if equal\n   ble start        ; branch if less than or equal\n   bne start        ; branch if not equal\n\nmylabel:\n   jmp mylabel      ; infinite loop\n\nmysub:\n   rts              ; return from subroutine\n```", "```\nadd.b d0, d4  ; add d0 to d4, store result in d4\nsub.w #43, d4 ; subtract constant 43 from d4, store result in d4\nmuls d0, d4   ; multiply (signed) d0 with d4, store result in d4\nmulu d0, d4   ; multiply (unsigned) d0 with d4, store result in d4\ndivs d0, d4   ; divide (signed) d0 by d4, store result in d4\ndivu d0, d4   ; divide (unsigned) d0 by d4, store result in d4\nand d0, d1    ; bitwise and d0 with d1, store result in d1\nasr d0, d1    ; arithmetic shift right d1 by d0 bits, store result in d1\n```", "```\ncustom      equ   $dff000     ; custom chips\nbplcon0     equ   $100        ; bitplane control register 0 (misc, control bits)\nbplcon1     equ   $102        ; bitplane control register 1 (horizontal, scroll)\nbplcon2     equ   $104        ; bitplane control register 2 (priorities, misc)\nbpl1mod     equ   $108        ; bitplane modulo\nddfstrt     equ   $092        ; data-fetch start\nddfstop     equ   $094        ; data-fetch stop\ndiwstrt     equ   $08E        ; display window start\ndiwstop     equ   $090        ; display window stop\ncopjmp1     equ   $088        ; copper restart at first location\ncop1lc      equ   $080        ; copper list pointer\ndmacon      equ   $096        ; DMA controller\nsprpt       equ   $120        ; sprite pointer\n\nCOLOR00     equ   $180        ; address to store COLOR00 (background)\nCOLOR01     equ   COLOR00+$02 ; address to store COLOR01 (foreground)\nCOLOR17     equ   COLOR00+$22 ; etc\nCOLOR18     equ   COLOR00+$24\nCOLOR19     equ   COLOR00+$26\nBPL1PTH     equ   $0E0        ; bitplane 1 pointer hi byte\nBPL1PTL     equ   BPL1PTH+$02 ; bitplane 1 pointer lo byte\nSPR0PTH     equ   sprpt+$00   ; sprite0 pointer, hi byte\nSPR0PTL     equ   SPR0PTH+$02 ; sprite0 pointer, lo byte\nSPR1PTH     equ   sprpt+$04   ; sprite1 etc\nSPR1PTL     equ   SPR1PTH+$02\nSPR2PTH     equ   sprpt+$08\nSPR2PTL     equ   SPR2PTH+$02\nSPR3PTH     equ   sprpt+$0C\nSPR3PTL     equ   SPR3PTH+$02\nSPR4PTH     equ   sprpt+$10\nSPR4PTL     equ   SPR4PTH+$02\nSPR5PTH     equ   sprpt+$14\nSPR5PTL     equ   SPR5PTH+$02\nSPR6PTH     equ   sprpt+$18\nSPR6PTL     equ   SPR6PTH+$02\nSPR7PTH     equ   sprpt+$1C\nSPR7PTL     equ   SPR7PTH+$02\n\nSHIPSPRITE equ $25000         ; address to store our ship sprite\nDUMMYSPRITE equ $30000        ; address to store our dummy sprite\nCOPPERLIST equ $20000         ; address to store our copper list\nBITPLANE1   equ $21000        ; address to store our bitplane data\n\n; Define bitplane1\n        lea     custom,a0               ; a0 := address of custom chips\n        move.w  #$1200,bplcon0(a0)      ; 1 bitplane color\n        move.w  #$0000,bpl1mod(a0)      ; modulo := 0\n        move.w  #$0000,bplcon1(a0)      ; horizontal scroll value := 0\n        move.w  #$0024,bplcon2(a0)      ; give sprites priority over playfields\n        move.w  #$0038,ddfstrt(a0)      ; data-fetch start\n        move.w  #$00D0,ddfstop(a0)      ; data-fetch stop\n\n; Define display window\n        move.w  #$3c81,diwstrt(a0)      ; set window start (hi byte = vertical, lo = horiz*2)\n        move.w  #$ffc1,diwstop(a0)      ; set window stop (hi byte = vertical, lo = horiz*2)\n\n; Put RGB constants defining colors into the color registers\n        move.w  #$000f,COLOR00(a0)      ; set color 00 (background) to blue (00f)\n        move.w  #$0000,COLOR01(a0)      ; set color 01 (foreground) to black (000)\n        move.w  #$0ff0,COLOR17(a0)      ; Set color 17 to yellow (ff0)\n        move.w  #$00ff,COLOR18(a0)      ; Set color 18 to cyan (0ff)\n        move.w  #$0f0f,COLOR19(a0)      ; Set color 19 to magenta (f0f)\n\n; Copy copper list data to addresses starting at COPPERLIST\n        move.l #COPPERLIST,a1           ; a1 := copper list destination\n        lea     copperl(pc),a2          ; a2 := copper list source\ncloop:\n        move.l  (a2),(a1)+              ; copy DMA command\n        cmp.l   #$fffffffe,(a2)+        ; end of list?\n        bne     cloop                   ; loop until whole list moved\n\n; Copy sprite to addresses starting at SHIPSPRITE\n        move.l  #SHIPSPRITE,a1          ; a1 := sprite destination\n        lea     sprite(pc),a2           ; a2 := sprite source\nsprloop:\n        move.l  (a2),(a1)+              ; copy DMA command\n        cmp.l   #$00000000,(a2)+        ; end of sprite?\n        bne     sprloop                 ; loop until whole sprite moved\n\n; All eight sprites are activated at the same time but we will only use one\n; Write a blank sprite to DUMMYSPRITE, so the other sprites can point to it\n        move.l #$00000000,DUMMYSPRITE\n\n; Point copper at our copper list data\n        move.l #COPPERLIST,cop1lc(a0)\n\ngameloop:\n\n; Fill bitplane pixels with foreground color (1-bit plane in fore/background colors)\n        move.l #BITPLANE1,a1            ; a1 := bitplane\n        move.w #1999,d0                 ; 2000-1(for dbf) long words = 8000 bytes\nfloop:\n        move.l #$ffffffff,(a1)+         ; put bit pattern $ffffffff as next row of 16*8 pixels\n        dbf    d0,floop                 ; decrement, repeat until false\n\n; start DMA, to blit the sprite onto the bitplane\n        move.w  d0,copjmp1(a0)          ; force load to copper program counter\n        move.w #$83A0,dmacon(a0)        ; bitplane, copper, and sprite DMA\n\n    ;**your game logic would go here---read keyboard, move sprites**\n\n    jmp gameloop\n\n; Copper list for one bitplane, and eight sprites. Bitplane is at BITPLANE1\n; Sprite 0 is at SHIPSPRITE; other (dummy) sprites are at DUMMYSPRITE\ncopperl:\n        dc.w    BPL1PTH,$0002           ; bitplane 1 pointer := BITPLANE1\n        dc.w    BPL1PTL,$1000\n        dc.w    SPR0PTH,$0002           ; sprite 0 pointer := SHIPSPRITE\n        dc.w    SPR0PTL,$5000\n        dc.w    SPR1PTH,$0003           ; sprite 1 pointer := DUMMYSPRITE\n        dc.w    SPR1PTL,$0000\n        dc.w    SPR2PTH,$0003           ; sprite 2 pointer := DUMMYSPRITE\n        dc.w    SPR2PTL,$0000\n        dc.w    SPR3PTH,$0003           ; sprite 3 pointer := DUMMYSPRITE\n        dc.w    SPR3PTL,$0000\n        dc.w    SPR4PTH,$0003           ; sprite 4 pointer := DUMMYSPRITE\n        dc.w    SPR4PTL,$0000\n        dc.w    SPR5PTH,$0003           ; sprite 5 pointer := DUMMYSPRITE\n        dc.w    SPR5PTL,$0000\n        dc.w    SPR6PTH,$0003           ; sprite 6 pointer := DUMMYSPRITE\n        dc.w    SPR6PTL,$0000\n        dc.w    SPR7PTH,$0003           ; sprite 7 pointer := DUMMYSPRITE\n        dc.w    SPR7PTL,$0000\n        dc.w    $ffff,$fffe             ; copper list end\n\n; Sprite data. Stores (x,y) screen coordinate and image data\nsprite:\n        dc.w    $6da0,$7200             ; 6d = y location; a0 = x location; 72-6d = 5 = height)\n\n        dc.w    $0000,$0ff0             ; image data, 5 rows x 16 cols x 2 bit color\n        dc.w    $0000,$33cc             ; each line describes one row of 16 pixels\n        dc.w    $ffff,$0ff0             ; each pixel is described by a 2-bit color\n        dc.w    $0000,$3c3c             ; the low pixel bits form the first word\n        dc.w    $0000,$0ff0             ; the high pixel bits form the second word\n\n        dc.w    $0000,$0000             ; ... all zeros marks end of image data\n\n```", "```\n    > git clone [https://github.com/charles-fox/easy6502.git](https://github.com/charles-fox/easy6502.git)\n    > cd easy6502\n    ```", "```\n          processor 6502          ; define processor family for das\n          org $C000               ; memory location for our code\n    ```", "```\n    > dasm hello.asm -ohello.prg\n    ```", "```\n    > make CPU=m68k SYNTAX=mot\n    ```", "```\n    > ./vasmm68k_mot -kick1hunks -Fhunkexe -o myexe -nosym myprog.asm\n    ```", "```\n    > xdftool mydisc.adf create\n    > xdftool mydisc.adf format \"title\"\n    > xdftool mydisc.adf write myexe\n    > xdftool mydisc.adf boot install\n    > xdftool mydisc.adf makedir S\n    > echo myexe > STARTUP-SEQUENCE\n    > xdftool mydisc.adf write STARTUP-SEQUENCE S/\n    ```"]