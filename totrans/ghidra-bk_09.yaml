- en: '## **7'
  prefs: []
  type: TYPE_NORMAL
- en: DISASSEMBLY MANIPULATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After navigation, disassembly modification is the next most significant feature
    of Ghidra. Ghidra offers the ability to easily manipulate disassemblies to add
    new information or reformat a listing to suit your particular needs, and because
    of Ghidra’s underlying structure, changes that you make to a disassembly are easily
    propagated to all associated Ghidra views to maintain a consistent picture of
    your program. Ghidra automatically handles operations such as context-aware search
    and replace when it makes sense to do so, and it makes trivial work of reformatting
    instructions as data, and data as instructions. And perhaps the best feature is
    that almost anything you do can be undone!
  prefs: []
  type: TYPE_NORMAL
- en: '**I WISH I HADN’T DONE THAT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of being good at software reverse engineering is the ability to explore,
    experiment, and, when necessary, backtrack and retrace your steps. Ghidra’s powerful
    Undo capability allows you the flexibility to undo (and redo) actions during the
    SRE process. Multiple methods are available to access this magical power: the
    appropriate arrow icons in the CodeBrowser toolbar ➊➋, as shown in [Figure 7-1](ch07.xhtml#fig7_1);
    Edit ▸ Undo from the CodeBrowser menu; and the hotkeys CTRL-Z to undo and CTRL-SHIFT-Z
    to redo.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Undo and Redo icons in the CodeBrowser toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating Names and Labels**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we have encountered two categories of identifiers in Ghidra
    disassemblies: labels (which are identifiers associated with locations) and names
    (which are identifiers associated with stack frame variables). For the most part,
    we will refer to both as *names*, as Ghidra is somewhat loose in this distinction
    also. (If you want to be really precise, labels actually have associated names,
    addresses, histories, and so on. The name of the label is how we generally reference
    the label.) We use more specific terms when the distinction makes a critical difference.'
  prefs: []
  type: TYPE_NORMAL
- en: To review, stack variable names have one of two prefixes based on whether the
    variable is a parameter (`param_`) or a local variable (`local_`), and locations
    are assigned names/labels with helpful prefixes during auto analysis (for example,
    `LAB_`, `DAT_`, `FUN_`, `EXT_`, `OFF_`, and `UNK_`). In most cases, Ghidra will
    automatically generate names and labels based on its best guess about the use
    of the associated variable or address, but you will need to analyze the program
    yourself to understand the purpose of a location or variable.
  prefs: []
  type: TYPE_NORMAL
- en: As you begin to analyze any program, one of the first and most common ways to
    manipulate a disassembly listing is to change default names into more meaningful
    names. Fortunately, Ghidra allows you to easily change any name, and it intelligently
    propagates name changes throughout the entire program. To open a name-change dialog,
    select the name by clicking it and then use the L hotkey or the Edit Label option
    on the right-click context menu. From there, the process for stack variables (names)
    and named locations (labels) varies, as detailed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Renaming Parameters and Local Variables***'
  prefs: []
  type: TYPE_NORMAL
- en: Names associated with stack variables are not associated with a specific virtual
    address. As in most programming languages, such names are restricted to the scope
    of the function to which a given stack frame belongs. Thus, every function in
    a program can have its own stack variable named `param_1`, but no function may
    have more than one variable named `param_1`, as shown in [Figure 7-2](ch07.xhtml#fig7_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Symbol Tree showing reuse of parameter names* (param_1)'
  prefs: []
  type: TYPE_NORMAL
- en: When you rename a variable in the Listing window, the informative dialog shown
    in [Figure 7-3](ch07.xhtml#fig7_3) will pop up. The type of entity you are changing
    (variable, function, and so on) appears in the title bar of the window, and the
    current (about to be changed) name appears in the editable text box and the title
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Renaming a stack variable* (local_14 to y)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a new name is supplied, Ghidra changes every occurrence of the old name
    in the current function. The following listing shows the result of renaming `local_14`
    to `y` in `demo_stackframe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These changes ➊➋➌ are also reflected in the Symbol Tree, as shown in [Figure
    7-4](ch07.xhtml#fig7_4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Symbol Tree view of renamed stack variable,* y'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE FORBIDDEN NAMES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting rules restrict what you can name variables within a function.
    Here are some of the more relevant rules for parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: You *can’t* use the prefix `param_` followed by an integer in a name, even if
    the resulting name does not conflict with an existing parameter name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *can* use the prefix `param_` followed by other characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *can* use the prefix `Param_` followed by an integer, as names are case-sensitive
    (but it might not be advisable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *can* restore a parameter name to its original Ghidra-assigned name by entering
    `param_` followed by an integer value. If you use the original integer value,
    Ghidra will revert the name with no complaints. If you use any integer other than
    the original value, Ghidra will warn “Rename failed – default names may not be
    used*.*” At this point, clicking Cancel in the Rename Parameter dialog will restore
    the original name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You *can* have two parameters with the names `param_1` (named by Ghidra) and
    `Param_1` (named by you). Names are case-sensitive, but it might not be advisable
    to reuse them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables are also case-sensitive, and you can use the prefix `local_`
    with a non-numeric suffix.
  prefs: []
  type: TYPE_NORMAL
- en: For all types of variables, you *can’t* use a variable name that’s already used
    in that scope (for example, in the same function). Your attempt will be rejected
    with a reason in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you are thoroughly confused by your labels, you can see the label
    history for a variable by pressing the hotkey H, choosing Show All History, and
    entering the current name (or a past name) of the variable into the text box.
    (This option is also available through Search ▸ Label History in the main menu.)
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE SHOULD YOU CHANGE YOUR NAME?**'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names can be changed from the Listing, Symbol Tree, and Decompiler
    windows; the outcome is the same regardless, but the dialog accessed from the
    Listing window presents more information. All rules associated with naming variables
    are enforced when using any of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the example parameter names in this book were changed in the Listing
    window using the dialog shown on the left in [Figure 7-5](ch07.xhtml#fig7_5).
    To change a name in the Symbol Tree, right-click the name and select **Rename**
    from the context menu. In the Decompiler window, use the hotkey L, or use the
    **Rename Variable** context menu option; the corresponding dialog is shown on
    the right in [Figure 7-5](ch07.xhtml#fig7_5). While the two dialogs provide the
    same functionality, the right dialog does not include information about the namespace
    or properties associated with the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Renaming a variable from the Listing window or Symbol Tree (left)
    or the Decompiler window (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: In Ghidra, a *namespace* is simply a named scope. Within a namespace, all symbols
    are unique. The global namespace contains all symbols within a binary. Function
    namespaces are nested within the global namespace. Within a function namespace,
    all variable names and labels are unique. Functions may themselves contain nested
    namespaces, such as a namespace associated with a switch statement (which allows
    case labels to be reused in separate namespaces; for example, when a function
    contains two switch statements that each have a case 10).
  prefs: []
  type: TYPE_NORMAL
- en: '***Renaming Labels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A label is a default or user-assigned name associated with a location. As with
    stack variables, the name-change dialog is opened with the hotkey L or context
    option Edit Label. When you change a location’s name, you can also change its
    namespace and properties, as shown in [Figure 7-6](ch07.xhtml#fig7_6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: Renaming a function*'
  prefs: []
  type: TYPE_NORMAL
- en: This enhanced dialog shows the entity type and virtual address of the location
    in the title bar. Under Properties, you can identify the address as an entry point
    or pin the address (see “[Editing Labels](ch07.xhtml#ch07lev122)” on [page 126](ch07.xhtml#page_126)).
    As mentioned in [Chapter 6](ch06.xhtml#ch06), Ghidra limits names to a maximum
    of 2000 characters, so feel free to use meaningful names or even embed a narrative
    about the address (without any spaces). The Listing window will display only a
    portion of the name if the length is excessive, but the Decompiler window shows
    the entire thing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding a New Label***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Ghidra generates many default labels, you can also add new labels and
    associate them with any address in the listing. These can be used to annotate
    your disassembly, although in many cases *comments* (discussed later in this chapter)
    are a more appropriate mechanism for this. To add a new label, open the Add Label
    dialog (hotkey L), shown in [Figure 7-7](ch07.xhtml#fig7_7), for the address associated
    with the cursor location. The drop-down list for the name includes a list of names
    you have used recently, and the Namespace drop-down list lets you choose an appropriate
    label scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Add Label dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: '**FUN_ WITH PREFIXES**'
  prefs: []
  type: TYPE_NORMAL
- en: When Ghidra creates labels during auto analysis, it uses meaningful prefixes
    followed by an address to let you know what to expect at that location. These
    prefixes are listed next with very general descriptions. More information about
    the meaning of each prefix can be found in Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: LAB_address Code—an auto-generated label (usually a jump target within a function)
  prefs: []
  type: TYPE_NORMAL
- en: DAT_address Data—an auto-generated global variable name
  prefs: []
  type: TYPE_NORMAL
- en: FUN_address Function—an auto-generated function name
  prefs: []
  type: TYPE_NORMAL
- en: SUB_address Target of a call (or equivalent)—probably not a function
  prefs: []
  type: TYPE_NORMAL
- en: EXT_address External entry point—probably someone else’s function
  prefs: []
  type: TYPE_NORMAL
- en: OFF_address An offcut (inside existing data or code)—probably a disassembly
    error
  prefs: []
  type: TYPE_NORMAL
- en: UNK_address Unknown—the purpose of the data here can’t be determined
  prefs: []
  type: TYPE_NORMAL
- en: 'Function labels have the following specific behaviors associated with them:'
  prefs: []
  type: TYPE_NORMAL
- en: If you delete a default function label (such as `FUN_08048473`) in the Listing
    window, the `FUN_` prefix will be replaced by the `SUB_` prefix (in this case,
    resulting in `SUB_08048473`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new label to an address that has a default `FUN_` label changes the
    function name rather than creating a new label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels are case-sensitive, so you can use `Fun_` or `fun_` as a valid prefix
    if your desire is to create a confusing disassembly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run into conflicts if you attempt to use one of Ghidra’s reserved prefixes
    when entering a name. If you insist on using a reserved prefix, Ghidra will reject
    your new label if it believes that a name conflict might arise. This occurs only
    when Ghidra determines that your suffix looks like an address (in our experience,
    this means four or more hex digits). For example, Ghidra will allow `FUN_zone`
    and `FUN_123`, but will reject `FUN_12345`. Also, if you attempt to add a label
    at the same address as a function that has a default label (for example, `FUN_08048473`),
    Ghidra renames the function rather than adding a second label at that location.
  prefs: []
  type: TYPE_NORMAL
- en: '***Editing Labels***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To edit a label, use the hotkey L or context menu option Edit Label. Editing
    a label presents you with the same dialog as adding a label, except that the fields
    in the dialog will be initialized with the current values for the existing label.
    Note that editing labels can have an effect on other labels that share the same
    address, whether or not they share the same namespace. For example, if you identify
    a label as an entry point, Ghidra will identify all labels associated with that
    location as entry points.
  prefs: []
  type: TYPE_NORMAL
- en: '**IS IT A BUG OR A FEATURE?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the course of experimenting with function names, you may notice that Ghidra
    is perfectly content to allow you to give two functions the same name. This may
    elicit flashbacks to overloaded functions, which can be distinguished by the parameters
    they are passed. Ghidra’s capability extends beyond this: you can give two functions
    the exact same name even if this results in duplicate function prototypes within
    the same namespace. This is possible because a label is not a unique identifier
    (primary key in the database sense) and thus does not uniquely identify a function,
    even when considered with its associated parameters. Duplicate names can be used
    to tag functions; for example, to classify them for further analysis or eliminate
    them from consideration. Recall that all names are preserved in the function history
    (hotkey H) and can easily be reverted.'
  prefs: []
  type: TYPE_NORMAL
- en: The Primary checkbox in [Figure 7-7](ch07.xhtml#fig7_7) indicates that this
    is the label that will be displayed when the address is displayed. By default,
    this checkbox is disabled for the primary label, so you cannot deselect the primary
    name. This is necessary to ensure that there is always a name to display. If another
    label were chosen as the primary, its checkbox would be disabled, and checkboxes
    for other labels at the same address would be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have, up to now, associated labels with addresses, in reality labels
    are most commonly associated with content that happens to have an address. For
    example, the label `main` typically denotes the beginning of the block of code
    that is the main function in a program. Ghidra assigns an address to this location
    based on file header information. If we were to relocate the entire content of
    the binary to a new address range, we would expect that the label `main` would
    continue to correctly associate with the new address of `main` and its corresponding,
    unchanged byte content. When a label is *pinned*, the label’s association with
    the content at its address is severed. If you were to then relocate the binary’s
    content to a new address range, any pinned labels would not move accordingly,
    but remain fixed to the address that you pinned them to. The most common use of
    pinned labels is to name reset vectors and memory mapped I/O locations that exist
    at specific addresses designated by the processor/system designers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Removing a Label***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To remove a label at the cursor, you can use the right-click context option
    (or hotkey DELETE). Be warned that not all labels are removable. First, it is
    impossible to delete a default, Ghidra-generated label. Second, if you have renamed
    a default label and later decide to delete the new label, Ghidra will replace
    the name you are deleting with the originally assigned, default label (this is
    a direct result of the previous statement). The finer details associated with
    removing labels are discussed in Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Navigating Labels***'
  prefs: []
  type: TYPE_NORMAL
- en: Labels are associated with navigable locations, so double-clicking a reference
    to a label will navigate you to that label. While this is discussed more thoroughly
    in [Chapter 9](ch09.xhtml#ch09), remember that you can add labels to any location
    you wish to navigate to in the disassembly. While the same functionality is described
    in “[Annotations](ch07.xhtml#ch07lev131)” on [page 132](ch07.xhtml#page_132),
    sometimes a label (particularly with its 2000-character allowance) is the quickest
    way to accomplish the same goal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedding comments into your disassembly and decompiler listings is a particularly
    useful way to leave notes for yourself regarding your progress and discoveries
    as you analyze a program. Ghidra offers five categories of comments, each suited
    for a different purpose. We begin by looking at comments that we can add directly
    to the disassembly in the Listing window.
  prefs: []
  type: TYPE_NORMAL
- en: While you can navigate to the Set Comment dialog (shown in [Figure 7-8](ch07.xhtml#fig7_8))
    through the right-click context menu, the quickest way is to use the hotkey for
    comments, which is the semicolon (;) key. (This is a logical choice, as the semicolon
    is the comment indicator in many flavors of assembly.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Set Comment dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Set Comment dialog opens in association with a particular address: `08048479`
    in [Figure 7-8](ch07.xhtml#fig7_8), as displayed in the title bar. Any content
    entered into any one of the five comment category tabs (EOL, Pre, Post, Plate,
    and Repeatable Comments) is associated with that address.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, you enter content in the text box, including carriage returns, create
    a comment that is one or more lines long, and then click **Apply** or **OK**.
    (Apply allows you to see the comment in context and keeps the Set Comment dialog
    open for continued editing.) To save time when entering short comments, select
    the **Enter accepts comment** checkbox in the lower left of the dialog. (You can
    always deselect the box temporarily if you are writing a particularly informative
    plate comment.)
  prefs: []
  type: TYPE_NORMAL
- en: '**THOSE THREE BUTTONS**'
  prefs: []
  type: TYPE_NORMAL
- en: Of the three buttons at the bottom of the Set Comment dialog ([Figure 7-8](ch07.xhtml#fig7_8)),
    the OK and Apply buttons behave as you might expect. Clicking OK closes the dialog
    and commits your changes. When you click Apply, the listing is updated so that
    you can examine your changes and approve them or continue editing your comment.
  prefs: []
  type: TYPE_NORMAL
- en: Dismiss, however, is not the same as Cancel, which would exit the dialog with
    no effect on your listing! The unique term is consistent with the unique behavior.
    Clicking the Dismiss button exits the window immediately if you have not modified
    any comments, but lets you decide whether you want to save changes if you did
    modify comments. Closing the window using the X in the top right exhibits the
    same behavior. This Dismiss functionality will be encountered in other places
    within Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: To delete a comment, clear a comment’s text in the Set Comment dialog, or use
    the hotkey DELETE when the cursor is on a comment in the Listing window. Right-clicking
    Comments ▸ Show History for Comment can be used to recall the comments associated
    with a particular address and reinstate them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***End-of-Line Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps the most commonly used type of comment is the *end-of-line (EOL) comment*,
    placed at the end of existing lines in the Listing window. To add one, open the
    Set Comment dialog with the semicolon hotkey and select the EOL Comment tab. By
    default, EOL comments are displayed as blue text and will span multiple lines
    if you enter multiple lines in the comment text box. Each line will be indented
    to align at the right side of the disassembly, and existing content will be moved
    down to make space for the new comments. You can edit your comments at any time
    by reopening the Set Comment dialog. The quickest method to delete a comment is
    to click the comment in the Listing window and press DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra itself adds many EOL comments during auto analysis. For example, when
    you load a PE file, Ghidra inserts descriptive EOL comments to describe the fields
    in the `IMAGE_DOS_HEADER` section, including the comment `Magic number`. Ghidra
    is able to do this only when it has this information associated with a particular
    data type. This information is typically contained within type libraries, which
    are displayed in the Data Type Manager window and discussed in depth in [Chapter
    8](ch08.xhtml#ch08) and [Chapter 13](ch13.xhtml#ch13). Among all the comment types,
    EOL comments are the most configurable through the Edit ▸ Tool Options ▸ Listing
    Fields options for each comment type.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Pre and Post Comments***'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pre* and *post comments* are full-line comments that appear either immediately
    before or after a given disassembly line. The following listing shows a multi­line
    pre comment and a truncated single-line post comment, associated with address
    `08048476`. Hovering over a truncated comment will display the complete comment.
    By default, pre comments are displayed in purple, and post comments are displayed
    in blue, so that you can easily associate them with the correct address in the
    listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '***Plate Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Plate comments* allow you to group comments for display anywhere in the Listing
    window. A plate comment is centered and placed within an asterisk-bounded rectangle.
    Many of the listings we have examined include a simple plate comment with the
    word `FUNCTION` inside the bounding box, as shown in [Figure 7-9](ch07.xhtml#fig7_9).
    This example includes the associated Decompiler window on the right side so you
    can see that, in this default presentation, a plate comment has been inserted
    in the Listing window, but no corresponding comment exists in the Decompiler window.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Plate comment example*'
  prefs: []
  type: TYPE_NORMAL
- en: When you open the comment dialog with the first address in the function selected,
    you have the option to replace this general plate comment with your own, more
    informative one, as shown in [Figure 7-10](ch07.xhtml#fig7_10). In addition to
    replacing the default plate comment, Ghidra adds your comment as a C-style comment
    at the top of the Decompiler window. If the cursor were at the top of the Decompiler
    window when the plate comment was created, the result would have been the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Custom plate comment example*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Only plate and pre comments are displayed in the Decompiler window by default,
    although you can change this using options in Edit ▸ Tool Options ▸ Decompiler
    ▸ Display.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Repeatable Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *repeatable comment* is entered once but may appear automatically in many
    locations throughout the disassembly. The behavior of repeatable comments is tied
    to the concept of cross-references, which are discussed in depth in [Chapter 9](ch09.xhtml#ch09).
    Basically, a repeatable comment entered at the target of a cross-reference is
    echoed at the source of a cross-reference. As a result, a single repeatable comment
    may be echoed at many locations in the disassembly (because cross-references can
    be many-to-one). In a disassembly listing, the default color is orange for repeatable
    comments and gray for echoed comments, making them easily distinguishable from
    other types of comments. The following listing demonstates the use of a repeatable
    comment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the listing, a repeatable comment is set at `08048446` ➋ and repeated at
    `08048432` ➊ because the instruction at `08048432` refers to address `08048446`
    as a jump target (thus a cross-reference exists from `08048432` to `08048446`).
  prefs: []
  type: TYPE_NORMAL
- en: When an EOL comment and a repeatable comment share the same address, only the
    EOL comment is visible in the listing. Both comments can be viewed and edited
    in the Set Comment dialog. If you delete the EOL comment, the repeatable comment
    will become visible in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parameter and Local Variable Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To associate a comment with a stack variable, select the stack variable and
    use the semicolon hotkey. [Figure 7-11](ch07.xhtml#fig7_11) shows the resulting
    minimal comment window. The comment will be displayed next to the stack variable
    in a truncated format similar to an EOL comment. Hovering over the comment will
    display it in its entirety. The color of the comment matches the default color
    of the variable type, rather than the blue default for EOL comments.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Stack variable comment*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Annotations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ghidra provides a powerful capability to annotate comments with links to programs,
    URLs, addresses, and symbols in its Set Comment dialog. Symbol information in
    comments will automatically update when symbol names are changed. When you use
    an annotation to launch a specified executable, you can provide optional parameters
    to gain even more control (yes, that sounds dangerous to us, too).
  prefs: []
  type: TYPE_NORMAL
- en: For example, the annotation on a plate comment in [Figure 7-12](ch07.xhtml#fig7_12)
    provides a hyperlink to an address in the listing. Additional information about
    the power of annotations is provided in Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Address annotation example*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Code Transformations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, you will be perfectly content with the disassembly listings that
    Ghidra generates. In some cases, however, you won’t. As the types of files that
    you analyze diverge further and further from ordinary executables generated with
    common compilers, you may need to take more control of the disassembly analysis
    and display processes. This will be especially true if you analyze obfuscated
    code or files that utilize a custom (unknown to Ghidra) file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghidra facilitates the following code transformations (among others):'
  prefs: []
  type: TYPE_NORMAL
- en: Changing code display options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting instruction operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting data into code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting code into data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, if a binary is very complex, or if Ghidra is not familiar with the
    code sequences generated by the compiler used to build the binary, then Ghidra
    will encounter more problems during the analysis phase, and you will need to make
    manual adjustments to the disassembled code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Changing Code Display Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ghidra allows very fine-grained control over the formatting of lines within
    the Listing window. Layout is controlled with the Browser Field Formatter (introduced
    in [Chapter 5](ch05.xhtml#ch05)). Selecting the Browser Field Formatter icon opens
    a tabbed display of all the fields associated with your listing, as displayed
    in [Figure 5-8](ch05.xhtml#fig5_8). You can add, delete, and rearrange fields
    by using a simple drag-and-drop interface that allows you to immediately observe
    the changes in your listing. The tight association between an item in the listing
    field and in the associated Browser Field Formatter is very useful. Anytime you
    move the cursor to a new location in the Listing window, the Browser Field Formatter
    moves the appropriate tab and associated field so that you can immediately identify
    options associated with a particular item. See “[Special Tool Editing Features](ch12.xhtml#ch12lev212)”
    on [page 247](ch12.xhtml#page_247) for additional discussion of the Browser Field
    Formatter.
  prefs: []
  type: TYPE_NORMAL
- en: To control the appearance of individual elements within the Listing window,
    you can select Edit ▸ Tool Options, as described in [Chapter 4](ch04.xhtml#ch04).
    The unique submenus for each field in the Listing window allow you to fine-tune
    each field to your liking. While the capabilities associated with each field vary,
    in general you can control display colors, associated default values, configurations,
    and formats. For example, users who love assembly code and read it in their spare
    time may choose to adjust the default parameters in the EOL Comments Field area,
    shown in [Figure 7-13](ch07.xhtml#fig7_13), to activate the Show Semicolon at
    Start of Each Line option in order to view the assembly comments in a familiar
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Tool Options menu for EOL Comments Field*'
  prefs: []
  type: TYPE_NORMAL
- en: To color the background for individual lines or larger selections in the Listing
    window, select the Colors option through the right-click context menu and choose
    a color. The range of available colors is extensive, and a quick pick option is
    provided for recently used colors. Through the same menu, you can also clear the
    background color for a line, a selection, or an entire file.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clearing options do not appear if no colors are currently set for the listing.*'
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Formatting Instruction Operands***'
  prefs: []
  type: TYPE_NORMAL
- en: During the auto analysis process, Ghidra makes many decisions regarding how
    to format operands associated with each instruction, especially various integer
    constants used by a wide variety of instruction types. Among other things, these
    constants can represent relative offsets in jump or call instructions, absolute
    addresses of global variables, values to be used in arithmetic operations, or
    programmer-defined constants. To make a disassembly more readable, Ghidra attempts
    to use symbolic names rather than numbers whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, formatting decisions are made based on the context of the instruction
    being disassembled (such as a call instruction); in other cases, the decision
    is based on the data being used (such as access to a global variable or an offset
    into a stack frame or structure). Often, the exact context in which a constant
    is used may not be discernable to Ghidra. When this happens, the constant is typically
    formatted as a hexadecimal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not one of the few people in the world who eat, sleep, and breathe
    hex, then you will welcome Ghidra’s operand-formatting features. Assume that you
    have the following in your disassembly listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Right-clicking the hex constant `0x41` opens the context-sensitive menu shown
    in [Figure 7-14](ch07.xhtml#fig7_14). (See [Figure 6-7](ch06.xhtml#fig6_7) for
    this example in context.) The constant can be reformatted in the various numeric
    representations displayed on the right side of the figure, or as a character constant
    (since this value also falls within the ASCII printable range). This can be a
    very helpful feature as you may not realize the many representations that can
    be associated with a given constant. In all cases, the menu displays the exact
    text that will replace the operand text should a particular option be selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Formatting options for constants*'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, programmers use named constants in their source code. Such constants
    may be the result of `#define` statements (or their equivalent), or they may belong
    to a set of enumerated constants. Unfortunately, by the time a compiler is finished
    with the source code, it is no longer possible to determine whether the source
    used a symbolic constant or a literal, numeric constant. Fortunately, Ghidra maintains
    a large catalog of named constants associated with many common libraries, such
    as the C standard library or the Windows API. This catalog is accessible via the
    Set Equate option (hotkey E) on the context-sensitive menu associated with any
    constant value. Selecting this option for the constant `0xa` opens the Set Equate
    dialog ([Figure 7-15](ch07.xhtml#fig7_15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Set Equate dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog is populated from Ghidra’s internal list of constants after filtering
    according to the value of the constant we are attempting to format. In this case,
    we can scroll to see all of the constants that Ghidra knows to be equated with
    the value `0xA`. If we determined that the value was being used in conjunction
    with the creation of an X.25-style network connection, we might select `AF_CCITT`
    and end up with the following disassembly line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The list of standard constants is useful to determine whether a particular constant
    may be associated with a known name and can save a lot of time reading through
    API documentation in search of potential matches.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Manipulating Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra provides the capability to manipulate functions in the disassembly (for
    example, correcting which code Ghidra identifies as belonging to functions, or
    changing function attributes), which is especially helpful when you disagree with
    the results of the auto analysis. In some cases, such as when Ghidra fails to
    locate a call to a function, functions may not be recognized, as there may be
    no obvious way to reach them. In other cases, Ghidra may fail to properly locate
    the end of a function, requiring you to correct the disassembly. Ghidra may have
    trouble locating the end of a function if a compiler has split the function across
    several address ranges or when, in the process of optimizing code, a compiler
    merges common end sequences of two or more functions in order to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating New Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: New functions can be created from existing instructions that do not already
    belong to a function. You create functions by right-clicking the first instruction
    to be included in the new function and selecting Create Function (or hotkey F).
    If you selected a range, that will become the function body. If you did not, Ghidra
    will follow the control flow to try to determine the bounds of the function body.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can delete existing functions by placing the cursor within the function
    signature and using the hotkey DELETE. You may wish to delete a function if you
    believe that Ghidra has erred in its auto analysis or you have erred in creating
    a function. Note that while the function and its associated attributes will no
    longer exist, no change occurs to the underlying byte content, so the function
    can be re-created if desired.
  prefs: []
  type: TYPE_NORMAL
- en: '**Editing Function Attributes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ghidra associates several attributes with each function that it recognizes,
    which can be viewed by selecting the Window ▸ Functions option from the CodeBrowser
    menu. (While only five attributes are displayed by default, you can add any of
    16 additional attributes by right-clicking in a column heading.) To edit the attributes,
    open the Edit Function dialog from the right-click context menu when the cursor
    is positioned in the region between a function’s plate comment and the last local
    variable listed before the beginning of the function’s disassembled code. An example
    of the Edit Function dialog is shown in [Figure 7-16](ch07.xhtml#fig7_16).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: Edit Function dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each attribute that can be modified through this dialog is explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Name**'
  prefs: []
  type: TYPE_NORMAL
- en: You can modify the name within the text box at the top of the dialog or within
    the Function Name field.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: Five optional function attributes can be enabled in this area. The first four
    attributes, Varargs, In Line, No Return, and Use Custom Storage, are checkboxes
    that are unchecked by default. The fifth optional attribute, Call Fixup, appears
    in the bottom left of the dialog, defaults to `none`, and provides a drop-down
    menu from which you can choose a value. If you modify any of the function’s attributes,
    Ghidra automatically propagates the function’s updated prototype to all locations
    at which it may be displayed throughout the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: The Varargs option indicates that a function takes a variable number of arguments
    (for example, `printf`). Varargs is also enabled if you edit (in the text field
    at the top of [Figure 7-16](ch07.xhtml#fig7_16)) the function’s parameter list
    such that the last argument has an ellipsis (. . .). The In Line option has no
    effect on disassembly analysis other than to include the `inline` keyword in the
    function’s prototype. (Keep in mind that if a function were actually inlined by
    a compiler, you would not see that function as a distinct entity in a disassembly
    because its body would have been embedded within the body of the functions that
    call it.) The No Return option is used when it is known that a function will never
    return (for example, if it uses `exit` or an opaque predicate to jump to another
    function). When a function is tagged as No Return, Ghidra will not assume that
    the bytes following a call to that function are reachable unless it has other
    evidence to support their reachability, such as a jump instruction targeting those
    bytes. The Use Custom Storage option allows you to override Ghidra’s analysis
    of parameter and return value storage locations and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling Convention**'
  prefs: []
  type: TYPE_NORMAL
- en: The Calling Convention drop-down allows you to modify the calling convention
    used by the function. Modifying the calling convention may change Ghidra’s stack
    pointer analysis, so it is important to get this correct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Variables**'
  prefs: []
  type: TYPE_NORMAL
- en: The Function Variables area allows you to edit function variables with guidance.
    As you modify the data in the four columns associated with the variables, Ghidra
    will provide information to help you change things appropriately. For example,
    attempts to change the Storage for `param_1` will result in a message saying `Enable
    'Use Custom Storage' to allow editing of Parameter and Return Storage`. The four
    icons on the right allow you to add, delete, and navigate through the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Data to Code (and Vice Versa)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the automatic analysis phase, data bytes may be incorrectly classified
    as code bytes and disassembled into instructions, or code bytes may be incorrectly
    classified as data bytes and formatted as data values. This happens for many reasons,
    including because some compilers embed data into the code section of programs
    and because some code bytes are never directly referenced as code and thus Ghidra
    opts not to disassemble them. Obfuscated programs in particular tend to deliberately
    blur the distinction between code and data. (See [Chapter 21](ch21.xhtml#ch21).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option for reformatting anything is to remove its current formatting
    (code or data). It is possible to undefine functions, code, or data by right-clicking
    the item you wish to undefine and selecting Clear Code Bytes (hotkey C). Undefining
    an item causes the underlying bytes to be reformatted as a list of raw byte values.
    Large regions can be undefined by using a click-and-drag operation to select a
    range of addresses prior to performing the undefine operation. As an example,
    consider this simple function listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Undefining this function would yield the series of uncategorized bytes shown
    here, which we could reformat in virtually any manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To disassemble a sequence of undefined bytes, right-click the first byte to
    be disassembled and select **Disassemble**. This causes Ghidra to start the recursive
    descent algorithm at that point. Large regions can be converted to code by using
    click-and-drag to select a range of addresses prior to performing the code-conversion
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Converting code to data is a little more complex. First, you cannot directly
    convert code to data by using the context menu, unless you first undefine the
    instructions that you wish to convert to data and then format the bytes appropriately.
    Basic data formatting is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Data Transformations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand a program’s behavior, properly formatted data can be as important
    as properly formatted code. Ghidra takes information from a variety of sources
    and uses an algorithmic approach to determine the most appropriate way to format
    data within a disassembly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types and/or sizes can be inferred from the manner in which registers are
    used. An instruction that loads a 32-bit register from memory implies that the
    associated memory location holds a 4-byte data type (though we may not be able
    to distinguish between a 4-byte integer and a 4-byte pointer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function prototypes can be used to assign data types to function parameters.
    Ghidra maintains a large library of function prototypes for exactly this purpose.
    Analysis is performed on the parameters passed to functions in an attempt to tie
    a parameter to a memory location. If such a relationship can be uncovered, a data
    type can be applied to the associated memory location. Consider a function whose
    single parameter is a pointer to a `CRITICAL_SECTION` (a Windows API data type).
    If Ghidra can determine the address passed in a call to this function, that address
    can be flagged as a `CRITICAL_SECTION` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of a sequence of bytes can reveal likely data types. This is precisely
    what happens when a binary is scanned for string content. When long sequences
    of ASCII characters are encountered, it is not unreasonable to assume that they
    represent character arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, we discuss some basic transformations that you can
    perform on data within your disassemblies.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Specifying Data Types***'
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra offers data size and type specifiers. The most commonly encountered specifiers
    are `byte`, `word`, `dword`, and `qword`, representing 1-, 2-, 4-, and 8-byte
    data, respectively. Data types can be set or changed by right-clicking any disassembly
    line that contains data (that is not an instruction) and selecting the Set Data
    Type submenu shown in [Figure 7-17](ch07.xhtml#fig7_17).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The Data submenu*'
  prefs: []
  type: TYPE_NORMAL
- en: This list allows you to immediately change the formatting and data size of the
    currently selected item by choosing a data type. The Cycle option lets you quickly
    cycle through a group of associated data types, such as numeric, character, and
    floating point types, as shown (with associated hotkeys) in [Figure 7-18](ch07.xhtml#fig7_18).
    For example, repeatedly pressing F would cycle you between float and double, as
    they are the only items in that cycle group.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: Cycle groups*'
  prefs: []
  type: TYPE_NORMAL
- en: Toggling through data types causes data items to grow, shrink, or remain the
    same size. If an item’s size remains the same, the only observable change is in
    the way the data is formatted. If you reduce an item’s size, from `ddw` (4 bytes)
    to `db` (1 byte), for example, any extra bytes (3 in this case) become undefined.
    If you increase the size of an item, Ghidra will warn you of any conflict and
    guide you through resolving it. An example involving array dimensioning is shown
    in [Figure 7-19](ch07.xhtml#fig7_19).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Example of an array declaration and warning*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Choosing Search ▸ For Strings brings up the dialog shown in [Figure 7-20](ch07.xhtml#fig7_20),
    where you can set and control the search criteria for a specific string search.
    While most of the fields in this window are self-explanatory, a unique feature
    of Ghidra is the ability to associate a *word model* with a search. A word model
    can be used to determine whether a particular string is considered a word in a
    given context. Word models are discussed in [Chapter 13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: Search For Strings dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Once a search has been conducted, the results are presented in a String Search
    window ([Figure 7-21](ch07.xhtml#fig7_21)). Subsequent searches will be tabbed
    within the same window, and the window title bar will include timestamps for each
    search so you can easily order them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: String Search window showing search results*'
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost column of the String Search window contains icons that indicate
    the string definition status (from undefined to conflicting). The meanings of
    the icons are shown in [Figure 7-22](ch07.xhtml#fig7_22). To show or hide strings
    in any of the categories, toggle the corresponding icons in the title bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: String toggle icon definitions*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the icons allows you to easily identify the items in the listing that
    are not already defined as strings and make a string or character array from these
    entries by selecting them and clicking the Make String or Make Char Array button,
    as appropriate. These newly defined entities will be displayed in the Defined
    Strings window, which is discussed in “[The Defined Strings Window](ch05.xhtml#ch05lev84)”
    on [page 81](ch05.xhtml#page_81).
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the drawbacks to disassembly listings derived from higher-level languages
    is that they provide very few clues regarding the size of arrays. In a disassembly
    listing, an array can require a tremendous amount of space if each item in the
    array is specified on its own line. The following listing shows a sequence of
    items in a data section. The fact that only the first item in the listing is referenced
    by any instructions suggests that it may be the first element in an array. Rather
    than being referenced directly, additional elements within arrays are often referenced
    using index computations relative to the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ghidra can group consecutive data definitions into a single array definition.
    To create an array, select the first element of the array and use the Data ▸ Create
    Array option in the context menu (hotkey [). You will be prompted for the number
    of elements in the array, or you can accept the default that Ghidra suggests.
    (If you have selected a range of data, rather than a single value, Ghidra will
    use your selection as the array bounds.) By default, the data type and size associated
    with the array elements are based on the data type of the first element in the
    selection. The array is presented in a collapsed format, but can be expanded to
    view the individual elements. The number of elements displayed per line is controlled
    in the Edit ▸ Tool Options of the CodeBrowser window. Arrays are discussed more
    thoroughly in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '### **Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Together with the previous chapter, this chapter encompasses the most common
    operations that Ghidra users will ever need to perform. Disassembly manipulation
    lets you combine your knowledge with the knowledge imparted by Ghidra during its
    analysis phase to produce valuable information. As in source code, the effective
    use of names, assignment of data types, and detailed comments will not only assist
    you in remembering what you have analyzed but also greatly assist others who make
    use of your work. In the next chapter, we take a look at how to deal with more
    complex data structures, such as the C `struct`, and examine some of the low-level
    details of compiled C++.
  prefs: []
  type: TYPE_NORMAL
