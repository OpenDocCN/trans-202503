- en: '## **7'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **7'
- en: DISASSEMBLY MANIPULATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编操作**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: After navigation, disassembly modification is the next most significant feature
    of Ghidra. Ghidra offers the ability to easily manipulate disassemblies to add
    new information or reformat a listing to suit your particular needs, and because
    of Ghidra’s underlying structure, changes that you make to a disassembly are easily
    propagated to all associated Ghidra views to maintain a consistent picture of
    your program. Ghidra automatically handles operations such as context-aware search
    and replace when it makes sense to do so, and it makes trivial work of reformatting
    instructions as data, and data as instructions. And perhaps the best feature is
    that almost anything you do can be undone!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航之后，反汇编修改是Ghidra的下一个最重要功能。Ghidra提供了轻松操作反汇编的能力，能够添加新信息或重新格式化列表以满足你的特定需求，并且由于Ghidra的底层结构，你对反汇编所做的更改会很容易地传播到所有相关的Ghidra视图，从而保持程序的一致视图。Ghidra会自动处理诸如上下文感知的搜索和替换等操作（在合理的情况下），并且它能轻松地将指令重新格式化为数据，数据重新格式化为指令。而且，也许最好的功能是你几乎做的任何事情都可以撤销！
- en: '**I WISH I HADN’T DONE THAT**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**我希望我没有做那件事**'
- en: 'Part of being good at software reverse engineering is the ability to explore,
    experiment, and, when necessary, backtrack and retrace your steps. Ghidra’s powerful
    Undo capability allows you the flexibility to undo (and redo) actions during the
    SRE process. Multiple methods are available to access this magical power: the
    appropriate arrow icons in the CodeBrowser toolbar ➊➋, as shown in [Figure 7-1](ch07.xhtml#fig7_1);
    Edit ▸ Undo from the CodeBrowser menu; and the hotkeys CTRL-Z to undo and CTRL-SHIFT-Z
    to redo.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 成为软件逆向工程的高手的一部分是具备探索、实验的能力，并且在必要时，能够回溯并重新追溯自己的步骤。Ghidra强大的撤销功能使你在SRE过程中可以灵活地撤销（和重做）操作。有多种方法可以访问这种神奇的功能：CodeBrowser工具栏中的适当箭头图标
    ➊➋，如[图 7-1](ch07.xhtml#fig7_1)所示；从CodeBrowser菜单中选择编辑 ▸ 撤销；以及使用热键CTRL-Z撤销和CTRL-SHIFT-Z重做。
- en: '![image](Images/fig7-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-1.jpg)'
- en: '*Figure 7-1: Undo and Redo icons in the CodeBrowser toolbar*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：CodeBrowser工具栏中的撤销和重做图标*'
- en: '**Manipulating Names and Labels**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作名称和标签**'
- en: 'At this point, we have encountered two categories of identifiers in Ghidra
    disassemblies: labels (which are identifiers associated with locations) and names
    (which are identifiers associated with stack frame variables). For the most part,
    we will refer to both as *names*, as Ghidra is somewhat loose in this distinction
    also. (If you want to be really precise, labels actually have associated names,
    addresses, histories, and so on. The name of the label is how we generally reference
    the label.) We use more specific terms when the distinction makes a critical difference.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在Ghidra反汇编中遇到了两类标识符：标签（与位置相关的标识符）和名称（与栈帧变量相关的标识符）。在大多数情况下，我们会将这两者统称为*名称*，因为Ghidra在这方面也有些模糊。（如果要非常精确，标签实际上有相关的名称、地址、历史记录等。标签的名称是我们通常引用标签的方式。）当这种区分至关重要时，我们会使用更具体的术语。
- en: To review, stack variable names have one of two prefixes based on whether the
    variable is a parameter (`param_`) or a local variable (`local_`), and locations
    are assigned names/labels with helpful prefixes during auto analysis (for example,
    `LAB_`, `DAT_`, `FUN_`, `EXT_`, `OFF_`, and `UNK_`). In most cases, Ghidra will
    automatically generate names and labels based on its best guess about the use
    of the associated variable or address, but you will need to analyze the program
    yourself to understand the purpose of a location or variable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，栈变量名称有两种前缀，取决于变量是参数（`param_`）还是局部变量（`local_`），而位置在自动分析期间会分配有帮助的前缀的名称/标签（例如，`LAB_`、`DAT_`、`FUN_`、`EXT_`、`OFF_`
    和 `UNK_`）。在大多数情况下，Ghidra会根据它对相关变量或地址用途的最佳猜测自动生成名称和标签，但你仍然需要自己分析程序，理解位置或变量的目的。
- en: As you begin to analyze any program, one of the first and most common ways to
    manipulate a disassembly listing is to change default names into more meaningful
    names. Fortunately, Ghidra allows you to easily change any name, and it intelligently
    propagates name changes throughout the entire program. To open a name-change dialog,
    select the name by clicking it and then use the L hotkey or the Edit Label option
    on the right-click context menu. From there, the process for stack variables (names)
    and named locations (labels) varies, as detailed in the following sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始分析任何程序时，最常见的处理反汇编列表的方法之一是将默认名称更改为更有意义的名称。幸运的是，Ghidra允许你轻松更改任何名称，并且它会智能地将名称更改传播到整个程序中。要打开名称更改对话框，请点击名称，然后使用L快捷键或右键上下文菜单中的编辑标签选项。从这里开始，栈变量（名称）和命名位置（标签）的过程会有所不同，详情见后面的章节。
- en: '#### ***Renaming Parameters and Local Variables***'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***重命名参数和局部变量***'
- en: Names associated with stack variables are not associated with a specific virtual
    address. As in most programming languages, such names are restricted to the scope
    of the function to which a given stack frame belongs. Thus, every function in
    a program can have its own stack variable named `param_1`, but no function may
    have more than one variable named `param_1`, as shown in [Figure 7-2](ch07.xhtml#fig7_2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈变量相关的名称并不与特定的虚拟地址相关联。与大多数编程语言一样，这些名称仅限于所属栈帧对应的函数作用域。因此，程序中的每个函数可以有一个名为`param_1`的栈变量，但没有任何函数可以有多个名为`param_1`的变量，如[图
    7-2](ch07.xhtml#fig7_2)所示。
- en: '![image](Images/fig7-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-2.jpg)'
- en: '*Figure 7-2: Symbol Tree showing reuse of parameter names* (param_1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: 符号树显示参数名称的重用*（param_1）'
- en: When you rename a variable in the Listing window, the informative dialog shown
    in [Figure 7-3](ch07.xhtml#fig7_3) will pop up. The type of entity you are changing
    (variable, function, and so on) appears in the title bar of the window, and the
    current (about to be changed) name appears in the editable text box and the title
    bar.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在列出窗口中重命名变量时，[图 7-3](ch07.xhtml#fig7_3)中所示的提示对话框将弹出。你正在更改的实体类型（变量、函数等）将出现在窗口的标题栏中，而当前（即将更改的）名称将出现在可编辑文本框和标题栏中。
- en: '![image](Images/fig7-3.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-3.jpg)'
- en: '*Figure 7-3: Renaming a stack variable* (local_14 to y)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: 重命名栈变量*（local_14改为y）'
- en: 'Once a new name is supplied, Ghidra changes every occurrence of the old name
    in the current function. The following listing shows the result of renaming `local_14`
    to `y` in `demo_stackframe`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了新名称，Ghidra将更改当前函数中所有旧名称的出现。以下列表显示了在`demo_stackframe`中将`local_14`重命名为`y`后的结果：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These changes ➊➋➌ are also reflected in the Symbol Tree, as shown in [Figure
    7-4](ch07.xhtml#fig7_4).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改➊➋➌也会反映在符号树中，如[图 7-4](ch07.xhtml#fig7_4)所示。
- en: '![image](Images/fig7-4.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-4.jpg)'
- en: '*Figure 7-4: Symbol Tree view of renamed stack variable,* y'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 重命名栈变量后的符号树视图*，y'
- en: '**THE FORBIDDEN NAMES**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁止的名称**'
- en: 'Some interesting rules restrict what you can name variables within a function.
    Here are some of the more relevant rules for parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的规则限制了你在函数内命名变量。以下是一些更相关的参数命名规则：
- en: You *can’t* use the prefix `param_` followed by an integer in a name, even if
    the resulting name does not conflict with an existing parameter name.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你*不能*在名称中使用前缀`param_`后跟一个整数，即使结果名称与现有参数名称不冲突。
- en: You *can* use the prefix `param_` followed by other characters.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你*可以*使用前缀`param_`，后跟其他字符。
- en: You *can* use the prefix `Param_` followed by an integer, as names are case-sensitive
    (but it might not be advisable).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你*可以*使用前缀`Param_`后跟一个整数，因为名称区分大小写（但这可能不建议这样做）。
- en: You *can* restore a parameter name to its original Ghidra-assigned name by entering
    `param_` followed by an integer value. If you use the original integer value,
    Ghidra will revert the name with no complaints. If you use any integer other than
    the original value, Ghidra will warn “Rename failed – default names may not be
    used*.*” At this point, clicking Cancel in the Rename Parameter dialog will restore
    the original name.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你*可以*通过输入`param_`后跟一个整数值来将参数名称恢复为原始的Ghidra分配名称。如果使用原始的整数值，Ghidra将无异常地恢复该名称。如果使用任何不同于原始值的整数，Ghidra将警告“重命名失败——默认名称不可使用*.*”此时，在重命名参数对话框中点击取消将恢复原始名称。
- en: You *can* have two parameters with the names `param_1` (named by Ghidra) and
    `Param_1` (named by you). Names are case-sensitive, but it might not be advisable
    to reuse them.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你*可以*拥有两个参数，分别命名为`param_1`（由Ghidra命名）和`Param_1`（由你命名）。名称区分大小写，但不建议重复使用它们。
- en: Local variables are also case-sensitive, and you can use the prefix `local_`
    with a non-numeric suffix.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量也区分大小写，你可以使用前缀`local_`和非数字后缀。
- en: For all types of variables, you *can’t* use a variable name that’s already used
    in that scope (for example, in the same function). Your attempt will be rejected
    with a reason in the dialog.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有类型的变量，你*不能*使用已经在该范围内（例如，在同一个函数中）使用的变量名。你的尝试将会被对话框拒绝，并附有拒绝的理由。
- en: Finally, if you are thoroughly confused by your labels, you can see the label
    history for a variable by pressing the hotkey H, choosing Show All History, and
    entering the current name (or a past name) of the variable into the text box.
    (This option is also available through Search ▸ Label History in the main menu.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你对标签感到完全困惑，可以通过按快捷键 H，选择“显示所有历史记录”，并将变量的当前名称（或过去的名称）输入文本框来查看变量的标签历史。（此选项也可以通过主菜单中的“搜索
    ▸ 标签历史”来访问。）
- en: '**WHERE SHOULD YOU CHANGE YOUR NAME?**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**你应该在哪里更改你的名字？**'
- en: Variable names can be changed from the Listing, Symbol Tree, and Decompiler
    windows; the outcome is the same regardless, but the dialog accessed from the
    Listing window presents more information. All rules associated with naming variables
    are enforced when using any of these methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称可以从列表、符号树和反编译窗口中更改；结果是一样的，但从列表窗口访问的对话框会显示更多信息。使用任何这些方法时，都会强制执行与命名变量相关的所有规则。
- en: Many of the example parameter names in this book were changed in the Listing
    window using the dialog shown on the left in [Figure 7-5](ch07.xhtml#fig7_5).
    To change a name in the Symbol Tree, right-click the name and select **Rename**
    from the context menu. In the Decompiler window, use the hotkey L, or use the
    **Rename Variable** context menu option; the corresponding dialog is shown on
    the right in [Figure 7-5](ch07.xhtml#fig7_5). While the two dialogs provide the
    same functionality, the right dialog does not include information about the namespace
    or properties associated with the parameter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多示例参数名称都是在列表窗口中使用左侧所示对话框进行更改的，参见[图7-5](ch07.xhtml#fig7_5)。要在符号树中更改名称，请右键点击名称并从上下文菜单中选择**重命名**。在反编译窗口中，使用快捷键
    L，或使用**重命名变量**上下文菜单选项；相应的对话框显示在[图7-5](ch07.xhtml#fig7_5)的右侧。虽然这两个对话框提供相同的功能，但右侧对话框不包含与参数相关的命名空间或属性信息。
- en: '![image](Images/fig7-5.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-5.jpg)'
- en: '*Figure 7-5: Renaming a variable from the Listing window or Symbol Tree (left)
    or the Decompiler window (right)*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：从列表窗口或符号树（左）或反编译窗口（右）重命名变量*'
- en: In Ghidra, a *namespace* is simply a named scope. Within a namespace, all symbols
    are unique. The global namespace contains all symbols within a binary. Function
    namespaces are nested within the global namespace. Within a function namespace,
    all variable names and labels are unique. Functions may themselves contain nested
    namespaces, such as a namespace associated with a switch statement (which allows
    case labels to be reused in separate namespaces; for example, when a function
    contains two switch statements that each have a case 10).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ghidra中，*命名空间*只是一个命名的范围。在命名空间内，所有符号都是唯一的。全局命名空间包含二进制文件中的所有符号。函数命名空间嵌套在全局命名空间内。在函数命名空间内，所有变量名和标签都是唯一的。函数本身也可以包含嵌套的命名空间，例如与开关语句相关联的命名空间（这允许在不同的命名空间中重用
    case 标签；例如，当一个函数包含两个开关语句，每个语句都有一个 case 10）。
- en: '***Renaming Labels***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重命名标签***'
- en: A label is a default or user-assigned name associated with a location. As with
    stack variables, the name-change dialog is opened with the hotkey L or context
    option Edit Label. When you change a location’s name, you can also change its
    namespace and properties, as shown in [Figure 7-6](ch07.xhtml#fig7_6).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是与位置相关联的默认或用户分配的名称。与堆栈变量一样，名称更改对话框可以通过快捷键 L 或上下文选项“编辑标签”打开。当你更改一个位置的名称时，还可以更改其命名空间和属性，如[图7-6](ch07.xhtml#fig7_6)所示。
- en: '![image](Images/fig7-6.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-6.jpg)'
- en: '*Figure 7-6: Renaming a function*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：重命名函数*'
- en: This enhanced dialog shows the entity type and virtual address of the location
    in the title bar. Under Properties, you can identify the address as an entry point
    or pin the address (see “[Editing Labels](ch07.xhtml#ch07lev122)” on [page 126](ch07.xhtml#page_126)).
    As mentioned in [Chapter 6](ch06.xhtml#ch06), Ghidra limits names to a maximum
    of 2000 characters, so feel free to use meaningful names or even embed a narrative
    about the address (without any spaces). The Listing window will display only a
    portion of the name if the length is excessive, but the Decompiler window shows
    the entire thing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增强版对话框在标题栏中显示实体类型和虚拟地址。在属性下，你可以将地址标识为入口点或固定地址（参见“[编辑标签](ch07.xhtml#ch07lev122)”第[126页](ch07.xhtml#page_126)）。如[第六章](ch06.xhtml#ch06)所述，Ghidra
    限制名称的最大长度为 2000 个字符，所以可以随意使用有意义的名称，甚至将关于该地址的叙述嵌入其中（不允许有空格）。如果名称过长，清单窗口将只显示部分名称，但反编译器窗口会显示完整名称。
- en: '***Adding a New Label***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加新标签***'
- en: While Ghidra generates many default labels, you can also add new labels and
    associate them with any address in the listing. These can be used to annotate
    your disassembly, although in many cases *comments* (discussed later in this chapter)
    are a more appropriate mechanism for this. To add a new label, open the Add Label
    dialog (hotkey L), shown in [Figure 7-7](ch07.xhtml#fig7_7), for the address associated
    with the cursor location. The drop-down list for the name includes a list of names
    you have used recently, and the Namespace drop-down list lets you choose an appropriate
    label scope.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ghidra 会生成许多默认标签，但你也可以添加新标签并将它们与清单中的任何地址关联。这些标签可以用于注释你的反汇编，尽管在许多情况下，*注释*（本章后面会讨论）是更合适的方式。要添加新标签，请打开添加标签对话框（快捷键
    L），如[图 7-7](ch07.xhtml#fig7_7)所示，针对与光标位置关联的地址。名称的下拉列表包含你最近使用的名称列表，而命名空间的下拉列表让你选择适当的标签范围。
- en: '![image](Images/fig7-7.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-7.jpg)'
- en: '*Figure 7-7: Add Label dialog*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：添加标签对话框*'
- en: '**FUN_ WITH PREFIXES**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**FUN_ 与前缀**'
- en: When Ghidra creates labels during auto analysis, it uses meaningful prefixes
    followed by an address to let you know what to expect at that location. These
    prefixes are listed next with very general descriptions. More information about
    the meaning of each prefix can be found in Ghidra Help.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ghidra 在自动分析过程中创建标签时，它使用有意义的前缀后跟地址，告诉你在该位置会发生什么。这些前缀如下列出，并附有非常概括的描述。有关每个前缀的更多信息，可以在
    Ghidra 帮助中找到。
- en: LAB_address Code—an auto-generated label (usually a jump target within a function)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: LAB_address 代码——自动生成的标签（通常是函数内的跳转目标）
- en: DAT_address Data—an auto-generated global variable name
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DAT_address 数据——自动生成的全局变量名称
- en: FUN_address Function—an auto-generated function name
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: FUN_address 函数——自动生成的函数名称
- en: SUB_address Target of a call (or equivalent)—probably not a function
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SUB_address 调用目标（或等效项）——可能不是函数
- en: EXT_address External entry point—probably someone else’s function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: EXT_address 外部入口点——可能是其他人的函数
- en: OFF_address An offcut (inside existing data or code)—probably a disassembly
    error
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: OFF_address 剪切片（位于现有数据或代码内部）——可能是反汇编错误
- en: UNK_address Unknown—the purpose of the data here can’t be determined
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: UNK_address 未知——无法确定此处数据的目的
- en: 'Function labels have the following specific behaviors associated with them:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数标签具有以下特定行为：
- en: If you delete a default function label (such as `FUN_08048473`) in the Listing
    window, the `FUN_` prefix will be replaced by the `SUB_` prefix (in this case,
    resulting in `SUB_08048473`).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在清单窗口删除了默认的函数标签（例如 `FUN_08048473`），则 `FUN_` 前缀将被 `SUB_` 前缀替换（在这种情况下，结果为 `SUB_08048473`）。
- en: Adding a new label to an address that has a default `FUN_` label changes the
    function name rather than creating a new label.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个已有默认 `FUN_` 标签的地址添加新标签，会改变函数名称，而不是创建新标签。
- en: Labels are case-sensitive, so you can use `Fun_` or `fun_` as a valid prefix
    if your desire is to create a confusing disassembly.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签区分大小写，因此你可以使用 `Fun_` 或 `fun_` 作为有效的前缀，如果你的目的是创建混淆的反汇编。
- en: You can run into conflicts if you attempt to use one of Ghidra’s reserved prefixes
    when entering a name. If you insist on using a reserved prefix, Ghidra will reject
    your new label if it believes that a name conflict might arise. This occurs only
    when Ghidra determines that your suffix looks like an address (in our experience,
    this means four or more hex digits). For example, Ghidra will allow `FUN_zone`
    and `FUN_123`, but will reject `FUN_12345`. Also, if you attempt to add a label
    at the same address as a function that has a default label (for example, `FUN_08048473`),
    Ghidra renames the function rather than adding a second label at that location.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 Ghidra 的保留前缀来命名，可能会遇到冲突。如果你坚持使用一个保留前缀，Ghidra 会拒绝你的新标签，如果它认为可能会发生名称冲突。仅当
    Ghidra 确定你的后缀看起来像一个地址时才会发生这种情况（根据我们的经验，这意味着四个或更多的十六进制数字）。例如，Ghidra 会允许 `FUN_zone`
    和 `FUN_123`，但会拒绝 `FUN_12345`。此外，如果你尝试在与具有默认标签的函数相同的地址上添加标签（例如，`FUN_08048473`），Ghidra
    会重命名该函数，而不是在该位置添加第二个标签。
- en: '***Editing Labels***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑标签***'
- en: To edit a label, use the hotkey L or context menu option Edit Label. Editing
    a label presents you with the same dialog as adding a label, except that the fields
    in the dialog will be initialized with the current values for the existing label.
    Note that editing labels can have an effect on other labels that share the same
    address, whether or not they share the same namespace. For example, if you identify
    a label as an entry point, Ghidra will identify all labels associated with that
    location as entry points.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑标签，可以使用快捷键 L 或右键菜单中的“编辑标签”选项。编辑标签会呈现与添加标签相同的对话框，只不过对话框中的字段会初始化为现有标签的当前值。请注意，编辑标签可能会对共享相同地址的其他标签产生影响，无论它们是否共享相同的命名空间。例如，如果你将一个标签标识为入口点，Ghidra
    会将与该位置关联的所有标签标识为入口点。
- en: '**IS IT A BUG OR A FEATURE?**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个 BUG 还是一个特性？**'
- en: 'In the course of experimenting with function names, you may notice that Ghidra
    is perfectly content to allow you to give two functions the same name. This may
    elicit flashbacks to overloaded functions, which can be distinguished by the parameters
    they are passed. Ghidra’s capability extends beyond this: you can give two functions
    the exact same name even if this results in duplicate function prototypes within
    the same namespace. This is possible because a label is not a unique identifier
    (primary key in the database sense) and thus does not uniquely identify a function,
    even when considered with its associated parameters. Duplicate names can be used
    to tag functions; for example, to classify them for further analysis or eliminate
    them from consideration. Recall that all names are preserved in the function history
    (hotkey H) and can easily be reverted.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试修改函数名称的过程中，你可能会注意到，Ghidra 很乐意让你为两个函数设置相同的名称。这可能会让你联想到重载函数，可以通过传递给它们的参数来区分它们。Ghidra
    的能力远不止于此：即使这导致在同一命名空间内出现重复的函数原型，你也可以给两个函数完全相同的名称。这是可能的，因为标签不是唯一的标识符（在数据库意义上是主键），因此即使与其相关的参数一起考虑，它也不能唯一标识一个函数。重复的名称可以用来标记函数；例如，用于对它们进行进一步分析或将它们排除在考虑之外。请记住，所有的名称都会保存在函数历史记录中（快捷键
    H），并且可以轻松恢复。
- en: The Primary checkbox in [Figure 7-7](ch07.xhtml#fig7_7) indicates that this
    is the label that will be displayed when the address is displayed. By default,
    this checkbox is disabled for the primary label, so you cannot deselect the primary
    name. This is necessary to ensure that there is always a name to display. If another
    label were chosen as the primary, its checkbox would be disabled, and checkboxes
    for other labels at the same address would be enabled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-7](ch07.xhtml#fig7_7)中的主复选框表示这是当地址显示时将显示的标签。默认情况下，此复选框对主标签是禁用的，因此你不能取消选择主名称。这是必要的，以确保始终有一个名称可供显示。如果选择了另一个标签作为主标签，那么该标签的复选框将被禁用，其他标签在相同地址上的复选框将被启用。'
- en: Although we have, up to now, associated labels with addresses, in reality labels
    are most commonly associated with content that happens to have an address. For
    example, the label `main` typically denotes the beginning of the block of code
    that is the main function in a program. Ghidra assigns an address to this location
    based on file header information. If we were to relocate the entire content of
    the binary to a new address range, we would expect that the label `main` would
    continue to correctly associate with the new address of `main` and its corresponding,
    unchanged byte content. When a label is *pinned*, the label’s association with
    the content at its address is severed. If you were to then relocate the binary’s
    content to a new address range, any pinned labels would not move accordingly,
    but remain fixed to the address that you pinned them to. The most common use of
    pinned labels is to name reset vectors and memory mapped I/O locations that exist
    at specific addresses designated by the processor/system designers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止，我们将标签与地址关联，但实际上标签最常见的用途是与拥有地址的内容相关联。例如，`main` 标签通常表示程序中主函数代码块的开始。Ghidra
    会根据文件头信息为该位置分配一个地址。如果我们将整个二进制内容重新定位到新的地址范围，我们预计 `main` 标签会继续正确地关联到 `main` 的新地址及其对应的、未改变的字节内容。当一个标签被
    *固定* 时，标签与其地址处内容的关联会被切断。如果你随后将二进制内容移动到新地址范围，任何固定的标签将不会相应移动，而是会固定在你固定它们时的地址。固定标签最常见的用途是为复位向量和内存映射的
    I/O 地址命名，这些地址是由处理器/系统设计者指定的特定地址。
- en: '***Removing a Label***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移除标签***'
- en: To remove a label at the cursor, you can use the right-click context option
    (or hotkey DELETE). Be warned that not all labels are removable. First, it is
    impossible to delete a default, Ghidra-generated label. Second, if you have renamed
    a default label and later decide to delete the new label, Ghidra will replace
    the name you are deleting with the originally assigned, default label (this is
    a direct result of the previous statement). The finer details associated with
    removing labels are discussed in Ghidra Help.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除光标处的标签，你可以使用右键菜单选项（或快捷键 DELETE）。需要注意的是，并非所有标签都可以删除。首先，不可能删除默认的 Ghidra 生成标签。其次，如果你重命名了一个默认标签，并且后来决定删除这个新标签，Ghidra
    会将你删除的标签替换为最初分配的默认标签（这是上一陈述的直接结果）。有关删除标签的更多细节，请参考 Ghidra 帮助文档。
- en: '#### ***Navigating Labels***'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***导航标签***'
- en: Labels are associated with navigable locations, so double-clicking a reference
    to a label will navigate you to that label. While this is discussed more thoroughly
    in [Chapter 9](ch09.xhtml#ch09), remember that you can add labels to any location
    you wish to navigate to in the disassembly. While the same functionality is described
    in “[Annotations](ch07.xhtml#ch07lev131)” on [page 132](ch07.xhtml#page_132),
    sometimes a label (particularly with its 2000-character allowance) is the quickest
    way to accomplish the same goal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标签与可导航的位置相关联，因此双击标签的引用将带你跳转到该标签。虽然这一点在[第9章](ch09.xhtml#ch09)中有更详细的讨论，但请记住，你可以在反汇编中为任何你希望导航到的位置添加标签。虽然在[第132页](ch07.xhtml#page_132)的“[注释](ch07.xhtml#ch07lev131)”部分也描述了相同的功能，但有时候，标签（特别是它的2000字符限制）是实现同样目标的最快方法。
- en: '**Comments**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注释**'
- en: Embedding comments into your disassembly and decompiler listings is a particularly
    useful way to leave notes for yourself regarding your progress and discoveries
    as you analyze a program. Ghidra offers five categories of comments, each suited
    for a different purpose. We begin by looking at comments that we can add directly
    to the disassembly in the Listing window.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将注释嵌入到反汇编和反编译器列表中，是在分析程序时为自己留下进展和发现备注的特别有用方式。Ghidra 提供了五种类型的注释，每种类型都适用于不同的目的。我们首先来看一下可以直接添加到反汇编中的注释，这些注释出现在列表窗口中。
- en: While you can navigate to the Set Comment dialog (shown in [Figure 7-8](ch07.xhtml#fig7_8))
    through the right-click context menu, the quickest way is to use the hotkey for
    comments, which is the semicolon (;) key. (This is a logical choice, as the semicolon
    is the comment indicator in many flavors of assembly.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以通过右键菜单导航到“设置注释”对话框（见[图7-8](ch07.xhtml#fig7_8)），最快的方法是使用注释的快捷键，即分号（;）键。（这是一个合乎逻辑的选择，因为在许多汇编语言的变种中，分号是注释的标志。）
- en: '![image](Images/fig7-8.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-8.jpg)'
- en: '*Figure 7-8: Set Comment dialog*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：设置注释对话框*'
- en: 'The Set Comment dialog opens in association with a particular address: `08048479`
    in [Figure 7-8](ch07.xhtml#fig7_8), as displayed in the title bar. Any content
    entered into any one of the five comment category tabs (EOL, Pre, Post, Plate,
    and Repeatable Comments) is associated with that address.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “设置评论”对话框会与特定地址一起打开：如[图 7-8](ch07.xhtml#fig7_8)中所示的`08048479`，并在标题栏中显示。输入到五个评论类别标签（EOL、Pre、Post、Plate
    和 Repeatable Comments）中的任何内容都会与该地址关联。
- en: By default, you enter content in the text box, including carriage returns, create
    a comment that is one or more lines long, and then click **Apply** or **OK**.
    (Apply allows you to see the comment in context and keeps the Set Comment dialog
    open for continued editing.) To save time when entering short comments, select
    the **Enter accepts comment** checkbox in the lower left of the dialog. (You can
    always deselect the box temporarily if you are writing a particularly informative
    plate comment.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你在文本框中输入内容，包括回车符，创建一个或多行的评论，然后点击**应用**或**确定**。（应用可以让你在上下文中查看评论，并保持“设置评论”对话框打开以便继续编辑。）为了节省输入简短评论的时间，可以在对话框左下角选择**回车键接受评论**复选框。（如果你写的是特别详细的板块评论，你随时可以暂时取消勾选此框。）
- en: '**THOSE THREE BUTTONS**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**这三个按钮**'
- en: Of the three buttons at the bottom of the Set Comment dialog ([Figure 7-8](ch07.xhtml#fig7_8)),
    the OK and Apply buttons behave as you might expect. Clicking OK closes the dialog
    and commits your changes. When you click Apply, the listing is updated so that
    you can examine your changes and approve them or continue editing your comment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在“设置评论”对话框底部的三个按钮（见[图 7-8](ch07.xhtml#fig7_8)）中，OK 和 Apply 按钮的行为符合预期。点击 OK 会关闭对话框并提交更改。点击
    Apply 会更新列表，方便你检查更改并决定是否批准或继续编辑评论。
- en: Dismiss, however, is not the same as Cancel, which would exit the dialog with
    no effect on your listing! The unique term is consistent with the unique behavior.
    Clicking the Dismiss button exits the window immediately if you have not modified
    any comments, but lets you decide whether you want to save changes if you did
    modify comments. Closing the window using the X in the top right exhibits the
    same behavior. This Dismiss functionality will be encountered in other places
    within Ghidra.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Dismiss 并不等同于 Cancel，Cancel 会退出对话框且对列表没有任何影响！这个独特的术语与其独特的行为一致。点击 Dismiss
    按钮，如果没有修改任何评论，则立即退出窗口；如果修改了评论，则可以选择是否保存更改。使用右上角的 X 关闭窗口也会表现出相同的行为。这种 Dismiss 功能将在
    Ghidra 的其他地方遇到。
- en: To delete a comment, clear a comment’s text in the Set Comment dialog, or use
    the hotkey DELETE when the cursor is on a comment in the Listing window. Right-clicking
    Comments ▸ Show History for Comment can be used to recall the comments associated
    with a particular address and reinstate them as needed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除评论，可以在“设置评论”对话框中清除评论文本，或者当光标停在列表窗口的评论上时使用快捷键 DELETE。右键点击 Comments ▸ Show
    History for Comment 可以用来回顾与特定地址关联的评论，并根据需要恢复它们。
- en: '***End-of-Line Comments***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***行尾评论***'
- en: Perhaps the most commonly used type of comment is the *end-of-line (EOL) comment*,
    placed at the end of existing lines in the Listing window. To add one, open the
    Set Comment dialog with the semicolon hotkey and select the EOL Comment tab. By
    default, EOL comments are displayed as blue text and will span multiple lines
    if you enter multiple lines in the comment text box. Each line will be indented
    to align at the right side of the disassembly, and existing content will be moved
    down to make space for the new comments. You can edit your comments at any time
    by reopening the Set Comment dialog. The quickest method to delete a comment is
    to click the comment in the Listing window and press DELETE.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常用的评论类型是*行尾（EOL）评论*，它们被放置在列表窗口现有行的末尾。要添加一个行尾评论，可以使用分号快捷键打开“设置评论”对话框并选择 EOL
    评论标签。默认情况下，EOL 评论以蓝色文本显示，如果你在评论文本框中输入多行，它们会跨越多行。每一行会缩进对齐到反汇编的右侧，现有内容会被向下移动以腾出空间给新评论。你可以随时通过重新打开“设置评论”对话框来编辑评论。删除评论的最快方法是点击列表窗口中的评论并按
    DELETE 键。
- en: Ghidra itself adds many EOL comments during auto analysis. For example, when
    you load a PE file, Ghidra inserts descriptive EOL comments to describe the fields
    in the `IMAGE_DOS_HEADER` section, including the comment `Magic number`. Ghidra
    is able to do this only when it has this information associated with a particular
    data type. This information is typically contained within type libraries, which
    are displayed in the Data Type Manager window and discussed in depth in [Chapter
    8](ch08.xhtml#ch08) and [Chapter 13](ch13.xhtml#ch13). Among all the comment types,
    EOL comments are the most configurable through the Edit ▸ Tool Options ▸ Listing
    Fields options for each comment type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra本身在自动分析过程中添加了许多EOL注释。例如，当你加载PE文件时，Ghidra会插入描述EOL注释，用以描述`IMAGE_DOS_HEADER`部分的字段，包括`Magic
    number`注释。只有当Ghidra拥有与特定数据类型相关的信息时，才能做到这一点。这些信息通常包含在类型库中，在数据类型管理器窗口中显示，并在[第8章](ch08.xhtml#ch08)和[第13章](ch13.xhtml#ch13)中深入讨论。在所有注释类型中，EOL注释通过编辑
    ▸ 工具选项 ▸ 列表字段选项对每个注释类型进行配置的能力最强。
- en: '#### ***Pre and Post Comments***'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***前置和后置注释***'
- en: '*Pre* and *post comments* are full-line comments that appear either immediately
    before or after a given disassembly line. The following listing shows a multi­line
    pre comment and a truncated single-line post comment, associated with address
    `08048476`. Hovering over a truncated comment will display the complete comment.
    By default, pre comments are displayed in purple, and post comments are displayed
    in blue, so that you can easily associate them with the correct address in the
    listing.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*前置*注释和*后置*注释是完整行注释，分别出现在给定反汇编行的前后。以下示例显示了一个多行的前置注释和一个截断的单行后置注释，关联地址为`08048476`。将鼠标悬停在截断的注释上将显示完整的注释。默认情况下，前置注释以紫色显示，后置注释以蓝色显示，因此你可以轻松地将它们与列表中的正确地址关联。'
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***Plate Comments***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***板块注释***'
- en: '*Plate comments* allow you to group comments for display anywhere in the Listing
    window. A plate comment is centered and placed within an asterisk-bounded rectangle.
    Many of the listings we have examined include a simple plate comment with the
    word `FUNCTION` inside the bounding box, as shown in [Figure 7-9](ch07.xhtml#fig7_9).
    This example includes the associated Decompiler window on the right side so you
    can see that, in this default presentation, a plate comment has been inserted
    in the Listing window, but no corresponding comment exists in the Decompiler window.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*板块注释*允许你在列表窗口的任何位置分组显示注释。板块注释居中，并置于星号框住的矩形内。我们已经检查的许多列表都包含了一个简单的板块注释，框内写着`FUNCTION`，如[图
    7-9](ch07.xhtml#fig7_9)所示。这个示例包括了右侧的反编译窗口，你可以看到，在这个默认展示中，一个板块注释已被插入到列表窗口中，但反编译窗口中没有对应的注释。'
- en: '![image](Images/fig7-9.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-9.jpg)'
- en: '*Figure 7-9: Plate comment example*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：板块注释示例*'
- en: When you open the comment dialog with the first address in the function selected,
    you have the option to replace this general plate comment with your own, more
    informative one, as shown in [Figure 7-10](ch07.xhtml#fig7_10). In addition to
    replacing the default plate comment, Ghidra adds your comment as a C-style comment
    at the top of the Decompiler window. If the cursor were at the top of the Decompiler
    window when the plate comment was created, the result would have been the same.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在选择函数中的第一个地址时打开注释对话框，你可以选择用更具信息性的自定义注释替换默认的板块注释，如[图 7-10](ch07.xhtml#fig7_10)所示。除了替换默认的板块注释外，Ghidra还会在反编译窗口顶部添加你的注释作为C风格注释。如果光标在创建板块注释时位于反编译窗口顶部，结果也是一样的。
- en: '![image](Images/fig7-10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-10.jpg)'
- en: '*Figure 7-10: Custom plate comment example*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：自定义板块注释示例*'
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Only plate and pre comments are displayed in the Decompiler window by default,
    although you can change this using options in Edit ▸ Tool Options ▸ Decompiler
    ▸ Display.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认情况下，反编译窗口只显示板块注释和前置注释，但你可以通过编辑 ▸ 工具选项 ▸ 反编译器 ▸ 显示来更改此设置。*'
- en: '***Repeatable Comments***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可重复的注释***'
- en: A *repeatable comment* is entered once but may appear automatically in many
    locations throughout the disassembly. The behavior of repeatable comments is tied
    to the concept of cross-references, which are discussed in depth in [Chapter 9](ch09.xhtml#ch09).
    Basically, a repeatable comment entered at the target of a cross-reference is
    echoed at the source of a cross-reference. As a result, a single repeatable comment
    may be echoed at many locations in the disassembly (because cross-references can
    be many-to-one). In a disassembly listing, the default color is orange for repeatable
    comments and gray for echoed comments, making them easily distinguishable from
    other types of comments. The following listing demonstates the use of a repeatable
    comment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*可重复注释*是一次输入但可能在反汇编中许多位置自动出现的注释。可重复注释的行为与交叉引用的概念相关，交叉引用将在[第 9 章](ch09.xhtml#ch09)中深入讨论。基本上，在交叉引用目标位置输入的可重复注释会在交叉引用源位置回显。因此，一个可重复注释可能会在反汇编的多个位置回显（因为交叉引用可以是多对一的）。在反汇编清单中，可重复注释的默认颜色为橙色，回显注释为灰色，这使它们与其他类型的注释区分开来。以下清单演示了可重复注释的使用。'
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the listing, a repeatable comment is set at `08048446` ➋ and repeated at
    `08048432` ➊ because the instruction at `08048432` refers to address `08048446`
    as a jump target (thus a cross-reference exists from `08048432` to `08048446`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单中，`08048446` ➋ 位置设置了可重复注释，并在 `08048432` ➊ 位置重复出现，因为 `08048432` 位置的指令将地址 `08048446`
    作为跳转目标（因此，从 `08048432` 到 `08048446` 存在交叉引用）。
- en: When an EOL comment and a repeatable comment share the same address, only the
    EOL comment is visible in the listing. Both comments can be viewed and edited
    in the Set Comment dialog. If you delete the EOL comment, the repeatable comment
    will become visible in the listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当 EOL 注释和可重复注释共享相同的地址时，仅 EOL 注释会在清单中显示。两个注释都可以在“设置注释”对话框中查看和编辑。如果你删除 EOL 注释，则可重复注释将在清单中变为可见。
- en: '***Parameter and Local Variable Comments***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***参数和局部变量注释***'
- en: To associate a comment with a stack variable, select the stack variable and
    use the semicolon hotkey. [Figure 7-11](ch07.xhtml#fig7_11) shows the resulting
    minimal comment window. The comment will be displayed next to the stack variable
    in a truncated format similar to an EOL comment. Hovering over the comment will
    display it in its entirety. The color of the comment matches the default color
    of the variable type, rather than the blue default for EOL comments.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将注释与堆栈变量关联，请选择堆栈变量并使用分号快捷键。[图 7-11](ch07.xhtml#fig7_11) 显示了生成的最小注释窗口。该注释将以类似于
    EOL 注释的格式显示在堆栈变量旁边。将鼠标悬停在注释上时，可以显示完整的注释。注释的颜色与变量类型的默认颜色相匹配，而不是 EOL 注释的蓝色默认颜色。
- en: '![image](Images/fig7-11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-11.jpg)'
- en: '*Figure 7-11: Stack variable comment*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：堆栈变量注释*'
- en: '***Annotations***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注释***'
- en: Ghidra provides a powerful capability to annotate comments with links to programs,
    URLs, addresses, and symbols in its Set Comment dialog. Symbol information in
    comments will automatically update when symbol names are changed. When you use
    an annotation to launch a specified executable, you can provide optional parameters
    to gain even more control (yes, that sounds dangerous to us, too).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 提供了一种强大的功能，可以在其“设置注释”对话框中为注释添加链接，链接可以指向程序、URL、地址和符号。当符号名称发生变化时，注释中的符号信息会自动更新。当你使用注释启动指定的可执行文件时，你还可以提供可选参数以获得更大的控制权限（是的，这对我们来说听起来也很危险）。
- en: For example, the annotation on a plate comment in [Figure 7-12](ch07.xhtml#fig7_12)
    provides a hyperlink to an address in the listing. Additional information about
    the power of annotations is provided in Ghidra Help.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图 7-12](ch07.xhtml#fig7_12) 中的板注释提供了一个指向清单中地址的超链接。关于注释强大功能的更多信息可以在 Ghidra
    帮助中找到。
- en: '![image](Images/fig7-12.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-12.jpg)'
- en: '*Figure 7-12: Address annotation example*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：地址注释示例*'
- en: '**Basic Code Transformations**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本代码转换**'
- en: In many cases, you will be perfectly content with the disassembly listings that
    Ghidra generates. In some cases, however, you won’t. As the types of files that
    you analyze diverge further and further from ordinary executables generated with
    common compilers, you may need to take more control of the disassembly analysis
    and display processes. This will be especially true if you analyze obfuscated
    code or files that utilize a custom (unknown to Ghidra) file format.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您会对Ghidra生成的反汇编列表感到非常满意。然而，在某些情况下，您可能不会满意。当您分析的文件类型越来越远离普通可执行文件时，您可能需要更多地控制反汇编分析和显示过程。如果您分析的是混淆代码或使用了自定义（Ghidra未知）文件格式的文件，这一点尤为重要。
- en: 'Ghidra facilitates the following code transformations (among others):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra支持以下代码转换（包括但不限于）：
- en: Changing code display options
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改代码显示选项
- en: Formatting instruction operands
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化指令操作数
- en: Manipulating functions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作函数
- en: Converting data into code
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换为代码
- en: Converting code into data
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码转换为数据
- en: In general, if a binary is very complex, or if Ghidra is not familiar with the
    code sequences generated by the compiler used to build the binary, then Ghidra
    will encounter more problems during the analysis phase, and you will need to make
    manual adjustments to the disassembled code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果二进制文件非常复杂，或者Ghidra不熟悉用于构建二进制文件的编译器生成的代码序列，那么在分析阶段，Ghidra将遇到更多问题，您需要手动调整反汇编代码。
- en: '***Changing Code Display Options***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改代码显示选项***'
- en: Ghidra allows very fine-grained control over the formatting of lines within
    the Listing window. Layout is controlled with the Browser Field Formatter (introduced
    in [Chapter 5](ch05.xhtml#ch05)). Selecting the Browser Field Formatter icon opens
    a tabbed display of all the fields associated with your listing, as displayed
    in [Figure 5-8](ch05.xhtml#fig5_8). You can add, delete, and rearrange fields
    by using a simple drag-and-drop interface that allows you to immediately observe
    the changes in your listing. The tight association between an item in the listing
    field and in the associated Browser Field Formatter is very useful. Anytime you
    move the cursor to a new location in the Listing window, the Browser Field Formatter
    moves the appropriate tab and associated field so that you can immediately identify
    options associated with a particular item. See “[Special Tool Editing Features](ch12.xhtml#ch12lev212)”
    on [page 247](ch12.xhtml#page_247) for additional discussion of the Browser Field
    Formatter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra允许对列表窗口中的行进行非常细粒度的格式控制。布局通过浏览器字段格式化器进行控制（在[第5章](ch05.xhtml#ch05)中介绍）。选择浏览器字段格式化器图标会打开一个选项卡式显示，展示与您的列表相关的所有字段，如[图5-8](ch05.xhtml#fig5_8)所示。您可以通过简单的拖放界面添加、删除和重新排列字段，并立即查看列表中的更改。列表字段项与关联的浏览器字段格式化器之间的紧密关联非常有用。每当您将光标移动到列表窗口中的新位置时，浏览器字段格式化器会自动移动相应的选项卡和字段，以便您可以立即识别与特定项相关的选项。有关浏览器字段格式化器的更多讨论，请参见[第12章](ch12.xhtml#ch12lev212)中的“[特殊工具编辑功能](ch12.xhtml#page_247)”。
- en: To control the appearance of individual elements within the Listing window,
    you can select Edit ▸ Tool Options, as described in [Chapter 4](ch04.xhtml#ch04).
    The unique submenus for each field in the Listing window allow you to fine-tune
    each field to your liking. While the capabilities associated with each field vary,
    in general you can control display colors, associated default values, configurations,
    and formats. For example, users who love assembly code and read it in their spare
    time may choose to adjust the default parameters in the EOL Comments Field area,
    shown in [Figure 7-13](ch07.xhtml#fig7_13), to activate the Show Semicolon at
    Start of Each Line option in order to view the assembly comments in a familiar
    format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制列表窗口中各个元素的显示方式，可以选择“编辑 ▸ 工具选项”，如[第4章](ch04.xhtml#ch04)所述。每个字段在列表窗口中都有独特的子菜单，允许您根据个人喜好微调每个字段。虽然每个字段的功能不同，但通常您可以控制显示颜色、关联的默认值、配置和格式。例如，喜欢汇编代码并在闲暇时阅读的用户，可能会选择调整EOL注释字段区域的默认参数，如[图7-13](ch07.xhtml#fig7_13)所示，启用“在每行开始处显示分号”选项，以便以熟悉的格式查看汇编注释。
- en: '![image](Images/fig7-13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-13.jpg)'
- en: '*Figure 7-13: Tool Options menu for EOL Comments Field*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：EOL 注释字段的工具选项菜单*'
- en: To color the background for individual lines or larger selections in the Listing
    window, select the Colors option through the right-click context menu and choose
    a color. The range of available colors is extensive, and a quick pick option is
    provided for recently used colors. Through the same menu, you can also clear the
    background color for a line, a selection, or an entire file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 若要为列表窗口中的单独行或较大范围的选择设置背景颜色，请通过右键点击上下文菜单选择“颜色”选项，并选择一种颜色。可用的颜色范围广泛，还提供了最近使用的颜色快速选择选项。通过相同的菜单，您还可以清除单行、选定区域或整个文件的背景颜色。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Clearing options do not appear if no colors are currently set for the listing.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果当前未为列表设置任何颜色，则清除选项不会显示。*'
- en: '#### ***Formatting Instruction Operands***'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***格式化指令操作数***'
- en: During the auto analysis process, Ghidra makes many decisions regarding how
    to format operands associated with each instruction, especially various integer
    constants used by a wide variety of instruction types. Among other things, these
    constants can represent relative offsets in jump or call instructions, absolute
    addresses of global variables, values to be used in arithmetic operations, or
    programmer-defined constants. To make a disassembly more readable, Ghidra attempts
    to use symbolic names rather than numbers whenever possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动分析过程中，Ghidra会做出许多关于如何格式化与每条指令相关的操作数的决定，尤其是各种整数常量，这些常量被各种指令类型广泛使用。其中，这些常量可能表示跳转或调用指令中的相对偏移、全局变量的绝对地址、算术运算中使用的值，或程序员定义的常量。为了提高反汇编的可读性，Ghidra尽量使用符号名称而不是数字。
- en: In some cases, formatting decisions are made based on the context of the instruction
    being disassembled (such as a call instruction); in other cases, the decision
    is based on the data being used (such as access to a global variable or an offset
    into a stack frame or structure). Often, the exact context in which a constant
    is used may not be discernable to Ghidra. When this happens, the constant is typically
    formatted as a hexadecimal value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，格式化决定是根据被反汇编指令的上下文做出的（例如调用指令）；在其他情况下，决定是基于所使用的数据（例如访问全局变量或栈帧或结构中的偏移量）。通常，Ghidra可能无法辨别常量使用的确切上下文。当这种情况发生时，常量通常以十六进制值的形式进行格式化。
- en: 'If you are not one of the few people in the world who eat, sleep, and breathe
    hex, then you will welcome Ghidra’s operand-formatting features. Assume that you
    have the following in your disassembly listing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是世界上少数几个以十六进制为生的人，你一定会欢迎Ghidra的操作数格式化功能。假设你的反汇编列表中有以下内容：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Right-clicking the hex constant `0x41` opens the context-sensitive menu shown
    in [Figure 7-14](ch07.xhtml#fig7_14). (See [Figure 6-7](ch06.xhtml#fig6_7) for
    this example in context.) The constant can be reformatted in the various numeric
    representations displayed on the right side of the figure, or as a character constant
    (since this value also falls within the ASCII printable range). This can be a
    very helpful feature as you may not realize the many representations that can
    be associated with a given constant. In all cases, the menu displays the exact
    text that will replace the operand text should a particular option be selected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击十六进制常量`0x41`，会弹出如[图 7-14](ch07.xhtml#fig7_14)所示的上下文敏感菜单。（请参见[图 6-7](ch06.xhtml#fig6_7)查看此示例的上下文。）该常量可以按图中右侧显示的各种数字表示重新格式化，或者作为字符常量（因为该值也在ASCII可打印范围内）。这个功能非常有帮助，因为你可能没有意识到给定常量可以关联的多种表示方式。在所有情况下，菜单会显示如果选择某个选项，操作数文本将被替换的确切文本。
- en: '![image](Images/fig7-14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-14.jpg)'
- en: '*Figure 7-14: Formatting options for constants*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：常量的格式化选项*'
- en: In many cases, programmers use named constants in their source code. Such constants
    may be the result of `#define` statements (or their equivalent), or they may belong
    to a set of enumerated constants. Unfortunately, by the time a compiler is finished
    with the source code, it is no longer possible to determine whether the source
    used a symbolic constant or a literal, numeric constant. Fortunately, Ghidra maintains
    a large catalog of named constants associated with many common libraries, such
    as the C standard library or the Windows API. This catalog is accessible via the
    Set Equate option (hotkey E) on the context-sensitive menu associated with any
    constant value. Selecting this option for the constant `0xa` opens the Set Equate
    dialog ([Figure 7-15](ch07.xhtml#fig7_15)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，程序员在源代码中使用命名常量。这些常量可能是`#define`语句（或其等效语句）的结果，或者它们可能属于枚举常量集合。不幸的是，当编译器处理完源代码后，已经无法确定源代码使用的是符号常量还是文字常量。幸运的是，Ghidra维护了一个包含许多常见库（如C标准库或Windows
    API）关联的命名常量的大型目录。通过在与任何常量值相关的上下文菜单中选择“设置等式”选项（快捷键E），可以访问此目录。选择常量`0xa`的“设置等式”选项后，会打开设置等式对话框（[图7-15](ch07.xhtml#fig7_15)）。
- en: '![image](Images/fig7-15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-15.jpg)'
- en: '*Figure 7-15: Set Equate dialog*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-15：设置等式对话框*'
- en: 'The dialog is populated from Ghidra’s internal list of constants after filtering
    according to the value of the constant we are attempting to format. In this case,
    we can scroll to see all of the constants that Ghidra knows to be equated with
    the value `0xA`. If we determined that the value was being used in conjunction
    with the creation of an X.25-style network connection, we might select `AF_CCITT`
    and end up with the following disassembly line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该对话框是从Ghidra的内部常量列表中填充的，经过筛选以符合我们正在尝试格式化的常量值。在这种情况下，我们可以滚动查看Ghidra已知的所有与值`0xA`相等的常量。如果我们确定该值与创建X.25风格的网络连接有关，我们可能会选择`AF_CCITT`，最终得到以下反汇编行：
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The list of standard constants is useful to determine whether a particular constant
    may be associated with a known name and can save a lot of time reading through
    API documentation in search of potential matches.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标准常量列表非常有用，可以帮助确定特定常量是否与已知名称相关联，并节省大量时间浏览API文档寻找潜在匹配项。
- en: '#### ***Manipulating Functions***'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***操作函数***'
- en: Ghidra provides the capability to manipulate functions in the disassembly (for
    example, correcting which code Ghidra identifies as belonging to functions, or
    changing function attributes), which is especially helpful when you disagree with
    the results of the auto analysis. In some cases, such as when Ghidra fails to
    locate a call to a function, functions may not be recognized, as there may be
    no obvious way to reach them. In other cases, Ghidra may fail to properly locate
    the end of a function, requiring you to correct the disassembly. Ghidra may have
    trouble locating the end of a function if a compiler has split the function across
    several address ranges or when, in the process of optimizing code, a compiler
    merges common end sequences of two or more functions in order to save space.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra提供了在反汇编中操作函数的功能（例如，修正Ghidra识别为属于函数的代码，或更改函数属性），这在你不同意自动分析结果时尤其有用。在某些情况下，例如Ghidra无法找到函数调用时，可能会无法识别函数，因为没有显而易见的方式可以到达它们。在其他情况下，Ghidra可能无法正确定位函数的结束位置，要求你修正反汇编。当编译器将函数分割到多个地址范围中，或在优化代码的过程中，编译器将两个或多个函数的常见结束序列合并以节省空间时，Ghidra可能会很难找到函数的结束位置。
- en: '**Creating New Functions**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建新函数**'
- en: New functions can be created from existing instructions that do not already
    belong to a function. You create functions by right-clicking the first instruction
    to be included in the new function and selecting Create Function (or hotkey F).
    If you selected a range, that will become the function body. If you did not, Ghidra
    will follow the control flow to try to determine the bounds of the function body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过现有的、不属于函数的指令创建新函数。创建函数的方法是右键点击将要包含在新函数中的第一条指令，并选择“创建函数”（或快捷键F）。如果选择了一个范围，它将成为函数体。如果没有选择，Ghidra将跟随控制流，试图确定函数体的边界。
- en: '**Deleting Functions**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除函数**'
- en: You can delete existing functions by placing the cursor within the function
    signature and using the hotkey DELETE. You may wish to delete a function if you
    believe that Ghidra has erred in its auto analysis or you have erred in creating
    a function. Note that while the function and its associated attributes will no
    longer exist, no change occurs to the underlying byte content, so the function
    can be re-created if desired.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将光标放置在函数签名内并使用快捷键 DELETE 删除现有的函数。如果您认为 Ghidra 在自动分析时出错，或者您在创建函数时出错，您可能希望删除某个函数。请注意，尽管函数及其相关属性将不再存在，但底层字节内容不会发生任何变化，因此如果需要，可以重新创建该函数。
- en: '**Editing Function Attributes**'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编辑函数属性**'
- en: Ghidra associates several attributes with each function that it recognizes,
    which can be viewed by selecting the Window ▸ Functions option from the CodeBrowser
    menu. (While only five attributes are displayed by default, you can add any of
    16 additional attributes by right-clicking in a column heading.) To edit the attributes,
    open the Edit Function dialog from the right-click context menu when the cursor
    is positioned in the region between a function’s plate comment and the last local
    variable listed before the beginning of the function’s disassembled code. An example
    of the Edit Function dialog is shown in [Figure 7-16](ch07.xhtml#fig7_16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 为它识别的每个函数关联多个属性，您可以通过从 CodeBrowser 菜单中选择“窗口 ▸ 函数”选项来查看这些属性。（虽然默认只显示五个属性，但您可以通过右键单击列标题添加额外的
    16 个属性。）要编辑这些属性，请在光标位于函数的板注释与函数反汇编代码开始前的最后一个局部变量之间的区域时，从右键上下文菜单中打开编辑函数对话框。编辑函数对话框的示例见[图
    7-16](ch07.xhtml#fig7_16)。
- en: '![image](Images/fig7-16.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig7-16.jpg)'
- en: '*Figure 7-16: Edit Function dialog*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：编辑函数对话框*'
- en: 'Each attribute that can be modified through this dialog is explained here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此对话框可以修改的每个属性在这里进行了说明：
- en: '**Function Name**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数名称**'
- en: You can modify the name within the text box at the top of the dialog or within
    the Function Name field.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在对话框顶部的文本框中修改名称，也可以在“函数名称”字段中修改。
- en: '**Function Attributes**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数属性**'
- en: Five optional function attributes can be enabled in this area. The first four
    attributes, Varargs, In Line, No Return, and Use Custom Storage, are checkboxes
    that are unchecked by default. The fifth optional attribute, Call Fixup, appears
    in the bottom left of the dialog, defaults to `none`, and provides a drop-down
    menu from which you can choose a value. If you modify any of the function’s attributes,
    Ghidra automatically propagates the function’s updated prototype to all locations
    at which it may be displayed throughout the disassembly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此区域可以启用五个可选的函数属性。前四个属性，Varargs、In Line、No Return 和 Use Custom Storage，默认为未选中复选框。第五个可选属性
    Call Fixup 出现在对话框的左下角，默认为 `none`，并提供一个下拉菜单，您可以从中选择一个值。如果您修改了任何函数的属性，Ghidra 会自动将更新后的函数原型传播到所有可能显示该函数的反汇编位置。
- en: The Varargs option indicates that a function takes a variable number of arguments
    (for example, `printf`). Varargs is also enabled if you edit (in the text field
    at the top of [Figure 7-16](ch07.xhtml#fig7_16)) the function’s parameter list
    such that the last argument has an ellipsis (. . .). The In Line option has no
    effect on disassembly analysis other than to include the `inline` keyword in the
    function’s prototype. (Keep in mind that if a function were actually inlined by
    a compiler, you would not see that function as a distinct entity in a disassembly
    because its body would have been embedded within the body of the functions that
    call it.) The No Return option is used when it is known that a function will never
    return (for example, if it uses `exit` or an opaque predicate to jump to another
    function). When a function is tagged as No Return, Ghidra will not assume that
    the bytes following a call to that function are reachable unless it has other
    evidence to support their reachability, such as a jump instruction targeting those
    bytes. The Use Custom Storage option allows you to override Ghidra’s analysis
    of parameter and return value storage locations and sizes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数（Varargs）选项表示函数接受可变数量的参数（例如，`printf`）。如果你在编辑函数参数列表（位于[图 7-16](ch07.xhtml#fig7_16)顶部的文本字段中），使得最后一个参数有省略号（...），也会启用可变参数。内联选项对反汇编分析没有影响，除了在函数原型中包含`inline`关键字。请注意，如果编译器实际内联了函数，你在反汇编中将看不到该函数作为一个独立实体，因为其主体将嵌入在调用它的函数体内部。无返回选项用于已知函数永远不会返回的情况（例如，使用`exit`或不透明谓词跳转到另一个函数）。当标记函数为无返回时，Ghidra将不假定调用该函数后的字节是可达的，除非有其他证据支持其可达性，例如跳转指令指向这些字节。使用自定义存储选项允许你覆盖Ghidra对参数和返回值存储位置及大小的分析。
- en: '**Calling Convention**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用约定**'
- en: The Calling Convention drop-down allows you to modify the calling convention
    used by the function. Modifying the calling convention may change Ghidra’s stack
    pointer analysis, so it is important to get this correct.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调用约定下拉菜单允许你修改函数使用的调用约定。修改调用约定可能会改变Ghidra的堆栈指针分析，因此正确设置非常重要。
- en: '**Function Variables**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数变量**'
- en: The Function Variables area allows you to edit function variables with guidance.
    As you modify the data in the four columns associated with the variables, Ghidra
    will provide information to help you change things appropriately. For example,
    attempts to change the Storage for `param_1` will result in a message saying `Enable
    'Use Custom Storage' to allow editing of Parameter and Return Storage`. The four
    icons on the right allow you to add, delete, and navigate through the variables.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数变量区域允许你在指导下编辑函数变量。当你修改与变量相关的四列数据时，Ghidra会提供信息，帮助你适当地进行更改。例如，尝试更改`param_1`的存储将显示消息：“启用‘使用自定义存储’以允许编辑参数和返回存储”。右侧的四个图标允许你添加、删除和导航变量。
- en: '***Converting Data to Code (and Vice Versa)***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将数据转换为代码（反之亦然）***'
- en: During the automatic analysis phase, data bytes may be incorrectly classified
    as code bytes and disassembled into instructions, or code bytes may be incorrectly
    classified as data bytes and formatted as data values. This happens for many reasons,
    including because some compilers embed data into the code section of programs
    and because some code bytes are never directly referenced as code and thus Ghidra
    opts not to disassemble them. Obfuscated programs in particular tend to deliberately
    blur the distinction between code and data. (See [Chapter 21](ch21.xhtml#ch21).)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动分析阶段，数据字节可能会被错误地分类为代码字节并解析为指令，或者代码字节可能会被错误地分类为数据字节并格式化为数据值。这种情况有多种原因，包括某些编译器将数据嵌入程序的代码部分，以及一些代码字节从未直接引用为代码，因此Ghidra选择不对其进行反汇编。特别是混淆程序通常故意模糊代码和数据之间的区别。（参见[第
    21 章](ch21.xhtml#ch21)。）
- en: 'The first option for reformatting anything is to remove its current formatting
    (code or data). It is possible to undefine functions, code, or data by right-clicking
    the item you wish to undefine and selecting Clear Code Bytes (hotkey C). Undefining
    an item causes the underlying bytes to be reformatted as a list of raw byte values.
    Large regions can be undefined by using a click-and-drag operation to select a
    range of addresses prior to performing the undefine operation. As an example,
    consider this simple function listing:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Undefining this function would yield the series of uncategorized bytes shown
    here, which we could reformat in virtually any manner:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To disassemble a sequence of undefined bytes, right-click the first byte to
    be disassembled and select **Disassemble**. This causes Ghidra to start the recursive
    descent algorithm at that point. Large regions can be converted to code by using
    click-and-drag to select a range of addresses prior to performing the code-conversion
    operation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Converting code to data is a little more complex. First, you cannot directly
    convert code to data by using the context menu, unless you first undefine the
    instructions that you wish to convert to data and then format the bytes appropriately.
    Basic data formatting is discussed in the following section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Data Transformations**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand a program’s behavior, properly formatted data can be as important
    as properly formatted code. Ghidra takes information from a variety of sources
    and uses an algorithmic approach to determine the most appropriate way to format
    data within a disassembly. For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Data types and/or sizes can be inferred from the manner in which registers are
    used. An instruction that loads a 32-bit register from memory implies that the
    associated memory location holds a 4-byte data type (though we may not be able
    to distinguish between a 4-byte integer and a 4-byte pointer).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function prototypes can be used to assign data types to function parameters.
    Ghidra maintains a large library of function prototypes for exactly this purpose.
    Analysis is performed on the parameters passed to functions in an attempt to tie
    a parameter to a memory location. If such a relationship can be uncovered, a data
    type can be applied to the associated memory location. Consider a function whose
    single parameter is a pointer to a `CRITICAL_SECTION` (a Windows API data type).
    If Ghidra can determine the address passed in a call to this function, that address
    can be flagged as a `CRITICAL_SECTION` object.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of a sequence of bytes can reveal likely data types. This is precisely
    what happens when a binary is scanned for string content. When long sequences
    of ASCII characters are encountered, it is not unreasonable to assume that they
    represent character arrays.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, we discuss some basic transformations that you can
    perform on data within your disassemblies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Specifying Data Types***'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra offers data size and type specifiers. The most commonly encountered specifiers
    are `byte`, `word`, `dword`, and `qword`, representing 1-, 2-, 4-, and 8-byte
    data, respectively. Data types can be set or changed by right-clicking any disassembly
    line that contains data (that is not an instruction) and selecting the Set Data
    Type submenu shown in [Figure 7-17](ch07.xhtml#fig7_17).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-17.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The Data submenu*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This list allows you to immediately change the formatting and data size of the
    currently selected item by choosing a data type. The Cycle option lets you quickly
    cycle through a group of associated data types, such as numeric, character, and
    floating point types, as shown (with associated hotkeys) in [Figure 7-18](ch07.xhtml#fig7_18).
    For example, repeatedly pressing F would cycle you between float and double, as
    they are the only items in that cycle group.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-18.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: Cycle groups*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Toggling through data types causes data items to grow, shrink, or remain the
    same size. If an item’s size remains the same, the only observable change is in
    the way the data is formatted. If you reduce an item’s size, from `ddw` (4 bytes)
    to `db` (1 byte), for example, any extra bytes (3 in this case) become undefined.
    If you increase the size of an item, Ghidra will warn you of any conflict and
    guide you through resolving it. An example involving array dimensioning is shown
    in [Figure 7-19](ch07.xhtml#fig7_19).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-19.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: Example of an array declaration and warning*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Strings***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Choosing Search ▸ For Strings brings up the dialog shown in [Figure 7-20](ch07.xhtml#fig7_20),
    where you can set and control the search criteria for a specific string search.
    While most of the fields in this window are self-explanatory, a unique feature
    of Ghidra is the ability to associate a *word model* with a search. A word model
    can be used to determine whether a particular string is considered a word in a
    given context. Word models are discussed in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-20.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-20: Search For Strings dialog*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Once a search has been conducted, the results are presented in a String Search
    window ([Figure 7-21](ch07.xhtml#fig7_21)). Subsequent searches will be tabbed
    within the same window, and the window title bar will include timestamps for each
    search so you can easily order them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-21.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-21: String Search window showing search results*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost column of the String Search window contains icons that indicate
    the string definition status (from undefined to conflicting). The meanings of
    the icons are shown in [Figure 7-22](ch07.xhtml#fig7_22). To show or hide strings
    in any of the categories, toggle the corresponding icons in the title bar.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig7-22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-22: String toggle icon definitions*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Using the icons allows you to easily identify the items in the listing that
    are not already defined as strings and make a string or character array from these
    entries by selecting them and clicking the Make String or Make Char Array button,
    as appropriate. These newly defined entities will be displayed in the Defined
    Strings window, which is discussed in “[The Defined Strings Window](ch05.xhtml#ch05lev84)”
    on [page 81](ch05.xhtml#page_81).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Arrays***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the drawbacks to disassembly listings derived from higher-level languages
    is that they provide very few clues regarding the size of arrays. In a disassembly
    listing, an array can require a tremendous amount of space if each item in the
    array is specified on its own line. The following listing shows a sequence of
    items in a data section. The fact that only the first item in the listing is referenced
    by any instructions suggests that it may be the first element in an array. Rather
    than being referenced directly, additional elements within arrays are often referenced
    using index computations relative to the beginning of the array.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ghidra can group consecutive data definitions into a single array definition.
    To create an array, select the first element of the array and use the Data ▸ Create
    Array option in the context menu (hotkey [). You will be prompted for the number
    of elements in the array, or you can accept the default that Ghidra suggests.
    (If you have selected a range of data, rather than a single value, Ghidra will
    use your selection as the array bounds.) By default, the data type and size associated
    with the array elements are based on the data type of the first element in the
    selection. The array is presented in a collapsed format, but can be expanded to
    view the individual elements. The number of elements displayed per line is controlled
    in the Edit ▸ Tool Options of the CodeBrowser window. Arrays are discussed more
    thoroughly in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '### **Summary**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Together with the previous chapter, this chapter encompasses the most common
    operations that Ghidra users will ever need to perform. Disassembly manipulation
    lets you combine your knowledge with the knowledge imparted by Ghidra during its
    analysis phase to produce valuable information. As in source code, the effective
    use of names, assignment of data types, and detailed comments will not only assist
    you in remembering what you have analyzed but also greatly assist others who make
    use of your work. In the next chapter, we take a look at how to deal with more
    complex data structures, such as the C `struct`, and examine some of the low-level
    details of compiled C++.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
