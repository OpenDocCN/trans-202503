- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PACKERS
    AND UNPACKING MALWARE</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: Modern malware needs built-in protections to evade modern endpoint and network
    defenses. Ideally, these protections will also impede reverse-engineering and
    help protect the malware’s payload and internals from investigators. One option
    is a *packer*, a tool that adds obfuscation and protection to software. Many of
    the malware samples you’re likely to encounter in the wild will be packed, so
    it’s very important to be familiar with them. This chapter will introduce various
    types of malware packers, their architecture, how they work, and, most importantly,
    how to bypass them in order to access the malicious code they contain.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Types of Packers</samp>'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: When packers were originally designed, there was nothing inherently malicious
    about them. They were used simply to compress files such as executables. Once
    malware started using packing programs, however, the word *packer* became synonymous
    with malware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple varieties of packers. The most common type, which I’ll call
    *general packers*, is often free, open source, or otherwise widely available.
    Examples of general packers include NSPack, MPRESS, and UPX (Ultimate Packer for
    Executables), which are freely available to anyone, including malware authors.
    The downside of malware using general packers (for their authors, at least) is
    that they’re typically very easy to unpack using automated tools or manual analysis
    since they weren’t designed with anti-analysis in mind. Still, some malware samples
    in the wild use these simple packers as a quick and inexpensive way to provide
    basic obfuscation for their payloads.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The second type of packer includes *commercial packers* such as VMProtect, Themida,
    and Armadillo. Also known as protectors or obfuscators, these were created primarily
    for protecting the intellectual property of legitimate software. Because a lot
    of research went into their design, commercial packers are often very difficult
    to unpack. Luckily for us, they’re not as commonly used to protect malware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last type of packer is designed specifically for malware. These
    packers, sometimes called *crypters*, are often developed by threat actor groups
    or affiliates and sold on hacker forums. Some examples of this type of packer
    are Warzone, Atilla, and Softinca Crypter, the last of which is shown in [Figure
    17-1](chapter17.xhtml#fig17-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-1: The interface
    for Softinca Crypter</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Softinca Crypter takes an executable file (the unpacked malware payload) as
    input, adds protection such as code obfuscation and the ability to hide the payload
    execution from the victim, and then creates the packed executable file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since* packer *is often used as a catch-all term for protectors, obfuscators,
    and crypters, I’ll follow that convention throughout this chapter.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于*打包程序*通常作为保护工具、混淆器和加密器的统称，本章中我将遵循这一惯例。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Packer Architecture and Functionality</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">打包程序架构与功能</samp>
- en: When a malware executable is run through a packing program, the program encrypts
    and compresses the PE’s sections (*.text*, *.data*, *.rdata*, *.rsrc*, and so
    on) within the executable. The packer also adds an *unpacking stub*, a (usually)
    small section of code that’s responsible for decrypting the executable’s sections
    once it’s run on the target host, to the packed executable. [Figure 17-2](chapter17.xhtml#fig17-2)
    illustrates this process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件可执行文件通过打包程序运行时，该程序会加密并压缩可执行文件中的各个 PE 部分（*.text*、*.data*、*.rdata*、*.rsrc*
    等）。打包程序还会添加一个*解包存根*，这通常是一个小的代码段，负责在目标主机上运行后解密可执行文件的各个部分。 [图 17-2](chapter17.xhtml#fig17-2)
    展示了这一过程。
- en: '![](../images/fig17-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-2: The malware packing
    process</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-2：恶意软件打包过程</samp>
- en: You can see in [Figure 17-2](chapter17.xhtml#fig17-2) that the unpacked malware
    executable is being run through the packing program, which takes its code and
    data and encrypts (or packs) it. The unpacking stub is also added to the packed
    file. Upon running on the victim host, the unpacking stub decrypts the packed
    code and data, loads the unpacked payload into memory, and executes the payload
    by transferring control flow to the *Original Entry Point (OEP)*, as shown in
    [Figure 17-3](chapter17.xhtml#fig17-3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 17-2](chapter17.xhtml#fig17-2) 中看到，解包后的恶意软件可执行文件正在通过打包程序运行，该程序将其代码和数据加密（或打包）。解包存根也被添加到打包文件中。在受害者主机上运行时，解包存根解密打包的代码和数据，将解包后的有效载荷加载到内存中，并通过将控制流转移到*原始入口点（OEP）*来执行有效载荷，如
    [图 17-3](chapter17.xhtml#fig17-3) 所示。
- en: '![](../images/fig17-3.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-3: Packed malware
    being unpacked into memory</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-3：打包的恶意软件正在解包到内存中</samp>
- en: Let’s take a look at this process in more depth.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这个过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacking the Malware
    Payload</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">解包恶意软件有效载荷</samp>
- en: Before the malware’s payload can be executed, it must be unpacked. The unpacking
    stub must decrypt (or deobfuscate) the original executable file’s code and data
    into memory. For most Windows executables, this will involve running decryption
    and decompression algorithms on the packed executable, allocating memory space
    using Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    and writing the newly unpacked executable to the new memory region.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件的有效载荷可以执行之前，它必须被解包。解包存根必须将原始可执行文件的代码和数据解密（或去混淆）到内存中。对于大多数 Windows 可执行文件，这通常涉及对打包的可执行文件执行解密和解压算法，使用
    Windows API 函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>）分配内存空间，并将解包后的可执行文件写入新的内存区域。
- en: Unpacking can occur in one or more stages. General packers, such as UPX, simply
    unpack the executable in memory and run it. Other packers, especially custom packers
    designed for malware, may have more than one unpacking stage, as shown in [Figure
    17-4](chapter17.xhtml#fig17-4).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可以分为一个或多个阶段。一般的打包程序，如 UPX，简单地在内存中解包可执行文件并运行它。其他打包程序，尤其是为恶意软件设计的定制打包程序，可能有多个解包阶段，如
    [图 17-4](chapter17.xhtml#fig17-4) 所示。
- en: '![](../images/fig17-4.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-4: Malware using
    multistage unpacking</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-4：使用多阶段解包的恶意软件</samp>
- en: The simplified process shown in [Figure 17-4](chapter17.xhtml#fig17-4) illustrates
    a packed malware sample unpacking code Segment 1, which unpacks code Segment 2,
    which in turn unpacks code Segment 3\. By unpacking the code in pieces, malware
    can evade host-based defenses that are looking for the entire malicious code in
    memory. This sort of unpacking routine also complicates the malware analysis process
    since the analyst will have a more difficult time understanding the unpacking
    process and identifying all the locations in memory into which the malware is
    being unpacked.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-4](chapter17.xhtml#fig17-4)中显示的简化过程展示了一个压缩恶意软件样本解包代码段1，它解包代码段2，后者又解包代码段3。通过分段解包代码，恶意软件可以规避宿主防御措施，这些防御措施通常会在内存中查找整个恶意代码。这种解包例程还使恶意软件分析过程更加复杂，因为分析人员将更难理解解包过程并识别恶意软件解包到内存中的所有位置。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Resolving Imports</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">解析导入</samp>
- en: Once the malware’s payload has been unpacked into memory, the unpacking stub
    must resolve the imports of the original executable. Remember, imports are the
    Windows libraries (DLLs) that allow the executable to function within a Windows
    environment. When a malware sample is run through a packing program, the import
    address table (IAT) is typically obfuscated or hidden to mask the intent of the
    program and better evade defenses. This IAT must be rebuilt for the malware’s
    unpacked executable to function as originally intended.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件的有效载荷被解包到内存中，解包存根必须解析原始可执行文件的导入。请记住，导入是Windows库（DLL），允许可执行文件在Windows环境中运行。当恶意软件样本通过打包程序运行时，导入地址表（IAT）通常会被混淆或隐藏，以掩盖程序的意图并更好地规避防御。这一IAT必须被重建，以便恶意软件的解包可执行文件能够按原定意图运行。
- en: It’s common for packed malware to contain only a few entries in its IAT, including
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> functions. These
    two functions are often used to load additional libraries, resolve function addresses,
    and rebuild the IAT of the original executable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    function loads each library required by the original malware executable, and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> function gets
    the address of each required function. You should be suspicious if you come across
    an executable file with only a few libraries listed in its IAT.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩的恶意软件通常只在其IAT（导入地址表）中包含几个条目，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>函数。这两个函数通常用于加载附加库、解析函数地址，并重建原始可执行文件的IAT。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>函数加载原始恶意软件可执行文件所需的每个库，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>函数获取每个所需函数的地址。如果你遇到一个IAT中只列出了少数几个库的可执行文件，你应该保持警惕。
- en: Packers might also remove all imports, leaving behind an empty IAT. This is
    the stealthiest approach, but the unpacking stub is then required to do the heavy
    lifting and resolve all imports. It starts by getting the address of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    functions, and then it loads each library and resolves each function address needed
    for the unpacked payload’s operation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 打包工具也可能删除所有导入，留下一个空的IAT。这是最隐蔽的方式，但解包存根需要做大量工作来解析所有导入。它首先获取<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>函数的地址，然后加载每个库并解析解包后的有效载荷操作所需的每个函数地址。
- en: Alternatively, certain packers will not rebuild the original IAT at all. In
    this case, the imports and address resolution process must be completely handled
    by the unpacked malware itself. If this is the case, you will see the malware
    likely using <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to resolve
    its imports *after* the unpacking process has completed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，某些打包工具根本不会重建原始IAT。在这种情况下，导入和地址解析过程必须完全由解包后的恶意软件自己处理。如果是这种情况，你将看到恶意软件很可能会在解包过程完成*之后*使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>来解析其导入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Transferring Execution
    to the OEP</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">转移执行到OEP</samp>
- en: Finally, once the malware is unpacked and the IAT is rebuilt, the unpacking
    stub must transfer execution from its own code to the OEP of the executable. The
    OEP is where the unpacked malware payload will begin executing its code. This
    transfer of execution, often called the *tail jump* or *tailing jump*, usually
    appears in the form of a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>),
    return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>), or <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction at the end of the unpacking stub. Once this instruction is hit, the
    program control will be transferred to the unpacked code in memory, and the unpacked
    malware payload will finally run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Many packers, especially ones designed specifically for malware packing, implement
    some form of code injection technique to try to bypass defenses and hide on the
    host. For example, a packer might allocate memory inside an arbitrary or specific
    process on the victim host, write its unpacked code into that memory, and transfer
    execution to this code. In this case, you’ll likely spot some of the process injection
    techniques and related functions covered in [Chapter 12](chapter12.xhtml). This
    is an important point to remember, and we’ll come back to it later in the chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at how to identify whether malware is packed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Identify Packed Malware</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you begin to unpack a malware sample, you have to identify whether it’s
    even packed to begin with. There are a few ways to do so.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Viewing Imports</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the simplest and most effective ways of determining whether a sample
    is packed is to inspect the file’s imports. You can do this with almost any PE
    file viewer tool, such as CFF Explorer, PEStudio, and PE-bear. Packed malware
    may have only a few imported libraries and functions. The screenshot from PEStudio
    in [Figure 17-5](chapter17.xhtml#fig17-5) illustrates what packed malware might
    look like.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-5.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-5: Viewing a packed
    malware sample in PEStudio</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Notice how there’s only a limited subset of functions listed, two of which are
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>.
    By comparison, in [Figure 17-6](chapter17.xhtml#fig17-6) you can see an unpacked
    malware sample’s list of imports.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-6.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-6: Viewing an unpacked
    malware sample in PEStudio</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the malware sample in [Figure 17-6](chapter17.xhtml#fig17-6) has more
    imports. Again, if malware has only a limited list of imports, there’s a good
    chance that it is packed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inspecting Strings</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another good way to determine whether a sample is packed is to inspect its strings.
    Packed malware will have either many strings that aren’t human readable or hardly
    any strings at all. This is because during the packing process, the packer compresses,
    encrypts, or otherwise obfuscates the data in the file to make analysis more difficult
    and to bypass defenses. The screenshot from PEStudio in [Figure 17-7](chapter17.xhtml#fig17-7)
    shows what packed malware’s strings might look like.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个判断样本是否被打包的好方法是检查它的字符串。打包的恶意软件要么有许多不可读的字符串，要么几乎没有任何字符串。这是因为在打包过程中，打包器会压缩、加密或以其他方式混淆文件中的数据，使得分析更加困难，并绕过防御措施。[图
    17-7](chapter17.xhtml#fig17-7)中的PEStudio截图展示了打包恶意软件字符串的可能样子。
- en: '![](../images/fig17-7.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-7: Strings from a
    packed malware sample</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-7：打包恶意软件样本的字符串</samp>
- en: In contrast, an unpacked sample should have many cleartext (deobfuscated) strings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，未打包的样本应该有许多明文（已去混淆）的字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Calculating the Entropy
    Value</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">计算熵值</samp>
- en: Packed malware will likely have a high entropy value. *Entropy* is the measurement
    of randomness in data. High entropy indicates that the data may be encrypted or
    compressed, and in the context of packing, it suggests that a sample is likely
    packed. The maximum possible entropy value is 8; the closer the file gets to this
    value, the more likely that it is packed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的恶意软件通常会有较高的熵值。*熵*是数据随机性的度量。高熵表示数据可能已被加密或压缩，在打包的背景下，这意味着样本很可能是打包过的。最大可能的熵值是8；文件的熵值越接近这个值，它被打包的可能性就越大。
- en: There are many tools that can calculate the entropy of a malware executable,
    but I’ve used PEStudio as an example once again. [Figure 17-8](chapter17.xhtml#fig17-8)
    illustrates the entropy value of a packed malware sample.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以计算恶意软件可执行文件的熵值，但我再次使用了PEStudio作为示例。[图 17-8](chapter17.xhtml#fig17-8)展示了一个打包恶意软件样本的熵值。
- en: '![](../images/fig17-8.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-8: Viewing a packed
    malware entropy value in PEStudio</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-8：在PEStudio中查看打包恶意软件的熵值</samp>
- en: A good rule of thumb is that a packed executable file will have an entropy value
    of about 6 or higher. Anything lower than this, and the chances that the file
    is packed decrease.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是，打包的可执行文件熵值大约为6或更高。低于这个值的文件，文件被打包的可能性较低。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Keep in mind that some non-PE files (such as document files) will always have
    a high entropy value, so the “6 or higher” rule of thumb applies only to PE files.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，某些非PE文件（如文档文件）通常会有较高的熵值，因此“6或更高”这一经验法则仅适用于PE文件。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Checking PE Sections</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">检查PE节</samp>
- en: You can also use the PE file section information to determine whether malware
    is packed. As you may remember from [Chapter 1](chapter1.xhtml), executable files
    have multiple sections called *.text*, *.data*, *.rdata*, .*rsrc*, and so on.
    In a normal, nonpacked executable, the sections will be labeled with these names.
    Sometimes packers rename these sections in the file in a way that identifies the
    packer. For example, the UPX packer renames them to *UPX0*, *UPX1*, and so on.
    Another anomaly of packed malware is that it often has too many or not enough
    sections. A normal, nonpacked executable typically has four sections (give or
    take a few), so a file with nine sections or only one or two sections is a possible
    red flag and should be investigated further.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用PE文件的节信息来判断恶意软件是否被打包。如你可能记得的那样，[第1章](chapter1.xhtml)中提到过，可执行文件有多个节，分别是*.text*、*.data*、*.rdata*、.*rsrc*等。在一个正常的非打包可执行文件中，这些节会被标记为这些名称。有时，打包器会以一种识别打包器的方式重命名文件中的节。例如，UPX打包器会将它们重命名为*UPX0*、*UPX1*等。另一个打包恶意软件的异常特征是它通常有太多或不够的节。一个正常的非打包可执行文件通常有四个节（大约一两个多一些或少一些），因此一个拥有九个节或只有一两个节的文件可能是一个警示信号，应该进一步调查。
- en: There are many different tools that allow you to view PE file section information.
    In [Figure 17-9](chapter17.xhtml#fig17-9), I’ve used PE-bear to show what a packed
    malware sample may look like.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的工具可以让你查看PE文件的节信息。在[图 17-9](chapter17.xhtml#fig17-9)中，我使用了PE-bear来展示一个打包恶意软件样本的外观。
- en: '![](../images/fig17-9.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-9: Viewing a packed
    malware sample’s PE sections in PE-bear</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-9：在 PE-bear 中查看被打包恶意软件样本的
    PE 区段</samp>
- en: The file in this figure has only two sections. One is completely unlabeled,
    and the other is called *petite*, which is a nonstandard executable section name.
    This file is likely packed, possibly using the Petite packer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该图中的文件只有两个区段。一个区段完全没有标签，另一个被称为 *petite*，这是一个非标准的可执行区段名称。该文件很可能是被打包过的，可能使用了 Petite
    打包器。
- en: 'Lastly, a PE file’s section sizes can be another great indicator of packing.
    Each section has two size characteristics: the raw size and the virtual size.
    The PE file’s *raw size* is the size of the section on disk, and the *virtual
    size* is the size once it is executed and subsequently mapped to memory. If you
    spot a malware sample that has a raw size of zero and a virtual size of nonzero,
    this is a good indication that the malware is packed. In this case, the malware
    may be trying to hide its code in another section, for example.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PE 文件的区段大小也是打包的一个重要指标。每个区段有两个大小特征：原始大小和虚拟大小。PE 文件的 *原始大小* 是区段在磁盘上的大小，而 *虚拟大小*
    是文件执行并随后映射到内存后占用的大小。如果你发现一个恶意软件样本的原始大小为零，虚拟大小非零，那么这很可能表明该恶意软件是被打包的。在这种情况下，恶意软件可能试图将其代码隐藏在另一个区段中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Automated Packer
    Detection</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用自动化打包器检测</samp>
- en: Finally, the simplest method of determining whether or not a malware sample
    is packed is using an automated packer detection tool. There are several of these
    tools available, but my personal favorites are Detect It Easy (DIE), Exeinfo PE,
    PE Detective, and CFF Explorer. These tools provide information such as the file’s
    entropy, section names and sizes, compiler data, and sometimes (in the best case)
    the name of the packer itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的判断恶意软件样本是否被打包的方法是使用自动化打包器检测工具。市面上有几种这类工具，但我个人最喜欢的是 Detect It Easy (DIE)、Exeinfo
    PE、PE Detective 和 CFF Explorer。这些工具提供的信息包括文件的熵值、区段名称和大小、编译器数据，有时（在最佳情况下）还会提供打包器的名称。
- en: 'Exeinfo PE, for example, attempts to identify the packer variant using static
    signatures. In [Figure 17-10](chapter17.xhtml#fig17-10), you can see Exeinfo PE
    in action: it has identified that this malware sample is possibly written in .NET
    and potentially packed with the DeepSea obfuscator.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Exeinfo PE 试图使用静态签名识别打包器变种。在 [图 17-10](chapter17.xhtml#fig17-10) 中，你可以看到
    Exeinfo PE 的运行情况：它已识别出该恶意软件样本可能是用 .NET 编写的，并且可能被 DeepSea 混淆器打包。
- en: '![](../images/fig17-10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-10: Identifying a
    malware’s packer in Exeinfo PE</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-10：在 Exeinfo PE 中识别恶意软件的打包器</samp>
- en: While automated packer detectors like Exeinfo PE are not always 100 percent
    accurate, using them is a great first step in inspecting malware executable files,
    and they can provide vital tips to guide your analysis and unpacking process.
    It’s always best to try a few of these tools and see which provides the best output
    for the malware sample you are inspecting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像 Exeinfo PE 这样的自动化打包器检测工具并不总是 100% 准确，但它们是检查恶意软件可执行文件的良好第一步，并且可以为你的分析和解包过程提供重要的提示。最好尝试几种工具，看看哪一种能为你正在检查的恶意软件样本提供最好的输出。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Many of these tools update their detection databases regularly, so be sure
    to install any updates for these tools to ensure that you’re getting accurate
    results.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多这些工具会定期更新其检测数据库，因此务必安装这些工具的更新，以确保获取准确的结果。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Automated Unpacking</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自动解包</samp>
- en: Once you’ve identified that the malware sample is indeed packed, you can start
    thinking of ways to unpack it. You may be asking yourself, *Why should I unpack
    the malware sample? Can’t I simply run it and analyze it as is?* It’s always an
    option to simply run the malware in a sandbox or debugger and avoid unpacking
    entirely; in fact, I’ll specifically address that in “Analyzing Without Unpacking”
    on [page 383](chapter17.xhtml#pg_383). However, unpacking allows you to get to
    the heart of the malware and extract its payload, which is often necessary for
    you to fully understand the malware’s capabilities and statically analyze its
    code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认恶意软件样本确实被打包了，就可以开始考虑解包的方法。你可能会问自己，*为什么要解包恶意软件样本？我不能直接运行它并进行分析吗？* 当然，也可以选择直接在沙箱或调试器中运行恶意软件，完全避免解包；事实上，我将在《不解包分析》一章的[第383页](chapter17.xhtml#pg_383)专门讨论这一点。然而，解包能让你深入了解恶意软件的核心并提取其有效载荷，这通常是你完全理解恶意软件的能力并对其代码进行静态分析所必需的。
- en: While you can still understand a malware’s behaviors without unpacking it, you
    may lose some nuance. An example is a malware sample that has hidden capabilities
    or acts differently depending on its analysis environment. In the context of evasive
    malware, for example, this could mean that the malware behaves differently in
    an automated malware sandbox. Without unpacking this malware and closely analyzing
    its code, you might miss some key behaviors, capabilities, and indicators. There
    are multiple ways to unpack a malware sample, including fully automated unpacking,
    sandbox-assisted unpacking, manual dynamic unpacking, and static unpacking. We’ll
    begin in this section with fully automated unpacking and sandbox-assisted unpacking,
    then dig into the other methods in the coming sections.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你仍然可以理解恶意软件的行为而无需解包它，但你可能会错过一些细微之处。例如，一个恶意软件样本可能具有隐藏的功能，或根据分析环境的不同而表现出不同的行为。在回避恶意软件的情况下，这意味着恶意软件在自动化的恶意软件沙箱中可能表现不同。如果不解包并仔细分析其代码，你可能会错过一些关键的行为、能力和指标。解包恶意软件样本的方法有很多，包括完全自动化解包、沙箱辅助解包、手动动态解包和静态解包。本节将从完全自动化解包和沙箱辅助解包开始，随后在接下来的章节中深入探讨其他方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Fully Automated Unpacking</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">完全自动化解包</samp>
- en: '*Fully automated unpacking* is the simplest and fastest method of unpacking
    a malware sample, so it’s always a good idea to try it first. Many general and
    common packers have either built-in capabilities for unpacking or automated unpackers
    written specifically for them. The UPX packing program contains a flag that allows
    files to be unpacked as well. Simply passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    parameter to UPX like so will unpack the file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全自动化解包*是解包恶意软件样本最简单和最快捷的方法，因此总是建议首先尝试这一方法。许多通用和常见的打包工具都具有内置的解包功能，或者有专门为它们编写的自动化解包工具。UPX打包程序包含一个标志，允许文件解包。只需像这样将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">-d</sup>参数传递给UPX，就能解包该文件：'
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Other tools include Un{i}packer, which uses code emulation to unpack many common
    packers (such as MPRESS, ASPack, and, of course, UPX), and Universal Extractor
    2 (UniExtract2), which can unpack many common packers and compressed file archives.
    You should first try to identify the packer being used; employ the techniques
    you’ve seen so far and then test out some of these helpful automated tools.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具包括Un{i}packer，它通过代码仿真解包许多常见的打包工具（如MPRESS、ASPack，以及当然的UPX），还有Universal Extractor
    2（UniExtract2），它可以解包许多常见的打包工具和压缩文件档案。你应该首先尝试识别正在使用的打包工具；运用你迄今为止学到的技巧，然后尝试一些这些有用的自动化工具。
- en: One important thing to remember is that common packers like the ones just mentioned
    can be modified by malware authors, since many of them are open source. It’s relatively
    simple to modify these packers to prevent unpacking with these fully automated
    methods. Also keep in mind that advanced malware generally won’t be packed (or,
    at least, won’t be solely packed) with free and common packers, so make sure not
    to rely only on these automated tools. As you’ll soon see, there are many other
    tools that can assist you in both automated and semiautomated unpacking.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件重要事情是，像刚才提到的常见打包工具可以被恶意软件作者修改，因为它们中的许多是开源的。恶意软件作者修改这些打包工具来防止通过这些完全自动化方法进行解包是相对简单的。同样，记住高级恶意软件通常不会仅仅使用免费和常见的打包工具进行打包（或者至少不会仅仅使用这些工具），所以不要只依赖这些自动化工具。正如你很快就会看到的那样，还有许多其他工具可以帮助你进行自动化和半自动化的解包。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sandbox-Assisted Unpacking</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">沙箱辅助解压</samp>
- en: The next-simplest way to unpack a sample is to use a malware analysis sandbox.
    Many malware sandboxes can automate malware unpacking, typically by detecting
    malicious code in memory, hooking and monitoring key Windows functions often invoked
    during the malware-unpacking process, and automating the extraction of executable
    code from memory. One sandbox that does this fairly well is the commercial sandbox
    VMRay Analyzer. In the output shown in [Figure 17-11](chapter17.xhtml#fig17-11),
    you can see that VMRay Analyzer was able to extract the malware from memory in
    its various stages of unpacking.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解压样本的下一个最简单方法是使用恶意软件分析沙箱。许多恶意软件沙箱可以自动化恶意软件的解压，通常通过检测内存中的恶意代码、挂钩并监视在恶意软件解压过程中经常调用的关键Windows函数，以及自动从内存中提取可执行代码。一个做得比较好的沙箱是商业沙箱VMRay分析器。在[图17-11](chapter17.xhtml#fig17-11)所示的输出中，您可以看到VMRay分析器成功地从内存中提取了恶意软件，并展示了其解压的不同阶段。
- en: '![](../images/fig17-11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-11: Viewing malware
    executable code dumped from memory in the VMRay Analyzer sandbox</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图17-11：在VMRay分析器沙箱中查看从内存中转储的恶意软件可执行代码</samp>
- en: In this screenshot you can see how VMRay Analyzer has attempted to unpack the
    sample by dumping the malware’s memory at key stages of its behavior. For example,
    as you can see in the Dump Reason column, the malicious code is dumped from memory
    when its content is changed, when it is first executed, and when there is an executable
    file (image) in memory. VMRay Analyzer has also attempted to rebuild the PE headers
    of the dumped executable file so that it can be better analyzed in a disassembler
    or debugger.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，您可以看到VMRay分析器如何通过在恶意软件行为的关键阶段转储内存来尝试解压样本。例如，正如您在“Dump Reason”列中看到的那样，当恶意代码的内容发生变化、第一次执行时，或者内存中出现可执行文件（镜像）时，恶意代码会从内存中转储。VMRay分析器还尝试重建转储的可执行文件的PE头，以便在反汇编器或调试器中更好地分析。
- en: 'There’s even a sandbox dedicated solely to unpacking: UnpacMe. According to
    its author, “UnpacMe automates the first step in your malware analysis process.”
    That is, it automates the unpacking process. UnpacMe is a commercial sandbox but
    (at the time of this writing) offers a free service with limited submissions per
    month. [Figure 17-12](chapter17.xhtml#fig17-12) shows an example submission to
    UnpacMe and the resulting unpacked, downloadable payload files.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至有一个专门用于解压的沙箱：UnpacMe。根据其作者的说法，“UnpacMe自动化了恶意软件分析过程的第一步。”也就是说，它自动化了解压过程。UnpacMe是一个商业沙箱，但（截至本书写作时）提供免费的服务，每月提交次数有限。[图17-12](chapter17.xhtml#fig17-12)展示了一个提交到UnpacMe的示例，以及解压后可下载的有效载荷文件。
- en: '![](../images/fig17-12.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig17-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-12: A malware sample
    unpacked by UnpacMe</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图17-12：通过UnpacMe解压的恶意软件样本</samp>
- en: Sometimes malware sandboxes fail to successfully unpack the malware’s payload.
    There are a number of reasons for this, such as evasive behaviors by the malware
    or failure to follow the malware’s unpacking process in memory. Let’s look at
    some manual unpacking techniques that will help you in the event that these automated
    techniques fail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时恶意软件沙箱无法成功解压恶意软件的有效载荷。这可能有多种原因，例如恶意软件的规避行为，或未能按照恶意软件在内存中的解压过程进行操作。让我们来看看一些手动解压技术，这些技术可以帮助您在自动化技术失败时使用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Manual Dynamic Unpacking</samp>
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">手动动态解压</samp>
- en: 'Manual unpacking involves identifying where the unpacking routine is located
    in the packed malware’s code, determining how it is unpacking the malware, and
    following this unpacking process to “catch” the malware’s payload in a freshly
    unpacked state. There are two forms of manual unpacking: dynamic and static.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解压涉及确定解压例程在打包恶意软件代码中的位置，了解它是如何解压恶意软件的，并跟踪这个解压过程以“捕捉”恶意软件的有效载荷到一个新解压的状态。手动解压有两种形式：动态解压和静态解压。
- en: '*Manual dynamic unpacking* involves detonating the malware in a virtual machine
    environment and allowing the malware to execute and unpack as it normally would
    on a victim host, while using a debugger to follow the unpacking process and catch
    the unpacked payload in memory. By contrast, *static unpacking* involves reverse
    engineering the malware’s unpacking stub code, re-creating this code logic, and
    running it on the packed malware. This section will focus on dynamic packing,
    and we’ll discuss static unpacking in “Manual Static Unpacking” on [page 382](chapter17.xhtml#pg_382).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Rather than providing very specific techniques for unpacking certain packers,
    I’ll be covering more generic methods that you can use to dynamically unpack many
    variants of malware, regardless of the packer used. These techniques are not presented
    in any particular order; every packer behaves differently, so there’s no one-size-fits-all
    technique. You may need to try different techniques or combine bits and pieces
    from several of them. This is what makes unpacking so challenging but also very
    rewarding!*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Quick-and-Dirty
    Option: Letting the Malware Do the Work</samp>'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When packed malware runs on the victim host, it must unpack itself somewhere
    in memory. Detonating the malware in a virtual machine, letting the malware do
    the work of unpacking itself, and then extracting the unpacked code is one of
    the simplest forms of dynamic unpacking. You can attempt this first before delving
    into the more difficult unpacking techniques in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Dumping a process from memory is fairly straightforward and can be done simply
    with Process Hacker or Process Explorer, as well as with other advanced task manager–type
    tools. In Process Hacker, you right-click the malware’s running process and select
    **Create Dump File**, as shown in [Figure 17-13](chapter17.xhtml#fig17-13) with
    the *sample.exe* process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-13: Extracting malware
    from memory using Process Hacker</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: This is a quick-and-dirty unpacking method, and it has some limitations. First,
    there’s no way of knowing if the malware completely unpacked itself in memory
    yet. For example, evasive malware may detect the VM environment and refuse to
    unpack its payload. Not only that, but since this file was extracted directly
    from memory, it also hasn’t been properly unmapped from memory and will be misaligned,
    which means that you likely won’t be able to easily analyze it in a disassembler
    like IDA Pro. You can, however, inspect the strings of the file by running the
    Strings tool (or a tool such as PEStudio), which will give you hints about what
    this malware sample may be doing. You may even spot cleartext functions, C2 addresses,
    or decrypted data. There’s a better option, however.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The tool Scylla allows you to extract this malware from memory and will automatically
    realign the file, fix the file headers, and even repair the IAT. Scylla is both
    a plug-in for x64dbg and a stand-alone tool, and it works exactly the same in
    both capacities. For example, say you have a malware sample, and after transferring
    it to your analysis VM, you detonate it. The sample may not immediately unpack
    itself into memory, so you choose to wait a minute or so to ensure the sample
    has completely unpacked itself. Next, you can run the Scylla tool, as shown in
    [Figure 17-14](chapter17.xhtml#fig17-14).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-14.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-14: Malware process
    dumping with Scylla</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Scylla allows you to select a target process in which to dump; this would normally
    be the malware’s active process (*sample.exe* in this case). You can then click
    **IAT Autosearch** to automatically search the process memory for a possible IAT.
    Once the IAT has been found, click **Get Imports** to generate a list of imports
    that will populate the IAT once the process has been dumped. Next, clicking **Dump**
    will dump the process from memory to disk into an executable file, which essentially
    unmaps the process from memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Most advanced malware won’t allow itself to be unpacked so cleanly. However,
    since this technique takes less than five minutes, it’s always worth a shot. Now
    let’s dig into some more advanced unpacking techniques.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Memory Operation Monitoring</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the unpacking stub must allocate memory for the newly unpacked executable
    and modify its memory protections, we can assume that at some point, it will invoke
    Windows functions related to memory operations. The idea here is to set breakpoints
    in the debugger on these memory operation functions, run the malware, and closely
    monitor these operations, looking for an opportunity to dump the malware’s unpacked
    code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">VirtualAlloc</samp>
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> is likely
    the most common memory allocation function you’ll see, but <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> are also used.
    You can simply attach the packed malware sample to a debugger such as x64bdg,
    set a breakpoint on the memory allocation function you’d like to target (or set
    breakpoints on all of them), and run the malware sample. Once a memory allocation
    function breakpoint is hit, you must identify the base address of the newly created
    memory region and watch this memory region for new data. Let’s see how this works
    in practice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To follow along with this example, you can find the required malware file
    on VirusTotal or MalShare at the following hash:*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: 7b8fc6e62ef39770587a056af9709cb38f052aad5d815f808346494b7a3d00c5'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Load the executable (which I’ve renamed in [Figure 17-15](chapter17.xhtml#fig17-15)
    to *badthing.exe*) into x64dbg and execute the **Run to User Code** function in
    the Debug menu, which brings you to the entry point of the malware’s code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-15.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-15: The malware’s
    entry point in x64dbg</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Next, place a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    function (<samp class="SANS_TheSansMonoCd_W5Regular_11">bp VirtualAlloc</samp>),
    as shown in [Figure 17-16](chapter17.xhtml#fig17-16). What we’re hoping for here
    is that the unpacked executable will eventually be mapped to this region of memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-16.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-16: Setting a breakpoint
    on VirtualAlloc</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Following this, continue to run the malware (by pressing F9) until this breakpoint
    is hit (see [Figure 17-17](chapter17.xhtml#fig17-17)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-17.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-17: Hitting the breakpoint
    on VirtualAlloc</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Once the breakpoint is hit, you can execute the malware until the function returns;
    select **Debug****Execute Till Return** and then check the value of the EAX register,
    which contains the target memory region that was allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    (see [Figure 17-18](chapter17.xhtml#fig17-18)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-18.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-18: A newly allocated
    memory region in EAX</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In my case, this memory region’s base address is <samp class="SANS_TheSansMonoCd_W5Regular_11">000F0000</samp>.
    Right-click on this value in EAX and select **Follow in Dump**. You should see
    an empty memory region in the Dump window (see [Figure 17-19](chapter17.xhtml#fig17-19)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-19.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-19: A fresh memory
    region in the x64dbg Dump window</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If you continue to press F9 to run the code while watching this Dump window,
    you might see something of interest, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>
    header, which could be the malware’s unpacked payload (see [Figure 17-20](chapter17.xhtml#fig17-20)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-20.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-20: Viewing the unpacked
    code in allocated memory</samp>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: You can extract this file from memory by selecting the start of the header (starting
    at the <samp class="SANS_TheSansMonoCd_W5Regular_11">M</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>)
    and the rest of this memory region in the dump view, right-clicking, and selecting
    **Binary****Save to File**. You can then inspect this file in a PE file viewer
    tool, looking for signs of successful unpacking, such as cleartext strings and
    imports.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> functions
    subsequently call the lower-level API function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>.
    Sneaky malware might invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    directly instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>.
    Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    can help in these situations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> 函数会随后调用低级 API 函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>。狡猾的恶意软件可能直接调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>，而不是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    上设置断点可以帮助解决这些情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">HeapAlloc and Malloc</samp>
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">HeapAlloc 和 Malloc</samp>
- en: 'Malware will sometimes call <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> when
    allocating memory. <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>
    differs from <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    in two ways: it allocates memory on the program’s heap rather than the stack,
    and it’s a higher-level API call and will sometimes subsequently invoke <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. Because of this,
    it’s more common to put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    but you can try setting a <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>
    breakpoint as well.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件有时会在分配内存时调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 有两个主要区别：它在程序的堆上分配内存，而不是堆栈；它是一个更高级的
    API 调用，有时会随后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>。因此，通常会在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> 上设置断点，但你也可以尝试在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> 上设置断点。
- en: The C function <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> also
    allocates memory similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>.
    In fact, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> typically
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, or in
    some cases, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>.
    It’s not as common to see malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    but it might if it’s written in C or if it’s trying to evade analysis or hide
    its activities, since <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    may get less attention from analysts. Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    can be useful in these scenarios.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的内存分配方式与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> 相似。实际上，<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    通常会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>，或者在某些情况下调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>。恶意软件调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的情况不常见，但如果它是用 C 编写的，或者试图逃避分析或隐藏其活动时，可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    可能会引起分析人员的较少关注。在这种情况下，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    上设置断点可能会很有用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Deallocation</samp>
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">内存释放</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFree</samp> (as well
    as its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFreeEx</samp>)
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapFree</samp> functions are
    used by Windows to release and free a memory region after it has been used. During
    the malware’s unpacking process, once the malware allocates memory for its unpacked
    code and executes it, it will likely need to clean up afterward. Similarly to
    setting a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, setting a
    breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFree</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFreeEx</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapFree</samp>
    can be a good tactic for catching unpacked malicious code before it has a chance
    to deallocate its memory. You may get lucky and spot an unpacked executable in
    one of these memory regions that can then be extracted for further analysis.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">VirtualProtect</samp>
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> and its
    sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp>,
    are also functions that can be monitored for unpacked code. During the unpacking
    phase, after the malware allocates memory, it must set protections on the memory.
    The memory’s protection represents what the malware is able to do with that memory
    region: write to it, read from it, execute it, or all of these. The memory protection
    option is passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    function as a parameter when the function is called, as shown in IDA Pro in [Figure
    17-21](chapter17.xhtml#fig17-21).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-21.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-21: Malware calling
    VirtualProtect, viewed in IDA Pro</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, the <samp class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp>
    parameter represents the new protection (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40</samp>,
    which is PAGE_EXECUTE_READWRITE) that will be applied to the memory region (referenced
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp>). Also important
    is the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp> parameter,
    which represents the size of the memory region that will have the new protection
    class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp> and
    watching for memory regions being marked as executable can help you catch malicious
    code that will soon be executed by the malware. Oftentimes, the malware’s unpacked
    code resides in one of these memory regions. This area of code can then be dumped
    from memory for further analysis.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](chapter17.xhtml#tab17-1) lists some of the important memory protection
    constants.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 17-1:</samp> <samp class="SANS_Futura_Std_Book_11">Memory
    Protection Constants</samp>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant (hex)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Constant
    value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE</samp>
    | <samp class="SANS_Futura_Std_Book_11">This memory region will now be execut</samp><samp
    class="SANS_Futura_Std_Book_11">able only (writes and reads will result in an
    access violation error).</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x20</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READ</samp>
    | <samp class="SANS_Futura_Std_Book_11">This memory region will now be executable
    and readable, but not writable.</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x40</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READWRITE</samp>
    | <samp class="SANS_Futura_Std_Book_11">This memory region will now be execut</samp><samp
    class="SANS_Futura_Std_Book_11">able, readable, and writable.</samp> |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: You can read about these and others in the “Memory Protection Constants” page
    in Microsoft’s documentation at [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/win32<wbr>/memory<wbr>/memory<wbr>-protection<wbr>-constants*](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp> subsequently
    call the lower-level API function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>.
    Sometimes tricky malware samples may call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    directly, bypassing the normal <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    call, thus circumventing malware analysts who may only be on the lookout for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>. In these cases,
    it can be helpful to simply put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: When using breakpoints on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>-like
    functions, it can be helpful to set hardware breakpoints on the memory region
    being modified rather than software breakpoints. As [Chapter 3](chapter3.xhtml)
    discussed, hardware breakpoints are more persistent, so evasive malware will have
    a tougher time removing them to circumvent analysis. I’ll come back to this in
    “Hardware Breakpoints on Allocated Memory” on [page 365](chapter17.xhtml#pg_365).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Inspection During Runtime</samp>
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another useful general technique for unpacking malware is inspecting memory
    regions within the debugger, looking specifically for regions that are assigned
    executable protections. Such regions can indicate the presence of executable code.
    To do this in a debugger (in my case, x64dbg), select **Memory Map** near the
    top of the debugger window. The result should look similar to [Figure 17-22](chapter17.xhtml#fig17-22).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-22.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-22: Viewing a memory
    map in x64dbg</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This memory map shows a few memory regions that are marked as executable. You
    can sort this list simply by clicking on the **Protection** column header at the
    top. Once you spot one of these memory regions, you can dump it by right-clicking
    the memory address and selecting **Dump Memory to File**, or you can view it in
    the Dump window for closer inspection by selecting **Follow in Dump**. You can
    also view this memory region in the disassembler, which is helpful if you suspect
    the data contained in a memory region is code, for example. The debugger’s disassembler
    will also help you quickly see the disassembled code. To do this, right-click
    the memory address and select **Follow in Disassembler**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key things to look for are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory regions that have E (Executable) in the Protection column**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: This would indicate that there is executable code in this region. Regions with
    protection class ERW (Execute-Read-Write) should be prioritized; in many cases,
    malware that is about to execute its unpacked payload will assign ERW protection
    to this memory. Note that in some debuggers and memory editors, this protection
    class is called RWX (Read-Write-Executable).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Regions with the PRV memory type**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can spot this in the Type column. PRV is a great candidate for finding unpacked
    code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory regions that have nothing in the Info and Content columns**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: If these fields are populated, it likely means that these memory regions are
    associated with the malware executable file itself (the packed version) and not
    its unpacked code. The memory region highlighted in [Figure 17-22](chapter17.xhtml#fig17-22)
    is a prime candidate for closer inspection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**Large data size (indicated by the Size column)**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A substantial memory region (for example, 30,000 bytes) could indicate an unpacked
    executable in memory. This is not always true, however, as smaller memory sections
    can contain small bits of malicious code such as shellcode.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Any areas of memory that contain a PE header**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: It can be helpful to run a memory string scan for <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">This program</samp>. To do this
    in x64dbg, right-click in the Memory Map area and select **Find Pattern**. Then,
    input your desired search string (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">This
    program</samp>) in the ASCII text box and click **OK**. This will search all memory
    regions for your chosen ASCII string. If you find a PE header in one of these
    regions, you should closely inspect it, as it could be the malware’s unpacked
    payload (but take into account the next point).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Addresses below the 0x7 range**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Memory addresses that start with 0x7 (x77300000, for example) are usually associated
    with legitimate Windows DLLs that are mapped into the malware’s process address
    space, so you should focus less on this memory range. I say *usually* because
    malware can load malicious code into one of these regions, but it’s not as common.
    Focus your efforts on the addresses below the 0x7 range first. For 64-bit malware,
    this would be addresses below the range of 0x700000000000.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hardware Breakpoints on Allocated
    Memory</samp>
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](chapter3.xhtml), most modern debuggers offer both
    software and hardware breakpoint options. In most cases, software breakpoints
    will suffice (for example, for setting a breakpoint on a specific CPU instruction
    or API function call). However, hardware breakpoints are also useful for following
    a malware’s unpacking process, as they can be set directly on memory regions.
    When a malware sample calls a memory allocation function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    setting a hardware breakpoint on the newly allocated memory region can help catch
    the malware executing its unpacked code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To do this in x64dbg, locate the memory region you’re interested in (for example,
    a newly allocated memory region created via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>),
    view the memory in the Dump area, right-click, and select **Breakpoint****Hardware,
    Write**. This effectively creates a persistent hardware breakpoint that will cause
    the malware program to pause when code or data is written to this memory region.
    Once code has been written to this region, you can set a <samp class="SANS_TheSansMonoCd_W5Regular_11">Hardware,
    Execute</samp> breakpoint to catch the malware executing it. Note that memory
    breakpoints can also be used here for the same purpose.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Pitfalls of Following Memory
    Operations</samp>
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Setting breakpoints on memory management functions can be an effective trick
    for following the malware unpacking process, but there are pitfalls. First, since
    these memory management functions are used often (both in legitimate and illegitimate
    circumstances), they can create a lot of noise. It’s not uncommon to see thousands
    of memory management functions executed in a malware sample, so you may find that
    setting breakpoints on them will trigger constant pauses in your debugger execution,
    giving you too much to go through. In this case, coordinating your efforts with
    process creations and code injection is best, as will be covered in the sections
    that follow. Alternatively, you can simply switch up your tactics. For example,
    focus only on one memory operation function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>, rather
    than all of the functions listed in this chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Second, breakpoints on memory can trigger unintended consequences during the
    malware’s execution, usually in the form of exceptions and program crashes. Malware
    can take advantage of this by implementing special safeguards and evasion techniques
    in its code, as discussed in [Chapter 10](chapter10.xhtml); we’ll revisit this
    briefly toward the end of this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection
    Monitoring</samp>
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After unpacking their malicious code, malware packers must write this code into
    memory. This may involve writing it into its own process address space (self-injection)
    or injecting the code into a spawned child process or other victim process on
    the host. This is a critical part of how malware unpacks itself, and it’s important
    to keep an eye out for. As mentioned previously, detonating the malware sample
    in a sandbox is always a good first step, but this is even truer when you’re attempting
    to manually unpack the malware. Many sandboxes provide a great overview of how
    the malware is executing its process injection behaviors; such guidance will help
    you decide where to set breakpoints in the running malware sample while you’re
    dynamically unpacking it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, [Figure 17-23](chapter17.xhtml#fig17-23) shows the results
    of a suspect malware sample submitted to the Hybrid Analysis sandbox.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-23.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-23: Malware sample
    behavior in the Hybrid Analysis sandbox</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We can see that this malware sample is spawning a child process *svchost.exe*,
    which appears to be executed from the path *C:\system32\svchost.exe*. This tells
    us that the malware sample may be unpacking its payload and injecting it into
    the legitimate *svchost.exe* Windows executable from the *system32* directory.
    If we wanted to unpack this malware sample manually by using a debugger, a good
    first step would be to set breakpoints on functions we predict would be invoked
    for this injection technique. For example, the malware would probably call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessInternal</samp>
    in order to execute the *svchost.exe* process. Next, it may invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write the malicious code into the target process. And finally, in order to
    execute the malicious code in the context of *svchost.exe*, the malware may call
    a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>.
    Setting breakpoints on each of these functions could help you catch the malware’s
    payload in an unpacked state and extract it from memory for further analysis.
    All of these functions were described in [Chapter 12](chapter12.xhtml), so they
    shouldn’t be completely new to you. Let’s see what injection-based unpacking looks
    like in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To follow along with this example, you can find the required malware file
    on VirusTotal or MalShare using the following hash:*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: cfb959cc29e728cd0dc6d6f45bcd893fc91cad6f465720d63c5143001e63e705'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The malware sample we’re investigating, a variant of the Ryuk ransomware family,
    is using a process injection technique that involves getting a handle to a process
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>), allocating
    memory within that process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>),
    writing its unpacked code into the victim process (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>),
    and finally executing this malicious code (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>).
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is a great
    function to investigate when you’re unpacking malware because the code is fully
    unpacked at this point and about to be executed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Load the malware sample into your debugger of choice (x64dbg, in my case) and
    set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.
    Next, run the malware to hit the breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>,
    as shown in [Figure 17-24](chapter17.xhtml#fig17-24).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-24.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-24: Malware calling
    CreateRemoteThread for process injection</samp>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> takes
    a few arguments, one of which is a handle to the process the malicious code was
    written to; this process is the one about to be executed. Since this malware sample
    is a 64-bit sample, this parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>
    function is in the RCX register (see [Figure 17-25](chapter17.xhtml#fig17-25)).
    If this were a 32-bit sample, this value would be on the stack.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-25.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-25: Investigating
    64-bit CPU registers</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In my case, this handle value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1A8</samp>.
    Cross-referencing this with the list of handles in the Handles tab of x64dbg,
    we can see that it is associated with process ID <samp class="SANS_TheSansMonoCd_W5Regular_11">2924</samp>,
    which, on my VM, is the system process *sihost.exe* (see [Figure 17-26](chapter17.xhtml#fig17-26)).
    Note that you may need to refresh the data in the handles tab by pressing F5.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-26.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-26: A list of handles
    in x64dbg</samp>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To find the injected unpacked malicious code that’s about to be executed, you
    need to locate the memory region where this code resides in the *sihost.exe* process.
    To do so, start another debugger instance and then attach to this process by selecting
    **File****Attach** and choosing **sihost.exe** from the process list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: After attaching this process, you can use the Memory Map tab to locate the suspect
    region of memory. This suspect memory region will have ERW (Execute-Read-Write)
    protection and will be a private (PRV) memory region. [Figure 17-27](chapter17.xhtml#fig17-27)
    shows a screenshot of the suspect memory region.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-27.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-27: Suspected injected
    code in the memory map</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To verify whether this memory region contains an unpacked executable, right-click
    it and select **Follow in Dump**. [Figure 17-28](chapter17.xhtml#fig17-28) shows
    that this memory region contains executable code!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-28.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-28: The unpacked
    executable in memory</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Now, to confirm that this is indeed unpacked malicious code, let’s dump this
    code to disk (in the Memory Map tab, right-click the target memory region and
    select **Dump Memory to File**) and open the file in a PE viewer such as PEStudio.
    As [Figure 17-29](chapter17.xhtml#fig17-29) shows, the Strings tab in PEStudio
    reveals some interesting things.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-29.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-29: Viewing strings
    from the unpacked code in PEStudio</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Some of the incriminating strings include commands (specifically, *cmd.exe*
    commands that attempt to delete backup files from the host) and registry keys
    that may be related to establishing persistence on the host (<samp class="SANS_TheSansMonoCd_W5Regular_11">/C
    REG...</samp> ). When we compare these strings to the original malware sample
    file, we can see drastic differences (see [Figure 17-30](chapter17.xhtml#fig17-30)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-30.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-30: Strings from
    the original, packed malware</samp>'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Can you spot the differences in [Figure 17-30](chapter17.xhtml#fig17-30)? Many
    of the strings from the unpacked code are missing. As you can see, comparing the
    strings in the unpacked file with those in the original packed malware file can
    be an effective way to confirm that the malware was successfully unpacked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Simply viewing strings has its limits, however. To further analyze the unpacked
    code, such as in a disassembler, we’d likely need to repair and realign the dumped
    code, which we’ll cover shortly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection
    Tracing with API Monitor</samp>
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tracing, which was introduced in [Chapter 3](chapter3.xhtml), is an effective
    technique not only for spying on malware’s function calls but also for unpacking
    malware. [Figure 17-31](chapter17.xhtml#fig17-31) shows a malware sample in API
    Monitor. You can see the malware sample executing a process injection technique
    and using several functions you’ve seen in this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-31.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-31: Viewing process
    injection in API Monitor</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new process (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>)
    and allocating a new memory region in this process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>),
    the malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    to write code into this new memory region (see [Figure 17-32](chapter17.xhtml#fig17-32)).
    Selecting the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    function in API Monitor and inspecting the Hex Buffer window reveals something
    interesting: an <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> header!
    This <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> header tells us that
    the malware wrote an executable to memory, and this can be copied and dumped from
    API Monitor.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-32.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-32: Viewing WriteProcessMemory
    process injection in API Monitor</samp>'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: API tracing tools like API Monitor are excellent additions to your toolbox for
    following process injection and catching malware in the unpacking process.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Library Loading and
    Address Resolution</samp>
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier you learned that the packer’s unpacking stub will likely use functions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to dynamically resolve
    the malware’s required functions. Because these functions are called before the
    malware can execute its malicious behaviors, <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> are great
    starting points for getting to the unpacked malware payload.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: When you have the packed executable file loaded in a debugger, simply place
    a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> and run
    the code by pressing F9\. Optionally, place a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    only, and you can skip all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    operations. The first breakpoint to be hit will likely be <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>,
    which is responsible for importing the respective DLL library, and then <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> will get the address
    of the specific function exports from this DLL that the malware wishes to execute.
    If you continue to run the program until all function addresses have been resolved,
    this may be the point at which the malware is unpacked in memory and ready to
    start executing its malicious payload and functionalities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can either dump the process from memory (which hopefully contains
    the unpacked executable) or try to locate the OEP.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OEP Location</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since all packers eventually transfer control flow to the malware’s OEP after
    unpacking its payload, locating this OEP is one of the best and cleanest methods
    of unpacking. By “cleanest,” I mean that dumping the unpacked malware at the OEP
    often results in an executable that most resembles the original, prepacked malware
    sample. Let’s dig into how you can find the OEP.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating the Decryption Routine</samp>
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, to better understand the unpacking procedure that the malware will go
    through once executed, it’s helpful to know how to locate decryption and decompression
    routines in the packed sample. [Chapter 16](chapter16.xhtml) described how to
    locate decryption routines in malware, and the process is mostly the same with
    packers. You can locate these routines in a debugger while debugging the packed
    sample or in a disassembler such as IDA Pro.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few key indicators of possible decryption and decompression routines.
    First, there will likely be shift-related assembly instructions that are executed
    repeatedly, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>, and so on. You might
    also see many mathematical instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mul</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>.
    Finally, there will be looping, which indicates multiple iterations of decryption
    or decompression. Here’s an example of what an unpacking routine in an unpacking
    stub may look like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this malware sample code, you may have spotted the <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions, which
    all hint that this code block is modifying data. Also notice the move instructions
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">movzx</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>),
    which indicate that the code is shifting data around. Given these indicators,
    you can assume that this block of code may be loading encrypted (packed) data
    and decrypting (unpacking) it. But to be certain, locate the tailing jump, which
    we’ll talk about now.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding the Tailing
    Jump</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The tailing jump, as mentioned earlier in the chapter, occurs at the end of
    the unpacking stub and directs the malware’s control flow to the newly unpacked
    code (more specifically, the OEP). Locating the tailing jump instruction can help
    you identify where the unpacked code will begin execution and is a good technique
    to use during the unpacking process. Since the tailing jump will be at the end
    of the unpacking procedure, it will likely come directly after the decompression
    and decryption routines you’ve just identified. Locating the tailing jump is easiest
    with a disassembler like IDA Pro. It should look something like [Figure 17-33](chapter17.xhtml#fig17-33).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-33.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-33: The packed malware’s
    tailing jump in IDA Pro</samp>'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, there are three arrows at the top of the code block, which
    means that other code blocks in the unpacking routine are jumping to this one.
    There is also a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction,
    followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> instruction.
    Both of these instructions reference dynamic locations (notice the CPU registers)
    rather than a static address, which is another good sign that one of these is
    the tailing jump. Since the malware could execute a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    instruction, though, which one is actually the tailing jump? To answer this, you’d
    probably have to throw this sample into a debugger and set breakpoints on the
    addresses of these instructions to see what happens, or spend more time statically
    analyzing the unpacking stub’s code. One of them leads to the OEP, the point at
    which the malware is unpacked and begins to execute its payload code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may have noticed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sp-analysis
    failed</samp> in the highlighted last line of the code in [Figure 17-33](chapter17.xhtml#fig17-33).
    This is IDA’s way of stating that it couldn’t disassemble the rest of this code,
    likely due to the fact that the rest of the code is dynamically resolved after
    unpacking and not available statically in the binary. This is another good indicator
    of packed code and the unpacking stub!*  ##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding
    the OEP Automatically</samp>'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: While the best method of locating the OEP is usually by first locating the tailing
    jump, there are also debugging tools and plug-ins that try to automatically locate
    the OEP in a sample. For example, OllyDbg (an older debugger that is still occasionally
    used by malware analysts and reverse engineers) has a built-in feature called
    SFX that may be useful in finding the unpacking routine and OEP. In OllyDbg, navigate
    to **Options****Debugging Options****SFX**, and you should see the options shown
    in [Figure 17-34](chapter17.xhtml#fig17-34).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-34.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-34: Debugging options
    in OllyDbg</samp>'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Select either **Trace Real Entry Blockwise** or **Trace Real Entry Bytewise**
    and then run the executable. This tool will attempt to trace the unpacking code
    and break at the OEP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Since tools for locating the OEP automatically are hit or miss, they likely
    won’t be effective on advanced malware and packers. However, they’re still options
    to keep in your toolbox and may save you some time and headaches.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Once you believe you’ve found the OEP (using any of the techniques discussed
    previously) and the sample is unpacked in memory, there are multiple ways of verifying
    that this is the true OEP and that the sample is fully unpacked. One approach
    is to inspect strings in memory. In x64dbg, simply right-click the mouse in the
    disassembler view and select **Search For****Current Module****String References**.
    An unpacked malware sample typically has human-readable strings loaded into memory
    that indicate some of its capabilities. If you see some suspect strings in memory,
    the sample (or at least parts of it) is now unpacked in memory. In this window,
    you can also use the search bar at the bottom of the screen to search for a specific
    string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: You can also search for specific strings or binary patterns in memory by right-clicking
    in the disassembler window and then selecting **Search For****Current Module****Pattern**.
    This approach is useful if you know the malware has a certain capability that
    will be unpacked in memory. For example, if you know the malware will attempt
    to contact a C2 URL (such as *http://<wbr>evil<wbr>.com<wbr>/c2<wbr>.php*), you
    can specifically search for this pattern in the debugger; if it exists, the malware
    is likely unpacked or the string has otherwise been deobfuscated. Note that this
    could also mean simply that the string has been loaded onto the stack at this
    point in runtime.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can inspect *intermodular calls*, the Windows API functions that
    the malware executes at some point, which may now be unpacked in memory. To do
    so, right-click in the disassembly view in x64dbg and select **Search For****Current
    Module****Intermodular Calls**. In an unpacked malware sample, there usually
    will be many interesting API functions listed here. Keep in mind, however, that
    some malware won’t reveal its intermodular calls and will further unpack and resolve
    the functions at a later time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacked Malware Extraction</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you believe the malware’s payload has been unpacked in memory, it’s a good
    time to dump the unpacked code. Dumping the unpacked executable from memory will
    allow you to analyze the malicious code in more detail, such as in a disassembler.
    You can do this at any point in the unpacking process, so you don’t necessarily
    need to have already located the OEP. However, finding the tailing jump and the
    subsequent control transfer to the OEP first is usually best. You also don’t have
    to extract the payload from memory in order to analyze it further; you can simply
    continue letting the malware run and analyze it in the debugger, as I’ll discuss
    later in the chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to dump the malware’s unpacked payload from memory. One
    method is to use Scylla, and the steps are roughly the same as described earlier
    in the chapter. To launch Scylla in x64dbg, simply navigate to **Plugins****Scylla**.
    Select the malware’s process, and in the OEP field, enter the OEP address if you’ve
    located it or leave this set to the default OEP. You can also click **IAT Autosearch**
    and **Get Imports** to try to automatically rebuild the IAT. Finally, click **Dump**.
    After dumping the unpacked payload, you may also need to use the PE Rebuild option
    to repair the executable file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use OllyDumpEx, which is included with some packages
    of x64dbg or can be found here: [*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/x64dbg<wbr>/wiki<wbr>/Plugins*](https://github.com/x64dbg/x64dbg/wiki/Plugins).
    OllyDumpEx allows more granularity and control but is a bit less user-friendly.
    To launch OllyDumpEx in x64dbg, navigate to **Plugins****OllyDumpEx****Dump
    Process**. OllyDumpEx allows you to select a process (module), a specific memory
    region, or a memory address to dump. Which option you use depends on how the sample
    has been unpacked and whether you’ve successfully found the OEP. If you’ve found
    the unpacked malware’s OEP, select the malware process module and click **Get
    EIP as OEP** and then **Dump**, as shown in [Figure 17-35](chapter17.xhtml#fig17-35).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-35.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-35: The OllyDumpEx
    plug-in in x64dbg</samp>'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you can use the native x64dbg interface to save the suspect memory region
    to disk. Right-click the disassembler window and select **Follow in Memory Map**.
    Next, select the region of memory that contains the unpacked code, right-click
    it, and select **Dump Memory to File**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the extracted memory will be in the form of binary data, usually
    saved as a *.bin* file. Running a strings utility (such as Strings or PE Viewer)
    on this extracted memory is always a good first step. Looking at the strings can
    provide clues about how to proceed with your analysis. If you load this file into
    a disassembler to view its code, however, you might be disappointed to find it
    needs some repairs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacked Executable
    Repair</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the unpacked payload has been dumped to disk, depending on how it was extracted,
    it may not be in a runnable state or cleanly analyzable in a disassembler. Common
    reasons for this are file misalignment, PE header corruption, or a broken IAT,
    all of which can also make static analysis of the executable problematic. Let’s
    look at how to fix these issues.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Automated Repair</samp>
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scylla will allow you to rebuild a broken executable dump file. After you dump
    the malware’s suspected unpacked payload from memory, launch Scylla (either the
    stand-alone version or the plug-in built into x64dbg), select the malware’s running
    process, enter the correct OEP (if you have identified it), and click **IAT Autosearch**
    and then **Get Imports**. You may get a message asking whether or not to use the
    advanced results. Select **No** for now. (Try the advanced results later if this
    method doesn’t work correctly.) Next, click **Fix Dump**, select your memory dump,
    and save the file. After inspecting the newly generated executable, if the PE
    headers are corrupted, you can also click **PE Rebuild** to rebuild the headers.
    There are other tools you could use to rebuild the IAT, such as Imports Fixer,
    ImpREC, and ChimpREC, but I have found Scylla to be one of the best for imports
    reconstruction. Feel free to test out these other tools if Scylla isn’t working
    in your specific situation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Another one of my go-to tools for fixing unmapped (dumped) PE executables is
    PE Unmapper ([*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/pe<wbr>_unmapper*](https://github.com/hasherezade/pe_unmapper)).
    This tool can help automate the process of unmapping an executable image from
    memory into a file and realigning the executable. Here’s an example of it in use:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To execute PE Unmapper, you point the tool (<samp class="SANS_TheSansMonoCd_W5Regular_11">pe_unmapper.exe</samp>)
    at your target memory image (<samp class="SANS_TheSansMonoCd_W5Regular_11">dumped_executable.mem</samp>,
    in this example), specify the base address of the image (where you dumped the
    image from memory; in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x13F630000</samp>),
    and then specify the output filename (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">fixed_executable.exe</samp>).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manual Realignment</samp>
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your automated tools fail, you’ll need to manually realign the headers using
    a PE editor tool such as PE-bear. In PE-bear, simply load the executable file
    and navigate to the **Section Hdrs** tab, and you should see all sections and
    their associated raw and virtual sizes. Remember, the raw size represents the
    size of the file on disk, and the virtual size represents the size once it is
    loaded into memory. Since we unmapped the file from memory, we need to get the
    file on disk to match the file that was in memory as closely as possible. [Figure
    17-36](chapter17.xhtml#fig17-36) shows what the dumped executable may look like
    prior to section realignment.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-36.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-36: Viewing the newly
    unmapped executable in PE-bear</samp>'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the raw (Raw Addr.) and virtual (Virtual Addr.) address offsets do
    not match. To fix and realign the file, first ensure each raw address matches
    its associated virtual address. This can be a simple copy-paste operation from
    the Virtual Addr. column to the Raw Addr. column. For example, if the virtual
    address of the *.text* section is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>,
    then the raw address should be <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    as well.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to recalculate the raw size to match the new raw addresses in
    order to allocate space in the file. Subtract the raw address of the first section
    (usually *.text*) from the raw address of the next listed section (usually *.rdata*).
    For example, if the raw address of the *.text* section is 1,000 bytes and the
    raw address of *.rdata* is 13,000 bytes, the raw size of the *.text* section should
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">A000</samp> (12,000 bytes in
    decimal). You’ll need to do this for each address. For the last section, you can
    try entering 0 bytes, which will usually be okay. If this doesn’t work, try changing
    it to something like 1,000 bytes. [Figure 17-37](chapter17.xhtml#fig17-37) shows
    what the file should look like afterward.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-37.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-37: Viewing the fixed
    executable in PE-bear</samp>'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To test whether the realignment was successful, navigate to the **Imports**
    tab in PE-bear and you should see the imports listed. If needed, you can use Scylla
    to attempt to rebuild the IAT and headers as described previously.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If automated and manual repairing are ineffective and the unpacked executable
    still won’t run, you may not necessarily need to repair it. You could simply continue
    to examine the malware in a debugger (since the unpacked payload was already about
    to execute when you dumped it from memory), or you could try to analyze the unpacked
    executable as it is in a disassembler or PE tool. It just may be a bit more difficult
    to navigate, and you may need to manually label Windows function calls.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">General Tips for Dynamic
    Unpacking</samp>
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes these techniques just won’t cut it. The malware could be using an
    uncommon unpacking method, or maybe it’s especially stealthy in the way it unpacks
    or injects its code. If you’re in this situation and have hit a wall, there are
    some general tips that may help you get unstuck.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Working Backward</samp>
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you are analyzing a stubborn malware sample and are unable to follow the
    unpacking process or locate the OEP, working backward can help.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: First, you identify a certain behavior that you know the malware is exhibiting
    and determine which Windows API function is likely responsible for this behavior.
    For example, if the malware attempts to contact a C2 address via HTTP, it might
    call the function <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp>
    after its payload is unpacked. Or, if the malware is creating and modifying files
    on the disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Next, set a breakpoint on the functions you’ve identified. Once the breakpoint
    is hit, walk backward in the code and try to find the unpacking routine, the memory
    region where the sample first unpacked itself, or (even better) the OEP.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hooking Windows Decryption
    and Compression Functions</samp>
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Malware packers may call native Windows API decryption-related functions during
    the unpacking process. Two of these functions are <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> is used to decrypt
    data that was previously encrypted with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    function. Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>
    may enable you to catch part of the malware’s unpacked payload (or other juicy
    data) directly after it has been decrypted and before it is executed. After the
    breakpoint has been hit, examine the buffer passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>
    function (usually the *fifth* value on the stack) after the function call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp> is
    sometimes used by malware to decompress a buffer that was previously compressed.
    As with <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>, set
    a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp>
    and examine the buffer (usually the *second* value on the stack) after the function
    call. You may get lucky and see newly unpacked code or an executable in this buffer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Packed Code</samp>
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: IDA Pro and some other disassemblers have a feature that visually represents
    the data and code in an executable file as colored boxes. You can find this visual
    at the top of the IDA interface, as shown in [Figure 17-38](chapter17.xhtml#fig17-38).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-38.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-38: A visual representation
    of a file in IDA Pro</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Although you can’t see it in a black-and-white book, this visual representation
    assigns different colors to the different types of data contained in the file.
    The Unexplored section (at the far-right of this image) is an area of the executable
    where IDA can’t determine the type of data. Sometimes these regions are encrypted
    or packed data or code, or they are areas where the malware will write data once
    it is executed. These regions are typically assigned a name (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">unk_4141C0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">dword_1000502C</samp>). If you
    select the region name and press X (a shortcut for cross-reference), you should
    see a list of the areas of code that reference that region. Exploring these code
    areas may lead you to the malware’s main unpacking routine! Alternatively, setting
    a breakpoint on a code area referencing the unexplored region may give you some
    insight into how the malware is using the region.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Helpful Tools
    for Dynamic Unpacking</samp>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Because unpacking can be very difficult at times, it is helpful to have a set
    of tools that you can rely on when the going gets tough. This section will outline
    some of my favorites.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">HollowsHunter</samp>
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: HollowsHunter ([*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/hollows<wbr>_hunter*](https://github.com/hasherezade/hollows_hunter)),
    which is built on a tool called PE-Sieve ([*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/pe<wbr>-sieve*](https://github.com/hasherezade/pe-sieve)),
    is a Windows command line tool that can detect various anomalies in running processes
    (such as injected PE files and code, hooked functions, and in-memory patches)
    and then dump the suspect regions of memory. While it’s not a tool solely for
    unpacking, it’s also great at that. [Table 17-2](chapter17.xhtml#tab17-2) lists
    some of the most useful HollowsHunter parameters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 17-2:</samp> <samp class="SANS_Futura_Std_Book_11">Helpful
    HollowsHunter Parameters</samp>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/help</samp> | <samp class="SANS_Futura_Std_Book_11">Shows
    all commands and their usage.</samp> |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/pid</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pid</samp>
    | <samp class="SANS_Futura_Std_Book_11">Specifies a target process ID to scan,
    rather than scanning all processes. Can also specify multiple target process IDs.</samp>
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/loop</samp> | <samp class="SANS_Futura_Std_Book_11">Continues
    to loop after the initial scan is completed. Good for</samp> <samp class="SANS_Futura_Std_Book_11">monitoring
    the running processes on a system in case there is a delay in malware unpacking
    or code injection.</samp> |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/data</samp> | <samp class="SANS_Futura_Std_Book_11">Scans
    nonexecutable memory regions as well as executable regions. Enable this if you
    suspect the malware may be writing code or data and setting it to a nonexecutable
    protection (R, W, RW, and so on).</samp> |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/hooks</samp> | <samp class="SANS_Futura_Std_Book_11">Scans
    for memory patches and inline hooks.</samp> |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/iat</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp>
    | <samp class="SANS_Futura_Std_Book_11">Scans for IAT hooks. Setting</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp> <samp class="SANS_Futura_Std_Book_11">to</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">will
    produce a filtered scan, leaving out the noise of system IAT hooks.</samp> |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/shellc</samp> | <samp class="SANS_Futura_Std_Book_11">Scans
    for shellcode injections. Can be a bit noisy, so use with caution.</samp> |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/imp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp>
    | <samp class="SANS_Futura_Std_Book_11">Attempts to recover the imports table
    of any dumped executables. Setting</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp>
    <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_Futura_Std_Book_11">will attempt to automatically detect the
    correct method of imports reconstruction.</samp> |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: 'To use HollowsHunter, execute the malware in your analysis environment and
    run HollowsHunter with your desired command line options, such as the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command tells HollowsHunter to continue to loop through all the running
    processes on the system (<samp class="SANS_TheSansMonoCd_W5Regular_11">/loop</samp>),
    specifically searching for hooks (<samp class="SANS_TheSansMonoCd_W5Regular_11">/hooks</samp>),
    injected shellcode (<samp class="SANS_TheSansMonoCd_W5Regular_11">/shellc</samp>),
    and IAT hooks (<samp class="SANS_TheSansMonoCd_W5Regular_11">/iat 1</samp>). Finally,
    HollowsHunter will attempt to rebuild the IAT (<samp class="SANS_TheSansMonoCd_W5Regular_11">/imp
    1</samp>) of the dumped unpacked executable files.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: After you run HollowsHunter, it will attempt to detect malicious code in memory.
    For example, in [Figure 17-39](chapter17.xhtml#fig17-39), HollowsHunter has detected
    potentially malicious code in the *RuntimeBroker.exe* and *dllhost.exe* processes.
    This code could be the result of the malware unpacking itself and subsequently
    injecting code into these processes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-39.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-39: HollowsHunter
    scanning process memory</samp>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Once it detects suspicious code, HollowsHunter dumps the suspect memory regions
    to disk and nicely organizes all the dumped memory images into a series of directories
    by process ID, as shown in [Figure 17-40](chapter17.xhtml#fig17-40).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-40.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-40: The HollowsHunter
    output</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: HollowsHunter is often one of the first unpacking techniques I try. Sometimes
    I just need to get to the unpacked malware sample quickly, without messing around
    with the unpacking process. A similar tool, Mal_Unpack ([*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/mal<wbr>_unpack*](https://github.com/hasherezade/mal_unpack)),
    is written by the same author and can also be very helpful. Like HollowsHunter,
    Mal_Unpack is based on PE-Sieve, but it uses a special optional driver that allows
    for better control of the automated unpacking process. [Figure 17-41](chapter17.xhtml#fig17-41)
    shows Mal_Unpack in action.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-41.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-41: Mal_Unpack unpacking
    a Dridex malware sample</samp>'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Mal_Unpack was able to unpack a malware sample that is part
    of the Dridex family!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Both tools can be valuable additions to your analysis arsenal. However, since
    HollowsHunter is able to scan all processes running on the host, it can often
    identify and locate code that malware has injected into other processes. For this
    reason, I often find that it suits my needs better. I recommend trying out both
    tools to determine which works best for you.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">ScyllaHide RunPE Unpacker</samp>
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ScyllaHide, which I’ve mentioned several times throughout this book, has an
    option called RunPE Unpacker that attempts to automatically extract executable
    files from memory when it detects that unpacking has occurred. The feature hooks
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp> to intercept
    certain process injection techniques and dump the unpacked malware before it can
    execute its payload.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: To use this feature, load your malware sample into x64dbg and select **Plugins****ScyllaHide****Options**.
    Check **RunPE Unpacker** and click **Apply**, as shown in [Figure 17-42](chapter17.xhtml#fig17-42).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig17-42.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-42: RunPE Unpacker
    in ScyllaHide</samp>'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: After enabling this feature, run the malware as normal. If the unpacking is
    successful, you should see a newly created executable file on your desktop; you
    won’t receive any other notification about whether or not it is successful. RunPE
    Unpacker targets a specific process injection technique and does not work in all
    cases. When it does work, however, it saves you a lot of time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Note on Emulation and Instrumentation</samp>
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Emulators and binary instrumentation frameworks, which we’ll briefly discuss
    in [Appendix A](appendix-A.xhtml) can also be useful for dynamically unpacking
    malware. These toolsets can even provide a means of completely automating the
    unpacking process. For example, Speakeasy ([*https://<wbr>github<wbr>.com<wbr>/mandiant<wbr>/speakeasy*](https://github.com/mandiant/speakeasy))
    allows you to emulate malicious code and “hook” suspect function calls. As Speakeasy
    operations can be scripted, it’s possible to automate the interception of function
    calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> in order to automate
    malware unpacking. I won’t touch on emulators or instrumentation more in this
    chapter, but know that many of the techniques you learned in this chapter can
    be applied to these toolsets.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Tools</samp>
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, you can find several scripts and plug-ins for x64dbg that can aid in
    unpacking on GitHub at [*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/Scripts*](https://github.com/x64dbg/Scripts)
    and [*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/x64dbg<wbr>/wiki<wbr>/Plugins*](https://github.com/x64dbg/x64dbg/wiki/Plugins).
    These scripts and plug-ins can automatically unpack certain packers, automatically
    locate the OEP, hide your debugger from unpackers, help bypass anti-analysis checks,
    and more.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, there are always new and innovative research projects and tools
    being released from the amazing malware research and reverse engineering community,
    so there’s no way I can capture them all here. Always be on the lookout for newly
    released tools that can aid in unpacking and in malware analysis more generally.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Manual Static Unpacking</samp>
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final method of unpacking we’ll discuss is *static unpacking*, the process
    of reverse engineering the unpacking mechanism in a packed malware sample and
    then writing code that replicates that mechanism. Once this code is run on the
    packed malware executable, the malware sample will theoretically be unpacked.
    The process of writing a static unpacker is roughly as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Locate the unpacking routine in the packed malware executable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Locate the specific instructions that are part of the deobfuscation or decryption
    process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Reverse engineer the decryption routine (this can be done with the help
    of a decompiler, such as the ones built into IDA Pro, Ghidra, or x64dbg).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Write the static unpacking code to model the unpacking routine in the executable.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Feed the packed malware sample into your static unpacker and test it out!
    Debug as necessary.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: I chose not to go into depth on this unpacking technique for two reasons. First,
    this process can be very time-consuming and tedious, and learning about other
    unpacking techniques may be a better use of your time, assuming your goal is to
    quickly unpack the malware sample so that you can better understand it. Second,
    if you were to successfully reverse engineer the unpacking technique and write
    a static unpacker, your code might only work properly on this particular sample,
    as malware packers often introduce some sort of randomness to the unpacking routine
    (a random decryption key, obfuscation technique, or something else). Static unpackers
    are not resilient to heavy modification of the packer’s code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t mean that there’s no value in manual static unpacking. Static unpackers
    are often better for at-scale analysis. For example, if you’re attempting to unpack
    tens or hundreds of samples at a time, it’s more efficient to do so statically
    than to run all those samples through a dynamic engine. Also, reversing the unpacking
    process and writing an unpacker is a great way to learn how malware packs its
    code and, more generally, a great way to learn about encryption, compression,
    and obfuscation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Analyzing Without Unpacking</samp>
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you may find yourself unable to successfully unpack a malware sample.
    Maybe you lose control of the sample while it is running, can’t determine where
    and how the malware is unpacking itself, or can’t find the OEP. When in this situation,
    ask yourself if unpacking the malware is really necessary. What are you trying
    to achieve by doing so? What questions are you trying to answer?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you don’t have to fully unpack the sample to understand its key
    behaviors or even to perform code analysis. You may be able to extract pieces
    of the unpacked malware sample from memory using the techniques described throughout
    this book. This will allow you to at least perform some analysis of the data,
    code, and extracted strings. Alternatively, you can inspect the running malware
    in a debugger, monitor its behaviors, set breakpoints on interesting function
    calls, and examine code and strings in memory. Finally, sometimes simply examining
    the malware executing in an automated sandbox is all you need to be able to understand
    the malware’s basic functionalities.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-unpacking Techniques</samp>
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until now, we’ve been discussing typical methods that malware packers use
    to decrypt and deobfuscate the malware’s payload, write it into memory, and execute
    it, sometimes in a covert manner. We’ve also talked about common methods of automatically
    and manually unpacking the malware so that it can be better analyzed and understood.
    But what if the malware packer itself fights back and attempts to evade your tools
    and analysis? Some packers, especially those designed specifically for malware,
    implement some form of VM and sandbox detection techniques and attempt to evade
    the analysis process in order to protect the malware’s original code. For this
    reason, it’s important to know and understand common anti-unpacking techniques
    used by advanced packers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Many of these techniques have already been discussed throughout this book. For
    example, malware packers often implement the sandbox and VM detection techniques
    covered in [Part II](part2.xhtml). Before unpacking the malicious code, the packers
    try to identify whether the sample is running in a VM or sandbox environment and,
    if so, whether it will avoid unpacking.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Many malware packers also take advantage of the techniques discussed in [Chapter
    10](chapter10.xhtml) to detect and obstruct debugging programs. For example, before
    unpacking and running the malicious code, the packer tries to detect if it is
    being debugged and kills itself if it is. It might also attempt to interfere with
    the manual unpacking process by using anti-debugging techniques, such as interfering
    with breakpoints or using memory guard pages. Some packers even implement the
    sandbox evasion techniques discussed in [Chapter 8](chapter8.xhtml). For example,
    they may sleep for a certain amount of time before unpacking and executing the
    malware’s payload in order to create a timeout situation in malware sandboxes
    and confuse the analysis process.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Basic anti-unpacking techniques can be as simple as modifying the original packer
    so that it’s more difficult to detect and unpack, which can be accomplished with
    any well-known or open source packer. The malware author could pack their sample
    with the UPX packer, for example, but modify it to remove the normal section name
    strings (UPX0, UPX1, and so on) or corrupt its headers. Then, when the malware
    analyst tries to identify the packer, they won’t be able to detect UPX as easily.
    Additionally, the packer’s code could be modified so that the normal UPX unpacking
    is impossible (by using the UPX tool, for example). Packers can also modify or
    destroy the unpacked executable’s headers so that when the sample is unpacked,
    it’s more difficult for automated tooling and malware analysts to locate the unpacked
    PE.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: IAT confusion is another technique employed by malware packers. After the packer
    has resolved the initial imports and functions, it may alter or completely destroy
    the IAT and then rebuild it at a later point by dynamically resolving function
    addresses. Similarly, the packer may allocate a separate area of memory, like
    a jump table, to store instructions that jump to the functions it wishes to execute
    as a way of obfuscating its IAT.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Finally, malware packers can obfuscate themselves through sheer confusion. It’s
    not uncommon for the packer to have a very convoluted control flow, with spaghetti
    code and control flow transfers (such as some of the techniques discussed in [Chapters
    9](chapter9.xhtml) and [11](chapter11.xhtml)) that make following the code and
    unpacking process difficult. The packer might also unpack the malicious code in
    multiple steps, further obfuscating the unpacking process and making it difficult
    for analysts to cleanly unpack the malware’s payload.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about some common packer types and how malware
    can leverage packers to obfuscate code, obstruct analysts and researchers from
    understanding its behaviors, and evade detection and defensive tools. You also
    saw several techniques you can use to peel back the unpacker’s layers and get
    to the source of the malware’s evil: its payload. Finally, we briefly examined
    some ways in which malware packers may try to circumvent analysis measures.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In [Appendix A](appendix-A.xhtml), we’ll look at how to build an effective anti-evasion
    analysis lab, which can be a great asset in your evasive-malware investigations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Closing Thoughts</samp>
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter marks the end of *Evasive Malware*. I hope you’ve obtained new
    skills you can start applying to your threat investigations and analysis efforts.
    But above all, I hope this book has deepened your interest in the area of evasive
    threats and given you a thirst for more knowledge.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'I encourage you to continue researching this fascinating topic. A great start
    would be to consult [Appendix C](appendix-C.xhtml), which contains some recommended
    resources and further reading. Then, test out your new skills. Take apart an interesting
    piece of malware. Experiment and uncover how it attempts to evade defenses and
    your analysis tooling. And most importantly: document your findings for others!
    We are much more powerful fighting the battle against malware and cybercrime together
    than we are individually. Thank you for reading.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
