<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="77" id="Page_77"/>6</span><br/>&#13;
<span class="ChapterTitle">Basic Math and Stats with SQL</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">If your data includes any of the number data types we explored in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>—integers, decimals, or floating points—sooner or later your analysis will include some calculations. You might want to know the average of all the dollar values in a column or add values in two columns to produce a total for each row. SQL can handle those calculations and more, from basic math through advanced statistics.</p>&#13;
<p>In this chapter, I’ll start with the basics and progress to math functions and beginning statistics. I’ll also discuss calculations related to percentages and percent change. For several of the exercises, we’ll use the 2019 US Census population estimates data you imported in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>&#13;
<h2 id="h1-501065c06-0001"><span epub:type="pagebreak" title="78" id="Page_78"/>Understanding Math Operators and Functions</h2>&#13;
<p class="BodyFirst">Let’s start with the basic math you learned in grade school (all’s forgiven if you’ve forgotten some of it). <a href="#table6-1" id="tableanchor6-1">Table 6-1</a> shows nine math operators you’ll use most often in your calculations. The first four (addition, subtraction, multiplication, and division) are part of the ANSI SQL standard and are implemented in all database systems. The others are PostgreSQL-specific operators, although most other database managers likely have functions or operators to perform those operations too. For example, the modulo operator (<code>%</code>) works in Microsoft SQL Server and MySQL as well as with PostgreSQL. If you’re using another database system, check its documentation.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Basic Math Operators</p></figcaption>&#13;
<table id="table-501065c06-0001" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Operator</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>+</code></td>&#13;
<td>Addition</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>-</code></td>&#13;
<td>Subtraction</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>*</code></td>&#13;
<td>Multiplication</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>/</code></td>&#13;
<td>Division (returns the quotient only, no remainder)</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>%</code></td>&#13;
<td>Modulo (returns just the remainder)</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>^</code></td>&#13;
<td>Exponentiation</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>|/</code></td>&#13;
<td>Square root</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>||/</code></td>&#13;
<td>Cube root</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>!</code></td>&#13;
<td>Factorial</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>We’ll step through each of these operators by executing simple SQL queries on plain numbers rather than operating on a table or another database object. You can either enter the statements separately into the pgAdmin query tool and execute them one at a time, or if you copied the code for this chapter from the resources at <a href="https://www.nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://www.nostarch.com/practical-sql-2nd-edition/</a>, you can highlight each line and execute it.</p>&#13;
<h3 id="h2-501065c06-0001">Understanding Math and Data Types</h3>&#13;
<p class="BodyFirst">As you work through the examples, note the data type of each result, which is listed beneath each column name in the pgAdmin results grid. The type returned for a calculation will vary depending on the operation and the data type of the input numbers. When using an operator between two numbers—addition, subtraction, multiplication, or division—the data type returned follows this pattern:</p>&#13;
<ul>&#13;
<li>Two integers return an <code>integer</code>.</li>&#13;
<li>A <code>numeric</code> on either side or both sides of the operator returns a <code>numeric</code>.</li>&#13;
<li>Anything with a floating-point number returns a floating-point number of type <code>double precision</code>.</li>&#13;
</ul>&#13;
<p><span epub:type="pagebreak" title="79" id="Page_79"/>However, the exponentiation, root, and factorial functions are different. Each takes just one number, either before or after the operator, and returns numeric and floating-point types, even when the input is an integer.</p>&#13;
<p>Sometimes the result’s data type will suit your needs; other times, you may need to use <code>CAST</code> to change the data type, as mentioned in “Transforming Values from One Type to Another with CAST” in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, such as if you need to feed the result into a function that takes a certain type. I’ll note those times as we work through the book.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	PostgreSQL defines the arguments that operators accept, the internal functions they call, and the data types they return in a table called <code>pg_operator</code>. For example, the <code>+</code> operator is defined once for accepting integers, again for accepting numerics, and so on.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c06-0002">Adding, Subtracting, and Multiplying</h3>&#13;
<p class="BodyFirst">Let’s start with simple integer addition, subtraction, and multiplication. <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a> shows three examples, each with the <code>SELECT</code> keyword followed by the math formula. Since <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, we’ve used <code>SELECT</code> for its main purpose: to retrieve data from a table. But with PostgreSQL, Microsoft’s SQL Server, MySQL, and some other database management systems, you can omit the table name and perform simple math and string operations, as we do here. For readability’s sake, I recommend you use a single space before and after the math operator; although using spaces isn’t strictly necessary for your code to work, it is good practice.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT 2 + 2;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SELECT 9 - 1;&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT 3 * 4;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Basic addition, subtraction, and multiplication with SQL</p>&#13;
<p>None of these statements is rocket science, so you shouldn’t be surprised that running <code>SELECT 2 + 2;</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> in the Query Tool shows a result of <code>4</code>. Similarly, the examples for subtraction <span class="CodeAnnotation" aria-label="annotation2">2</span> and multiplication <span class="CodeAnnotation" aria-label="annotation3">3</span> yield what you’d expect: <code>8</code> and <code>12</code>. The output displays in a column, as with any query result. But because we’re not querying a table and specifying a column, the results appear beneath a <code>?column?</code> name, signifying an unknown column:</p>&#13;
<pre><code>?column?&#13;
--------&#13;
       4</code></pre>&#13;
<p>That’s okay. We’re not affecting any data in a table, just displaying a result. If you want to display a column name, you can provide an alias, as in <code>SELECT 3 * 4 AS result;</code>.</p>&#13;
<h3 id="h2-501065c06-0003">Performing Division and Modulo</h3>&#13;
<p class="BodyFirst">Division with SQL gets a little trickier because of the difference between math with integers and math with decimals. Add in <em>modulo</em>, an operator <span epub:type="pagebreak" title="80" id="Page_80"/>that returns just the <em>remainder</em> in a division operation, and the results can be confusing. So, to make it clear, <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> shows four examples.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT 11 / 6;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SELECT 11 % 6;&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT 11.0 / 6;&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> SELECT CAST(11 AS numeric(3,1)) / 6;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Integer and decimal division with SQL</p>&#13;
<p>The <code>/</code> operator <span class="CodeAnnotation" aria-label="annotation1">1</span> divides the integer <code>11</code> by another integer, <code>6</code>. If you do that math in your head, you know the answer is <code>1</code> with a remainder of <code>5</code>. However, running this query yields <code>1</code>, which is how SQL handles division of one integer by another—by reporting only the integer <em>quotient</em> without any remainder. If you want to retrieve the <em>remainder</em> as an integer, you must perform the same calculation using the modulo operator <code>%</code>, as in <span class="CodeAnnotation" aria-label="annotation2">2</span>. That statement returns just the remainder, in this case <code>5</code>. No single operation today will provide you with both the quotient and the remainder as integers, though an enterprising developer could add that functionality in the future.</p>&#13;
<p>Modulo is useful for more than just fetching a remainder: you can also use it as a test condition. For example, to check whether a number is even, you can test it using the <code>% 2</code> operation. If the result is <code>0</code> with no remainder, the number is even.</p>&#13;
<p>There are two ways to divide two numbers and have the result return as a <code>numeric</code> type. First, if one or both of the numbers is a <code>numeric</code>, the result will by default be expressed as a <code>numeric</code>. That’s what happens when I divide <code>11.0</code> by <code>6</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. Execute that query, and the result is <code>1.83333</code>. The number of decimal digits displayed may vary according to your PostgreSQL and system settings.</p>&#13;
<p>Second, if you’re working with data stored only as integers and need to force decimal division, you can use <code>CAST</code> to convert one of the integers to a <code>numeric</code> type <span class="CodeAnnotation" aria-label="annotation4">4</span>. Executing this also returns <code>1.83333</code>.</p>&#13;
<h3 id="h2-501065c06-0004">Using Exponents, Roots, and Factorials</h3>&#13;
<p class="BodyFirst">Beyond the basics, PostgreSQL-flavored SQL also provides operators and functions to square, cube, or otherwise raise a base number to an exponent, as well as find roots or the factorial of a number. <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a> shows these operations in action.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT 3 ^ 4;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SELECT |/ 10;&#13;
SELECT sqrt(10);&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT ||/ 10;&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> SELECT factorial(4);&#13;
SELECT 4 !;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Exponents, roots, and factorials with SQL</p>&#13;
<p>The exponentiation operator (<code>^</code>) allows you to raise a given base number to an exponent, as in <span class="CodeAnnotation" aria-label="annotation1">1</span>, where <code>3 ^ 4</code> (colloquially, we’d call that three to the fourth power) returns <code>81</code>.</p>&#13;
<p><span epub:type="pagebreak" title="81" id="Page_81"/>You can find the square root of a number in two ways: using the <code>|/</code> operator <span class="CodeAnnotation" aria-label="annotation2">2</span> or the <code>sqrt(</code><var>n</var><code>)</code> function. For a cube root, use the <code>||/</code> operator <span class="CodeAnnotation" aria-label="annotation3">3</span>.  Both are <em>prefix operators</em>, named because they come before a single value.</p>&#13;
<p>To find the <em>factorial</em> of a number, you can use the <code>factorial(</code><var>n</var><code>)</code> function or the <code>!</code> operator. The <code>!</code>, available only in PostgreSQL versions 13 and earlier, is a <em>suffix operator</em>, coming after a single value. You’ll use factorials in many places in math, but perhaps the most common is to determine how many ways a number of items can be ordered. Say you have four photographs. How many ways could you order them on a wall? To find the answer, you’d calculate the factorial by starting with the number of items and multiplying it by all the smaller positive integers. So, at <span class="CodeAnnotation" aria-label="annotation4">4</span>, the function <code>factorial(4)</code> is equivalent to 4 × 3 × 2 × 1. That’s 24 ways to order four photos. No wonder decorating takes so long sometimes!</p>&#13;
<p>Again, these operators are specific to PostgreSQL; they’re not part of the SQL standard. If you’re using another database application, check its documentation for how it implements these operations.</p>&#13;
<h3 id="h2-501065c06-0005">Minding the Order of Operations</h3>&#13;
<p class="BodyFirst">You may recall from early math lessons what the order of operations, or <em>operator precedence</em>, is on a mathematical expression. Which calculations does SQL execute first? Not surprisingly, SQL follows the established math standard. For the PostgreSQL operators discussed so far, the order is as follows:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Exponents and roots</li>&#13;
<li value="2">Multiplication, division, modulo</li>&#13;
<li value="3">Addition and subtraction</li>&#13;
</ol>&#13;
<p>Given these rules, you’ll need to encase an operation in parentheses if you want to calculate it in a different order. For example, the following two expressions yield different results:</p>&#13;
<pre><code>SELECT 7 + 8 * 9;&#13;
SELECT (7 + 8) * 9;</code></pre>&#13;
<p>The first expression returns <code>79</code> because the multiplication operation receives precedence and is processed before the addition. The second returns <code>135</code> because the parentheses force the addition operation to occur first.</p>&#13;
<p>Here’s a second example using exponents:</p>&#13;
<pre><code>SELECT 3 ^ 3 - 1;&#13;
SELECT 3 ^ (3 - 1);</code></pre>&#13;
<p>Exponent operations take precedence over subtraction, so without parentheses the entire expression is evaluated left to right and the operation to find 3 to the power of 3 happens first. Then 1 is subtracted, returning <code>26</code>. In the second example, the parentheses force the subtraction to happen first, so the operation results in <code>9</code>, which is 3 to the power of 2.</p>&#13;
<p><span epub:type="pagebreak" title="82" id="Page_82"/>Keep operator precedence in mind to avoid having to correct your analysis later!</p>&#13;
<h2 id="h1-501065c06-0002">Doing Math Across Census Table Columns</h2>&#13;
<p class="BodyFirst">Let’s try to use the most frequently used SQL math operators on real data by digging into the 2019 US Census population estimates table, <code>us_counties_pop_est_2019</code>, that you imported in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>. Instead of using numbers in queries, we’ll use the names of the columns that contain the numbers. When we execute the query, the calculation will occur on each row of the table.</p>&#13;
<p>To refresh your memory about the data, run the script in <a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a>. It should return 3,142 rows showing the name and state of each county in the United States plus the 2019 components of population change: births, deaths, and international and domestic migration.</p>&#13;
<pre><code>SELECT county_name AS<span class="CodeAnnotation" aria-label="annotation1">1</span> county,&#13;
       state_name AS state,&#13;
       pop_est_2019 AS pop,&#13;
       births_2019 AS births,&#13;
       deaths_2019 AS deaths,&#13;
       international_migr_2019 AS int_migr,&#13;
       domestic_migr_2019 AS dom_migr,&#13;
       residual_2019 AS residual&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Selecting census population estimate columns with aliases</p>&#13;
<p>This query doesn’t return all columns in the table, just the ones with data related to the population estimates. In addition, I employ the <code>AS</code> keyword <span class="CodeAnnotation" aria-label="annotation1">1</span> to give each column a shorter <em>alias</em> in the result set. Because all the data in this query is from 2019, I’m eliminating the year from the names of the results columns to reduce scrolling in the pgAdmin output. It’s an arbitrary decision that you can adjust.</p>&#13;
<h3 id="h2-501065c06-0006">Adding and Subtracting Columns</h3>&#13;
<p class="BodyFirst">Now, let’s try a simple calculation using two of the columns. <a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a> subtracts the number of deaths from the number of births in each county, a measure the census refers to as natural increase. Let’s see what this shows. </p>&#13;
<pre><code>SELECT county_name AS county,&#13;
       state_name AS state,&#13;
       births_2019 AS births,&#13;
       deaths_2019 AS deaths,&#13;
       <span class="CodeAnnotationHang" aria-label="annotation1">1</span> births_2019 - deaths_2019 AS natural_increase&#13;
FROM us_counties_pop_est_2019&#13;
ORDER BY state_name, county_name;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Subtracting two columns in <em>us_counties_pop_est_2019</em></p>&#13;
<p><span epub:type="pagebreak" title="83" id="Page_83"/>Providing <code>births_2019 - deaths_2019</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> as one of the columns in the <code>SELECT</code> statement handles the calculation. Again, I use the <code>AS</code> keyword to provide a readable alias for the column. If you don’t provide an alias, PostgreSQL uses the label <code>?column?</code>, which is far less than helpful.</p>&#13;
<p>Run the query to see the results. The first few rows should resemble this output:</p>&#13;
<pre><code>county           state     births    deaths   natural_increase&#13;
--------------   -------   ------    ------   ----------------&#13;
Autauga County   Alabama     624       541                 83&#13;
Baldwin County   Alabama    2304      2326                -22&#13;
Barbour County   Alabama     256       312                -56&#13;
Bibb County      Alabama     240       252                -12</code></pre>&#13;
<p>A quick check with a calculator or pencil and paper confirms that the <code>natural_increase</code> column equals the difference between the two columns you subtracted. Excellent! Notice as you scroll through the output that some counties have more births than deaths, while others have the opposite. Typically, counties with a younger mix of residents see births outpace deaths; those with an older set of people—think rural areas and retirement hotspots—tend to see a greater number of deaths than births.</p>&#13;
<p>Now, let’s build on this to test our data and validate that we imported columns correctly. The population estimate for 2019 should equal the sum of the 2018 estimate and the columns about births, deaths, migration, and residual factor. The code in <a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a> should show that it does.</p>&#13;
<pre><code>SELECT county_name AS county,&#13;
       state_name AS state,&#13;
       <span class="CodeAnnotationHang" aria-label="annotation1">1</span> pop_est_2019 AS pop,&#13;
       <span class="CodeAnnotationHang" aria-label="annotation2">2</span> pop_est_2018 + births_2019 - deaths_2019 +&#13;
           international_migr_2019 + domestic_migr_2019 +&#13;
           residual_2019 AS components_total,&#13;
       <span class="CodeAnnotationHang" aria-label="annotation3">3</span> pop_est_2019 - (pop_est_2018 + births_2019 - deaths_2019 +&#13;
           international_migr_2019 + domestic_migr_2019 +&#13;
           residual_2019) AS difference&#13;
FROM us_counties_pop_est_2019&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> ORDER BY difference DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Checking census data totals</p>&#13;
<p>This query includes the 2019 population estimate <span class="CodeAnnotation" aria-label="annotation1">1</span>, followed by a calculation adding the components to the 2018 population estimate as <code>component_total</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The 2018 estimate plus the components should equal the 2019 estimate. Rather than manually check, we also add a column that subtracts the components total from the 2019 estimate <span class="CodeAnnotation" aria-label="annotation3">3</span>. That column, named <code>difference</code>, should contain a zero in each row if all the data is in the right place. To avoid having to scan all 3,142 rows, we add an <code>ORDER BY</code> clause <span class="CodeAnnotation" aria-label="annotation4">4</span> on the named column. Any rows showing a difference should appear at the top or bottom of the query result.</p>&#13;
<p><span epub:type="pagebreak" title="84" id="Page_84"/>Run the query; the first few rows should provide this result:</p>&#13;
<pre><code>    county       state    pop    components_total  difference&#13;
--------------  -------  ------  ----------------  ----------&#13;
Autauga County  Alabama   55869             55869           0&#13;
Baldwin County  Alabama  223234            223234           0&#13;
Barbour County  Alabama   24686             24686           0</code></pre>&#13;
<p>With the <code>difference</code> column showing zeros, we can be confident that our import was clean. Whenever I encounter or import a new dataset, I like to perform little tests like this. They help me better understand the data and head off any potential issues before I dig into analysis.</p>&#13;
<h3 id="h2-501065c06-0007">Finding Percentages of the Whole</h3>&#13;
<p class="BodyFirst">One way to spot differences in the items in a dataset is to calculate the percentage of the whole that a particular data point represents. Then, you can glean meaningful insights—and sometimes surprises—by comparing that percentage across all the items in your dataset.</p>&#13;
<p>To figure out the percentage of the whole, divide the number in question by the total. For example, if you had a basket of 12 apples and used 9 in a pie, that would be 9 / 12 or 0.75—commonly expressed as 75 percent.</p>&#13;
<p>We’ll try this on the census population estimates using the two columns that represent the size of each county’s geographical features. The columns <code>area_land</code> and <code>area_water</code> show a county’s land and water measurement in square meters. Using the code in <a href="#listing6-7" id="listinganchor6-7">Listing 6-7</a>, we can calculate for each county the percentage of its area that is made up of water. </p>&#13;
<pre><code>SELECT county_name AS county,&#13;
       state_name AS state,&#13;
       <span class="CodeAnnotationHang" aria-label="annotation1">1</span> area_water::numeric / (area_land + area_water) * 100 AS pct_water&#13;
FROM us_counties_pop_est_2019&#13;
ORDER BY pct_water DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: Calculating the percent of a county’s area that is water</p>&#13;
<p>The key piece of this query divides <code>area_water</code> by the sum of <code>area_land</code> and <code>area_water</code>, which together represent the total area of the county <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>&#13;
<p>If we use the data as their original integer types, we won’t get the fractional result we need: every row will display a result of 0, the quotient. Instead, we force decimal division by casting one of the integers to the numeric type. Here, for brevity, we use the PostgreSQL-specific double-colon notation after the first reference to <code>area_water</code>, but you can also use the ANSI SQL standard <code>CAST</code> function covered in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>. Finally, we multiply the result by 100 to present the result as a fraction of 100—the way most people understand percentages.</p>&#13;
<p><span epub:type="pagebreak" title="85" id="Page_85"/>By sorting from highest to lowest percentage, the top of the output is as follows:</p>&#13;
<pre><code>      county           state            pct_water&#13;
------------------  -------------  -----------------------&#13;
Keweenaw County     Michigan       90.94723747453215452900&#13;
Leelanau County     Michigan       86.28858968116583102500&#13;
Nantucket County    Massachusetts  84.79692499185512352300&#13;
St. Bernard Parish  Louisiana      82.48371149202893908400&#13;
Alger County        Michigan       81.87221940647501072300</code></pre>&#13;
<p>If you check the Wikipedia entry for Keweenaw County, you’ll discover the reason why its total area is more than 90 percent water: its land area includes an island in Lake Superior, and the lake’s waters are included in the total reported by the census. Add that to your trivia collection!</p>&#13;
<h3 id="h2-501065c06-0008">Tracking Percent Change</h3>&#13;
<p class="BodyFirst">Another key indicator in data analysis is percent change: how much bigger, or smaller, is one number than another? Percent change calculations are often employed when analyzing change over time, and they’re particularly useful for comparing change among similar items.</p>&#13;
<p>Some examples include the following:</p>&#13;
<ul class="bullet">&#13;
<li>The year-over-year change in the number of vehicles sold by each automobile maker</li>&#13;
<li>The monthly change in subscriptions to each email list owned by a marketing firm</li>&#13;
<li>The annual increase or decrease in enrollment at schools across a nation</li>&#13;
</ul>&#13;
<p>The formula to calculate percent change can be expressed like this: </p>&#13;
<p class="Equation">(<em>new number</em> – <em>old number</em>) / <em>old number</em></p>&#13;
<p>So, if you own a lemonade stand and sold 73 glasses of lemonade today and 59 glasses yesterday, you’d figure the day-to-day percent change like this:</p>&#13;
<p class="Equation">(73 – 59) / 59 = .237 = 23.7%</p>&#13;
<p>Let’s try this with a small collection of test data related to spending in departments of a hypothetical local government. <a href="#listing6-8" id="listinganchor6-8">Listing 6-8</a> calculates which departments had the greatest percentage increase and decrease.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE TABLE percent_change (&#13;
    department text,&#13;
    spend_2019 numeric(10,2),&#13;
    spend_2022 numeric(10,2)&#13;
);&#13;
&#13;
<span epub:type="pagebreak" title="86" id="Page_86"/><span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO percent_change&#13;
VALUES&#13;
    ('Assessor', 178556, 179500),&#13;
    ('Building', 250000, 289000),&#13;
    ('Clerk', 451980, 650000),&#13;
    ('Library', 87777, 90001),&#13;
    ('Parks', 250000, 223000),&#13;
    ('Water', 199000, 195000);&#13;
&#13;
SELECT department,&#13;
       spend_2019,&#13;
       spend_2022,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation3">3</span> round( (spend_2022 - spend_2019) /&#13;
                    spend_2019 * 100, 1) AS pct_change&#13;
FROM percent_change;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: Calculating percent change</p>&#13;
<p>We create a small table called <code>percent_change</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and insert six rows <span class="CodeAnnotation" aria-label="annotation2">2</span> with data on department spending for the years 2019 and 2022. The percent change formula <span class="CodeAnnotation" aria-label="annotation3">3</span> subtracts <code>spend_2019</code> from <code>spend_2022</code> and then divides by <code>spend_2019</code>. We multiply by 100 to express the result as a portion of 100.</p>&#13;
<p>To simplify the output, this time I’ve added the <code>round()</code> function to remove all but one decimal place. The function takes two arguments: the column or expression to be rounded and the number of decimal places to display. Because both numbers are type <code>numeric</code>, the result will also be a <code>numeric</code>.</p>&#13;
<p>The script creates this result:</p>&#13;
<pre><code>department  spend_2019  spend_2022  pct_change&#13;
----------  ----------  ----------  ----------&#13;
Assessor     178556.00   179500.00         0.5&#13;
Building     250000.00   289000.00        15.6&#13;
Clerk        451980.00   650000.00        43.8&#13;
Library       87777.00    90001.00         2.5&#13;
Parks        250000.00   223000.00       -10.8&#13;
Water        199000.00   195000.00        -2.0</code></pre>&#13;
<p>Now, it’s just a matter of finding out why the Clerk department’s spending has outpaced others in the town.</p>&#13;
<h2 id="h1-501065c06-0003">Using Aggregate Functions for Averages and Sums</h2>&#13;
<p class="BodyFirst">So far, we’ve performed math operations across columns in each row of a table. SQL also lets you calculate a result from values within the same column using <em>aggregate functions</em>. You can see a full list of PostgreSQL aggregates, which calculate a single result from multiple inputs, at <a href="https://www.postgresql.org/docs/current/functions-aggregate.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-aggregate.html</a>. Two of the most-used aggregate functions in data analysis are <code>avg()</code> and <code>sum()</code>.</p>&#13;
<p>Returning to the <code>us_counties_pop_est_2019</code> census table, it’s reasonable to want to calculate the total population of all counties plus the average <span epub:type="pagebreak" title="87" id="Page_87"/>population of all counties. Using <code>avg()</code> and <code>sum()</code> on column <code>pop_est_2019</code> (the population estimate for 2019) makes it easy, as shown in <a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a>. Again, we use the <code>round()</code> function to remove numbers after the decimal point in the average calculation.</p>&#13;
<pre><code>SELECT sum(pop_est_2019) AS county_sum,&#13;
       round(avg(pop_est_2019), 0) AS county_average&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: Using the <code>sum()</code> and <code>avg()</code> aggregate functions</p>&#13;
<p>This calculation produces the following result:</p>&#13;
<pre><code>county_sum  county_average&#13;
----------  --------------&#13;
 328239523          104468</code></pre>&#13;
<p>The estimated population for all counties in the United States in 2019 added up to approximately 328.2 million, and the average of the county population estimates was 104,468.</p>&#13;
<h2 id="h1-501065c06-0004">Finding the Median</h2>&#13;
<p class="BodyFirst">The <em>median</em> value in a set of numbers is as important an indicator, if not more so, than the average. Here’s the difference between median and average:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">Average</span>  The sum of all the values divided by the number of values</li>&#13;
<li><span class="RunInHead">Median</span>  The “middle” value in an ordered set of values</li>&#13;
</ol>&#13;
<p>Median is important in data analysis because it reduces the effect of outliers. Consider this example: let’s say six kids, ages 10, 11, 10, 9, 13, and 12, go on a field trip. It’s easy to add the ages and divide by six to get the group’s average age:</p>&#13;
<p class="Equation">(10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8</p>&#13;
<p>Because the ages fall within a narrow range, the 10.8 average is a good representation of the group. But averages are less helpful when the values are bunched, or skewed, toward one end of the distribution, or if the group includes outliers.</p>&#13;
<p>For example, say an older chaperone joins the field trip. With ages of 10, 11, 10, 9, 13, 12, and 46, the average age increases considerably:</p>&#13;
<p class="Equation">(10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9</p>&#13;
<p>Now the average doesn’t represent the group well because the outlier skews it, making it an unreliable indicator.</p>&#13;
<p>It’s better in this case to find the median, the midpoint in an ordered list of values—the point at which half the values are more and half are <span epub:type="pagebreak" title="88" id="Page_88"/>less. Using the field trip, we order the attendees’ ages from lowest to highest:</p>&#13;
<p class="Equation">9, 10, 10, 11, 12, 13, 46</p>&#13;
<p>The middle (median) value is 11. Given this group, the median of 11 is a better picture of the typical age than the average of 15.9.</p>&#13;
<p>If the set of values is an even number, you take the average of the two middle numbers to find the median. Let’s add another student (age 12) to the field trip:</p>&#13;
<p class="Equation">9, 10, 10, 11, 12, 12, 13, 46</p>&#13;
<p>Now, the two middle values are 11 and 12. To find the median, we average them: 11.5.</p>&#13;
<p>Medians are reported frequently in financial news. Reports on housing prices often use medians because a few sales of McMansions in a ZIP code that is otherwise modest can make averages useless. The same goes for sports player salaries: one or two superstars can skew a team’s average.</p>&#13;
<p>A good test is to calculate the average and the median for a group of values. If they’re close, the group is probably normally distributed (the familiar bell curve), and the average is useful. If they’re far apart, the values are not normally distributed, and the median is the better representation.</p>&#13;
<h3 id="h2-501065c06-0009">Finding the Median with Percentile Functions</h3>&#13;
<p class="BodyFirst">PostgreSQL (as with most relational databases) does not have a built-in <code>median()</code> function like you’d find in Excel or other spreadsheet programs. It’s also not included in the ANSI SQL standard. Instead we can use a SQL <em>percentile</em> function to find the median and use <em>quantiles</em> or <em>cut points</em> to divide a group of numbers into equal sizes. Percentile functions are part of standard ANSI SQL.</p>&#13;
<p>In statistics, percentiles indicate the point in an ordered set of data below which a certain percentage of the data is found. For example, a doctor might tell you that your height places you in the 60th percentile for an adult in your age group. That means 60 percent of people are shorter than you.</p>&#13;
<p>The median is equivalent to the 50th percentile—again, half the values are below and half above. There are two versions of the percentile function—<code>percentile_cont(</code><var>n</var><code>)</code> and <code>percentile_disc(</code><var>n</var><code>)</code>. Both functions are part of the ANSI SQL standard and are present in PostgreSQL, Microsoft SQL Server, and other databases.</p>&#13;
<p>The <code>percentile_cont(</code><var>n</var><code>)</code> function calculates percentiles as <em>continuous</em> values. That is, the result does not have to be one of the numbers in the dataset but can be a decimal value in between two of the numbers. This follows the methodology for calculating medians on an even number of values, where the median is the average of the two middle numbers. The <code>percentile_disc(</code><var>n</var><code>)</code> function returns only <em>discrete</em> values, meaning the result will be rounded to one of the numbers in the set.</p>&#13;
<p>In <a href="#listing6-10" id="listinganchor6-10">Listing 6-10</a> we make a test table with six numbers and find the percentiles.</p>&#13;
<pre><code><span epub:type="pagebreak" title="89" id="Page_89"/>CREATE TABLE percentile_test (&#13;
    numbers integer&#13;
);&#13;
&#13;
INSERT INTO percentile_test (numbers) VALUES&#13;
    (1), (2), (3), (4), (5), (6);&#13;
&#13;
SELECT&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> percentile_cont(.5)&#13;
    WITHIN GROUP (ORDER BY numbers),&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> percentile_disc(.5)&#13;
    WITHIN GROUP (ORDER BY numbers)&#13;
FROM percentile_test;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: Testing SQL percentile functions</p>&#13;
<p>In both the continuous <span class="CodeAnnotation" aria-label="annotation1">1</span> and discrete <span class="CodeAnnotation" aria-label="annotation2">2</span> percentile functions, we enter <code>.5</code> to represent the 50th percentile, equivalent to the median. Running the code returns the following:</p>&#13;
<pre><code>percentile_cont     percentile_disc&#13;
---------------     ---------------&#13;
            3.5                   3</code></pre>&#13;
<p>The <code>percentile_cont()</code> function returned what we’d expect the median to be: <code>3.5</code>. But because <code>percentile_disc()</code> calculates discrete values, it reports <code>3</code>, the last value in the first 50 percent of the numbers. Because the accepted method of calculating medians is to average the two middle values in an even-numbered set, use <code>percentile_cont(.5)</code> to find a median.</p>&#13;
<h3 id="h2-501065c06-0010">Finding Median and Percentiles with Census Data</h3>&#13;
<p class="BodyFirst">Our census data can show how a median tells a different story than an average. <a href="#listing6-11" id="listinganchor6-11">Listing 6-11</a> adds <code>percentile_cont()</code> alongside the <code>sum()</code> and <code>avg()</code> aggregates we’ve used so far to find the sum, average, and median population of all counties.</p>&#13;
<pre><code>SELECT sum(pop_est_2019) AS county_sum,&#13;
       round(avg(pop_est_2019), 0) AS county_average,&#13;
       percentile_cont(.5)&#13;
       WITHIN GROUP (ORDER BY pop_est_2019) AS county_median&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-11">Listing 6-11</a>: Using <code>sum()</code>, <code>avg()</code>, and <code>percentile_cont()</code> aggregate functions</p>&#13;
<p>Your result should equal the following:</p>&#13;
<pre><code>county_sum  county_avg  county_median&#13;
----------  ----------  -------------&#13;
 328239523      104468          25726</code></pre>&#13;
<p><span epub:type="pagebreak" title="90" id="Page_90"/>The median and average are far apart, which shows that averages can mislead. As of 2019 estimates, half the counties in America had fewer than 25,726 people, whereas half had more. If you gave a presentation on US demographics and told the audience that the “average county in America has 104,468 people,” they’d walk away with a skewed picture of reality. More than 40 counties were estimated to have a million or more people in 2019, and Los Angeles County had more than 10 million. That pushed the average higher.</p>&#13;
<h3 id="h2-501065c06-0011">Finding Other Quantiles with Percentile Functions</h3>&#13;
<p class="BodyFirst">You can also slice data into smaller equal groups for analysis. Most common are <em>quartiles</em> (four equal groups), <em>quintiles</em> (five groups), and <em>deciles</em> (10 groups). To find any individual value, you can just plug it into a percentile function. To find the value marking the first quartile or the lowest 25 percent of data, you’d use a value of <code>.25</code>:</p>&#13;
<pre><code>percentile_cont(.25)</code></pre>&#13;
<p>However, entering values one at a time is laborious if you want to generate multiple cut points. Instead, you can pass values into <code>percentile_cont()</code> using an <em>array</em>, a list of items.</p>&#13;
<p><a href="#listing6-12" id="listinganchor6-12">Listing 6-12</a> shows how to calculate all four quartiles at once.</p>&#13;
<pre><code>SELECT percentile_cont(<span class="CodeAnnotation" aria-label="annotation1">1</span>ARRAY[.25,.5,.75])&#13;
       WITHIN GROUP (ORDER BY pop_est_2019) AS quartiles&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-12">Listing 6-12</a>: Passing an array of values to <code>percentile_cont()</code></p>&#13;
<p>In this example, we create our cut points by enclosing values in an <em>array constructor</em> <span class="CodeAnnotation" aria-label="annotation1">1</span> called <code>ARRAY[]</code>. An array constructor is an expression that builds an array from the elements included between the square brackets. Inside the brackets, we provide comma-separated values representing the three points at which to cut to create four quartiles. Run the query, and you should see this output:</p>&#13;
<pre><code>quartiles&#13;
------------------------&#13;
{10902.5,25726,68072.75}</code></pre>&#13;
<p>Because we passed in an array, PostgreSQL returns an array, denoted in the results by curly brackets. Each quartile is separated by commas. The first quartile is 10,902.5, which means 25 percent of counties have a population that is equal to or lower than this value. The second quartile is the same as the median: 25,726. The third quartile is 68,072.75, meaning the largest 25 percent of counties have at least this large of a population. (When reporting these, we’d of course round up or down, as we don’t deal in fractions when talking about people.)</p>&#13;
<p><span epub:type="pagebreak" title="91" id="Page_91"/>Arrays are defined in the ANSI SQL standard, and our use here is just one of several ways you work with arrays in PostgreSQL. You can, for example, define a table column as an array of a particular data type. That’s useful if you want store multiple values in a single database column, such as a collection of tags for a blog post, instead of storing them in a separate table. See the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/arrays.html" class="LinkURL">https://www.postgresql.org/docs/current/arrays.html</a> for examples of declaring, searching, and modifying arrays.</p>&#13;
<p>Arrays also come with a host of functions (noted for PostgreSQL at <a href="https://www.postgresql.org/docs/current/functions-array.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-array.html</a>) that allow you to perform tasks such as adding or removing values or counting the elements. A handy function for working with the result returned in <a href="#listing6-12">Listing 6-12</a> is <code>unnest()</code>, which makes the array easier to read by turning it into rows. <a href="#listing6-13" id="listinganchor6-13">Listing 6-13</a> shows the code.</p>&#13;
<pre><code>SELECT unnest(&#13;
            percentile_cont(ARRAY[.25,.5,.75])&#13;
            WITHIN GROUP (ORDER BY pop_est_2019)&#13;
            ) AS quartiles&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-13">Listing 6-13</a>: Using <code>unnest()</code> to turn an array into rows</p>&#13;
<p>Now the output should be in rows:</p>&#13;
<pre><code>quartiles&#13;
---------&#13;
  10902.5&#13;
    25726&#13;
 68072.75</code></pre>&#13;
<p>If we were computing deciles, pulling them from the resulting array and displaying them in rows would be especially helpful.</p>&#13;
<h2 id="h1-501065c06-0005">Finding the Mode</h2>&#13;
<p class="BodyFirst">We can find the <em>mode</em>, the value that appears most often, using the PostgreSQL <code>mode()</code> function. The function is not part of standard SQL and has a syntax similar to the percentile functions. <a href="#listing6-14" id="listinganchor6-14">Listing 6-14</a> shows a <code>mode()</code> calculation on <code>births_2019</code>, the column showing the number of babies born.</p>&#13;
<pre><code>SELECT mode() WITHIN GROUP (ORDER BY births_2019)&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing6-14">Listing 6-14</a>: Finding the most frequent value with <code>mode()</code></p>&#13;
<p>The result is <code>86</code>, a number of births shared by 16 counties.</p>&#13;
<h2 id="h1-501065c06-0006"><span epub:type="pagebreak" title="92" id="Page_92"/>Wrapping Up</h2>&#13;
<p class="BodyFirst">Working with numbers is a key step in acquiring meaning from your data, and with the math skills covered in this chapter, you’re ready to handle the foundations of numerical analysis with SQL. Later in the book, you’ll learn about deeper statistical concepts including regression and correlation, but at this point you’ve mastered the basics of sums, averages, and percentiles. You’ve also learned how a median can be a fairer assessment of a group of values than an average. That alone can help you avoid inaccurate conclusions.</p>&#13;
<p>In the next chapter, I’ll introduce you to the power of joining data in two or more tables to increase your options for data analysis. We’ll use the 2019 US Census data you’ve already loaded into the <code>analysis</code> database and explore additional datasets.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>try it yourself</h2>&#13;
<p class="BoxBodyFirst">Here are three exercises to test your SQL math skills:</p>&#13;
<ol>&#13;
<li value="1">Write a SQL statement for calculating the area of a circle whose radius is 5 inches. (If you don’t remember the formula, it’s an easy web search.) Do you need parentheses in your calculation? Why or why not?</li>&#13;
<li value="2">Using the 2019 US Census county estimates data, calculate a ratio of births to deaths for each county in New York state. Which region of the state generally saw a higher ratio of births to deaths in 2019?</li>&#13;
<li value="3">Was the 2019 median county population estimate higher in California or New York?</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>