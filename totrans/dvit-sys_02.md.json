["```\n/* An example C program with local and global variables */\n\n#include <stdio.h>\n\nint max(int n1, int n2); /* function prototypes */\n\nint change(int amt);\n\nint g_x;  /* global variable: declared outside function bodies */\n\nint main() {\n\n    int x, result;   /* local variables: declared inside function bodies */\n\n    printf(\"Enter a value: \");\n\n    scanf(\"%d\", &x);\n\n    g_x = 10;       /* global variables can be accessed in any function */\n\n    result = max(g_x, x);\n\n    printf(\"%d is the largest of %d and %d\\n\", result, g_x, x);\n\n    result = change(10);\n\n    printf(\"g_x's value was %d and now is %d\\n\", result, g_x);\n\n    return 0;\n\n}\n\nint max(int n1, int n2) {  /* function with two parameters */\n\n    int val;    /* local variable */\n\n    val = n1;\n\n    if ( n2 > n1 ) {\n\n        val = n2;\n\n    }\n\n    return val;\n\n}\n\nint change(int amt) {\n\n    int val;\n\n    val = g_x;  /* global variables can be accessed in any function */\n\n    g_x += amt;\n\n return val;\n\n}\n```", "```\nint *ptr;   // stores the memory address of an int (ptr \"points to\" an int)\n\nchar *cptr; // stores the memory address of a char (cptr \"points to\" a char)\n```", "```\nint x;\n\nchar ch;\n\nptr = &x;    // ptr gets the address of x, pointer \"points to\" x\n\ncptr = &ch;  // cptr gets the address of ch, pointer \"points to\" ch\n```", "```\ncptr = &x;   // ERROR: cptr can hold a char memory location\n\n             // (&x is the address of an int)\n```", "```\nptr = NULL;\n\ncptr = NULL;\n```", "```\n/* Assuming an integer named x has already been declared, this code sets the\n\n   value of x to 8\\. */\n\nptr = &x;   /* initialize ptr to the address of x (ptr points to variable x) */\n\n*ptr = 8;   /* the memory location ptr points to is assigned 8 */\n```", "```\nint *ptr1, *ptr2, x, y;\n\nx = 8;\n\nptr2 = &x;     // ptr2 is assigned the address of x\n\nptr1 = NULL;\n```", "```\n*ptr2 = 10;     // the memory location ptr2 points to is assigned 10\n\ny = *ptr2 + 3;  // y is assigned what ptr2 points to plus 3\n```", "```\nptr1 = ptr2;   // ptr1 gets the address value stored in ptr2 (both point to x)\n```", "```\n*ptr1 = 100;\n```", "```\nptr1 = &y;     // change ptr1's value (change what it points to)\n\n*ptr1 = 80;\n```", "```\nptr = 20;       // ERROR?:  this assigns ptr to point to address 20\n\nptr = &x;\n\n*ptr = 20;      // CORRECT: this assigns 20 to the memory pointed to by ptr\n```", "```\nptr = NULL;\n\n*ptr = 6;    // CRASH! program crashes with a segfault (a memory fault)\n\nptr = 20;\n\n*ptr = 6;    // CRASH! segfault (20 is not a valid address)\n\nptr = x;\n\n*ptr = 6;    // likely CRASH or may set some memory location with 6\n\n             // (depends on the value of x which is used as an address value)\n\nptr = &x;    // This is probably what the programmer intended\n\n*ptr = 6;\n```", "```\nif (ptr != NULL) {\n\n    *ptr = 6;\n\n}\n```", "```\n#include <stdio.h>\n\nint change_value(int *input);\n\nint main() {\n\n    int x;\n\n    int y;\n\n    x = 30;\n\n    y = change_value(&x);\n\n    printf(\"x: %d y: %d\\n\", x, y);  // prints x: 100 y: 30\n\n    return 0;\n\n}\n\n/*\n\n * changes the value of the argument\n\n *     input: a pointer to the value to change\n\n *     returns: the original value of the argument\n\n */\n\nint change_value(int *input) {\n\n    int val;\n\n    val = *input; /* val gets the value input points to */\n\n    if (val < 100) {\n\n        *input = 100;  /* the value input points to gets 100 */\n\n    } else {\n\n        *input =  val * 2;\n\n    }\n\n    return val;\n\n}\n```", "```\nx: 100 y: 30\n```", "```\n// Determine the size of an integer and allocate that much heap space.\n\nmalloc(sizeof(int));\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\nint main() {\n\n    int *p;\n\n    p = malloc(sizeof(int));  // allocate heap memory for storing an int\n\n    if (p != NULL) {\n\n        *p = 6;   // the heap memory p points to gets the value 6\n\n    }\n\n}\n```", "```\np = (int *) malloc(sizeof(int));\n```", "```\nint *p;\n\np = malloc(sizeof(int));\n\nif (p == NULL) {\n\n    printf(\"Bad malloc error\\n\");\n\n    exit(1);   // exit the program and indicate error\n\n}\n\n*p = 6;\n```", "```\nfree(p);\n\np = NULL;\n```", "```\nint *arr;\n\nchar *c_arr;\n\n// allocate an array of 20 ints on the heap:\n\narr = malloc(sizeof(int) * 20);\n\n// allocate an array of 10 chars on the heap:\n\nc_arr = malloc(sizeof(char) * 10);\n```", "```\nint i;\n\nint s_array[20];\n\nint *d_array;\n\nd_array = malloc(sizeof(int) * 20);\n\nif (d_array == NULL) {\n\n    printf(\"Error: malloc failed\\n\");\n\n    exit(1);\n\n}\n\nfor (i=0; i < 20; i++) {\n\n    s_array[i] = i;\n\n    d_array[i] = i;\n\n}\n\nprintf(\"%d %d \\n\", s_array[3], d_array[3]);  // prints 3 3\n```", "```\n/* these two statements are identical: both put 8 in index 0 */\n\nd_array[0] = 8; // put 8 in index 0 of the d_array\n\n*d_array = 8;   // in the location pointed to by d_array store 8\n```", "```\nfree(arr);\n\narr = NULL;\n\nfree(c_arr);\n\nc_arr = NULL;\n\nfree(d_array);\n\nd_array = NULL;\n```", "```\nint main() {\n\n    int *arr1;\n\n    arr1 = malloc(sizeof(int) * 10);\n\n    if (arr1 == NULL) {\n\n        printf(\"malloc error\\n\");\n\n        exit(1);\n\n    }\n\n    /* pass the value of arr1 (base address of array in heap) */\n\n    init_array(arr1, 10);\n\n    ...\n\n}\n\nvoid init_array(int *arr, int size) {\n\n    int i;\n\n    for (i = 0; i < size; i++) {\n\n        arr[i] = i;\n\n    }\n\n}\n```", "```\n// declare arrays specifying their type and total capacity\n\nfloat averages[30];   // array of float, 30 elements\n\nchar  name[20];       // array of char, 20 elements\n\nint i;\n\n// access array elements\n\nfor (i = 0; i < 10; i++) {\n\n    averages[i] = 0.0 + i;\n\n    name[i] = 'a' + i;\n\n}\n\nname[10] = '\\0';    // name is being used for storing a C-style string\n\n// prints: 3 d abcdefghij\n\nprintf(\"%g %c %s\\n\", averages[3], name[3], name);\n\nstrcpy(name, \"Hello\");\n\nprintf(\"%s\\n\", name);  // prints: Hello\n```", "```\n// declare a pointer variable to point to allocated heap space\n\nint    *p_array;\n\ndouble *d_array;\n\n// call malloc to allocate the appropriate number of bytes for the array\n\np_array = malloc(sizeof(int) * 50);      // allocate 50 ints\n\nd_array = malloc(sizeof(double) * 100);  // allocate 100 doubles\n\n// always CHECK RETURN VALUE of functions and HANDLE ERROR return values\n\nif ( (p_array == NULL) || (d_array == NULL) ) {\n\n    printf(\"ERROR: malloc failed!\\n\");\n\n    exit(1);\n\n}\n\n// use [] notation to access array elements\n\nfor (i = 0; i < 50; i++) {\n\n    p_array[i] = 0;\n\n    d_array[i] = 0.0;\n\n}\n\n// free heap space when done using it\n\nfree(p_array);\n\np_array = NULL;\n\nfree(d_array);\n\nd_array = NULL;\n```", "```\n array [0]:  base address\n\n array [1]:  next address\n\n array [2]:  next address\n\n   ...            ...\n\n array [99]: last address\n```", "```\nint  iarray[6];  // an array of six ints, each of which is four bytes\n\nchar carray[4];  // an array of four chars, each of which is one byte\n```", "```\n addr   element\n\n ----   -------\n\n 1230:  iarray[0]\n\n 1234:  iarray[1]\n\n 1238:  iarray[2]\n\n 1242:  iarray[3]\n\n 1246:  iarray[4]\n\n 1250:  iarray[5]\n\n     ...\n\n 1280:  carray[0]\n\n 1281:  carray[1]\n\n 1282:  carray[2]\n\n 1283:  carray[3]\n```", "```\nint   matrix[50][100];\n\nshort little[10][10];\n```", "```\nint   val;\n\nshort num;\n\nval = matrix[3][7];  // get int value in row 3, column 7 of matrix\n\nnum = little[8][4];  // get short value in row 8, column 4 of little\n```", "```\nint i, j;\n\nfor (i = 0; i < 50; i++) {  // for each row i\n\n    for (j = 0; j < 100; j++) { // iterate over each column element in row i\n\n        matrix[i][j] = 0;\n\n    }\n\n}\n```", "```\n// a C constant definition: COLS is defined to be the value 100\n\n#define COLS  (100)\n\n/*\n\n * init_matrix: initializes the passed matrix elements to the\n\n *              product of their index values\n\n *   m: a 2D array (the column dimension must be 100)\n\n *   rows: the number of rows in the matrix\n\n *   return: does not return a value\n\n */\n\nvoid init_matrix(int m[][COLS], int rows) {\n\n    int i, j;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < COLS; j++) {\n\n            m[i][j] = i*j;\n\n        }\n\n    }\n\n}\n\nint main() {\n\n    int matrix[50][COLS];\n\n    int bigger[90][COLS];\n\n    init_matrix(matrix, 50);\n\n    init_matrix(bigger, 90);\n\n    ...\n```", "```\nint arr[3][4];  // int array with 3 rows and 4 columns\n```", "```\n#define N 3\n\n#define M 4\n\nint main() {\n\n    int *two_d_array;    // the type is a pointer to an int (the element type)\n\n    // allocate in a single malloc of N x M int-sized elements:\n\n    two_d_array = malloc(sizeof(int) * N * M);\n\n    if (two_d_array == NULL) {\n\n        printf(\"ERROR: malloc failed!\\n\");\n\n        exit(1);\n\n    }\n\n    ...\n```", "```\n// access using [] notation:\n\n//   cannot use [i][j] syntax because the compiler has no idea where the\n\n//   next row starts within this chunk of heap space, so the programmer\n\n//   must explicitly add a function of row and column index values\n\n//   (i*M+j) to map their 2D view of the space into the 1D chunk of memory\n\n for (i = 0; i < N; i++) {\n\n    for (j = 0; j < M; j++) {\n\n        two_d_array[i*M + j] = 0;\n\n    }\n\n}\n```", "```\n/*\n\n * initialize all elements in a 2D array to 0\n\n *  arr: the array\n\n *  rows: number of rows\n\n *  cols: number of columns\n\n */\n\nvoid init2D(int *arr, int rows, int cols) {\n\n    int i, j;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < cols; j++) {\n\n            arr[i*cols + j] = 0;\n\n        }\n\n    }\n\n}\n\nint main() {\n\n    int *array;\n\n    array = malloc(sizeof(int) * N * M);\n\n    if (array != NULL) {\n\n        init2D(array, N, M);\n\n    }\n\n    ...\n```", "```\n// the 2D array variable is declared to be `int **` (a pointer to an int *)\n\n// a dynamically allocated array of dynamically allocated int arrays\n\n// (a pointer to pointers to ints)\n\nint **two_d_array;\n\nint i;\n\n// allocate an array of N pointers to ints\n\n// malloc returns the address of this array (a pointer to (int *)'s)\n\ntwo_d_array = malloc(sizeof(int *) * N);\n\n// for each row, malloc space for its column elements and add it to\n\n// the array of arrays\n\nfor (i = 0; i < N; i++) {\n\n// malloc space for row i's M column elements\n\n    two_d_array[i] = malloc(sizeof(int) * M);\n\n}\n```", "```\nint i, j;\n\nfor (i = 0; i < N; i++) {\n\n    for (j = 0; j < M; j++) {\n\n        two_d_array[i][j] = 0;\n\n    }\n\n}\n```", "```\n       two_d_array: an array of int pointers, it stores the base address of an\n\n                 array of (int *) values. Its type is int** (a pointer to \n\n                 int *).\n\n    two_d_array[i]: the ith index into the array of arrays, it stores an \n\n                 (int *) value that represents the base address of an array of \n\n                 (int) values.  Its type is int*.\n\n two_d_array[i][j]: the jth element pointed to by the ith element of the array\n\n                of arrays, it stores an int value (the value in row i, column \n\n                j of the 2D array).  Its type is int.\n```", "```\n/*\n\n * initialize a 2D array\n\n * arr: the array\n\n * rows: number of rows\n\n * cols: number of columns\n\n */\n\nvoid init2D_Method2(int **arr, int rows, int cols) {\n\n    int i,j;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < cols; j++) {\n\n            arr[i][j] = 0;\n\n        }\n\n    }\n\n}\n\n/*\n\n * main: example of calling init2D_Method2\n\n */\n\nint main() {\n\n    int **two_d_array;\n\n    // some code to allocate the row array and multiple col arrays\n\n    // ...\n\n    init2D_Method2(two_d_array, N, M);\n\n    ...\n```", "```\n#include <stdio.h>\n\n#include <string.h>   // include the C string library\n\nint main() {\n\n    char str1[10];\n\n    char str2[10];\n\n    str1[0] = 'h';\n\n    str1[1] = 'i';\n\n    str1[2] = '\\0';   // explicitly add null terminating character to end\n\n    // strcpy copies the bytes from the source parameter (str1) to the\n\n    // destination parameter (str2) and null terminates the copy.\n\n    strcpy(str2, str1);\n\n    str2[1] = 'o';\n\n    printf(\"%s %s\\n\", str1, str2);  // prints: hi ho\n\n    return 0;\n\n}\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n int main() {\n\n    int size;\n\n    char str[64];         // statically allocated\n\n    char *new_str = NULL; // for dynamically allocated\n\n    strcpy(str, \"Hello\");\n\n    size = strlen(str);   // returns 5\n\n    new_str = malloc(sizeof(char) * (size+1)); // need space for '\\0'\n\n    if(new_str == NULL) {\n\n        printf(\"Error: malloc failed!  exiting.\\n\");\n\n        exit(1);\n\n    }\n\n    strcpy(new_str, str);\n\n    printf(\"%s %s\\n\", str, new_str);    // prints \"Hello Hello\"\n\n    strcat(str, \" There\");  // concatenate \" There\" to the end of str\n\n    printf(\"%s\\n\", str);    // prints \"Hello There\"\n\n    free(new_str);  // free malloc'ed space when done\n\n    new_str = NULL;\n\n    return 0;\n\n}\n```", "```\n// returns the number of characters in the string \n\n// (not including the null character)\n\nint strlen(char *s);\n\n// copies string src to string dst up until the first '\\0' character in src\n\n// (the caller needs to make sure src is initialized correctly and\n\n// dst has enough space to store a copy of the src string)\n\n// returns the address of the dst string\n\nchar *strcpy(char *dst, char *src);\n\n// like strcpy but copies up to the first '\\0' or size characters\n\n// (this provides some safety to not copy beyond the bounds of the dst\n\n// array if the src string is not well formed or is longer than the\n\n// space available in the dst array); size_t is an unsigned integer type\n\nchar *strncpy(char *dst, char *src, size_t size);\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>   // include the string library\n\nint main() {\n\n    // variable declarations that will be used in examples\n\n    int len, i, ret;\n\n    char str[32];\n\n    char *d_str, *ptr;\n\n    strcpy(str, \"Hello There\");\n\n    len = strlen(str);  // len is 11\n\n    d_str = malloc(sizeof(char) * (len+1));\n\n    if (d_str == NULL) {\n\n        printf(\"Error: malloc failed\\n\");\n\n        exit(1);\n\n    }\n\n    strncpy(d_str, str, 5);\n\n    d_str[5] = '\\0';   // explicitly add null terminating character to end\n\n    printf(\"%d:%s\\n\", strlen(str), str);      // prints 11:Hello There\n\n    printf(\"%d:%s\\n\", strlen(d_str), d_str);  // prints 5:Hello\n\n    return 0;\n\n}\n```", "```\nif (d_str == str) { ...\n```", "```\nint strcmp(char *s1, char *s2);\n\n// returns 0 if s1 and s2 are the same strings\n\n// a value < 0 if s1 is less than s2\n\n// a value > 0 if s1 is greater than s2\n\nint strncmp(char *s1, char *s2, size_t n);\n\n// compare s1 and s2 up to at most n characters\n```", "```\nstrcpy(str, \"alligator\");\n\nstrcpy(d_str, \"Zebra\");\n\nret =  strcmp(str,d_str);\n\nif (ret == 0) {\n\n    printf(\"%s is equal to %s\\n\", str, d_str);\n\n} else if (ret < 0) {\n\n    printf(\"%s is less than %s\\n\", str, d_str);\n\n} else {\n\n    printf(\"%s is greater than %s\\n\", str, d_str);  // true for these strings\n\n}\n\nret = strncmp(str, \"all\", 3);  // returns 0: they are equal up to first 3 chars\n```", "```\n// append chars from src to end of dst\n\n// returns ptr to dst and adds '\\0' to end\n\nchar *strcat(char *dst, char *src)\n\n// append the first chars from src to end of dst, up to a maximum of size\n\n// returns ptr to dst and adds '\\0' to end\n\nchar *strncat(char *dst, char *src, size_t size);\n```", "```\n// locate a substring inside a string\n\n// (const means that the function doesn't modify string)\n\n// returns a pointer to the beginning of substr in string\n\n// returns NULL if substr not in string\n\nchar *strstr(const char *string, char *substr);\n\n// locate a character (c) in the passed string (s)\n\n// (const means that the function doesn't modify s)\n\n// returns a pointer to the first occurrence of the char c in string\n\n// or NULL if c is not in the string\n\nchar *strchr(const char *s, int c);\n```", "```\nchar str[32];\n\nchar *ptr;\n\nstrcpy(str, \"Zebra fish\");\n\nstrcat(str, \" stripes\");  // str gets \"Zebra fish stripes\"\n\nprintf(\"%s\\n\", str);     // prints: Zebra fish stripes\n\nstrncat(str, \" are black.\", 8);\n\nprintf(\"%s\\n\", str);     // prints: Zebra fish stripes are bla  (spaces count)\n\nptr = strstr(str, \"trip\");\n\nif (ptr != NULL) {\n\n    printf(\"%s\\n\", ptr);   // prints: tripes are bla\n\n}\n\nptr = strchr(str, 'e');\n\nif (ptr != NULL) {\n\n    printf(\"%s\\n\", ptr);   // prints: ebra fish stripes are bla\n\n}\n```", "```\nchar *strtok(char *str, const char *delim);\n\n// a reentrant version of strtok (reentrant is defined in later chapters):\n\nchar *strtok_r(char *str, const char *delim, char **saveptr);\n```", "```\n/*\n\n * Extract whitespace-delimited tokens from a line of input\n\n * and print them one per line.\n\n *\n\n * to compile:\n\n *   gcc -g -Wall strtokexample.c\n\n *\n\n * example run:\n\n *   Enter a line of text:        aaaaa             bbbbbbbbb          cccccc\n\n *\n\n *   The input line is:\n\n *         aaaaa             bbbbbbbbb          cccccc\n\n *   Next token is aaaaa\n\n *   Next token is bbbbbbbbb\n\n *   Next token is cccccc\n\n */\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\nint main() {\n\n     /* whitespace stores the delim string passed to strtok.  The delim\n\n * string  is initialized to the set of characters that delimit tokens\n\n      * We initialize the delim string to the following set of chars:\n\n      *   ' ': space  '\\t': tab  '\\f': form feed  '\\r': carriage return\n\n      *   '\\v': vertical tab  '\\n': new line\n\n      * (run \"man ascii\" to list all ASCII characters)\n\n      *\n\n      * This line shows one way to statically initialize a string variable\n\n      * (using this method the string contents are constant, meaning that they\n\n      *  cannot be modified, which is fine for the way we are using the\n\n      *  whitespace string in this program).\n\n      */\n\n    char *whitespace = \" \\t\\f\\r\\v\\n\";  /* Note the space char at beginning */\n\n    char *token;  /* The next token in the line. */\n\n    char *line;   /* The line of text read in that we will tokenize. */\n\n    /* Allocate some space for the user's string on the heap. */\n\n    line = malloc(200 * sizeof(char));\n\n    if (line == NULL) {\n\n        printf(\"Error: malloc failed\\n\");\n\n        exit(1);\n\n    }\n\n    /* Read in a line entered by the user from \"standard in\". */\n\n    printf(\"Enter a line of text:\\n\");\n\n    line = fgets(line, 200 * sizeof(char), stdin);\n\n    if (line == NULL) {\n\n        printf(\"Error: reading input failed, exiting...\\n\");\n\n        exit(1);\n\n    }\n\n    printf(\"The input line is:\\n%s\\n\", line);\n\n    /* Divide the string into tokens. */\n\n    token = strtok(line, whitespace);       /* get the first token */\n\n    while (token != NULL) {\n\n        printf(\"Next token is %s\\n\", token);\n\n        token = strtok(NULL, whitespace);     /* get the next token */\n\n    }\n\n    free(line);\n\n    return 0;\n\n}\n```", "```\n// like printf(), the format string allows for placeholders like %d, %f, etc.\n\n// pass parameters after the format string to fill them in\n\nint sprintf(char *s, const char *format, ...);\n```", "```\nchar str[64];\n\nfloat ave = 76.8;\n\nint num = 2;\n\n// initialize str to format string, filling in each placeholder with\n\n// a char representation of its arguments' values\n\nsprintf(str, \"%s is %d years old and in grade %d\", \"Henry\", 12, 7);\n\nprintf(\"%s\\n\", str);  // prints: Henry is 12 years old and in grade 7\n\nsprintf(str, \"The average grade on exam %d is %g\", num, ave);\n\nprintf(\"%s\\n\", str);  // prints: The average grade on exam 2 is 76.8\n```", "```\n#include <stdlib.h>   // include stdlib and ctype to use these\n\n#include <ctype.h>\n\nint islower(ch);\n\nint isupper(ch);       // these functions return a non-zero value if the\n\nint isalpha(ch);       // test is TRUE, otherwise they return 0 (FALSE)\n\nint isdigit(ch);\n\nint isalnum(ch);\n\nint ispunct(ch);\n\nint isspace(ch);\n\nchar tolower(ch);     // returns ASCII value of lower-case of argument\n\nchar toupper(ch);\n```", "```\nchar str[64];\n\nint len, i;\n\nstrcpy(str, \"I see 20 ZEBRAS, GOATS, and COWS\");\n\nif ( islower(str[2]) ){\n\n    printf(\"%c is lower case\\n\", str[2]);   // prints: s is lower case\n\n}\n\nlen = strlen(str);\n\nfor (i = 0; i < len; i++) {\n\n    if ( isupper(str[i]) ) {\n\n        str[i] = tolower(str[i]);\n\n    } else if( isdigit(str[i]) ) {\n\n        str[i] = 'X';\n\n    }\n\n}\n\nprintf(\"%s\\n\", str);  // prints: i see XX zebras, goats, and cows\n```", "```\n#include <stdlib.h>\n\nint atoi(const char *nptr);     // convert a string to an integer\n\ndouble atof(const char *nptr);  // convert a string to a float\n```", "```\nprintf(\"%d %g\\n\", atoi(\"1234\"), atof(\"4.56\"));\n```", "```\n$ man strcpy\n```", "```\n#include <stdio.h>\n\n#include <string.h>\n\n/* define a new struct type (outside function bodies) */\n\nstruct studentT {\n\n    char  name[64];\n\n    int   age;\n\n    float gpa;\n\n    int   grad_yr;\n\n};\n\n/* function prototypes */\n\nint checkID(struct studentT s1, int min_age);\n\nvoid changeName(char *old, char *new);\n\nint main() {\n\n    int can_vote;\n\n    // declare variables of struct type:\n\n    struct studentT student1, student2;\n\n // access field values using .\n\n    strcpy(student1.name, \"Ruth\");\n\n    student1.age = 17;\n\n    student1.gpa = 3.5;\n\n    student1.grad_yr = 2021;\n\n    // structs are lvalues\n\n    student2 = student1;\n\n    strcpy(student2.name, \"Frances\");\n\n    student2.age = student1.age + 4;\n\n    // passing a struct\n\n    can_vote = checkID(student1, 18);\n\n    printf(\"%s %d\\n\", student1.name, can_vote);\n\n    can_vote = checkID(student2, 18);\n\n    printf(\"%s %d\\n\", student2.name, can_vote);\n\n    // passing a struct field value\n\n    changeName(student2.name, \"Kwame\");\n\n    printf(\"student 2's name is now %s\\n\", student2.name);\n\n    return 0;\n\n}\n\nint checkID(struct studentT s, int min_age) {\n\n    int ret = 1;\n\n    if (s.age < min_age) {\n\n        ret = 0;\n\n        // changes age field IN PARAMETER COPY ONLY\n\n        s.age = min_age + 1;\n\n    }\n\n    return ret;\n\n}\n\nvoid changeName(char *old, char *new) {\n\n    if ((old == NULL) || (new == NULL)) {\n\n        return;\n\n    }\n\n    strcpy(old,new);\n\n}\n```", "```\nRuth 0\n\nFrances 1\n\nstudent 2's name is now Kwame\n```", "```\nstruct studentT {\n\n    char  name[64];\n\n    int   age;\n\n    float gpa;\n\n    int   grad_yr;\n\n};\n```", "```\nstruct studentT s;\n\nstruct studentT *sptr;\n\n// think very carefully about the type of each field when\n\n// accessing it (name is an array of char, age is an int ...)\n\nstrcpy(s.name, \"Freya\");\n\ns.age = 18;\n\ns.gpa = 4.0;\n\n s.grad_yr = 2020;\n\n// malloc space for a struct studentT for sptr to point to:\n\nsptr = malloc(sizeof(struct studentT));\n\nif (sptr == NULL) {\n\n    printf(\"Error: malloc failed\\n\");\n\n    exit(1);\n\n}\n```", "```\n// the grad_yr field of what sptr points to gets 2021:\n\n(*sptr).grad_yr = 2021;\n\n// the age field of what sptr points to gets s.age plus 1:\n\n(*sptr).age = s.age + 1;\n```", "```\n// the gpa field of what sptr points to gets 3.5:\n\nsptr->gpa = 3.5;\n\n// the name field of what sptr points to is a char *\n\n// (can use strcpy to init its value):\n\nstrcpy(sptr->name, \"Lars\");\n```", "```\nstruct personT {\n\n    char *name;     // for a dynamically allocated string field\n\n    int  age;\n\n};\n\nint main() {\n\n    struct personT p1, *p2;\n\n    // need to malloc space for the name field:\n\n    p1.name = malloc(sizeof(char) * 8);\n\n    strcpy(p1.name, \"Zhichen\");\n\n    p1.age = 22;\n\n    // first malloc space for the struct:\n\n    p2 = malloc(sizeof(struct personT));\n\n    // then malloc space for the name field:\n\n    p2->name = malloc(sizeof(char) * 4);\n\n    strcpy(p2->name, \"Vic\");\n\n    p2->age = 19;\n\n    ...\n\n    // Note: for strings, we must allocate one extra byte to hold the\n\n    // terminating null character that marks the end of the string.\n\n}\n```", "```\nstruct studentT classroom1[40];   // an array of 40 struct studentT\n\nstruct studentT *classroom2;      // a pointer to a struct studentT\n\n                                  // (for a dynamically allocated array)\n\nstruct studentT *classroom3[40];  // an array of 40 struct studentT *\n\n                                  // (each element stores a (struct studentT *)\n```", "```\n// classroom1 is an array:\n\n//    use indexing to access a particular element\n\n//    each element in classroom1 stores a struct studentT:\n\n//    use dot notation to access fields\n\nclassroom1[3].age = 21;\n\n// classroom2 is a pointer to a struct studentT\n\n//    call malloc to dynamically allocate an array\n\n//    of 15 studentT structs for it to point to:\n\nclassroom2 = malloc(sizeof(struct studentT) * 15);\n\n// each element in array pointed to by classroom2 is a studentT struct\n\n//    use [] notation to access an element of the array, and dot notation\n\n//    to access a particular field value of the struct at that index:\n\nclassroom2[3].year = 2013;\n\n// classroom3 is an array of struct studentT *\n\n//    use [] notation to access a particular element\n\n//    call malloc to dynamically allocate a struct for it to point to\n\nclassroom3[5] = malloc(sizeof(struct studentT));\n\n// access fields of the struct using -> notation\n\n// set the age field pointed to in element 5 of the classroom3 array to 21\n\nclassroom3[5]->age = 21;   \n```", "```\nvoid updateAges(struct studentT *classroom, int size) {\n\n    int i;\n\n for (i = 0; i < size; i++) {\n\n        classroom[i].age += 1;\n\n    }\n\n}\n```", "```\nupdateAges(classroom1, 40);\n\nupdateAges(classroom2, 15);\n```", "```\nstruct node {\n\n    int data;           // used to store a list element's data value\n\n    struct node *next;  // used to point to the next node in the list\n\n};\n```", "```\nstruct node *head, *temp;\n\nint i;\n\nhead = NULL;  // an empty linked list\n\nhead = malloc(sizeof(struct node));  // allocate a node\n\nif (head == NULL) {\n\n    printf(\"Error malloc\\n\");\n\n    exit(1);\n\n}\n\nhead->data = 10;    // set the data field\n\nhead->next = NULL;  // set next to NULL (there is no next element)\n\n// add 2 more nodes to the head of the list:\n\nfor (i = 0; i < 2; i++) {\n\n    temp = malloc(sizeof(struct node));  // allocate a node\n\n    if (temp == NULL) {\n\n        printf(\"Error malloc\\n\");\n\n        exit(1);\n\n    }\n\n    temp->data = i;     // set data field\n\n    temp->next = head;  // set next to point to current first node\n\n    head = temp;        // change head to point to newly added node\n\n}\n```", "```\n#  redirect a.out's stdin to read from file infile.txt:\n\n$ ./a.out < infile.txt\n\n#  redirect a.out's stdout to print to file outfile.txt:\n\n$ ./a.out > outfile.txt\n\n# redirect a.out's stdout and stderr to a file out.txt\n\n$ ./a.out &> outfile.txt\n\n# redirect all three to different files:\n\n#   (< redirects stdin, 1> stdout, and 2> stderr):\n\n$ ./a.out < infile.txt 1> outfile.txt 2> errorfile.txt\n```", "```\nint x = 5, y = 10;\n\nfloat pi = 3.14;\n\nprintf(\"x is %d and y is %d\\n\", x, y);\n\nprintf(\"%g \\t %s \\t %d\\n\", pi, \"hello\", y);\n```", "```\nx is 5 and y is 10\n\n3.14   hello   10\n```", "```\n%f, %g: placeholders for a float or double value\n\n%d:     placeholder for a decimal value (char, short, int)\n\n%u:     placeholder for an unsigned decimal\n\n%c:     placeholder for a single character\n\n%s:     placeholder for a string value\n\n%p:     placeholder to print an address value\n\n%ld:    placeholder for a long value\n\n%lu:    placeholder for an unsigned long value\n\n%lld:   placeholder for a long long value\n\n%llu:   placeholder for an unsigned long long value\n```", "```\nfloat labs;\n\nint midterm;\n\nlabs = 93.8;\n\nmidterm = 87;\n\n printf(\"Hello %s, here are your grades so far:\\n\", \"Tanya\");\n\nprintf(\"\\t midterm: %d (out of %d)\\n\", midterm, 100);\n\nprintf(\"\\t lab ave: %f\\n\", labs);\n\nprintf(\"\\t final report: %c\\n\", 'A');\n```", "```\nHello Tanya, here are your grades so far:\n\n     midterm: 87 (out of 100)\n\n     lab ave: 93.800003\n\n     final report: A\n```", "```\n%5.3f: print float value in space 5 chars wide, with 3 places beyond decimal\n\n%20s:  print the string value in a field of 20 chars wide, right justified\n\n%-20s: print the string value in a field of 20 chars wide, left justified\n\n%8d:   print the int value in a field of 8 chars wide, right justified\n\n%-8d:  print the int value in a field of 8 chars wide, left justified\n```", "```\n#include <stdio.h> // library needed for printf\n\nint main() {\n\n    float x, y;\n\n    char ch;\n\n    x = 4.50001;\n\n    y = 5.199999;\n\n    ch = 'a';      // ch stores ASCII value of 'a' (the value 97)\n\n    // .1: print x and y with single precision\n\n    printf(\"%.1f %.1f\\n\", x, y);\n\n    printf(\"%6.1f \\t %6.1f \\t %c\\n\", x, y, ch);\n\n    // ch+1 is 98, the ASCII value of 'b'\n\n    printf(\"%6.1f \\t %6.1f \\t %c\\n\", x+1, y+1, ch+1);\n\n    printf(\"%6.1f \\t %6.1f \\t %c\\n\", x*20, y*20, ch+2);\n\n    return 0;\n\n}\n```", "```\n4.5 5.2\n\n   4.5    5.2     a\n\n   5.5    6.2     b\n\n  90.0  104.0     c\n```", "```\n%x:     print value in hexadecimal (base 16)\n\n%o:     print value in octal (base 8)\n\n%d:     print value in signed decimal  (base 10)\n\n%u:     print value in unsigned decimal (unsigned base 10)\n\n%e:     print float or double in scientific notation\n\n(there is no formatting option to display a value in binary)\n```", "```\nint x;\n\nchar ch;\n\nx = 26;\n\nch = 'A';\n\nprintf(\"x is %d in decimal, %x in hexadecimal and %o in octal\\n\", x, x, x);\n\nprintf(\"ch value is %d which is the ASCII value of  %c\\n\", ch, ch);\n```", "```\nx is 26 in decimal, 1a in hexadecimal and 32 in octal\n\nch value is 65 which is the ASCII value of A\n```", "```\nint x;\n\nfloat pi;\n\n// read in an int value followed by a float value (\"%d%g\")\n\n// store the int value at the memory location of x (&x)\n\n// store the float value at the memory location of pi (&pi)\n\nscanf(\"%d%g\", &x, &pi);\n```", "```\n           8                   3.14\n```", "```\n// read in an int and a float separated by at least one white space character\n\nscanf(\"%d%g\",&x, &pi);\n```", "```\nch = getchar();  // read in the next char value from stdin\n\nputchar(ch);     // write the value of ch to stdout\n```", "```\nFILE *infile;\n\nFILE *outfile;\n```", "```\ninfile = fopen(\"input.txt\", \"r\");  // relative path name of file, read mode\n\nif (infile == NULL) {\n\n    printf(\"Error: unable to open file %s\\n\", \"input.txt\");\n\n    exit(1);\n\n}\n\n// fopen with absolute path name of file, write mode\n\noutfile = fopen(\"/home/me/output.txt\", \"w\");\n\nif (outfile == NULL) {\n\n    printf(\"Error: unable to open outfile\\n\");\n\n    exit(1);\n\n}\n```", "```\nint ch;  // EOF is not a char value, but is an int.\n\n         // since all char values can be stored in int, use int for ch\n\nch = getc(infile);      // read next char from the infile stream\n\nif (ch != EOF) {\n\n    putc(ch, outfile);  // write char value to the outfile stream\n\n}\n```", "```\nfclose(infile);\n\nfclose(outfile);\n```", "```\n// to reset current position to beginning of file\n\nvoid rewind(FILE *f);\n\nrewind(infile);\n\n// to move to a specific location in the file:\n\nfseek(FILE *f, long offset, int whence);\n\nfseek(f, 0, SEEK_SET);    // seek to the beginning of the file\n\nfseek(f, 3, SEEK_CUR);    // seek 3 chars forward from the current position\n\nfseek(f, -3, SEEK_END);   // seek 3 chars back from the end of the file\n```", "```\n// ---------------\n\n// Character Based\n\n// ---------------\n\n// returns the next character in the file stream (EOF is an int value)\n\nint fgetc(FILE *f);\n\n// writes the char value c to the file stream f\n\n// returns the char value written\n\nint fputc(int c, FILE *f);\n\n // pushes the character c back onto the file stream\n\n// at most one char (and not EOF) can be pushed back\n\nint ungetc(int c, FILE *f);\n\n// like fgetc and fputc but for stdin and stdout\n\nint getchar();\n\nint putchar(int c);\n\n// -------------\n\n// String  Based\n\n// -------------\n\n// reads at most n-1 characters into the array s stopping if a newline is\n\n// encountered, newline is included in the array which is '\\0' terminated\n\nchar *fgets(char *s, int n, FILE *f);\n\n// writes the string s (make sure '\\0' terminated) to the file stream f\n\nint fputs(char *s, FILE *f);\n\n// ---------\n\n// Formatted\n\n// ---------\n\n// writes the contents of the format string to file stream f\n\n//   (with placeholders filled in with subsequent argument values)\n\n// returns the number of characters printed\n\nint fprintf(FILE *f, char *format, ...);\n\n// like fprintf but to stdout\n\nint printf(char *format, ...);\n\n// use fprintf to print stderr:\n\nfprintf(stderr, \"Error return value: %d\\n\", ret);\n\n// read values specified in the format string from file stream f\n\n//   store the read-in values to program storage locations of types\n\n//   matching the format string\n\n// returns number of input items converted and assigned\n\n//   or EOF on error or if EOF was reached\n\nint fscanf(FILE *f, char *format, ...);\n\n// like fscanf but reads from stdin\n\nint scanf(char *format, ...);\n```", "```\n%d integer\n\n%f float\n\n%lf double\n\n%c character\n\n%s string, up to first white space\n\n%[...] string, up to first character not in brackets\n\n%[0123456789] would read in digits\n\n%[^...] string, up to first character in brackets\n\n%[^\\n] would read everything up to a newline\n```", "```\nint x;\n\ndouble d;\n\nchar c, array[MAX];\n\n// write int & char values to file separated by colon with newline at the end\n\nfprintf(outfile, \"%d:%c\\n\", x, c);\n\n// read an int & char from file where int and char are separated by a comma\n\nfscanf(infile, \"%d,%c\", &x, &c);\n\n// read a string from a file into array (stops reading at whitespace char)\n\nfscanf(infile,\"%s\", array);\n\n// read a double and a string up to 24 chars from infile\n\nfscanf(infile, \"%lf %24s\", &d, array);\n\n// read in a string consisting of only char values in the specified set (0-5)\n\n// stops reading when...\n\n//   20 chars have been read OR\n\n//   a character not in the set is reached OR\n\n//   the file stream reaches end-of-file (EOF)\n\nfscanf(infile, \"%20[012345]\", array);\n\n// read in a string; stop when reaching a punctuation mark from the set\n\n fscanf(infile, \"%[^.,:!;]\", array);\n\n// read in two integer values: store first in long, second in int\n\n// then read in a char value following the int value\n\nfscanf(infile, \"%ld %d%c\", &x, &b, &c);\n```", "```\nswitch (<expression>) {\n\n   case <literal value 1>:\n\n        <statements>;\n\n        break;         // breaks out of switch statement body\n\n   case <literal value 2>:\n\n        <statements>;\n\n        break;         // breaks out of switch statement body\n\n   ...\n\n   default:            // default label is optional\n\n        <statements>;\n\n}\n```", "```\n#include <stdio.h>\n\nint main() {\n\n    int num, new_num = 0;\n\n    printf(\"enter a number between 6 and 9: \");\n\n    scanf(\"%d\", &num);\n\n    switch(num) {\n\n        case 6:\n\n            new_num = num + 1;\n\n            break;\n\n        case 7:\n\n            new_num = num;\n\n            break;\n\n        case 8:\n\n            new_num = num - 1;\n\n            break;\n\n        case 9:\n\n            new_num = num + 2;\n\n            break;\n\n        default:\n\n            printf(\"Hey, %d is not between 6 and 9\\n\", num);\n\n    }\n\n    printf(\"num %d  new_num %d\\n\", num, new_num);\n\n    return 0;\n\n}\n```", "```\n./a.out\n\nenter a number between 6 and 9: 9\n\nnum 9  new_num 11\n\n./a.out\n\nenter a number between 6 and 9: 6\n\nnum 6  new_num 7\n\n./a.out\n\nenter a number between 6 and 9: 12\n\nHey, 12 is not between 6 and 9\n\nnum 12  new_num 0\n```", "```\nint main(int argc, char *argv[]) { ...\n```", "```\n./a.out 10 11 200\n```", "```\nint x;\n\nx = atoi(argv[1]);  // x gets the int value 10\n```", "```\nvoid *gen_ptr;\n\nint x;\n\nchar ch;\n\ngen_ptr = &x;  // gen_ptr can be assigned the address of an int\n\ngen_ptr = &ch; // or the address of a char (or the address of any type)\n```", "```\nint *array;\n\nchar *str;\n\narray = (int *)malloc(sizeof(int) * 10); // recast void * return value\n\nstr = (char *)malloc(sizeof(char) * 20);\n\n*array = 10;\n\nstr[0] = 'a';\n```", "```\n/*\n\n * an application-specific pthread main function\n\n * must have this function prototype: int func_name(void *args)\n\n *\n\n * any given implementation knows what type is really passed in\n\n *  args: pointer to an int value\n\n */\n\nint my_thr_main(void *args) {\n\n    int num;\n\n    // first recast args to an int *, then dereference to get int value\n\n    num = *((int *)args);  // num gets 6\n\n    ...\n\n}\n\nint main() {\n\n    int ret, x;\n\n    pthread_t tid;\n\n    x = 6;\n\n    // pass the address of int variable (x) to pthread_create's void * param\n\n    // (we recast &x as a (void *) to match the type of pthread_create's param)\n\n    ret = pthread_create(&tid, NULL,\n\n                         my_thr_main,    // a thread main function\n\n                         (void *)(&x));  // &x will be passed to my_thr_main\n\n    // ...\n```", "```\n#define N 10\n\n#define M 20\n\nint main() {\n\n    // array declarations:\n\n    char letters[N];\n\n    int numbers[N], i, j;\n\n    int matrix[N][M];\n\n    // declare pointer variables that will access int or char array elements\n\n    // using pointer arithmetic (the pointer type must match array element type)\n\n    char *cptr = NULL;\n\n    int *iptr = NULL;\n\n    ...\n```", "```\n// make the pointer point to the first element in the array\n\ncptr = &(letters[0]); //  &(letters[0])  is the address of element 0\n\niptr = numbers;       // the address of element 0 (numbers is &(numbers[0]))\n```", "```\n// initialized letters and numbers arrays through pointer variables\n\nfor (i = 0; i < N; i++) {\n\n    // dereference each pointer and update the element it currently points to\n\n    *cptr = 'a' + i;\n\n    *iptr = i * 3;\n\n    // use pointer arithmetic to set each pointer to point to the next element\n\n    cptr++;  // cptr points to the next char address (next element of letters)\n\n    iptr++;  // iptr points to the next int address  (next element of numbers)\n\n}\n```", "```\nprintf(\"\\n array values using indexing to access: \\n\");\n\n// see what the code above did:\n\nfor (i = 0; i < N; i++) {\n\n    printf(\"letters[%d] = %c, numbers[%d] = %d\\n\",\n\n           i, letters[i], i, numbers[i]);\n\n}\n\n// we could also use pointer arith to print these out:\n\nprintf(\"\\n array values using pointer arith to access: \\n\");\n\n// first: initialize pointers to base address of arrays:\n\ncptr = letters;  // letters == &letters[0]\n\niptr = numbers;\n\nfor (i = 0; i < N; i++) {\n\n    // dereference pointers to access array element values\n\n    printf(\"letters[%d] = %c, numbers[%d] = %d\\n\",\n\n            i, *cptr, i, *iptr);\n\n    // increment pointers to point to the next element\n\n    cptr++;\n\n    iptr++;\n\n}\n```", "```\n array values using indexing to access:\n\nletters[0] = a, numbers[0] = 0\n\nletters[1] = b, numbers[1] = 3\n\n letters[2] = c, numbers[2] = 6\n\nletters[3] = d, numbers[3] = 9\n\nletters[4] = e, numbers[4] = 12\n\nletters[5] = f, numbers[5] = 15\n\nletters[6] = g, numbers[6] = 18\n\nletters[7] = h, numbers[7] = 21\n\nletters[8] = i, numbers[8] = 24\n\nletters[9] = j, numbers[9] = 27\n\n array values using pointer arith to access:\n\nletters[0] = a, numbers[0] = 0\n\nletters[1] = b, numbers[1] = 3\n\nletters[2] = c, numbers[2] = 6\n\nletters[3] = d, numbers[3] = 9\n\nletters[4] = e, numbers[4] = 12\n\nletters[5] = f, numbers[5] = 15\n\nletters[6] = g, numbers[6] = 18\n\nletters[7] = h, numbers[7] = 21\n\nletters[8] = i, numbers[8] = 24\n\nletters[9] = j, numbers[9] = 27\n```", "```\n// sets matrix to:\n\n// row 0:   0,   1,   2, ...,  99\n\n// row 1: 100, 110, 120, ..., 199\n\n//        ...\n\niptr = &(matrix[0][0]);\n\nfor (i = 0; i < N*M; i++) {\n\n    *iptr = i;\n\n    iptr++;\n\n}\n\n// see what the code above did:\n\nprintf(\"\\n 2D array values inited using pointer arith: \\n\");\n\nfor (i = 0; i < N; i++) {\n\n    for (j = 0; j < M; j++) {\n\n        printf(\"%3d \", matrix[i][j]);\n\n    }\n\n    printf(\"\\n\");\n\n}\n\nreturn 0;\n\n}\n```", "```\n 2D array values initialized using pointer arith:\n\n  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19\n\n 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39\n\n 40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59\n\n 60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79\n\n 80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99\n\n100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119\n\n120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139\n\n140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159\n\n160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179\n\n180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199\n```", "```\niptr = &numbers[2];\n\n*iptr = -13;\n\niptr += 4;\n\n*iptr = 9999;\n```", "```\nnumbers[0] = 0\n\nnumbers[1] = 3\n\nnumbers[2] = -13\n\nnumbers[3] = 9\n\nnumbers[4] = 12\n\nnumbers[5] = 15\n\nnumbers[6] = 9999\n\nnumbers[7] = 21\n\nnumbers[8] = 24\n\nnumbers[9] = 27\n```", "```\n$ gcc -o myprog myprog.c -lpthread -lreadline\n```", "```\n$ gcc -o myprog myprog.c --static -lpthread -lreadline\n```", "```\n$ gcc -E  myprog.c\n\n$ gcc -E  myprog.c  > out\n\n$ vim out\n```", "```\n$ gcc -S  myprog.c\n\n$ vim myprog.s\n```", "```\n$ gcc -c  myprog.c\n\n# disassemble functions in myprog.o with objdump:\n\n$ objdump -d myprog.o\n```", "```\n$ gcc myprog.c\n\n$ ./a.out\n\n# disassemble functions in a.out with objdump:\n\n$ objdump -d a.out\n```", "```\n$ ldd a.out\n```", "```\n#include <stdio.h>\n\n#include <examplelib.h>\n\nint main(int argc, char *argv[]) {\n\n    int result;\n\n    result = libraryfunc(6, MAX);\n\n    printf(\"result is %d\\n\", result);\n\n    return 0;\n\n}\n```", "```\n#define MAX 10   // a constant exported by the library\n\n// a function exported by the library\n\nextern int libraryfunc(int x, int y);\n```", "```\n# '-g': add debug information, -c: compile to '.o'\n\n$ gcc -g -c myprog.c\n\nmyprog.c: In function main:\n\nmyprog.c:8:12: warning: implicit declaration of function libraryfunc\n\n   result = libraryfunc(6, MAX);\n\n            ^~~~~~~~~~~\n\nmyprog.c:8:27: error: MAX undeclared (first use in this function)\n\n   result = libraryfunc(6, MAX);\n\n                           ^~~\n```", "```\n$ gcc -g myprog.c\n\nIn function main:\n\nmyprog.c:9: undefined reference to libraryfunc\n\ncollect2: error: ld returned 1 exit status\n```", "```\n$ gcc -g myprog.c  -lexamplelib\n```", "```\n$ gcc -c myprog.c -lexamplelib\n\nmyprog.c:1:10: fatal error: examplelib.h: No such file or directory\n\n #include <examplelib.h>\n\n          ^~~~~~~\n\ncompilation terminated.\n```", "```\n$ gcc -c myprog.c -lexamplelib\n\n/usr/bin/ld: cannot find -lexamplelib\n\ncollect2: error: ld returned 1 exit status\n```", "```\n$ ./a.out\n\n./a.out: error while loading shared libraries:\n\n   libexamplelib.so: cannot open shared object file: No such file or directory\n```", "```\n$ gcc  -I/home/me/include -o myprog myprog.c -L/home/me/lib -lexamplelib\n```", "```\nexport LD_LIBRARY_PATH=/home/me/lib:$LD_LIBRARY_PATH\n```", "```\n$ vi /usr/include/stdio.h\n```", "```\n#ifndef _MYLIB_H_\n\n#define _MYLIB_H_\n\n// a constant definition exported by library:\n\n#define MAX_FOO  20\n\n// a type definition exported by library:\n\n struct foo_struct {\n\n    int x;\n\n    float y;\n\n};\n\n// a global variable exported by library\n\n// \"extern\" means that this is not a variable declaration,\n\n// but it defines that a variable named total_times of type\n\n// int exists in the library implementation and is available\n\n// for use by programs using the library.\n\n// It is unusual for a library to export global variables\n\n// to its users, but if it does, it is important that\n\n// extern appears in the definition in the .h file\n\nextern int total_times;\n\n// a function prototype for a function exported by library:\n\n// extern means that this function definition exists\n\n// somewhere else.\n\n/*\n\n * This function returns the larger of two float values\n\n *  y, z: the two values\n\n *  returns the value of the larger one\n\n */\n\nextern float bigger(float y, float z);\n\n#endif\n```", "```\n#ifndef <identifier>\n\n// header file contents\n\n#endif <identifier>\n```", "```\n#include <stdlib.h>\n\n// Include the library header file if the implementation needs\n\n// any of its definitions (types or constants, for example.)\n\n// Use \" \" instead of < > if the mylib.h file is not in a\n\n// default library path with other standard library header\n\n// files (the usual case for library code you write and use.)\n\n#include \"mylib.h\"\n\n// declare the global variable exported by the library\n\nint total_times = 0;\n\n// include function definitions for each library function:\n\nfloat bigger(float y, float z) {\n\n    total_times++;\n\n    if (y > z) {\n\n        return y;\n\n    }\n\n    return z;\n\n}\n```", "```\n$ gcc -o mylib.o -c mylib.c\n```", "```\n$ ar -rcs libmylib.a mylib.o\n```", "```\n$ gcc -fPIC -o mylib.o -c mylib.c\n\n$ gcc -shared -o libmylib.so mylib.o\n```", "```\n$ gcc -shared -o libbiglib.so file1.o file2.o file3.o file4.o\n\n$ ar -rcs libbiglib.a file1.o file2.o file3.o file4.o\n```", "```\n#include <stdio.h>\n\n#include \"mylib.h\"   // include library header file\n\nint main() {\n\n    float val1, val2, ret;\n\n    printf(\"Enter two float values: \");\n\n    scanf(\"%f%f\", &val1, &val2);\n\n    ret = bigger(val1, val2);   // use a library function\n\n    printf(\"%f is the biggest\\n\", ret);\n\n    return 0;\n\n}\n```", "```\n$ gcc -o myprog myprog.c mylib.o\n```", "```\n$ gcc -o myprog myprog.c mylib.c\n```", "```\n$ gcc -o myprog myprog.c -L. -lmylib\n```", "```\n$ ./myprog\n```", "```\n/usr/bin/ld: cannot find -lmylib\n\ncollect2: error: ld returned 1 exit status\n```", "```\n$ export LD_LIBRARY_PATH=/home/me/mylibs:$LD_LIBRARY_PATH\n```", "```\nint main() {\n\n    int x, y;\n\n    x = 1;\n\n    x = x + 2;\n\n    x = x - 14;\n\n    y = x*100;\n\n    x = x + y * 6;\n\n    return 0;\n\n}\n```", "```\n$ gcc -m32 -S simpleops.c   # runs the assembler to create a .s text file\n```", "```\n$ vim simpleops.s\n```", "```\n$ gcc -m32 -c simpleops.s   # compiles to a relocatable object binary file (.o)\n```", "```\n$ gcc -m32 -o simpleops simpleops.o  # creates a 32-bit executable file\n```", "```\n$ objdump -d simpleops.o\n```", "```\n$ cat simpleops.s\n```", "```\n        .file   \"simpleops.c\"\n\n        .text\n\n        .globl main\n\n        .type   main, @function\n\nmain:\n\n        pushl   %ebp\n\n        movl    %esp, %ebp\n\n        subl    $16, %esp\n\n        movl    $1, -8(%ebp)      # x = 1\n\n        addl    $2, -8(%ebp)      # x = x + 2\n\n        subl    $14, -8(%ebp)     # x = x - 14\n\n        movl    -8(%ebp), %eax    # load x into R[%eax]\n\n        imull   $100, %eax, %eax  # into R[%eax] store result of x*100\n\n        movl    %eax, -4(%ebp)    # y = x*100\n\n        movl    -4(%ebp), %edx\n\n        movl    %edx, %eax\n\n        addl    %eax, %eax\n\n        addl    %edx, %eax\n\n        addl    %eax, %eax\n\n        addl    %eax, -8(%ebp)\n\n        movl    $0, %eax\n\n        leave\n\n        ret\n\n        .size   main, .-main\n\n        .ident \"GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0\"\n\n        .section .note.GNU-stack,\"\",@progbits\n```", "```\n        .text                   # this file contains instruction code\n\n.globl myfunc                   # myfunc is the name of a function\n\n        .type   myfunc, @function\n\nmyfunc:                         # the start of the function\n\n        pushl   %ebp            # function preamble:\n\n        movl    %esp, %ebp      #  the 1st three instrs set up the stack\n\n        subl    $16, %esp\n\n        # A programmer adds specific IA32 instructions\n\n        # here that allocate stack space for any local variables\n\n        # and then implements code using parameters and locals to\n\n        # perform the functionality of the myfunc function\n\n        #\n\n        # the return value should be stored in %eax before returning\n\n        leave    # function return code\n\n        ret\n```", "```\n#include <stdio.h>\n\nint myfunc(int param);\n\nint main() {\n\n    int ret;\n\n    ret = myfunc(32);\n\n    printf(\"myfunc(32) is %d\\n\", ret);\n\n    return 0;\n\n}\n```", "```\n$ gcc -m32 -c myfunc.s\n\n$ gcc -m32 -o myprog myfunc.o main.c\n```"]