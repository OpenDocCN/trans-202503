- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ADDING
    PROFESSIONAL POWER CONTROL</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of controlling power to your Arduino with a switch or USB cable, you
    can use *soft power control*: turning power on and off with buttons or having
    your Arduino turn itself off via the sketch or external sensor. Soft power increases
    the professionalism of your projects. If you’re designing, say, a fancy hi-fi
    amplifier, a pair of on/off buttons looks far nicer than the type of on/off switch
    you’d find on industrial equipment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces various methods of soft power control. You’ll learn
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Control larger currents with MOSFETs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the 555 timer IC in bistable mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on Arduino circuits with external devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conserve power by building projects that turn on only when required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the DS3231 real-time clock (RTC) library for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also create a soft on/off switch for your Arduino and build a low-power
    event logger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Power the Arduino without a Physical
    Switch</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s common to supply power to Arduino projects with the USB socket, battery
    pack, or external AC adapter. Turning the project on and off in these cases means
    removing a cable or DC plug, which works well if you’re just experimenting or
    building something for your own use. However, soft power control allows you to
    control the power to your Arduino project by using buttons or signals from other
    devices or allowing an Arduino project to turn itself off completely. This doesn’t
    require a “hard” physical switch to connect or cut current flow.
  prefs: []
  type: TYPE_NORMAL
- en: Soft power control saves on hardware wear and tear, as there are no moving parts
    for power control, and makes interfaces simpler and easier to use. Turning power
    on and off with buttons or further automating device controls creates a better
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section further discusses two types of components that are required for
    these soft power control circuits: the MOSFET, used for switching current; and
    the 555 timer IC, in this case used as an interface between on and off signals
    in soft power control.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Operating MOSFETs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MOSFETs allow you to switch large voltages and currents with a small signal,
    such as that from our Arduino’s digital output pins. They are available in various
    sizes, such as those shown in [Figure 6-1](chapter6.xhtml#fig6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF VARIOUS THROUGH-HOLE AND SURFACE-MOUNT MOSFETS](../images/fig6-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Various MOSFETs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom left of [Figure 6-1](chapter6.xhtml#fig6-1) shows the small 2N7000
    N-MOSFET from Project #14 in [Chapter 4](chapter4.xhtml), which we’ll also use
    in this chapter. Looking at the front of the 2N7000 (the flat-faced side), the
    three pins are, from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 6-2](chapter6.xhtml#fig6-2) shows the schematic symbol for the 2N7000
    MOSFET.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR A 2N7000 MOSFET](../images/fig6-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: The schematic symbol
    for a 2N7000 MOSFET</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Operating a MOSFET is easy. When you apply a small current to the gate pin,
    a large current can flow in through the drain pin and out through the source pin.
    You can also use PWM with a MOSFET, allowing various controls of lights, motors,
    and more. Your 2N7000 MOSFET can handle up to 60 V DC at 200 mA continuously,
    or 500 mA in bursts. When choosing a MOSFET for other projects, be sure to check
    the voltage and current maximums against the signal you want to switch.
  prefs: []
  type: TYPE_NORMAL
- en: You can use larger MOSFETs to control larger currents, such as the IRF520 shown
    in [Figure 6-3](chapter6.xhtml#fig6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A THROUGH-HOLE PACKAGE IRF520 N-MOSFET](../images/fig6-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: An IRF520 N-MOSFET</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using MOSFETS, be sure to check the datasheet for the pinouts, as they
    vary between units. You can find larger MOSFETs in breakout-board form for convenient
    prototyping. [Figure 6-4](chapter6.xhtml#fig6-4) shows two examples: on the left
    is the N-MOSFET module from Freetronics, and on the right is an IRF520 breakout
    from PMD Way (part 759300).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF TWO N-MOSFET BREAKOUT BOARDS, ONE WITH A SURFACE-MOUNT MOSFET
    AND ONE WITH A THROUGH-HOLE MOSFET AND TERMINAL BLOCKS](../images/fig6-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: Two example MOSFET
    breakout boards</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use the 2N7000 to control the power supply of your Arduino.
    You’ll also connect a 10 kΩ resistor between the gate and the source pins to keep
    the gate switched off when a current is not applied to it, stopping the MOSFET
    from turning slightly on or off at random.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the 555 Timer
    IC in Bistable Mode</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create an on/off switch, you can harness the 555 timer IC (originally used
    in [Chapter 4](chapter4.xhtml)) in *bistable mode*, configuring the circuit to
    use two buttons to toggle the output pin HIGH or LOW. The output will then be
    used to control the MOSFET, which will be used to switch power going to the Arduino
    on and off.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-5](chapter6.xhtml#fig6-5) shows the bistable 555 circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A 555 TIMER IC IN BISTABLE MODE SCHEMATIC](../images/fig6-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The schematic for
    a 555 timer IC in bistable mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Pulling pin 2 (the trigger pin) to GND with SW[1] will turn on the output, while
    pulling pin 4 (the reset pin) to GND with SW[2] turns off the output. That’s all
    you need for a soft on/off switch! The circuit can operate on anything between
    5 V and 12 V DC. Build it yourself and test it, perhaps using an LED and 1 kΩ
    resistor on the output as an indicator.
  prefs: []
  type: TYPE_NORMAL
- en: For the projects in this chapter, however, you need to switch the power to an
    entire Arduino. In the following project, instead of using the output pin as a
    power supply, you’ll switch the 2N7000 N-MOSFET on and off with the bistable circuit,
    allowing you to control more current.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #19: Creating a Soft On/Off
    Switch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create a soft on/off switch for your Arduino. You can
    use a power supply of between 9 and 12 V DC to operate the 555; the Arduino will
    regulate the voltage to its required 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build this circuit using a solderless breadboard for a more temporary
    experiment or using a custom PCB created with the downloadable project files if
    you’d like a more permanent version. You’ll use the parts listed here for the
    remaining projects in this chapter as well:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 9 to 12 V DC, 1A power supply, wall wart, or plugback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One solderless breadboard or Project #19 PCB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 10 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 2N7000 N-MOSFET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 555 timer IC (and 8-pin IC socket if using a PCB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two tactile buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 × 40 2.54 mm inline header pins (if using a PCB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCB-mount DC socket (if using a PCB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re using a power supply with a DC plug, such as a wall wart, you may
    want to use a DC socket breakout such as PMD Way part 51201299 to avoid having
    to cut the plug off the end of the power lead, as shown in [Figure 6-6](chapter6.xhtml#fig6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A DC SOCKET BREAKOUT BOARD](../images/fig6-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: A DC socket breakout</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 6-7](chapter6.xhtml#fig6-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #19](../images/fig6-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: The schematic for
    Project #19</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a solderless breadboard, the DC socket is just a way of getting
    the required 9 to 12 V DC to the circuit. The Vin and GND labels at the top right
    of the schematic are connections to the Arduino’s Vin and GND pins, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the PCB, shown in [Figure 6-8](chapter6.xhtml#fig6-8), assembly
    is straightforward. Start with the resistors first, then the buttons, and then
    the IC socket, DC socket, and inline header pins. (There are a few extra connections
    not listed for this project, which you’ll use in Project #20.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN UNPOPULATED PCB FOR PROJECT #19](../images/fig6-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: The PCB for Project
    #19</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once assembled, your PCB should resemble that shown in [Figure 6-9](chapter6.xhtml#fig6-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN ASSEMBLED PCB FOR PROJECT #19 WITH ALL COMPONENTS FITTED](../images/fig6-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: The completed PCB
    for Project #19</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the Arduino to the PCB and then connect the external power of between
    6 and 12 V DC. You can then simply turn the Arduino and off with switches SW[1]
    and SW[2], respectively. The Arduino’s power-on LED will tell you at a glance
    whether the Arduino is on or off.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, when you press SW[2], the 555’s output should go HIGH.
    In this circuit, current flows to the gate (G) pin of the N-MOSFET, which then
    turns on the MOSFET, which then allows current to flow through the drain (D) pin
    to the source (S) pin. (Even if the Arduino is switched off, the circuit itself
    will draw around 5 mA of current at 9 V DC.) When the MOSFET is on, current can
    flow from the external power supply into the Arduino via the Vin pin, out via
    its GND pin, through the MOSFET, and finally to GND, completing the power circuit.
    When you press SW[1], the 555’s output goes LOW and the MOSFET is switched off.
    This means no current can flow through the Arduino, turning it off as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a solderless breadboard, keep the circuit together for the rest
    of the chapter. You can also use this circuit with other devices if they meet
    the same power requirements. For now, let’s use this circuit to give the Arduino
    the ability to turn itself off.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #20: Powering Off the Arduino
    Automatically</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an extension to the soft on/off circuit used in Project #19, you can have
    your Arduino turn itself off by pulling pin 4 of the 555 to LOW (as you did with
    SW[1] in the previous project). This is useful for creating applications you don’t
    want to run continuously, from simple games to more complex data-logging projects
    that need to write data only when an event occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the Project #19 circuit for this purpose, first connect digital output
    pin D12 to the junction of 555 pin 4 and resistor R[1] to become the Off Signal
    connection if using the solderless breadboard, as shown in [Figure 6-10](chapter6.xhtml#fig6-10),
    or to the pin on the PCB labeled A OFF.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #20](../images/fig6-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-10: The Project #20
    circuit with Arduino self-off contact</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the Vin and GND as well. Turn on the Arduino (which should light up
    the onboard power LED), and the D13 LED should also turn on. After five seconds
    the D13 LED should turn off; then, a second later, the Arduino should turn itself
    off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first ensures D12 is HIGH in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>. Next, a simple custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp>
    ❶ drops D12 to LOW, triggering the 555 to turn off the MOSFET and thus turn off
    the power to the Arduino. The sketch turns the D13 LED on ❷ and off ❸ as an example
    of activity; then the Arduino turns itself off ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Activating an Arduino from an External
    Device</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve learned how an Arduino can shut itself off. I’ll now explain
    how to program an external device or sensor to activate power to an Arduino, which
    completes a task and then powers itself off, ready for the next event.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Normally Open Contact
    Devices</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The switch used in Projects #18 and #19 closes the circuit between 555 pin
    2 and GND. This means you can replace the switch with (or use in parallel with)
    something that has normally open (NO) contacts—in other words, a device that closes
    a circuit in the same way a press-button or switch does. This could be anything
    such as a simple doorbell button, a pressure mat that acts as a switch when walked
    on, a passive infrared (PIR) motion sensor that detects movement with relay output
    contacts, a normally open reed switch, a door magnet that can detect the opening
    of a door, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Any device that can close the two points in the circuit will activate your Arduino.
    Simply connect the two wires from the device to 555 pin 2 and GND, respectively,
    as shown in [Figure 6-11](chapter6.xhtml#fig6-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR A SOFT ON/OFF POWER CIRCUIT WITH EXTERNAL TRIGGER CONNECTIONS](../images/fig6-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-11: The schematic
    for a soft on/off circuit with external trigger connections</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two contacts in question are shown as ON_SIGNAL points in the schematic.
    If you’re using the project PCB for this chapter, these are the ON+ and ON− pins.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Output Logic Devices</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may want to have your Arduino turned on by devices that give out an electrical
    signal when they’re activated, such as a logic-level 5 V output. These devices
    include some passive infrared (PIR) motion detectors, thermostats, some industrial
    programmable logic controller (PLC) device outputs, and more. However, such devices
    require a little more circuitry to bridge the gap for activation, as their output
    signal isn’t the same as the normally open method described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of these sorts of devices, you’ll use their logic output to
    switch another 2N7000 MOSFET to bridge the gap and act as the On switch for you.
    The devices’ output voltage must be high enough to turn on the MOSFET, so be sure
    to check this with the device supplier or datasheet before getting started. The
    MOSFET you’ll use in the next project requires 3 to 5 V DC to activate.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-12](chapter6.xhtml#fig6-12) shows an example circuit, with the requisite
    additional MOSFET and inputs on the left side. The TRIGGER point is connected
    to the device’s output, and TR_GND is connected to the device’s negative or GND
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR SOFT ON/OFF POWER CIRCUIT WITH LOGIC LEVEL TRIGGER CONNECTIONS](../images/fig6-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-12: The soft on/off
    schematic with logic level trigger</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now before moving onto the next project, I’ll show you an easier way to use
    DS1307 and DS3231 real-time clock ICs by installing a useful Arduino library.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The DS3231 Real-Time Clock Library</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next project uses a DS1307 or DS3231 real-time clock IC to keep time for
    a data-logging project. To simplify this, you’ll now learn how to use the matching
    DS3231 RTC library to save coding effort and space. This library works similarly
    to that for the DS1307.
  prefs: []
  type: TYPE_NORMAL
- en: First, download the library code ZIP file from [*https://<wbr>github<wbr>.com<wbr>/NorthernWidget<wbr>/DS3231*](https://github.com/NorthernWidget/DS3231).
    Open the Arduino IDE and select **Sketch** ![](../images/arr.png) **Include Library**
    ![](../images/arr.png) **Add .ZIP library**. Navigate to the downloaded file and
    then click **OK** to install the library. You can check whether the library has
    installed by selecting **File** ![](../images/arr.png) **Examples** in the IDE;
    a new DS3231 option should be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the sketch from [Listing 6-1](#LiT-6-1) to test the library and the basic
    functions to set and retrieve time and date information, but don’t upload it yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Testing the DS3231
    RTC library</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch first includes the I²C and RTC libraries and then creates an instance
    of the real-time clock to reference ❶. It then declares the required variables
    to hold the time and data information ❷. These include three Boolean variables,
    which are left as false by default, as you’re using 24-hour time.
  prefs: []
  type: TYPE_NORMAL
- en: To set the time, the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp>
    contains the functions to set all the time and date parameters. The variables
    declared earlier are placed in each matching function. This function needs to
    be called only once ❸, as you’ll initially set the time and date and then comment
    out the function before reuploading the sketch. Otherwise, the clock will reset
    to the value of the variables ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the time, the sketch uses a series of functions that begin with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RTC</samp>, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RTC.getdate()</samp>,
    which return their matching data. For a natural-looking display of the minutes
    and seconds, the sketch shows a 0 before the values for minutes under 10 ❹ and
    seconds under 10 ❺.
  prefs: []
  type: TYPE_NORMAL
- en: To change the time and date values to match your own time zone, enter your own
    values for time and date ❷, then uncomment the function <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp>❸,
    and finally upload the sketch. Now re-comment the <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp>
    function and save and re-upload the sketch. Once completed, open the Serial Monitor
    at 9,600 bps, and you should see the date and time being updated every second.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s combine these methods of triggering power to the Arduino and logging the
    events in a final project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #21: Building an Event Logger</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, imagine that someone needs to prove their arrival at a certain
    place on a regular basis. This might be a child arriving at school or activities,
    a security guard checking into work for the night, or an employee who must open
    a store at a particular time in the morning. To create a device to record the
    time and date of these events, this project uses a soft on/off circuit with an
    Arduino and a DS1307 or DS3231 real-time clock IC and SD card socket for logging
    the data to memory card. The trigger will be a simple button wired a distance
    away from the Arduino, like that included with a wired doorbell.
  prefs: []
  type: TYPE_NORMAL
- en: As an experienced Arduino user, you might build a circuit like the one in this
    project with slightly different products than those used here. For example, you
    could build a similar circuit with either an SD card module or an SD card shield
    (such as PMD Way part 668046, shown in [Figure 6-13](chapter6.xhtml#fig6-13)).
    You can use the framework you learn in this project for any situation where you
    want to trigger your Arduino to do something just once and then switch off until
    the next event.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN SD MEMORY CARD AND REAL-TIME CLOCK SHIELD FOR ARDUINO](../images/fig6-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-13: An SD and RTC
    shield for Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 9 to 12 V DC, 1 A power supply, wall wart, or plugpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The completed PCB or hardware from Project #20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DS1307 or DS3231 real-time clock module and SD or microSD card module, or
    SD card and RTC shield for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD or SD memory card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A remote button and suitable twin-core wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 6-14](chapter6.xhtml#fig6-14). If you’re
    using the solderless breadboard, you can omit the tactile switches if you don’t
    want local control.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #21](../images/fig6-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-14: The schematic
    for Project #21</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to format your memory card correctly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re unfamiliar with the use of the SD card or real-time clock module,
    review Chapters 7 and 20 of* Arduino Workshop*, 2nd edition.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve assembled the hardware, set the current time and date in the Project
    #21 sketch using the function <samp class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. To preserve
    the time and date in the real-time clock, upload the sketch and then comment out
    the line and re-upload the sketch, as you did in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The sketch is a combination of basic real-time clock and SD-card-writing functions,
    along with self-turn-off once the event has been recorded to the memory card.
    It first includes the required libraries and then sets the RTC I²C bus address
    and the pin number that triggers the 555 timer to turn the circuit off ❶. Next,
    it sets the required variables for the date and time, along with the function
    to write the data ❷.
  prefs: []
  type: TYPE_NORMAL
- en: When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp>
    function sets the digital pin connected to the 555 to LOW, turning off the circuit.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">logEvent()</samp> function opens
    the text file on the SD card, retrieves the time and date from the real-time clock,
    and writes it in a neat line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> function initializes the real-time clock and allows for setting
    the time and date. It also initializes the digital pins required for triggering
    the external circuit and using the SD card and checks that the SD card is ready.
  prefs: []
  type: TYPE_NORMAL
- en: The final loop ❸ operates when the external device circuit triggers the Arduino
    and turns it on. The <samp class="SANS_TheSansMonoCd_W5Regular_11">logEvent()</samp>
    function logs the event, writing the time and date to the SD card. There’s a short
    delay to ensure the data file has closed, after which <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp>
    turns the Arduino off.
  prefs: []
  type: TYPE_NORMAL
- en: To review the data logged by the project, disconnect the power from the Arduino
    and insert the SD card into your computer. Open the *DATA.TXT* file to see the
    events listed in order.
  prefs: []
  type: TYPE_NORMAL
- en: The project has recorded a new line of text containing the date and time for
    each event.
  prefs: []
  type: TYPE_NORMAL
- en: When operating at 9 V DC, this project draws around 5 mA of current when off
    and peaks at 70 mA during operation. If you powered it with six AA cells for portable
    use and had one or two events an hour, the project could easily run for more than
    seven days.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter showed you how to add professional power control to your projects,
    reducing power consumption by allowing external actions to turn the power on and
    having your Arduino turn itself off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter demonstrates another advanced way to turn projects on and
    off: safely controlling mains AC current with a wireless remote-controlled outlet.'
  prefs: []
  type: TYPE_NORMAL
