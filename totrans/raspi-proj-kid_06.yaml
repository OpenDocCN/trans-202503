- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MANIPULATING MINECRAFT
  prefs: []
  type: TYPE_NORMAL
- en: IN THIS CHAPTER, YOU’LL WRITE PYTHON PROGRAMS TO HACK INTO THE MINECRAFT ENVIRONMENT
    SO YOU CAN DO SOME COOL THINGS. YOU’LL SEND MESSAGES TO THE MINECRAFT WORLD AND
    TURN ITS GRASS INTO TRAMPOLINES. THEN YOU’LL WRITE YOUR FIRST MINECRAFT GAME,
    *SAND DROP*, WHERE PLAYERS DODGE FALLING BLOCKS OF SAND. USING YOUR GLUE GUN LED
    LIGHT THAT YOU BUILT IN [CHAPTER 3](ch03.xhtml#ch03), YOU’LL ADD REAL-WORLD HARDWARE
    THAT YOU’LL CONTROL FROM MINECRAFT. COMBINING THE POWER OF MINECRAFT WITH THE
    PI CAMERA, YOU’LL CREATE A HIDDEN CAMERA YOU CONTROL WITH TOWERS OF GOLD, BRICK,
    AND MELONS!
  prefs: []
  type: TYPE_NORMAL
- en: WHAT YOU’LL NEED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For most of the projects in this chapter, you’ll be coding in Python and Minecraft,
    so you don’t need many items beyond your Pi and a computer. Here are the few additional
    items you need:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your glue gun LED light or a new LED with a 220–330 ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pi Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MINECRAFT ON THE RASPBERRY PI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Chances are you’re already familiar with Minecraft, but just in case you’re
    not, here’s a description: Minecraft is a game where you mine, craft, and create
    all kinds of weird and wonderful objects within a 3D world that consists of various
    terrains, habitats, and materials. It’s often described as a computer-game version
    of LEGO. The world is free roaming: you, as the main character Steve or Alex,
    can travel wherever you want to, see what you want to, and basically do what you
    want to.'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi operating system comes preinstalled with a Minecraft Pi Edition.
    This is a stripped-down version of the game that lets you hack the Minecraft world
    through a range of programming languages, including Python, which is what we’ll
    use here.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Minecraft
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Boot up your Raspberry Pi and click the Pi symbol at the top left of the screen.
    A drop-down menu appears. Scroll down to and click the **Games** tab. The option
    to open Minecraft appears. Click this option to load the Minecraft Pi Edition,
    as shown in [Figure 6-1](ch06.xhtml#ch06fig01). Loading will take between a few
    seconds and a full minute, depending on which Pi model you’re using. Minecraft
    loads fastest on the Pi 4 model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-1** Loading Minecraft Pi Edition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Minecraft on the Pi is the same as using it on your computer. The Pi
    uses a classic keyboard-control layout to move your player around the world. But
    the Pi Edition has something extra: it allows you to *fly*, meaning you can quickly
    travel to other locations. You do this by pressing the spacebar twice, using the
    arrow keys for direction, and using your mouse to control the player’s view (as
    usual).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other control you’ll use in these hacks is the TAB key. It releases the
    mouse from the Minecraft controls so you can use it to click elsewhere. This means
    you can select the Python programming interface and either write new code or select
    your program to run. Then you can launch Minecraft and double-click either the
    left or right mouse button in the middle of the world: the mouse movement will
    control the player’s view again.'
  prefs: []
  type: TYPE_NORMAL
- en: This table shows the keys for the main Minecraft controls.
  prefs: []
  type: TYPE_NORMAL
- en: '| **KEY** | **ACTION** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| W | Move forward |'
  prefs: []
  type: TYPE_TB
- en: '| A | Move left |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move backward |'
  prefs: []
  type: TYPE_TB
- en: '| D | Move right |'
  prefs: []
  type: TYPE_TB
- en: '| E | Load inventory |'
  prefs: []
  type: TYPE_TB
- en: '| Spacebar | Jump |'
  prefs: []
  type: TYPE_TB
- en: '| Double spacebar | Fly/fall |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT | Float downward |'
  prefs: []
  type: TYPE_TB
- en: '| ESC | Pause/Game menu |'
  prefs: []
  type: TYPE_TB
- en: '| TAB | Release mouse cursor |'
  prefs: []
  type: TYPE_TB
- en: 'Finding Yourself: Using the X-, Y-, and Z- Coordinates'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the Pi Edition of the Minecraft world is not as large as the full game,
    it’s still easy to get lost. To locate the player in the world, the game uses
    x-, y-, and z- coordinates, as shown in [Figure 6-2](ch06.xhtml#ch06fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-2** The x-, y-, and z- coordinates are located at the top left of
    the window.'
  prefs: []
  type: TYPE_NORMAL
- en: These three values are an essential part of the game. They ensure that the things
    you make happen in your program happen at your player’s location. You’ll use these
    coordinates in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate values display at the top left of the screen. All values are
    measured from the middle of the game world. So, if you’re at the x, y, and z values
    0.0, 0.0, 0.0, you’re in the exact center of the world. A negative, or minus,
    x value means the player is to the left of the world’s midpoint; a negative y
    value means the player is below the midpoint; and a negative z value means the
    player is behind the midpoint. For example, 0.0, -45.7, 0.0 means the player is
    45.7 blocks lower than the middle of the world. But the worlds are randomly generated,
    so the size of the worlds varies. This table lists the maximum and minimum values
    of these coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '| **COORDINATE** | **INDICATES** | **MINIMUM VALUE** | **MAXIMUM VALUE** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x | Left and right movement | -255 | +255 |'
  prefs: []
  type: TYPE_TB
- en: '| y | Up and down movement | -128 | +128 |'
  prefs: []
  type: TYPE_TB
- en: '| z | Forward and backward movement | -255 | +255 |'
  prefs: []
  type: TYPE_TB
- en: Hacking Minecraft
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start hacking Minecraft! The Raspberry Pi operating system lets you connect
    directly to Minecraft by using Python code. You can develop and write your programs,
    open and start a Minecraft game, run your code, and then return to the Minecraft
    world to see the effects in action.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re running your hacking programs, unless you’re using a Raspberry Pi
    4, don’t run Minecraft in full-screen mode; instead, keep the window at its default
    size. Full-screen mode prevents you from viewing your code or any program errors
    and puts a huge demand on the graphics card, creating lag in the game. If you
    are using the Pi 4, feel free to use full-screen mode! Also, because of a bug
    in the Minecraft program, full-screen mode prevents you from accessing the last
    line of items in your inventory.
  prefs: []
  type: TYPE_NORMAL
- en: POSTING A MESSAGE TO CHAT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with a simple program that will post a message to the Minecraft
    world, as shown in [Figure 6-3](ch06.xhtml#ch06fig03). This hack is only three
    lines and will teach you how the interaction between Python and Minecraft works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-3** Displaying a chat message in Minecraft'
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Chat Messenger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To begin your first hack, open Python and start a new file. Then enter the program
    code in [Listing 6-1](ch06.xhtml#ch06ex01). Remember that you can download the
    program from *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    and either use it to compare against your program or just run the *first_program.py*
    file from the download.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-1** The Minecraft messaging program'
  prefs: []
  type: TYPE_NORMAL
- en: First, import the `mcpi` library, which enables you to use Python to control
    Minecraft. This library tells the program to open and run in Minecraft. To trigger
    events within the Minecraft world, use the library’s `minecraft.Minecraft.create()`
    function to create a connection from Python to Minecraft. Store that function
    in the variable `mc` so you don’t have to type it each time. Then use the `postToChat()`
    function, after your newly created `mc` variable, to display a message in the
    Minecraft game. You can change the message inside the quotes to anything you want
    to display.
  prefs: []
  type: TYPE_NORMAL
- en: Running Your Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the program, save the file and then open Minecraft. Start a game and
    wait for the world to load. Once it’s loaded, press TAB to release the mouse from
    the game so you can use it to find your hack. Next, select your Python program
    (open it if you closed it), and execute it by pressing **F5**. Your program will
    start running in Minecraft automatically. Return to the Minecraft game by selecting
    it with either one of the mouse buttons. Your custom message should appear. Congratulations!
    You’ve made your first Minecraft hack! Now let’s do something a bit more adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: TRAMPOLINE GRASS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This trampoline project walks you through creating your first proper interactive
    program. Each time you step onto a block of grass, you’ll spring into the air
    just like you’re on a trampoline, as shown in [Figure 6-4](ch06.xhtml#ch06fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-4** Turn all grass into a trampoline'
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Trampoline Grass
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Begin the hack by opening Python and starting a new file. Enter the program
    code in [Listing 6-2](ch06.xhtml#ch06ex02). Remember that you can download the
    program from *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    and either use it to compare against your program or just run the *trampoline.py*
    file from the download.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-2** The trampoline grass program'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `minecraft` module from the `mcpi` library again so you can use Python
    to control Minecraft. Save the `minecraft.Minecraft.create()` connection into
    a variable named `mc` again.
  prefs: []
  type: TYPE_NORMAL
- en: Then create a `while` loop ❶, which, as you might remember from [Chapter 2](ch02.xhtml#ch02),
    makes sure the program keeps running. Also, remember to indent the code after
    the `while` line four spaces because it belongs in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop, you find and return the current position of your player within
    the Minecraft environment ❷ and the type of block the player is standing on ❸.
    This is important because only the grass is springy, not any other ground. This
    position is returned as an ID number, and you store it in a variable called `b`.
    You subtract 1 from the y position of the block, which is the up-and-down coordinate.
    The reason is that you want to affect the block *below* the player, not the actual
    player.
  prefs: []
  type: TYPE_NORMAL
- en: Use a conditional to check the kind of ground you’re standing on ❹. Each type
    of block has an ID value, and the value for a grass block is `2`. So you check
    whether the block ID value stored in variable `b` is equal to `2` and run the
    code to make the grass bouncy only if it has that value.
  prefs: []
  type: TYPE_NORMAL
- en: When the conditional finds that the player *is* indeed standing on grass, you
    use `setPos()` to send the player up in the air to a new y position ❺. You want
    to send the player up, not across, so you keep the same x and z positions but
    add 20 to the y value. The player should shoot into the air.
  prefs: []
  type: TYPE_NORMAL
- en: Running Your Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As before, save your program and make sure Minecraft is open. Resume your game
    and wait for the world to load. Press TAB to release the mouse from the game,
    and then select your Python program. Execute it by pressing **F5**, and return
    to the Minecraft window by clicking it with the mouse. Walk around and watch out
    for that grass!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re getting any errors, check that you’ve followed the same indentation
    spacing as in [Listing 6-2](ch06.xhtml#ch06ex02). Also, make sure you included
    the colon after the `while True` and `if` lines.
  prefs: []
  type: TYPE_NORMAL
- en: Taking It Further
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can alter your program to make the player go higher, lower, or even underground—a
    kind of antigravity trampoline—by changing the `p.y` number in `mc.player.setPos()`.
    Try a few numbers to see the effect. As another challenge, try changing the trigger
    block ID so the water triggers the trampoline instead. Check out the IDs at *[https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/](https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/)*.
  prefs: []
  type: TYPE_NORMAL
- en: THE SAND DROP GAME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll make your first game, called *Sand Drop*. In this simple game, blocks
    of sand drop from the sky, and the player has to dodge them. In the Minecraft
    environment, the sand block is automatically affected by gravity: if you set a
    sand block above the player, it will fall downward, landing on the player if they
    don’t move in time. If one of the blocks hits the player, it’s *game over*.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll program the sand blocks to follow you as you move around the world ([Figure
    6-5](ch06.xhtml#ch06fig05)), so don’t think you can run away. The sand is out
    to get you!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-5** The *Sand Drop* game'
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Sand Drop Game
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Begin the hack by opening Python and starting a new file. Enter the program
    code in [Listing 6-3](ch06.xhtml#ch06ex03). Remember that you can download the
    program from *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    and either use it to compare against your program or just run the *sand_drop.py*
    file from the download.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-3** The *Sand Drop* game program'
  prefs: []
  type: TYPE_NORMAL
- en: As with previous hacks, begin by importing the `minecraft` library and storing
    the event trigger in the `mc` variable to keep it simple and save you from having
    to type `minecraft.Minecraft.create()` each time.
  prefs: []
  type: TYPE_NORMAL
- en: Also import the `sleep()` function from the `time` module, which adds a small
    delay between each block dropping. This gives you some time to dodge each block.
    Add a short time delay after the game begins and before the blocks start falling
    ❶ to give you time to return to the game from the Python window. The blocks will
    follow you around, so you need to get the player’s x, y, and z position data.
    Use a `while` loop to check whether a sand block has hit you ❷. The loop does
    this by checking the block’s ID at the same position as the player. If it’s not
    block ID 13—the sand block—you haven’t been hit. Yet.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t been hit, the next line runs to place and drop a new sand block.
    Note that the block’s y position is +25, meaning that the block is placed 25 blocks
    above you before it drops. Then you wait for 1 second before running the next
    line of code, which takes the player’s new x, y, and z position reading in case
    you’ve moved. If a sand block does hit you, a message is posted to the Minecraft
    world, and it’s game over for you ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Running Your Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As before, save your program as *sand_drop.py*, make sure Minecraft is open,
    and start or resume a game. Release the mouse by pressing TAB, and select and
    execute your Python program. Return to your Minecraft game, and get ready to dodge
    that falling sand.
  prefs: []
  type: TYPE_NORMAL
- en: Taking It Further
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to test your reflexes, try changing the height of the block to make
    the game more challenging. If the blocks are closer to the player when they start
    falling, you’ll have less time to react. You could also reduce the delay or `sleep()`
    time between each block dropping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different blocks in Minecraft have different physics. Test the world by changing
    the block from sand to another type. This will alter how the block falls: it might
    be slower, it might be faster, or it might land in a different location, affecting
    how you play the game. Try the blocks in the following table for starters.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **BLOCK TYPE** | **BLOCK ID** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Water | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| Lava | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Gravel | 13 |'
  prefs: []
  type: TYPE_TB
- en: A list of all the block IDs is at *[https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/](https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/)*.
  prefs: []
  type: TYPE_NORMAL
- en: MINECRAFT-CONTROLLED LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you’ll write a program that lets you use Minecraft to control
    the glue gun LED light that you made in [Chapter 3](ch03.xhtml#ch03). Whenever
    you touch water in the Minecraft world, the light in the real world will turn
    on. When you leave the water, the light will turn off.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Minecraft LED
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using either your custom glue gun light from [Chapter 3](ch03.xhtml#ch03) or
    a new LED, attach one male-to-female jumper wire to each of the LED legs. Attach
    the *longer* positive leg to GPIO pin 18: this is physical pin 12 on the Pi. Connect
    the other jumper wire to any one of the ground pins: choose from physical number
    9, 14, 20, 30, 34, or 39\. [Figure 6-6](ch06.xhtml#ch06fig06) shows the wiring
    diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-6** Wiring up the LED'
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Minecraft LED
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open a new Python file and enter the code in [Listing 6-4](ch06.xhtml#ch06ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-4** The Minecraft LED program'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by importing the `LED` class from the `gpiozero` library ❶, as you did
    in [Chapter 3](ch03.xhtml#ch03). Also import the `time` module, so you can add
    a delay if required, and the `minecraft` library. Again, set the variable `mc`
    to hold the `minecraft` library code ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Tell the Pi that the LED is attached to pin 18 ❸ and create a `while` loop ❹
    so the program keeps running the next few indented lines. Then get the player’s
    x, y, and z position data. Use the `getBlock()` function to find out the ID of
    the block you’re standing on and store this ID in a variable called `block_id`
    ❺. Recall that you can check the IDs online at *[https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/](https://www.raspberrypi-spy.co.uk/2014/09/raspberry-pi-minecraft-block-id-number-reference/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the block ID is equal to 9, the ID for water ❻. If it is, the
    LED will turn on. If you aren’t standing on water, the LED will be off.
  prefs: []
  type: TYPE_NORMAL
- en: Running Your Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Save your program, open Minecraft, and press TAB to release the mouse. Select
    your program and execute it by pressing **F5**. Return to your Minecraft game
    and find some water! When the character stands in water, the LED should light
    up, as shown in [Figure 6-7](ch06.xhtml#ch06fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-7** The LED turns on when the character touches water.'
  prefs: []
  type: TYPE_NORMAL
- en: CAMERA SURVEILLANCE MINECRAFT TOWERS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this hack, you’ll set up a surveillance camera that you’ll control from Minecraft.
    To anyone else around, it will appear that you’re simply playing Minecraft. But,
    really, you’ll be using three towers in the game to control the camera. Tower
    1 is made from gold and triggers the camera to take a picture. Tower 2 is made
    from brick and starts capturing video. Tower 3 is made from melons—yes, melons—and
    ends the video recording. To trigger each tower, you’ll hit it with a sword. You
    can then view your photos and watch the video or take another video or photo.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start, set up your Pi Camera as you did in [Chapter 4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: Building the Three Trigger Towers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s make the secret trigger towers. Load a new Minecraft world, and find a
    suitable flat space to build your three towers. Select the gold block from the
    inventory, and build a small tower of three or four blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the same process for the two other towers, except use the brick and melon
    blocks. Build the brick and melon towers close together, because when you hit
    the brick tower, the video won’t stop recording until you hit the melon tower!
    [Figure 6-8](ch06.xhtml#ch06fig08) shows the tower placement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-8** The camera control towers'
  prefs: []
  type: TYPE_NORMAL
- en: You can actually use any block you want, as long as you amend the program code
    to include the relevant block name. But make sure each tower is made of only one
    block type.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a way to set off the towers, so equip your player with the sword
    from the inventory by pressing **E** and selecting the sword. When you click the
    left mouse button, you remove blocks, and clicking the right mouse button hits
    blocks. Hitting a block doesn’t destroy it; instead, it returns block data, which
    you’ll use in this hack to control the Pi Camera functions. You can try out hitting
    the towers first before you start your program code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Camera Towers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open a new Python file and enter the code in [Listing 6-5](ch06.xhtml#ch06ex05).
    This code sets up the camera and instruction messages for the player. You’ll add
    the rest of the code shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-5** Setting up the camera and player instructions'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by importing the `PiCamera` ❶ class to control the camera. Then create
    a variable called `camera` to store the `PiCamera()` command so you don’t have
    to type it each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the resolution of the camera image to 100 ❷. This is the *frame rate*:
    a high `framerate` value produces a smooth video, and a lower `framerate` value
    makes the video appear jerkier—but it’s a bit of a trade-off. A frame rate of
    100 is good, because if you make it too high, the Raspberry Pi will quickly run
    out of memory and struggle to take the image. You can change the `framerate` value
    later if you want to alter the video quality.'
  prefs: []
  type: TYPE_NORMAL
- en: Then import the usual Minecraft libraries, as well as the `block` library ❸,
    which lets you identify and refer to blocks by their name instead of their ID
    number. For example, you can specify gold, grass, sand, and brick by name. Finally,
    import the `time` module and the `datetime` library that will add a timestamp
    to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Add a line to make a message appear in Minecraft that shows the title of your
    program ❹. Add a short delay to give the player time to read the message. Then
    post another message to inform the player of what action each block triggers;
    for example, gold takes a picture. Now let’s add the triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the Gold Tower
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now you’ll add the main section of the program, as shown in [Listing 6-6](ch06.xhtml#ch06ex06).
    This code checks which tower block has been hit and responds with the appropriate
    camera command. You’ll start with the gold tower and add the others in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you indent the lines of code exactly as shown: lines inside the `while`
    loop need to be indented four spaces. Then the lines inside the `for` loop that
    follows need to be indented another four spaces, and finally the lines inside
    the `if` statement need to be indented four more spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-6** Programming the gold tower'
  prefs: []
  type: TYPE_NORMAL
- en: First create a `while True` loop, which means the program is constantly checking
    whether you’ve hit one of the towers. If a tower has been hit, take a reading
    of the current time and store it in a variable called `current_time`. Then print
    a line to the screen showing the details of the block you hit. This includes the
    player’s x-, y-, and z- coordinates as well as the tower’s ID and block name.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to determine which type of tower was hit and which camera action
    to take. You do this with an `if` statement that checks whether the block that
    you just hit is a gold block. If it is, the word *PICTURE* prints to the screen.
    At the same time, the word *Smile!* prints in the Minecraft chat messages to remind
    the character to smile. Wait a second for the character to pose, and then trigger
    the camera to take a picture.
  prefs: []
  type: TYPE_NORMAL
- en: Store the picture that was taken on the desktop and assign it a filename of
    the current time, which you took earlier and stored in the `current_time` variable.
    Now the action for the gold tower is taken care of. Save your program as *camera_tower.py*,
    but keep it open to add more code.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the Brick Tower
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Add the code in [Listing 6-7](ch06.xhtml#ch06ex07) to your *camera_tower.py*
    program. This code checks whether the player has hit the brick block. If so, the
    camera starts a video recording.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-7** Programming the brick tower'
  prefs: []
  type: TYPE_NORMAL
- en: Add an `elif` statement to check whether the brick block has been hit ❶. This
    is like the `if` statement you added to check whether a gold tower had been hit.
    But the `elif` statement means *else if* and runs only if the tower hit wasn’t
    made of gold blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Post a message to the Minecraft screen to inform the player that the video is
    about to start recording ❷. Start a preview on the screen so you can see what’s
    being filmed, wait a second, and then trigger the camera to start filming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, save the file to your */home/pi* folder and name it *my_video.h264*
    ❸. The video will continue to record until the melon tower is hit or you stop
    the program by clicking the close button at the top-right corner of the IDLE window.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the Melon Tower or Hitting Nothing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last part of the program responds to the player hitting the melon tower,
    hitting any other block, or doing nothing. Add the code in [Listing 6-8](ch06.xhtml#ch06ex08)
    to the end of your *camera_tower.py* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**LISTING 6-8** Programming the melon tower'
  prefs: []
  type: TYPE_NORMAL
- en: Add another `elif` statement to check whether the block that was hit is a melon
    block. If it is, post a chat message to Minecraft informing the player that the
    video recording is about to stop, and stop the preview. Wait for 1 second and
    stop the recording.
  prefs: []
  type: TYPE_NORMAL
- en: Then add a last `else` statement to respond to the player doing something else
    other than hitting one of the three towers. If the player doesn’t hit one of the
    three trigger towers, use a `pass` statement. A `pass` statement tells the program
    to take no action except to return to the start of the `while` loop in [Listing
    6-6](ch06.xhtml#ch06ex06). The program then checks for the next block interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Running Your Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Save your program and run it. If you encounter any errors, be sure to double-check
    that the indentation levels are correct. You can load the *camera_tower.py* file
    from the downloads section at *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    and compare your program against it (or just use mine!) if you can’t get yours
    to work. Also, make sure you’ve used uppercase and lowercase letters in the same
    places that they’re used in the program code. Remember to ensure that Minecraft
    is open and running too.
  prefs: []
  type: TYPE_NORMAL
- en: After you have taken some photos and videos, minimize the Minecraft windows
    by clicking the middle icon at the top right of the window. You should see the
    photo files on the Pi desktop. Simply click and open to view each one. To view
    your video, you need to execute it from the terminal. Click the terminal icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, enter this line, but replace my_video with the name of your
    file if you gave it a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This line runs OMXPlayer, a video player specifically made for the Raspberry
    Pi. Press ENTER, and the video should play. To play it again, press the up arrow
    key. Don’t forget to share your photos and videos with your friends.
  prefs: []
  type: TYPE_NORMAL
- en: WRAPPING UP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an extra challenge, try changing the towers to other blocks, like wool, sand,
    or even obsidian. You could also build additional towers to add further functionality
    to your program. Perhaps have a block that adds a filter to your photo.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve enjoyed these Minecraft hacks and want more, be sure to check out
    *Learn to Program with Minecraft* by Craig Richardson (No Starch Press, 2015)
    and *Coding with Minecraft* by Al Sweigart (No Starch Press, 2018).
  prefs: []
  type: TYPE_NORMAL
