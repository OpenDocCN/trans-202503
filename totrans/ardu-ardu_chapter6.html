<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch6">
<span class="CN"><span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ADDING PROFESSIONAL POWER CONTROL</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Instead of controlling power to your Arduino with a switch or USB cable, you can use <i>soft power control</i>: turning power on and off with buttons or having your Arduino turn itself off via the sketch or external sensor. Soft power increases the professionalism of your projects. If you’re designing, say, a fancy hi-fi amplifier, a pair of on/off buttons looks far nicer than the type of on/off switch you’d find on industrial equipment.</p>
<p class="TX">This chapter introduces various methods of soft power control. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Control larger currents with MOSFETs</li>
<li class="BL">Use the 555 timer IC in bistable mode</li>
<li class="BL">Turn on Arduino circuits with external devices</li>
<li class="BL"><span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>Conserve power by building projects that turn on only when required</li>
<li class="BL">Use the DS3231 real-time clock (RTC) library for Arduino</li>
</ul>
<p class="TX">You’ll also create a soft on/off switch for your Arduino and build a low-power event logger.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-43"/><samp class="SANS_Futura_Std_Bold_B_11">Power the Arduino without a Physical Switch</samp></h2>
<p class="TNI">It’s common to supply power to Arduino projects with the USB socket, battery pack, or external AC adapter. Turning the project on and off in these cases means removing a cable or DC plug, which works well if you’re just experimenting or building something for your own use. However, soft power control allows you to control the power to your Arduino project by using buttons or signals from other devices or allowing an Arduino project to turn itself off completely. This doesn’t require a “hard” physical switch to connect or cut current flow.</p>
<p class="TX">Soft power control saves on hardware wear and tear, as there are no moving parts for power control, and makes interfaces simpler and easier to use. Turning power on and off with buttons or further automating device controls creates a better user experience.</p>
<p class="TX">This section further discusses two types of components that are required for these soft power control circuits: the MOSFET, used for switching current; and the 555 timer IC, in this case used as an interface between on and off signals in soft power control.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h2-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Operating MOSFETs</samp></h3>
<p class="TNI">MOSFETs allow you to switch large voltages and currents with a small signal, such as that from our Arduino’s digital output pins. They are available in various sizes, such as those shown in <a href="chapter6.xhtml#fig6-1">Figure 6-1</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF VARIOUS THROUGH-HOLE AND SURFACE-MOUNT MOSFETS" class="img4" id="fig6-1" src="../images/fig6-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Various MOSFETs</samp></p></figcaption>
</figure>
<p class="TX">The bottom left of <a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows the small 2N7000 N-MOSFET from <span class="Xref">Project #14 in <a href="chapter4.xhtml">Chapter 4</a></span>, which we’ll also use in this chapter. Looking at the front of the 2N7000 (the flat-faced side), the three pins are, from left to right:</p>
<ul class="ul">
<li class="BL">Source</li>
<li class="BL">Gate</li>
<li class="BL">Drain</li>
</ul>
<p class="TX"><a href="chapter6.xhtml#fig6-2">Figure 6-2</a> shows the schematic symbol for the 2N7000 MOSFET.<span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR A 2N7000 MOSFET" class="img4" id="fig6-2" src="../images/fig6-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: The schematic symbol for a 2N7000 MOSFET</samp></p></figcaption>
</figure>
<p class="TX">Operating a MOSFET is easy. When you apply a small current to the gate pin, a large current can flow in through the drain pin and out through the source pin. You can also use PWM with a MOSFET, allowing various controls of lights, motors, and more. Your 2N7000 MOSFET can handle up to 60 V DC at 200 mA continuously, or 500 mA in bursts. When choosing a MOSFET for other projects, be sure to check the voltage and current maximums against the signal you want to switch.</p>
<p class="TX">You can use larger MOSFETs to control larger currents, such as the IRF520 shown in <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A THROUGH-HOLE PACKAGE IRF520 N-MOSFET" class="img2" id="fig6-3" src="../images/fig6-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: An IRF520 N-MOSFET</samp></p></figcaption>
</figure>
<p class="TX">When using MOSFETS, be sure to check the datasheet for the pinouts, as they vary between units. You can find larger MOSFETs in breakout-board form for convenient prototyping. <a href="chapter6.xhtml#fig6-4">Figure 6-4</a> shows two examples: on the left is the N-MOSFET module from Freetronics, and on the right is an IRF520 breakout from PMD Way (part 759300).</p>
<figure class="IMG"><img alt="A PHOTO OF TWO N-MOSFET BREAKOUT BOARDS, ONE WITH A SURFACE-MOUNT MOSFET AND ONE WITH A THROUGH-HOLE MOSFET AND TERMINAL BLOCKS" class="img6" id="fig6-4" src="../images/fig6-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: Two example MOSFET breakout boards</samp></p></figcaption>
</figure>
<p class="TX">In this chapter, you’ll use the 2N7000 to control the power supply of your Arduino. You’ll also connect a 10 kΩ resistor between the gate and the source pins to keep the gate switched off when a current is not applied to it, stopping the MOSFET from turning slightly on or off at random.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h2-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the 555 Timer IC in Bistable Mode</samp></h3>
<p class="TNI">To create an on/off switch, you can harness the 555 timer IC (originally used in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>) in <i>bistable mode</i>, configuring the circuit to use two buttons to toggle the output pin HIGH or LOW. The output will then be used to control the MOSFET, which will be used to switch power going to the Arduino on and off.</p>
<p class="TX"><a href="chapter6.xhtml#fig6-5">Figure 6-5</a> shows the bistable 555 circuit.<span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A 555 TIMER IC IN BISTABLE MODE SCHEMATIC" class="img7" id="fig6-5" src="../images/fig6-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The schematic for a 555 timer IC in bistable mode</samp></p></figcaption>
</figure>
<p class="TX">Pulling pin 2 (the trigger pin) to GND with SW<sub>1</sub> will turn on the output, while pulling pin 4 (the reset pin) to GND with SW<sub>2</sub> turns off the output. That’s all you need for a soft on/off switch! The circuit can operate on anything between 5 V and 12 V DC. Build it yourself and test it, perhaps using an LED and 1 kΩ resistor on the output as an indicator.</p>
<p class="TX">For the projects in this chapter, however, you need to switch the power to an entire Arduino. In the following project, instead of using the output pin as a power supply, you’ll switch the 2N7000 N-MOSFET on and off with the bistable circuit, allowing you to control more current.</p>
<p class="HeadProject"><span id="h1-44"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #19: Creating a Soft On/Off Switch</samp></p>
<p class="TNI">In this project, you’ll create a soft on/off switch for your Arduino. You can use a power supply of between 9 and 12 V DC to operate the 555; the Arduino will regulate the voltage to its required 5 V.</p>
<p class="TX">You can build this circuit using a solderless breadboard for a more temporary experiment or using a custom PCB created with the downloadable project files if you’d like a more permanent version. You’ll use the parts listed here for the remaining projects in this chapter as well:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A 9 to 12 V DC, 1A power supply, wall wart, or plugback</li>
<li class="BL">One solderless breadboard or Project #19 PCB</li>
<li class="BL">Three 10 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">One 2N7000 N-MOSFET</li>
<li class="BL">A 555 timer IC (and 8-pin IC socket if using a PCB)</li>
<li class="BL">Two tactile buttons</li>
<li class="BL"><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>1 <span class="symbol">×</span> 40 2.54 mm inline header pins (if using a PCB)</li>
<li class="BL">A PCB-mount DC socket (if using a PCB)</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">If you’re using a power supply with a DC plug, such as a wall wart, you may want to use a DC socket breakout such as PMD Way part 51201299 to avoid having to cut the plug off the end of the power lead, as shown in <a href="chapter6.xhtml#fig6-6">Figure 6-6</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A DC SOCKET BREAKOUT BOARD" class="img4" id="fig6-6" src="../images/fig6-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: A DC socket breakout</samp></p></figcaption>
</figure>
<p class="TX">Assemble the circuit as shown in <a href="chapter6.xhtml#fig6-7">Figure 6-7</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #19" class="img8" id="fig6-7" src="../images/fig6-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: The schematic for Project #19</samp></p></figcaption>
</figure>
<p class="TX">If you are using a solderless breadboard, the DC socket is just a way of getting the required 9 to 12 V DC to the circuit. The Vin and GND labels at the top right of the schematic are connections to the Arduino’s Vin and GND pins, respectively.</p>
<p class="TX">If you are using the PCB, shown in <a href="chapter6.xhtml#fig6-8">Figure 6-8</a>, assembly is straightforward. Start with the resistors first, then the buttons, and then the IC socket, DC socket, and inline header pins. (There are a few extra connections not listed for this project, which you’ll use in Project #20.)<span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN UNPOPULATED PCB FOR PROJECT #19" class="img5" id="fig6-8" src="../images/fig6-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: The PCB for Project #19</samp></p></figcaption>
</figure>
<p class="TX">Once assembled, your PCB should resemble that shown in <a href="chapter6.xhtml#fig6-9">Figure 6-9</a>.</p>
<figure class="IMG"><img alt="AN ASSEMBLED PCB FOR PROJECT #19 WITH ALL COMPONENTS FITTED" class="img6" id="fig6-9" src="../images/fig6-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: The completed PCB for Project #19</samp></p></figcaption>
</figure>
<p class="TX">Connect the Arduino to the PCB and then connect the external power of between 6 and 12 V DC. You can then simply turn the Arduino and off with switches SW<sub>1</sub> and SW<sub>2</sub>, respectively. The Arduino’s power-on LED will tell you at a glance whether the Arduino is on or off.</p>
<p class="TX">As mentioned earlier, when you press SW<sub>2</sub>, the 555’s output should go HIGH. In this circuit, current flows to the gate (G) pin of the N-MOSFET, which then turns on the MOSFET, which then allows current to flow through the drain (D) pin to the source (S) pin. (Even if the Arduino is switched <span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>off, the circuit itself will draw around 5 mA of current at 9 V DC.) When the MOSFET is on, current can flow from the external power supply into the Arduino via the Vin pin, out via its GND pin, through the MOSFET, and finally to GND, completing the power circuit. When you press SW<sub>1</sub>, the 555’s output goes LOW and the MOSFET is switched off. This means no current can flow through the Arduino, turning it off as well.</p>
<p class="TX">If you’re using a solderless breadboard, keep the circuit together for the rest of the chapter. You can also use this circuit with other devices if they meet the same power requirements. For now, let’s use this circuit to give the Arduino the ability to turn itself off.</p>
<p class="HeadProject"><span id="h1-45"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #20: Powering Off the Arduino Automatically</samp></p>
<p class="TNI">As an extension to the soft on/off circuit used in Project #19, you can have your Arduino turn itself off by pulling pin 4 of the 555 to LOW (as you did with SW<sub>1</sub> in the previous project). This is useful for creating applications you don’t want to run continuously, from simple games to more complex data-logging projects that need to write data only when an event occurs.</p>
<p class="TX">To modify the Project #19 circuit for this purpose, first connect digital output pin D12 to the junction of 555 pin 4 and resistor R<sub>1</sub> to become the Off Signal connection if using the solderless breadboard, as shown in <a href="chapter6.xhtml#fig6-10">Figure 6-10</a>, or to the pin on the PCB labeled A OFF.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #20" class="img1" id="fig6-10" src="../images/fig6-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-10: The Project #20 circuit with Arduino self-off contact</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>Connect the Vin and GND as well. Turn on the Arduino (which should light up the onboard power LED), and the D13 LED should also turn on. After five seconds the D13 LED should turn off; then, a second later, the Arduino should turn itself off.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-20"/>

<pre><code>// Project #20 - Arduino self power off

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void turnOff()
{
    digitalWrite(12, LOW);
}

void setup()
{
    pinMode(12, OUTPUT);
    pinMode(13, OUTPUT);
    digitalWrite(12, HIGH);
}

void loop()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> digitalWrite(13, HIGH);
    delay(5000);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> digitalWrite(13, LOW);
    delay(1000);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> turnOff();
}
</code></pre>

<p class="TX">The sketch first ensures D12 is HIGH in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. Next, a simple custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> drops D12 to LOW, triggering the 555 to turn off the MOSFET and thus turn off the power to the Arduino. The sketch turns the D13 LED on <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and off <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> as an example of activity; then the Arduino turns itself off <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-46"/><samp class="SANS_Futura_Std_Bold_B_11">Activating an Arduino from an External Device</samp></h2>
<p class="TNI">So far, you’ve learned how an Arduino can shut itself off. I’ll now explain how to program an external device or sensor to activate power to an Arduino, which completes a task and then powers itself off, ready for the next event.</p>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h2-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Normally Open Contact Devices</samp></h3>
<p class="TNI">The switch used in <span class="Xref">Projects #18 and #19</span> closes the circuit between 555 pin 2 and GND. This means you can replace the switch with (or use in parallel with) something that has normally open (NO) contacts—in other words, a device that closes a circuit in the same way a press-button or switch does. This could be anything such as a simple doorbell button, a pressure mat that acts as a switch when walked on, a passive infrared (PIR) motion sensor <span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>that detects movement with relay output contacts, a normally open reed switch, a door magnet that can detect the opening of a door, and more.</p>
<p class="TX">Any device that can close the two points in the circuit will activate your Arduino. Simply connect the two wires from the device to 555 pin 2 and GND, respectively, as shown in <a href="chapter6.xhtml#fig6-11">Figure 6-11</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR A SOFT ON/OFF POWER CIRCUIT WITH EXTERNAL TRIGGER CONNECTIONS" class="img1" id="fig6-11" src="../images/fig6-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-11: The schematic for a soft on/off circuit with external trigger connections</samp></p></figcaption>
</figure>
<p class="TX">The two contacts in question are shown as ON_SIGNAL points in the schematic. If you’re using the project PCB for this chapter, these are the ON+ and ON<span class="symbol">−</span> pins.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h2-13"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Output Logic Devices</samp></h3>
<p class="TNI">You may want to have your Arduino turned on by devices that give out an electrical signal when they’re activated, such as a logic-level 5 V output. These devices include some passive infrared (PIR) motion detectors, thermostats, some industrial programmable logic controller (PLC) device outputs, and more. However, such devices require a little more circuitry to bridge the gap for activation, as their output signal isn’t the same as the normally open method described in the previous section.</p>
<p class="TX">To take advantage of these sorts of devices, you’ll use their logic output to switch another 2N7000 MOSFET to bridge the gap and act as the On switch for you. The devices’ output voltage must be high enough to turn on the MOSFET, so be sure to check this with the device supplier or datasheet before getting started. The MOSFET you’ll use in the next project requires 3 to 5 V DC to activate.</p>
<p class="TX"><span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/><a href="chapter6.xhtml#fig6-12">Figure 6-12</a> shows an example circuit, with the requisite additional MOSFET and inputs on the left side. The TRIGGER point is connected to the device’s output, and TR_GND is connected to the device’s negative or GND connection.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR SOFT ON/OFF POWER CIRCUIT WITH LOGIC LEVEL TRIGGER CONNECTIONS" class="img1" id="fig6-12" src="../images/fig6-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-12: The soft on/off schematic with logic level trigger</samp></p></figcaption>
</figure>
<p class="TX">Now before moving onto the next project, I’ll show you an easier way to use DS1307 and DS3231 real-time clock ICs by installing a useful Arduino library.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h2 class="H1" id="sec7"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">The DS3231 Real-Time Clock Library</samp></h2>
<p class="TNI">The next project uses a DS1307 or DS3231 real-time clock IC to keep time for a data-logging project. To simplify this, you’ll now learn how to use the matching DS3231 RTC library to save coding effort and space. This library works similarly to that for the DS1307.</p>
<p class="TX">First, download the library code ZIP file from <a href="https://github.com/NorthernWidget/DS3231"><i>https://<wbr/>github<wbr/>.com<wbr/>/NorthernWidget<wbr/>/DS3231</i></a>. Open the Arduino IDE and select <b>Sketch</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Include Library</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Add .ZIP library</b>. Navigate to the downloaded file and then click <b>OK</b> to install the library. You can check whether the library has installed by selecting <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Examples</b> in the IDE; a new DS3231 option should be visible.</p>
<p class="TX">Enter the sketch from <a href="#LiT-6-1">Listing 6-1</a> to test the library and the basic functions to set and retrieve time and date information, but don’t upload it yet:</p>
<span id="LiT-6-1"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;DS3231.h&gt;
DS3231 RTC;

<span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/><span aria-label="annotation2" class="CodeAnnotationHang">❷</span> bool century = false;
bool h12Flag = false;
bool pmFlag = false;
// Change the following for your own time
byte year = <var>22</var>;
byte month = <var>9</var>;
byte date = <var>2</var>;
byte hour = <var>11</var>;
byte minute = <var>8</var>;
byte second = <var>0</var>;

void setTimeData()
{
    RTC.setYear(year);
    RTC.setMonth(month);
    RTC.setDate(date);
    RTC.setHour(hour);
    RTC.setMinute(minute);
    RTC.setSecond(second);
    RTC.setClockMode(false); // Set clock to 24 hour
}

void setup()
{
    Wire.begin();
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> //setTimeData(); // Set time and date
    Serial.begin(9600);
}

void loop()
{
    // Display data on Serial Monitor
    Serial.print(RTC.getDate());
    Serial.print("/");
    Serial.print(RTC.getMonth(century));
    Serial.print("/20");
    Serial.print(RTC.getYear());
    Serial.print(" - ");
    Serial.print(RTC.getHour(h12Flag, pmFlag));
    Serial.print(":");
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> if (RTC.getMinute() &lt; 10)
    {
        Serial.print("0");
    }
    Serial.print(RTC.getMinute());
    Serial.print(":");
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (RTC.getSecond() &lt; 10)
    {
        Serial.print("0");
    }
    Serial.println(RTC.getSecond());
    delay(1000);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Testing the DS3231 RTC library</samp></p>
<p class="TX"><span aria-label=" Page 86. " epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>The sketch first includes the I<sup>2</sup>C and RTC libraries and then creates an instance of the real-time clock to reference <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It then declares the required variables to hold the time and data information <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. These include three Boolean variables, which are left as false by default, as you’re using 24-hour time.</p>
<p class="TX">To set the time, the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp> contains the functions to set all the time and date parameters. The variables declared earlier are placed in each matching function. This function needs to be called only once <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, as you’ll initially set the time and date and then comment out the function before reuploading the sketch. Otherwise, the clock will reset to the value of the variables <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">To retrieve the time, the sketch uses a series of functions that begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">RTC</samp>, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RTC.getdate()</samp>, which return their matching data. For a natural-looking display of the minutes and seconds, the sketch shows a 0 before the values for minutes under 10 <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and seconds under 10 <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">To change the time and date values to match your own time zone, enter your own values for time and date <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, then uncomment the function <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp><span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, and finally upload the sketch. Now re-comment the <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp> function and save and re-upload the sketch. Once completed, open the Serial Monitor at 9,600 bps, and you should see the date and time being updated every second.</p>
<p class="TX">Let’s combine these methods of triggering power to the Arduino and logging the events in a final project.</p>
<p class="HeadProject"><span id="h1-48"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #21: Building an Event Logger</samp></p>
<p class="TNI">For this project, imagine that someone needs to prove their arrival at a certain place on a regular basis. This might be a child arriving at school or activities, a security guard checking into work for the night, or an employee who must open a store at a particular time in the morning. To create a device to record the time and date of these events, this project uses a soft on/off circuit with an Arduino and a DS1307 or DS3231 real-time clock IC and SD card socket for logging the data to memory card. The trigger will be a simple button wired a distance away from the Arduino, like that included with a wired doorbell.</p>
<p class="TX">As an experienced Arduino user, you might build a circuit like the one in this project with slightly different products than those used here. For example, you could build a similar circuit with either an SD card module or an SD card shield (such as PMD Way part 668046, shown in <a href="chapter6.xhtml#fig6-13">Figure 6-13</a>). You can use the framework you learn in this project for any situation where you want to trigger your Arduino to do something just once and then switch off until the next event.<span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF AN SD MEMORY CARD AND REAL-TIME CLOCK SHIELD FOR ARDUINO" class="img5" id="fig6-13" src="../images/fig6-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-13: An SD and RTC shield for Arduino</samp></p></figcaption>
</figure>
<p class="TX">You’ll use the following hardware:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A 9 to 12 V DC, 1 A power supply, wall wart, or plugpack</li>
<li class="BL">The completed PCB or hardware from Project #20</li>
<li class="BL">A DS1307 or DS3231 real-time clock module and SD or microSD card module, or SD card and RTC shield for Arduino</li>
<li class="BL">A microSD or SD memory card</li>
<li class="BL">A remote button and suitable twin-core wire</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter6.xhtml#fig6-14">Figure 6-14</a>. If you’re using the solderless breadboard, you can omit the tactile switches if you don’t want local control.<span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #21" class="img1" id="fig6-14" src="../images/fig6-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-14: The schematic for Project #21</samp></p></figcaption>
</figure>
<p class="TX">Don’t forget to format your memory card correctly.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you’re unfamiliar with the use of the SD card or real-time clock module, review Chapters 7 and 20 of</i> <span class="note">Arduino Workshop</span><i>, 2nd edition.</i></p>
<p class="TX">Once you’ve assembled the hardware, set the current time and date in the Project #21 sketch using the function <samp class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. To preserve the time and date in the real-time clock, upload the sketch and then comment out the line and re-upload the sketch, as you did in the previous section.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-21"/>

<pre><code>// Project #21 - Arduino event logger

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;DS3231.h&gt;
DS3231 RTC;
#include &lt;SD.h&gt;
#define offPin 9

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> bool century = false;
bool h12Flag = false;
<span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>bool pmFlag = false;
byte year = <var>22</var>;
byte month = <var>9</var>;
byte date = <var>2</var>;
byte hour = <var>11</var>;
byte minute = <var>8</var>;
byte second = <var>0</var>;

void setTimeData()
{
    RTC.setYear(year);
    RTC.setMonth(month);
    RTC.setDate(date);
    RTC.setHour(hour);
    RTC.setMinute(minute);
    RTC.setSecond(second);
    RTC.setClockMode(false); // Set clock to 24 hour
}

void turnOff()
{
    digitalWrite(offPin, LOW);
}

void logEvent()
{
    // Create the file for writing
    File dataFile = SD.open("DATA.TXT", FILE_WRITE);
    // If the file is ready, write to it:
    if (dataFile)
    {
        dataFile.print("Event occurred on: ");
        dataFile.print(RTC.getDate());
        dataFile.print("/");
        dataFile.print(RTC.getMonth(century));
        dataFile.print("/20");
        dataFile.print(RTC.getYear());
        dataFile.print(" - ");
        dataFile.print(RTC.getHour(h12Flag, pmFlag));
        dataFile.print(":");
        if (RTC.getMinute() &lt; 10) {
            dataFile.print("0");
        }
        dataFile.print(RTC.getMinute());
        dataFile.print(":");
        if (RTC.getSecond() &lt; 10) {
            dataFile.print("0");
        }
    dataFile.println(RTC.getSecond());
    dataFile.close(); // Close the file once the system has finished with it
    }
}

<span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>void setup()
{
    Wire.begin();
    //setTimeData(); // Set time and date
    pinMode(offPin, OUTPUT);
    digitalWrite(offPin, HIGH);
    pinMode(10, OUTPUT);
    // Check that the memory card exists and is usable
    if (!SD.begin(10))
    {
        // Stop sketch:
        return;
    }
}

<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> void loop()
{
    logEvent(); // Log event to SD card
    delay(1000); // Wait a moment
    turnOff();
}
</code></pre>

<p class="TX">The sketch is a combination of basic real-time clock and SD-card-writing functions, along with self-turn-off once the event has been recorded to the memory card. It first includes the required libraries and then sets the RTC I<sup>2</sup>C bus address and the pin number that triggers the 555 timer to turn the circuit off <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, it sets the required variables for the date and time, along with the function to write the data <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp> function sets the digital pin connected to the 555 to LOW, turning off the circuit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">logEvent()</samp> function opens the text file on the SD card, retrieves the time and date from the real-time clock, and writes it in a neat line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> function initializes the real-time clock and allows for setting the time and date. It also initializes the digital pins required for triggering the external circuit and using the SD card and checks that the SD card is ready.</p>
<p class="TX">The final loop <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> operates when the external device circuit triggers the Arduino and turns it on. The <samp class="SANS_TheSansMonoCd_W5Regular_11">logEvent()</samp> function logs the event, writing the time and date to the SD card. There’s a short delay to ensure the data file has closed, after which <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp> turns the Arduino off.</p>
<p class="TX">To review the data logged by the project, disconnect the power from the Arduino and insert the SD card into your computer. Open the <i>DATA.TXT</i> file to see the events listed in order.</p>
<p class="TX">The project has recorded a new line of text containing the date and time for each event.</p>
<p class="TX">When operating at 9 V DC, this project draws around 5 mA of current when off and peaks at 70 mA during operation. If you powered it with six AA cells for portable use and had one or two events an hour, the project could easily run for more than seven days.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h2 class="H1" id="sec8"><span id="h1-49"/><span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter showed you how to add professional power control to your projects, reducing power consumption by allowing external actions to turn the power on and having your Arduino turn itself off.</p>
<p class="TX">The next chapter demonstrates another advanced way to turn projects on and off: safely controlling mains AC current with a wireless remote-controlled outlet.</p>
</section>
</section>
</body>
</html>