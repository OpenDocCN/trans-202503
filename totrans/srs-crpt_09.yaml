- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: AUTHENTICATED ENCRYPTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 认证加密
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: This chapter is about a type of algorithm that protects not only a message’s
    confidentiality but also its authenticity. Recall from [Chapter 7](ch07.xhtml#ch7)
    that message authentication codes (MACs) are algorithms that protect a message’s
    authenticity by creating a tag, which is a kind of signature. Like MACs, the authenticated
    encryption (AE) algorithms we’ll discuss in this chapter produce an authentication
    tag, but they also encrypt the message. In other words, a single AE algorithm
    offers the features of both a normal cipher and a MAC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是一种不仅保护消息机密性，还保护其真实性的算法。回想一下[第7章](ch07.xhtml#ch7)中的内容，消息认证码（MAC）是通过创建标签来保护消息真实性的算法，标签是一种签名。与MAC类似，本章将讨论的认证加密（AE）算法也会生成认证标签，但它们同时也会加密消息。换句话说，单一的AE算法同时具备普通密码算法和MAC的功能。
- en: 'Combining a cipher and a MAC can achieve varying levels of authenticated encryption,
    as you’ll learn throughout this chapter. I’ll review several possible ways to
    combine MACs with ciphers, explain which methods are the most secure, and introduce
    you to ciphers that produce both a ciphertext and an authentication tag. We’ll
    then look at four important authenticated ciphers: three block cipher–based constructions,
    with a focus on the popular Advanced Encryption Standard in Galois Counter Mode
    (AES-GCM), and a cipher that uses only a permutation algorithm.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 结合密码算法和MAC可以实现不同级别的认证加密，正如你在本章中将要学习的那样。我将回顾几种将MAC与密码算法结合的可能方式，解释哪些方法是最安全的，并向你介绍既生成密文又生成认证标签的密码算法。接下来，我们将关注四种重要的认证密码算法：三种基于分组密码的构造，重点介绍流行的高级加密标准（AES-GCM）在Galois计数模式下的应用，以及一种仅使用置换算法的密码。
- en: Authenticated Encryption Using MACs
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MAC的认证加密
- en: 'As shown in [Figure 8-1](ch08.xhtml#ch8fig1), MACs and ciphers can be combined
    in one of three ways to both encrypt and authenticate a plaintext: encrypt-and-MAC,
    MAC-then-encrypt, and encrypt-then-MAC.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8-1](ch08.xhtml#ch8fig1)所示，MAC和密码算法可以通过三种方式结合，以同时对明文进行加密和认证：加密并MAC、MAC后加密以及加密后MAC。
- en: '![image](../images/f08-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f08-01.jpg)'
- en: '*Figure 8-1: Cipher and MAC combinations*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：密码和MAC组合*'
- en: The three combinations differ in the order in which encryption is applied and
    the authentication tag is generated. However, the choice of a specific MAC or
    cipher algorithm is unimportant as long as each is secure in its own right, and
    the MAC and cipher use distinct keys.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种组合方式的区别在于加密应用的顺序和认证标签的生成方式。然而，选择具体的MAC或密码算法并不重要，只要每种算法本身是安全的，并且MAC和密码算法使用不同的密钥。
- en: As you can see in [Figure 8-1](ch08.xhtml#ch8fig1), in the encrypt-and-MAC composition,
    the plaintext is encrypted and an authentication tag is generated from the plaintext
    directly, such that the two operations (encryption and authentication) are independent
    of each other and can therefore be computed in parallel. In the MAC-then-encrypt
    scheme, the tag is generated from the plaintext first, and then the plaintext
    and MAC are encrypted together. In contrast, in the case of the encrypt-then-MAC
    method, the plaintext is encrypted first, and then the tag is generated from the
    ciphertext.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8-1](ch08.xhtml#ch8fig1)所示，在加密并MAC的组合方式中，明文首先被加密，然后直接从明文生成认证标签，因此这两种操作（加密和认证）是相互独立的，可以并行计算。在MAC后加密方案中，标签首先从明文生成，然后将明文和MAC一起加密。与此相反，在加密后MAC方法中，明文首先被加密，然后从密文中生成标签。
- en: All three approaches are about equally resource intensive. Let’s see which method
    is likely to be the most secure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法的资源消耗大致相同。接下来我们将看看哪种方法可能是最安全的。
- en: '*Encrypt-and-MAC*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加密并MAC*'
- en: The *encrypt-and-MAC* approach computes a ciphertext and a MAC tag separately.
    Given a plaintext (*P*), the sender computes a ciphertext *C* = **E**(*K*[1],
    *P*), where **E** is an encryption algorithm and *C* is the resulting ciphertext.
    The authentication tag (*T*) is calculated from the plaintext as *T* = **MAC**(*K*[2],
    *P*). You can compute *C* and *T* first or in parallel.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密并MAC* 方法将密文和MAC标签分别计算。给定一个明文（*P*），发送方计算密文 *C* = **E**(*K*[1], *P*)，其中 **E**
    是加密算法，*C* 是生成的密文。认证标签（*T*）由明文计算得到，*T* = **MAC**(*K*[2], *P*)。你可以先计算 *C* 和 *T*，也可以并行计算。'
- en: Once the ciphertext and authentication tag have been generated, the sender transmits
    both to the intended recipient. When the recipient receives *C* and *T*, they
    decrypt *C* to obtain the plaintext *P* by computing *P* = **D**(*K*[1], *C*).
    Next, they compute **MAC**(*K*[2], *P*) using the decrypted plaintext and compare
    the result to the *T* received. This verification will fail if either *C* or *T*
    was corrupted, and the message will be deemed invalid.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密文和认证标签生成完毕，发送方将两者传输给目标接收方。当接收方接收到*C*和*T*时，他们通过计算*P* = **D**(*K*[1], *C*)来解密*C*，从而获得明文*P*。接着，他们使用解密后的明文计算**MAC**(*K*[2],
    *P*)，并将结果与接收到的*T*进行比较。如果*C*或*T*受到损坏，这一验证将失败，消息将被视为无效。
- en: At least in theory, encrypt-and-MAC is the least secure MAC and cipher composition
    because even a secure MAC could leak information on *P*, which would make *P*
    easier to recover. Because the goal of using MACs is simply to make tags unforgeable,
    and because tags aren’t necessarily random looking, the authentication tag (*T*)
    of a plaintext (*P*) could still leak information even though the MAC is considered
    secure! (Of course, if the MAC is a pseudorandom function, the tag won’t leak
    anything on *P*.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 至少从理论上讲，加密-然后MAC是最不安全的MAC和密码组合，因为即便是一个安全的MAC也可能泄露*P*的信息，从而使得*P*更容易被恢复。因为使用MAC的目的仅仅是使标签不可伪造，而且标签不一定看起来是随机的，明文(*P*)的认证标签(*T*)即使在MAC被认为安全的情况下，也可能泄露信息！（当然，如果MAC是伪随机函数，标签就不会泄露任何*P*的信息。）
- en: Still, despite its relative weakness, encrypt-and-MAC continues to be supported
    by many systems, including the secure transport layer protocol SSH, wherein each
    encrypted packet *C* is followed by the tag *T* = **MAC**(*K*, *N* || *P*) sent
    in the unencrypted plaintext packet *P*. *N* in this equation is a 32-bit sequence
    number that is incremented for each sent packet, in order to help ensure that
    the received packets are processed in the right order. In practice, encrypt-and-MAC
    has proven good enough for use with SSH, thanks to the use of strong MAC algorithms
    like HMAC-SHA-256 that don’t leak information on *P*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对较弱，加密-然后MAC依然被许多系统支持，包括安全传输层协议SSH，其中每个加密包*C*后面跟着标签*T* = **MAC**(*K*, *N*
    || *P*)，该标签通过未加密的明文数据包*P*发送。此公式中的*N*是一个32位的序列号，每发送一个包都会递增，用于帮助确保接收到的包按正确顺序处理。实际上，由于使用了像HMAC-SHA-256这样的强大MAC算法（它不会泄露*P*的信息），加密-然后MAC已被证明足够适用于SSH。
- en: '*MAC-then-Encrypt*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*MAC-然后加密*'
- en: The *MAC-then-encrypt* composition protects a message, *P*, by first computing
    the authentication tag *T* = **MAC**(*K*[2], *P*). Next, it creates the ciphertext
    by encrypting the plaintext and tag together, according to *C* = **E**(*K*[1],
    *P* || *T*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*MAC-然后加密*组合通过首先计算认证标签*T* = **MAC**(*K*[2], *P*)来保护消息*P*。接下来，根据*C* = **E**(*K*[1],
    *P* || *T*)，它将明文和标签一起加密，生成密文。'
- en: Once these steps have been completed, the sender transmits only *C*, which contains
    both the encrypted plaintext and tag. Upon receipt, the recipient decrypts *C*
    by computing *P* || *T* = **D**(*K*[1], *C*) to obtain the plaintext and tag *T*.
    Next, the recipient verifies the received tag *T* by computing a tag directly
    from the plaintext according to **MAC**(*K*[2], *P*) in order to confirm that
    the computed tag is equal to the tag *T*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些步骤完成，发送方只传输*C*，其中包含加密后的明文和标签。接收方接收后，通过计算*P* || *T* = **D**(*K*[1], *C*)来解密*C*，从而获得明文和标签*T*。接下来，接收方通过根据**MAC**(*K*[2],
    *P*)从明文计算标签，来验证接收到的标签*T*，以确认计算出的标签是否等于标签*T*。
- en: As with encrypt-and-MAC, when MAC-then-encrypt is used, the recipient must decrypt
    *C* before they can determine whether they are receiving corrupted packets—a process
    that exposes potentially corrupted plaintexts to the receiver. Nevertheless, MAC-then-encrypt
    is more secure than encrypt-and-MAC because it hides the plaintext’s authentication
    tag, thus preventing the tag from leaking information on the plaintext.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密-然后MAC（encrypt-and-MAC）类似，当使用MAC-然后加密时，接收方必须在确定是否接收到损坏的数据包之前先解密*C*——这一过程可能会让接收方看到潜在损坏的明文。然而，MAC-然后加密比加密-然后MAC更安全，因为它隐藏了明文的认证标签，从而防止标签泄露明文信息。
- en: MAC-then-encrypt has been used in the TLS protocol for years, but TLS 1.3 replaced
    MAC-then-encrypt with authenticated ciphers (see [Chapter 13](ch13.xhtml#ch13)
    for more on TLS 1.3).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MAC-然后加密（MAC-then-encrypt）已经在TLS协议中使用多年，但TLS 1.3将MAC-然后加密替换为经过认证的加密算法（有关TLS
    1.3的更多信息，请参见[第13章](ch13.xhtml#ch13)）。
- en: '*Encrypt-then-MAC*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加密-然后MAC*'
- en: 'The encrypt-then-MAC composition sends two values to the recipient: the ciphertext
    produced by *C* = **E**(*K*[1], *P*) and a tag based on the ciphertext, *T* =
    **MAC**(*K*[2], *C*). The receiver computes the tag using **MAC**(*K*[2], *C*)
    and verifies that it equals the *T* received. If the values are equal, the plaintext
    is computed as *P* = **D**(*K*[1], *C*); if they are not equal, the plaintext
    is discarded.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 加密-再计算 MAC 的组合向接收者发送两个值：由 *C* = **E**(*K*[1], *P*) 产生的密文，以及基于密文的标签 *T* = **MAC**(*K*[2],
    *C*)。接收方通过 **MAC**(*K*[2], *C*) 计算标签，并验证其是否与接收到的 *T* 相等。如果值相等，则计算明文 *P* = **D**(*K*[1],
    *C*)；如果不相等，则丢弃该密文。
- en: One advantage with this method is that the receiver only needs to compute a
    MAC in order to detect corrupt messages, meaning that there is no need to decrypt
    a corrupt ciphertext. Another advantage is that attackers can’t send pairs of
    *C* and *T* to the receiver to decrypt unless they have broken the MAC, which
    makes it harder for attackers to transmit malicious data to the recipient.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优势是接收方只需要计算一个 MAC 来检测损坏的消息，这意味着无需解密损坏的密文。另一个优势是，攻击者不能发送一对 *C* 和 *T* 给接收方进行解密，除非他们破解了
    MAC，这使得攻击者更难将恶意数据传输给接收方。
- en: This combination of features makes encrypt-then-MAC stronger than the encrypt-and-MAC
    and MAC-then-encrypt approaches. This is one reason why the widely used IPSec
    secure communications protocol suite uses it to protect packets (for example,
    within VPN tunnels).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能组合使得加密-再计算 MAC 比加密-和 MAC 计算、以及 MAC-再加密的方式更强大。这也是广泛使用的 IPSec 安全通信协议套件采用它来保护数据包（例如在
    VPN 隧道内）的原因之一。
- en: But then why don’t SSH and TLS use encrypt-then-MAC? The simple answer is that
    when SSH and TLS were created, other approaches appeared adequate—not because
    theoretical weaknesses didn’t exist but because theoretical weaknesses don’t necessarily
    become actual vulnerabilities.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么 SSH 和 TLS 不使用加密-再计算 MAC（encrypt-then-MAC）呢？简单的答案是，在 SSH 和 TLS 被创建时，其他方法看起来已经足够有效——并不是因为理论上的弱点不存在，而是因为理论上的弱点不一定会转化为实际的安全漏洞。
- en: Authenticated Ciphers
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证加密算法
- en: '*Authenticated ciphers* are an alternative to the cipher and MAC combinations.
    They are like normal ciphers except that they return an authentication tag together
    with the ciphertext.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证加密算法*是替代密码算法和 MAC 组合的一种选择。它们与普通的密码算法类似，只不过它们除了返回密文外，还会返回一个认证标签。'
- en: The authenticated cipher encryption is represented as **AE**(*K*, *P*) = (*C*,
    *T*). The term **AE** stands for *authenticated encryption*, which as you can
    see from this equation is based on a key (*K*) and a plaintext (*P*) and returns
    a ciphertext (*C*) and a generated authentication tag pair (*T*). In other words,
    a single authenticated cipher algorithm does the same job as a cipher and MAC
    combination, making it simpler, faster, and often more secure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 认证加密算法的加密表示为 **AE**(*K*, *P*) = (*C*, *T*)。术语 **AE** 代表 *认证加密*，如你从这个公式中看到的，它基于密钥
    (*K*) 和明文 (*P*), 返回密文 (*C*) 和生成的认证标签对 (*T*)。换句话说，一个单一的认证加密算法完成了密码和 MAC 组合的相同工作，从而使其更加简洁、快速且通常更安全。
- en: Authenticated cipher decryption is represented by **AD**(*K*, *C*, *T*) = *P*.
    Here, **AD** stands for *authenticated decryption*, which returns a plainte (*P*)
    given a ciphertext (*C*), tag (*T*), and key (*K*). If either or both *C* and
    *T* are invalid, **AD** will return an error to prevent the recipient from processing
    a plaintext that may have been forged. By the same token, if **AD** returns a
    plaintext, you can be sure that it has been encrypted by someone or something
    that knows the secret key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 认证加密算法的解密表示为 **AD**(*K*, *C*, *T*) = *P*。这里，**AD** 代表 *认证解密*，它在给定密文 (*C*), 标签
    (*T*), 和密钥 (*K*) 的情况下返回明文 (*P*)。如果 *C* 或 *T* 任意一个或两个无效，**AD** 将返回错误，以防止接收方处理可能已被伪造的明文。换句话说，如果
    **AD** 返回明文，你可以确定它已经被某个知道秘密密钥的人或事物加密过。
- en: 'The basic security requirements of an authenticated cipher are simple: its
    authentication should be as strong as a MAC’s, meaning that it should be impossible
    to forge a ciphertext and tag pair (*C*, *T*) that the decryption function **AD**
    will accept and decrypt.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 认证加密算法的基本安全要求很简单：其认证应当与 MAC 的安全性一样强，这意味着不可能伪造出解密函数 **AD** 会接受并解密的密文和标签对 (*C*,
    *T*)。
- en: As far as confidentiality is concerned, an authenticated cipher is fundamentally
    stronger than a basic cipher because systems holding the secret key will only
    decrypt a ciphertext if the authentication tag is valid. If the tag is invalid,
    the plaintext will be discarded. This characteristic prevents attackers from performing
    chosen-ciphertext queries, an attack where they create ciphertexts and ask for
    the corresponding plaintext.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就保密性而言，经过认证的密码系统本质上比基本密码系统更强，因为持有密钥的系统只有在认证标签有效的情况下才能解密密文。如果标签无效，明文将被丢弃。这个特点防止了攻击者执行选择密文查询攻击，即他们生成密文并请求相应的明文。
- en: '*Authenticated Encryption with Associated Data*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*带有关联数据的认证加密*'
- en: Cryptographers define *associated data* as any data processed by an authenticated
    cipher such that the data is authenticated (thanks to the authentication tag)
    but not encrypted. Indeed, by default, all plaintext data fed to an authenticated
    cipher is encrypted *and* authenticated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学家将*关联数据*定义为通过认证密码处理的任何数据，这些数据已经被认证（感谢认证标签），但未被加密。事实上，默认情况下，所有输入到认证密码的明文数据都会被加密*并*认证。
- en: But what if you simply want to authenticate all of a message, including its
    unencrypted parts, but not encrypt the entire message? That is, you want to authenticate
    and transmit data in addition to an encrypted message. For example, if a cipher
    processes a network packet composed of a header followed by a payload, you might
    choose to encrypt the payload to hide the actual data transmitted, but not encrypt
    the header since it contains information required to deliver the packet to its
    final recipient. At the same time, you might still like to authenticate the header’s
    data to make sure that it is received from the expected sender.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你只是想认证整个消息，包括它的未加密部分，而不是加密整个消息怎么办？也就是说，你希望在加密消息的基础上认证和传输其他数据。例如，如果一个密码处理一个由头部和有效负载组成的网络数据包，你可能选择加密有效负载以隐藏实际传输的数据，但不加密头部，因为它包含将数据包交付给最终接收者所需的信息。同时，你可能仍然希望认证头部的数据，以确保它是从预期的发送方收到的。
- en: In order to accomplish these goals, cryptographers have created the notion of
    authenticated encryption with associated data (AEAD). An AEAD algorithm allows
    you to attach cleartext data to a ciphertext in such a way that if the cleartext
    data is corrupted, the authentication tag will not validate and the ciphertext
    will not be decrypted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，加密学家提出了带有关联数据的认证加密（AEAD）这一概念。AEAD算法允许你将明文数据附加到密文中，以使得如果明文数据被篡改，认证标签将无法验证，密文也无法解密。
- en: We can write an AEAD operation as **AEAD**(*K*, *P*, *A*) = (*C*, *A*, *T*).
    Given a key (*K*), plaintext (*P*), and associated data (*A*), AEAD returns the
    ciphertext, the unencrypted associated data *A*, and an authentication tag. AEAD
    leaves the unencrypted associated data unchanged, and the ciphertext is the encryption
    of plaintext. The authentication tag depends on both *P* and *A*, and will only
    be verified as valid if neither *C* nor *A* has been modified.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将AEAD操作表示为**AEAD**(*K*, *P*, *A*) = (*C*, *A*, *T*)。给定一个密钥(*K*)、明文(*P*)和关联数据(*A*)，AEAD返回密文、未加密的关联数据*A*和认证标签。AEAD保持未加密的关联数据不变，而密文则是明文的加密。认证标签依赖于*P*和*A*，只有当*C*和*A*都未被修改时，才会被验证为有效。
- en: Because the authenticated tag depends on *A*, decryption with associated data
    is computed by **ADAD**(*K*, *C*, *A*, *T*) = (*P*, *A*). Decryption requires
    the key, ciphertext, associated data, and tag in order to compute the plaintext
    and associated data, and it will fail if either *C* or *A* has been corrupted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于认证标签依赖于*A*，使用关联数据的解密通过**ADAD**(*K*, *C*, *A*, *T*) = (*P*, *A*)来计算。解密需要密钥、密文、关联数据和标签，以计算明文和关联数据，如果*C*或*A*被篡改，解密将失败。
- en: One thing to note when using AEAD is that you can leave *A* or *P* empty. If
    the associated data *A* is empty, AEAD becomes a normal authenticated cipher;
    if *P* is empty, it’s just a MAC.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AEAD时需要注意的一点是，你可以将*A*或*P*留空。如果关联数据*A*为空，AEAD将变为一个普通的认证密码；如果*P*为空，它只是一个MAC。
- en: '**NOTE**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of this writing, AEAD is the current norm for authenticated encryption.
    Because nearly all authenticated ciphers in use today support associated data,
    when referring to authenticated ciphers throughout this book, I am referring to
    AEAD unless stated otherwise. When discussing AEAD operations of encryption and
    decryption, I’ll refer to them as **AE** and **AD**, respectively.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至目前，AEAD是当前认证加密的标准。由于几乎所有现有的认证加密算法都支持关联数据，因此在本书中提到认证加密算法时，除非特别说明，我指的都是AEAD。在讨论AEAD的加密和解密操作时，我将分别称之为**AE**和**AD**。*'
- en: '*Avoiding Predictability with Nonces*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*通过Nonce避免可预测性*'
- en: 'Recall from [Chapter 1](ch01.xhtml#ch1) that in order to be secure, encryption
    schemes must be unpredictable and return different ciphertexts when called repeatedly
    to encrypt the same plaintext—otherwise, an attacker can determine whether the
    same plaintext was encrypted twice. In order to be unpredictable, block ciphers
    and stream ciphers feed the cipher an extra parameter: the initial value (IV)
    or nonce—a number that can be used only once. Authenticated ciphers use the same
    trick. Thus, authenticated encryption can be expressed as **AE**(*K*, *P*, *A*,
    *N*), where *N* is a nonce. It’s up to the encryption operation to pick a nonce
    that has never been used before with the same key.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下[第1章](ch01.xhtml#ch1)中提到的，为了确保安全，加密方案必须是不可预测的，并且在多次调用加密同一明文时返回不同的密文——否则，攻击者可以判断是否对相同的明文进行了两次加密。为了确保不可预测性，分组加密和流加密算法会向加密算法提供一个额外的参数：初始值（IV）或nonce——一个只能使用一次的数字。认证加密算法也使用了相同的技巧。因此，认证加密可以表示为**AE**(*K*,
    *P*, *A*, *N*)，其中*N*是nonce。加密操作负责选择一个从未与相同密钥一起使用过的nonce。
- en: As with block and stream ciphers, decryption with an authenticated cipher requires
    the nonce used for encryption in order to perform correctly. We can thus express
    decryption as **AD**(*K*, *C*, *A*, *T*, *N*) = (*P*, *A*), where *N* is the nonce
    used to create *C* and *T*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与分组加密和流加密算法一样，使用认证加密算法进行解密时，需要加密时使用的nonce（随机数），以确保解密操作正确。因此，我们可以将解密表示为**AD**(*K*,
    *C*, *A*, *T*, *N*) = (*P*, *A*)，其中*N*是用于生成*C*和*T*的nonce。
- en: '*What Makes a Good Authenticated Cipher?*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*什么才是一个好的认证加密算法？*'
- en: Researchers have been struggling since the early 2000s to define what makes
    a good authenticated cipher, and as I write this, the answer is still elusive.
    Because of AEAD’s many inputs that play different roles, it’s harder to define
    a notion of security than it is for basic ciphers that only encrypt a message.
    Nevertheless, in this section, I’ll summarize the most important criteria to consider
    when evaluating the security, performance, and functionality of an authenticated
    cipher.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自2000年代初期以来，研究人员一直在努力定义什么才算一个好的认证加密算法，直到我写下这段话时，答案仍然难以捉摸。由于AEAD具有多种角色不同的输入，定义其安全性比基本加密算法（仅加密消息）更为困难。然而，在本节中，我将总结在评估认证加密算法的安全性、性能和功能时需要考虑的最重要标准。
- en: Security Criteria
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全性标准
- en: 'The most important criteria used to measure the strength of an authenticated
    cipher are its ability to protect the confidentiality of data (that is, the secrecy
    of the plaintext) and the authenticity and integrity of the communication (as
    with the MAC’s ability to detect corrupted messages). An authenticated cipher
    must compete in both leagues: its confidentiality must be as strong as that of
    the strongest cipher, and its authenticity as strong as that of the best MAC.
    In other words, if you remove the authentication part in an AEAD, you should get
    a secure cipher, and if you remove the encryption part, you should get a strong
    MAC.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用于衡量认证加密算法强度的最重要标准是其保护数据机密性（即明文的保密性）以及通信的真实性和完整性（例如，MAC检测消息损坏的能力）。一个认证加密算法必须在这两个方面都具有竞争力：它的机密性必须与最强的加密算法一样强，其真实性必须与最强的MAC一样强。换句话说，如果你去掉AEAD中的认证部分，应该得到一个安全的加密算法；如果去掉加密部分，应该得到一个强大的MAC。
- en: Another measure of the strength of an authenticated cipher’s security is based
    on something a bit more subtle—namely, its fragility when faced with repeated
    nonces. For example, if a nonce is reused, can an attacker decrypt ciphertexts
    or learn the difference between plaintexts?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个衡量认证加密算法安全性强度的标准则基于一些更微妙的因素——即其在面对重复的nonce时的脆弱性。例如，如果一个nonce被重复使用，攻击者是否能够解密密文或区分明文之间的差异？
- en: Researchers call this notion of robustness *misuse resistance*, and have designed
    misuse-resistant authenticated ciphers to weigh the impact of a repeated nonce
    and attempt to determine whether confidentiality, authenticity, or both would
    be compromised in the face of such an attack, as well as what information about
    the encrypted data would likely be leaked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员将这种稳健性的概念称为*误用抗性*，并设计了抗误用认证加密算法来评估重复随机数的影响，并尝试确定在此类攻击下，机密性、真实性或两者是否会受到威胁，以及有关加密数据的信息可能会泄漏的程度。
- en: Performance Criteria
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 性能标准
- en: As with every cryptographic algorithm, the throughput of an authenticated cipher
    can be measured in bits processed per second. This speed depends on the number
    of operations performed by the cipher’s algorithm and on the extra cost of the
    authentication functionality. As you might imagine, the extra security features
    of authenticated ciphers come with a performance hit. However, the measure of
    a cipher’s performance isn’t just about pure speed. It’s also about parallelizability,
    structure, and whether the cipher is streamable. Let’s examine these notions more
    closely.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个加密算法一样，认证加密算法的吞吐量可以用每秒处理的比特数来衡量。这个速度取决于加密算法执行的操作次数以及认证功能的额外开销。正如你所想，认证加密算法的额外安全特性会带来性能上的损失。然而，衡量加密算法性能的不仅仅是纯粹的速度。它还与并行化能力、结构以及加密算法是否支持流式处理有关。让我们更仔细地分析这些概念。
- en: A cipher’s *parallelizability* is a measure of its ability to process multiple
    data blocks simultaneously without waiting for the previous block’s processing
    to complete. Block cipher–based designs can be easily parallelizable when each
    block can be processed independently of the other blocks. For example, the CTR
    block cipher mode discussed in [Chapter 4](ch04.xhtml#ch4) is parallelizable,
    whereas the CBC encryption mode is not, because blocks are chained.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法的*并行化能力*是衡量其能否同时处理多个数据块而不需要等待前一个数据块处理完成的能力。基于块加密的设计，当每个数据块可以独立于其他数据块处理时，通常容易并行化。例如，[第4章](ch04.xhtml#ch4)中讨论的CTR块加密模式是可以并行化的，而CBC加密模式则不行，因为它们的块是串联的。
- en: 'The internal structure of an authenticated cipher is another important performance
    criteria. There are two main types of structure: one-layer and two-layer. In a
    two-layer structure (for example, in the widely used AES-GCM), one algorithm processes
    the plaintext and then a second algorithm processes the result. Typically, the
    first layer is the encryption layer and the second is the authentication layer.
    But as you might expect, a two-layer structure complicates implementation and
    tends to slow down computations.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 认证加密算法的内部结构是另一个重要的性能标准。主要有两种结构类型：单层结构和双层结构。在双层结构中（例如，广泛使用的AES-GCM），一种算法处理明文，然后第二种算法处理结果。通常，第一个层是加密层，第二个层是认证层。但正如你所预料的，双层结构会使实现变得更加复杂，并且通常会导致计算变慢。
- en: 'An authenticated cipher is *streamable* (also called an *online* cipher) when
    it can process a message block-by-block and discard any already-processed blocks.
    In contrast, nonstreamable ciphers must store the entire message, typically because
    they need to make two consecutive passes over the data: one from the start to
    the end, and the other from the end to the start of the data obtained from the
    first pass.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当认证加密算法能够逐块处理消息并丢弃已经处理过的块时，它就是*流式*（也称为*在线*）加密算法。相比之下，非流式加密算法必须存储整个消息，通常是因为它们需要对数据进行两次连续的处理：第一次从开始到结束，第二次从结束到开始，使用第一次处理所得到的数据。
- en: Due to potentially high memory requirements, some applications won’t work with
    nonstreamable ciphers. For example, a router could receive an encrypted block
    of data, decrypt it, and then return the plaintext block before moving on to decrypt
    the subsequent block of the message, though the recipient of the decrypted message
    would still have to verify the authentication tag sent at the end of the decrypted
    data stream.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能需要较高的内存，一些应用程序无法使用非流式加密算法。例如，一个路由器可以接收一个加密的数据块，解密后返回明文块，然后再继续解密消息的后续数据块，尽管解密后的消息接收方仍然需要验证发送的认证标签。
- en: Functional Criteria
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 功能标准
- en: 'Functional criteria are the features of a cipher or its implementation that
    don’t directly relate to either security or performance. For example, some authenticated
    ciphers only allow associated data to precede the data to be encrypted (because
    they need access to it in order to start encryption). Others require associated
    data to follow the data to be encrypted or support the inclusion of associated
    data anywhere—even between chunks of plaintext. This last case is the best, because
    it enables users to protect their data in any possible situation, but it’s also
    the hardest to design securely: as always, more features often bring more complexity—and
    more potential vulnerabilities.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标准是指加密算法或其实现的特性，这些特性与安全性或性能没有直接关系。例如，一些认证加密算法只允许关联数据出现在待加密数据之前（因为它们需要访问这些数据以开始加密）。其他算法要求关联数据出现在待加密数据之后，或者支持在任何位置包括关联数据——即使是在明文块之间。这种最后一种情况是最好的，因为它使用户能够在任何可能的情况下保护数据，但它也是最难以安全设计的：一如既往，更多的功能往往带来更多的复杂性——也可能带来更多的潜在漏洞。
- en: Another piece of functional criteria to consider relates to whether you can
    use the same core algorithm for both encryption and decryption. For example, many
    authenticated ciphers are based on the AES block cipher, which specifies the use
    of two similar algorithms for encrypting and decrypting a block. As discussed
    in [Chapter 4](ch04.xhtml#ch4), the CBC block cipher mode requires both algorithms,
    but the CTR mode requires only the encryption algorithm. Likewise, authenticated
    ciphers may not need both algorithms. Although the extra cost of implementing
    both encryption and decryption algorithms won’t impact most software, it’s often
    noticeable on low-cost dedicated hardware, where implementation cost is measured
    in terms of logic gates, or the silicon area occupied by the cryptography.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的功能标准是，是否可以使用相同的核心算法进行加密和解密。例如，许多认证加密算法是基于 AES 块加密算法的，该算法指定使用两种相似的算法分别进行加密和解密块。如[第
    4 章](ch04.xhtml#ch4)中所讨论的，CBC 块加密模式需要两种算法，而 CTR 模式只需要加密算法。同样，认证加密算法可能不需要两种算法。尽管实现加密和解密算法的额外成本对大多数软件影响不大，但在低成本专用硬件上，通常会很明显，因为在这种硬件上，实施成本是以逻辑门或加密所占硅面积来衡量的。
- en: 'AES-GCM: The Authenticated Cipher Standard'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AES-GCM：认证加密标准
- en: AES-GCM is the most widely used authenticated cipher. AES-GCM is, of course,
    based on the AES algorithm, and the Galois counter mode (GCM) of operation is
    essentially a tweak of the CTR mode that incorporates a small and efficient component
    to compute an authentication tag. As I write this, AES-GCM is the only authenticated
    cipher that is a NIST standard (SP 800-38D). AES-GCM is also part of NSA’s Suite
    B and of the Internet Engineering Task Force (IETF) for the secure network protocols
    IPSec, SSH, and TLS 1.2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM 是最广泛使用的认证加密算法。AES-GCM 当然是基于 AES 算法的，而 Galois 计数器模式（GCM）实际上是对 CTR 模式的一个改进，其中加入了一个小巧高效的组件来计算认证标签。在我写这篇文章时，AES-GCM
    是唯一一个被 NIST 标准化的认证加密算法（SP 800-38D）。AES-GCM 也是 NSA Suite B 和互联网工程任务组（IETF）用于安全网络协议
    IPSec、SSH 和 TLS 1.2 的一部分。
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although GCM works with any block cipher, you’ll probably only see it used
    with AES. Some people don’t want to use AES because it’s American, but they won’t
    use GCM either, for the same reason. Therefore, GCM is rarely paired with other
    ciphers.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 GCM 可以与任何块加密算法一起使用，但你可能只会看到它与 AES 配合使用。有些人不想使用 AES，因为它是美国的算法，但他们也不使用 GCM，原因相同。因此，GCM
    很少与其他加密算法配对使用。*'
- en: '*GCM Internals: CTR and GHASH*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*GCM 内部结构：CTR 和 GHASH*'
- en: '![image](../images/f08-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f08-02.jpg)'
- en: '*Figure 8-2: The AES-GCM mode, applied to one associated data block,* A[1],
    *and two plaintext blocks*, P[1] *and* P[2]. *The circled multiplication sign
    represents polynomial multiplication by* H, *the authentication key derived from*
    K.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：AES-GCM 模式，应用于一个关联数据块* A[1]，*和两个明文块* P[1] *和* P[2]。*圈出的乘法符号表示由* H *进行的多项式乘法，*H*
    是从* K *衍生的认证密钥。'
- en: '[Figure 8-2](ch08.xhtml#ch8fig2) shows how AES-GCM works: AES instances parameterized
    by a secret key (*K*) transform a block composed of the nonce (*N*) concatenated
    with a counter (starting here at 1, then incremented to 2, 3, and so on) and then
    XOR the result with a plaintext block to obtain a ciphertext block. So far, that’s
    nothing new compared to the CTR mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](ch08.xhtml#ch8fig2) 显示了 AES-GCM 的工作原理：由一个秘密密钥（*K*）参数化的 AES 实例将由一次性数（*N*）与计数器（从
    1 开始，然后递增为 2、3 等）连接组成的块进行变换，然后将结果与明文块进行 XOR 操作，从而得到密文块。到目前为止，与 CTR 模式相比，这没有什么新变化。'
- en: Next, the ciphertext blocks are mixed using a combination of XORs and multiplications
    (as you’ll see next). You can see AES-GCM as doing 1) an encryption in CTR mode
    and 2) a MAC over the ciphertext blocks. Therefore, AES-GCM is essentially an
    encrypt-then-MAC construction, where AES-CTR encrypts using a 128-bit key (*K*)
    and a 96-bit nonce (*N*), with the minor difference that the counter starts from
    1, not 0, as in normal CTR mode (which doesn’t matter, as far as security is concerned).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，密文块使用XOR和乘法的组合进行混合（如你接下来将看到的）。你可以将AES-GCM视为执行1）CTR模式加密和2）对密文块进行MAC操作。因此，AES-GCM本质上是一种加密后再进行MAC的构造，其中AES-CTR使用128位密钥（*K*）和96位随机数（*N*）进行加密，唯一的不同是计数器从1开始，而不是像正常的CTR模式那样从0开始（就安全性而言，这并不重要）。
- en: To authenticate the ciphertext, GCM uses a Wegman–Carter MAC (see [Chapter 7](ch07.xhtml#ch7))
    to authenticate the ciphertext, which XORs the value **AES**(*K*, *N* || 0) with
    the output of a universal hash function called *GHASH*. In [Figure 8-2](ch08.xhtml#ch8fig2),
    GHASH corresponds to the series of operations “⊗[H]” followed by the XOR with
    len(*A*) || len(*C*), or the bit length of *A* (the associated data) followed
    by the bit length of *C* (the ciphertext).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了认证密文，GCM使用Wegman-Carter MAC（见[第7章](ch07.xhtml#ch7)）来认证密文，它将**AES**(*K*, *N*
    || 0*)的值与名为*GHASH*的通用哈希函数的输出进行XOR。在[图8-2](ch08.xhtml#ch8fig2)中，GHASH对应于“⊗[H]”的操作序列，后面是与len(*A*)
    || len(*C*)进行XOR操作，或者说是与*A*（关联数据）的位长和*C*（密文）的位长进行XOR。
- en: We can thus express the authentication tag’s value as *T* = **GHASH**(*H*, *C*)
    ⊕ **AES**(*K*, *N* || 0), where *C* is the ciphertext and *H* is the *hash key*,
    or *authentication key*. This key is determined as *H* = **AES**(*K*, 0), which
    is the encryption of the block equal to a sequence of null bytes (this step does
    not appear in [Figure 8-2](ch08.xhtml#ch8fig2), for clarity).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将认证标签的值表示为*T* = **GHASH**(*H*, *C*) ⊕ **AES**(*K*, *N* || 0)，其中*C*是密文，*H*是*哈希密钥*或*认证密钥*。该密钥被确定为*H*
    = **AES**(*K*, 0)，即加密等于一串空字节的块（为了清晰起见，这一步在[图8-2](ch08.xhtml#ch8fig2)中没有出现）。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In GCM, GHASH doesn’t use* K *directly in order to ensure that if GHASH’s
    key is compromised, the master key* K *remains secret. Given* K, *you can get*
    H *by computing **AES***(K, *0), but you can’t recover* K *from that value since*
    K *acts here as AES’s key.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*在GCM中，GHASH并不直接使用* K *，以确保如果GHASH的密钥被泄露，主密钥* K *仍然保持机密。给定* K *，你可以通过计算**AES**(*K*,
    *0*)得到* H *，但是你无法从这个值恢复* K *，因为* K *在这里作为AES的密钥作用。*'
- en: As [Figure 8-2](ch08.xhtml#ch8fig2) shows, GHASH uses *polynomial notation*
    to multiply each ciphertext block with the authentication key *H*. This use of
    polynomial multiplication makes GHASH fast in hardware as well as in software,
    thanks to a special polynomial multiplication instruction available in many common
    microprocessors (`CLMUL`, for carry-less multiplication).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图8-2](ch08.xhtml#ch8fig2)所示，GHASH使用*多项式表示法*将每个密文块与认证密钥*H*相乘。这种多项式乘法使得GHASH在硬件和软件中都非常快速，因为许多常见微处理器中都提供了一个特殊的多项式乘法指令（`CLMUL`，即无进位乘法）。
- en: Alas, GHASH is far from ideal. For one thing, its speed is suboptimal. Even
    when the `CLMUL` instruction is used, the AES-CTR layer that encrypts the plaintext
    remains faster than the GHASH MAC. Second, GHASH is painful to implement correctly.
    In fact, even the experienced developers of the OpenSSL project, by far the most-used
    cryptographic piece of software in the world, got AES-GCM’s GHASH wrong. One commit
    had a bug in a function called `gcm_ghash_clmul` that allowed attackers to forge
    valid MACs for the AES-GCM. (Fortunately, the error was spotted by Intel engineers
    before the bug entered the next OpenSSL release.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GHASH远非理想。首先，它的速度并不最优。即使使用了`CLMUL`指令，加密明文的AES-CTR层仍然比GHASH MAC快。其次，GHASH的实现非常麻烦。实际上，连OpenSSL项目的经验丰富的开发人员——世界上最常用的加密软件——也在实现AES-GCM的GHASH时出了问题。一次提交中，`gcm_ghash_clmul`函数中有一个bug，允许攻击者伪造AES-GCM的有效MAC。（幸运的是，这个错误在bug进入下一版本的OpenSSL之前被英特尔工程师发现了。）
- en: POLYNOMIAL MULTIPLICATION
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式乘法
- en: 'While clearly more complicated for us than classic integer arithmetic, polynomial
    multiplication is simpler for computers because there are no carries. For example,
    say we want to compute the product of the polynomials (1 + *X* + *X*²) and (*X*
    + *X*³). We first multiply the two polynomials (1 + *X* + *X*²) and (*X* + *X*³)
    as though we were doing normal polynomial multiplication, thus giving us the following
    (the two terms *X*³ cancel each other out):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于我们来说多项式乘法明显比经典的整数运算复杂，但对于计算机来说，它更简单，因为没有进位。例如，假设我们想计算多项式 (1 + *X* + *X*²)
    和 (*X* + *X*³) 的乘积。我们首先像进行普通的多项式乘法那样，将这两个多项式 (1 + *X* + *X*²) 和 (*X* + *X*³) 相乘，得到以下结果（两个
    *X*³ 项互相抵消）：
- en: (1 + *X* + *X*²) ⊕ (*X* + *X*³) = *X* + *X*³ + *X*² + *X*⁴ + *X*³ + *X*⁵ = *X*
    + *X*² + *X*⁴ + *X*⁵
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (1 + *X* + *X*²) ⊕ (*X* + *X*³) = *X* + *X*³ + *X*² + *X*⁴ + *X*³ + *X*⁵ = *X*
    + *X*² + *X*⁴ + *X*⁵
- en: We now apply modulo reduction, reducing *X* + *X*² + *X*⁴ + *X*⁵ modulo 1 +
    *X*³ +*X*⁴ to give us *X*², because *X* + *X*² + *X*⁴ + *X*⁵ can be written as
    *X* + *X*² + *X*⁴ + *X*⁵ = *X* ⊗ (1 + *X*³ + *X*⁴) + *X*². In more general terms,
    *A* + *BC* modulo *B* is equal to *A*, by definition of modular reduction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在进行模运算，将 *X* + *X*² + *X*⁴ + *X*⁵ 对 1 + *X*³ + *X*⁴ 进行模约简，得到 *X*²，因为 *X*
    + *X*² + *X*⁴ + *X*⁵ 可以表示为 *X* + *X*² + *X*⁴ + *X*⁵ = *X* ⊗ (1 + *X*³ + *X*⁴)
    + *X*²。更一般地，*A* + *BC* 对 *B* 取模等于 *A*，这是模约简的定义。
- en: '*GCM Security*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*GCM 安全性*'
- en: AES-GCM’s biggest weakness is its fragility in the face of nonce repetition.
    If the same nonce *N* is used twice in an AES-GCM implementation, an attacker
    can get the authentication key *H* and use it to forge tags for any ciphertext,
    associated data, or combination thereof.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM 的最大弱点是在面对重复 nonce 时的脆弱性。如果在 AES-GCM 实现中使用相同的 nonce *N* 两次，攻击者可以获得认证密钥
    *H*，并利用它伪造任何密文、关联数据或两者的组合的标签。
- en: A look at the basic algebra behind AES-GCM’s computations (as shown in [Figure
    8-2](ch08.xhtml#ch8fig2)) will help make this fragility clear. Specifically, a
    tag (*T*) is computed as *T* = **GHASH**(*H*, *A*, *C*) ⊕ **AES**(*K*, *N* ||
    0), where GHASH is a universal hash function with linearly related inputs and
    outputs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 AES-GCM 计算背后的基本代数（如 [图 8-2](ch08.xhtml#ch8fig2) 所示）将帮助我们理解这种脆弱性。具体来说，标签 (*T*)
    是通过 *T* = **GHASH**(*H*, *A*, *C*) ⊕ **AES**(*K*, *N* || 0) 计算出来的，其中 GHASH 是一个输入输出线性相关的通用哈希函数。
- en: 'Now what happens if you get two tags, *T*[1] and *T*[2], computed with the
    same nonce *N* ? Right, the AES part will vanish. If we have two tags, *T*[1]
    = **GHASH**(*H*, *A*[1], *C*[1]) ⊕ **AES**(*K*, *N* || 0) and *T*[2] = **GHASH**(*H*,
    *A*[1], *C*[1]) ⊕ **AES**(*K*, *N* || 0), then XORing them together gives the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到两个标签，*T*[1] 和 *T*[2]，它们是用相同的 nonce *N* 计算出来的，结果会怎样？没错，AES 部分会消失。如果我们有两个标签，*T*[1]
    = **GHASH**(*H*, *A*[1], *C*[1]) ⊕ **AES**(*K*, *N* || 0) 和 *T*[2] = **GHASH**(*H*,
    *A*[1], *C*[1]) ⊕ **AES**(*K*, *N* || 0)，那么将它们异或得到以下结果：
- en: '![image](../images/f0154-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0154-01.jpg)'
- en: If the same nonce is used twice, an attacker can thus recover the value **GHASH**(*H*,
    *A*[1], *C*[1]) ⊕ **GHASH**(*H*, *A*[2], *C*[2]) for some known *A*[1], *C*[1],
    *A*[2], and *C*[2]. The linearity of GHASH then allows an attacker to easily determine
    *H*. (It would have been worse if GHASH had used the same key *K* as the encryption
    part, but because *H* = **AES**(*K*, 0), there’s no way to find *K* from *H*.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的 nonce 被使用两次，攻击者就可以恢复值 **GHASH**(*H*, *A*[1], *C*[1]) ⊕ **GHASH**(*H*,
    *A*[2], *C*[2])，对于一些已知的 *A*[1]、*C*[1]、*A*[2] 和 *C*[2]。GHASH 的线性特性使得攻击者可以轻松地确定
    *H*。（如果 GHASH 使用了与加密部分相同的密钥 *K*，情况会更糟，但由于 *H* = **AES**(*K*, 0)，所以无法通过 *H* 来找到
    *K*。）
- en: As recently as 2016, researchers scanned the internet for instances of AES-GCM
    exposed through HTTPS servers, in search of systems with repeating nonces (see
    *[https://eprint.iacr.org/2016/475/](https://eprint.iacr.org/2016/475/)*). They
    found 184 servers with repeating nonces, including 23 that always used the all-zero
    string as a nonce.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2016 年，研究人员仍在互联网上扫描 AES-GCM 通过 HTTPS 服务器暴露的实例，寻找具有重复 nonce 的系统（见 *[https://eprint.iacr.org/2016/475/](https://eprint.iacr.org/2016/475/)*）。他们发现了
    184 台具有重复 nonce 的服务器，其中 23 台总是使用全零字符串作为 nonce。
- en: '*GCM Efficiency*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*GCM 效率*'
- en: One advantage of GCM mode is that both GCM encryption and decryption are parallelizable,
    allowing you to encrypt or decrypt different plaintext blocks independently. However,
    the AES-GCM MAC computation isn’t parallelizable, because it must be computed
    from the beginning to the end of the ciphertext once GHASH has processed any associated
    data. This lack of parallelizability means that any system that receives the plaintext
    first and then the associated data will have to wait until all associated data
    is read and hashed before hashing the first ciphertext block.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GCM 模式的一个优势是，GCM 加密和解密都可以并行处理，允许你独立地加密或解密不同的明文块。然而，AES-GCM 的 MAC 计算无法并行化，因为在
    GHASH 处理完任何关联数据后，它必须从密文的开始到结束进行计算。缺乏并行化意味着任何先接收明文再接收关联数据的系统，必须等到所有关联数据被读取并哈希完后，才能开始哈希第一个密文块。
- en: 'Nevertheless, GCM is streamable: since the computations in its two layers can
    be pipelined, there’s no need to store all ciphertext blocks before computing
    GHASH because GHASH will process each block as it’s encrypted. In other words,
    *P*[1] is encrypted to *C*[1], then GHASH processes *C*[1] while *P*[2] is encrypted
    to *C*[2], then *P*[1] and *C*[1] are no longer needed, and so on.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GCM 是可以流式处理的：由于其两层计算可以流水线处理，因此在计算 GHASH 时不需要先存储所有密文块，因为 GHASH 会在每个块被加密时处理它。换句话说，*P*[1]
    会被加密为 *C*[1]，然后 GHASH 处理 *C*[1]，同时 *P*[2] 被加密为 *C*[2]，之后 *P*[1] 和 *C*[1] 就不再需要，以此类推。
- en: 'OCB: An Authenticated Cipher Faster than GCM'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'OCB: 比 GCM 更快的认证密码'
- en: The acronym *OCB* stands for *offset codebook* (though its designer, Phil Rogaway,
    prefers to simply call it OCB). First developed in 2001, OCB predates GCM, and
    like GCM it produces an authenticated cipher from a block cipher, though it does
    so faster and more simply. Then why hasn’t OCB seen wider adoption? Unfortunately,
    until 2013, all uses of OCB required a license from the inventor. Fortunately,
    as I write this, Rogaway grants free licenses for nonmilitary software implementations
    (see *[http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm](http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm)*).
    Therefore, although OCB is not yet a formal standard, perhaps we will begin to
    see wider adoption.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写 *OCB* 代表 *offset codebook*（尽管其设计者 Phil Rogaway 更喜欢直接称之为 OCB）。OCB 于 2001 年首次开发，早于
    GCM，并且像 GCM 一样，它从一个块密码生成一个认证密码，尽管它做得更快、更简单。那么为什么 OCB 没有得到更广泛的采用呢？不幸的是，直到 2013
    年，所有 OCB 的使用都需要从发明人那里获得许可证。幸运的是，正如我写这篇文章时，Rogaway 允许非军事软件实现免费授权（参见 *[http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm](http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm)*）。因此，尽管
    OCB 还不是正式标准，也许我们会开始看到它的更广泛应用。
- en: Unlike GCM, OCB blends encryption and authentication into one processing layer
    that uses only one key. There’s no separate authentication component, so OCB gets
    you authentication mostly for free and performs almost as many block cipher calls
    as a non-authenticated cipher. Actually, OCB is almost as simple as the ECB mode
    (see [Chapter 4](ch04.xhtml#ch4)), except that it’s secure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 不同，OCB 将加密和认证合并成一个处理层，并只使用一个密钥。没有单独的认证组件，因此 OCB 基本上可以“免费”获得认证，并且它的块密码调用次数几乎和非认证密码一样。实际上，OCB
    几乎和 ECB 模式一样简单（参见 [第 4 章](ch04.xhtml#ch4)），只不过它是安全的。
- en: '*OCB Internals*'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*OCB 内部原理*'
- en: '[Figure 8-3](ch08.xhtml#ch8fig3) shows how OCB works: OCB encrypts each plaintext
    block *P* to a ciphertext block *C* = **E**(*K*, *P* ⊕ *O*) ⊕ *O*, where **E**
    is a block cipher encryption function. Here, *O* (called the *offset*) is a value
    that depends on the key and the nonce incremented for each new block processed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](ch08.xhtml#ch8fig3) 显示了 OCB 的工作原理：OCB 将每个明文块 *P* 加密为密文块 *C* = **E**(*K*,
    *P* ⊕ *O*) ⊕ *O*，其中 **E** 是一个块密码加密函数。这里的 *O*（称为 *偏移量*）是一个依赖于密钥和对每个新处理的块递增的 nonce
    的值。'
- en: To produce the authentication tag, OCB first XORs the plaintext blocks together
    to compute *S* = *P*[1] ⊕ *P*[2] ⊕ *P*[3] ⊕ … (that is, the XOR of all plaintext
    blocks). The authentication tag is then *T* = **E**(*K*, *S* ⊕ *O*^*), where *O*^*
    is an offset value computed from the offset of the last plaintext block processed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成认证标签，OCB 首先对明文块进行 XOR 运算，计算 *S* = *P*[1] ⊕ *P*[2] ⊕ *P*[3] ⊕ …（即所有明文块的 XOR）。然后认证标签为
    *T* = **E**(*K*, *S* ⊕ *O*^*)，其中 *O*^* 是从处理的最后一个明文块的偏移量计算出来的偏移值。
- en: '![image](../images/f08-03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f08-03.jpg)'
- en: '*Figure 8-3: The OCB encryption process when run on two plaintext blocks, with
    no associated data*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：OCB 加密过程，当处理两个明文块且没有关联数据时*'
- en: Like AES-GCM, OCB also supports associated data as a series of blocks, *A*[1],
    *A*[2], and so on. When an OCB encrypted message contains associated data, the
    authentication tag is calculated according to the formula
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AES-GCM 类似，OCB 也支持作为一系列块的关联数据，*A*[1]、*A*[2] 等。当 OCB 加密消息包含关联数据时，认证标签会根据公式进行计算。
- en: '*T* = **E**(*K*, *S* ⊕ *O*^*) ⊕ **E**(*K*, *A*[1] ⊕ *O*[1]) ⊕ **E**(*K*, *A*[2]
    ⊕ *O*[2]) ⊕ …'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* = **E**(*K*, *S* ⊕ *O*^*) ⊕ **E**(*K*, *A*[1] ⊕ *O*[1]) ⊕ **E**(*K*, *A*[2]
    ⊕ *O*[2]) ⊕ …'
- en: where OCB specifies offset values that are different from those used to encrypt
    *P*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，OCB 指定的偏移值与用于加密 *P* 的偏移值不同。
- en: Unlike GCM and encrypt-then-MAC, which create an authentication tag by combining
    ciphertext, OCB calculates the authentication tag by combining plaintext data.
    There’s nothing wrong with this approach, and OCB is backed by solid security
    proofs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 和加密后 MAC（Encrypt-then-MAC）不同，后者通过结合密文生成认证标签，而 OCB 是通过结合明文数据来计算认证标签。这个方法没有问题，而且
    OCB 得到了坚实的安全性证明。
- en: '**NOTE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more on how to implement OCB correctly, see either RFC 7253 or the 2011
    paper “The Software Performance of Authenticated-Encryption Modes” by Krovetz
    and Rogaway, which covers the latest and best version of OCB, OCB3\. For further
    details on OCB, see the OCB FAQ at* [http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm](http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于如何正确实现 OCB 的更多信息，请参见 RFC 7253 或 Krovetz 和 Rogaway 2011 年的论文《Authenticated-Encryption
    Modes 的软件性能》，该论文涵盖了最新且最好的 OCB 版本 OCB3。有关 OCB 的进一步细节，请参见 OCB 常见问题解答* [http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm](http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm)。'
- en: '*OCB Security*'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*OCB 安全性*'
- en: OCB is a bit less fragile than GCM against repeated nonces. For example, if
    a nonce is used twice, an attacker that sees the two ciphertexts will notice that,
    say, the third plaintext block of the first message is identical to the third
    plaintext block of the second message. With GCM, attackers can find not only duplicates
    but also XOR differences between blocks at the same position. The impact of repeated
    nonces is therefore worse with GCM than it is with OCB.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 相比，OCB 对重复的 nonce 要稍微不那么脆弱。例如，如果 nonce 被使用两次，攻击者看到这两个密文后，会注意到，第一个消息的第三个明文块与第二个消息的第三个明文块相同。对于
    GCM，攻击者不仅可以找到重复的块，还能在同一位置找到块之间的 XOR 差异。因此，重复的 nonce 对 GCM 的影响要比 OCB 更严重。
- en: As with GCM, repeated nonces can break the authenticity of OCB, though less
    effectively. For example, an attacker could combine blocks from two messages authenticated
    with OCB to create another encrypted message with the same checksum and tag as
    one of the original two messages, but the attacker would not be able to recover
    a secret key as with GCM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 一样，重复的 nonce 会破坏 OCB 的真实性，但效果较差。例如，攻击者可以将通过 OCB 验证的两个消息的块合并，生成另一个加密消息，该消息的校验和和标签与原始两个消息之一相同，但攻击者无法像
    GCM 那样恢复出密钥。
- en: '*OCB Efficiency*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*OCB 效率*'
- en: OCB and GCM are about equally fast. Like GCM, OCB is parallelizable and streamable.
    In terms of raw efficiency, GCM and OCB will make about as many calls to the underlying
    block cipher (usually AES), but OCB is slightly more efficient than GCM because
    it simply XORs the plaintext rather than performing something like the relatively
    expensive GHASH computation. (In earlier generations of Intel microprocessors,
    AES-GCM used to be more than three times slower than AES-OCB because AES and GHASH
    instructions had to compete for CPU resources and couldn’t be run in parallel.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OCB 和 GCM 的速度大致相同。像 GCM 一样，OCB 也是可并行化和可流式处理的。在原始效率方面，GCM 和 OCB 调用底层块密码（通常是 AES）的次数大致相同，但
    OCB 比 GCM 略高效，因为它仅仅是对明文进行 XOR 操作，而不像 GCM 那样执行相对昂贵的 GHASH 计算。（在早期的英特尔微处理器中，AES-GCM
    的速度比 AES-OCB 慢了三倍以上，因为 AES 和 GHASH 指令必须竞争 CPU 资源，无法并行执行。）
- en: One important difference between OCB and GCM implementations is that OCB needs
    both the block cipher’s encryption and decryption functions in order to encrypt
    and decrypt, which increases the cost of hardware implementations when only limited
    silicon is available for crypto components. In contrast, GCM uses only the encryption
    function for both encryption and decryption.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: OCB 和 GCM 实现之间的一个重要区别是，OCB 需要块密码的加密和解密功能才能进行加解密，这在只有有限硅资源用于加密组件的硬件实现中会增加成本。相比之下，GCM
    仅使用加密功能来进行加解密。
- en: 'SIV: The Safest Authenticated Cipher?'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SIV：最安全的认证加密算法？
- en: '*Synthetic IV*, also known as *SIV*, is an authenticated cipher mode typically
    used with AES. Unlike GCM and OCB, SIV is secure even if you use the same nonce
    twice: if an attacker gets two ciphertexts encrypted using the same nonce, they’ll
    only be able to learn whether the same plaintext was encrypted twice. Unlike with
    messages encrypted with GCM or OCB, the attacker would be unable to tell whether
    the first block of the two messages is the same because the nonce used to encrypt
    is first computed as a combination of the given nonce and the plaintext.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*合成IV*，也称为*SIV*，是一种经过认证的加密模式，通常与AES一起使用。与GCM和OCB不同，SIV即使使用相同的nonce两次也依然安全：如果攻击者获得了使用相同nonce加密的两个密文，他们只能知道是否是同一明文被加密了两次。与使用GCM或OCB加密的消息不同，攻击者无法判断两个消息的第一个块是否相同，因为用于加密的nonce首先是作为给定nonce和明文的组合计算出来的。'
- en: The SIV construction specification is more general than that of GCM. Instead
    of specifying detailed internals as with GCM’s GHASH, SIV simply tells you how
    to combine a cipher (**E**) and a pseudorandom function (**PRF**) to get an authenticated
    cipher. Specifically, you compute the tag *T* = **PRF**(*K*[1], *N* || *P*) and
    then compute the ciphertext *C* = **E**(*K*[2], *T*, *P*), where *T* acts as the
    nonce of **E**. Thus, SIV needs two keys (*K*[1] and *K*[2]) and a nonce (*N*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SIV的构造规范比GCM更为通用。与GCM的GHASH详细内部机制不同，SIV只是告诉你如何将一个加密器（**E**）和一个伪随机函数（**PRF**）结合起来得到一个认证加密器。具体来说，你计算标签*T*
    = **PRF**(*K*[1], *N* || *P*)，然后计算密文*C* = **E**(*K*[2], *T*, *P*)，其中*T*作为**E**的nonce。因此，SIV需要两个密钥（*K*[1]和*K*[2]）和一个nonce（*N*）。
- en: 'The major problem with SIV is that it’s not streamable: after computing *T*,
    it must keep the entire plaintext *P* in memory. In other words, in order to encrypt
    a 100GB plaintext with SIV, you must first store the 100GB of plaintext so that
    SIV encryption can read it.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SIV的主要问题在于它不能流式处理：计算完*T*之后，它必须将整个明文*P*保存在内存中。换句话说，要用SIV加密一个100GB的明文，你必须首先存储这100GB的明文，以便SIV加密可以读取它。
- en: The document RFC 5297, based on the 2006 paper “Deterministic Authenticated-Encryption”
    by Rogaway and Shrimpton, specifies SIV as using CMAC-AES (a MAC construction
    using AES) as a PRF and AES-CTR as a cipher. In 2015, a more efficient version
    of SIV was proposed, called GCM-SIV, that combines GCM’s fast GHASH function and
    SIV’s mode and is nearly as fast as GCM. Like the original SIV, however, GCM-SIV
    isn’t streamable. (For more information, see *[https://eprint.iacr.org/2015/102/](https://eprint.iacr.org/2015/102/)*.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于2006年Rogaway和Shrimpton的论文《确定性认证加密》（Deterministic Authenticated-Encryption），文档RFC
    5297规定SIV使用CMAC-AES（一种基于AES的MAC构造）作为PRF，并将AES-CTR作为加密器。2015年，提出了一种更高效的SIV版本，称为GCM-SIV，它结合了GCM的快速GHASH函数和SIV的模式，速度几乎与GCM一样。然而，像原始SIV一样，GCM-SIV也不能流式处理。（有关更多信息，请参见
    *[https://eprint.iacr.org/2015/102/](https://eprint.iacr.org/2015/102/)*。）
- en: Permutation-Based AEAD
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于置换的AEAD
- en: 'Now for a totally different approach to building an authenticated cipher: instead
    of building a mode of operation around a block cipher like AES, we’ll look at
    a cipher that builds a mode around a permutation. A permutation simply transforms
    an input to an output of the same size, reversibly, without using a key, that’s
    the simplest component imaginable. Better still, the resulting AEAD is fast, provably
    secure, and more resistant to nonce reuse than GCM and OCB.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一种完全不同的构建认证加密器的方法：我们不围绕像AES这样的块加密器来构建工作模式，而是看一种围绕置换构建工作模式的加密器。置换仅仅是将一个输入转换为一个与其大小相同的输出，且是可逆的，不使用密钥，这是最简单的组成部分。更好的是，得到的AEAD是快速的，具有可证明的安全性，并且比GCM和OCB对nonce重用的抵抗力更强。
- en: '[Figure 8-4](ch08.xhtml#ch8fig4) shows how a permutation-based AEAD works:
    from some fixed initial state *H*[0], you XOR the key *K* followed by the nonce
    *N* to the internal state, to obtain a new value of the internal state that is
    the same size as the original. You then transform the new state with **P** and
    get another new value of the state. Now you XOR the first plaintext block *P*[1]
    to the current state and take the resulting value as the first ciphertext block
    *C*[1], where *P*[1] and *C*[1] are equal in size but smaller than the state.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-4](ch08.xhtml#ch8fig4)展示了基于置换的AEAD是如何工作的：从某个固定的初始状态*H*[0]开始，你将密钥*K*和nonce*N*按顺序进行XOR操作，得到与原始状态大小相同的新状态。接着你用**P**变换新状态，并获得另一个新状态值。然后，你将第一个明文块*P*[1]与当前状态进行XOR操作，并将结果作为第一个密文块*C*[1]，其中*P*[1]和*C*[1]大小相等，但都比状态小。'
- en: To encrypt a second block, you transform the state with **P**, XOR the next
    plaintext block *P*[2] to the current state, and take the resulting value as *C*[2].
    You then iterate over all plaintext blocks and, following the last call to **P**,
    take bits from the internal state as the authentication tag *T*, as shown at the
    right of [Figure 8-4](ch08.xhtml#ch8fig4).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密第二个块，你需要用 **P** 变换当前状态，将下一个明文块 *P*[2] 与当前状态进行异或运算，然后将结果作为 *C*[2]。然后，你对所有明文块进行迭代，在最后一次调用
    **P** 后，从内部状态中提取比特作为认证标签 *T*，如 [图 8-4](ch08.xhtml#ch8fig4) 右侧所示。
- en: '![image](../images/f08-04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f08-04.jpg)'
- en: '*Figure 8-4: Permutation-based authenticated cipher*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：基于置换的认证加密算法*'
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The mode shown in [Figure 8-4](ch08.xhtml#ch8fig4) can be adapted to support
    associated data, but the process is a bit more complicated, so we’ll skip its
    description.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*如[图 8-4](ch08.xhtml#ch8fig4)所示的模式可以调整以支持关联数据，但过程稍微复杂，因此我们将跳过其描述。*'
- en: 'Designing permutation-based authenticated ciphers has certain requirements
    in order to ensure security. For one thing, note that you only XOR input values
    to a part of the state: the larger this part, the more control a successful attacker
    has on the internal state, and thus the lower the cipher’s security. Indeed, all
    security relies on the secrecy of the internal state.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设计基于置换的认证加密算法有一些要求，以确保安全性。首先，需要注意的是，你只能对部分状态进行异或操作：这一部分越大，成功攻击者对内部状态的控制越多，从而降低了算法的安全性。实际上，所有安全性都依赖于内部状态的保密性。
- en: Also, blocks must be padded properly with extra bits, in a way that ensures
    that any two different messages will yield different results. As a counterexample,
    if the last plaintext block is shorter than a complete block, it should not just
    be padded with zeroes; otherwise, a plaintext block of, say, two bytes (0000)
    would result in a complete plaintext block (0000 … 0000), as would a block of
    three bytes (000000). As a result, you’d get the same tag for both messages, although
    they differ in size.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，块必须适当地填充额外的位，以确保任何两个不同的消息都会产生不同的结果。作为反例，如果最后一个明文块小于完整块的大小，则不应仅用零填充；否则，一个两字节（0000）的明文块将变成完整的明文块（0000
    … 0000），而一个三字节（000000）的块也会变成相同的完整块。因此，尽管这两个消息的大小不同，你将得到相同的标签。
- en: What if a nonce is reused in such a permutation-based cipher? The good news
    is that the impact isn’t as bad as with GCM or OCB—the strength of the authentication
    tag won’t be compromised. If a nonce is repeated, a successful attacker would
    only be able to learn whether the two encrypted messages begin with the same value,
    as well as the length of this common value, or prefix. For example, although encrypting
    the two six-block messages *ABCXYZ* and *ABCDYZ* (each letter symbolizing a block
    here) with the same nonce might yield the two ciphertexts *JKLTUV* and *JKLMNO*,
    which have identical prefixes, attackers would not be able to learn that the two
    plaintexts shared the same final two blocks (*YZ*).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这种基于置换的加密算法中重用了一个随机数（nonce）会怎样？好消息是，影响没有 GCM 或 OCB 那么严重——认证标签的强度不会受到影响。如果随机数重复，成功的攻击者只能知道两个加密消息是否以相同的值开始，以及这个公共值或前缀的长度。例如，虽然使用相同的随机数加密两个六块的消息
    *ABCXYZ* 和 *ABCDYZ*（这里每个字母代表一个块）可能会得到相同前缀的密文 *JKLTUV* 和 *JKLMNO*，攻击者无法知道这两个明文共享相同的最后两个块
    (*YZ*)。
- en: In terms of performance, permutation-based ciphers offer the benefits of a single
    layer of operations, streamable processing, and the use of a single core algorithm
    for encryption and decryption. However, they are not parallelizable like GCM or
    OCB because new calls to **P** need to wait for the previous call to complete.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，基于置换的加密算法具有单层操作、可流处理以及加解密使用单一核心算法的优点。然而，它们不像 GCM 或 OCB 那样可以并行化，因为对 **P**
    的新调用需要等待前一个调用完成。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re tempted to pick your favorite permutation and make up your own authenticated
    cipher, don’t. You’re likely to get the details wrong and end up with an insecure
    cipher. Read the specifications written by experienced cryptographers for algorithms
    such as Keyak (an algorithm derived from Keccak) and NORX (designed by Philipp
    Jovanovic, Samuel Neves, and myself), and you’ll see that permutation-based ciphers
    are way more complex than they may first appear.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你有冲动选择你最喜欢的置换算法并自己制作认证密码，不要这么做。你很可能会弄错细节，最终得到一个不安全的密码。阅读由经验丰富的密码学家编写的算法规范，例如
    Keyak（一个源自 Keccak 的算法）和 NORX（由 Philipp Jovanovic、Samuel Neves 和我设计），你会发现基于置换的密码比它们初看起来要复杂得多。*'
- en: How Things Can Go Wrong
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误可能发生的情况
- en: Authenticated ciphers have a larger attack surface than hash functions or block
    ciphers because they aim to achieve both confidentiality *and* authenticity. They
    take several different input values, and must remain secure regardless of the
    input—whether that contains only associated data and no encrypted data, extremely
    large plaintexts, or different key sizes. They must also be secure for all nonce
    values against attackers who collect numerous message/tag pairs and, to some extent,
    against accidental repetition of nonces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 认证密码比哈希函数或分组密码有更大的攻击面，因为它们不仅要实现保密性 *和* 真实性。它们需要接受多个不同的输入值，并且必须在所有输入情况下保持安全——无论是仅包含关联数据而没有加密数据，还是非常大的明文，或者不同的密钥大小。它们还必须在所有随机数值下保持安全，抵御攻击者收集大量消息/标签对，并在一定程度上抵御随机数的意外重复。
- en: That’s a lot to ask, and as you’ll see next, even AES-GCM has several imperfections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的要求，正如你接下来将看到的那样，甚至 AES-GCM 也有几个缺陷。
- en: '*AES-GCM and Weak Hash Keys*'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AES-GCM 和弱哈希密钥*'
- en: 'One of AES-GCM’s weaknesses is found in its authentication algorithm GHASH:
    certain values of the hash key *H* greatly simplify attacks against GCM’s authentication
    mechanism. Specifically, if the value *H* belongs to some specific, mathematically
    defined subgroups of all 128-bit strings, attackers might be able to guess a valid
    authentication tag for some message simply by shuffling the blocks of a previous
    message.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM 的一个弱点存在于其认证算法 GHASH 中：某些哈希密钥 *H* 的值大大简化了对 GCM 认证机制的攻击。具体来说，如果 *H* 的值属于某些特定的、数学上定义的
    128 位字符串子群，攻击者可能通过重排前一条消息的块来猜测某条消息的有效认证标签。
- en: In order to understand this weakness, let’s look at how GHASH works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个弱点，让我们来看一下 GHASH 是如何工作的。
- en: GHASH Internals
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GHASH 内部结构
- en: As you saw in [Figure 8-2](ch08.xhtml#ch8fig2), GHASH starts with a 128-bit
    value, *H*, initially set to **AES**(*K*, 0), and then repeatedly computes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 8-2](ch08.xhtml#ch8fig2)中看到的，GHASH 从一个 128 位值 *H* 开始，初始值设为 **AES**(*K*,
    0)，然后反复计算
- en: '*X[i]* = (*X*[*i* − 1] ⊕ *C[i]*) ⊗ *H*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*X[i]* = (*X*[*i* − 1] ⊕ *C[i]*) ⊗ *H*'
- en: starting from *X*[0] = 0 and processing ciphertext blocks *C*[1], *C*[2], and
    so on. The final *X*[*i*] is returned by GHASH to compute the final tag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *X*[0] = 0 开始，处理密文块 *C*[1]、*C*[2] 等等。最终的 *X*[*i*] 由 GHASH 返回，用于计算最终标签。
- en: 'Now say for the sake of simplicity that all *C*[*i*] values are equal to 1,
    so that for any *i* we have this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了简化，假设所有的 *C*[*i*] 值都等于 1，那么对于任何 *i*，我们得到：
- en: '*C[i]* ⊗ = 1 ⊗ *H* = *H*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*C[i]* ⊗ = 1 ⊗ *H* = *H*'
- en: Next, from the GHASH equation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 GHASH 方程式出发：
- en: '*X[i]* = (*X*[i − 1] ⊕ *C[i]*) ⊗ *H*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*X[i]* = (*X*[i − 1] ⊕ *C[i]*) ⊗ *H*'
- en: we derive
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: '*X*[1] = (*X*[0] ⊕ *C*[1]) ⊕ *H* = (0 ⊕ 1) ⊗ *H* = *H*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[1] = (*X*[0] ⊕ *C*[1]) ⊕ *H* = (0 ⊕ 1) ⊗ *H* = *H*'
- en: 'substituting *X*[0] with 0 and *C*[1] with 1, to yield the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *X*[0] 替换为 0，*C*[1] 替换为 1，得到以下结果：
- en: (0 ⊕ 1) = 1
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (0 ⊕ 1) = 1
- en: Thanks to the distributive property of ⊗ over ⊕, we substitute *X* with *H*
    and *C*[2] with 1 and then compute the next value *X*[2] as
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于 ⊗ 在 ⊕ 上的分配律，我们将 *X* 替换为 *H*，并将 *C*[2] 替换为 1，然后计算下一个值 *X*[2] 如下：
- en: '*X*[2]= (*X*[1] ⊕ *X*[2]) ⊗ *H* = (*H* ⊕ 1) ⊗ *H* = *H*² ⊕ *H*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[2] = (*X*[1] ⊕ *X*[2]) ⊗ *H* = (*H* ⊕ 1) ⊗ *H* = *H*² ⊕ *H*'
- en: where *H*² is *H* squared, or *H* ⊗ *H*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *H*² 是 *H* 的平方，或 *H* ⊗ *H*。
- en: 'Now we derive *X*[3] by substituting *X*[2] for its derivation, and obtain
    the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过将 *X*[2] 的推导代入，得出 *X*[3]，并得到以下结果：
- en: '*X*[3] = (*X*[2] ⊕ *C*[3]) ⊗ *H* = (*H*² ⊕ *H* ⊕ 1) ⊗ *H* = *H*³ ⊕ *H*² ⊕ *H*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[3] = (*X*[2] ⊕ *C*[3]) ⊗ *H* = (*H*² ⊕ *H* ⊕ 1) ⊗ *H* = *H*³ ⊕ *H*² ⊕ *H*'
- en: 'Next, we derive *X*[4] to be *X*[4] = *H* ⁴ ⊕ *H* ³ ⊕ *H* ² ⊕ *H*, and so on,
    and eventually the last *X*[*i*] is this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们推导出 *X*[4] 为 *X*[4] = *H* ⁴ ⊕ *H* ³ ⊕ *H* ² ⊕ *H*，以此类推，最终最后的 *X*[*i*]
    为：
- en: '*X[n]* = *H^n* ⊕ *H*^(*n* − 1) ⊕ *H*^(*n* − 2) ⊕ … ⊕ *H*² ⊕ *H*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*X[n]* = *H^n* ⊕ *H*^(*n* − 1) ⊕ *H*^(*n* − 2) ⊕ … ⊕ *H*² ⊕ *H*'
- en: 'Remember that we set all blocks *C*[*i*] equal to 1\. If instead those values
    were arbitrary values, we would end up with the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将所有块*C*[*i*]设为1。如果这些值是任意的，我们将得到以下结果：
- en: '*X[n]* = *C*[1] ⊕ *H^n* ⊕ *C*[2] ⊕ *H*^(*n* − 1) ⊕ *C*[3] *H*^(*n* − 2) ⊕ …
    ⊕ *C*[*n* − 1] *H*² ⊕ *C*[*n*] ⊕ *H*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*X[n]* = *C*[1] ⊕ *H^n* ⊕ *C*[2] ⊕ *H*^(*n* − 1) ⊕ *C*[3] *H*^(*n* − 2) ⊕ …
    ⊕ *C*[*n* − 1] *H*² ⊕ *C*[*n*] ⊕ *H*'
- en: GHASH then would XOR the message’s length to this last *X*[*n*], multiply the
    result by *H*, and then XOR this value with **AES**(*K*, *N* || 0) to create the
    final authentication tag, *T*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，GHASH会将消息的长度异或到这个最后的*X*[*n*]，将结果乘以*H*，然后将这个值与**AES**(*K*, *N* || 0)进行异或，生成最终的认证标签*T*。
- en: Where Things Break
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题出现的地方
- en: 'What can go wrong from here? Let’s look first at the two simplest cases:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可能出什么问题呢？我们首先来看两个最简单的情况：
- en: If *H* = 0, then *X*[*n*] = 0 regardless of the *C*[*i*] values, and thus regardless
    of the message. That is, all messages will have the same authentication tag if
    *H* is 0.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*H* = 0，则*X*[*n*] = 0，无论*C*[*i*]的值如何，因而无论消息如何。也就是说，如果*H*为0，所有消息的认证标签将相同。
- en: If *H* = 1, then the tag is just an XOR of the ciphertext blocks, and reordering
    the ciphertext blocks will give the same authentication tag.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*H* = 1，则标签仅为密文块的异或值，重新排序密文块将得到相同的认证标签。
- en: Of course, 0 and 1 are only two values of 2^(128) possible values of *H*, so
    there is only a 2/2^(128) = 1/2^(127) chance of these occurring. But there are
    other weak values as well—namely, all values of *H* that belong to a *short cycle*
    when raised to *i*th powers. For example, the value *H* = 10d04d25f93556e69f58ce2f8d035a4
    belongs to a cycle of length five, as it satisfies *H* ⁵ = *H*, and therefore
    *H*^(*e*) = *H* for any *e* that is a multiple of five (the very definition of
    cycle with respect to fifth powers). Consequently, in the preceding expression
    of the final GHASH value *X*[*n*], swapping the blocks *C*[*n*] (multiplied to
    *H*) and the block *C*[*n* – 4] (multiplied to *H* ⁵) will leave the authentication
    tag unchanged, which amounts to a forgery. An attacker may exploit this property
    to construct a new message and its valid tag without knowing the key, which should
    be impossible for a secure authenticated cipher.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，0和1只是2^(128)中*H*的可能值中的两个，因此它们发生的概率仅为2/2^(128) = 1/2^(127)。但还有其他弱值——即，所有当*H*被提升到*i*次方时属于*短周期*的值。例如，值*H*
    = 10d04d25f93556e69f58ce2f8d035a4属于长度为五的周期，因为它满足*H* ⁵ = *H*，因此*H*^(*e*) = *H*，对于任何*e*是五的倍数的情况（这是关于五次方的周期的定义）。因此，在前面的最终GHASH值*X*[*n*]的表达式中，将块*C*[*n*]（与*H*相乘）和块*C*[*n*
    - 4]（与*H* ⁵相乘）交换，将不会改变认证标签，这相当于伪造。攻击者可能会利用这一性质，在不知情的情况下构造一个新的消息及其有效标签，而这是一个安全的认证密码所不应该允许的。
- en: The preceding example is based on a cycle of length five, but there are many
    cycles of greater length and therefore many values of *H* that are weaker than
    they should be. The upshot is that, in the unlikely case that *H* belongs to a
    short cycle of values and attackers can forge as many authentication tags as they
    want, unless they know *H* or *K*, they cannot determine *H*’s cycle length. So
    although this vulnerability can’t be exploited, it could have been avoided by
    more carefully choosing the polynomial used for modulo reductions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例基于一个长度为五的循环，但实际上有许多更长的循环，因此有许多值的*H*比应该的要弱。结果是，在极不可能的情况下，如果*H*属于一个短周期的值，并且攻击者可以伪造任意数量的认证标签，那么除非他们知道*H*或*K*，否则无法确定*H*的周期长度。因此，尽管这一漏洞无法被利用，但通过更仔细地选择用于模运算的多项式，本来是可以避免的。
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For further details on this attack, read “Cycling Attacks on GCM, GHASH and
    Other Polynomial MACs and Hashes” by Markku-Juhani O. Saarinen, available at*
    [https://eprint.iacr.org/2011/202/](https://eprint.iacr.org/2011/202/).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于此攻击的更多细节，请阅读Markku-Juhani O. Saarinen的《GCM、GHASH和其他多项式MAC和哈希的循环攻击》，可在* [https://eprint.iacr.org/2011/202/](https://eprint.iacr.org/2011/202/)
    获得。'
- en: '*AES-GCM and Small Tags*'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AES-GCM和小标签*'
- en: In practice, AES-GCM usually returns 128-bit tags, but it can produce tags of
    any length. Unfortunately, when shorter tags are used, the probability of forgery
    increases significantly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，AES-GCM通常返回128位的标签，但它可以生成任意长度的标签。不幸的是，当使用较短的标签时，伪造的概率会显著增加。
- en: When a 128-bit tag is used, an attacker who attempts a forgery should succeed
    with a probability of 1/2^(128) because there are 2^(128) possible 128-bit tags.
    (Generally, with an *n*-bit tag, the probability of success should be 1/2^(*n*),
    where 2^(*n*) is the number of possible values of an *n*-bit tag.) But when shorter
    tags are used, the probability of forgery is much higher than 1/2^(*n*) due to
    weaknesses in the structure of GCM that are beyond the scope of this discussion.
    For example, a 32-bit tag will allow an attacker who knows the authentication
    tag of some 2MB message to succeed with a chance of 1/2^(16) instead of 1/2^(32).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用128位标签时，尝试伪造的攻击者成功的概率应该是1/2^(128)，因为存在2^(128)种可能的128位标签。（通常，对于*n*位标签，成功的概率应该是1/2^(*n*)，其中2^(*n*)是*n*位标签的可能值数。）但是，当使用较短的标签时，由于GCM结构中的一些弱点（这超出了本讨论的范围），伪造的概率远高于1/2^(*n*)。例如，32位标签将允许一个知道某2MB消息的认证标签的攻击者以1/2^(16)的概率成功，而不是1/2^(32)。
- en: Generally, with *n*-bit tags, the probability of forgery isn’t 1/2^(*n*) but
    rather 2^(*m*)/2^(*n*), where 2^(*m*) is the number of blocks of the longest message
    for which a successful attacker observed the tag. For example, if you use 48-bit
    tags and process messages of 4GB (or 2^(28) blocks of 16 bytes each), the probability
    of a forgery will be 2^(28)/2^(48) = 1/2^(20), or about one chance in a million.
    That’s a relatively high chance as far as cryptography is concerned. (For more
    information on this attack, see the 2005 paper “Authentication Weaknesses in GCM”
    by Niels Ferguson.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于*n*位标签，伪造的概率不是1/2^(*n*)，而是2^(*m*)/2^(*n*)，其中2^(*m*)是成功攻击者观察到标签的最长消息的块数。例如，如果你使用48位标签并处理4GB的消息（即2^(28)个16字节的块），那么伪造的概率将是2^(28)/2^(48)
    = 1/2^(20)，大约是一百万分之一。这对于密码学来说是一个相对较高的概率。（有关这种攻击的更多信息，请参阅尼尔斯·弗格森（Niels Ferguson）在2005年发表的论文《GCM中的认证弱点》）
- en: Further Reading
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about authenticated ciphers, visit the home page of CAESAR, the
    Competition for Authenticated Encryption: Security, Applicability, and Robustness
    (*[http://competitions.cr.yp.to/caesar.html](http://competitions.cr.yp.to/caesar.html)*).
    Begun in 2012, CAESAR is a crypto competition in the style of the AES and SHA-3
    competitions, though it isn’t organized by NIST.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于认证密码的信息，请访问CAESAR的主页，认证加密竞赛：安全性、适用性和健壮性（*[http://competitions.cr.yp.to/caesar.html](http://competitions.cr.yp.to/caesar.html)*）。CAESAR自2012年开始，是一场类似于AES和SHA-3竞赛的密码竞赛，尽管它并非由NIST组织。
- en: 'The CAESAR competition has attracted an impressive number of innovative designs:
    from OCB-like modes to permutation-based modes, as well as new core algorithms.
    Examples include the previously mentioned NORX and Keyak permutation-based authenticated
    ciphers; AEZ (as in AEasy), which is built on a nonstreamable two-layer mode that
    makes it misuse resistant; AEGIS, a beautifully simple authenticated cipher that
    leverages AES’s round function.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: CAESAR竞赛吸引了大量创新设计：从类似OCB的模式到基于置换的模式，以及新的核心算法。举例来说，包括前面提到的基于置换的认证密码NORX和Keyak；AEZ（如AEasy），它建立在一种不可流式化的两层模式上，使其具有抗滥用能力；AEGIS，一种简单美观的认证密码，利用了AES的轮函数。
- en: In this chapter, I’ve focused on GCM, but a handful of other modes are used
    in real applications as well. Specifically, the counter with CBC-MAC (CCM) and
    EAX modes competed with GCM for standardization in the early 2000s, and although
    GCM was selected, the two competitors are used in a few applications. For example,
    CCM is used in the WPA2 Wi-Fi encryption protocol. You may want to read these
    ciphers’ specifications and review their relative security and performance merits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我集中讨论了GCM，但实际上还有一些其他模式在实际应用中也有使用。具体来说，带CBC-MAC的计数器模式（CCM）和EAX模式在2000年代初期曾与GCM竞争标准化，尽管GCM最终被选中，但这两种竞争者仍在一些应用中使用。例如，CCM用于WPA2
    Wi-Fi加密协议。你可能想要阅读这些密码的规范，并回顾它们在安全性和性能上的相对优劣。
- en: This concludes our discussion of symmetric-key cryptography! You’ve seen block
    ciphers, stream ciphers, (keyed) hash functions, and now authenticated ciphers—or
    all the main cryptography components that work with a symmetric key, or no key
    at all. Before we move to *asymmetric* cryptography, [Chapter 9](ch09.xhtml#ch9)
    will focus more on computer science and math, to provide background for asymmetric
    schemes such as RSA ([Chapter 10](ch10.xhtml#ch10)) and Diffie–Hellman ([Chapter
    11](ch11.xhtml#ch11)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于对称密钥加密的讨论！你已经了解了分组密码、流密码、（带密钥的）哈希函数，以及现在的认证密码——这些都是与对称密钥或完全不使用密钥的主要加密组件。在我们进入*非对称*加密之前，[第9章](ch09.xhtml#ch9)将更多地聚焦于计算机科学和数学，为RSA（[第10章](ch10.xhtml#ch10)）和Diffie–Hellman（[第11章](ch11.xhtml#ch11)）等非对称方案提供背景知识。
