- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 MAPS AND GEOSPATIAL DATA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When I first started learning R, I considered it a tool for working with numbers,
    not shapes, so I was surprised when I saw people using it to make maps. For example,
    developer Abdoul Madjid used R to make a map that visualizes rates of COVID-19
    in the United States in 2021.
  prefs: []
  type: TYPE_NORMAL
- en: You might think you need specialized mapmaking software like ArcGIS to make
    maps, but it’s an expensive tool. And while Excel has added support for mapmaking
    in recent years, its features are limited (for example, you can’t use it to make
    maps based on street addresses). Even QGIS, an open source tool similar to ArcGIS,
    still requires learning new skills.
  prefs: []
  type: TYPE_NORMAL
- en: Using R for mapmaking is more flexible than using Excel, less expensive than
    using ArcGIS, and based on syntax you already know. It also lets you perform all
    of your data manipulation tasks with one tool and apply the principles of high-quality
    data visualization discussed in [Chapter 2](chapter2.xhtml). In this chapter,
    you’ll work with simple features of geospatial data and examine Madjid’s code
    to understand how he created this map. You’ll also learn where to find geospatial
    data and how to use it to make your own maps.
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Primer on Geospatial Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You don’t need to be a GIS expert to make maps, but you do need to understand
    a few things about how geospatial data works, starting with its two main types:
    vector and raster. *Vector* data uses points, lines, and polygons to represent
    the world. *Raster* data, which often comes from digital photographs, ties each
    pixel in an image to a specific geographic location. Vector data tends to be easier
    to work with, and you’ll be using it exclusively in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, working with geospatial data meant mastering competing standards,
    each of which required learning a different approach. Today, though, most people
    use the *simple features* model (often abbreviated as *sf*) for working with vector
    geospatial data, which is easier to understand. For example, to import simple
    features data about the state of Wyoming, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can look at the data like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output has two columns, one for the state name (NAME) and another called
    geometry. This data looks like the data frames you’ve seen before, aside from
    two major differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are five lines of metadata above the data frame. At the top is
    a line stating that the data contains one feature and one field. A *feature* is
    a row of data, and a *field* is any column containing nonspatial data. Second,
    the simple features data contains geographical data in a variable called geometry.
    Because the geometry column must be present for a data frame to be geospatial
    data, it isn’t counted as a field. Let’s look at each part of this simple features
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The Geometry Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *geometry type* represents the shape of the geospatial data you’re working
    with and is typically shown in all caps. In this case, the relatively simple POLYGON
    type represents a single polygon. You can use ggplot to display this data by calling
    geom_sf(), a special geom designed to work with simple features data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-1](chapter4.xhtml#fig4-1) shows the resulting map of Wyoming. It
    may not look like much, but I wasn’t the one who made Wyoming a nearly perfect
    rectangle!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: A map of Wyoming generated using POLYGON simple features data'
  prefs: []
  type: TYPE_NORMAL
- en: Other geometry types used in simple features data include POINT, to display
    elements such as a pin on a map that represents a single location. For example,
    the map in [Figure 4-2](chapter4.xhtml#fig4-2) uses POINT data to show a single
    electric vehicle charging station in Wyoming.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A map of Wyoming containing POINT simple features data'
  prefs: []
  type: TYPE_NORMAL
- en: The LINESTRING geometry type is for a set of points that can be connected with
    lines and is often used to represent roads. [Figure 4-3](chapter4.xhtml#fig4-3)
    shows a map that uses LINESTRING data to represent a section of US Highway 30
    that runs through Wyoming.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: A road represented using LINESTRING simple features data'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these geometry types has a MULTI variation (MULTIPOINT, MULTI LINESTRING,
    and MULTIPOLYGON) that combines multiple instances of the type in one row of data.
    For example, [Figure 4-4](chapter4.xhtml#fig4-4) uses MULTIPOINT data to show
    all electric vehicle charging stations in Wyoming.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: Using MULTIPOINT data to represent multiple electric vehicle charging
    stations'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you can use MULTILINESTRING data to show not just one road but all
    major roads in Wyoming ([Figure 4-5](chapter4.xhtml#fig4-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Using MULTILINESTRING data to represent several roads'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you could use MULTIPOLYGON data, for example, to depict a state made
    up of multiple polygons. The following data represents the 23 counties in the
    state of Wyoming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see on the second line, the geometry type of this data is MULTIPOLYGON.
    In addition, the repeated MULTIPOLYGON text in the geometry column indicates that
    each row contains a shape of type MULTIPOLYGON. [Figure 4-6](chapter4.xhtml#fig4-6)
    shows a map made with this data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: A map of Wyoming counties'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the map is made up entirely of polygons.
  prefs: []
  type: TYPE_NORMAL
- en: The Dimensions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, the geospatial data frame contains the data’s *dimensions*, or the type
    of geospatial data you’re working with. In the Wyoming example, it looks like
    Dimension: XY, meaning the data is two-dimensional, as in the case of all the
    geospatial data used in this chapter. There are two other dimensions (Z and M)
    that you’ll see much more rarely. I’ll leave them for you to investigate further.'
  prefs: []
  type: TYPE_NORMAL
- en: The Bounding Box
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The penultimate element in the metadata is the *bounding box*, which represents
    the smallest area in which you can fit all of your geospatial data. For the wyoming
    object, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The ymin value of 40.99475 and ymax value of 45.0059 represent the lowest and
    highest latitudes, respectively, that the state’s polygon can fit into. The x-values
    do the same for the longitude. Bounding boxes are calculated automatically, and
    typically you don’t have to worry about altering them.
  prefs: []
  type: TYPE_NORMAL
- en: The Coordinate Reference System
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last piece of metadata specifies the *coordinate reference system* used
    to project the data when it’s plotted. The challenge with representing any geospatial
    data is that you’re displaying information about the three-dimensional Earth on
    a two-dimensional map. Doing so requires choosing a coordinate reference system
    that determines what type of correspondence, or *projection*, to use when making
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data for the Wyoming counties map includes the line Geodetic CRS: WGS 84,
    indicating the use of a coordinate reference system known as *WGS84*. To see a
    different projection, check out the same map using the *Albers equal-area conic
    convenience projection*. While Wyoming looked perfectly horizontal in [Figure
    4-6](chapter4.xhtml#fig4-6), the version in [Figure 4-7](chapter4.xhtml#fig4-7)
    appears to be tilted.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: A map of Wyoming counties using the Albers equal-area conic convenience
    projection'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re wondering how to change projections when making maps of your own,
    fear not: you’ll see how to do this when we look at Madjid’s map in the next section.
    And if you want to know how to choose appropriate projections for your maps, check
    out “Using Appropriate Projections” on [page 81](#pg_81).'
  prefs: []
  type: TYPE_NORMAL
- en: The geometry Column
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to the metadata, simple features data differs from traditional
    data frames in another respect: its geometry column. As you might have guessed
    from the name, this column holds the data needed to draw the maps.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, consider the connect-the-dots drawings you probably
    completed as a kid. As you added lines to connect one point to the next, the subject
    of your drawing became clearer. The geometry column is similar. It has a set of
    numbers, each of which corresponds to a point. If you’re using LINESTRING/MULTILINESTRING
    or POLYGON/MULTIPOLYGON simple features data, ggplot uses the numbers in the geometry
    column to draw each point and then adds lines to connect the points. If you’re
    using POINT/MULTIPOINT data, it draws the points but doesn’t connect them.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, thanks to R, you never have to worry about these details or look
    in any depth at the geometry column.
  prefs: []
  type: TYPE_NORMAL
- en: Re-creating the COVID-19 Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand the basics of geospatial data, let’s walk through the
    code Madjid used to make his COVID-19 map. Shown in [Figure 4-8](chapter4.xhtml#fig4-8),
    it makes use of the geometry types, dimensions, bounding boxes, projections, and
    the geometry column just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: Abdoul Madjid’s map of COVID-19 in the United States in 2021'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve made some small modifications to the code to make the final map fit on
    the page. You’ll begin by loading a few packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The albersusa package will give you access to geospatial data. Install it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can install all of the other packages using the standard install .packages()
    code. You’ll use the tidyverse to import data, manipulate it, and plot it with
    ggplot. The sf package will enable you to change the coordinate reference system
    and use an appropriate projection for the data. The zoo package has functions
    for calculating rolling averages, and the colorspace package gives you a color
    scale that highlights the data well.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, you’ll import the data you need: COVID-19 rates by state over time, state
    populations, and geospatial information. Madjid imported each of these pieces
    of data separately and then merged them, and you’ll do the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The COVID-19 data comes directly from the *New York Times*, which publishes
    daily case rates by state as a CSV file on its GitHub account. To import it, enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Federal Information Processing Standards (FIPS) are numeric codes used to represent
    states, but you’ll reference states by their names instead, so the line select(-fips)
    drops the fips variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at this data, you can see the arrival of the first COVID-19 cases in
    the United States in January 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Madjid’s map shows per capita rates (the rates per 100,000 people) rather than
    absolute rates (the rates without consideration for a state’s population). So,
    to re-create his maps, you also need to obtain data on each state’s population.
    Download this data as a CSV as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code imports the data, keeps the State and Pop (population) variables,
    and saves the data as an object called usa_states. Here’s what usa_states looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, import the geospatial data and save it as an object called usa_states_geom
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The usa_sf() function from the albersusa package gives you simple features data
    for all US states. Conveniently, it places Alaska and Hawaii at a position and
    scale that make them easy to see. This data includes multiple variables, but because
    you need only the state names, this code keeps just the name variable.
  prefs: []
  type: TYPE_NORMAL
- en: The st_transform() function from the sf package changes the coordinate reference
    system. The one used here comes from the us_laea_proj object in the albersusa
    package. This is the Albers equal-area conic convenience projection you used earlier
    to change the appearance of the Wyoming counties map.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Daily COVID-19 Cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The covid_data data frame lists cumulative COVID-19 cases by state, but not
    the number of cases per day, so the next step is to calculate that number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The group_by() function calculates totals for each state, then creates a new
    variable called pd_cases, which represents the number of cases in the previous
    day (the lag() function is used to assign data to this variable) ❶. Some days
    don’t have case counts for the previous day, so set this value to 0 using the
    replace_na() function ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, this code creates a new variable called daily_cases ❸. To set the value
    of this variable, use the case_when() function to create a condition: if the cases
    variable (which holds the cases on that day) is greater than the pd_cases variable
    (which holds cases from one day prior), then daily_cases is equal to cases minus
    pd_cases. Otherwise, you set daily_cases to be equal to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, because you grouped the data by state at the beginning of the code,
    now you need to remove this grouping using the ungroup() function before arranging
    the data by state and date ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the resulting covid_cases data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, you’ll make use of the new daily_cases variable.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Incidence Rates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’re not quite done calculating values. The data that Madjid used to make
    his map didn’t include daily case counts. Instead, it contained a five-day rolling
    average of cases per 100,000 people. A *rolling average* is the average case rate
    in a certain time period. Quirks of reporting (for example, not reporting on weekends
    but instead rolling Saturday and Sunday cases into Monday) can make the value
    for any single day less reliable. Using a rolling average smooths out these quirks.
    Generate this data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new data frame called covid_cases_rm (where *rm* stands
    for rolling mean). The first step in its creation is to use the rollmean() function
    from the zoo package to create a roll_cases variable, which holds the average
    number of cases in the five-day period surrounding a single date. The k argument
    is the number of days for which you want to calculate the rolling average (5,
    in this case), and the fill argument determines what happens in cases like the
    first day, where you can’t calculate a five-day rolling mean because there are
    no days prior to this day (Madjid set these values to NA).
  prefs: []
  type: TYPE_NORMAL
- en: 'After calculating roll_cases, you need to calculate per capita case rates.
    To do this, you need population data, so join the population data from the usa_states
    data frame with the covid_cases data like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To drop rows with missing population data, you call the drop_na() function with
    the Pop variable as an argument. In practice, this removes several US territories
    (American Samoa, Guam, the Northern Mariana Islands, and the Virgin Islands).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you create a per capita case rate variable called incidence_rate by multiplying
    the roll_cases variable by 100,000 and then dividing it by the population of each
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than keeping raw values (for example, on June 29, 2021, Florida had
    a rate of 57.77737 cases per 100,000 people), you use the cut() function to convert
    the values into categories: values of >0 (greater than zero), values of >5 (greater
    than five), and values of >50 (greater than 50).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to filter the data so it includes only 2021 data (the only
    year depicted in Madjid’s map) and then select just the variables (state, date,
    and incidence_rate) you’ll need to create the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the final covid_cases_rm data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You now have a data frame that you can combine with your geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Geospatial Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve used two of the three data sources (COVID-19 case data and state population
    data) to create the covid_cases_rm data frame you’ll need to make the map. Now
    it’s time to use the third data source: the geospatial data you saved as usa_states_geom.
    Simple features data allows you to merge regular data frames and geospatial data
    (another point in its favor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code merges the covid_cases_rm data frame into the geospatial data, matching
    the name variable from usa_states_geom to the state variable in covid_cases_rm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you create a new variable called fancy_date to format the date nicely
    (for example, Jan. 01 instead of 2021-01-01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The format() function does the formatting, while the fct_inorder() function
    makes the fancy_date variable sort data by date (rather than, say, alphabetically,
    which would put August before January). Last, the relocate() function puts the
    fancy_date column next to the date column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this data frame as usa_states_geom_covid and take a look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can see the metadata and geometry columns discussed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It took a lot of work to end up with the surprisingly simple usa_states_geom_covid
    data frame. While the data may be simple, the code Madjid used to make his map
    is quite complex. This section walks you through it in pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final map is actually multiple maps, one for each day in 2021\. Combining
    365 days makes for a large final product, so instead of showing the code for every
    single day, filter the usa_states_geom_covid to show just the first six days in
    January:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the result as a data frame called usa_states_geom_covid_six_days. Here’s
    what this data looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Madjid’s map is giant, as it includes all 365 days. The size of a few elements
    have been changed so that they fit in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Basic Map
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With your six days of data, you’re ready to make some maps. Madjid’s mapmaking
    code has two main parts: generating the basic map, then tweaking its appearance.
    First, you’ll revisit the three lines of code used to make the Wyoming maps, with
    some adornments to improve the quality of the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The geom_sf() function plots the geospatial data, modifying a couple of arguments:
    size = .05 makes the state borders less prominent and color = "grey55" sets them
    to a medium-gray color. Then, the facet_wrap() function is used for the faceting
    (that is, to make one map for each day). The vars(fancy_date) code specifies that
    the fancy_date variable should be used for the faceted maps, and strip.position
    = "bottom" moves the labels Jan. 01, Jan. 02, and so on to the bottom of the maps.
    [Figure 4-9](chapter4.xhtml#fig4-9) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: A map showing the incidence rate of COVID-19 for the first six
    days of 2021'
  prefs: []
  type: TYPE_NORMAL
- en: Having generated the basic map, now you’ll make it look good.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Data Visualization Principles
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'From now on, all of the code that Madjid uses is to improve the appearance
    of the maps. Many of the tweaks shown here should be familiar if you’ve read [Chapter
    2](chapter2.xhtml), highlighting a benefit of making maps with ggplot: you can
    apply the same data visualization principles you learned about when making charts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The scale_fill_discrete_sequential() function, from the colorspace package,
    sets the color scale. This code uses the rocket palette (the same palette that
    Cédric Scherer and Georgios Karamanis used in [Chapter 2](chapter2.xhtml)) and
    changes the legend title to “COVID-19 INCIDENCE RATE.” The guide_legend() function
    adjusts the position, alignment, and text properties of the title. The code then
    puts the colored squares in one row, adjusts their height and width, and tweaks
    the text properties of the labels (>0, >5, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the labs() function adds a title and caption. Following theme _minimal(),
    the theme() function makes some design tweaks, including setting the font and
    text color; making the title and caption bold; and adjusting their size, alignment,
    and margins. The code then adjusts the size of the strip text (Jan. 01, Jan. 02,
    and so on) and makes it bold, puts the legend at the top of the maps, and adds
    a bit of spacing around it. Grid lines, as well as the longitude and latitude
    lines, are removed, and then the entire visualization gets a bit of padding and
    a light gray background.
  prefs: []
  type: TYPE_NORMAL
- en: There you have it! [Figure 4-10](chapter4.xhtml#fig4-10) shows the re-creation
    of his COVID-19 map.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: The re-creation of Abdoul Madjid’s map'
  prefs: []
  type: TYPE_NORMAL
- en: From data import and data cleaning to analysis and visualization, you’ve seen
    how Madjid made a beautiful map in R.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Own Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may now be wondering, *Okay, great, but how do I actually make my own maps?*
    In this section you’ll learn where you can find geospatial data, how to choose
    a projection, and how to prepare the data for mapping.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to access simple features geospatial data. The first is to
    import raw data, and the second is to access it with R functions.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Raw Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Geospatial data can come in various formats. While ESRI shapefiles (with the
    *.shp* extension) are the most common, you might also encounter GeoJSON files
    (*.geojson*) like the ones we used in the Wyoming example at the beginning of
    this chapter, KML files (*.kml*), and others. [Chapter 8](chapter8.xhtml) of *Geocomputation
    with R* by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow discusses this range
    of formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that a single function can read pretty much any type of geospatial
    data: read_sf() from the sf package. Say you’ve downloaded geospatial data about
    US state boundaries from the website *geojson.xyz* in GeoJSON format, then saved
    it in the *data* folder as *states.geojson*. To import this data, use the read_sf()
    function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The dsn argument (which stands for *data source name*) tells read_sf() where
    to find the file. You save the data as the object us_states.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Geospatial Data with R Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you’ll have to work with raw data in this way, but not always. That’s
    because certain R packages provide functions for accessing geospatial data. Madjid
    used the usa_sf() function from the albersusa package to acquire his data. Another
    package for accessing geospatial data related to the United States, tigris, has
    a number of well-named functions for different types of data. For example, load
    the tigris package and run the states() function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The cb = TRUE argument opts out of using the most detailed shapefile and sets
    the resolution to a more manageable 20m (1:20 million). Without these changes,
    the resulting shapefile would be large and slow to work with. Setting progress_bar
    = FALSE hides the messages that tigris generates as it loads data. The result
    is saved as states_tigris. The tigris package has functions to get geospatial
    data about counties, census tracts, roads, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re looking for data outside the United States, the rnaturalearth package
    provides functions for importing geospatial data from across the world. For example,
    use ne_countries() to retrieve geospatial data about various countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses two arguments: returnclass = "sf" to get data in simple features
    format, and continent = "Africa" to get only countries on the African continent.
    If you save the result to an object called africa_countries, you can plot the
    data on a map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-11](chapter4.xhtml#fig4-11) shows the resulting map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-11: A map of Africa made with data from the rnaturalearth package'
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t find an appropriate package, you can always fall back on using
    read_sf() from the sf package.
  prefs: []
  type: TYPE_NORMAL
- en: Using Appropriate Projections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have access to geospatial data, you need to decide which projection
    to use. If you’re looking for a simple answer to this question, you’ll be disappointed.
    As *Geocomputation with R* puts it, “The question of *which* CRS [to use] is tricky,
    and there is rarely a ‘right’ answer.”
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re overwhelmed by the task of choosing a projection, the crsuggest package
    from Kyle Walker can give you ideas. Its suggest_top_crs() function returns a
    coordinate reference system that is well suited for your data. Load crsuggest
    and try it out on your africa_countries data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The suggest_top_crs() function should return projection number 28232. Pass
    this value to the st_transform() function to change the projection before you
    plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When run, this code generates the map in [Figure 4-12](chapter4.xhtml#fig4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-12: A map of Africa made with projection number 28232'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you’ve successfully mapped Africa with a different projection.
  prefs: []
  type: TYPE_NORMAL
- en: Wrangling Geospatial Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ability to merge traditional data frames with geospatial data is a huge
    benefit of working with simple features data. Remember that for his COVID-19 map,
    Madjid analyzed traditional data frames before merging them with geospatial data.
    But because simple features data acts just like traditional data frames, you can
    just as easily apply the data-wrangling and analysis functions from the tidyverse
    directly to a simple features object. To see how this works, revisit the africa_countries
    simple features data and select two variables (name and pop_est) to see the name
    and population of the countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you want to make a map showing which African countries have populations
    larger than 20 million. First, you’ll need to calculate this value for each country.
    To do so, use the mutate() and if_else() functions, which will return TRUE if
    a country’s population is over 20 million and FALSE otherwise, and then store
    the result in a variable called population_above_20_million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then take this code and pipe it into ggplot, setting the fill aesthetic
    property to be equal to population_above_20_million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code generates the map shown in [Figure 4-13](chapter4.xhtml#fig4-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-13: A map of Africa highlighting countries with populations above
    20 million people'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a basic example of the data wrangling and analysis you can perform
    on simple features data. The larger lesson is this: any skill you’ve developed
    for working with data in R will serve you well when working with geospatial data.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this short romp through the world of mapmaking in R, you learned the basics
    of simple features geospatial data, reviewed how Abdoul Madjid applied this knowledge
    to make his map, explored how to get your own geospatial data, and saw how to
    project it appropriately to make your own maps.
  prefs: []
  type: TYPE_NORMAL
- en: R may very well be the best tool for making maps. It also lets you use the skills
    you’ve developed for working with traditional data frames and the ggplot code
    to make your visualizations look great. After all, Madjid isn’t a GIS expert,
    but he combined a basic understanding of geospatial data, fundamental R skills,
    and knowledge of data visualization principles to make a beautiful map. Now it’s
    your turn to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kieran Healy, “Draw Maps,” in *Data Visualization: A Practical Introduction*
    (Princeton, NJ: Princeton University Press, 2018), *[https://socviz.co](https://socviz.co)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Andrew Heiss, “Lessons on Space from Data Visualization: Use R, ggplot2, and
    the Principles of Graphic Design to Create Beautiful and Truthful Visualizations
    of Data,” online course, last updated July 11, 2022, *[https://datavizs22.classes.andrewheiss.com/content/12-content/](https://datavizs22.classes.andrewheiss.com/content/12-content/)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robin Lovelace, Jakub Nowosad, and Jannes Muenchow, *Geocomputation with R*
    (Boca Raton, FL: CRC Press, 2019), *[https://r.geocompx.org](https://r.geocompx.org)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kyle Walker, *Analyzing US Census Data: Methods, Maps, and Models in R* (Boca
    Raton, FL: CRC Press, 2013).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
