- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 7 SELECTING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we looked at the sorting problem, and here we’ll consider
    a related problem with many similar algorithms: *selection*. The basic situation
    is given a number *k* and an array with *n* items, we want to find the value at
    the array’s *k*th place if we ordered the array. But we don’t actually need the
    array to be sorted; we just need to know its *k*th element. Unlike the sorting
    problem, JavaScript doesn’t provide a “ready-made” solution for selection, so
    if you’re in need of this kind of function, you’ll have to use some of the algorithms
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way this problem relates to sorting is simple: if you just sort the list
    of values (using any of the algorithms in the previous chapter), you can quickly
    produce the *k*th value of the sorted list for all possible values of *k*; you
    just look at the *k*th place in the sorted array. That would be a good solution
    if you actually needed to make many selections from the same array; an *O*(*n*
    log *n*) sort followed by many *O*(1) selections. However, there’s no requirement
    to actually sort the list, and we’ll try to avoid doing that. The selection algorithms
    that we’ll explore in this chapter perform better than sorting algorithms because
    they don’t need to sort everything.'
  prefs: []
  type: TYPE_NORMAL
- en: In the selection problem, if you ask for *k* = 1, you’re asking for the minimum
    of the list; *k* = *n* asks for the maximum, and *k* = *n*/2 asks for the median.
    Keep in mind that in “real life” *k* goes from 1 to *n*, but because of JavaScript’s
    0-based arrays, *k* goes from 0 to one less than the array’s length.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Formally, if the list of values is of even length, the definition of median
    would ask for the average of the two center values of the sorted array, but we’re
    not doing that. In order for your selection code to produce the median of arrays
    with even length, you’d need to call the selection algorithm twice to get the
    two center values and only then calculate their mean. We’ll just deal with the
    problem of finding the value at any given position.*'
  prefs: []
  type: TYPE_NORMAL
- en: Selection Without Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the same way you could implement sorting without comparisons (meaning you
    never have to compare one key with another), you can use variations of the bitmap
    and counting sorting methods to find the *k*th value of a list quickly, without
    even attempting a partial sort of the data. Remember that these algorithms are
    limited; they work only for numbers (not key + data of any kind) and preferably
    numbers in a not very extensive range.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap Selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitmap sort worked by reading all data and setting bits on in a bitmap;
    after that, outputting the sorted numbers just required walking through the bitmap.
    You’ll do the same here, except you won’t output all numbers; you need only the
    *k*th value in the bitmap. [Figure 7-1](chapter7.xhtml#fig7-1) shows the method;
    assume you want to find the 4th element in the same array used as an example in
    [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: A variation of bitmap sort allows a fast selection algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: First generate the bitmap and then traverse it looking for the 4th set bit,
    which in this case corresponds to 27.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The parameters for this algorithm are the same as when sorting ❶ with the addition
    of k, the place of interest. The logic to create the bitmap ❷ is exactly the same
    as for sorting; the only difference comes in the final output ❸. Set a counter
    j to the first position in the array, and every time you find a set bit ❹, test
    whether j reached the desired place at k ❺; if so, you’re done ❻. Otherwise, keep
    looping, after counting one more found number ❼.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is obviously *O*(*n*), and if it weren’t for the limitations
    mentioned earlier, it would be one of the best for solving the selection problem.
  prefs: []
  type: TYPE_NORMAL
- en: Counting Selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Under the same circumstances as for bitmap sort, in [Chapter 6](chapter6.xhtml)
    we considered the counting sort, which didn’t have issues if numbers were repeated
    in the input. This situation, however, was a problem when using a bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the same kind of solution here: go through the array, generate
    the list of counts, and finish by going through the counts from left to right
    until you find what value is at the *k*th place.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example using the same numbers from [Chapter 6](chapter6.xhtml)
    (see [Figure 7-2](chapter7.xhtml#fig7-2)); you want to find the value at the 4th
    place in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: Counting sort also provides a simple selection algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: First find all the counts and then sum through them, from left to right, until
    the sum equals or exceeds 4; in this case, that happens at value 50 when the accumulated
    sum goes from 3 to 5\. (Keep in mind the case where the sum exceeds *k* because
    of repeated values in the input array.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The parameters are the same as earlier ❶, and all the logic to generate the
    counts ❷ is the same as in [Chapter 6](chapter6.xhtml). The changes appear when
    preparing output. First initialize a counter j at the first position of the input
    array ❸, and every time you find a nonzero count ❹, update the counter ❺ and see
    whether you reached or passed *k* with that sum. If so, return the corresponding
    value ❻; otherwise, just keep looping.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have an *O*(*n*) algorithm, but we want to be able to handle more
    general conditions, so let’s move on to selection algorithms based on key-to-key
    comparisons that will work in every case.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting with Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most algorithms for the selection problem are based on sorting algorithms.
    The first one we’ll explore is based on selection sort, but we won’t sort the
    whole array—just its first *k* values. Selection sort works by finding the minimum
    of the array and exchanging it with the value at the first place; then it looks
    for the minimum of the remaining values and exchanges it with the value at the
    second place, and so on, until the whole array is sorted. We’ll do the same, but
    stop after finding the *k*th minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The parameters for this algorithm are the same as before ❶. We made a small
    change in the loop. When sorting, you went through the entire array, but now you’ll
    stop after having reached the *k*th place ❷. The rest of the logic is exactly
    the same as for the sorting algorithm, except that you return the desired value
    instead of the sorted array ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of this algorithm is *O*(*kn*), which is an efficient result
    for low values of *k* and an asymptotically bad one if *k* grows and is proportional
    to *n*. (See question 7.3 for a unique case.) In particular, if you want to find
    the middle element of the array, then *k* = *n* / 2 and performance becomes *O*(*n*²);
    you’ll do better with different algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Quickselect Family
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many selection algorithms are derived from the quicksort code, in particular,
    the way it partitions an array in relation to a pivot, moving values around so
    that the array ends up consisting of values lower than the pivot on one side,
    then the pivot itself, and values greater than the pivot on the other side. In
    the case of quicksort, after partitioning the array this way, the algorithm continues
    recursively by sorting each of the two parts; in this case you’ll continue the
    search in only one of the parts. See [Figure 7-3](chapter7.xhtml#fig7-3) for an
    example where you want to find the 6th element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The pivot technique used in quicksort provides a selection algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the same first pivot scheme as for quicksort and choose the rightmost
    value (14) as the pivot. After repartitioning the array around 14, the pivot ends
    at the 4th place in the array. You want the 6th element, so continue searching
    on the right side of the pivot. There you choose 56 as the pivot, and after repartitioning,
    56 ends at the 7th place in the array. That comes after the place you want, so
    continue searching the left part. You then choose 22 as the pivot. It ends in
    the 5th place, and you continue searching the right side, which now consists of
    a single element, so you know for sure 34 is the 6th value in the array. To the
    left of 34 there are lower values (but not necessarily ordered), and to the right
    there are greater values.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 6](chapter6.xhtml), the performance of quicksort on
    average is *O*(*n* log *n*), but in the worst case, it becomes *O*(*n*²). Quickselect’s
    average performance has been proven to be *O*(*n*), but it could become *O*(*n*²)
    if you generally make unlucky pivot selections, so rather than study a single
    algorithm, we’ll consider a whole family of them by varying how we choose the
    pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Quickselect
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the basic logic. As in [Chapter 6](chapter6.xhtml), assume
    single-field keys that can be compared with the < and > operators. Always write
    tests as a > b, so adapting the code for a more generic comparison would just
    require writing compare(a,b) > 0, assuming a user-provided compare(x,y) function
    that returns a positive value if x is greater than y.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the basic structure of the quickselect family;
    the pivot selection part is in bold, and we’ll make changes to that section to
    get other, enhanced versions of the selection function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The parameters for quickselect ❶ are the same as for selection sort and all
    the algorithms in this chapter. The start of this algorithm is exactly like quicksort’s,
    with the option of using a random choice for the pivot, up to and including how
    you split the array, having the chosen pivot end at position p ❷. The only difference
    is how to proceed after that. If the pivot ends in the *k*th position ❸, you’re
    done, because that’s the value you want. Otherwise, use recursion to examine the
    left ❹ or right ❺ partition, whichever includes the *k*th position. (Actually,
    you don’t need to use recursion; see question 7.4.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As is, quickselect reorders (partitions) the input array to ensure the element
    in the *k*th place isn’t lower than any element before it or greater than any
    element after it. You can easily get the value itself by writing an auxiliary
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use quickselect to repartition the array ❶, and then return the value at the
    desired position ❷. (See question 7.5 for a simple modification.) On average,
    this algorithm can be shown to be linear, but if it happens to choose the worst
    pivot every time, it becomes quadratic instead. Now consider some alternative
    pivot-choosing strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Median of Medians
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous version of quickselect could become slow, but you can split the
    array better. For example, you don’t want either of the two possible partitions
    to be small in case you have to recurse on the large one.
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy you can apply is called *median of medians*, and the idea is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Divide the array in groups of up to five elements.
  prefs: []
  type: TYPE_NORMAL
- en: 2. Find the median of each group.
  prefs: []
  type: TYPE_NORMAL
- en: 3. Find the median of the medians found in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: 4. Use that value to split the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](chapter7.xhtml#fig7-4) illustrates this concept; each rectangle
    is a set of five values in order from low to high from bottom to top (as the vertical
    arrow shows) with the median in the middle. The medians themselves grow from left
    (lowest median) to right (highest median) according to the horizontal arrow. The
    pivot you’ll choose is the median of the set of medians—the center value in the
    diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: The middle element in each column is its median; medians are sorted
    from left to right, and the center value is not less than the shaded values, a
    third of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-4](chapter7.xhtml#fig7-4), all the gray values (15 out of 45, a
    third of the complete set) are *guaranteed* not to be greater than the chosen
    pivot. Similarly, the chosen pivot is also guaranteed not to be greater than the
    other third of array values (see [Figure 7-5](chapter7.xhtml#fig7-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: In the same situation as [Figure 7-4](chapter7.xhtml#fig7-4), the
    center value is also not greater than the shaded values, a third of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: This means the chosen pivot will be such that it splits the array somehow between
    33/66 percent and 50/50 percent. At worst, you’ll have to apply recursion in a
    new array that is two-thirds the size of the original array (and, at best, one
    that’s only one-third the size) and that can be shown to produce *O*(*n*) performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements this method (the bold indicates the parts that
    changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the array is short enough (five elements or fewer) ❶, you can use another
    algorithm to find the median of medians (mom). If the array has more than five
    elements ❷, consider sets of five elements at a time. You find the median of the
    set ❸ and move it to the left of the original array ❹ by swapping, so all medians
    end up together starting at position left of the array. You now want the median
    of this (smaller) set, so you calculate its position ❺ and use recursion ❻ to
    find the desired pivot. Once you’ve found it, swap it with the value at the right
    of the array ❼, and from that point onward, it’s the same pivoting logic as shown
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now complete the code. You need a fast simpleMedian(...) algorithm to find
    the median of an array of up to five elements, and an insertion sort does the
    job (you also could use the sortingSelect(...) code from the section “Selecting
    with Comparisons” on page 124):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Sort the whole array ❶, which isn’t very slow because an insertion sort is quite
    speedy for such a small set of values, and then choose the middle element of the
    sorted array ❷.
  prefs: []
  type: TYPE_NORMAL
- en: This logic works well and has guaranteed results, unlike the original quickselect
    that had a worst case different from the average case.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated Step
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another variation on how to select the pivot is called *repeated step*. This
    algorithm seemingly does a worse job of partitioning an array, but it has advantages
    in terms of speed. Choosing the median of three elements is quite quick using
    the “ninther” technique (as described in [Chapter 6](chapter6.xhtml)): first go
    through the array, generating a set by choosing the median out of every trio of
    values; then, go through that set of medians to create a second set by choosing
    the median out of every trio of medians. [Figure 7-6](chapter7.xhtml#fig7-6) shows
    how this would work for an array with 18 elements. The idea is exactly the same
    for larger arrays, but there’s not enough space to show it here.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Repeatedly applying the “median of three” process reduces the original
    array to one-ninth of its size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repeated step of choosing the median of three reduces the original array
    to one-ninth of its size and makes recursion go very quickly. (In a sense, you
    are choosing the median of medians of medians.) The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The mom variable ends up with the median of medians position in the array ❶.
    If the array is less than nine elements long ❷, you don’t need to do any fancy
    work; just use a sort-based algorithm to find the desired median. Variable j1
    keeps track of the medians you’ve swapped to the left of the array ❸. A simple
    loop goes through the array’s elements, three at a time, finding the median of
    that trio and swapping it to the left ❹. You then perform the same logic again,
    using a new j2 variable ❺ and another loop ❻. After these loops, positions from
    left to j2 have the medians of medians ❼, and you apply the algorithm recursively
    to find its median, which you swap with the element at right ❽, so you can proceed
    with the rest of the otherwise unchanged quickselect algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm can also be proved to have *O*(*n*) performance, so it’s a good
    option. Why use recursion after two rounds of finding the medians of medians and
    not go on? (See question 7.6.)
  prefs: []
  type: TYPE_NORMAL
- en: So far you’ve explored algorithms that find the *k*th element for any value
    of *k*; this chapter finishes by explicitly considering the problem of finding
    the center element of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Median with Lazy Select
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to find the median (remember the working definition isn’t the one
    used in statistics; you just choose the element closest to the center of the array
    without any particular considerations for arrays of even length), you could obviously
    use any of the algorithms in this chapter, letting *k* be half the length of the
    input array. However, there are some other ways to find the center value, and
    in this section, we’ll consider an interesting one that’s based on random sampling
    (you’ll study sampling algorithms in [Chapter 8](chapter8.xhtml)) and probability
    calculations. The lazy select algorithm uses sampling and may find the right value
    with a single pass with an *O*(*n*^(–1/4)) probability of failure, looping again
    and again as needed until it succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm to find the median of set *S* of size *n* works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Choose a random sample *R* of *n*^(3/4) values from *S*.
  prefs: []
  type: TYPE_NORMAL
- en: 2. Sort *R* using any algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 3. Choose two values, *d* and *u*, in *R* that will satisfy *d* < *median* <
    *u with high probability (*you’ll see how to do this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 4. Let *dSize* be how many values of *R* are < *d*; if *dSize* > *n*/2, you
    failed and must try again.
  prefs: []
  type: TYPE_NORMAL
- en: 5. Let *uSize* be how many values of *R* are > *u*; if *uSize* > *n*/2, you
    must try again.
  prefs: []
  type: TYPE_NORMAL
- en: 6. Let *m* be the set of values *x* of *S* that are *d* < *x* < *u*; if the
    count exceeds 4*n*^(3/4) you must try again.
  prefs: []
  type: TYPE_NORMAL
- en: 7. Sort *m* and return the value at its *n*/2 – *dSize* position.
  prefs: []
  type: TYPE_NORMAL
- en: The proof of performance for this algorithm depends highly on probabilistic
    arguments, and you won’t see those here. The key concept is that a random choice
    of values *R*—but not too many, so sorting *R* is *O*(*n*)—should usually be good
    enough to find lower and upper limits to the median (*d* and *u* in the previous
    list) and that the set of values between *d* and *u* should be small enough so
    that, again, sorting doesn’t go above *O*(*n*) in performance. This algorithm
    may fail, but the probability is low *O*(*n**^–*^(1/4)), meaning that in the worst
    case, a few new attempts should succeed. As an example, if the odds of failure
    were 10 percent (which means the algorithm may succeed at first 90 percent of
    the times), the odds of two failures in a row would be 1 percent (10 percent of
    10 percent, resulting in 99 percent odds of success), and three successive failures
    would happen once every 1,000 times, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is straightforward, but with lots of math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You use merge sort ❶ to sort arrays when needed; it’s important to choose an
    *O*(*n* log *n*) algorithm, because you’ll use it with arrays that are at most
    4*n*^(3/4) size, so the performance becomes *O*(4*n*^(3/4) log 4*n*^(3/4)) < *O*(*n*).
    Then you define several variables for the rest of the code: len is the size of
    the input array ❷, sR is the size of the sample ❸, dIndex and uIndex are the positions
    of d and u in the sorted r array ❹, and dSize, uSize, and m ❺ correspond with
    the description listed earlier in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Use a “sampling with repetition” algorithm ❻ to choose sR random values from
    the input array into the r array; making sure no repeated values are sampled would
    work as well, but the logic would be more complex, as you’ll see in [Chapter 8](chapter8.xhtml).
    After having chosen and sorted r ❼, calculate dSize and uSize (how many values
    in the input array are smaller than d or greater than u; note that you never actually
    define d and u; you just refer to them by their indices) and m (with values between
    d and u).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you want to know whether the results are as expected ❽. If dSize or
    uSize includes more than half the input array, the median isn’t in m, as was expected;
    you failed. Likewise, if m is too large, you also failed. If all tests pass, m
    has a proper size that allows you to sort it and choose the median from it ❾.
    Note that you account for the dSize values lower than d, which precede the array
    m.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is quite different from most of what you’ve considered in this
    book, because it depends on probabilistic properties to work, but performance
    is usually quite good, and it finds the median with few iterations, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you studied several algorithms for selection, most of which
    are closely related to the sorting algorithms examined in [Chapter 6](chapter6.xhtml).
    The selection problem isn’t as common as sorting, so it’s no surprise that JavaScript
    doesn’t provide a ready-made method for it, so the implementations in this chapter
    cannot be avoided if you need this functionality. Most of the algorithms covered
    here have *O*(*n*) performance, which is optimum, but the proofs of their behaviors
    are often complex, so they were omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**7.1  Tennis Sudden Death**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose 111 tennis players enter a knockout tournament to find the champion.
    In each round, random pairs of players play each other, and the loser is out of
    the tournament, while the winner passes to the next round. If there’s an odd number
    of players, one player gets a free pass to the next round. How many matches will
    be necessary to find the champion? How many extra matches will you need to find
    the second-best player? (And no, whoever lost to the champion in the last game
    isn’t necessarily the second-best player.) Can you generalize your answer for
    *n* players?
  prefs: []
  type: TYPE_NORMAL
- en: '**7.2  Take Five**'
  prefs: []
  type: TYPE_NORMAL
- en: “Take Five” is the name of a jazz piece that Dave Brubeck made famous, but in
    this case you want to take the median of five elements. What’s the absolute minimum
    number of comparisons that guarantees finding that median? Can you provide an
    appropriate medianOf5(a,b,c,d,e) function that will return the median of its five
    arguments? You could be achieving a better simpleMedian() function with this!
  prefs: []
  type: TYPE_NORMAL
- en: '**7.3  Top to Bottom**'
  prefs: []
  type: TYPE_NORMAL
- en: If *k* is close to *n*, the length of the input array, your selection sort–based
    algorithm would have a bad quadratic performance, but you can make it quite better
    with a simple trick; can you see how?
  prefs: []
  type: TYPE_NORMAL
- en: '**7.4  Just Iterate**'
  prefs: []
  type: TYPE_NORMAL
- en: Quickselect does a single tail recursive call and may be rewritten to avoid
    all recursion; can you do it?
  prefs: []
  type: TYPE_NORMAL
- en: '**7.5  Select Without Changing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is, qSelect returns the desired *k*th value, but it has a side effect: the
    input array will be changed. Can you modify qSelect to avoid this secondary effect?'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.6  The Sicilian Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repeated step selection algorithm does two rounds of choosing medians of
    three, and finally, it uses recursion to find the median of the resulting array
    of medians of medians. Implement the following variation: instead of recursion,
    keep applying the same method (grouping by three, choosing the median, and so
    on) until the resulting array is less than 3 in length, and then choose the pivot
    from that small array without any recursion.'
  prefs: []
  type: TYPE_NORMAL
