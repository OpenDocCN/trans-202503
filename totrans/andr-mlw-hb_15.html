<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_283"/><strong><span class="big">12</span><br/>THE FUTURE OF ANDROID MALWARE</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentsa">In this last chapter, we’ll share our thoughts about the future of Android malware, based on an examination of recent specimens, as well as trends observed on other platforms. Some of our predictions are almost guaranteed to come true; others are more speculative.</p>&#13;
<p class="indent">Of course, not all Android malware is created for the same purpose, making it difficult to lay out a unified vision for the future. For this reason, we’ll restrict our discussion to mass malware, which indiscriminately infects Android devices in an attempt to make money at scale. Other, more targeted malware specimens, such as state-sponsored remote exploitation tools, have diverse and complicated motivations, so we won’t cover these here.</p>&#13;
<p class="indent">When it comes to mass malware, we can consider three areas: technology, distribution, and economics. We’ll also compare Android to the older Windows operating system and describe what the trends observed on that platform mean for future machine learning detection efforts.<span epub:type="pagebreak" id="page_284"/></p>&#13;
<h3 class="h3" id="ch12lev1"><strong>Windows vs. Android</strong></h3>&#13;
<p class="noindent">To predict future Android malware trends, we can learn from Microsoft Windows, whose popularity and accessibility are comparable to Android’s. As Windows is more than 20 years older than Android, a number of the malware techniques that we are seeing and expect to see in the future on Android have already appeared on Windows, making it easy to draw parallels between the two. However, other aspects of the operating systems, including their licensing and software architecture, are very different and cannot be easily compared. Thus, certain Android malware technology trends might not apply to Windows, and vice versa.</p>&#13;
<h4 class="h4" id="ch12lev1sec1"><strong><em>Windows</em></strong></h4>&#13;
<p class="noindent">Since the 1980s, Microsoft and hundreds of third-party security companies have helped protect users and computers from Windows malware, as well as malware targeting its predecessor, MS-DOS. As a result, this malware has gone through many cycles of refinement, taking advantage of newly discovered niches in these operating systems before Microsoft catches up.</p>&#13;
<p class="indent">As an example, recall the file infector viruses of these operating systems’ early days. File infectors modified benign executable files by injecting malicious code into them. This kind of malware was extremely common until Microsoft added executable file signing to Windows. Today, file infectors are rare, as most benign executable files are signed with a private key that is known only to the file’s original software developers. Careless modification of these signed executable files, for example, by a file infector wanting to inject malicious code, breaks the file’s integrity, and Windows won’t allow the modified files to execute.</p>&#13;
<p class="indent">In the late 1990s, Office macro malware surpassed the popularity of file infectors on Windows. Attackers embedded malicious code in files belonging to Office products like Word or Excel, which allowed powerful scripts to execute many different kinds of attacks against affected systems. Users were tricked into opening these <em>.doc</em> or <em>.xls</em> files sent via email spam with alluring messages promising money or particularly juicy information, like leaked salary information from their employers. Once again, Microsoft caught up and closed this vector of attack by making it safer to open Office documents by default. It also launched additional safety features, like the ability to permanently disable Office macros across a whole enterprise, to counter this form of abuse.</p>&#13;
<p class="indent">In the early 2000s, Windows computers connected to the fledgling internet were regularly attacked by early internet worms with names like Code Red, Nimda, and SQL Slammer. These worms took advantage of Windows installations that had many services exposed to the internet by default (a condition that occurred even on consumer machines, where average users may not have known the services even existed). The ease with which these internet worms spread, and the difficulty that users experienced in defending themselves, made them the first globally feared malware. The age of the internet worms peaked early, though, lasting just a few years. Facing <span epub:type="pagebreak" id="page_285"/>pressure, Microsoft once again revisited the security of Windows: default Windows installations exposed fewer services to the internet, and services that really did need to be enabled were significantly hardened against wormlike attacks.</p>&#13;
<p class="indent">Microsoft’s work to improve the security of its products is impressive and not limited to these examples. New Windows malware must find fresh pathways for abuse, imposing costs on malware developers. In addition, Windows-specific antivirus companies have spent decades developing strong capabilities for detecting and defending against abuse. Once it’s detected by antivirus tools, the lifetime of new Windows malware is cut short. Today, successful specimens must be a lot more sophisticated than successful Android malware, as the Windows ecosystem has gone through many more cycles of this exploitation and hardening cycle.</p>&#13;
<h4 class="h4" id="ch12lev1sec2"><strong><em>Android</em></strong></h4>&#13;
<p class="noindent">What does all of that have to do with the future of Android malware? Our look at Windows suggests that the best way to stop Android malware in the long term is to improve the security of the Android ecosystem across the board. Malware defenders can’t win merely by using a malware detection and removal strategy.</p>&#13;
<p class="indent">As discussed in <a href="part1.xhtml">Part I</a>, Android has already experienced several rounds of hardening; malware authors discover avenues of attack, and Google consequently beefs up the security of the operating system. Some of the most successful defensive examples include Android’s response to attempts to send fraudulent premium SMS messages. The operating system now shows a warning dialog whenever an app tries to send a premium SMS, making it almost impossible for malware to abuse this vector. The deprecation of the device administration API, which malware abused to gain persistence on devices, is another example. Future Android malware will have to continuously react to such changes, abandon previously profitable attack techniques, and move on to target less defended parts of the ecosystem.</p>&#13;
<p class="indent">Operating system improvements are less likely to thwart certain types of malware, such as those relying on social engineering or advertising fraud, which really only need an internet connection and a JavaScript engine. Thus, defenses must involve partnerships with major players in the Android security ecosystem, including other platform providers, mobile carriers, device manufacturers, and security companies that benefit from a clean Android ecosystem. If the profitability of certain types of Android malware can be lowered enough, malware authors may move on to a different target with a higher return on investment.</p>&#13;
<p class="indent">In many ways, however, Android lives in a world with a completely different threat model than Windows. The first version of Windows was developed when few people owned personal computers, and even fewer connected their computers to any kind of public network; the number of criminal gangs trying to abuse network-connected computers was just about zero. From the beginning, Android has run on millions (and later billions) <span epub:type="pagebreak" id="page_286"/>of devices with nearly permanent connections to the internet, where thousands of criminal gangs are lurking. Understanding this, Android’s developers created a heavily locked down operating system where regular apps, including malware, have barely any access to areas of the operating system that could be abused. In theory, this should mean that there are fewer ways for attackers to abuse Android than Windows. As the platform matures, it will be interesting to see which overlooked niches malware developers discover in the future and how the Android team will respond to these threats.</p>&#13;
<h3 class="h3" id="ch12lev2"><strong>Hiding Malicious Behavior with Anti-Analysis Techniques</strong></h3>&#13;
<p class="noindent">Windows malware is more advanced than Android malware in one particular aspect: the anti-analysis techniques its developers have deployed over the years. These techniques make analysis using typical tools like virtual machines, disassemblers, and decompilers much harder and more frustrating. Even better for malware authors, many free and commercial executable packers, obfuscators, and other protectors exist for Windows, so they don’t need to spend time building their own protection mechanisms. They can use freely available tools or buy, steal, or pirate powerful commercial products.</p>&#13;
<p class="indent">While similar app protectors exist on Android, they aren’t usually as advanced. For example, Windows malware authors can choose from a large set of executable protectors with advanced features like control flow obfuscation. Certain tools will even transform their original executable code into protector-specific virtual machine code. On Android, there are far fewer off-the-shelf protectors available, and the features they provide are much less sophisticated. In the coming years, we expect the sophistication of anti-analysis defenses and executable packers on the Android platform to increase; however, many of the techniques used on Windows are flat-out impossible on Android due to the ways in which the operating system is locked down.</p>&#13;
<p class="indent">For that reason, Android is unlikely to be targeted by certain attack techniques common on Windows, such as privileged code running at kernel level or tricks that require the coordination of multiple processes, cross-process thread injection, and files hidden across the filesystem. One big advantage of Android for security companies is that nearly everything an app does on the platform has to happen within the same process. This means security researchers can look for malicious behavior in just one place. Barring privilege escalation exploits, which are extremely rare on recent versions of Android, abuse cannot be strewn across the system, hiding from detection and analysis wherever possible.</p>&#13;
<h4 class="h4" id="ch12lev1sec3"><strong><em>Native ARM Code</em></strong></h4>&#13;
<p class="noindent">Because Android prevents the hiding of abuse across the system, malware authors have explored ways to conceal malware’s functionality within an app’s single process. One example of such efforts is the use of native assembly code as an anti-detection measure.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_287"/>Historically, malware developers have written their code in Java or Kotlin and compiled it to DEX, as have most legitimate app developers. However, certain technical properties of DEX code make it easy for security researchers to analyze. Malware authors are fully aware of this, which is why we’re seeing them shift away from DEX code.</p>&#13;
<p class="indent">The most obvious alternative to DEX code is the use of native assembly code, usually ARM, compiled from languages like C++. Native assembly code doesn’t have the nice technical properties of DEX code and is much harder to parse and analyze. Most, if not all, companies performing Android malware analysis today have more advanced DEX analysis capabilities than ARM analysis capabilities. We believe malware authors are aware of this fact and are using it to their advantage.</p>&#13;
<p class="indent">While Android malware apps compiled to DEX code still outnumber those compiled to ARM code, we’ve seen malware authors slowly starting to experiment with ARM code. Some Android malware is completely developed in ARM. In other cases, the harmless parts of the apps are developed in DEX and the malicious parts in ARM. In yet other cases, ARM usage is minimal but purposefully applied to circumvent typical capabilities of anti-malware software. For example, in some known Android malware samples, the ARM code supplies an encryption key to the DEX code, which uses it to decrypt strings involved in malicious behavior.</p>&#13;
<p class="indent">Unless a static analysis engine has data flow analysis capabilities that can cross ARM–DEX code boundaries, it will have a hard time flagging malicious behavior hidden in encrypted strings in the DEX code. Malware authors likely correctly assume that most security companies do not have the capabilities for cross-architecture control flow and data flow analysis.</p>&#13;
<h4 class="h4" id="ch12lev1sec4"><strong><em>Downloaded Modules</em></strong></h4>&#13;
<p class="noindent">Because Android devices are often online most of the time, whether through Wi-Fi or a mobile network, many malware apps targeting the platform rely on the availability of an internet connection to download additional code from remote servers. This allows them to hide this malicious code from analysts.</p>&#13;
<p class="indent">Using the most common form of this technique, an app might contain only harmless code in its APK file and download all malicious functionality from a remote server. Anybody analyzing the APK file for malicious activity will come up blank unless they also acquire the remote code file, which can be tricky. Often, attackers won’t upload that file to their servers until their malware installation base has reached critical mass; there’s no need to tip off anti-malware researchers while you’re still building up your botnet. Security researchers who are late to the analysis game may likewise miss the window during which malicious code is available for download.</p>&#13;
<p class="indent">More sophisticated Android malware today is already deploying complex plug-in-based architectures through remotely hosted files. Depending on environmental variables like the user’s phone model, country, or mobile carrier, the apps download different malicious plug-ins from remote servers to optimize the monetization of the malware.</p>&#13;
<h4 class="h4" id="ch12lev1sec5"><span epub:type="pagebreak" id="page_288"/><strong><em>Less Popular Languages</em></strong></h4>&#13;
<p class="noindent">Another way to deny visibility to anti-malware products is to make use of uncommon programming languages. It’s safe to assume that defenders can analyze Java code and (to some degree) native ARM assembly code. But how many anti-malware companies can analyze newer app development frameworks like Flutter or ReactNative? And how many have analysis engines for languages that are niche on Android, like Lua or Python, especially when these scripts interact with the Android APIs?</p>&#13;
<p class="indent">We’ve seen one particularly innovative piece of malware download a Bash shell and then use it for its malicious activity. First, it ran the Linux package installation command <code>apt-get</code> inside the shell to install a couple of standard Linux modules, such as OpenSSL and <code>libcurl</code>, as well as Python. Then it downloaded Bash scripts to execute malicious code from the shell. Very few security companies can automatically analyze such setups.</p>&#13;
<p class="indent">The multitude of scripted and interpreted languages available for Android makes detection of malware written in these languages very tedious and requires a serious financial investment. We expect that malware authors will increasingly go down this road, even if it requires a bit more up-front investment on their part.</p>&#13;
<h4 class="h4" id="ch12lev1sec6"><strong><em>SDK-less Techniques</em></strong></h4>&#13;
<p class="noindent">The holy grail of hiding from security researchers is to not expose any code at all. As users become increasingly privacy-aware and begin to scrutinize the data collection practices of tech companies, we’ve seen problematic data broker companies move to what we call <em>SDK-less</em> or <em>server-to-server</em> systems. In the earlier years of Android malware, if a shady data broker wanted to collect information about users, they would build an SDK and entice developers to embed that SDK in their apps. Of course, this made it easy for security researchers to scrutinize the SDK’s code and identify its problematic functionality.</p>&#13;
<p class="indent">In the SDK-less world, the data brokers do not provide app developers with any code at all. Instead, they provide a server endpoint to which apps should send the collected information. It is the responsibility of the app developer to harvest this data and transmit it. To avoid detection, developers first send it to their own servers and then forward it to the data broker’s systems. Since nobody can inspect the traffic going between these servers, the original app developer won’t be implicated in selling user data to the data broker, and the data broker won’t have an obvious connection to user data collection at all.</p>&#13;
<p class="indent">If, for example, a fitness tracker app collects a device’s GPS location or a contact list backup app sends contact list information to its backup server, who would be able to verify that they’re then reselling this data without user consent? Security researchers will have to find ways to trace these data sales that go beyond app analysis, as nothing suspicious happens in the apps themselves.</p>&#13;
<h3 class="h3" id="ch12lev3"><span epub:type="pagebreak" id="page_289"/><strong>Distribution</strong></h3>&#13;
<p class="noindent">In addition to technical developments, we expect to see new trends evolving in the distribution of Android malware. Although malware authors will likely continue to target Google Play as an easy way to reach a large audience, the threat of supply chain compromises remains a major concern. Even sideloaded malware may experience a revival, as recently proven social engineering methods have successfully tricked millions of users into downloading and installing apps from malicious websites.</p>&#13;
<h4 class="h4" id="ch12lev1sec7"><strong><em>Preloaded Malware and Supply Chain Compromises</em></strong></h4>&#13;
<p class="noindent">Malware enterprises will continue to infiltrate the Android device supply chain. In <a href="ch02.xhtml">Chapter 2</a>, we covered recent incidents in which malware authors succeeded in subverting equipment manufacturers, device driver manufacturers, and other companies involved in the development of Android devices. With thousands of companies involved in the process, we expect to see more of this behavior going forward.</p>&#13;
<p class="indent">Experts speculate about how supply chain compromises can happen. Based on the stories we’ve heard, the most successful malware authors set up seemingly legitimate companies that develop apps or SDKs with desirable functionality. These companies then approach manufacturers that are part of the supply chain and propose partnerships to license these apps or SDKs. The manufacturers don’t know that these products come with backdoors or other malicious functionality that operates in the background. This kind of attack has been highly effective and is very dangerous because malware authors tend to offer functionality that goes into the depths of the Android operating system, giving malware apps and other malicious system modifications many more privileges and permissions than they would get if they were regular apps.</p>&#13;
<p class="indent">Consider the real example of the backdoored font manager app EagerFonts described in <a href="ch02.xhtml">Chapter 2</a>. Font management software is unprofitable to develop in-house, so manufacturers frequently license it from a specialized third-party developer. Additionally, manufacturers probably won’t ask too many questions if the developers tell them to grant the code additional privileges; a font manager could be part of the operating system’s core functionality and may require more privileges than those given to regular apps. The hidden backdoor can then use those elevated privileges.</p>&#13;
<p class="indent">Attacking the supply chain rather than individual Android devices requires more initial investment but has some advantages. For example, malware authors don’t need to develop apps that attract many users. Instead, they need only convince a few decision-makers somewhere in the supply chain, which they can do in a more targeted manner. Using Google Play for malware distribution requires creating effective marketing materials and advertising campaigns; the apps also shouldn’t seem bad or useless, or else users will promptly uninstall them. The added danger of being detected by Google and removed from Google Play makes this effort a risky proposition. Infiltrating the supply chain with a preinstalled app removes the need to <span epub:type="pagebreak" id="page_290"/>create a marketing campaign to distribute the app. The preinstalled malware doesn’t need to have any user-visible functionality, as it can operate in a hidden part of the system where it silently runs in the background, executing its money-generating payload.</p>&#13;
<p class="indent">Another huge advantage, and we believe one of the main incentives to develop preinstalled malware, is system privileges. In the early days of Android, malware authors gained elevated privileges on the system by discovering privilege escalation exploits, but more recent versions of Android are significantly harder to exploit, and it may take a long time for new exploits to be published. In the preloaded malware world, gaining elevated app privileges may just be a matter of asking the subverted manufacturer to relax some system settings, such as SELinux rules, under false pretenses.</p>&#13;
<p class="indent">For similar reasons, preinstalled malware is much harder to remove from devices. Regular apps can simply be uninstalled. This is not the case for preinstalled apps. Usually, users can do nothing more than disable them, so the malware could potentially be re-enabled. In many cases, even disabling preinstalled malware isn’t possible. Malware authors have figured out that if they inject code into critical applications that ship with the device, anti-malware products won’t be able to disable them. For example, a very common target for maliciously injected code is the system UI process. Defenders can’t disable this process without rendering the device unusable, as it is responsible for the screen display.</p>&#13;
<h4 class="h4" id="ch12lev1sec8"><strong><em>Smarter Sideloading</em></strong></h4>&#13;
<p class="noindent">The distribution of sideloaded malware will, of course, continue for as long as Android allows users to install applications from sources other than Google Play. Compared to other distribution methods, sideloading is simpler and has a lower likelihood of attracting the attention of many security researchers. Malware authors can easily set up their own malware distribution servers or upload their apps to alternative app stores that may have fewer protections than Google Play (but also offer access to fewer potential victims).</p>&#13;
<p class="indent">The Flubot malware family that hit Europe, Australia, and New Zealand in 2021 made it obvious that sideloaded malware can succeed if users are heavily socially engineered throughout the sideloading process. Flubot developers were able to get victims to sideload their bank-phishing apps at scale by mass-spamming users in affected countries with SMS messages that implied the need for urgent action to download and install a linked malware app. Most commonly, the Flubot spam messages would claim that the user was about to receive a package but would have to schedule a delivery time through the linked app. Flubot proved that hundreds of thousands of users will click through five or more warning dialogs from the Android operating system, Google Play Protect, and the Google Messenger app to schedule an incoming package delivery. Other malware developers have taken note of Flubot’s success and will likely attempt to emulate these tactics.</p>&#13;
<p class="indent">We see only one exception to the trend of an increase in sideloaded malware. Malware distribution in countries where Google Play is not available or popular will continue to target the predominant app stores in these <span epub:type="pagebreak" id="page_291"/>countries, as they serve the same role as Google Play in those locations, with all the advantages and disadvantages for malware distribution.</p>&#13;
<h3 class="h3" id="ch12lev4"><strong>Malware Economics</strong></h3>&#13;
<p class="noindent">Today, Android malware is moving away from techniques that generate high profits per device but are visible to the user and turning instead to sneakier techniques that generate less profit per device but are more likely to go unnoticed. Attackers make up for the lower per-device profits by infecting huge numbers of devices, with each contributing just a little bit to the total malware revenue.</p>&#13;
<p class="indent">Modern malware tries to stay hidden from users and remain installed for a long time so it can keep making a profit for months or years. This also means that malware cannot abuse users directly, for example by asking for a ransom in exchange for access to their maliciously encrypted files. User involvement means detection, and detection means removal. Once users understand that they’re being abused, anti-malware companies will soon hear about it, too. These companies will develop signatures and other defenses and deploy them to devices, cutting short the malware’s lifetime.</p>&#13;
<p class="indent">For these reasons, malware has become a lot more subtle and is nowadays often undetectable during device use, even by the most aware of users. Instead of locking users out of their devices, this new generation of malware drives fake traffic to advertising platforms that defraud advertisers, rents out available network bandwidth to botnets, manipulates social media or other platforms for pay, or mines cryptocurrency in the background. This activity is less harmful to users than malware that, say, empties their bank accounts. On the other hand, it allows malware authors to build up huge botnets before security companies catch on. Some of these botnets have grown to command a total network bandwidth that poses a DDoS threat to even the largest tech companies in the world.</p>&#13;
<p class="indent">Of course, not all malware will follow the direction described in this chapter. Like defenders, malware authors are constrained by budgets, technological know-how, and business acumen. Low-quality malware will continue to exist as new malware authors enter the space. For organized cybercrime, though, the trends are clear: the most successful malware operations come from front companies that manage to infiltrate supply chains, then use technical means to hide their code from defensive companies.</p>&#13;
<h3 class="h3" id="ch12lev5"><strong>Machine Learning Trends for Attackers and Defenders</strong></h3>&#13;
<p class="noindent">A growing number of security firms now use machine learning for mal-ware detection, employing a variety of techniques to predict whether some behavior on a device is normal or abnormal. Apps might also be clustered together based on their respective feature vectors. For instance, many different variations of an Amazon or eBay app may all end up in the same cluster, as would variants of an Android malware specimen like Acecard. Thus, while <span epub:type="pagebreak" id="page_292"/>the most heavily used machine learning techniques are classification algorithms, you’ll see anomaly detection and clustering methods used too.</p>&#13;
<p class="indent">To date, we don’t have evidence that attackers have been using machine learning techniques. However, we expect them to do so in the imminent future. Firstly, attackers could use artificial intelligence and machine learning to identify the targets who are most likely to download their malware. By gathering information about specific individuals, attackers can build such behavioral models using classifiers in much the same way that defenders build predictive models to identify malware apps, as demonstrated in the previous chapters of this book. Attackers could also use regression models to predict how much a victim of a ransomware attack might be willing to pay or how much a victim of a banking trojan might have to steal. Attackers might prefer to target a smaller number of high-value victims rather than a large number of low-value victims, as an attack that has many targets is more likely to be flagged by cybersecurity companies.</p>&#13;
<p class="indent">Machine learning methods may also allow attackers to inject their malware much more effectively. For example, current vectors for injection include phishing and <em>watering holes</em>, which are URLs that install malware into the browser or operating system of any individual who makes the mistake of visiting them. Adversarial phishing algorithms show how adversaries can avoid algorithms that detect phishing attempts (as described in the paper “Mitigating Adversarial Gray-Box Attacks Against Phishing Detectors” by Apruzzese and Subrahmanian in <em>IEEE Transactions on Dependable and Secure Computing</em>).</p>&#13;
<p class="indent">Phishing attacks will likely improve both in quality and quantity because a number of recent artificial intelligence tools, such as DALL-E and ChatGPT, can generate highly realistic synthetic text blurbs and images and produce fake tweets, WhatsApp messages, emails, Facebook and Instagram posts, and more. These new capabilities would allow malicious hackers to not only develop extremely attractive phishing lures (say, a cute cat video with a catchy associated text caption), but to do so at scale, cranking out thousands of different lures in seconds. Some of this fake content will be posted through the accounts of real users of social and messaging platforms (who may unwittingly share malicious content). In addition, malware developers will create and leverage fake accounts explicitly for the purpose of distributing malware.</p>&#13;
<p class="indent">A separate set of attacks that leverage tools such as DALL-E and ChatGPT might seek to automatically compromise legitimate app stores such as Google Play by posting mostly honest reviews of benign apps (in order to gain credibility), but also posting dishonest reviews of their malicious apps on a regular but infrequent basis, potentially eluding detection as fake accounts.</p>&#13;
<p class="indent">On the positive side, defenders might be able to use machine learning techniques for generating novel content, such as <em>generative adversarial networks (GANs)</em> and <em>variational autoencoders (VAEs)</em>, for defensive purposes. For example, these techniques can be used to generate content for fake sites, known as <em>honeypots</em>, that are attractive to attackers. Once an attacker accesses <span epub:type="pagebreak" id="page_293"/>a honeypot, they are, unbeknownst to them, within a computational environment that is carefully set up to log all of their activities. Defenders can then study them in detail, allowing them to gain an understanding of the attacker’s tactics, techniques, and procedures, and sometimes even their identity.</p>&#13;
<p class="indent">Attackers could potentially use the same artificial intelligence tools to directly generate malware, and defenders to sharpen their skills at detecting it. For example, attackers could use GANs and VAEs to automatically generate many diverse versions of a given malicious app in the hopes that at least some will evade detection, while defenders could do the same to study known malware and learn how to better identify variations of it.</p>&#13;
<p class="indent">These techniques have the potential to dramatically alter the malware development and detection landscapes in coming years. However, while attackers may try to use GANs to generate malware, they need to avoid obvious errors that many GANs make. For instance, in image processing, GANs may generate images of people with six fingers rather than five. Humans may not always spot details like these in images, but in the case of malware, the analog of such errors will likely lead to non-executable code. Thus, the use of GANs for malware development still has some challenges. Meanwhile, on the defending side, GANs offer an effective new tool to detect malware variants that have never been seen before.</p>&#13;
<p class="indent">To conclude, the democratization of machine learning techniques, along with the growing number of open source artificial intelligence tools, will spur the rapid development of new breeds of malware. Cybersecurity firms must take proactive efforts to prevent malicious actors from gaining the upper hand in this war.</p>&#13;
<h3 class="h3" id="ch12lev6"><strong>Next Steps</strong></h3>&#13;
<p class="noindent">Although we’ve aimed to provide you with a comprehensive introduction to the field of Android malware and the use of machine learning to detect it, you won’t become a capable malware analyst simply by reading books. Here are some guidelines for continuing your journey.</p>&#13;
<p class="indent">First, secure a reliable source of malware samples for analysis. If you can’t get these from your work or school, you may have to seek out community resources. For Android malware in particular, you can find many resources with a quick web search. In addition, there’s a large community of security researchers on X who regularly share the latest malware samples. We recommend that you tune in to this information channel.</p>&#13;
<p class="indent">Once you’ve secured access to the malware samples, the hard part begins. You need to work on mastering your tools, dissecting different types of malware, and gradually expanding your understanding of how these applications operate to reach their objectives. We’ve found that when someone without much prior malware analysis experience joins Google’s Android Security team, it tends to take them an hour or more to reverse engineer even a common malware sample. We encourage them to reverse engineer as much malware as possible during their initial weeks, using a number of <span epub:type="pagebreak" id="page_294"/>tools, until they can confidently determine whether an Android app is malware in less than two minutes. Keep this goal in mind as you make progress in your own journey.</p>&#13;
<p class="indent">The use of machine learning to combat malware is still a fairly new, rapidly evolving discipline without an easy-to-use toolchain, making it difficult to get started and become productive fast. You may find it useful to experiment with libraries for extracting and processing features. Also try training and validating the implementation of a few machine learning algorithms that are of interest to you. Once you see initial results (for example, a classifier that correctly identifies an Android app as malware), start working on improving the precision of your models and targeting specific malware categories.</p>&#13;
</div>
</div>
<div style="float: none; margin: 10px 0px 10px 0px; text-align: center;"><p><a href="https://oceanofpdf.com"><i>OceanofPDF.com</i></a></p></div></body></html>