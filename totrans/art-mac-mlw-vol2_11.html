<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">9</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">MUTING AND AUTHORIZATION EVENTS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In the previous chapter, I introduced Apple’s Endpoint Security and its notification events. In this chapter, I move into more advanced topics, such as muting, mute inversion, and authorization events.</p>&#13;
<p class="TX"><i>Muting</i> instructs Endpoint Security to withhold the delivery of certain events, such as those generated from chatty system processes. Conversely, <i>mute inversion</i> gives us the ability to create focused tools that, for example, subscribe solely to events from a specific process or only those related to the access of a few directories. Lastly, Endpoint Security’s authorization capabilities offer a mechanism to prevent undesirable actions altogether.</p>&#13;
<p class="TX">You’ll find the majority of the code snippets presented in this chapter in the <i>ESPlayground</i> project introduced in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. For each topic covered here, I’ll point to the part of this project where the relevant code resides, as well as how to execute it via command line arguments.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-56"/><span class="SANS_Futura_Std_Bold_B_11">Muting</span></h3>&#13;
<p class="TNI">All event monitoring implementations risk facing an overwhelming deluge of events. For example, file I/O events occur constantly as part of normal system activity, and file monitors may generate so much data that finding events tied to malicious processes becomes quite difficult. One solution is to mute irrelevant processes or paths. For example, you’ll likely want to ignore file I/O events involving the temporary directory or originating from certain chatty, legitimate operating system processes (such as the Spotlight indexing service), as these events occur almost constantly and are rarely useful for malware detection.</p>&#13;
<p class="TX">Luckily for us, Endpoint Security provides a flexible and robust muting mechanism. Its <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span> function will suppress events either from a specified process or that match a specified path. The function takes three parameters—a client; a path to a process, directory, or file; and a type:</p>&#13;
&#13;
<pre><code>es_mute_path(es_client_t* _Nonnull client, const char* _Nonnull path,&#13;
es_mute_path_type_t type);&#13;
</code></pre>&#13;
<p class="TX">The mute path type can be one of the four values found in the enumeration of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path_type_t</span> in <i>ESTypes.h</i>:</p>&#13;
&#13;
<pre><code>typedef enum {&#13;
    ES_MUTE_PATH_TYPE_PREFIX,&#13;
    ES_MUTE_PATH_TYPE_LITERAL,&#13;
    ES_MUTE_PATH_TYPE_TARGET_PREFIX,&#13;
    ES_MUTE_PATH_TYPE_TARGET_LITERAL&#13;
} es_mute_path_type_t;&#13;
</code></pre>&#13;
<p class="TX">The types ending in <span class="SANS_TheSansMonoCd_W5Regular_11">PREFIX</span> tell Endpoint Security that the path provided to <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span> is a prefix to a longer path. For example, you could use the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_TARGET_PREFIX</span> option to mute all file I/O events originating from a certain directory. On the other hand, if the mute path type ends in <span class="SANS_TheSansMonoCd_W5Regular_11">LITERAL</span>, the path has to match exactly for events to be muted.</p>&#13;
<p class="TX">Use the initial two values of the enumeration, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_PREFIX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_LITERAL</span>, when you want to mute the path of the process responsible for triggering the Endpoint Security event. For example, <a href="chapter9.xhtml#Lis9-1">Listing 9-1</a> shows a snippet from the <span class="SANS_TheSansMonoCd_W5Regular_11">mute</span> function (in the <i>ESPlayground</i> project’s <i>mute.m</i> file) that instructs Endpoint Security to mute all events originating from <i>mds_stores</i>, a very noisy Spotlight daemon responsible for managing macOS’s metadata indexes.</p>&#13;
<span id="Lis9-1"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #define MDS_STORE "/System/Library/Frameworks/CoreServices.framework/Versions/&#13;
A/Frameworks/Metadata.framework/Versions/A/Support/mds_stores"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> es_mute_path(client, MDS_STORE, ES_MUTE_PATH_TYPE_LITERAL);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: Muting events from the Spotlight service</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>After defining the path to the <i>mds_store</i> binary <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span> API <span class="CodeAnnotation" aria-label="annotation2">❷</span>, passing it an endpoint client (created previously via a call to <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span>), the path to the <i>mds_stores</i> binary, and the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_LITERAL</span> enumeration value.</p>&#13;
<p class="TX">If you instead (or also) want to mute the targets of the events (for example, in a file monitor, the paths to files being created or deleted), use either <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_TARGET_PREFIX</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_PATH_TYPE_TARGET_LITERAL</span>. For instance, if we wanted a file monitor to mute all file events involving the temporary directory associated with the user context under which the monitor process is running, we’d use the code in <a href="chapter9.xhtml#Lis9-2">Listing 9-2</a>.</p>&#13;
<span id="Lis9-2"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> char tmpDirectory[PATH_MAX] = {0};&#13;
realpath([NSTemporaryDirectory() UTF8String], tmpDirectory);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> es_mute_path(client, tmpDirectory, ES_MUTE_PATH_TYPE_TARGET_PREFIX);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Muting all events in the current user’s temporary directory</span></p>&#13;
<p class="TX">We retrieve the temporary directory with the <span class="SANS_TheSansMonoCd_W5Regular_11">NSTemporaryDirectory</span> function and then resolve any symbolic links in this path (for example, resolving <i>/var</i> to <i>/private/var</i>) with the <span class="SANS_TheSansMonoCd_W5Regular_11">realpath</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, we mute all file I/O events whose target paths fall within this directory <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Let’s compile and run the <i>ESPlayground</i> project from the terminal with root privileges. When we launch the Calculator app via Spotlight, it should print out various Endpoint Security events, such as file open and close events:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -mute</b>&#13;
&#13;
ES Playground&#13;
Executing 'mute' logic&#13;
&#13;
<b>muted process:</b> /System/Library/Frameworks/&#13;
CoreServices.framework/Versions/A/Frameworks/Metadata.framework/Versions/A/Support/mds_stores&#13;
&#13;
<b>muted directory:</b> /private/var/folders/zz/zyxvpxvq6csfxvn_n0000000000000/T&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_OPEN&#13;
process: /System/Library/CoreServices/Spotlight.app/Contents/MacOS/Spotlight&#13;
file path: /System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_CLOSE&#13;
process: /System/Library/CoreServices/Spotlight.app/Contents/MacOS/Spotlight&#13;
file path: /System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_OPEN&#13;
process: /System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
file path: /&#13;
</code></pre>&#13;
<p class="TX">But because we specified the <span class="SANS_TheSansMonoCd_W5Regular_11">-mute</span> flag, we won’t receive any events originating from the <i>mds_stores</i> daemon or from within the root user’s temporary directory. We can confirm this fact by simultaneously running <span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>a file monitor that implements no muting. Notice that this time, we receive such events:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty</b>&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_OPEN",&#13;
  "file" : {&#13;
    "destination" : "/private/var/folders/zz/zyxvpxvq6csfxvn_n0000000000000/T",&#13;
    "process" : {&#13;
      "pid" : 540,&#13;
      "name" : "mds_stores",&#13;
      "path" : "/System/Library/Frameworks/CoreServices.framework/&#13;
      Versions/A/Frameworks/Metadata.framework/Versions/A/Support/mds_stores"&#13;
    }&#13;
  }&#13;
  ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Endpoint Security has several other muting-related APIs worth mentioning. The <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_process</span> function provides another way to mute events from a specific process:</p>&#13;
&#13;
<pre><code>es_return_t&#13;
es_mute_process(es_client_t* _Nonnull client, const audit_token_t* _Nonnull audit_token);&#13;
</code></pre>&#13;
<p class="TX">As the definition shows, the function expects a client and an audit token of the process to mute. Because it takes an audit token instead of a path (as with the <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span> function), you can mute a specific instance of a running process. For example, you most likely want to mute events that originate from your own Endpoint Security tool. Using the <span class="SANS_TheSansMonoCd_W5Regular_11">getAuditToken</span> function covered in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a> performs such a muting.</p>&#13;
<span id="Lis9-3"/>&#13;
<pre><code>NSData* auditToken = getAuditToken(getpid());&#13;
&#13;
es_mute_process(client, auditToken.bytes);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: An ES client muting itself</span></p>&#13;
<p class="TX">Besides muting a process entirely, you can also mute just a subset of its events via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_process_events</span> API:</p>&#13;
&#13;
<pre><code>es_return_t es_mute_process_events(es_client_t* _Nonnull client, const audit_token_t*&#13;
_Nonnull audit_token, const es_event_type_t* _Nonnull events, size_t event_count);&#13;
</code></pre>&#13;
<p class="TX">After passing a client and an audit token of the process whose events you intend to mute, you should pass an array of events containing the events to mute, as well as the size of the array.</p>&#13;
<p class="TX">For each muting API, you’ll find a corresponding unmuting function, such as <span class="SANS_TheSansMonoCd_W5Regular_11">es_unmute_path</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">es_unmute_process</span>. Moreover, Endpoint Security provides several global unmuting functions. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">es_unmute_all_paths</span> unmutes all muted paths. You can find more details about these functions in Apple’s Endpoint Security developer documentation.<sup><a role="doc-noteref" id="chapter9_1" href="#chapter9-1">1</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>&#13;
<h3 class="H1" id="sec2"><span id="h1-57"/><span class="SANS_Futura_Std_Bold_B_11">Mute Inversion</span></h3>&#13;
<p class="TNI"><i>Mute inversion</i>, a capability added to Endpoint Security in macOS 13, inverts the logic for for muting, both for processes triggering the events and the events themselves. This allows you, for example, to subscribe to events for a very specific set of processes, directories, or files. You’ll find it useful for tasks such as the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Detecting unauthorized access to user directories, perhaps by ransomware attempting to encrypt user files or stealers attempting to access authentication tokens or cookies<sup><a role="doc-noteref" id="chapter9_2" href="#chapter9-2">2</a></sup></li>&#13;
<li class="BL">Implementing tamper-resistant mechanisms to protect your security tool<sup><a role="doc-noteref" id="chapter9_3" href="#chapter9-3">3</a></sup></li>&#13;
<li class="BL">Capturing events triggered by the actions of a malware specimen during analysis or profiling</li>&#13;
</ul>&#13;
<p class="TX">For example, consider MacStealer, a malware specimen that goes after user cookies.<sup><a role="doc-noteref" id="chapter9_4" href="#chapter9-4">4</a></sup> If we decompile its compiled Python code, we can see that it contains a list of common browsers, such as Chrome and Brave, as well as logic to extract their cookies:</p>&#13;
&#13;
<pre><code>class Browsers:&#13;
def __init__(self, decrypter: object) -&gt; object:&#13;
    ...&#13;
    self.cookies_path = []&#13;
    self.extension_path = []&#13;
    ...&#13;
    self.cookies = []&#13;
    self.decryption_keys = decrypter&#13;
    self.appdata = '/Users/*/Library/Application Support'&#13;
    self.browsers = {...&#13;
        'google-chrome':self.appdata + '/Google/Chrome/',&#13;
        ...&#13;
        'brave':self.appdata + '/BraveSoftware/Brave-Browser/',&#13;
        ...&#13;
    }&#13;
    ...&#13;
def browser_db(self, data, content_type):&#13;
    ...&#13;
    else:&#13;
        if content_type == 'cookies':&#13;
           sql = 'select name,encrypted_value,host_key,path,is_secure,..., from cookies'&#13;
           keys = ['name', 'encrypted_value', 'host_key', 'path',..., 'expires_utc']&#13;
    ...&#13;
    if __name__ == '__main__':&#13;
        decrypted = {}&#13;
        browsers = Browsers()&#13;
        paths = browsers.browser_data()&#13;
</code></pre>&#13;
<p class="TX">The code exfiltrates the collected cookies, giving the malware authors access to a user’s logged-in accounts. By leveraging mute inversion, we can subscribe to file events covering the locations of browser cookies. Any process that attempts to access browser cookies will trigger these events, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>including MacStealer, providing a mechanism to detect and thwart its unauthorized actions.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-66"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Beginning Mute Inversion</span></h4>&#13;
<p class="TNI">To invert muting, invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_invert_muting</span> function, which takes an Endpoint Security client as well as the mute inversion type:</p>&#13;
&#13;
<pre><code>es_return_t es_invert_muting(es_client_t* _Nonnull client, es_mute_inversion_type_t mute_type);</code></pre>&#13;
<p class="TX">You can find the mute inversion types in the <i>ESTypes.h</i> header file:</p>&#13;
&#13;
<pre><code>typedef enum {&#13;
    ES_MUTE_INVERSION_TYPE_PROCESS,&#13;
    ES_MUTE_INVERSION_TYPE_PATH,&#13;
    ES_MUTE_INVERSION_TYPE_TARGET_PATH,&#13;
    ES_MUTE_INVERSION_TYPE_LAST&#13;
} es_mute_inversion_type_t;&#13;
</code></pre>&#13;
<p class="TX">The first two types allow you to mute-invert a process. The first type should be used when you’re looking to mute-invert a process via its audit token, for example, via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_process</span> API. On the other hand, the second type, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_INVERSION_TYPE_PATH</span>, provides the means to identify the process to mute-invert by its path. Finally, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_INVERSION_TYPE_TARGET_PATH</span> should be used when instead you’re looking to mute-invert events related to the target path, such as a directory.</p>&#13;
<p class="TX">Mute inversion applies globally across the specified mute inversion type; that is to say, if you invoked <span class="SANS_TheSansMonoCd_W5Regular_11">es_invert_muting</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_INVERSION_TYPE_PATH</span> type, all muted process paths would unmute. For this reason, it often makes sense to create a new Endpoint Security client specifically for mute inversion. (While the system imposes a limit on the number of clients, your program can create at least several dozen of them before causing an <span class="SANS_TheSansMonoCd_W5Regular_11">ES_NEW_CLIENT_RESULT_ERR_TOO_MANY_CLIENTS</span> error.) Also worth nothing is that since muting inversion will only occur for the specified mute inversion type, you can mix and match mute and mute inversions. For example, you could mute processes while mute-inverting paths found in the events. This would be useful in a scenario where you are perhaps building a directory monitor leveraging mute inversion but want to ignore (mute) events from trusted system processes.</p>&#13;
<p class="TX">Mute inversions also impact the <i>default mute set</i>, a handful of paths to system-critical platform binaries that get muted by default. You can invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_muted_paths_events</span> function to retrieve a list of all muted paths, including the default ones. The default mute set aims to protect clients from deadlocks and timeout panics, so you likely won’t want to generate events for its paths. To avoid doing so, consider invoking <span class="SANS_TheSansMonoCd_W5Regular_11">es_unmute_all_paths</span> before any process-path mute inversions or <span class="SANS_TheSansMonoCd_W5Regular_11">es_unmute_all_target_paths</span> before any target-path mute inversions.</p>&#13;
<p class="TX">Now that you have inverted muting (for example, via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_invert_muting</span> API), you can invoke any of the corresponding, previously mentioned muting APIs, whose muting logic will now be inverted. This is clearly illustrated <span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>in the next section, which makes use of mute inversion to monitor file access within a single directory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-67"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Monitoring Directory Access</span></h4>&#13;
<p class="TNI"><a href="chapter9.xhtml#Lis9-4">Listing 9-4</a> is a snippet of mute inversion code that monitors the opening of files in the logged-in user’s <i>Documents</i> directory. You can find the full implementation in the <span class="SANS_TheSansMonoCd_W5Regular_11">muteInvert</span> function, in the <i>ESPlayground</i> project’s <i>muteInvert.m</i> file.</p>&#13;
<p class="TX">In <span class="Xref">“Authorization Events” on <a href="chapter9.xhtml#pg_213">page 213</a></span>, we’ll combine this approach with authorization access, a useful protection mechanism that could, for example, block ransomware or malware attempting to access sensitive user files.</p>&#13;
<span id="Lis9-4"/>&#13;
<pre><code>NSString* consoleUser =&#13;
(__bridge_transfer NSString*)SCDynamicStoreCopyConsoleUser(NULL, NULL, NULL); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
NSString* docsDirectory =&#13;
[NSHomeDirectoryForUser(consoleUser) stringByAppendingPathComponent:@"Documents"];&#13;
&#13;
es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_OPEN};&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    // Add code here to handle delivered events.&#13;
});&#13;
&#13;
es_unmute_all_target_paths(client); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
es_invert_muting(client, ES_MUTE_INVERSION_TYPE_TARGET_PATH); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
es_mute_path(client, docsDirectory.UTF8String, ES_MUTE_PATH_TYPE_TARGET_PREFIX); <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Monitoring file-open events in the user’s</span> <span class="SANS_Futura_Std_Book_11">Documents</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">directory</span></p>&#13;
<p class="TX">First, we dynamically build the path to the logged-in user’s <i>Documents</i> directory. Because Endpoint Security code always runs with root privileges, most APIs that return the current user would simply return the root. Instead, we make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">SCDynamicStoreCopyConsoleUser</span> API to get the name of the user currently logged in to the system <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Note that the API isn’t aware of the automatic reference counting (ARC) memory management feature, so we add <span class="SANS_TheSansMonoCd_W5Regular_11">__bridge_transfer</span>, which saves us from having to manually free the memory containing the user’s name. Next, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NSHomeDirectoryForUser</span> function to get the home directory, to which we then append the path component <i>Documents</i>.</p>&#13;
<p class="TX">After defining the events of interest and creating a new Endpoint Security client, the code unmutes all target paths <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then it invokes <span class="SANS_TheSansMonoCd_W5Regular_11">es_invert_muting</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_MUTE_INVERSION_TYPE_TARGET_PATH</span> value to invert muting <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Next, the code invokes <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span>, passing in the document’s directory <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Since we’ve inverted muting, this API instructs Endpoint Security to deliver only events that occur in this directory and ignore all others. Finally, we invoke <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> with the events of interest to commence the delivery of such events.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>To complete this example, print out the event, which you’ll recall gets delivered to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_handler_block_t</span> callback block specified in the last parameter to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span>. <a href="chapter9.xhtml#Lis9-5">Listing 9-5</a> shows an inline implementation.</p>&#13;
<span id="Lis9-5"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> es_string_token_t* procPath = &amp;message-&gt;process-&gt;executable-&gt;path;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> es_string_token_t* filePath = &amp;message-&gt;event.open.file-&gt;path;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> printf("event: ES_EVENT_TYPE_NOTIFY_OPEN\n");&#13;
    printf("process: %.*s\n", (int)procPath-&gt;length, procPath-&gt;data);&#13;
    printf("file path: %.*s\n", (int)filePath-&gt;length, filePath-&gt;data);&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: Printing out a file-open Endpoint Security event</span></p>&#13;
<p class="TX">We extract the path to the responsible process. We can always find this process in the <span class="SANS_TheSansMonoCd_W5Regular_11">message</span> structure passed by reference to the handler block. To get its path, we check the <span class="SANS_TheSansMonoCd_W5Regular_11">process</span> structure’s <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> member <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, we extract the path of the file that the process has attempted to open. For <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_OPEN</span> events, we find this path in an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_open_t</span> structure, located in the <span class="SANS_TheSansMonoCd_W5Regular_11">message</span> structure’s <span class="SANS_TheSansMonoCd_W5Regular_11">event</span> member <span class="CodeAnnotation" aria-label="annotation2">❷</span>. After extracting the paths for the responsible process and file, we print them out <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">The tool should now detect any access to files in the <i>Documents</i> directory. You can test this by running <i>ESPlayground</i> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-muteinvert</span> flag. You’ll see that it displays no Endpoint Security events unless they originate within <i>Documents</i>. You can trigger such events by either browsing to the directory via Finder or using the terminal (for example, to list the directory’s contents via <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>):</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -muteinvert</b>&#13;
&#13;
ES Playground&#13;
Executing 'mute inversion' logic&#13;
unmuted all (default) paths&#13;
mute (inverted) /Users/Patrick/Documents&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_OPEN&#13;
process: /System/Library/CoreServices/Finder.app/Contents/MacOS/Finder&#13;
file path: /Users/Patrick/Documents&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_OPEN&#13;
process: /bin/ls&#13;
file path: /Users/Patrick/Documents&#13;
</code></pre>&#13;
<p class="TX">If we extended the example code to also monitor other directories, such as those where browsers store their cookies, we’d easily detect stealers such as MacStealer! In the next section, I’ll cover the powerful authorization event type.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>&#13;
<h3 class="H1" id="sec5"><span id="h1-58"/><span class="SANS_Futura_Std_Bold_B_11">Authorization Events</span></h3>&#13;
<p class="TNI">Unlike notification-based events, which an Endpoint Security client receives after some activity occurs on the system, authorization events allow a client to examine and then allow or deny events <i>before</i> they’ve completed. This feature provides a mechanism for building security tools capable of proactively detecting and thwarting malicious activity. Although working with authorization events involves similar concepts as working with notification events, there are some important differences. To explore these, let’s dive into the code.</p>&#13;
<p class="TX">Conceptually, our goal is simple: design a tool capable of blocking the execution of non-notarized programs originating from the internet. As we’ve seen, the overwhelming majority of macOS malware isn’t notarized, while legitimate software almost always is, making this a powerful approach to stopping malware. When a user attempts to launch an item downloaded from the internet, we’ll intercept this execution before it’s allowed, then check its notarization status. We’ll allow validly notarized items and block all others.</p>&#13;
<p class="TX">At the time of this writing, recent versions of macOS attempt to implement this same check, but they do so less rigorously. First, up until macOS 15, if the user right-clicks a download item, the operating system still provides the option to run non-notarized items. Malware authors are, of course, well aware of this loophole and often leverage it to get their untrusted malware to execute. The prolific macOS adware Shlayer and many macOS stealers are fond of this trick. Moreover, Apple’s implementation to prevent non-notarized code on macOS has been rife with exploitable bugs (such as CVE-2021-30657 and CVE-2021-30853), rendering it essentially useless.<sup><a role="doc-noteref" id="chapter9_5" href="#chapter9-5">5</a></sup></p>&#13;
<p class="TX">I implemented a notarization check in one of Objective-See’s most popular tools, BlockBlock, discussed in detail in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. When run in notarization mode, this tool blocks any downloaded binary that isn’t notarized, including malware that attempts to exploit CVE-2021-30657 and CVE-2021-30853, well before patches from Apple were available.<sup><a role="doc-noteref" id="chapter9_6" href="#chapter9-6">6</a></sup> We’ll roughly follow BlockBlock’s approach here. Note that in your own implementation, you might take a less draconian approach; for example, rather than blocking all non-notarized items, you might block only those that users may have been tricked into running. (In macOS 15, Apple introduced the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE</span> event you may be able to leverage to detect this.) Or you might collect non-notarized binaries for external analysis or subject them to other heuristics mentioned in this book before deciding whether to prevent their execution.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-68"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Client and Subscribing to Events</span></h4>&#13;
<p class="TNI">In this section, we subscribe to Endpoint Security authorization events before discussing how to respond to such events in a timely manner. You can find a full implementation of the code mentioned in this section in the <span class="SANS_TheSansMonoCd_W5Regular_11">authorization</span> function, found in the <i>ESPlayground</i> project’s <i>authorization.m</i> file.</p>&#13;
<p class="TX">As when working with notification events, we start by creating an Endpoint Security client, specify an <span class="SANS_TheSansMonoCd_W5Regular_11">es_handler_block_t</span> block, and subscribe to events of interest (<a href="chapter9.xhtml#Lis9-6">Listing 9-6</a>).</p>&#13;
<span id="Lis9-6"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>es_client_t* client = NULL;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> es_event_type_t events[] = {ES_EVENT_TYPE_AUTH_EXEC};&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    // Add logic to allow or block processes.&#13;
});&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Subscribing to authorization events for process executions</span></p>&#13;
<p class="TX">To block non-notarized processes, we need to subscribe to only a single authorization event: <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Apple’s developer documentation succinctly describes it as the event type for any process that “requests permission from the operating system to execute another image.”<sup><a role="doc-noteref" id="chapter9_7" href="#chapter9-7">7</a></sup> Once the call to <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> returns, Endpoint Security will invoke our code anytime a new process is about to be executed.</p>&#13;
<p class="TX">Next, we must respond to the operating system with a decision to either authorize or deny the delivered event. To respond, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span> API, defined as follows in <i>ESClient.h</i>:</p>&#13;
&#13;
<pre><code>es_respond_result_t es_respond_auth_result(es_client_t* _Nonnull client,&#13;
const es_message_t* _Nonnull message, es_auth_result_t result, bool cache);&#13;
</code></pre>&#13;
<p class="TX">The function takes the client that received the message, the delivered message, the authorization result, and a flag indicating whether the results should be cached. To allow a message, invoke this function with an <span class="SANS_TheSansMonoCd_W5Regular_11">es_auth_result_t</span> value of <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_ALLOW</span>. To deny the message, specify a value of <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span>. If you pass in <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for the cache flag, Endpoint Security will cache the authorization decision, meaning future events from the same process may not trigger additional authorization events. This, of course, has performance benefits, though some important nuances to be aware of. First, imagine that you’ve cached an authorization decision for a process execution event. Even if that process is executed with different arguments, no additional authorization event will be generated, which could be problematic if a detection heuristic makes use of process arguments. Second, be aware that the cache is global for the system, meaning if any other Endpoint Security client does not cache an event, you’ll still receive it (even if you’ve previously cached it).</p>&#13;
<p class="TX">Let’s build upon the code in <a href="chapter9.xhtml#Lis9-6">Listing 9-6</a> to extract the path of the process about to be spawned and then determine how to respond. For simplicity, we’ll just allow all processes in this example (<a href="chapter9.xhtml#Lis9-7">Listing 9-7</a>).</p>&#13;
<span id="Lis9-7"/>&#13;
<pre><code>es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_AUTH_EXEC};&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> es_process_t* process = message-&gt;event.exec.target;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> es_string_token_t* procPath = &amp;process-&gt;executable-&gt;path;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>    printf("\nevent: ES_EVENT_TYPE_AUTH_EXEC\n");&#13;
    printf("process: %.*s\n", (int)procPath-&gt;length, procPath-&gt;data);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);&#13;
&#13;
});&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Handling process authorization events</span></p>&#13;
<p class="TX">Within the callback block, we extract information about the process that is about to be spawned. First, we get a pointer to its <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, found with the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure in the Endpoint Security message <span class="CodeAnnotation" aria-label="annotation1">❶</span>. From this, we extract just its path <span class="CodeAnnotation" aria-label="annotation2">❷</span> and print it out. Finally, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span> API with <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_ALLOW</span> to tell the Endpoint Security subsystem to authorize that process’s execution <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In</i> <span class="note_Italic">ESTypes.h</span><i>, Apple specifies an important but easy-to-overlook nuance: for file authorization events (<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ES_EVENT_TYPE_AUTH_OPEN</span>) only, your code must provide an authorization response via the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_respond_flags_result</span> function, not via the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_respond_auth_result</span> function. The same header file notes that when invoking the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_respond_flags_result</span> function, you should pass a value of 0 to deny the event and <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UINT32_MAX</span> to allow it.</i></p>&#13;
<p class="TX">Let’s run <i>ESPlayground</i> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-authorization</span> flag and then launch the Calculator application:</p>&#13;
&#13;
<pre><code>#<b> ESPlayground.app/Contents/MacOS/ESPlayground -authorization</b>&#13;
&#13;
ES Playground&#13;
Executing 'authorization' logic&#13;
&#13;
event: ES_EVENT_TYPE_AUTH_EXEC&#13;
process: /System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
</code></pre>&#13;
<p class="TX">We see the authorization event, and because we’re allowing all processes, Endpoint Security doesn’t block it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-69"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Meeting Message Deadlines</span></h4>&#13;
<p class="TNI">There is one very important caveat to responding to authorization events: if we miss the response deadline, Endpoint Security will allow the event and forcefully kill our client.</p>&#13;
&#13;
<pre><code>Exception Type:      EXC_CRASH (SIGKILL)&#13;
Exception Codes:     0x0000000000000000, 0x0000000000000000&#13;
Termination Reason:  Namespace ENDPOINTSECURITY, Code 2 EndpointSecurity client&#13;
terminated because it failed to respond to a message before its deadline&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>From a system and usability point of view, this approach makes sense. If the program takes too long to respond, the entire system could lag or, worse, hang.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span> structure has a field named <span class="SANS_TheSansMonoCd_W5Regular_11">deadline</span> that tells us exactly how long we have to respond to the message. The header file also notes that the deadline can vary substantially between each message; thus, our code should inspect each message’s deadline accordingly.</p>&#13;
<p class="TX">Let’s look at how BlockBlock’s process monitoring logic handles deadlines.<sup><a role="doc-noteref" id="chapter9_8" href="#chapter9-8">8</a></sup> Deadlines are especially important for this tool, as it waits for the user’s input before authorizing or denying the non-notarized process, meaning it faces a very real possibility of hitting the deadline (<a href="chapter9.xhtml#Lis9-8">Listing 9-8</a>).</p>&#13;
<span id="Lis9-8"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> uint64_t deadline = message-&gt;deadline - mach_absolute_time();&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if(0 != dispatch_semaphore_wait(semaphore,&#13;
    dispatch_time(DISPATCH_TIME_NOW, machTimeToNanoseconds(deadline)&#13;
    - (1 * NSEC_PER_SEC)))) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);&#13;
  }&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: BlockBlock’s handling of Endpoint Security message deadlines</span></p>&#13;
<p class="TX">First, the code creates a semaphore <span class="CodeAnnotation" aria-label="annotation1">❶</span> and computes the deadline <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Because Endpoint Security reports the message deadline in absolute time, the code subtracts the current time from it to figure out how long it has left. Next, the code submits a block to execute asynchronously in a background queue <span class="CodeAnnotation" aria-label="annotation3">❸</span>, where it delivers the message to the user and, in another asynchronous block, waits for the response. I’ve omitted this part of the code to keep things concise, as its specifics aren’t relevant.</p>&#13;
<p class="TX">Performing time-consuming processing in another asynchronous queue allows the code to signal the semaphore once the processing is complete and avoid the timeout, which the code sets up next <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Once BlockBlock has delivered the message to the user and is awaiting a response, it invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_semaphore_wait</span> function to wait on the semaphore until a certain time. You probably guessed it: the function waits until right before the message’s deadline is hit. If a timeout occurs (meaning a user response didn’t signal the semaphore and the message deadline is about to be hit), the code has no choice but to respond, which it does by defaulting to authorizing the event <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Note that the Mach absolute time value returned by a function can vary between processes, depending on whether they’re native or translated. To maintain consistency, you should apply a timebase, which you can retrieve using the <span class="SANS_TheSansMonoCd_W5Regular_11">mach_timebase_info</span> function. Apple documentation illustrates this in the following code, which converts a mach time value to nanoseconds using timebase information:</p>&#13;
&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>uint64_t MachTimeToNanoseconds(uint64_t machTime) {&#13;
    uint64_t nanoseconds = 0;&#13;
    static mach_timebase_info_data_t sTimebase;&#13;
    if (sTimebase.denom == 0)&#13;
        (void)mach_timebase_info(&amp;sTimebase);&#13;
&#13;
    nanoseconds = ((machTime * sTimebase.numer) / sTimebase.denom);&#13;
    return nanoseconds;&#13;
}&#13;
</code></pre>&#13;
<p class="TX">You might have noticed that the code in <a href="chapter9.xhtml#Lis9-8">Listing 9-8</a> leveraged this function when computing the wait time for the dispatch semaphore.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you’re asynchronously processing Endpoint Security messages, such as when asking a user for input and awaiting their response, you must retain the message via the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_retain_message API</span>. Once you’re done with the message, you must release it with a call to <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_release_message</span>.</i></p>&#13;
<p class="TX">Now that you’ve seen how to respond to Endpoint Security authorization events while taking deadlines into account, you’re ready to look at the last piece of the “blocking non-notarized processes” puzzle.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-70"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Binary Origins</span></h4>&#13;
<p class="TNI">Once we’ve registered for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span> events, the system will invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_handler_block_t</span> block passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> function before each new process is spawned. In this block, we’ll add logic to deny non-notarized processes from remote locations only. That last part is important, as local platform binaries aren’t notarized but should, of course, be allowed. Along the same lines, you may want to consider allowing applications from the official Mac App Store. Though not notarized, they’ve passed a similar and (hopefully) stringent Apple review process.</p>&#13;
<p class="TX">To determine if a process’s binary originated from a remote location, we’ll defer to macOS by checking whether the binary has been translocated or has the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute. If either condition is true, the operating system has marked the item as originating from a remote source. <i>Translocation</i> is a security mitigation built into recent versions of macOS designed to thwart relative dynamic library hijacking attacks.<sup><a role="doc-noteref" id="chapter9_9" href="#chapter9-9">9</a></sup></p>&#13;
<p class="TX">In short, when a user attempts to open an executable item from a downloaded disk image or ZIP file, macOS will first create a random read-only mount containing a copy of the item, then launch this copy. If we can programmatically determine that a process about to be executed has been translocated, we know we should subject it to a notarization check.</p>&#13;
<p class="TX">To check if an item has been translocated, we can invoke the private <span class="SANS_TheSansMonoCd_W5Regular_11">SecTranslocateIsTranslocatedURL</span> API. This function takes several parameters, including the path of the item to check and a pointer to a Boolean flag that macOS will set to true if it has translocated the item. Because the API is private, we must dynamically resolve it before we can invoke it. The code in <a href="chapter9.xhtml#Lis9-9">Listing 9-9</a> does both tasks.<sup><a role="doc-noteref" id="chapter9_10" href="#chapter9-10">10</a></sup></p>&#13;
<span id="Lis9-9"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>#import &lt;dlfcn.h&gt;&#13;
BOOL isTranslocated(NSString* path) {&#13;
    BOOL isTranslocated = NO;&#13;
    void* handle = dlopen(&#13;
    "/System/Library/Frameworks/Security.framework/Security", RTLD_LAZY); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    BOOL (*SecTranslocateIsTranslocatedURL)(CFURLRef path, bool* isTranslocated,&#13;
    CFErrorRef* __nullable error) = dlsym(handle,"SecTranslocateIsTranslocatedURL"); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    SecTranslocateIsTranslocatedURL((__bridge CFURLRef)([NSURL fileURLWithPath:path]),&#13;
    &amp;isTranslocated, NULL); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    return isTranslocated;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: A helper function that uses private APIs to determine whether an item has been translocated</span></p>&#13;
<p class="TX">The code loads the <i>Security</i> framework, which contains the <span class="SANS_TheSansMonoCd_W5Regular_11">SecTranslocateIsTranslocatedURL</span> API <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Once it’s loaded, the code resolves the API via <span class="SANS_TheSansMonoCd_W5Regular_11">dlsym</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then invokes the function with the path of the item to check <span class="CodeAnnotation" aria-label="annotation3">❸</span>. When the API returns, it will set the second parameter to the result of the translocation check.</p>&#13;
<p class="TX">Another way to check whether an item has a remote origin is via the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute, added either by the application responsible for downloading the item or by the operating system directly, if the application has set <span class="SANS_TheSansMonoCd_W5Regular_11">LSFileQuarantineEnabled = 1</span> in its <i>Info.plist</i> file. You can programmatically retrieve the value of an item’s extended attribute using various private <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_*</span> APIs found in <i>/usr/lib/system/libquarantine.dylib</i>, though you must first dynamically resolve these functions. Invoke them in the following manner:</p>&#13;
<p class="NLF">  1.  Invoke <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_alloc</span> to allocate a <span class="SANS_TheSansMonoCd_W5Regular_11">_qtn_file</span> structure.</p>&#13;
<p class="NL">  2.  Invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_init_with_path</span> API with the <span class="SANS_TheSansMonoCd_W5Regular_11">_qtn_file</span> pointer and the path of the item whose quarantine attributes you wish to retrieve. If this function returns <span class="SANS_TheSansMonoCd_W5Regular_11">QTN_NOT_QUARANTINED</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>), the item isn’t quarantined.</p>&#13;
<p class="NL">  3.  Invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_get_flags</span> API with the <span class="SANS_TheSansMonoCd_W5Regular_11">_qtn_file</span> pointer to retrieve the actual value of the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute.</p>&#13;
<p class="NL">  4.  If the <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_init_with_path</span> function didn’t return <span class="SANS_TheSansMonoCd_W5Regular_11">QTN_NOT_QUARANTINED</span>, you’ll know that the item is quarantined, but you may want to check whether a user previously approved the file. You can determine this by checking the value returned by <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_get_flags</span>, where the <span class="SANS_TheSansMonoCd_W5Regular_11">QTN_FLAG_USER_APPROVED</span> (0x0040) bit may be set.</p>&#13;
<p class="NLL">  5.  Make sure to free the <span class="SANS_TheSansMonoCd_W5Regular_11">_qtn_file</span> structure by calling <span class="SANS_TheSansMonoCd_W5Regular_11">qtn_file_free</span>.</p>&#13;
<p class="TX">In several cases, macOS didn’t appropriately classify nonlocal items as having originated from a remote source. For example, in CVE-2023-27951, the operating system failed to apply the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute. In production code, you might therefore want to take a more comprehensive approach to determining a binary’s origins. For instance, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>you could create a file monitor to detect binary downloads and then subject these binaries to the notarization checks, or just block any nonplatform binary that isn’t notarized. And, yes, malware (once it’s off and running) may remove the quarantine extended attribute from other components it has downloaded prior to their execution to potentially bypass macOS or BlockBlock checks. As such, you may also want to subscribe to the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT _TYPE_AUTH_DELETEEXTATTR</span> Endpoint Security event, which will be able to detect and prevent the removal of the quarantine attribute.</p>&#13;
<p class="TX">Now that we can determine whether a process originated from a remote source, we must check whether the binary backing the process is notarized. As you saw in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, this is as easy as invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API with the appropriate requirement string.</p>&#13;
<p class="TX">If BlockBlock ascertains that the process about to be executed is from a remote source and not notarized, it will alert the user to request their input. If the user decides that the process is, for example, untrustworthy or unrecognized, BlockBlock will invoke the function in <a href="chapter9.xhtml#Lis9-10">Listing 9-10</a> to block it.</p>&#13;
<span id="Lis9-10"/>&#13;
<pre><code>-(BOOL)block:(Event*)event {&#13;
    BOOL blocked = NO;&#13;
&#13;
    if(YES != (blocked = [self respond:event action:ES_AUTH_RESULT_DENY])) {&#13;
        os_log_error(logHandle, "ERROR: failed to block %{public}@", event.process.name);&#13;
    }&#13;
&#13;
    return blocked;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: Blocking untrustworthy processes</span></p>&#13;
<p class="TX">It invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">respond:action:</span> method with the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span> constant. If we look at this method, we see that, at its core, it just invokes <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span>, passing along the specified allow or deny action to the Endpoint Security subsystem. Also, as <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> is passed in for the cache flag, subsequent executions of the same process will not generate additional authorization events, thus providing a noticeable performance boost (<a href="chapter9.xhtml#Lis9-11">Listing 9-11</a>).</p>&#13;
<span id="Lis9-11"/>&#13;
<pre><code>-(BOOL)respond:(Event*)event action:(es_auth_result_t)action {&#13;
    ...&#13;
    result = es_respond_auth_result(event.esClient, event.esMessage, action, true);&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-11: Passing Endpoint Security the action to take</span></p>&#13;
<p class="TX">For a full implementation that blocks non-notarized processes via Endpoint Security, see BlockBlock’s process plug-in.<sup><a role="doc-noteref" id="chapter9_11" href="#chapter9-11">11</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-71"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Blocking Background Task Management Bypasses</span></h4>&#13;
<p class="TNI">Let’s consider another example that uses Endpoint Security authorization events to detect malware, this time by focusing on attempts to leverage <span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>exploits that bypass built-in macOS security mechanisms. While the use of these exploits isn’t yet widespread, the inclusion of new security mechanisms in macOS has increasingly forced malware to employ new techniques to achieve their malicious objectives, so monitoring for these exploits may aid your detections.</p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, I discussed macOS’s new Background Task Management (BTM) database, which monitors for persistent items, generates alerts for them, and globally tracks their behavior. BTM is problematic for malware hoping to persist, because users will now receive an alert when the malware gets installed. For example, <a href="chapter9.xhtml#fig9-1">Figure 9-1</a> shows the BTM alert that users receive when malware known as DazzleSpy persistently installs itself as a binary named <i>softwareupdate</i>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-1" src="../images/Figure9-1.jpg" alt="" width="900" height="226"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: A BTM alert showing that a binary named</span> <span class="SANS_Futura_Std_Book_11">softwareupdate</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">has been persistently installed</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Luckily for the malware, my research into BTM revealed that Apple’s original implementation was easy to subvert in several ways, preventing this alert. This section details two such bypasses and shows how to leverage Endpoint Security to detect and block these subversions. Note that I informed Apple about these issues, and, at least in macOS 15 (and perhaps on earlier versions of macOS), they appear to have been fixed. Even so, you could adapt the code in this section to detect other local exploits.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Manual Database Resets</span></h5>&#13;
<p class="TNI">The first method of bypassing BTM was incredibly simple. Recall that <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> discussed <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span>, which ships with macOS and allows users to interface with the BTM database. One of its command line options, <span class="SANS_TheSansMonoCd_W5Regular_11">resetbtm</span>, will clear the database, causing it to be rebuilt. Once this command is run, however, the system won’t deliver subsequent BTM alerts until it reboots, even though items can still persist.</p>&#13;
<p class="TX">Thus, malware wanting to avoid generating BTM alerts could simply execute <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">resetbtm</span> command before executing its persistence code. The technique has yet to be observed in the wild but is easy to exploit, as shown in the following log message, generated after a manual database reset. These message shows that while the BTM daemon detected DazzleSpy’s persistent install, it decided not to post an advisory alert:</p>&#13;
&#13;
<pre><code>% <b>log stream</b>&#13;
backgroundtaskmanagementd: registerLaunchItem: result=no error, new item&#13;
disposition=[enabled, allowed, visible, not notified],&#13;
identifier=com.apple.softwareupdate,&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>url=file:///Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist&#13;
backgroundtaskmanagementd: <b>should post advisory=false</b> for uid=501, id=&#13;
6ED3BEBC-8D60-45ED-8BCC-E0163A8AA806, item=softwareupdate&#13;
</code></pre>&#13;
<p class="TX">Under normal circumstances, users have no reason to reset the BTM database. So, we can thwart this exploit by subscribing to Endpoint Security process events and blocking the spawning of <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> when it is executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">resetbtm</span> argument.</p>&#13;
<p class="TX">To detect the execution of processes, including <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span>, we can register for the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> event discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. We can access the process’s path via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> process structure and extract its arguments with the <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg_count</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg</span> helper functions. Once you’ve extracted the path and arguments, simple string comparisons should tell you if the reported process event is a result of <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> spawned with the <span class="SANS_TheSansMonoCd_W5Regular_11">resetbtm</span> argument.</p>&#13;
<p class="TX">Of course, you’ll likely want to block these events, which you can do by registering for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span>. This event’s callback will be invoked with an Endpoint Security message containing a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. From this, you can extract both the path and the arguments of the process about to be spawned, then block the spawning by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span> function with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Stop Signals</span></h5>&#13;
<p class="TNI">While researching the BTM subsystem, I came across another trivial way to bypass its alerts.<sup><a role="doc-noteref" id="chapter9_12" href="#chapter9-12">12</a></sup> In short, malware could easily send a stop (<span class="SANS_TheSansMonoCd_W5Regular_11">SIGSTOP</span>) signal to the BTM agent responsible for displaying the persistence advisory message to the user. Once this component halted, the malware could persist without the user being alerted. To detect and block this bypass, we can lean on Endpoint Security once again. As it’s extremely unlikely that a user would send a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGSTOP</span> signal to the BTM agent under normal circumstances, we can assume this event is malware attempting to subset the subsystem.</p>&#13;
<p class="TX">The year following my presentation, researchers at Sentinel One uncovered malware taking a similar (albeit less elegant) approach. In their report,<sup><a role="doc-noteref" id="chapter9_13" href="#chapter9-13">13</a></sup> the researchers noted that the malicious code would continually send a kill signal to macOS’s Notification Center process to block the BTM’s persistence advisory message, which the system would normally display when the malware persisted.</p>&#13;
<p class="TX">We can detect signals with the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_SIGNAL</span> event or, better yet, block signals altogether with the corresponding authorization event, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_SIGNAL</span>. In <a href="chapter9.xhtml#Lis9-12">Listing 9-12</a>, we focus on the latter task.</p>&#13;
<span id="Lis9-12"/>&#13;
<pre><code>es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_AUTH_SIGNAL};&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    int signal = message-&gt;event.signal.sig; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    es_process_t* sourceProcess = message-&gt;process; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    es_process_t* targetProcess = message-&gt;event.signal.target; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>    // Add code to check if signal is a SIGSTOP or SIGKILL being sent to a process&#13;
    // involved in showing user notification alerts.&#13;
&#13;
});&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-12: Subscribing to authorization events for signal deliveries</span></p>&#13;
<p class="TX">Whenever a process attempts to send a signal, Endpoint Security will invoke the callback with a message containing an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_signal_t</span> structure. The code extracts the type of signal <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as well as the source <span class="CodeAnnotation" aria-label="annotation2">❷</span> and target processes <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">We can check whether the signal is a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGSTOP</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</span> and whether the process that would receive the signal is either the BTM agent or the Notification Center. If so, we simply deny the signal delivery by invoking <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span> value (<a href="chapter9.xhtml#Lis9-13">Listing 9-13</a>).</p>&#13;
<span id="Lis9-13"/>&#13;
<pre><code>if((signal == SIGSTOP) || (signal == SIGKILL)) {&#13;
    pid_t targetPID = audit_token_to_pid(targetProcess-&gt;audit_token);&#13;
&#13;
    if((targetPID == btmAgentPID) || (targetPID == notificationCenterPID)) {&#13;
        es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-13: Denying suspicious SIGSTOP or SIGKILL signals</span></p>&#13;
<p class="TX">Note that elsewhere in your code, you should probably look up and save the process ID for the BTM agent and Notification Center process, as you wouldn’t want to look it up each time a signal is delivered. You’d also likely want to log a message that includes information about the source process attempting to send the suspicious signal or else collect it for further examination.</p>&#13;
<p class="TX">If you implement this code, compile it, run it, and then manually attempt to subvert the notifications from the BTM subsystem by stopping the agent, your actions should now fail:</p>&#13;
&#13;
<pre><code>% <b>pgrep BackgroundTaskManagementAgent</b>&#13;
590&#13;
&#13;
% <b>kill -SIGSTOP 590</b>&#13;
kill: kill 590 failed: operation not permitted&#13;
</code></pre>&#13;
<p class="TX">In the terminal, we get the process ID of the BTM agent (590, in this instance). Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">kill</span> command to send a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGSTOP</span> signal to the agent. This will trigger the delivery of an <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_SIGNAL</span> event to our program, which will deny it, resulting in the “operation not permitted” message.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/>&#13;
<h3 class="H1" id="sec12"><span id="h1-59"/><span class="SANS_Futura_Std_Bold_B_11">Building a File Protector</span></h3>&#13;
<p class="TNI">I’ll wrap up the discussion of the Endpoint Security framework by developing a proof-of-concept file protector. You can find its full implementation in the <span class="SANS_TheSansMonoCd_W5Regular_11">protect</span> function, in the <i>ESPlayground</i> project’s <i>protect.m</i> file.</p>&#13;
<p class="TX">Our code will monitor a specific directory (for example, the user’s home directory or the directory containing browser cookies) and allow only authorized processes to access it. Whenever a process attempts to access a file in the directory, Endpoint Security will trigger an authorization event, giving our code an opportunity to closely examine the process and decide whether to allow it. In this example, we’ll allow only platform and notarized binaries and block the rest.</p>&#13;
<p class="TX">This file protector is conceptually similar to Apple’s Transparency, Consent, and Control (TCC), but it adds another level of protection. After all, users may naively grant TCC permissions to malware, making previously protected files accessible, and malware often exploits or bypasses TCC itself, as in the case of the XCSSET malware.<sup><a role="doc-noteref" id="chapter9_14" href="#chapter9-14">14</a></sup> Finally, you may want to provide authorized access (and detect unauthorized access) to files located outside TCC’s protected directories, such as the cookies files for certain third-party browsers.</p>&#13;
<p class="TX">Earlier in this chapter, I discussed monitoring the logged-in user’s <i>Documents</i> directory via a notify event. The code in this section is similar, except it covers the user’s entire home directory and extends the list of events of interest to also include those related to attempted file deletions. Most notably, this code leverages Endpoint Security authorization events to proactively block untrusted access. As usual, we’ll start by specifying the Endpoint Security events of interest, creating an Endpoint Security client, setting up muting inversion, and finally subscribing to the events (<a href="chapter9.xhtml#Lis9-14">Listing 9-14</a>).</p>&#13;
<span id="Lis9-14"/>&#13;
<pre><code>NSString* consoleUser =&#13;
(__bridge_transfer NSString*)SCDynamicStoreCopyConsoleUser(NULL, NULL, NULL);&#13;
&#13;
NSString* homeDirectory = NSHomeDirectoryForUser(consoleUser);&#13;
&#13;
es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_AUTH_OPEN, ES_EVENT_TYPE_AUTH_UNLINK}; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    // Add code here to implement logic to examine process and respond to event.&#13;
});&#13;
&#13;
es_unmute_all_target_paths(client); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
es_invert_muting(client, ES_MUTE_INVERSION_TYPE_TARGET_PATH);&#13;
es_mute_path(client, homeDirectory.UTF8String, ES_MUTE_PATH_TYPE_TARGET_PREFIX); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-14: Setting up an Endpoint Security client to authorize file access</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>Several Endpoint Security authorization events relate to file access. Here, we use <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_OPEN</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_UNLINK</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which give us the ability to authorize programs that attempt to open or delete files. The former event can detect a range of malware with either ransomware or stealer capabilities, while the latter event could perhaps detect and prevent malware with wiper capabilities that might try to delete or wipe important files.</p>&#13;
<p class="TX">After creating a new Endpoint Security client (whose handler block we’ll write shortly) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the code sets up muting inversion <span class="CodeAnnotation" aria-label="annotation3">❸</span>, given that we’re interested only in events related to the directory we’re about to specify. It dynamically builds a path to the logged-in user’s home directory, then invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">es_mute_path</span> API. Because we’ve inverted muting, this API tells the Endpoint Security subsystem to deliver events that occur within the specified path only. After the code calls <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span>, Endpoint Security will start delivering events by executing the handler block specified in the call to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> function.</p>&#13;
<p class="TX">How might we implement such a block? To keep things simple, let’s first assume we’ll allow any access (<a href="chapter9.xhtml#Lis9-15">Listing 9-15</a>).</p>&#13;
<span id="Lis9-15"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    switch(message-&gt;event_type) {&#13;
        case ES_EVENT_TYPE_AUTH_OPEN:&#13;
            es_respond_flags_result(client, message, UINT32_MAX, false); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
            break;&#13;
        case ES_EVENT_TYPE_AUTH_UNLINK:&#13;
            es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            break;&#13;
        ...&#13;
    }&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-15: Allowing all file accesses</span></p>&#13;
<p class="TX">Recall that for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_OPEN</span> events, Apple documentation states that we have to respond with the <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_flags_result</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. To tell the Endpoint Security subsystem to allow the event, we invoke this function with <span class="SANS_TheSansMonoCd_W5Regular_11">UINT32_MAX</span>. For the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_UNLINK</span> event, we respond using <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span>, as usual <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">On the flip side, <a href="chapter9.xhtml#Lis9-16">Listing 9-16</a> shows the code to deny all file opens or deletions in the directory.</p>&#13;
<span id="Lis9-16"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    switch(message-&gt;event_type) {&#13;
        case ES_EVENT_TYPE_AUTH_OPEN:&#13;
            es_respond_flags_result(client, message, 0, false); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
            break;&#13;
        case ES_EVENT_TYPE_AUTH_UNLINK:&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/>            es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            break;&#13;
        ...&#13;
    }&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-16: Denying all file accesses</span></p>&#13;
<p class="TX">The only changes from the code to allow all events is that we now call the <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_flags_result</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> as its third parameter and pass <span class="SANS_TheSansMonoCd_W5Regular_11">es_respond_auth_result</span> the value <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Let’s expand this code to extract the path of the process responsible for the event, as well as the path of the file the process is trying to open or delete (<a href="chapter9.xhtml#Lis9-17">Listing 9-17</a>).</p>&#13;
<span id="Lis9-17"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    es_string_token_t* filePath = NULL;&#13;
    es_string_token_t* procPath = &amp;message-&gt;process-&gt;executable-&gt;path; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    switch(message-&gt;event_type) {&#13;
        case ES_EVENT_TYPE_AUTH_OPEN:&#13;
            filePath = &amp;message-&gt;event.open.file-&gt;path; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            es_respond_flags_result(client, message, 0, false);&#13;
            break;&#13;
        case ES_EVENT_TYPE_AUTH_UNLINK:&#13;
            filePath = &amp;message-&gt;event.unlink.target-&gt;path; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);&#13;
            break;&#13;
        ...&#13;
    }&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-17: Extracting process paths and filepaths</span></p>&#13;
<p class="TX">We can find the responsible process’s path in the <span class="SANS_TheSansMonoCd_W5Regular_11">process</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">message</span> structure for any Endpoint Security event <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but other information is event specific. Thus, we extract the file in the handler for each event type. For <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_OPEN</span> events, we find it in an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_open_t</span> structure <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_UNLINK</span> events, it lives in an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_unlink_t</span> structure <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Now we should allow or deny file openings and deletions based on some rules, depending on what we’re attempting to protect. Recall that the MacStealer malware attempts to steal browser cookies. Generally speaking, no third-party process other than the browser should access its cookies. Thus, you may simply want to implement a deny rule with an exception to allow the browser itself. Via the process ID, path, or, better yet, code signing information, it should be easy to identify whether the browser is the responsible process.</p>&#13;
<p class="TX">If you’re protecting files in the user’s home directory, this kind of “deny all with exceptions” approach would likely impact the usability of the system. Thus, you may want to use heuristics, such as authorizing only notarized applications, those from the App Store, or platform binaries. However, malware <span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/>sometimes delegates actions to shell commands, which are platform binaries, so you’ll likely want to examine the process hierarchy of the responsible process to make sure it’s not being abused in malicious ways.</p>&#13;
<p class="TX">In this example, we’ll keep things simple by allowing only platform or notarized binaries to access the current user’s home directory (<a href="chapter9.xhtml#Lis9-18">Listing 9-18</a>).</p>&#13;
<span id="Lis9-18"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    es_string_token_t* filePath = NULL;&#13;
    es_string_token_t* procPath = &amp;message-&gt;process-&gt;executable-&gt;path;&#13;
&#13;
    BOOL isTrusted = ((YES == message-&gt;process-&gt;is_platform_binary) ||&#13;
    (YES == isNotarized(message-&gt;process)));&#13;
&#13;
    switch(message-&gt;event_type) {&#13;
        case ES_EVENT_TYPE_AUTH_OPEN:&#13;
            filePath = &amp;message-&gt;event.open.file-&gt;path;&#13;
            printf("\nevent: ES_EVENT_TYPE_AUTH_OPEN\n");&#13;
            printf("responsible process: %.*s\n", (int)procPath-&gt;length, procPath-&gt;data);&#13;
            printf("target file path: %.*s\n", (int)filePath-&gt;length, filePath-&gt;data);&#13;
            if(YES == isTrusted) {&#13;
                printf("process is trusted, so will allow event\n");&#13;
                es_respond_flags_result(client, message, UINT32_MAX, false);&#13;
            } else {&#13;
                printf("process is *not* trusted, so will deny event\n");&#13;
                es_respond_flags_result(client, message, 0, false);&#13;
            }&#13;
            break;&#13;
&#13;
        case ES_EVENT_TYPE_AUTH_UNLINK:&#13;
            filePath = &amp;message-&gt;event.unlink.target-&gt;path;&#13;
            printf("\nevent: ES_EVENT_TYPE_AUTH_UNLINK\n");&#13;
            printf("responsible process: %.*s\n", (int)procPath-&gt;length, procPath-&gt;data);&#13;
            printf("target file path: %.*s\n", (int)filePath-&gt;length, filePath-&gt;data);&#13;
            if(YES == isTrusted) {&#13;
                printf("process is trusted, so will allow event\n");&#13;
                es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);&#13;
            } else {&#13;
                printf("process is *not* trusted, so will deny event\n");&#13;
                es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);&#13;
            }&#13;
            break;&#13;
        ...&#13;
    }&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-18: Granting file access for platform and notarized processes only</span></p>&#13;
<p class="TX">We check whether the responsible process either is a platform binary or has been notarized. Checking whether a process is a platform binary is as easy as checking the <span class="SANS_TheSansMonoCd_W5Regular_11">is_platform_binary</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">process</span> structure found in the delivered Endpoint Security message. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we used Apple’s code signing APIs to figure out whether a process is notarized; we won’t cover <span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>this process again here, except to note that we’ve created a simple helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">isNotarized</span> that uses the responsible process’s audit token to check its notarization status. (If you’re interested in seeing the full implementation of this function, see the <i>protect.m</i> file in the <i>ESPlayground</i> project.)</p>&#13;
<p class="TX">It’s also worth pointing out that the logical OR operator will short-circuit if the first condition is true, so we put the platform binary check first. Because it’s a simple check against a Boolean value in a structure, it’s less computationally intensive than a full notarization check, so we perform the more efficient check first and perform the second check only if needed.</p>&#13;
<p class="TX">Let’s compile the <i>ESPlayground</i> project and run it with the <span class="SANS_TheSansMonoCd_W5Regular_11">-protect</span> flag to trigger this logic. The tool detects the use of built-in macOS commands to examine the home directory and delete a file within the <i>Documents</i> directory but still allows the actions:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -protect</b>&#13;
&#13;
ES Playground&#13;
Executing 'protect' logic&#13;
protecting directory: /Users/Patrick&#13;
&#13;
event: ES_EVENT_TYPE_AUTH_OPEN&#13;
responsible process: /bin/ls&#13;
target file path: /Users/Patrick&#13;
process is trusted, so will allow event&#13;
&#13;
event: ES_EVENT_TYPE_AUTH_UNLINK&#13;
responsible process: /bin/rm&#13;
target file path: /Users/Patrick/Documents/deleteMe.doc&#13;
process is trusted, so will allow event&#13;
</code></pre>&#13;
<p class="TX">Now consider WindTail, a persistent cyber-espionage implant that seeks to enumerate and exfiltrate files in the user’s <i>Documents</i> directory. If we install it in a virtual machine, we can see the malware (called <i>Final_Presentation.app</i>) attempts to enumerate the files in the user’s documents directory. We detect this access, and because WindTail’s binary (called <i>usrnode</i> in this example) isn’t trusted, we block access to the directory:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -protect</b>&#13;
&#13;
ES Playground&#13;
Executing 'protect' logic&#13;
protecting directory: /Users/User&#13;
&#13;
event: ES_EVENT_TYPE_AUTH_OPEN&#13;
responsible process: /Users/User/Library/Final_Presentation.app/Contents/MacOS/usrnode&#13;
target file path: /Users/User/Documents&#13;
process is *not* trusted, so will deny event&#13;
</code></pre>&#13;
<p class="TX">It’s hard to overstate the importance of Endpoint Security for building tools capable of detecting and protecting against Mac malware. In recent <span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>years, Apple has added more events (such as <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_XP_MALWARE _DETECTED</span> in macOS 13 and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE</span> in macOS 15), and powerful capabilities to the framework, so when building any security tool, using Endpoint Security should be your first consideration.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-60"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">In this chapter, I covered advanced Endpoint Security topics, including muting, inverted muting, and authorization events. The examples showed you how to use these capabilities to build tools capable of detecting malware when it performs unauthorized actions, as well as proactively thwarting the action in the first place.</p>&#13;
<p class="TX">This chapter wraps up <a href="part2.xhtml">Part II</a> of this book, dedicated to topics of real-time monitoring capabilities. <a href="part3.xhtml">Part III</a> will put together the many topics covered in <a href="part1.xhtml">Parts I</a> and <a href="part2.xhtml">II</a> as we explore the internals of Objective-See’s most popular macOS malware detection tools.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-1" href="#chapter9_1">  1</a></span>.  See “Client,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/endpointsecurity/client"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/endpointsecurity<wbr/>/client</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-2" href="#chapter9_2">  2</a></span>.  Pete Markowsky (@PeteMarkowsky), “A small list of things you can do with this. 1. lockdown access to your SAAS bearer tokens to specific apps . . . ,” X, May 2, 2023, <a href="https://x.com/PeteMarkowsky/status/1653453951839109133"><i>https://<wbr/>x<wbr/>.com<wbr/>/PeteMarkowsky<wbr/>/status<wbr/>/1653453951839109133</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-3" href="#chapter9_3">  3</a></span>.  See <a href="https://github.com/google/santa/blob/8a7f1142a87a48a48271c78c94f830d8efe9afa9/Source/santad/EventProviders/SNTEndpointSecurityTamperResistance.mm#L15"><i>https://<wbr/>github<wbr/>.com<wbr/>/google<wbr/>/santa<wbr/>/blob<wbr/>/8a7f1142a87a48a48271c78c94f830d8efe9afa9<wbr/>/Source<wbr/>/santad<wbr/>/EventProviders<wbr/>/SNTEndpointSecurityTamperResistance<wbr/>.mm#L15</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-4" href="#chapter9_4">  4</a></span>.  Shilpesh Trivedi, “MacStealer: Unveiling a Newly Identified MacOS-Based Stealer Malware,” <i>Uptycs</i>, March 24, 2023, <a href="https://www.uptycs.com/blog/macstealer-command-and-control-c2-malware"><i>https://<wbr/>www<wbr/>.uptycs<wbr/>.com<wbr/>/blog<wbr/>/macstealer<wbr/>-command<wbr/>-and<wbr/>-control<wbr/>-c2<wbr/>-malware</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-5" href="#chapter9_5">  5</a></span>.  You can read more about these notarization bypass flaws in Patrick Wardle, “All Your Macs Are Belong to Us,” Objective-See, April 26, 2021, <a href="https://objective-see.org/blog/blog_0x64.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x64<wbr/>.html</i></a>, and in Patrick Wardle, “Where’s the Interpreter!?,” Objective-See, December 22, 2021, <a href="https://objective-see.org/blog/blog_0x6A.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x6A<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-6" href="#chapter9_6">  6</a></span>.  Objective-See Foundation (@objective_see), “Did you know BlockBlock . . . ,” X, March 2, 2022, <a href="https://x.com/objective_see/status/1499172783502204929"><i>https://<wbr/>x<wbr/>.com<wbr/>/objective<wbr/>_see<wbr/>/status<wbr/>/1499172783502204929</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-7" href="#chapter9_7">  7</a></span>.  “ES_EVENT_TYPE_AUTH_EXEC,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/endpointsecurity/es_event_type_t/es_event_type_auth_exec"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/endpointsecurity<wbr/>/es<wbr/>_event<wbr/>_type<wbr/>_t<wbr/>/es<wbr/>_event<wbr/>_type<wbr/>_auth<wbr/>_exec</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-8" href="#chapter9_8">  8</a></span>.  See <a href="https://github.com/objective-see/BlockBlock"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/BlockBlock</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/><span class="en_tx"><a id="chapter9-9" href="#chapter9_9">  9</a></span>.  You can read about such attacks uncovered by yours truly in Patrick Wardle, “Dylib Hijacking on OS X,” VirusBulletin, March 19, 2015, <a href="https://www.virusbulletin.com/blog/2015/03/paper-dylib-hijacking-os-x"><i>https://<wbr/>www<wbr/>.virusbulletin<wbr/>.com<wbr/>/blog<wbr/>/2015<wbr/>/03<wbr/>/paper<wbr/>-dylib<wbr/>-hijacking<wbr/>-os<wbr/>-x</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-10" href="#chapter9_10">10</a></span>.  The code in <a href="chapter9.xhtml#Lis9-9">Listing 9-9</a> is inspired by Jeff Johnson, “Detect App Translocation,” Lapcat Software, July 26, 2016, <a href="https://lapcatsoftware.com/articles/detect-app-translocation.html"><i>https://<wbr/>lapcatsoftware<wbr/>.com<wbr/>/articles<wbr/>/detect<wbr/>-app<wbr/>-translocation<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-11" href="#chapter9_11">11</a></span>.  See <a href="https://github.com/objective-see/BlockBlock/blob/master/Daemon/Daemon/Plugins/Processes.m"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/BlockBlock<wbr/>/blob<wbr/>/master<wbr/>/Daemon<wbr/>/Daemon<wbr/>/Plugins<wbr/>/Processes<wbr/>.m</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-12" href="#chapter9_12">12</a></span>.  Patrick Wardle, “Demystifying (&amp; Bypassing) macOS’s Background Task Management,” presented at DefCon, Las Vegas, August 12, 2023, <a href="https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management"><i>https://<wbr/>speakerdeck<wbr/>.com<wbr/>/patrickwardle<wbr/>/demystifying<wbr/>-and<wbr/>-bypassing<wbr/>-macoss<wbr/>-background<wbr/>-task<wbr/>-management</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-13" href="#chapter9_13">13</a></span>.  Phil Stokes, “Backdoor Activator Malware Running Rife Through Torrents of macOS Apps,” Sentinel One, February 1, 2024, <a href="https://www.sentinelone.com/blog/backdoor-activator-malware-running-rife-through-torrents-of-macos-apps/"><i>https://<wbr/>www<wbr/>.sentinelone<wbr/>.com<wbr/>/blog<wbr/>/backdoor<wbr/>-activator<wbr/>-malware<wbr/>-running<wbr/>-rife<wbr/>-through<wbr/>-torrents<wbr/>-of<wbr/>-macos<wbr/>-apps<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter9-14" href="#chapter9_14">14</a></span>.  Jaron Bradley, “Zero-Day TCC Bypass Discovered in XCSSET Malware,” Jamf, May 24, 2021, <a href="https://www.jamf.com/blog/zero-day-tcc-bypass-discovered-in-xcsset-malware/"><i>https://<wbr/>www<wbr/>.jamf<wbr/>.com<wbr/>/blog<wbr/>/zero<wbr/>-day<wbr/>-tcc<wbr/>-bypass<wbr/>-discovered<wbr/>-in<wbr/>-xcsset<wbr/>-malware<wbr/>/</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>