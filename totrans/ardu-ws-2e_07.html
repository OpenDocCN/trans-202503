<html><head></head><body>
		<section>&#13;
			<header>&#13;
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_153" title="153"/>8</span><br/><span class="ChapterTitle">LED Numeric Displays and Matrices </span></h1>&#13;
			</header>&#13;
			<p class="ChapterIntro">In this chapter, you will</p>&#13;
			<ul>&#13;
				<li>Use MAX7219-based numeric LED displays</li>&#13;
				<li>Build your own digital stopwatch timer</li>&#13;
				<li>Use MAX7219-based LED matrix modules</li>&#13;
				<li>Build a scrolling text LED display</li>&#13;
			</ul>&#13;
			<p>Although LED numeric displays (such as those found in contemporary digital alarm clocks) may not be on the bleeding edge of display technology, they are easy to read and—more importantly—easy to use with our Arduino boards.</p>&#13;
			<p>&#13;
				You learned how to use one- and two-digit LED numeric displays in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. However, using more than two digits at a time can become messy—there’s a lot more wiring, more control ICs, and so on to take care of. Fortunately, there’s a popular IC that can control up to 64 LEDs (eight digits of a numeric display) with only three control wires from our Arduino: the MAX7219 LED driver IC from Maxim Integrated.</p>&#13;
			<p>&#13;
				The MAX7219 is available in both a through-hole package type, which means it has metal legs that can fit into a circuit board or a solderless breadboard (<a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a>), and a surface-mount package type (<a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a>).</p>&#13;
				<span epub:type="pagebreak" id="Page_154" title="154"/>&#13;
				<figure>&#13;
				<img alt="f08001" src="image_fi/500587c08/f08001.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-1">Figure 8-1</a>: The MAX7219 in a through-hole package type</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<figure>&#13;
				<img alt="f08002" src="image_fi/500587c08/f08002.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-2">Figure 8-2</a>: The MAX7219 in a surface-mount package type</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>In this chapter, you’ll learn how to use the MAX7219 to control up to eight numeric LED digits. You’ll also learn how to use the MAX7219 to control interesting LED matrix modules that allow for scrolling text displays.</p>&#13;
			<h2 id="h1-500587c08-0001">LED Numeric Displays</h2>&#13;
			<p class="BodyFirst">LED numeric displays that use the MAX7219 come in many shapes and sizes, usually with four to eight digits fitted to the module. For our examples, we’re using an eight-digit module, which is easily available and great value for the money (see <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>).</p>&#13;
			<figure>&#13;
				<img alt="f08003" src="image_fi/500587c08/f08003.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-3">Figure 8-3</a>: The eight-digit LED module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				These modules have the surface-mount version of the MAX7219, shown in <a href="#figure8-2">Figure 8-2</a>, on the back. The modules usually include some inline header pins to allow for attaching control wires. If you haven’t already done so, solder these to your module, as shown in <a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_155" title="155"/>&#13;
				<figure>&#13;
				<img alt="f08004" src="image_fi/500587c08/f08004.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-4">Figure 8-4</a>: Inline header pins connected to an eight-digit LED module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Before you can use the numeric display, you’ll need to connect five wires to both the display and the Arduino. This is easily done by connecting male-to-female jumper wires to the header pins that you soldered to the board. Make the connections as shown in <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>.</p>&#13;
			<figure>&#13;
				<figcaption class="TableTitle">&#13;
					<p><a id="table8-1">Table 8-1</a>: Connections Between the Display Module and Arduino</p>&#13;
				</figcaption>&#13;
				<table border="1" id="table-500587c08-0001">&#13;
					<thead>&#13;
						<tr>&#13;
							<td><b>Module pin label</b></td>&#13;
							<td><b>Arduino pin</b></td>&#13;
							<td><b>Module pin function</b></td>&#13;
						</tr>&#13;
					</thead>&#13;
					<tbody>&#13;
						<tr>&#13;
							<td>Vcc</td>&#13;
							<td>5V</td>&#13;
							<td>Power (+)</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>GND</td>&#13;
							<td>GND</td>&#13;
							<td>Power (−) or ground</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>DIN</td>&#13;
							<td>D12</td>&#13;
							<td>Data in</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>CS</td>&#13;
							<td>D10</td>&#13;
							<td>Chip select</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>CLK</td>&#13;
							<td>D11</td>&#13;
							<td>Clock signal</td>&#13;
						</tr>&#13;
					</tbody>&#13;
				</table>&#13;
			</figure>&#13;
			<h3 id="h2-500587c08-0001">Installing the Library</h3>&#13;
			<p class="BodyFirst">There are several Arduino libraries for the MAX7219. These libraries vary according to the configuration of the display module used. We will use the LedControl library. You will need to download the library ZIP file from <em>https://github.com/wayoda/LedControl/</em>. Click <b>Clone or Download</b> and then <b>Download ZIP</b>, as shown in <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a>.</p>&#13;
			<figure>&#13;
				<img alt="f08005" src="image_fi/500587c08/f08005.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-5">Figure 8-5</a>: Downloading the LedControl library</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_156" title="156"/>Once you have the ZIP file, install it as described in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Next, to use the display module, we will first examine a demonstration sketch that uses the required functions. Enter and upload the basic sketch shown in <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>.</p>&#13;
			<pre><code>// Listing 8-1<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include "LedControl.h"   // need the library&#13;
LedControl lc = LedControl(12, 11, 10, 1);&#13;
void setup()&#13;
{<span aria-label="annotation2" class="CodeAnnotationHang">2</span>   lc.shutdown(0, false);  // enable display lc.setIntensity(0, 3);  // set brightness lc.clearDisplay(0);     // clear screen&#13;
}&#13;
void loop()&#13;
{ // numbers with decimal point for (int a = 0; a &lt; 8; a++) {<span aria-label="annotation3" class="CodeAnnotationHang">3</span>     lc.setDigit(0, a, a, true); delay(500); lc.clearDisplay(0) ;  // clear screen } // dashes for (int a = 0; a &lt; 8; a++) {<span aria-label="annotation4" class="CodeAnnotationHang">4</span>     lc.setChar(0, a, '-', false); delay(500); lc.clearDisplay(0) ;  // clear screen } // numbers without decimal point for (int a = 0; a &lt; 8; a++) { lc.setDigit(0, a, a, false); delay(500); lc.clearDisplay(0) ;  // clear screen }<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   // display "abcdef" lc.setDigit(0, 5, 10, false); lc.setDigit(0, 4, 11, false); lc.setDigit(0, 3, 12, false); lc.setDigit(0, 2, 13, false); lc.setDigit(0, 1, 14, false); lc.setDigit(0, 0, 15, false); delay(500); lc.clearDisplay(0) ;    // clear screen&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Display module demonstration sketch</p>&#13;
			<p><span epub:type="pagebreak" id="Page_157" title="157"/>Let’s take a look at how the sketch in <a href="#listing8-1">Listing 8-1</a> works. At <span aria-label="annotation1" class="CodeAnnotation">1</span>, we include the necessary code to load the library for the display module. The <code>LedControl()</code> function has four parameters:</p>&#13;
			<pre><code>LedControl lc = LedControl(12, 11, 10, 1);</code></pre>&#13;
			<p class="BodyContinued">The first three say which digital pins are connected (see <a href="#table8-1">Table 8-1</a>), and the fourth parameter is the number of display modules connected to the Arduino—in this case one. (You can daisy-chain more than one module.)</p>&#13;
			<p>&#13;
				At <span aria-label="annotation2" class="CodeAnnotation">2</span>, we have three functions that control aspects of the display. The first one turns the display on or off:</p>&#13;
			<pre><code>lc.shutdown(0, false);  </code></pre>&#13;
			<p class="BodyContinued">The first parameter is the display. We use 0 because only one display is connected. If you have connected multiple displays, the second is display 1, the third is display 2, and so on. The second parameter specifies whether the display is on or off: <code>false</code> for on, <code>true</code> for off.</p>&#13;
			<p>The second function is used to set the brightness of the LEDs in the display:</p>&#13;
			<pre><code>lc.setIntensity(0, 3);  </code></pre>&#13;
			<p class="BodyContinued">The first parameter is the display number. The second is the brightness, which can be between 0 and 15 inclusive.</p>&#13;
			<p>The third function simply turns all the LEDs off:</p>&#13;
			<pre><code>lc.clearDisplay(0);     </code></pre>&#13;
			<p class="BodyContinued">This is great for clearing previously displayed data.</p>&#13;
			<p>&#13;
				At <span aria-label="annotation3" class="CodeAnnotation">3</span>, we display a digit on the screen using <code>setDigit()</code>:</p>&#13;
			<pre><code>lc.setDigit(0, a, b, true);</code></pre>&#13;
			<p class="BodyContinued">The first parameter is the display number. The second is the physical position of the digit on the display; for an eight-digit display, this value ranges from 7 (the leftmost digit) to 0 (the rightmost digit). The third parameter is the actual number to display (0 to 9). If you use 10 to 16, you can display the letters A to F, as we’ve done at <span aria-label="annotation5" class="CodeAnnotation">5</span>. Finally, the fourth parameter controls the decimal point: <code>true</code> for on and <code>false</code> for off.</p>&#13;
			<p>&#13;
				You can also write the characters A to F, H, L, P, dash, period, and underscore using <code>setChar()</code>, as at <span aria-label="annotation4" class="CodeAnnotation">4</span>:</p>&#13;
			<pre><code>lc.setChar(0, a, '-', false);</code></pre>&#13;
			<p class="BodyContinued">The parameters are the same, except you enclose the character with single quotes.</p>&#13;
			<p>Now that we’ve been through all the commands for showing numbers and characters on the display, let’s put them into action.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c08-0002"><span><span epub:type="pagebreak" id="Page_158" title="158"/>Project #26: Digital Stopwatch</span></h2>&#13;
			<p class="BodyFirst">You learned about timing in Project 24 in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, and you’ve just learned how to use a display module, so now you can combine these concepts to create a digital stopwatch. While not accurate to Olympic timing levels, this is a fun and useful project. Your stopwatch will be able to display milliseconds, seconds, minutes, and up to nine hours.</p>&#13;
			<p>&#13;
				You will need to connect the ProtoShield (or equivalent circuit) as described in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> and to the numeric display used earlier in this chapter. Then just upload the following sketch:</p>&#13;
			<pre><code>// Project 26 – Digital Stopwatch &#13;
#include "LedControl.h"   // need the library&#13;
LedControl lc = LedControl(12, 11, 10, 1);&#13;
unsigned long starting, finished, elapsed;&#13;
void setup()&#13;
{ pinMode(2, INPUT);      // the start button pinMode(3, INPUT);      // the stop button lc.shutdown(0, false);  // enable display lc.setIntensity(0, 3);  // set brightness lc.clearDisplay(0);     // clear screen starting = millis();&#13;
}<span aria-label="annotation1" class="CodeAnnotationHang">1</span> void displayResultLED()&#13;
{ float h, m, s, ms; int m1, m2, s1, s2, ms1, ms2, ms3; unsigned long over; finished = millis(); elapsed = finished - starting;<span aria-label="annotation2" class="CodeAnnotationHang">2</span>   h = int(elapsed / 3600000); over = elapsed % 3600000; m = int(over / 60000); over = over % 60000; s = int(over / 1000); ms = over % 1000; <span aria-label="annotation3" class="CodeAnnotationHang">3</span>   // display hours lc.setDigit(0, 7, h, true);  // display minutes m1 = m / 10; m2 = int(m) % 10; lc.setDigit(0, 6, m1, false); lc.setDigit(0, 5, m2, true);  // display seconds s1 = s / 10; s2 = int(s) % 10; lc.setDigit(0, 4, s1, false);<span epub:type="pagebreak" id="Page_159" title="159"/>  lc.setDigit(0, 3, s2, true);  // display milliseconds (1/100 s) ms1 = int(ms / 100); ms2 = (int((ms / 10)) % 10); ms3 = int(ms) % 10; lc.setDigit(0, 2, ms1, false); lc.setDigit(0, 1, ms2, false); lc.setDigit(0, 0, ms2, false);&#13;
}&#13;
void loop()&#13;
{<span aria-label="annotation4" class="CodeAnnotationHang">4</span>   if (digitalRead(2) == HIGH)  // reset count { starting = millis(); delay(200);                // for debounce }<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   if (digitalRead(3) == HIGH)  // display count for five seconds then resume { finished = millis(); delay(5000);               // for debounce } displayResultLED();&#13;
}</code></pre>&#13;
			<p>&#13;
				A moment after the sketch has been uploaded, the display will start counting up, as shown in <a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>.</p>&#13;
			<figure>&#13;
				<img alt="f08006" src="image_fi/500587c08/f08006.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-6">Figure 8-6</a>: The stopwatch at work</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Just as we did in Project 24, in this sketch we use <code>millis()</code> to track the elapsed time. We have put the time calculation and display in the function <code>void displayResultLED()</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>&#13;
			<p>&#13;
				At <span aria-label="annotation2" class="CodeAnnotation">2</span>, you can see how the elapsed time in milliseconds is broken down into hours, minutes, seconds, and milliseconds. Then, each digit of the display from left to right is filled with the corresponding time values, starting with hours <span aria-label="annotation3" class="CodeAnnotation">3</span>. The stopwatch controls are simple: when the user presses the button connected to digital input 2, the counter is reset to zero by making the starting time equal to the current value returned by <code>millis()</code> <span aria-label="annotation4" class="CodeAnnotation">4</span>. When the button connected to digital input 3 is pressed <span aria-label="annotation5" class="CodeAnnotation">5</span>, the display is frozen; this functionality is ideal for taking a lap reading. Note, however, that the counting continues and the display resumes after about five seconds.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_160" title="160"/>This project can easily be changed to display data in a simpler format—such as hours, minutes, and seconds—or to be used for longer periods, such as up to 24 hours. But for now, let’s move on to a more complex project involving LED matrix display boards.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c08-0003"><span>Project #27: Using LED Matrix Modules</span></h2>&#13;
			<p class="BodyFirst">The MAX7219 can control up to 64 LEDs. These displayed numbers in the last project. Here, we’ll use modules that arrange the LEDs in an 8 × 8 matrix form that is ideal for more interesting applications, such as displaying fixed or scrolling text.</p>&#13;
			<p>&#13;
				LED matrix modules are generally sold either as individual units or in sets of four; both are shown in <a href="#figure8-7" id="figureanchor8-7">Figure 8-7</a>.</p>&#13;
			<p>&#13;
				You may also see these advertised as kits; however, the cost savings is negligible, so save time with the preassembled versions. The LED displays fit onto the socketed pins on the module, as shown in <a href="#figure8-8" id="figureanchor8-8">Figure 8-8</a>, allowing you to change colors easily.</p>&#13;
			<figure>&#13;
				<img alt="f08007" src="image_fi/500587c08/f08007.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-7">Figure 8-7</a>: LED matrix modules</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<figure>&#13;
				<img alt="f08008" src="image_fi/500587c08/f08008.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-8">Figure 8-8</a>: A removable LED matrix</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Take care when inserting the LED matrix into the module, as some LED matrices have pins that get bent easily. Experience has shown that you still need to solder inline header pins to the matrix modules. However, these pins are generally included with the module and fit neatly, as shown in <a href="#figure8-9" id="figureanchor8-9">Figure 8-9</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_161" title="161"/>&#13;
				<figure>&#13;
				<img alt="f08009" src="image_fi/500587c08/f08009.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-9">Figure 8-9</a>: Inline header pins connected to a matrix module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Once again, before you can use the matrix modules, you’ll need to connect five wires to both the module and the Arduino, just as you did with the numeric display. Make the connections as shown in <a href="#table8-2" id="tableanchor8-2">Table 8-2</a>.</p>&#13;
			<figure>&#13;
				<figcaption class="TableTitle">&#13;
					<p><a id="table8-2">Table 8-2</a>: Connections Between the Matrix Module and Arduino</p>&#13;
				</figcaption>&#13;
				<table border="1" id="table-500587c08-0002">&#13;
					<thead>&#13;
						<tr>&#13;
							<td><b>Module pin label</b></td>&#13;
							<td><b>Arduino pin</b></td>&#13;
							<td><b>Module pin function</b></td>&#13;
						</tr>&#13;
					</thead>&#13;
					<tbody>&#13;
						<tr>&#13;
							<td>Vcc</td>&#13;
							<td>5V</td>&#13;
							<td>Power (+)</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>GND</td>&#13;
							<td>GND</td>&#13;
							<td>Power (−) or ground</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>DIN</td>&#13;
							<td>D11</td>&#13;
							<td>Data in</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>CS</td>&#13;
							<td>D9</td>&#13;
							<td>Chip select</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>CLK</td>&#13;
							<td>D13</td>&#13;
							<td>Clock signal</td>&#13;
						</tr>&#13;
					</tbody>&#13;
				</table>&#13;
			</figure>&#13;
			<h3 id="h2-500587c08-0002">Installing the Library</h3>&#13;
			<p class="BodyFirst">You’ll use a different library for these modules than for the MAX7219. To get the library, visit <a class="LinkURL" href="https://github.com/bartoszbielawski/LEDMatrixDriver/">https://github.com/bartoszbielawski/LEDMatrixDriver/</a> and click <b>Clone or Download</b>, then <b>Download ZIP</b>, as shown in <a href="#figure8-10" id="figureanchor8-10">Figure 8-10</a>.</p>&#13;
			<figure>&#13;
				<img alt="f08010" src="image_fi/500587c08/f08010.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-10">Figure 8-10</a>: Downloading the LEDMatrixDriver library</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_162" title="162"/>After you have downloaded the ZIP file, install it as described in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Enter and upload the sketch that follows. (At this point, I’d like to remind you that all the code in this book can be downloaded from <a class="LinkURL" href="https://nostarch.com/arduino-workshop-2nd-edition/">https://nostarch.com/arduino-workshop-2nd-edition/</a>.)</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">Note</span></h2>&#13;
					<p>&#13;
							If you’re using a single matrix module, change the value of <code>const int LEDMATRIX_SEGMENTS = 4</code> on line 4 from <var>4</var> to <var>1</var>.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<pre><code>// Project 27 - Using LED Matrix Modules<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include &lt;LEDMatrixDriver.hpp&gt;&#13;
const uint8_t LEDMATRIX_CS_PIN = 9;&#13;
// Number of matrix modules you are connecting&#13;
const int LEDMATRIX_SEGMENTS = 4;&#13;
const int LEDMATRIX_WIDTH = LEDMATRIX_SEGMENTS * 8;&#13;
LEDMatrixDriver lmd(LEDMATRIX_SEGMENTS, LEDMATRIX_CS_PIN);&#13;
// Text to display<span aria-label="annotation2" class="CodeAnnotationHang">2</span> char text[] = "** LED MATRIX DEMO! ** (1234567890) ++ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ++ &lt;$%/=?'.@,&gt; --";&#13;
// scroll speed (smaller = faster)<span aria-label="annotation3" class="CodeAnnotationHang">3</span> const int ANIM_DELAY = 30;&#13;
void setup() {<span aria-label="annotation4" class="CodeAnnotationHang">4</span> // init the display lmd.setEnabled(true); lmd.setIntensity(2);   // 0 = low, 10 = high&#13;
}&#13;
int x = 0, y = 0; // start top left&#13;
// font definition<span aria-label="annotation5" class="CodeAnnotationHang">5</span> byte font[95][8] = { {0, 0, 0, 0, 0, 0, 0, 0},      // SPACE {0x10, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18}, // EXCL {0x28, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}, // QUOT {0x00, 0x0a, 0x7f, 0x14, 0x28, 0xfe, 0x50, 0x00}, // # {0x10, 0x38, 0x54, 0x70, 0x1c, 0x54, 0x38, 0x10}, // $ {0x00, 0x60, 0x66, 0x08, 0x10, 0x66, 0x06, 0x00}, // % {0, 0, 0, 0, 0, 0, 0, 0},                         // &amp; {0x00, 0x10, 0x18, 0x18, 0x08, 0x00, 0x00, 0x00}, // ' {0x02, 0x04, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04}, // ( {0x40, 0x20, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20}, // ) {0x00, 0x10, 0x54, 0x38, 0x10, 0x38, 0x54, 0x10}, // * {0x00, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08}, // + {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x08}, // COMMA {0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00}, // - {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06}, // DOT {0x00, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40}, // / {0x00, 0x38, 0x44, 0x4c, 0x54, 0x64, 0x44, 0x38}, // 0 {0x04, 0x0c, 0x14, 0x24, 0x04, 0x04, 0x04, 0x04}, // 1 {0x00, 0x30, 0x48, 0x04, 0x04, 0x38, 0x40, 0x7c}, // 2 {0x00, 0x38, 0x04, 0x04, 0x18, 0x04, 0x44, 0x38}, // 3 {0x00, 0x04, 0x0c, 0x14, 0x24, 0x7e, 0x04, 0x04}, // 4 {0x00, 0x7c, 0x40, 0x40, 0x78, 0x04, 0x04, 0x38}, // 5 {0x00, 0x38, 0x40, 0x40, 0x78, 0x44, 0x44, 0x38}, // 6 {0x00, 0x7c, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10}, // 7<span epub:type="pagebreak" id="Page_163" title="163"/>  {0x00, 0x3c, 0x44, 0x44, 0x38, 0x44, 0x44, 0x78}, // 8 {0x00, 0x38, 0x44, 0x44, 0x3c, 0x04, 0x04, 0x78}, // 9 {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}, // : {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x08}, // ; {0x00, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10}, // &lt; {0x00, 0x00, 0x7e, 0x00, 0x00, 0xfc, 0x00, 0x00}, // = {0x00, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08}, // &gt; {0x00, 0x38, 0x44, 0x04, 0x08, 0x10, 0x00, 0x10}, // ? {0x00, 0x30, 0x48, 0xba, 0xba, 0x84, 0x78, 0x00}, // @ {0x00, 0x1c, 0x22, 0x42, 0x42, 0x7e, 0x42, 0x42}, // A {0x00, 0x78, 0x44, 0x44, 0x78, 0x44, 0x44, 0x7c}, // B {0x00, 0x3c, 0x44, 0x40, 0x40, 0x40, 0x44, 0x7c}, // C {0x00, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78}, // D {0x00, 0x78, 0x40, 0x40, 0x70, 0x40, 0x40, 0x7c}, // E {0x00, 0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40}, // F {0x00, 0x3c, 0x40, 0x40, 0x5c, 0x44, 0x44, 0x78}, // G {0x00, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42}, // H {0x00, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7e}, // I {0x00, 0x7e, 0x02, 0x02, 0x02, 0x02, 0x04, 0x38}, // J {0x00, 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44}, // K {0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c}, // L {0x00, 0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82}, // M {0x00, 0x42, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42}, // N {0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x44, 0x38}, // O {0x00, 0x78, 0x44, 0x44, 0x48, 0x70, 0x40, 0x40}, // P {0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x44, 0x3a}, // Q {0x00, 0x78, 0x44, 0x44, 0x78, 0x50, 0x48, 0x44}, // R {0x00, 0x38, 0x40, 0x40, 0x38, 0x04, 0x04, 0x78}, // S {0x00, 0x7e, 0x90, 0x10, 0x10, 0x10, 0x10, 0x10}, // T {0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3e}, // U {0x00, 0x42, 0x42, 0x42, 0x42, 0x44, 0x28, 0x10}, // V {0x80, 0x82, 0x82, 0x92, 0x92, 0x92, 0x94, 0x78}, // W {0x00, 0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42}, // X {0x00, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10}, // Y {0x00, 0x7c, 0x04, 0x08, 0x7c, 0x20, 0x40, 0xfe}, // Z&#13;
};<span aria-label="annotation6" class="CodeAnnotationHang">6</span> void drawString(char* text, int len, int x, int y)&#13;
{ for ( int idx = 0; idx &lt; len; idx ++ ) { int c = text[idx] - 32; // stop if char is outside visible area if ( x + idx * 8  &gt; LEDMATRIX_WIDTH ) return; // only draw if char is visible if ( 8 + x + idx * 8 &gt; 0 ) drawSprite( font[c], x + idx * 8, y, 8, 8 ); }&#13;
}<span aria-label="annotation7" class="CodeAnnotationHang">7</span> void scrollText()<span epub:type="pagebreak" id="Page_164" title="164"/>{ int len = strlen(text); drawString(text, len, x, 0); lmd.display(); delay(ANIM_DELAY); if ( --x &lt; len * -8 ) { x = LEDMATRIX_WIDTH; }&#13;
}&#13;
void loop()&#13;
{ scrollText();&#13;
}</code></pre>&#13;
			<p>A moment or two after the sketch has uploaded, you should see text scrolling from right to left across your LED display modules.</p>&#13;
			<p>&#13;
				Now let’s dig in to see how this sketch works. There’s a lot of code, but don’t let that put you off. Starting at <span aria-label="annotation1" class="CodeAnnotation">1</span>, we call the required functions to use the library and set up the displays. At <span aria-label="annotation2" class="CodeAnnotation">2</span>, an array of characters contains the text to show on the display modules. You can change this later if you’d like. You can also adjust the speed of scrolling by altering the value at <span aria-label="annotation3" class="CodeAnnotation">3</span>: the smaller the number, the faster the scroll speed.</p>&#13;
			<p>&#13;
				At <span aria-label="annotation4" class="CodeAnnotation">4</span>, we have two functions. This function turns the display on or off:</p>&#13;
			<pre><code>lmd.setEnabled(true);</code></pre>&#13;
			<p class="BodyContinued">And this one sets the brightness of the LEDs in the display module:</p>&#13;
			<pre><code>lmd.setIntensity(<em>x</em>);</code></pre>&#13;
			<p class="BodyContinued">The <code>setIntensity()</code> function takes values between 0 (dim) and 9 (bright).</p>&#13;
			<p>&#13;
				The font used by the display is defined in the huge array at <span aria-label="annotation5" class="CodeAnnotation">5</span>. We’ll return to that in the next section. Finally, the functions <code>drawstring()</code> <span aria-label="annotation6" class="CodeAnnotation">6</span> and <code>scrollText()</code> <span aria-label="annotation7" class="CodeAnnotation">7</span> are required for display operation.</p>&#13;
			<h3 id="h2-500587c08-0003">Editing the Display Font</h3>&#13;
			<p class="BodyFirst">You can easily specify which characters are usable in the display by changing the data in the <code>byte font</code> array <span aria-label="annotation5" class="CodeAnnotation">5</span>. First, recall that each matrix module is made up of eight rows of eight LEDs. This means you have 64 LEDs available for any character you create.</p>&#13;
			<p>Each row of LEDs is defined by a hexadecimal number, and eight of these hexadecimal numbers represent a character. For example, the letter N is defined by:</p>&#13;
			<pre><code>{0x00, 0x42, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42}, // N</code></pre>&#13;
			<p><span epub:type="pagebreak" id="Page_165" title="165"/>To visualize the character, we convert the hexadecimal numbers to binary. For example, our letter N converted from hexadecimal to binary is:</p>&#13;
			<pre><code>0 0 0 0 0 0 0 0 = 0x00&#13;
0 1 0 0 0 0 1 0 = 0x42&#13;
0 1 0 0 0 0 1 0 = 0x42&#13;
0 1 1 0 0 0 1 0 = 0x62&#13;
0 1 0 1 0 0 1 0 = 0x52&#13;
0 1 0 0 1 0 1 0 = 0x4a&#13;
0 1 0 0 0 1 1 0 = 0x46&#13;
0 1 0 0 0 0 1 0 = 0x42</code></pre>&#13;
			<p>You can see how the 1s represent the character against a field of 0s, with the 1s being LEDs turned on and the 0s being LEDs turned off. So, to create your own characters, just reverse the process. For example, a nice smiley face can be represented as:</p>&#13;
			<pre><code>0 1 1 1 1 1 1 0 = 0x7e&#13;
1 0 0 0 0 0 0 1 = 0x81&#13;
1 0 1 0 0 1 0 1 = 0xa5&#13;
1 0 0 0 0 0 0 1 = 0x81&#13;
1 0 1 0 0 1 0 1 = 0xa5&#13;
1 0 0 1 1 0 0 1 = 0x99&#13;
1 0 0 0 0 0 0 1 = 0x81&#13;
0 1 1 1 1 1 1 0 = 0x7e</code></pre>&#13;
			<p>This would be represented in the array as:</p>&#13;
			<pre><code>{0x7e,0x81,0xa5,0x81,0xa5,0x99,0x81,0x7e} // smiley</code></pre>&#13;
			<p>&#13;
				You can either replace an existing line in the <code>font</code> array with your new data or add your data to the end of the array as another element. If you add another line, you need to increase the first parameter in the <code>byte</code> declaration so that the first parameter equals the number of defined characters (in this case, 96):</p>&#13;
			<pre><code>byte font[96][8]</code></pre>&#13;
			<p>&#13;
				You’re probably wondering by now how to refer to your custom character in the sketch. The display library uses the character order in the ASCII chart, which can be found at <a class="LinkURL" href="https://www.arduino.cc/en/Reference/ASCIIchart/">https://www.arduino.cc/en/Reference/ASCIIchart/</a>.</p>&#13;
			<p>If you add another character after the last one in the sketch (which is Z by default), the next character in the table is [. Thus, to scroll three smiley faces across the display, you would set the line with text to display to:</p>&#13;
			<pre><code>char text[] = "[ [ [ ";</code></pre>&#13;
			<p>&#13;
				An example of this output can be seen in <a href="#figure8-11" id="figureanchor8-11">Figure 8-11</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_166" title="166"/>&#13;
				<figure>&#13;
				<img alt="f08011" src="image_fi/500587c08/f08011.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure8-11">Figure 8-11</a>: Using custom characters to display smiley faces</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c08-0004">Looking Ahead</h2>&#13;
			<p class="BodyFirst">Now that you know how to use them, working with LED numeric and matrix displays will be a cinch. However, there are more types of displays, so turn to the next chapter to learn about another one: liquid crystal displays.</p>&#13;
		</section>&#13;
	</body></html>