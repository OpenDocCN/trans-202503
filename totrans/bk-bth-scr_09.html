<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch8">
<span class="cn"><span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">8</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">EXECUTING COMPILED PROGRAMS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">This chapter is ostensibly about a bat file executing or calling a program written and compiled in another language. In truth, the syntax to do that is pretty straightforward. The most interesting facet of this chapter is that sometimes the program being executed doesn’t have a defined path in the bat file. How does the bat file find the executable?</p>
<p class="tx">The main focus of this chapter will be on two highly important mechanisms for finding such a program, the <i class="calibre6">current directory</i> and the <span class="sans_thesansmonocd_w5regular_">path</span> variable. This topic goes well past the executing of programs. You’ll use it when calling other bat files, and it impacts many other instances when a resource isn’t defined with a path. For instance, in <span class="xref"><a href="chapter7.xhtml" class="calibre3">Chapter 7</a></span>, I discussed many commands for copying, moving, deleting, and renaming files. All of those commands will work perfectly well in your bat files when the file or files in each command aren’t defined with a path in the bat file, but only if you <span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>understand these concepts. And of course, you’ll also learn different ways to invoke programs and pass them arguments.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-56"/><span class="sans_futura_std_bold_b_">Calling an Executable</span></h3>
<p class="tni">Often a bat file is little more than a vehicle or a wrapper for calling a compiled program, also known as an <i class="calibre6">executable</i>. The bat file will simply set some variables needed by the program, call the executable, and perform some error handling on the backend. More sophisticated bat files might call dozens of different programs, maybe even employing conditional logic on some calls. Simple or complex, a feature of Batch is the ability to call executables written in other languages.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">call</span> command accepts the executable as its first, and possibly only, argument. The following command calls or executes the program <i class="calibre6">MyProg .exe</i> located in the <i class="calibre6">C:\Executables\</i> directory:</p>
<pre class="pre"><code class="calibre11">call C:\Executables\MyProg.exe</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">call</span> command calls a program; that should surprise no one, but it’s about to get weird. This is the only command in Batch, and possibly all other languages, that works perfectly well when the command name itself is omitted. The following command, while not technically a <span class="sans_thesansmonocd_w5regular_">call</span> command, performs the same function as the <span class="sans_thesansmonocd_w5regular_">call</span> command in the prior example:</p>
<pre class="pre"><code class="calibre11">C:\Executables\MyProg.exe</code></pre>
<p class="tx">Think about this for a moment. The command <span class="sans_thesansmonocd_w5regular_">set x=1</span> sets a variable, but the statement <span class="sans_thesansmonocd_w5regular_">x=1</span> will do nothing more than confuse the interpreter. If the text <span class="sans_thesansmonocd_w5regular_">robocopy</span> is left off the beginning of a <span class="sans_thesansmonocd_w5regular_">robocopy</span> command, no one in their right mind would expect the remaining text to copy a file. (If this isn’t weird enough, the presence or lack of the <span class="sans_thesansmonocd_w5regular_">call</span> command gets a little weirder when calling other bat files in <span class="xref"><a href="chapter10.xhtml" class="calibre3">Chapter 10</a></span>.)</p>
<p class="tx">It almost seems like magic, but consider it from the interpreter’s perspective. When it interprets a new line, it usually expects the first item to be a command. When it finds <span class="sans_thesansmonocd_w5regular_">set</span>, it then anticipates a variable, an equal sign, and a value; when it finds <span class="sans_thesansmonocd_w5regular_">robocopy</span>, it next looks for a different set of arguments. When it finds something completely unexpected, the interpreter doesn’t balk; it gives you, the coder, the benefit of the doubt, assumes that whatever it is can be executed, and executes it—just as the <span class="sans_thesansmonocd_w5regular_">call</span> command would.</p>
<p class="tx">Some Batch coders use the <span class="sans_thesansmonocd_w5regular_">call</span> command for executables; some do not. I’m in the latter camp, preferring the clean look of the executable alone or just a resolved variable on a single line of code, but I’ve no qualms with those who explicitly spell out the command. More important, consistency is key; stick with your convention of choice.</p>
<p class="tx">I also prefer to keep the program name in a variable with a fully qualified path, setting it only when it isn’t already defined. This ensures that the <span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>desired program is stored in the variable by default, while also allowing others to set it to an alternate program for the sake of flexibility:</p>
<pre class="pre"><code class="calibre11">if not defined pgmMyProg  set pgmMyProg=C:\Executables\MyProg.exe</code></pre>
<p class="tx">Then when it comes time to execute the program, this simple command, if I can call it a command, will <i class="calibre6">call</i> the desired program:</p>
<pre class="pre"><code class="calibre11">%pgmMyProg%</code></pre>
<p class="tni">This variable contains the path of the executable, but let’s return to the concept of a line of code consisting of nothing more than a hardcoded path and filename.</p>
<p class="tx">You can shorten it by removing the path, leaving just the name of the program and maybe the extension:</p>
<pre class="pre"><code class="calibre11">myProg.exe</code></pre>
<p class="tni">This looks even simpler, but when you stop to ponder where on the machine or even on a network the interpreter is to find the program, the complexity grows. Before delving into those details, I’ll need a digression about two commands/variables.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-57"/><span class="sans_futura_std_bold_b_">The cd Command and Variable</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">cd</span> command is also a variable, a special variable that’s one of a few Batch pseudo-environment variables. In <span class="xref"><a href="chapter21.xhtml" class="calibre3">Chapter 21</a></span>, I’ll have much more to say about these variables. For now, just consider them to be variables originally set by the interpreter that have some unique features.</p>
<p class="tx">The variable stands for <i class="calibre6">current directory</i>. The command is a bit more ambiguous, as it can also mean <i class="calibre6">change directory</i> because it’s used to ... well, change the current directory.</p>
<p class="tx">When you double-click or open a bat file, the current directory is the directory or folder where the bat file resides. If the same bat file is called from a different process, the current directory is inherited from that process. Simply calling a bat file or executable in a different directory doesn’t change the current directory, but the <span class="sans_thesansmonocd_w5regular_">cd</span> command does.</p>
<p class="tx">The first and last lines shown next use the <span class="sans_thesansmonocd_w5regular_">cd</span> variable to display the current directory. The meat of this sandwich is the <span class="sans_thesansmonocd_w5regular_">cd</span> command that adeptly changes the current directory to its argument, assuming the directory exists:</p>
<pre class="pre"><code class="calibre11">&gt; con echo Current Directory is: %cd%
cd C:\NewDir\
&gt; con echo Current Directory is: %cd%
</code></pre>
<p class="tx"><span aria-label=" Page 86. " epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>If a bat file with these three lines resides in <i class="calibre6">C:\Batch\</i>, executing it displays both the original current directory and the newly assigned current directory to the console:</p>
<pre class="pre"><code class="calibre11">Current Directory is: C:\Batch
Current Directory is: C:\NewDir
</code></pre>
<p class="tx">You can also set the current directory relative to the existing current directory. A single dot represents its existing value, so this assigns the <span class="sans_thesansmonocd_w5regular_">cd</span> variable to a subdirectory:</p>
<pre class="pre"><code class="calibre11">cd .\Child\</code></pre>
<p class="tx">Two dots represent the existing current directory’s parent, so the following moves the current directory up one level:</p>
<pre class="pre"><code class="calibre11">cd ..</code></pre>
<p class="tni">(The <span class="sans_thesansmonocd_w5regular_">..\..</span> argument finds the grandparent directory.)</p>
<p class="tx">You can even reassign the <span class="sans_thesansmonocd_w5regular_">cd</span> variable to a sibling directory by first going up one level with the two dots:</p>
<pre class="pre"><code class="calibre11">cd ..\Sibling\</code></pre>
<p class="tx">I’m hesitant to even mention this, but <span class="sans_thesansmonocd_w5regular_">chdir</span> is a Batch synonym for the <span class="sans_thesansmonocd_w5regular_">cd</span> command. That is, the command in the prior example is functionally equivalent to <span class="sans_thesansmonocd_w5regular_">chdir ..\Sibling\</span>. However, the <span class="sans_thesansmonocd_w5regular_">cd</span> variable has no synonym, so you can use either <span class="sans_thesansmonocd_w5regular_">chdir</span> or <span class="sans_thesansmonocd_w5regular_">cd</span> to change the current directory, but you need to use <span class="sans_thesansmonocd_w5regular_">cd</span> when resolving the current directory. I find it easiest to always use <span class="sans_thesansmonocd_w5regular_">cd</span> for both purposes.</p>
<p class="tx">Before I get into the purpose of the current directory, I need to introduce another command that’s also a variable.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h" id="sec3"><span id="h1-58"/><span class="sans_futura_std_bold_b_">The path Command and Variable</span></h3>
<p class="tni">Much like <span class="sans_thesansmonocd_w5regular_">cd</span>, <span class="sans_thesansmonocd_w5regular_">path</span> also is both a command and a pseudo-environment variable. The variable is predefined on Windows machines with a semicolon-delimited list of directories needed by the computer, such as paths for Java and Windows executables. (To see the <span class="sans_thesansmonocd_w5regular_">path</span> variable currently set on any Windows machine, open a command prompt, and using what we learned in <span class="xref"><a href="chapter2.xhtml" class="calibre3">Chapter 2</a></span> enter the command <span class="sans_thesansmonocd_w7bold_b_">set path</span>.)</p>
<p class="tx">Just as the <span class="sans_thesansmonocd_w5regular_">cd</span> command sets the current directory, the <span class="sans_thesansmonocd_w5regular_">path</span> command sets the <span class="sans_thesansmonocd_w5regular_">path</span> variable. In the following line of code, the existing value is being prepended and appended with two other directories; notice the semicolons inserted at the end of each additional directory as a delimiter:</p>
<pre class="pre"><code class="calibre11">path C:\PrependDir\;%path%C:\AppendDir\;</code></pre>
<p class="tx"><span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>You can completely reassign the <span class="sans_thesansmonocd_w5regular_">path</span> variable—or even wipe it out entirely if the argument is solely a semicolon. The various directories in this variable exist for a purpose, probably allowing for some necessary processes to run. Be extremely cautious about changing the variable persistently on your machine, such as with the <span class="sans_thesansmonocd_w5regular_">setx</span> command, but the <span class="sans_thesansmonocd_w5regular_">path</span> command shown previously changes only the <span class="sans_thesansmonocd_w5regular_">path</span> for the execution of the bat file. At worst you might break your bat file, but you won’t break anything else on your computer. In the next section, I’ll explain why you might want to change the <span class="sans_thesansmonocd_w5regular_">path</span> variable.</p>
<p class="warning"><span class="sans_dogma_ot_bold_b_1">WARNING</span></p>
<p class="warning-txt"><i class="calibre6">The set command offers an alternative means of resetting both the cd and path variables, but out of consistency, I resist this method because some other pseudo- environment variables can’t or shouldn’t be reset with this command—and it requires a few more keystrokes.</i></p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="h" id="sec4"><span id="h1-59"/><span class="sans_futura_std_bold_b_">Finding an Executable</span></h3>
<p class="tni">Let’s get back to executing a program simply by invoking nothing but its name and extension like so:</p>
<pre class="pre"><code class="calibre11">myProg.exe</code></pre>
<p class="tx">Where does the interpreter find the executable? The first place it looks is in the current directory. If found there, that’s the file executed. Otherwise, the interpreter will look for it sequentially in each directory defined in the <span class="sans_thesansmonocd_w5regular_">path</span> variable and execute the first one it finds. If it can’t find an executable with this name in any of those directories, the interpreter does nothing more than set <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to the value of <span class="sans_thesansmonocd_w5regular_">9009</span>. (Oddly, the bad return code is <span class="sans_thesansmonocd_w5regular_">1</span> if the <span class="sans_thesansmonocd_w5regular_">call</span> command precedes the name of the executable.)</p>
<p class="tx">Let’s execute the same line of code, assuming that <i class="calibre6">myProg.exe</i> lives in <i class="calibre6">C:\Executables\</i>. If this directory is the current directory, the program will be found and executed. Otherwise, if this directory is in the <span class="sans_thesansmonocd_w5regular_">path</span> variable, the program will likely be found and executed. This assumes that the program isn’t superseded with a different program of the same name and extension residing in the current directory or higher in the <span class="sans_thesansmonocd_w5regular_">path</span> variable hierarchy.</p>
<p class="tx">If none of this is true, the program won’t be found, but there are different methods to make sure that the interpreter finds the executable. First, we can use the <span class="sans_thesansmonocd_w5regular_">cd</span> command to change the current directory prior to executing the program:</p>
<pre class="pre"><code class="calibre11">cd C:\Executables\</code></pre>
<p class="tx">Alternatively, we can alter the <span class="sans_thesansmonocd_w5regular_">path</span> variable to contain the directory in one of two ways. Here I’m prepending the path:</p>
<pre class="pre"><code class="calibre11">path C:\Executables\;%path%</code></pre>
<p class="tni"><span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>And here I’m appending the path:</p>
<pre class="pre"><code class="calibre11">path %path%C:\Executables\;</code></pre>
<p class="tx">If the directory is appended and if another file named <i class="calibre6">myProg.exe</i> exists in a directory defined earlier in the <span class="sans_thesansmonocd_w5regular_">path</span> variable, that other program will be the one executed. Prepending the directory ensures that my executable is picked up before any other, but this isn’t without its own dangers. It might be introducing something into the <span class="sans_thesansmonocd_w5regular_">path</span> variable that’ll override a resource used by some other process.</p>
<p class="tx">This is in no way a bad technique; in fact, it’s quite useful when managed wisely. One great use of finding an executable using the current directory or <span class="sans_thesansmonocd_w5regular_">path</span> variable is to make the code portable. You can keep a bat file in a single folder or a more complex folder structure with other bat files, as well as any number of executables, configuration files, and other resources. You then can copy that folder to other machines and networks with different root directory structures. Since the current directory essentially follows the high-level bat file around, it’ll work in those various locations if the current directory is used to find its other components.</p>
<p class="tx">You can house a default executable in the same folder as your bat file. If run on its own, it’ll use this executable. If called from another bat file with a different current directory, it may find a different program, allowing others to use your bat file to invoke their own executable. In short, you can create a hierarchy of same-named programs with different ones executed in different instances.</p>
<p class="tx">To take this one step further, I hinted earlier that the extension isn’t even required to invoke a program. That is, if <i class="calibre6">myProg.exe</i> resides in the current directory, it’ll <i class="calibre6">probably</i> be invoked with this line of code:</p>
<pre class="pre"><code class="calibre11">myProg</code></pre>
<p class="tx">The interpreter finds an executable given no extension with the aid of another pseudo-environment variable, <span class="sans_thesansmonocd_w5regular_">pathext</span>, which contains a hierarchy of semicolon-delimited extensions in much the same way that the <span class="sans_thesansmonocd_w5regular_">path</span> variable contains a hierarchy of directories. The interpreter still looks for the executable in the current directory, followed by the directories in the <span class="sans_thesansmonocd_w5regular_">path</span> variable, but in each folder, it now looks for the first executable it can find with the <i class="calibre6">myProg</i> filename and an extension listed in the given hierarchy.</p>
<p class="tx">If the <span class="sans_thesansmonocd_w5regular_">pathext</span> variable hasn’t been altered by someone or something else, it will likely contain about a dozen file extensions, starting with.<i class="calibre6">com</i>, <i class="calibre6">.exe</i>, <i class="calibre6">.bat</i>, and <i class="calibre6">.cmd</i>—in that order. Thus, the only entity that would prevent the previous command from executing <i class="calibre6">myProg.exe</i> from the current directory would be <i class="calibre6">myProg.com</i> in the current directory. (If you ever have to reset this variable, use the <span class="sans_thesansmonocd_w5regular_">set</span> command. The <span class="sans_thesansmonocd_w5regular_">pathext</span> variable is only a variable, not a command.)</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="h" id="sec5"><span id="h1-60"/><span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Pushing and Popping the Current Directory</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">cd</span> command does quite a nice job of changing the current directory, but the prior current directory is lost into the ether, never to be known again. Often that’s perfectly fine, but in other instances, you may want to change the current directory temporarily before reverting it to its prior state. Perhaps a utility bat file is written to be callable from many other bat files. In short order, I’ll discuss exactly how to call one bat file from another, but for now, we only need to understand the perspective of the called bat file.</p>
<p class="tx">The called bat file may create or use resources in a certain folder, so changing the current directory at the bat file’s onset makes sense. However, when the called bat file completes and turns control back to the calling bat file, the prior current directory should be restored. It’s simple courtesy because the calling bat file may be working in a different directory and changing its current directory might very well cause it problems. A more self-serving motivation is that the called bat file wants to keep its directory to itself. If the called bat file doesn’t restore the current directory, the calling bat file might drop unwanted files in what’s now the current directory. The called bat file can hide its directory from the unwashed masses while also presenting itself as being courteous.</p>
<p class="tx">To solve this issue, you could store the prior current directory in a variable just before the <span class="sans_thesansmonocd_w5regular_">cd</span> command is executed, and then you could execute another <span class="sans_thesansmonocd_w5regular_">cd</span> command at the end of the bat file to set it back. But Batch provides two commands that together will do this far more elegantly, namely, the <span class="sans_thesansmonocd_w5regular_">pushd</span> and <span class="sans_thesansmonocd_w5regular_">popd</span> commands.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">pushd</span> command changes the current directory just like the <span class="sans_thesansmonocd_w5regular_">cd</span> command, but it also <i class="calibre6">pushes</i> the prior current directory onto a stack to be used later. It’s sometimes referred to as the <i class="calibre6">push directory</i> command, although for the sake of brevity it’s usually pronounced as it’s written, that is, the “push-d” command. Near the beginning of the bat file this command will succinctly perform both tasks:</p>
<pre class="pre"><code class="calibre11">pushd C:\NewDir\</code></pre>
<p class="tx">At or near the close of the bat file, the following short command will remove <i class="calibre6">C:\NewDir\</i> as the current directory and retrieve or <i class="calibre6">pop</i> the prior current directory off the stack, using it to restore the current directory:</p>
<pre class="pre"><code class="calibre11">popd</code></pre>
<p class="tni">This is sometimes called the <i class="calibre6">pop directory</i> command, but more commonly, the “pop-d” command.</p>
<p class="tx">Notice that there’s no argument; <span class="sans_thesansmonocd_w5regular_">popd</span> is the rare command that accepts no arguments at all, ever. As multiple <span class="sans_thesansmonocd_w5regular_">pushd</span> commands execute, each one pushes another prior current directory onto the stack, and each subsequent <span class="sans_thesansmonocd_w5regular_">popd</span> command will restore the one most recently added.</p>
<p class="tx"><span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>Also of note, if the argument passed to the <span class="sans_thesansmonocd_w5regular_">pushd</span> command is a network path, the highest unused drive letter is assigned to that path, and the <span class="sans_thesansmonocd_w5regular_">popd</span> command will unassign it. Lastly, the <span class="sans_thesansmonocd_w5regular_">pushd</span> command with no argument displays the full list of directories on the stack starting with the most recently added.</p>
<p class="warning"><span class="sans_dogma_ot_bold_b_1">WARNING</span></p>
<p class="warning-txt"><i class="calibre6">It’s very important that pushd and popd commands be balanced. If a pushd assigns a network path, a corresponding popd should always execute, even if an error is handled. If not, any mapped drive letters will remain mapped, even after the bat file finishes up. If that happens often enough, the computer will run out of usable drive letters.</i></p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-61"/><span class="sans_futura_std_bold_b_">Finding Other Resources with the Current Directory</span></h3>
<p class="tni">The current directory is used for far more than finding programs to execute. For any resource, such as a file, if the path isn’t defined, the current directory is assumed to be its path. For instance, in <span class="xref"><a href="chapter7.xhtml" class="calibre3">Chapter 7</a></span>, this command deleted an explicit file and everything ending in a particular extension:</p>
<pre class="pre"><code class="calibre11">del /Q C:\Source\Junk.txt C:\Source\*.OLD</code></pre>
<p class="tx">The following command performs the same task with far fewer keystrokes <i class="calibre6">if</i>—the <i class="calibre6">if</i> being a critical qualifier—the current directory is <i class="calibre6">C:\Source\</i>, which is the path twice removed from the prior command:</p>
<pre class="pre"><code class="calibre11">del /Q Junk.txt *.OLD</code></pre>
<p class="tx">The same is true for the source argument of an <span class="sans_thesansmonocd_w5regular_">xcopy</span> command and any other command that accepts a path and filename as an argument. I usually prefer to use explicit paths to avoid any ambiguity, but this technique grants the same type of flexibility described throughout this chapter for a great number of commands. Flip through <span class="xref"><a href="chapter7.xhtml" class="calibre3">Chapter 7</a></span> again, imagining all of the commands for copying, moving, and renaming files without explicit paths. They’d all be good commands if the interpreter finds the particular file or files in whatever happened to be the current directory at that time.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="h" id="sec7"><span id="h1-62"/><span class="sans_futura_std_bold_b_">Passing Arguments to an Executable</span></h3>
<p class="tni">At the beginning of this chapter, I demonstrated how to call a compiled program. Before moving on, I have one last observation to share about this syntax.</p>
<p class="tx">Executables often accept one to many parameters at execution time. Those parameters are passed to the program as arguments by simply listing them after the program. For readability, I’ve put the three arguments into variables:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/>set inFile=C:\Batch\Input.dat
set outFile=C:\Batch\Output.dat
set logFile=C:\Batch\Log.dat

%pgmMyProg% %inFile% %outFile% %logFile%
</code></pre>
<p class="tx">The input file is the first argument passed to the program; in many languages, that would be considered <span class="sans_thesansmonocd_w5regular_">args[0]</span> inside the program. Likewise, the output file is the second argument, <span class="sans_thesansmonocd_w5regular_">args[1]</span>, and the log is the third, <span class="sans_thesansmonocd_w5regular_">args[2]</span>. You can also use hardcoded values, and the arguments can be anything you like; they don’t have to be files.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="h" id="sec8"><span id="h1-63"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">Executing a compiled program appears pretty basic at first. After all, you don’t even need a command. But you can’t truly understand how it works without knowing the details about the current directory and the <span class="sans_thesansmonocd_w5regular_">path</span> variable that I’ve detailed here. You’ve learned how the interpreter uses them to find executables, files, and any other resources, along with multiple means of managing the content of these important variables.</p>
<p class="tx">Executing another bat file is similar to but not the same as executing a compiled program, and you’ll learn about those differences in <a href="chapter10.xhtml" class="calibre3">Chapter 10</a>. But before I delve into that, you’ll learn about labels and their many important uses in the very next chapter, primarily their impact on when commands are executed and how often.</p>
</section>
</section>
</div></body></html>