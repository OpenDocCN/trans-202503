- en: '## **1'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **1'
- en: COMPUTING CONCEPTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机概念**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'Computers are everywhere now: in our homes, our schools, our offices—you might
    find a computer in your pocket, on your wrist, or even in your refrigerator. It’s
    easier than ever to find and use computers, but few people today really understand
    how computers work. This isn’t surprising, since learning the complexities of
    computing can be overwhelming. The goal of this book is to lay out the foundational
    principles of computing in a way that anyone with curiosity, and a bit of a technical
    bent, can follow. Before we dig into the nuts and bolts of how computers work,
    let’s take some time to get familiar with some major concepts of computing.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机如今无处不在：在我们的家里、学校、办公室——你可能在口袋里、手腕上，甚至在冰箱里找到计算机。如今，找到并使用计算机比以往任何时候都容易，但很少有人真正理解计算机是如何工作的。这并不令人惊讶，因为学习计算机的复杂性可能会让人不知所措。本书的目标是以一种任何有好奇心并具备一些技术倾向的人都能理解的方式，阐明计算机的基本原理。在我们深入了解计算机如何工作之前，让我们花点时间了解一些计算机的主要概念。
- en: In this chapter we’ll begin by discussing the definition of a computer. From
    there, we’ll cover the differences between analog and digital data and then explore
    number systems and the terminology used to describe digital data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从讨论计算机的定义开始。从这个定义出发，我们将介绍模拟数据和数字数据之间的差异，然后探讨数字数据的数制和术语。
- en: '**Defining a Computer**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义计算机**'
- en: 'Let’s start with a basic question: what is a computer? When people hear the
    word *computer*, most think of a laptop or desktop, sometimes referred to as a
    personal computer or PC. That is one class of device that this book covers, but
    let’s think a bit more broadly. Consider smartphones. Smartphones are certainly
    computers; they perform the same types of operations as PCs. In fact, for many
    people today, a smartphone is their primary computing device. Most computer users
    today also rely on the internet, which is powered by servers—another type of computer.
    Every time you visit a website or use an app that connects to the internet, you’re
    interacting with one or more servers connected to a global network. Video game
    consoles, fitness trackers, smart watches, smart televisions … all of these are
    computers!'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本问题开始：什么是计算机？当人们听到*计算机*这个词时，大多数人会想到笔记本电脑或台式电脑，有时被称为个人计算机或PC。这是本书讨论的其中一种设备类型，但让我们再扩大一些思考。考虑一下智能手机。智能手机当然是计算机；它们执行与PC相同类型的操作。事实上，对于今天的许多人来说，智能手机是他们的主要计算设备。如今，大多数计算机用户还依赖互联网，而互联网是由服务器提供支持的——另一种计算机类型。每次你访问网站或使用连接到互联网的应用程序时，你都在与一个或多个连接到全球网络的服务器互动。视频游戏机、健身追踪器、智能手表、智能电视……这些都是计算机！
- en: A *computer* is any electronic device that can be programmed to carry out a
    set of logical instructions. With that definition in mind, it becomes clear that
    many modern devices are in fact computers!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*计算机*是任何能够被编程以执行一组逻辑指令的电子设备。根据这个定义，很明显许多现代设备实际上都是计算机！
- en: '**EXERCISE 1-1: FIND THE COMPUTERS IN YOUR HOME**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-1：找出你家里的计算机**'
- en: Take a moment and see how many computers you can identify in your home. When
    I did this exercise with my family, we quickly found about 30 devices!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 花一点时间，看看你能在家里找出多少台计算机。当我和家人一起做这个练习时，我们很快找到了大约30个设备！
- en: '**Analog and Digital**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟与数字**'
- en: You’ve probably heard a computer described as a digital device. This is in contrast
    to an analog device, such as a mechanical clock. But what do these two terms really
    mean? Understanding the differences between analog and digital is foundational
    to understanding computing, so let’s take a closer look at these two concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过计算机被描述为数字设备。这与模拟设备，如机械钟表，是相对的。那么这两个术语到底是什么意思呢？理解模拟和数字之间的差异是理解计算机的基础，因此让我们仔细看看这两个概念。
- en: '***The Analog Approach***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟方法***'
- en: 'Look around you. Pick an object. Ask yourself: What color is it? What size
    is it? How much does it weigh? By answering these questions, you’re describing
    the attributes, or *data*, of that object. Now, pick a different object and answer
    the same questions. If you repeat this process for even more objects, you’ll find
    that for each question, the potential answers are numerous. You might pick up
    a red object, a yellow object, or a blue object. Or the object could be a mix
    of the primary colors. This type of variation does not only apply to color. For
    a given property, the variations found across the objects in our world are potentially
    infinite.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 环顾四周，挑选一个物体。问问自己：它是什么颜色的？它有多大？它重多少？通过回答这些问题，你正在描述该物体的属性，或者说是*数据*。现在，挑选另一个物体并回答相同的问题。如果你对更多的物体重复这个过程，你会发现，对于每个问题，潜在的答案是非常多的。你可能挑选一个红色物体，一个黄色物体，或者一个蓝色物体，或者物体可能是几种基本颜色的混合。这种变化不仅仅适用于颜色。对于给定的属性，我们世界上物体间的变化是潜在无限的。
- en: It’s one thing to describe an object verbally, but let’s say you want to measure
    one of its attributes more precisely. If you wanted to measure an object’s weight,
    for example, you could put it on a scale. The scale, responding to the weight
    placed upon it, would move a needle along a numbered line, stopping when it reaches
    a position that corresponds to the weight. Read the number from the scale and
    you have the object’s weight.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用语言描述一个物体是一回事，但假设你想要更精确地测量它的某个属性。例如，如果你想测量物体的重量，你可以将它放在一个秤上。秤根据放置在其上的重量，移动指针沿着标有数字的线，直到指针停在与重量相对应的位置。从秤上读出数字，你就得到了物体的重量。
- en: 'This kind of measurement is common, but let’s think a little more about how
    we’re measuring this data. The position of the needle on the scale isn’t actually
    the weight; it’s a representation of the weight. The numbered line that the needle
    points to provides a means for us to easily convert between the needle’s position,
    representing a weight, and the numeric value of that weight. In other words, though
    the weight is an attribute of the object, here we can understand that attribute
    through something else: the position of the needle along the line. The needle’s
    position changes proportionally in response to the weight placed on the scale.
    Thus, the scale is working as an *analogy* where we understand the weight of the
    object through the needle’s position on the line. This is why we call this method
    of measuring the *analog* approach.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测量方法很常见，但让我们稍微思考一下我们是如何测量这些数据的。刻度盘上指针的位置实际上不是重量，它是重量的一个表示。指针指向的数字线为我们提供了一种便捷的方式，将指针的位置（表示重量）与该重量的数值相互转换。换句话说，尽管重量是物体的属性，但在这里我们可以通过其他方式来理解这个属性：即指针在数字线上的位置。指针的位置会随着物体放置在秤上的重量成比例地变化。因此，秤起到了*类比*的作用，我们通过指针在刻度线上的位置来理解物体的重量。这就是为什么我们称这种测量方法为*模拟*方法。
- en: Another example of an analog measuring tool is a mercury thermometer. Mercury’s
    volume increases with temperature. Thermometer manufacturers utilize this property
    by placing mercury in a glass tube with markings that correspond to the expected
    volume of the mercury at various temperatures. Thus, the position of mercury in
    the tube serves as a representation of temperature. Notice that for both of these
    examples (a scale and a thermometer), when we make a measurement, we can use markings
    on the instrument to convert a position to a specific numeric value. But the value
    we read from the instrument is just an approximation. The true position of the
    needle or mercury can be anywhere within the range of the instrument, and we round
    up or down to the nearest marked value. So although it may seem that these tools
    can produce only a finite set of measurements, that’s a limitation imposed by
    the conversion to a number, not by the analogy itself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类比测量工具的例子是水银温度计。水银的体积随着温度的变化而增加。温度计制造商利用这一特性，将水银放入一个玻璃管中，管上有与不同温度下水银体积相对应的刻度标记。因此，水银在管中的位置就作为温度的一个表示。注意，在这两个例子中（秤和温度计），当我们进行测量时，我们可以利用仪器上的刻度将位置转换为一个具体的数值。但从仪器上读取的数值只是一个近似值。指针或水银的真实位置可能处于仪器范围内的任何位置，我们将其四舍五入到最接近的标记值。因此，尽管这些工具似乎只能产生有限的测量结果，但这是由转换为数字所施加的限制，而不是由类比本身的限制。
- en: Throughout most of human history, humans have measured things using an analog
    approach. But people don’t only use analog approaches for measurement. They’ve
    also devised clever ways to store data in an analog fashion. A phonograph record
    uses a modulated groove as an analog representation of audio that was recorded.
    The groove’s shape changes along its path in a way that corresponds to changes
    in the shape of the audio waveform over time. The groove isn’t the audio itself,
    but it’s an analogy of the original sound’s waveform. Film-based cameras do something
    similar by briefly exposing film to light from a camera lens, leading to a chemical
    change in the film. The chemical properties of the film are not the image itself,
    but a representation of the captured image, an analogy of the image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在人类历史的大部分时间里，人类一直通过模拟方法来测量事物。但人类不仅仅用模拟方法来测量，他们还设计出了巧妙的方法来以模拟方式存储数据。唱片利用调制的槽纹作为录制音频的模拟表示。槽纹的形状沿着路径变化，呈现出音频波形随时间变化的情况。槽纹本身不是音频，但它是原始声音波形的类比。基于胶片的相机做了类似的事情，通过短暂地将胶片暴露在相机镜头的光线下，导致胶片发生化学变化。胶片的化学性质不是图像本身，而是捕捉到的图像的表示，是图像的类比。
- en: '***Going Digital***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***走向数字化***'
- en: What does all this have to do with computing? It turns out that all those analog
    representations of data are hard for computers to deal with. The types of analog
    systems used are so different and variable that creating a common computing device
    that can understand all of them is nearly impossible. For example, creating a
    machine that can measure the volume of mercury is a very different task than creating
    a machine that can read the grooves on a vinyl disc. Additionally, computers require
    highly reliable and accurate representations of certain types of data, such as
    numeric data sets and software programs. Analog representations of data can be
    difficult to measure precisely, tend to decay over time, and lose fidelity when
    copied. Computers need a way to represent all types of data in a format that can
    be accurately processed, stored, and copied.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切与计算有什么关系？事实证明，那些数据的模拟表示方式对于计算机来说难以处理。所使用的模拟系统类型差异巨大且变化多端，几乎不可能创建一个通用的计算设备来理解所有这些系统。例如，制作一个能够测量水银体积的机器和制作一个能够读取黑胶唱片槽纹的机器是完全不同的任务。此外，计算机需要高度可靠和准确的数据表示，像数字数据集和软件程序等类型的数据。数据的模拟表示可能难以精确测量，随着时间的推移会衰减，且在复制时会失去保真度。计算机需要一种方法，以一种可以准确处理、存储和复制的格式来表示所有类型的数据。
- en: 'If we don’t want to represent data as something with potentially infinitely
    varying analog values, what can we do? We can use a digital approach instead.
    A *digital* system represents data as a sequence of symbols, where each symbol
    is one of a limited set of values. Now, that description may sound a bit formal
    and a bit confusing, so rather than go deep on the theory of digital systems,
    I’ll explain what this means in practice. In almost all of today’s computers,
    data is represented with combinations of two symbols: 0 and 1\. That’s it. Although
    a digital system could use more than two symbols, adding more symbols would increase
    the complexity and cost of the system. A set of only two symbols allows for simplified
    hardware and improved reliability. All data in most modern computing devices is
    represented as a sequence of 0s and 1s. From this point forward in this book,
    when I talk about digital computers, you can assume that I am talking about systems
    that only deal with 0s and 1s and not some other set of symbols. Nice and simple!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想将数据表示为具有潜在无限变化的模拟值，我们该怎么办？我们可以改用数字化方法。*数字*系统将数据表示为一系列符号，其中每个符号是有限集合中的一个值。现在，这个描述可能听起来有点正式，也有些让人困惑，所以与其深入探讨数字系统的理论，我将解释它在实际中的含义。在今天几乎所有的计算机中，数据是通过两个符号的组合来表示的：0和1。仅此而已。虽然数字系统可以使用超过两个符号，但添加更多符号会增加系统的复杂性和成本。仅使用两个符号的集合可以简化硬件设计，并提高可靠性。在大多数现代计算设备中，所有数据都表示为0和1的序列。从此书开始，当我谈论数字计算机时，您可以假设我指的是只处理0和1的系统，而不是其他符号集合。简单明了！
- en: 'It’s a point worth repeating: everything on your computer is stored as 0s and
    1s. The last photo you took on your smartphone? Your device stored the photo as
    a sequence of 0s and 1s. The song you streamed from the internet? 0s and 1s. The
    document you wrote on your computer? 0s and 1s. The app you installed? It was
    a bunch of 0s and 1s. The website you visited? 0s and 1s.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的一点是：你计算机上的一切都以0和1存储。你在智能手机上拍的最后一张照片？你的设备将这张照片存储为一串0和1。你从互联网流媒体播放的歌曲？0和1。你在计算机上写的文档？0和1。你安装的应用程序？一堆0和1。你访问的网站？0和1。
- en: It may sound limiting to say that we can only use 0 and 1 to represent the infinite
    values found in nature. How can a musical recording or a detailed photograph be
    distilled down to 0s and 1s? Many find it counterintuitive that such a limited
    “vocabulary” can be used to express complex ideas. The key here is that digital
    systems use a *sequence* of 0s and 1s. A digital photograph, for example, usually
    consists of millions of 0s and 1s.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说我们只能使用0和1来表示自然界中的无限值，可能听起来有些限制。如何将一段音乐录音或一张详细的照片浓缩成0和1呢？许多人觉得这样有限的“词汇”能够表达复杂的思想是直觉上难以理解的。关键在于，数字系统使用的是一串0和1。举个例子，一张数字照片通常由数百万个0和1组成。
- en: 'So what exactly are these 0s and 1s? You may see other terms used to describe
    these 0s and 1s: false and true, off and on, low and high, and so forth. This
    is because the computer doesn’t literally store the number *0* or *1*. It stores
    a sequence of entries where each entry in the sequence can have only two possible
    states. Each entry is like a light switch that is either on or off. In practice,
    these sequences of 1s and 0s are stored in various ways. On a CD or DVD, the 0s
    and 1s are stored on the disc as bumps (0) or flat spaces (1). On a flash drive,
    the 1s and 0s are stored as electrical charges. A hard disk drive stores the 0s
    and 1s using magnetization. As you’ll see in [Chapter 4](ch04.xhtml), digital
    circuits represent 0s and 1s using voltage levels.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些0和1究竟是什么呢？你可能会看到其他术语用来描述这些0和1：假和真，关和开，低和高等等。这是因为计算机并不直接存储数字*0*或*1*。它存储的是一串条目，其中每个条目只有两种可能的状态。每个条目就像一个开关，要么是开，要么是关。实际上，这些1和0的序列以各种方式存储。在CD或DVD上，0和1通过凸起（0）或平坦的空间（1）存储在光盘上。在闪存驱动器中，1和0以电荷的形式存储。在硬盘驱动器中，0和1通过磁化存储。正如你将在[第4章](ch04.xhtml)中看到的，数字电路通过电压水平来表示0和1。
- en: Before we move on, one final note on the term *analog*—it’s often used to simply
    mean “not digital.” For example, engineers may speak of an “analog signal,” meaning
    a signal that varies continuously and doesn’t align to digital values. In other
    words, it’s a non-digital signal but doesn’t necessarily represent an analogy
    of something else. So, when you see the term *analog*, consider that it might
    not always mean what you think.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，最后一个关于术语*模拟*的说明——它通常用来表示“非数字化”。例如，工程师可能会说“模拟信号”，意思是信号是连续变化的，并不与数字值对齐。换句话说，它是一个非数字信号，但不一定表示其他事物的类比。因此，当你看到*模拟*这个术语时，考虑到它可能并不总是意味着你想的那样。
- en: '**Number Systems**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值系统**'
- en: 'So far, we’ve established that computers are digital machines that deal with
    0s and 1s. For many people, this concept seems strange; they’re used to having
    0 through 9 at their disposal when representing numbers. If we constrain ourselves
    to only two symbols, rather than ten, how should we represent large numbers? To
    answer that question, let’s back up and review an elementary school math topic:
    number systems.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定计算机是处理0和1的数字机器。对于许多人来说，这个概念似乎很奇怪；他们习惯了在表示数字时使用0到9。如果我们只限于使用两个符号，而不是十个，我们应该如何表示大数字呢？为了回答这个问题，让我们回顾一下小学数学中的一个基本话题：数值系统。
- en: '***Decimal Numbers***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***十进制数***'
- en: We typically write numbers using something called *decimal place-value notation*.
    Let’s break that down. *Place-value notation* (or *positional notation*) means
    that each position in a written number represents a different order of magnitude;
    *decimal*, or *base 10*, means that the orders of magnitude are factors of 10,
    and each place can have one of ten different symbols, 0 through 9\. Look at the
    example of place-value notation in [Figure 1-1](ch01.xhtml#ch1fig1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用一种叫做*十进制位置值表示法*的方式来写数字。让我们来解析一下。*位置值表示法*（或*位置表示法*）意味着写下的每个数字位置代表不同的数量级；*十进制*，或者说*基数10*，意味着数量级是10的倍数，每个位置可以有十个不同的符号，0到9。请参见[图1-1](ch01.xhtml#ch1fig1)中的位置值表示法示例。
- en: '![image](../images/fig1-1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-1.jpg)'
- en: '*Figure 1-1: Two hundred seventy-five represented in decimal place-value notation*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：二百七十五在十进制位置值表示法中的表示*'
- en: 'In [Figure 1-1](ch01.xhtml#ch1fig1), the number two hundred seventy-five is
    written in decimal notation as 275\. The 5 is in the ones place, meaning its value
    is 5 × 1 = 5\. The 7 is in the tens place, meaning its value is 7 × 10 = 70\.
    The 2 is in the hundreds place, meaning its value is 2 × 100 = 200\. The total
    value is the sum of all the places: 5 + 70 + 200 = 275.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-1](ch01.xhtml#ch1fig1)中，数字二百七十五在十进制表示法中写作 275。5 位于个位，因此它的值是 5 × 1 = 5。7
    位于十位，因此它的值是 7 × 10 = 70。2 位于百位，因此它的值是 2 × 100 = 200。总值是所有位置值的和：5 + 70 + 200 =
    275。
- en: Easy, right? You’ve probably understood this since first grade. But let’s examine
    this a bit closer. Why is the rightmost place the ones place? And why is the next
    place the tens place, and so on? It’s because we are working in decimal, or base
    10, and therefore each place is a power of ten—in other words, 10 multiplied by
    itself a certain number of times. As seen in [Figure 1-2](ch01.xhtml#ch1fig2),
    the rightmost place is 10 raised to 0, which is 1, because any number raised to
    0 is 1\. The next place is 10 raised to 1, which is 10, and the next place is
    10 raised to 2 (10 × 10), which is 100.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？你可能从一年级起就已经理解了这个概念。但让我们更仔细地分析一下。为什么最右边的位置是个位？为什么下一个位置是十位，依此类推？这是因为我们使用的是十进制，或者说是基数
    10，因此每个位置代表的是 10 的幂，换句话说，10 是自乘若干次的结果。如[图 1-2](ch01.xhtml#ch1fig2)所示，最右边的位置是 10
    的 0 次方，等于 1，因为任何数的 0 次方都等于 1。下一个位置是 10 的 1 次方，等于 10，接下来的位置是 10 的 2 次方（10 × 10），等于
    100。
- en: '![image](../images/fig1-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-2.jpg)'
- en: '*Figure 1-2: In decimal place-value notation, each place is a power of ten.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：在十进制位置值表示法中，每个位置是 10 的幂。*'
- en: If we needed to represent a number larger than 999 in decimal, we’d add another
    place to the left, the thousands place, and its weight would be equal to 10 raised
    to 3 (10 × 10 × 10), which is 1,000\. This pattern continues so that we can represent
    any large whole number by adding more places as needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要表示一个比 999 更大的数字，我们会在左侧加一个位置，即千位，其权重等于 10 的 3 次方（10 × 10 × 10），也就是 1,000。这个模式继续延续，因此我们可以通过添加更多的位置来表示任何大数字。
- en: We’ve established why the various places have certain weights, but let’s keep
    digging. Why does each place use the symbols 0 through 9? When working in decimal,
    we can only have ten symbols, because by definition each place can only represent
    ten different values. 0 through 9 are the symbols that are currently used, but
    really any set of ten unique symbols could be used, with each symbol corresponding
    to a certain numeric value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了为什么不同的位置有不同的权重，但让我们继续深入。为什么每个位置使用符号 0 到 9？在十进制中，我们只能使用十个符号，因为根据定义，每个位置只能表示十个不同的值。当前使用的是
    0 到 9 这些符号，但实际上任何一组十个独特的符号都可以使用，每个符号对应某个数字值。
- en: Most humans prefer decimal, base 10, as a number system. Some say this is because
    we have ten fingers and ten toes, but whatever the reason, in the modern world
    most people read, write, and think of numbers in decimal. Of course, that’s just
    a convention we’ve collectively chosen to represent numbers. As we covered earlier,
    that convention doesn’t apply to computers, which instead use only two symbols.
    Let’s see how we can apply the principles of the place-value system while constraining
    ourselves to only two symbols.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人偏好使用十进制（基数 10）作为数字系统。有些人说这是因为我们有十个手指和十个脚趾，但无论原因如何，在现代世界，大多数人都是用十进制来读、写和思考数字。当然，这只是我们共同选择的代表数字的约定。如前所述，这一约定并不适用于计算机，计算机只使用两个符号。让我们看看如何在只使用两个符号的情况下应用位置值系统的原理。
- en: '***Binary Numbers***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制数字***'
- en: The number system consisting of only two symbols is *base 2*, or *binary*. Binary
    is still a place-value system, so the fundamental mechanics are the same as decimal,
    but there are a couple of changes. First, each place represents a power of 2,
    rather than a power of 10\. Second, each place can only have one of two symbols,
    rather than ten. Those two symbols are 0 and 1\. [Figure 1-3](ch01.xhtml#ch1fig3)
    has an example of how we’d represent a number using binary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个符号组成的数字系统是*二进制*。二进制仍然是一个位置值系统，因此其基本原理与十进制相同，但有一些变化。首先，每个位置代表的是 2 的幂，而不是 10
    的幂。其次，每个位置只能有两个符号中的一个，而不是十个符号。这两个符号是 0 和 1。[图 1-3](ch01.xhtml#ch1fig3)展示了我们如何使用二进制表示一个数字。
- en: '![image](../images/fig1-3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-3.jpg)'
- en: '*Figure 1-3: Five decimal represented in binary place-value notation*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：五的十进制在二进制位值表示法中的表现*'
- en: 'In [Figure 1-3](ch01.xhtml#ch1fig3), we have a binary number: 101\. That may
    look like one hundred and one to you, but when dealing in binary, this is actually
    a representation of five! If you wish to verbally say it, “one zero one binary”
    would be a good way to communicate what is written.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-3](ch01.xhtml#ch1fig3)中，我们有一个二进制数：101。看起来像一百零一，但在二进制中，这实际上表示的是五！如果你想口头表达，“一零一二进制”是个很好的表达方式。
- en: Just like in decimal, each place has a weight equal to the base raised to various
    powers. Since we are in base 2, the rightmost place is 2 raised to 0, which is
    1\. The next place is 2 raised to 1, which is 2, and the next place is 2 raised
    to 2 (2 × 2), which is 4\. Also, just like in decimal, to get the total value,
    we multiply the symbol in each place by the place-value weight and sum the results.
    So, starting from the right, we have (1 × 1) + (0 × 2) + (1 × 4) = 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在十进制中一样，每一位都有一个与基数的幂次相关的权重。由于我们使用的是二进制，因此最右边的位是2的0次方，即1。接下来的位是2的1次方，即2，再接下来的位是2的2次方（2
    × 2），即4。同样地，就像在十进制中那样，要获得总值，我们将每一位的符号与该位的权重相乘，并将结果相加。所以，从右开始，我们有(1 × 1) + (0 ×
    2) + (1 × 4) = 5。
- en: Now you can try converting from binary to decimal yourself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试自己从二进制转换成十进制了。
- en: '**EXERCISE 1-2: BINARY TO DECIMAL**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-2：二进制转十进制**'
- en: Convert these numbers, represented in binary, to their decimal equivalents.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些以二进制表示的数字转换成它们的十进制等价物。
- en: 10 (binary) = ______ (decimal)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 10（二进制） = ______ （十进制）
- en: 111 (binary) = ______ (decimal)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 111（二进制） = ______ （十进制）
- en: 1010 (binary) = ______ (decimal)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 1010（二进制） = ______ （十进制）
- en: You can check your answers in [Appendix A](appa.xhtml). Did you get them right?
    The last one might have been a bit tricky, since it introduced another place to
    the left, the eights place. Now, try going the other way around, from decimal
    to binary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录 A](appa.xhtml)中检查你的答案。你做对了吗？最后一个可能有点棘手，因为它引入了另一个位置，即八位位置。现在，尝试反向操作，从十进制转换成二进制。
- en: '**EXERCISE 1-3: DECIMAL TO BINARY**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-3：十进制转二进制**'
- en: Convert these numbers, represented in decimal, to their binary equivalents.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些以十进制表示的数字转换成它们的二进制等价物。
- en: 3 (decimal) = ______ (binary)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 3（十进制） = ______ （二进制）
- en: 8 (decimal) = ______ (binary)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 8（十进制） = ______ （二进制）
- en: 14 (decimal) = ______ (binary)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 14（十进制） = ______ （二进制）
- en: I hope you got those correct too! Right away, you can see that dealing with
    both decimal and binary at the same time can be confusing, since a number like
    10 represents ten in decimal or two in binary. From this point forward in the
    book, if there’s a chance of confusion, binary numbers will be written with a
    0b prefix. I’ve chosen the 0b prefix because several programming languages use
    this approach. The leading 0 (zero) character indicates a numeric value and the
    b is short for binary. As an example, 0b10 represents two in binary, whereas 10,
    with no prefix, means ten in decimal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你也做对了！立刻你就会发现，同时处理十进制和二进制可能会让人感到混淆，因为像10这样的数字，在十进制中表示十，而在二进制中表示二。从现在开始，在本书中，如果有可能造成混淆，二进制数字将会带有0b前缀。我之所以选择0b前缀，是因为许多编程语言都使用这种方式。前导的0（零）字符表示数字值，而b是binary（二进制）的缩写。举个例子，0b10表示二进制的二，而10没有前缀则表示十进制的十。
- en: '**Bits and Bytes**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比特与字节**'
- en: A single place or symbol in a decimal number is called a *digit*. A decimal
    number like 1,247 is a four-digit number. Similarly, a single place or symbol
    in a binary number is called a *bit* (a binary digit). Each bit can either be
    0 or 1\. A binary number like 0b110 is a 3-bit number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数字中的每一位或符号叫做*数字*。例如，数字1,247是一个四位数。类似地，二进制数字中的每一位或符号叫做*比特*（二进制数字）。每个比特的值可以是0或1。像0b110这样的二进制数是一个三比特数。
- en: 'A single bit cannot convey much information; it’s either off or on, 0 or 1\.
    We need a sequence of bits to represent anything more complex. To make these sequences
    of bits easier to manage, computers group bits together in sets of eight, called
    *bytes*. Here are some examples of bits and bytes (leaving off the 0b prefix since
    they are all binary):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单个比特不能传递太多信息；它要么是关（0），要么是开（1）。我们需要一系列比特来表示更复杂的信息。为了更方便地管理这些比特序列，计算机将比特按八个一组进行分组，这些组叫做*字节*。以下是一些比特和字节的例子（省略了0b前缀，因为它们都是二进制）：
- en: '**1**   That’s a bit.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**   这就是一个比特。'
- en: '**0**   That is also a bit.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**0**   这也是一个比特。'
- en: '**11001110**   That’s a byte, or 8 bits.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**11001110**  这是一个字节，或8个比特。'
- en: '**00111000**   That’s also a byte!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**00111000**  这也是一个字节！'
- en: '**10100101**   Yet another byte.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**10100101**  另一个字节。'
- en: '**0011100010100101**   That’s two bytes, or 16 bits.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**0011100010100101**  这是两个字节，或者说16位。'
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Fun fact: A 4-bit number, half a byte, is sometimes called a* nibble *(sometimes
    spelled* nybble *or* nyble).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*有趣的事实：4位二进制数，即半个字节，有时被称为* nibble *（有时拼写为* nybble *或* nyble）。'
- en: So how much data can we store in a byte? Another way to think about this question
    is how many unique combinations of 0s and 1s can we make with our 8 bits? Before
    we answer that question, let me illustrate with only 4 bits, as it’ll be easier
    to visualize.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能在一个字节中存储多少数据呢？换句话说，我们可以用8位二进制表示多少种不同的0和1的组合？在回答这个问题之前，我先用4位二进制来说明，因为这样更容易理解。
- en: In [Table 1-1](ch01.xhtml#ch1tab1), I’ve listed all the possible combination
    of 0s and 1s in a 4-bit number. I’ve also included the corresponding decimal representation
    of that number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表格1-1](ch01.xhtml#ch1tab1)中，我列出了4位二进制数的所有可能组合，并包括了该数的对应十进制表示。
- en: '**Table 1-1:** All Possible Values of a 4-bit Number'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格1-1：** 所有可能的4位二进制数值'
- en: '| **Binary** | **Decimal** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十进制** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | 8 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 |'
- en: '| 1001 | 9 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 |'
- en: '| 1010 | 10 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 10 |'
- en: '| 1011 | 11 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 11 |'
- en: '| 1100 | 12 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | 12 |'
- en: '| 1101 | 13 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 13 |'
- en: '| 1110 | 14 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 14 |'
- en: '| 1111 | 15 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | 15 |'
- en: As you can see in [Table 1-1](ch01.xhtml#ch1tab1), we can represent 16 unique
    combinations of 0s and 1s in a 4-bit number, ranging in decimal value from 0 to
    15\. Seeing the list of combinations of bits helps to illustrate this, but we
    could have figured this out in a couple of ways without enumerating every possible
    combination.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表格1-1](ch01.xhtml#ch1tab1)所示，我们可以在4位二进制数中表示16种不同的0和1的组合，十进制值从0到15不等。看到这些位组合的列表有助于理解这一点，但我们也可以通过其他几种方法来推导出这个结论，而不必列举每一种可能的组合。
- en: We could determine the largest possible number that 4 bits can represent by
    setting all the bits to one, giving us 0b1111\. That is 15 in decimal; if we add
    1 to account for representing 0, then we come to our total of 16\. Another shortcut
    is to raise 2 to the number of bits, 4 in this case, which gives us 2⁴ = 2 × 2
    × 2 × 2 = 16 total combinations of 0s and 1s.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将所有位设置为1来确定4位可以表示的最大数字，这样得到0b1111。它的十进制值为15；如果我们加1来表示0，那么总共有16种组合。另一种简便的方法是将2的位数次方，4在这里，就是2⁴
    = 2 × 2 × 2 × 2 = 16种0和1的组合。
- en: Looking at 4 bits is a good start, but previously we were talking about bytes,
    which contain 8 bits. Using the preceding approach, we could list out all combinations
    of 0s and 1s, but let’s skip that step and go straight to a shortcut. Raise 2
    to the power of 8 and you get 256, so that’s the number of unique combinations
    of bits in a byte.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看4位二进制数是一个很好的开始，但我们之前谈的是字节，字节包含8位。使用前面的方式，我们可以列出所有0和1的组合，但我们跳过这一过程，直接进入一个简便的方法。将2的8次方计算出来，得到256，这就是一个字节中0和1的唯一组合数。
- en: Now we know that a 4-bit number allows for 16 combinations of 0s and 1s, and
    a byte allows for 256 combinations. What does that have to do with computing?
    Let’s say that a computer game has 12 levels; the game could easily store the
    current level number in only 4 bits. On the other hand, if the game has 99 levels,
    4 bits won’t be enough … only 16 levels could be represented! A byte, on the other
    hand, would handle that 99-level requirement just fine. Computer engineers sometimes
    need to consider how many bits or bytes will be needed for storage of data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，4位二进制数可以表示16种0和1的组合，而一个字节则可以表示256种组合。这与计算机有什么关系呢？假设一个电脑游戏有12个关卡；游戏只需要4个位来存储当前的关卡编号就可以了。另一方面，如果游戏有99个关卡，4位就不够用了……只能表示16个关卡！而一个字节则能够满足99个关卡的需求。计算机工程师有时需要考虑存储数据时需要多少位或字节。
- en: '**Prefixes**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**前缀**'
- en: Representing complex data types takes a large number of bits. Something as simple
    as the number 99 won’t require more than a byte; a video in a digital format,
    on the other hand, can require billions of bits. To more easily communicate the
    size of data, we use prefixes like giga- and mega-. The *International System
    of Units (SI)*, also known as the *metric system*, defines a set of standard prefixes.
    These prefixes are used to describe anything that can be quantified, not just
    bits. We’ll see them again in upcoming chapters dealing with electrical circuits.
    [Table 1-2](ch01.xhtml#ch1tab2) lists some of the common SI prefixes and their
    meanings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表示复杂的数据类型需要大量的位。像数字 99 这样的简单东西不会超过一个字节；而数字格式的视频，另一方面，可能需要数十亿个位。为了更容易地传达数据的大小，我们使用类似吉和兆的前缀。*国际单位制（SI）*，也叫*公制系统*，定义了一组标准前缀。这些前缀用于描述任何可以量化的事物，不仅仅是位。我们将在接下来的章节中再次看到它们，特别是涉及电路时。[表
    1-2](ch01.xhtml#ch1tab2) 列出了常见的 SI 前缀及其含义。
- en: '**Table 1-2:** Common SI Prefixes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-2:** 常见的 SI 前缀'
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 10** | **English
    word** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **前缀名称** | **前缀符号** | **值** | **十进制** | **英文单词** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| tera | T | 1,000,000,000,000 | 10^(12) | trillion |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 太 | T | 1,000,000,000,000 | 10^(12) | 万亿 |'
- en: '| giga | G | 1,000,000,000 | 10⁹ | billion |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 吉 | G | 1,000,000,000 | 10⁹ | 十亿 |'
- en: '| mega | M | 1,000,000 | 10⁶ | million |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 兆 | M | 1,000,000 | 10⁶ | 百万 |'
- en: '| kilo | k | 1,000 | 10³ | thousand |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 千 | k | 1,000 | 10³ | 千 |'
- en: '| centi | c | 0.01 | 10^(-2) | hundredth |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 分 | c | 0.01 | 10^(-2) | 百分之一 |'
- en: '| milli | m | 0.001 | 10^(-3) | thousandth |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 毫 | m | 0.001 | 10^(-3) | 千分之一 |'
- en: '| micro | μ | 0.000001 | 10^(-6) | millionth |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 微 | μ | 0.000001 | 10^(-6) | 百万分之一 |'
- en: '| nano | n | 0.000000001 | 10^(-9) | billionth |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 纳 | n | 0.000000001 | 10^(-9) | 十亿分之一 |'
- en: '| pico | p | 0.000000000001 | 10^(-12) | trillionth |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 皮 | p | 0.000000000001 | 10^(-12) | 万亿分之一 |'
- en: With these prefixes, if we want to say “3 billion bytes,” we can use the shorthand
    3GB. Or if we want to represent 4 thousand bits, we can say 4kb. Note the uppercase
    B for byte and lowercase b for bit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些前缀时，如果我们想说“30亿字节”，可以使用简写 3GB。或者，如果我们想表示 4千位，可以说 4kb。注意字节（B）使用大写，位（b）使用小写。
- en: 'You’ll find that this convention is commonly used to represent quantities of
    bits and bytes. Unfortunately, it’s also often technically incorrect. Here’s why:
    when dealing with bytes, most software is actually working in base 2, not base
    10\. If your computer tells you that a file is 1MB in size, it is actually 1,048,576
    bytes! That is approximately one million, but not quite. Seems like an odd number,
    doesn’t it? That’s because we are looking at it in decimal. In binary, that same
    number is expressed as 0b100000000000000000000\. It’s a power of two, specifically
    2^(20). [Table 1-3](ch01.xhtml#ch1tab3) shows how to interpret the SI prefixes
    when dealing with bytes.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，这种约定通常用来表示位和字节的数量。不幸的是，它也常常在技术上是错误的。原因如下：在处理字节时，大多数软件实际上是按二进制而不是十进制工作。如果你的计算机告诉你某个文件的大小是
    1MB，实际上它是 1,048,576 字节！这大约是百万，但并不完全是百万。看起来这个数字很奇怪，不是吗？那是因为我们在用十进制看它。在二进制中，这个数字表示为
    0b100000000000000000000。它是 2 的幂，具体来说是 2^(20)。[表 1-3](ch01.xhtml#ch1tab3) 显示了处理字节时如何解释
    SI 前缀。
- en: '**Table 1-3:** SI Prefix Meaning When Applied to Bytes'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-3:** 当应用于字节时，SI 前缀的含义'
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 2** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **前缀名称** | **前缀符号** | **值** | **二进制** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| tera | T | 1,099,511,627,776 | 2^(40) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 太 | T | 1,099,511,627,776 | 2^(40) |'
- en: '| giga | G | 1,073,741,824 | 2^(30) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 吉 | G | 1,073,741,824 | 2^(30) |'
- en: '| mega | M | 1,048,576 | 2^(20) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 兆 | M | 1,048,576 | 2^(20) |'
- en: '| kilo | k | 1,024 | 2^(10) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 千 | k | 1,024 | 2^(10) |'
- en: Another point of confusion with bits and bytes relates to network transfer rates.
    Internet service providers usually advertise in bits per second, base 10\. So,
    if you get 50 mega*bits* per second from your internet connection, that means
    you can only transfer about 6 mega*bytes* per second. That is, 50,000,000 bits
    per second divided by 8 bits per byte gives us 6,250,000 bytes per second. Divide
    6,250,000 by 2^(20) and we get about 6 megabytes per second.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于位和字节的另一个混淆点是与网络传输速率相关。互联网服务提供商通常以每秒位数（十进制）做广告。因此，如果你的互联网连接速度是 50 兆*位*每秒，这意味着你只能传输大约
    6 兆*字节*每秒。也就是说，50,000,000 位每秒除以每字节 8 位，得到每秒 6,250,000 字节。将 6,250,000 除以 2^(20)，我们得到大约
    6 兆字节每秒。
- en: '**SI PREFIXES FOR BINARY DATA**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制数据的 SI 前缀**'
- en: To address the confusion caused by multiple meanings of prefixes, a new set
    of prefixes was introduced in 2002 (in a standard called IEEE 1541) to be used
    for binary scenarios. When dealing with powers of 2, kibi- is to be used instead
    of kilo-, mebi- is to be used instead of mega-, and so on. These new prefixes
    correspond to base 2 values and are intended to be used in scenarios where the
    old prefixes were previously being used incorrectly. For example, since kilobyte
    might be interpreted as 1,000 or 1,024 bytes, this standard recommends that kibibyte
    be used to mean 1,024 bytes, while kilo- retains its original meaning so that
    a kilobyte is equal to 1,000 bytes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除由前缀多重含义引起的混淆，2002 年（在 IEEE 1541 标准中）引入了一组新的前缀，用于二进制场景。在处理 2 的幂次时，应使用 kibi-
    代替 kilo-，mebi- 代替 mega-，以此类推。这些新的前缀对应基数 2 的值，旨在用于以前旧前缀被错误使用的场景。例如，由于千字节可能被解释为
    1,000 或 1,024 字节，标准建议使用 kibibyte 来表示 1,024 字节，而 kilo- 保留其原意，使得千字节等于 1,000 字节。
- en: This seems like a good idea, but at the time of this writing, these symbols
    haven’t been widely adopted. [Table 1-4](ch01.xhtml#ch1tab4) lists the new prefixes
    and their meanings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是个不错的主意，但在写这篇文章时，这些符号尚未被广泛采用。[表 1-4](ch01.xhtml#ch1tab4)列出了新的前缀及其含义。
- en: '**Table 1-4:** IEEE 1541-2002 Prefixes for Binary Data'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-4：** IEEE 1541-2002 二进制数据的前缀'
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 2** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **前缀名称** | **前缀符号** | **值** | **基数 2** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| tebi | Ti | 1,099,511,627,776 | 2^(40) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| tebi | Ti | 1,099,511,627,776 | 2^(40) |'
- en: '| gibi | Gi | 1,073,741,824 | 2^(30) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| gibi | Gi | 1,073,741,824 | 2^(30) |'
- en: '| mebi | Mi | 1,048,576 | 2^(20) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| mebi | Mi | 1,048,576 | 2^(20) |'
- en: '| kibi | Ki | 1,024 | 2^(10) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| kibi | Ki | 1,024 | 2^(10) |'
- en: This distinction is important because in practice, most software that displays
    the size of files uses the old SI prefix but calculates size using base 2\. In
    other words, if your device says a file’s size is 1KB, it means 1,024 bytes. On
    the other hand, manufacturers of storage devices tend to advertise the capacity
    of their devices using base 10\. This means that a hard drive that is advertised
    as 1TB probably holds 1 trillion bytes, but if you connect that device to a computer,
    the computer will show the size as about 931GB (1 trillion divided by 2^(30)).
    Given the lack of standard adoption of the new prefixes, in this book, I will
    continue to use the old SI prefixes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个区别很重要，因为在实际操作中，大多数显示文件大小的软件使用的是旧的 SI 前缀，但计算文件大小时却采用基数 2。换句话说，如果你的设备显示一个文件的大小是
    1KB，那就意味着 1,024 字节。另一方面，存储设备的制造商倾向于使用基数 10 来宣传其设备的容量。这意味着一个标称为 1TB 的硬盘可能存储 1 万亿字节，但如果你将该设备连接到计算机，计算机将显示大约
    931GB（1 万亿除以 2^(30)）。鉴于新的前缀尚未被广泛采用，在本书中，我将继续使用旧的 SI 前缀。
- en: '### **Hexadecimal**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '### **十六进制**'
- en: 'Before we leave the topic of thinking in binary, I’ll cover one more number
    system: hexadecimal. Quickly reviewing, our “normal” number system is decimal,
    or base 10\. Computers use binary, or base 2\. *Hexadecimal* is *base 16*! Given
    what you’ve already learned in this chapter, you probably know what that means.
    Hexadecimal, or just *hex* for short, is a place-value system where each place
    represents a power of 16, and each place can be one of 16 symbols.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开二进制思维的话题之前，我还要介绍一个数字系统：十六进制。快速回顾一下，我们的“正常”数字系统是十进制，或基数 10。计算机使用二进制，或基数
    2。*十六进制*是*基数 16*！根据你在本章已经学到的内容，你大概知道这意味着什么。十六进制，简称*hex*，是一种位置值系统，每个位置表示 16 的幂次，每个位置可以是
    16 个符号之一。
- en: 'As in all place-value systems, the rightmost place will still be the ones place.
    The next place to the left will be the sixteens place, then the 256s (16 × 16)
    place, then the 4,096s (16 × 16 × 16) place, and so on. Simple enough. But what
    about the other requirement that each place can be one of 16 symbols? We usually
    have ten symbols to use to represent numbers, 0 through 9\. We need to add six
    more symbols to represent the other values. We could pick some random symbols
    like & @ #, but these symbols have no obvious order. Instead, the standard is
    to use A, B, C, D, E, and F (either uppercase or lowercase is fine!). In this
    scheme, A represents ten, B represents eleven, and so on, up to F, which represents
    fifteen. That makes sense; we need symbols that represent zero through one less
    than the base. So our extra symbols are A through F. It’s standard practice to
    use the prefix 0x to indicate hexadecimal, when needed for clarity. [Table 1-5](ch01.xhtml#ch1tab5)
    lists each of the 16 hexadecimal symbols, along with their decimal and binary
    equivalents.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '在所有位值系统中，最右边的位仍然是个位。接下来的位是十六位，然后是256位（16 × 16），然后是4,096位（16 × 16 × 16），依此类推。很简单。那么每个位可以是16个符号中的一个的另一个要求怎么办呢？我们通常有十个符号来表示数字，0到9。我们需要添加六个符号来表示其他值。我们可以选择一些随机符号，如&
    @ #，但这些符号没有明显的顺序。相反，标准做法是使用A、B、C、D、E和F（大小写都可以！）。在这个方案中，A表示十，B表示十一，依此类推，到F表示十五。这是有道理的；我们需要表示从零到比基数少一的符号。所以我们的额外符号是A到F。通常在需要明确区分时，使用前缀0x来表示十六进制。[表1-5](ch01.xhtml#ch1tab5)列出了16个十六进制符号及其对应的十进制和二进制值。'
- en: '**Table 1-5:** Hexadecimal Symbols'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-5：** 十六进制符号'
- en: '| **Hexadecimal** | **Decimal** | **Binary (4-bit)** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **十六进制** | **十进制** | **二进制（4位）** |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0000 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0000 |'
- en: '| 1 | 1 | 0001 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0001 |'
- en: '| 2 | 2 | 0010 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 0010 |'
- en: '| 3 | 3 | 0011 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 0011 |'
- en: '| 4 | 4 | 0100 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 0100 |'
- en: '| 5 | 5 | 0101 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 0101 |'
- en: '| 6 | 6 | 0110 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 0110 |'
- en: '| 7 | 7 | 0111 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 0111 |'
- en: '| 8 | 8 | 1000 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 8 | 1000 |'
- en: '| 9 | 9 | 1001 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 9 | 1001 |'
- en: '| A | 10 | 1010 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| A | 10 | 1010 |'
- en: '| B | 11 | 1011 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| B | 11 | 1011 |'
- en: '| C | 12 | 1100 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| C | 12 | 1100 |'
- en: '| D | 13 | 1101 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| D | 13 | 1101 |'
- en: '| E | 14 | 1110 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| E | 14 | 1110 |'
- en: '| F | 15 | 1111 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| F | 15 | 1111 |'
- en: What happens when you need to count higher than 15 decimal or 0xF? Just like
    in decimal, we add another place. After 0xF comes 0x10, which is 16 decimal. Then
    0x11, 0x12, 0x13, and so on. Now take a look at [Figure 1-4](ch01.xhtml#ch1fig4),
    where we see a larger hexadecimal number, 0x1A5.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要数到超过十进制的15或0xF时会发生什么？就像在十进制中一样，我们加上了另一个位。0xF之后是0x10，即十进制的16。然后是0x11、0x12、0x13，依此类推。现在看看[图1-4](ch01.xhtml#ch1fig4)，我们看到一个更大的十六进制数，0x1A5。
- en: '![image](../images/fig1-4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-4.jpg)'
- en: '*Figure 1-4: Hexadecimal number 0x1A5 broken out by place value*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-4：十六进制数0x1A5按位值拆解*'
- en: In [Figure 1-4](ch01.xhtml#ch1fig4) we have the number 0x1A5 in hexadecimal.
    What’s the value of this number in decimal? The rightmost place is worth 5\. The
    next place has a weight of 16, and there’s an A there, which is 10 in decimal,
    so the middle place is worth 16 × 10 = 160\. The leftmost place has a weight of
    256, and there’s a 1 in that place, so that place is worth 256\. The total value
    then is 5 + 160 + 256 = 421 in decimal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1-4](ch01.xhtml#ch1fig4)中，我们有一个十六进制的数字0x1A5。这个数字在十进制中的值是多少？最右边的位是5。接下来的位的权重是16，那里是A，它在十进制中是10，所以中间位的值是16
    × 10 = 160。最左边的位的权重是256，那里是1，所以这一位的值是256。总值是5 + 160 + 256 = 421，换算成十进制就是421。
- en: Just to reinforce the point, this example shows how the new symbols, like A,
    have a different value depending on the place in which they appear. 0xA is 10
    decimal, but 0xA0 is 160 in decimal, because the A appears in the sixteens place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步强调这一点，这个例子展示了像A这样的新符号，根据它们出现的位置，值会有所不同。0xA是十进制的10，但0xA0是十进制的160，因为A出现在十六位的位置。
- en: At this point you may be saying to yourself “great, but what use is this?” I’m
    glad you asked. Computers don’t use hexadecimal, and neither do most people. And
    yet, hexadecimal is very useful for people who need to work in binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你可能会在心里想：“很好，但这有什么用呢？”很高兴你问了这个问题。计算机并不使用十六进制，大多数人也不使用。然而，十六进制对于需要处理二进制的人来说非常有用。
- en: Using hexadecimal helps overcome two common difficulties with working in binary.
    First, most people are terrible at reading long sequences of 0s and 1s. After
    a while the bits all run together. Dealing with 16 or more bits is tedious and
    error-prone for humans. The second problem is that although people are good at
    working in decimal, converting between decimal and binary isn’t easy. It’s tough
    for most people to look at a decimal number and quickly tell which bits would
    be 1 or 0 if that number were represented in binary. But with hexadecimal, conversions
    to binary are much more straightforward. [Table 1-6](ch01.xhtml#ch1tab6) provides
    a couple of examples of 16-bit binary numbers and their corresponding hexadecimal
    and decimal representations. Note that I’ve added spaces to the binary values
    for clarity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制有助于克服处理二进制时的两个常见困难。首先，大多数人不擅长阅读长串的0和1。过一段时间后，比特位就会混在一起。处理16个或更多比特对人类来说既繁琐又容易出错。第二个问题是，虽然人们擅长使用十进制，但在十进制和二进制之间转换并不容易。大多数人很难看着一个十进制数字，迅速判断出如果这个数字用二进制表示，哪些比特位是1，哪些是0。但使用十六进制，二进制到十六进制的转换就变得更加直接。[表1-6](ch01.xhtml#ch1tab6)提供了一些16位二进制数字的例子，以及它们对应的十六进制和十进制表示。请注意，我已在二进制值中加入空格，以提高清晰度。
- en: '**Table 1-6:** Examples of 16-bit Binary Numbers as Decimal and Hexadecimal'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-6：16位二进制数字的十进制和十六进制示例**'
- en: '|  | **Example 1** | **Example 2** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | **示例 1** | **示例 2** |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Binary** | 1111 0000 0000 1111 | 1000 1000 1000 0001 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | 1111 0000 0000 1111 | 1000 1000 1000 0001 |'
- en: '| **Hexadecimal** | F00F | 8881 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **十六进制** | F00F | 8881 |'
- en: '| **Decimal** | 61,455 | 34,945 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | 61,455 | 34,945 |'
- en: 'Consider Example 1 in [Table 1-6](ch01.xhtml#ch1tab6). In binary, there’s a
    clear sequence: the first four bits are 1, the next eight bits are 0, and the
    last four bits are 1\. In decimal, this sequence is obscured. It isn’t clear at
    all from looking at 61,455 which bits might be set to 0 or 1\. Hexadecimal, on
    the other hand, mirrors the sequence in binary. The first hex symbol is F (which
    is 1111 in binary), the next two hex symbols are 0, and the final hex symbol is
    F.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[表1-6](ch01.xhtml#ch1tab6)中的示例 1。在二进制中，序列非常清晰：前四个比特是1，接下来的八个比特是0，最后四个比特是1。在十进制中，这个序列就变得模糊了。从61,455看不出哪些比特可能是0或1。而十六进制则很好地反映了二进制中的序列。第一个十六进制符号是F（在二进制中是1111），接下来的两个十六进制符号是0，最后一个十六进制符号是F。
- en: Continuing to Example 2, the first three sets of four bits are all 1000 and
    the final set of four bits is 0001\. That’s easy to see in binary, but rather
    hard to see in decimal. Hexadecimal provides a clearer picture, with the hexadecimal
    symbol of 8 corresponding to 1000 in binary and the hexadecimal symbol of 1 corresponding
    to, well, 1!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 继续看示例 2，前三组四个比特都是1000，最后一组四个比特是0001。在二进制中很容易看出这一点，但在十进制中就比较难以看清。十六进制提供了一个更清晰的表示，其中十六进制符号8对应于二进制的1000，而十六进制符号1则对应于1！
- en: 'I hope you are seeing a pattern emerge: every four bits in binary correspond
    to one symbol in hexadecimal. If you remember, four bits is half a byte (or a
    nibble). Therefore, a byte can be easily represented with two hexadecimal symbols.
    A 16-bit number can be represented with four hex symbols, a 32-bit number with
    eight hex symbols, and so on. Let’s take the 32-bit number in [Figure 1-5](ch01.xhtml#ch1fig5)
    as an example.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能看到一个规律：二进制中的每四个比特对应十六进制中的一个符号。如果你记得的话，四个比特是半个字节（或者说是半个Nibble）。因此，一个字节可以用两个十六进制符号来表示。一个16位的数字可以用四个十六进制符号表示，一个32位的数字可以用八个十六进制符号表示，依此类推。我们来看[图1-5](ch01.xhtml#ch1fig5)中的32位数字作为例子。
- en: '![image](../images/fig1-5.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-5.jpg)'
- en: '*Figure 1-5: Each hexadecimal character maps to 4 bits*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-5：每个十六进制字符映射到4个比特*'
- en: In [Figure 1-5](ch01.xhtml#ch1fig5) we can digest this rather long number one
    half-byte at a time, something that isn’t possible using a decimal representation
    of the same number (2,320,695,040).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1-5](ch01.xhtml#ch1fig5)中，我们可以每次处理半个字节来理解这个相对较长的数字，而用十进制表示同一个数字（2,320,695,040）时是无法做到的。
- en: Because it’s relatively easy to move between binary and hex, many engineers
    will often use the two in tandem, converting to decimal numbers only when necessary.
    I’ll use hexadecimal later in this book where it makes sense.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在二进制和十六进制之间转换相对容易，许多工程师通常会同时使用这两种表示方式，只有在必要时才转换为十进制数字。本书稍后会在适当的地方使用十六进制。
- en: Try converting from binary to hexadecimal without going through the intermediate
    step of converting to decimal.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从二进制转换到十六进制，而不通过先转换为十进制的中间步骤。
- en: '**EXERCISE 1-4: BINARY TO HEXADECIMAL**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-4：二进制转十六进制**'
- en: Convert these numbers, represented in binary, to their hexadecimal equivalents.
    Don’t convert to decimal if you can help it! The goal is to move directly from
    binary to hexadecimal.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些以二进制表示的数字转换为其十六进制等价物。如果可以避免，请不要转换为十进制！目标是直接从二进制转换为十六进制。
- en: 10 (binary) = ______ (hexadecimal)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 10 (二进制) = ______ (十六进制)
- en: 11110000 (binary) = ______ (hexadecimal)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 11110000 (二进制) = ______ (十六进制)
- en: You can check your answers in [Appendix A](appa.xhtml).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录 A](appa.xhtml)中查看你的答案。
- en: Once you have the hang of binary to hexadecimal, try going the other way, from
    hex to binary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了从二进制到十六进制的转换，试着反过来做，从十六进制转换到二进制。
- en: '**EXERCISE 1-5: HEXADECIMAL TO BINARY**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-5：十六进制转二进制**'
- en: Convert these numbers, represented in hexadecimal, to their binary equivalents.
    Don’t convert to decimal if you can help it! The goal is to move directly from
    hexadecimal to binary.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些以十六进制表示的数字转换为其二进制等价物。如果可以避免，请不要转换为十进制！目标是直接从十六进制转换为二进制。
- en: 1A (hexadecimal) = _____ (binary)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 1A (十六进制) = _____ (二进制)
- en: C3A0 (hexadecimal) = ______ (binary)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C3A0 (十六进制) = ______ (二进制)
- en: You can check your answers in [Appendix A](appa.xhtml).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录 A](appa.xhtml)中查看你的答案。
- en: '**Summary**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we covered some of the foundational concepts of computing.
    You learned that a computer is any electronic device that can be programmed to
    carry out a set of logical instructions. You then saw that modern computers are
    digital devices rather than analog devices, and you learned the difference between
    the two: analog systems are those that use widely varying values to represent
    data, whereas digital systems represent data as a sequence of symbols. After that,
    we explored how modern digital computers rely on only two symbols, 0 and 1, and
    learned about a number system consisting of only two symbols, base 2, or binary.
    We covered bits, bytes, and the standard SI prefixes (giga-, mega-, kilo-, and
    so on) you can use to more easily describe the size of data. Lastly, you learned
    how hexadecimal is useful for people who need to work in binary.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些计算机基础概念。你学到了计算机是任何可以被编程以执行一系列逻辑指令的电子设备。接着你了解到现代计算机是数字设备，而不是模拟设备，并学会了它们之间的区别：模拟系统使用广泛变化的值来表示数据，而数字系统则将数据表示为符号的序列。之后，我们探讨了现代数字计算机如何仅依赖于两个符号，0和1，并了解了由这两个符号组成的数字系统，即二进制。我们介绍了位（bit）、字节（byte）以及你可以用来更轻松描述数据大小的标准国际单位前缀（如千兆（giga-）、兆（mega-）、千（kilo-）等）。最后，你学到了十六进制如何帮助那些需要在二进制中工作的人员。
- en: In the next chapter we’ll look more closely at how binary is used in digital
    systems. We’ll take a look at how binary can be used to represent various types
    of data, and we’ll see how binary logic works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地研究二进制在数字系统中的应用。我们将看看如何使用二进制表示各种类型的数据，并了解二进制逻辑是如何工作的。
