- en: '## **1'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **1'
- en: COMPUTING CONCEPTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机概念**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'Computers are everywhere now: in our homes, our schools, our offices—you might
    find a computer in your pocket, on your wrist, or even in your refrigerator. It’s
    easier than ever to find and use computers, but few people today really understand
    how computers work. This isn’t surprising, since learning the complexities of
    computing can be overwhelming. The goal of this book is to lay out the foundational
    principles of computing in a way that anyone with curiosity, and a bit of a technical
    bent, can follow. Before we dig into the nuts and bolts of how computers work,
    let’s take some time to get familiar with some major concepts of computing.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机如今无处不在：在我们的家里、学校、办公室——你可能在口袋里、手腕上，甚至在冰箱里找到计算机。如今，找到并使用计算机比以往任何时候都容易，但很少有人真正理解计算机是如何工作的。这并不令人惊讶，因为学习计算机的复杂性可能会让人不知所措。本书的目标是以一种任何有好奇心并具备一些技术倾向的人都能理解的方式，阐明计算机的基本原理。在我们深入了解计算机如何工作之前，让我们花点时间了解一些计算机的主要概念。
- en: In this chapter we’ll begin by discussing the definition of a computer. From
    there, we’ll cover the differences between analog and digital data and then explore
    number systems and the terminology used to describe digital data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从讨论计算机的定义开始。从这个定义出发，我们将介绍模拟数据和数字数据之间的差异，然后探讨数字数据的数制和术语。
- en: '**Defining a Computer**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义计算机**'
- en: 'Let’s start with a basic question: what is a computer? When people hear the
    word *computer*, most think of a laptop or desktop, sometimes referred to as a
    personal computer or PC. That is one class of device that this book covers, but
    let’s think a bit more broadly. Consider smartphones. Smartphones are certainly
    computers; they perform the same types of operations as PCs. In fact, for many
    people today, a smartphone is their primary computing device. Most computer users
    today also rely on the internet, which is powered by servers—another type of computer.
    Every time you visit a website or use an app that connects to the internet, you’re
    interacting with one or more servers connected to a global network. Video game
    consoles, fitness trackers, smart watches, smart televisions … all of these are
    computers!'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本问题开始：什么是计算机？当人们听到*计算机*这个词时，大多数人会想到笔记本电脑或台式电脑，有时被称为个人计算机或PC。这是本书讨论的其中一种设备类型，但让我们再扩大一些思考。考虑一下智能手机。智能手机当然是计算机；它们执行与PC相同类型的操作。事实上，对于今天的许多人来说，智能手机是他们的主要计算设备。如今，大多数计算机用户还依赖互联网，而互联网是由服务器提供支持的——另一种计算机类型。每次你访问网站或使用连接到互联网的应用程序时，你都在与一个或多个连接到全球网络的服务器互动。视频游戏机、健身追踪器、智能手表、智能电视……这些都是计算机！
- en: A *computer* is any electronic device that can be programmed to carry out a
    set of logical instructions. With that definition in mind, it becomes clear that
    many modern devices are in fact computers!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*计算机*是任何能够被编程以执行一组逻辑指令的电子设备。根据这个定义，很明显许多现代设备实际上都是计算机！
- en: '**EXERCISE 1-1: FIND THE COMPUTERS IN YOUR HOME**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1-1：找出你家里的计算机**'
- en: Take a moment and see how many computers you can identify in your home. When
    I did this exercise with my family, we quickly found about 30 devices!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 花一点时间，看看你能在家里找出多少台计算机。当我和家人一起做这个练习时，我们很快找到了大约30个设备！
- en: '**Analog and Digital**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟与数字**'
- en: You’ve probably heard a computer described as a digital device. This is in contrast
    to an analog device, such as a mechanical clock. But what do these two terms really
    mean? Understanding the differences between analog and digital is foundational
    to understanding computing, so let’s take a closer look at these two concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过计算机被描述为数字设备。这与模拟设备，如机械钟表，是相对的。那么这两个术语到底是什么意思呢？理解模拟和数字之间的差异是理解计算机的基础，因此让我们仔细看看这两个概念。
- en: '***The Analog Approach***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟方法***'
- en: 'Look around you. Pick an object. Ask yourself: What color is it? What size
    is it? How much does it weigh? By answering these questions, you’re describing
    the attributes, or *data*, of that object. Now, pick a different object and answer
    the same questions. If you repeat this process for even more objects, you’ll find
    that for each question, the potential answers are numerous. You might pick up
    a red object, a yellow object, or a blue object. Or the object could be a mix
    of the primary colors. This type of variation does not only apply to color. For
    a given property, the variations found across the objects in our world are potentially
    infinite.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: It’s one thing to describe an object verbally, but let’s say you want to measure
    one of its attributes more precisely. If you wanted to measure an object’s weight,
    for example, you could put it on a scale. The scale, responding to the weight
    placed upon it, would move a needle along a numbered line, stopping when it reaches
    a position that corresponds to the weight. Read the number from the scale and
    you have the object’s weight.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of measurement is common, but let’s think a little more about how
    we’re measuring this data. The position of the needle on the scale isn’t actually
    the weight; it’s a representation of the weight. The numbered line that the needle
    points to provides a means for us to easily convert between the needle’s position,
    representing a weight, and the numeric value of that weight. In other words, though
    the weight is an attribute of the object, here we can understand that attribute
    through something else: the position of the needle along the line. The needle’s
    position changes proportionally in response to the weight placed on the scale.
    Thus, the scale is working as an *analogy* where we understand the weight of the
    object through the needle’s position on the line. This is why we call this method
    of measuring the *analog* approach.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Another example of an analog measuring tool is a mercury thermometer. Mercury’s
    volume increases with temperature. Thermometer manufacturers utilize this property
    by placing mercury in a glass tube with markings that correspond to the expected
    volume of the mercury at various temperatures. Thus, the position of mercury in
    the tube serves as a representation of temperature. Notice that for both of these
    examples (a scale and a thermometer), when we make a measurement, we can use markings
    on the instrument to convert a position to a specific numeric value. But the value
    we read from the instrument is just an approximation. The true position of the
    needle or mercury can be anywhere within the range of the instrument, and we round
    up or down to the nearest marked value. So although it may seem that these tools
    can produce only a finite set of measurements, that’s a limitation imposed by
    the conversion to a number, not by the analogy itself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Throughout most of human history, humans have measured things using an analog
    approach. But people don’t only use analog approaches for measurement. They’ve
    also devised clever ways to store data in an analog fashion. A phonograph record
    uses a modulated groove as an analog representation of audio that was recorded.
    The groove’s shape changes along its path in a way that corresponds to changes
    in the shape of the audio waveform over time. The groove isn’t the audio itself,
    but it’s an analogy of the original sound’s waveform. Film-based cameras do something
    similar by briefly exposing film to light from a camera lens, leading to a chemical
    change in the film. The chemical properties of the film are not the image itself,
    but a representation of the captured image, an analogy of the image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在人类历史的大部分时间里，人类一直通过模拟方法来测量事物。但人类不仅仅用模拟方法来测量，他们还设计出了巧妙的方法来以模拟方式存储数据。唱片利用调制的槽纹作为录制音频的模拟表示。槽纹的形状沿着路径变化，呈现出音频波形随时间变化的情况。槽纹本身不是音频，但它是原始声音波形的类比。基于胶片的相机做了类似的事情，通过短暂地将胶片暴露在相机镜头的光线下，导致胶片发生化学变化。胶片的化学性质不是图像本身，而是捕捉到的图像的表示，是图像的类比。
- en: '***Going Digital***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***走向数字化***'
- en: What does all this have to do with computing? It turns out that all those analog
    representations of data are hard for computers to deal with. The types of analog
    systems used are so different and variable that creating a common computing device
    that can understand all of them is nearly impossible. For example, creating a
    machine that can measure the volume of mercury is a very different task than creating
    a machine that can read the grooves on a vinyl disc. Additionally, computers require
    highly reliable and accurate representations of certain types of data, such as
    numeric data sets and software programs. Analog representations of data can be
    difficult to measure precisely, tend to decay over time, and lose fidelity when
    copied. Computers need a way to represent all types of data in a format that can
    be accurately processed, stored, and copied.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切与计算有什么关系？事实证明，那些数据的模拟表示方式对于计算机来说难以处理。所使用的模拟系统类型差异巨大且变化多端，几乎不可能创建一个通用的计算设备来理解所有这些系统。例如，制作一个能够测量水银体积的机器和制作一个能够读取黑胶唱片槽纹的机器是完全不同的任务。此外，计算机需要高度可靠和准确的数据表示，像数字数据集和软件程序等类型的数据。数据的模拟表示可能难以精确测量，随着时间的推移会衰减，且在复制时会失去保真度。计算机需要一种方法，以一种可以准确处理、存储和复制的格式来表示所有类型的数据。
- en: 'If we don’t want to represent data as something with potentially infinitely
    varying analog values, what can we do? We can use a digital approach instead.
    A *digital* system represents data as a sequence of symbols, where each symbol
    is one of a limited set of values. Now, that description may sound a bit formal
    and a bit confusing, so rather than go deep on the theory of digital systems,
    I’ll explain what this means in practice. In almost all of today’s computers,
    data is represented with combinations of two symbols: 0 and 1\. That’s it. Although
    a digital system could use more than two symbols, adding more symbols would increase
    the complexity and cost of the system. A set of only two symbols allows for simplified
    hardware and improved reliability. All data in most modern computing devices is
    represented as a sequence of 0s and 1s. From this point forward in this book,
    when I talk about digital computers, you can assume that I am talking about systems
    that only deal with 0s and 1s and not some other set of symbols. Nice and simple!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想将数据表示为具有潜在无限变化的模拟值，我们该怎么办？我们可以改用数字化方法。*数字*系统将数据表示为一系列符号，其中每个符号是有限集合中的一个值。现在，这个描述可能听起来有点正式，也有些让人困惑，所以与其深入探讨数字系统的理论，我将解释它在实际中的含义。在今天几乎所有的计算机中，数据是通过两个符号的组合来表示的：0和1。仅此而已。虽然数字系统可以使用超过两个符号，但添加更多符号会增加系统的复杂性和成本。仅使用两个符号的集合可以简化硬件设计，并提高可靠性。在大多数现代计算设备中，所有数据都表示为0和1的序列。从此书开始，当我谈论数字计算机时，您可以假设我指的是只处理0和1的系统，而不是其他符号集合。简单明了！
- en: 'It’s a point worth repeating: everything on your computer is stored as 0s and
    1s. The last photo you took on your smartphone? Your device stored the photo as
    a sequence of 0s and 1s. The song you streamed from the internet? 0s and 1s. The
    document you wrote on your computer? 0s and 1s. The app you installed? It was
    a bunch of 0s and 1s. The website you visited? 0s and 1s.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的一点是：你计算机上的一切都以0和1存储。你在智能手机上拍的最后一张照片？你的设备将这张照片存储为一串0和1。你从互联网流媒体播放的歌曲？0和1。你在计算机上写的文档？0和1。你安装的应用程序？一堆0和1。你访问的网站？0和1。
- en: It may sound limiting to say that we can only use 0 and 1 to represent the infinite
    values found in nature. How can a musical recording or a detailed photograph be
    distilled down to 0s and 1s? Many find it counterintuitive that such a limited
    “vocabulary” can be used to express complex ideas. The key here is that digital
    systems use a *sequence* of 0s and 1s. A digital photograph, for example, usually
    consists of millions of 0s and 1s.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说我们只能使用0和1来表示自然界中的无限值，可能听起来有些限制。如何将一段音乐录音或一张详细的照片浓缩成0和1呢？许多人觉得这样有限的“词汇”能够表达复杂的思想是直觉上难以理解的。关键在于，数字系统使用的是一串0和1。举个例子，一张数字照片通常由数百万个0和1组成。
- en: 'So what exactly are these 0s and 1s? You may see other terms used to describe
    these 0s and 1s: false and true, off and on, low and high, and so forth. This
    is because the computer doesn’t literally store the number *0* or *1*. It stores
    a sequence of entries where each entry in the sequence can have only two possible
    states. Each entry is like a light switch that is either on or off. In practice,
    these sequences of 1s and 0s are stored in various ways. On a CD or DVD, the 0s
    and 1s are stored on the disc as bumps (0) or flat spaces (1). On a flash drive,
    the 1s and 0s are stored as electrical charges. A hard disk drive stores the 0s
    and 1s using magnetization. As you’ll see in [Chapter 4](ch04.xhtml), digital
    circuits represent 0s and 1s using voltage levels.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些0和1究竟是什么呢？你可能会看到其他术语用来描述这些0和1：假和真，关和开，低和高等等。这是因为计算机并不直接存储数字*0*或*1*。它存储的是一串条目，其中每个条目只有两种可能的状态。每个条目就像一个开关，要么是开，要么是关。实际上，这些1和0的序列以各种方式存储。在CD或DVD上，0和1通过凸起（0）或平坦的空间（1）存储在光盘上。在闪存驱动器中，1和0以电荷的形式存储。在硬盘驱动器中，0和1通过磁化存储。正如你将在[第4章](ch04.xhtml)中看到的，数字电路通过电压水平来表示0和1。
- en: Before we move on, one final note on the term *analog*—it’s often used to simply
    mean “not digital.” For example, engineers may speak of an “analog signal,” meaning
    a signal that varies continuously and doesn’t align to digital values. In other
    words, it’s a non-digital signal but doesn’t necessarily represent an analogy
    of something else. So, when you see the term *analog*, consider that it might
    not always mean what you think.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，最后一个关于术语*模拟*的说明——它通常用来表示“非数字化”。例如，工程师可能会说“模拟信号”，意思是信号是连续变化的，并不与数字值对齐。换句话说，它是一个非数字信号，但不一定表示其他事物的类比。因此，当你看到*模拟*这个术语时，考虑到它可能并不总是意味着你想的那样。
- en: '**Number Systems**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值系统**'
- en: 'So far, we’ve established that computers are digital machines that deal with
    0s and 1s. For many people, this concept seems strange; they’re used to having
    0 through 9 at their disposal when representing numbers. If we constrain ourselves
    to only two symbols, rather than ten, how should we represent large numbers? To
    answer that question, let’s back up and review an elementary school math topic:
    number systems.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定计算机是处理0和1的数字机器。对于许多人来说，这个概念似乎很奇怪；他们习惯了在表示数字时使用0到9。如果我们只限于使用两个符号，而不是十个，我们应该如何表示大数字呢？为了回答这个问题，让我们回顾一下小学数学中的一个基本话题：数值系统。
- en: '***Decimal Numbers***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***十进制数***'
- en: We typically write numbers using something called *decimal place-value notation*.
    Let’s break that down. *Place-value notation* (or *positional notation*) means
    that each position in a written number represents a different order of magnitude;
    *decimal*, or *base 10*, means that the orders of magnitude are factors of 10,
    and each place can have one of ten different symbols, 0 through 9\. Look at the
    example of place-value notation in [Figure 1-1](ch01.xhtml#ch1fig1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用一种叫做*十进制位置值表示法*的方式来写数字。让我们来解析一下。*位置值表示法*（或*位置表示法*）意味着写下的每个数字位置代表不同的数量级；*十进制*，或者说*基数10*，意味着数量级是10的倍数，每个位置可以有十个不同的符号，0到9。请参见[图1-1](ch01.xhtml#ch1fig1)中的位置值表示法示例。
- en: '![image](../images/fig1-1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-1.jpg)'
- en: '*Figure 1-1: Two hundred seventy-five represented in decimal place-value notation*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：二百七十五在十进制位置值表示法中的表示*'
- en: 'In [Figure 1-1](ch01.xhtml#ch1fig1), the number two hundred seventy-five is
    written in decimal notation as 275\. The 5 is in the ones place, meaning its value
    is 5 × 1 = 5\. The 7 is in the tens place, meaning its value is 7 × 10 = 70\.
    The 2 is in the hundreds place, meaning its value is 2 × 100 = 200\. The total
    value is the sum of all the places: 5 + 70 + 200 = 275.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-1](ch01.xhtml#ch1fig1)中，数字二百七十五在十进制表示法中写作 275。5 位于个位，因此它的值是 5 × 1 = 5。7
    位于十位，因此它的值是 7 × 10 = 70。2 位于百位，因此它的值是 2 × 100 = 200。总值是所有位置值的和：5 + 70 + 200 =
    275。
- en: Easy, right? You’ve probably understood this since first grade. But let’s examine
    this a bit closer. Why is the rightmost place the ones place? And why is the next
    place the tens place, and so on? It’s because we are working in decimal, or base
    10, and therefore each place is a power of ten—in other words, 10 multiplied by
    itself a certain number of times. As seen in [Figure 1-2](ch01.xhtml#ch1fig2),
    the rightmost place is 10 raised to 0, which is 1, because any number raised to
    0 is 1\. The next place is 10 raised to 1, which is 10, and the next place is
    10 raised to 2 (10 × 10), which is 100.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？你可能从一年级起就已经理解了这个概念。但让我们更仔细地分析一下。为什么最右边的位置是个位？为什么下一个位置是十位，依此类推？这是因为我们使用的是十进制，或者说是基数
    10，因此每个位置代表的是 10 的幂，换句话说，10 是自乘若干次的结果。如[图 1-2](ch01.xhtml#ch1fig2)所示，最右边的位置是 10
    的 0 次方，等于 1，因为任何数的 0 次方都等于 1。下一个位置是 10 的 1 次方，等于 10，接下来的位置是 10 的 2 次方（10 × 10），等于
    100。
- en: '![image](../images/fig1-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-2.jpg)'
- en: '*Figure 1-2: In decimal place-value notation, each place is a power of ten.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：在十进制位置值表示法中，每个位置是 10 的幂。*'
- en: If we needed to represent a number larger than 999 in decimal, we’d add another
    place to the left, the thousands place, and its weight would be equal to 10 raised
    to 3 (10 × 10 × 10), which is 1,000\. This pattern continues so that we can represent
    any large whole number by adding more places as needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要表示一个比 999 更大的数字，我们会在左侧加一个位置，即千位，其权重等于 10 的 3 次方（10 × 10 × 10），也就是 1,000。这个模式继续延续，因此我们可以通过添加更多的位置来表示任何大数字。
- en: We’ve established why the various places have certain weights, but let’s keep
    digging. Why does each place use the symbols 0 through 9? When working in decimal,
    we can only have ten symbols, because by definition each place can only represent
    ten different values. 0 through 9 are the symbols that are currently used, but
    really any set of ten unique symbols could be used, with each symbol corresponding
    to a certain numeric value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了为什么不同的位置有不同的权重，但让我们继续深入。为什么每个位置使用符号 0 到 9？在十进制中，我们只能使用十个符号，因为根据定义，每个位置只能表示十个不同的值。当前使用的是
    0 到 9 这些符号，但实际上任何一组十个独特的符号都可以使用，每个符号对应某个数字值。
- en: Most humans prefer decimal, base 10, as a number system. Some say this is because
    we have ten fingers and ten toes, but whatever the reason, in the modern world
    most people read, write, and think of numbers in decimal. Of course, that’s just
    a convention we’ve collectively chosen to represent numbers. As we covered earlier,
    that convention doesn’t apply to computers, which instead use only two symbols.
    Let’s see how we can apply the principles of the place-value system while constraining
    ourselves to only two symbols.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人偏好使用十进制（基数 10）作为数字系统。有些人说这是因为我们有十个手指和十个脚趾，但无论原因如何，在现代世界，大多数人都是用十进制来读、写和思考数字。当然，这只是我们共同选择的代表数字的约定。如前所述，这一约定并不适用于计算机，计算机只使用两个符号。让我们看看如何在只使用两个符号的情况下应用位置值系统的原理。
- en: '***Binary Numbers***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制数字***'
- en: The number system consisting of only two symbols is *base 2*, or *binary*. Binary
    is still a place-value system, so the fundamental mechanics are the same as decimal,
    but there are a couple of changes. First, each place represents a power of 2,
    rather than a power of 10\. Second, each place can only have one of two symbols,
    rather than ten. Those two symbols are 0 and 1\. [Figure 1-3](ch01.xhtml#ch1fig3)
    has an example of how we’d represent a number using binary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个符号组成的数字系统是*二进制*。二进制仍然是一个位置值系统，因此其基本原理与十进制相同，但有一些变化。首先，每个位置代表的是 2 的幂，而不是 10
    的幂。其次，每个位置只能有两个符号中的一个，而不是十个符号。这两个符号是 0 和 1。[图 1-3](ch01.xhtml#ch1fig3)展示了我们如何使用二进制表示一个数字。
- en: '![image](../images/fig1-3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig1-3.jpg)'
- en: '*Figure 1-3: Five decimal represented in binary place-value notation*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 1-3](ch01.xhtml#ch1fig3), we have a binary number: 101\. That may
    look like one hundred and one to you, but when dealing in binary, this is actually
    a representation of five! If you wish to verbally say it, “one zero one binary”
    would be a good way to communicate what is written.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Just like in decimal, each place has a weight equal to the base raised to various
    powers. Since we are in base 2, the rightmost place is 2 raised to 0, which is
    1\. The next place is 2 raised to 1, which is 2, and the next place is 2 raised
    to 2 (2 × 2), which is 4\. Also, just like in decimal, to get the total value,
    we multiply the symbol in each place by the place-value weight and sum the results.
    So, starting from the right, we have (1 × 1) + (0 × 2) + (1 × 4) = 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Now you can try converting from binary to decimal yourself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 1-2: BINARY TO DECIMAL**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Convert these numbers, represented in binary, to their decimal equivalents.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = ______ (decimal)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 111 (binary) = ______ (decimal)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 1010 (binary) = ______ (decimal)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You can check your answers in [Appendix A](appa.xhtml). Did you get them right?
    The last one might have been a bit tricky, since it introduced another place to
    the left, the eights place. Now, try going the other way around, from decimal
    to binary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 1-3: DECIMAL TO BINARY**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Convert these numbers, represented in decimal, to their binary equivalents.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 3 (decimal) = ______ (binary)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 8 (decimal) = ______ (binary)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 14 (decimal) = ______ (binary)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: I hope you got those correct too! Right away, you can see that dealing with
    both decimal and binary at the same time can be confusing, since a number like
    10 represents ten in decimal or two in binary. From this point forward in the
    book, if there’s a chance of confusion, binary numbers will be written with a
    0b prefix. I’ve chosen the 0b prefix because several programming languages use
    this approach. The leading 0 (zero) character indicates a numeric value and the
    b is short for binary. As an example, 0b10 represents two in binary, whereas 10,
    with no prefix, means ten in decimal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits and Bytes**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A single place or symbol in a decimal number is called a *digit*. A decimal
    number like 1,247 is a four-digit number. Similarly, a single place or symbol
    in a binary number is called a *bit* (a binary digit). Each bit can either be
    0 or 1\. A binary number like 0b110 is a 3-bit number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'A single bit cannot convey much information; it’s either off or on, 0 or 1\.
    We need a sequence of bits to represent anything more complex. To make these sequences
    of bits easier to manage, computers group bits together in sets of eight, called
    *bytes*. Here are some examples of bits and bytes (leaving off the 0b prefix since
    they are all binary):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**1**   That’s a bit.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**0**   That is also a bit.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**11001110**   That’s a byte, or 8 bits.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**00111000**   That’s also a byte!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**10100101**   Yet another byte.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**0011100010100101**   That’s two bytes, or 16 bits.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**0011100010100101**  这是两个字节，或者说16位。'
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Fun fact: A 4-bit number, half a byte, is sometimes called a* nibble *(sometimes
    spelled* nybble *or* nyble).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*有趣的事实：4位二进制数，即半个字节，有时被称为* nibble *（有时拼写为* nybble *或* nyble）。'
- en: So how much data can we store in a byte? Another way to think about this question
    is how many unique combinations of 0s and 1s can we make with our 8 bits? Before
    we answer that question, let me illustrate with only 4 bits, as it’ll be easier
    to visualize.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能在一个字节中存储多少数据呢？换句话说，我们可以用8位二进制表示多少种不同的0和1的组合？在回答这个问题之前，我先用4位二进制来说明，因为这样更容易理解。
- en: In [Table 1-1](ch01.xhtml#ch1tab1), I’ve listed all the possible combination
    of 0s and 1s in a 4-bit number. I’ve also included the corresponding decimal representation
    of that number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表格1-1](ch01.xhtml#ch1tab1)中，我列出了4位二进制数的所有可能组合，并包括了该数的对应十进制表示。
- en: '**Table 1-1:** All Possible Values of a 4-bit Number'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格1-1：** 所有可能的4位二进制数值'
- en: '| **Binary** | **Decimal** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十进制** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | 8 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 |'
- en: '| 1001 | 9 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 |'
- en: '| 1010 | 10 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 10 |'
- en: '| 1011 | 11 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 11 |'
- en: '| 1100 | 12 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | 12 |'
- en: '| 1101 | 13 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 13 |'
- en: '| 1110 | 14 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 14 |'
- en: '| 1111 | 15 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | 15 |'
- en: As you can see in [Table 1-1](ch01.xhtml#ch1tab1), we can represent 16 unique
    combinations of 0s and 1s in a 4-bit number, ranging in decimal value from 0 to
    15\. Seeing the list of combinations of bits helps to illustrate this, but we
    could have figured this out in a couple of ways without enumerating every possible
    combination.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表格1-1](ch01.xhtml#ch1tab1)所示，我们可以在4位二进制数中表示16种不同的0和1的组合，十进制值从0到15不等。看到这些位组合的列表有助于理解这一点，但我们也可以通过其他几种方法来推导出这个结论，而不必列举每一种可能的组合。
- en: We could determine the largest possible number that 4 bits can represent by
    setting all the bits to one, giving us 0b1111\. That is 15 in decimal; if we add
    1 to account for representing 0, then we come to our total of 16\. Another shortcut
    is to raise 2 to the number of bits, 4 in this case, which gives us 2⁴ = 2 × 2
    × 2 × 2 = 16 total combinations of 0s and 1s.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将所有位设置为1来确定4位可以表示的最大数字，这样得到0b1111。它的十进制值为15；如果我们加1来表示0，那么总共有16种组合。另一种简便的方法是将2的位数次方，4在这里，就是2⁴
    = 2 × 2 × 2 × 2 = 16种0和1的组合。
- en: Looking at 4 bits is a good start, but previously we were talking about bytes,
    which contain 8 bits. Using the preceding approach, we could list out all combinations
    of 0s and 1s, but let’s skip that step and go straight to a shortcut. Raise 2
    to the power of 8 and you get 256, so that’s the number of unique combinations
    of bits in a byte.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看4位二进制数是一个很好的开始，但我们之前谈的是字节，字节包含8位。使用前面的方式，我们可以列出所有0和1的组合，但我们跳过这一过程，直接进入一个简便的方法。将2的8次方计算出来，得到256，这就是一个字节中0和1的唯一组合数。
- en: Now we know that a 4-bit number allows for 16 combinations of 0s and 1s, and
    a byte allows for 256 combinations. What does that have to do with computing?
    Let’s say that a computer game has 12 levels; the game could easily store the
    current level number in only 4 bits. On the other hand, if the game has 99 levels,
    4 bits won’t be enough … only 16 levels could be represented! A byte, on the other
    hand, would handle that 99-level requirement just fine. Computer engineers sometimes
    need to consider how many bits or bytes will be needed for storage of data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，4位二进制数可以表示16种0和1的组合，而一个字节则可以表示256种组合。这与计算机有什么关系呢？假设一个电脑游戏有12个关卡；游戏只需要4个位来存储当前的关卡编号就可以了。另一方面，如果游戏有99个关卡，4位就不够用了……只能表示16个关卡！而一个字节则能够满足99个关卡的需求。计算机工程师有时需要考虑存储数据时需要多少位或字节。
- en: '**Prefixes**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**前缀**'
- en: Representing complex data types takes a large number of bits. Something as simple
    as the number 99 won’t require more than a byte; a video in a digital format,
    on the other hand, can require billions of bits. To more easily communicate the
    size of data, we use prefixes like giga- and mega-. The *International System
    of Units (SI)*, also known as the *metric system*, defines a set of standard prefixes.
    These prefixes are used to describe anything that can be quantified, not just
    bits. We’ll see them again in upcoming chapters dealing with electrical circuits.
    [Table 1-2](ch01.xhtml#ch1tab2) lists some of the common SI prefixes and their
    meanings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-2:** Common SI Prefixes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 10** | **English
    word** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| tera | T | 1,000,000,000,000 | 10^(12) | trillion |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| giga | G | 1,000,000,000 | 10⁹ | billion |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| mega | M | 1,000,000 | 10⁶ | million |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| kilo | k | 1,000 | 10³ | thousand |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| centi | c | 0.01 | 10^(-2) | hundredth |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| milli | m | 0.001 | 10^(-3) | thousandth |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| micro | μ | 0.000001 | 10^(-6) | millionth |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| nano | n | 0.000000001 | 10^(-9) | billionth |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| pico | p | 0.000000000001 | 10^(-12) | trillionth |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: With these prefixes, if we want to say “3 billion bytes,” we can use the shorthand
    3GB. Or if we want to represent 4 thousand bits, we can say 4kb. Note the uppercase
    B for byte and lowercase b for bit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find that this convention is commonly used to represent quantities of
    bits and bytes. Unfortunately, it’s also often technically incorrect. Here’s why:
    when dealing with bytes, most software is actually working in base 2, not base
    10\. If your computer tells you that a file is 1MB in size, it is actually 1,048,576
    bytes! That is approximately one million, but not quite. Seems like an odd number,
    doesn’t it? That’s because we are looking at it in decimal. In binary, that same
    number is expressed as 0b100000000000000000000\. It’s a power of two, specifically
    2^(20). [Table 1-3](ch01.xhtml#ch1tab3) shows how to interpret the SI prefixes
    when dealing with bytes.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-3:** SI Prefix Meaning When Applied to Bytes'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 2** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| tera | T | 1,099,511,627,776 | 2^(40) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| giga | G | 1,073,741,824 | 2^(30) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| mega | M | 1,048,576 | 2^(20) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| kilo | k | 1,024 | 2^(10) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: Another point of confusion with bits and bytes relates to network transfer rates.
    Internet service providers usually advertise in bits per second, base 10\. So,
    if you get 50 mega*bits* per second from your internet connection, that means
    you can only transfer about 6 mega*bytes* per second. That is, 50,000,000 bits
    per second divided by 8 bits per byte gives us 6,250,000 bytes per second. Divide
    6,250,000 by 2^(20) and we get about 6 megabytes per second.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**SI PREFIXES FOR BINARY DATA**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To address the confusion caused by multiple meanings of prefixes, a new set
    of prefixes was introduced in 2002 (in a standard called IEEE 1541) to be used
    for binary scenarios. When dealing with powers of 2, kibi- is to be used instead
    of kilo-, mebi- is to be used instead of mega-, and so on. These new prefixes
    correspond to base 2 values and are intended to be used in scenarios where the
    old prefixes were previously being used incorrectly. For example, since kilobyte
    might be interpreted as 1,000 or 1,024 bytes, this standard recommends that kibibyte
    be used to mean 1,024 bytes, while kilo- retains its original meaning so that
    a kilobyte is equal to 1,000 bytes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: This seems like a good idea, but at the time of this writing, these symbols
    haven’t been widely adopted. [Table 1-4](ch01.xhtml#ch1tab4) lists the new prefixes
    and their meanings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-4:** IEEE 1541-2002 Prefixes for Binary Data'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prefix name** | **Prefix symbol** | **Value** | **Base 2** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| tebi | Ti | 1,099,511,627,776 | 2^(40) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| gibi | Gi | 1,073,741,824 | 2^(30) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| mebi | Mi | 1,048,576 | 2^(20) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| kibi | Ki | 1,024 | 2^(10) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: This distinction is important because in practice, most software that displays
    the size of files uses the old SI prefix but calculates size using base 2\. In
    other words, if your device says a file’s size is 1KB, it means 1,024 bytes. On
    the other hand, manufacturers of storage devices tend to advertise the capacity
    of their devices using base 10\. This means that a hard drive that is advertised
    as 1TB probably holds 1 trillion bytes, but if you connect that device to a computer,
    the computer will show the size as about 931GB (1 trillion divided by 2^(30)).
    Given the lack of standard adoption of the new prefixes, in this book, I will
    continue to use the old SI prefixes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '### **Hexadecimal**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave the topic of thinking in binary, I’ll cover one more number
    system: hexadecimal. Quickly reviewing, our “normal” number system is decimal,
    or base 10\. Computers use binary, or base 2\. *Hexadecimal* is *base 16*! Given
    what you’ve already learned in this chapter, you probably know what that means.
    Hexadecimal, or just *hex* for short, is a place-value system where each place
    represents a power of 16, and each place can be one of 16 symbols.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'As in all place-value systems, the rightmost place will still be the ones place.
    The next place to the left will be the sixteens place, then the 256s (16 × 16)
    place, then the 4,096s (16 × 16 × 16) place, and so on. Simple enough. But what
    about the other requirement that each place can be one of 16 symbols? We usually
    have ten symbols to use to represent numbers, 0 through 9\. We need to add six
    more symbols to represent the other values. We could pick some random symbols
    like & @ #, but these symbols have no obvious order. Instead, the standard is
    to use A, B, C, D, E, and F (either uppercase or lowercase is fine!). In this
    scheme, A represents ten, B represents eleven, and so on, up to F, which represents
    fifteen. That makes sense; we need symbols that represent zero through one less
    than the base. So our extra symbols are A through F. It’s standard practice to
    use the prefix 0x to indicate hexadecimal, when needed for clarity. [Table 1-5](ch01.xhtml#ch1tab5)
    lists each of the 16 hexadecimal symbols, along with their decimal and binary
    equivalents.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-5:** Hexadecimal Symbols'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hexadecimal** | **Decimal** | **Binary (4-bit)** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0000 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0001 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 0010 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 0011 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | 0100 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 0101 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | 0110 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| 7 | 7 | 0111 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| 8 | 8 | 1000 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| 9 | 9 | 1001 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| A | 10 | 1010 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| B | 11 | 1011 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| C | 12 | 1100 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| D | 13 | 1101 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| E | 14 | 1110 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| F | 15 | 1111 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: What happens when you need to count higher than 15 decimal or 0xF? Just like
    in decimal, we add another place. After 0xF comes 0x10, which is 16 decimal. Then
    0x11, 0x12, 0x13, and so on. Now take a look at [Figure 1-4](ch01.xhtml#ch1fig4),
    where we see a larger hexadecimal number, 0x1A5.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig1-4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Hexadecimal number 0x1A5 broken out by place value*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 1-4](ch01.xhtml#ch1fig4) we have the number 0x1A5 in hexadecimal.
    What’s the value of this number in decimal? The rightmost place is worth 5\. The
    next place has a weight of 16, and there’s an A there, which is 10 in decimal,
    so the middle place is worth 16 × 10 = 160\. The leftmost place has a weight of
    256, and there’s a 1 in that place, so that place is worth 256\. The total value
    then is 5 + 160 + 256 = 421 in decimal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Just to reinforce the point, this example shows how the new symbols, like A,
    have a different value depending on the place in which they appear. 0xA is 10
    decimal, but 0xA0 is 160 in decimal, because the A appears in the sixteens place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: At this point you may be saying to yourself “great, but what use is this?” I’m
    glad you asked. Computers don’t use hexadecimal, and neither do most people. And
    yet, hexadecimal is very useful for people who need to work in binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Using hexadecimal helps overcome two common difficulties with working in binary.
    First, most people are terrible at reading long sequences of 0s and 1s. After
    a while the bits all run together. Dealing with 16 or more bits is tedious and
    error-prone for humans. The second problem is that although people are good at
    working in decimal, converting between decimal and binary isn’t easy. It’s tough
    for most people to look at a decimal number and quickly tell which bits would
    be 1 or 0 if that number were represented in binary. But with hexadecimal, conversions
    to binary are much more straightforward. [Table 1-6](ch01.xhtml#ch1tab6) provides
    a couple of examples of 16-bit binary numbers and their corresponding hexadecimal
    and decimal representations. Note that I’ve added spaces to the binary values
    for clarity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-6:** Examples of 16-bit Binary Numbers as Decimal and Hexadecimal'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Example 1** | **Example 2** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| **Binary** | 1111 0000 0000 1111 | 1000 1000 1000 0001 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| **Hexadecimal** | F00F | 8881 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| **Decimal** | 61,455 | 34,945 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: 'Consider Example 1 in [Table 1-6](ch01.xhtml#ch1tab6). In binary, there’s a
    clear sequence: the first four bits are 1, the next eight bits are 0, and the
    last four bits are 1\. In decimal, this sequence is obscured. It isn’t clear at
    all from looking at 61,455 which bits might be set to 0 or 1\. Hexadecimal, on
    the other hand, mirrors the sequence in binary. The first hex symbol is F (which
    is 1111 in binary), the next two hex symbols are 0, and the final hex symbol is
    F.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to Example 2, the first three sets of four bits are all 1000 and
    the final set of four bits is 0001\. That’s easy to see in binary, but rather
    hard to see in decimal. Hexadecimal provides a clearer picture, with the hexadecimal
    symbol of 8 corresponding to 1000 in binary and the hexadecimal symbol of 1 corresponding
    to, well, 1!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you are seeing a pattern emerge: every four bits in binary correspond
    to one symbol in hexadecimal. If you remember, four bits is half a byte (or a
    nibble). Therefore, a byte can be easily represented with two hexadecimal symbols.
    A 16-bit number can be represented with four hex symbols, a 32-bit number with
    eight hex symbols, and so on. Let’s take the 32-bit number in [Figure 1-5](ch01.xhtml#ch1fig5)
    as an example.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig1-5.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Each hexadecimal character maps to 4 bits*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 1-5](ch01.xhtml#ch1fig5) we can digest this rather long number one
    half-byte at a time, something that isn’t possible using a decimal representation
    of the same number (2,320,695,040).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s relatively easy to move between binary and hex, many engineers
    will often use the two in tandem, converting to decimal numbers only when necessary.
    I’ll use hexadecimal later in this book where it makes sense.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Try converting from binary to hexadecimal without going through the intermediate
    step of converting to decimal.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 1-4: BINARY TO HEXADECIMAL**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Convert these numbers, represented in binary, to their hexadecimal equivalents.
    Don’t convert to decimal if you can help it! The goal is to move directly from
    binary to hexadecimal.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = ______ (hexadecimal)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 11110000 (binary) = ______ (hexadecimal)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: You can check your answers in [Appendix A](appa.xhtml).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the hang of binary to hexadecimal, try going the other way, from
    hex to binary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 1-5: HEXADECIMAL TO BINARY**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Convert these numbers, represented in hexadecimal, to their binary equivalents.
    Don’t convert to decimal if you can help it! The goal is to move directly from
    hexadecimal to binary.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 1A (hexadecimal) = _____ (binary)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: C3A0 (hexadecimal) = ______ (binary)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You can check your answers in [Appendix A](appa.xhtml).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we covered some of the foundational concepts of computing.
    You learned that a computer is any electronic device that can be programmed to
    carry out a set of logical instructions. You then saw that modern computers are
    digital devices rather than analog devices, and you learned the difference between
    the two: analog systems are those that use widely varying values to represent
    data, whereas digital systems represent data as a sequence of symbols. After that,
    we explored how modern digital computers rely on only two symbols, 0 and 1, and
    learned about a number system consisting of only two symbols, base 2, or binary.
    We covered bits, bytes, and the standard SI prefixes (giga-, mega-, kilo-, and
    so on) you can use to more easily describe the size of data. Lastly, you learned
    how hexadecimal is useful for people who need to work in binary.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’ll look more closely at how binary is used in digital
    systems. We’ll take a look at how binary can be used to represent various types
    of data, and we’ll see how binary logic works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
