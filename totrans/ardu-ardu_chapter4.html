<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch4">
<span class="CN"><span aria-label=" Page 47. " epub:type="pagebreak" id="pg_47" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BUILDING WATCHDOG TIMERS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Projects that sit unattended for some time may lock up or stop working because of accidents, suboptimal design, or power issues. To solve these problems, you can use a <i>watchdog timer</i>, a small circuit that sits dormant while the project is operating normally but hard resets the microcontroller to a restart operation if it doesn’t receive a normal signal. These timers can help you build more advanced, professional, and reliable projects.</p>
<p class="TX">In this chapter, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Configure the 555 timer IC as an astable timer</li>
<li class="BL">Use the formulas to calculate 555 timer IC delay periods</li>
<li class="BL">Build your own watchdog timer using a PCB</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-32"/><span aria-label=" Page 48. " epub:type="pagebreak" id="pg_48" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Ensuring Constant and Reliable Operation</samp></h2>
<p class="TNI">As you gain microcontroller expertise, you may find yourself building projects or products operating without your constant attention over long periods of time. This could be a weather-monitoring system, a data-logging device, a hardware web host that allows remote reviews of current data, or some other device whose physical location is hard to access (buried in a basement or an attic).</p>
<p class="TX">When the final project is out of your hands, how can you ensure constant and reliable operation? Even when your hardware and sketch or code seems foolproof, unexpected situations can cause your Arduino to stop operating. A temporary power brownout could freeze the microcontroller (that is, halt the sketch). An unexpected temperature extreme could also cause issues. Or your sketch may have unanticipated bugs. For these reasons and more, you’ll need a watchdog.</p>
<p class="TX">In this section, I’ll explain the theory behind watchdog timers and then show you how to build your own watchdog timer circuit.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h2-6"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Watchdog Timer Theory</samp></h3>
<p class="TNI">A watchdog timer circuit is an external timer connected to the RESET pin on the Arduino board. The watchdog circuit begins with a HIGH signal set to change to LOW after a predetermined length of time, which will cause the Arduino to reset and start again. However, the Arduino can prevent this reset by sending a regular signal, or <i>heartbeat</i>, via a digital output pin connected to the watchdog circuit. The heartbeat resets the timer circuit before the watchdog timer can reset the Arduino.</p>
<p class="TX">Consider the timing diagram in <a href="chapter4.xhtml#fig4-1">Figure 4-1</a>.</p>
<figure class="IMG"><img alt="A TIMING DIAGRAM EXPLAINING THE ARDUINO HEARTBEAT CAUSING RESET BY THE WATCHDOG TIMER CIRCUIT" class="img1" id="fig4-1" src="../images/fig4-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A timing diagram of a watchdog timer output and Arduino heartbeat output</samp></p></figcaption>
</figure>
<p class="TX">The top signal is the output from a watchdog timer, continually oscillating between HIGH and LOW. The period for the HIGH signal is much longer than that for LOW. The watchdog output is connected to the Arduino’s RESET pin. When the watchdog timer resets, the output starts at HIGH, meaning the Arduino must keep resetting the watchdog timer to stop the watchdog timer resetting the Arduino.</p>
<p class="TX">To enable this, an Arduino digital output pin connected to the watchdog timer sends a quick pulse (HIGH and then LOW) to the timer <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, resetting the timer and stopping the timer output from going LOW. If the <span aria-label=" Page 49. " epub:type="pagebreak" id="pg_49" role="doc-pagebreak"/>Arduino has a problem and stops pulsing the heartbeat signal to the watchdog timer <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, the watchdog timer oscillations continue and its signal will go LOW <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, resetting the Arduino. After this reset, the Arduino should recover and begin sending out the heartbeat signal again <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">The watchdog timer is a hardware-based solution, making it less error-prone than a software-based function. If the reset doesn’t get the Arduino going again, there’s a major fault in the project that will require you to physically examine the hardware or code.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h2-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Watchdog Timer Circuit Configuration</samp></h3>
<p class="TNI">The heart of the watchdog timer circuit is the 555 timer IC shown in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>. This compact part contains a customizable timing circuit you can use in several ways.</p>
<figure class="IMG"><img alt="A PHOTO OF A TEXAS INSTRUMENTS 555 TIMER IC" class="img3" id="fig4-2" src="../images/fig4-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A 555 timer IC</samp></p></figcaption>
</figure>
<p class="TX">To use the 555 as a watchdog timer, you’ll configure it as an <i>astable timer</i>, one that generates a continuous signal output with a longer HIGH than LOW, as shown in <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>.</p>
<figure class="IMG"><img alt="A BASIC SCHEMATIC FOR A555 ASTABLE TIMER CIRCUIT" class="img8" id="fig4-3" src="../images/fig4-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: A basic astable timer circuit</samp></p></figcaption>
</figure>
<p class="TX">The astable timer circuit is fairly simple. Inside the 555 are a voltage comparator circuit and a flip-flop, which changes state between LOW and HIGH to drive the output pin. When power is applied, the voltage at pin 2 (the trigger pin) is less than one-third V<sub>CC</sub>, meaning the flip-flop switches to set the 555 output to HIGH. C then charges via R<sub>A</sub> and R<sub>B</sub>.</p>
<p class="TX">After a period with output at HIGH, the voltage at pin 6 (the threshold pin) goes above two-thirds V<sub>CC</sub>. The flip-flop switches to set the 555 output to LOW. This also enables the discharge function so that C discharges via R<sub>B</sub>.</p>
<p class="TX"><span aria-label=" Page 50. " epub:type="pagebreak" id="pg_50" role="doc-pagebreak"/>After a period with the output at LOW, the voltage at pin 2 is less than one-third V<sub>CC</sub>, so the flip-flop switches to set the 555 output to HIGH … and the cycle repeats. The output is sourced from pin 3, which operates as an open collector—that is, when LOW, it can sink current to GND.</p>
<p class="TX">The duty cycle of the output signal and the HIGH and LOW periods are determined by the values of resistors R<sub>1</sub> and R<sub>2</sub> and the capacitor C. The R<sub>L</sub> parts are the loads, or the circuitry controlled by the output. Current can flow from V<sub>CC</sub> through the higher R<sub>L</sub> when the output is off, and from the output through the lower R<sub>L</sub> to GND when the output is on. Up to 200 mA of current can flow in or out of the 555’s output pin.</p>
<p class="TX">To determine the HIGH and LOW period times for the output—and if you are curious, the frequency of the output signal (which we don’t use but might as well set!)—we use the following three formulas:</p>
<figure class="IMG1"><img alt="" class="img1" src="../images/pg50-1.png"/></figure>
<p class="TX">T<sub>low</sub> is the length of time the astable output from the 555 timer is LOW, and T<sub>high</sub> is the length of time the output is HIGH. For example, with a value of 100 kΩ for R<sub>1</sub>, a value of 4.7 kΩ for R<sub>2</sub>, and a capacitor C of 100 uF, the calculations are as follows:</p>
<p class="Equation">T<sub>high</sub> = 0.693 (4,700) 0.0001 = 7.255 s</p>
<p class="Equation">T<sub>low</sub> = 0.693 (100,000 + 4,700) 0.0001 = 0.3257 s</p>
<p class="TX">A spreadsheet with these formulas is available in the sketch download from <a href="https://nostarch.com/arduino-arduinians"><i>https://<wbr/>nostarch<wbr/>.com<wbr/>/arduino<wbr/>-arduinians</i></a>. Use these formulas to easily calculate the values of resistors and the capacitor needed for your required HIGH and LOW times. The value of R<sub>2</sub> generally remains constant, as R<sub>1</sub> has more effect on the final values.</p>
<p class="TX">When building a 555 timer circuit, use 1 percent tolerance resistors. Larger capacitors can have a very large tolerance, especially during temperature fluctuations—sometimes up to +/<span class="symbol">−</span>20 percent—so try to keep the capacitor value as small as possible.</p>
<p class="TX">Now that you know how to operate a 555 timer, let’s build a watchdog timer circuit for our Arduino.</p>
<p class="HeadProject"><span id="h1-33"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #14: Building a Watchdog Timer</samp></p>
<p class="TNI">In this project, you’ll build a convenient and adjustable watchdog timer for your Arduino Uno or other microcontroller that utilizes the type of reset circuit discussed. You can build the circuit on a solderless breadboard for a more temporary setup or download the PCB files for this project and have your own PCB manufactured to create a permanent watchdog timer.</p>
<p class="TX"><span aria-label=" Page 51. " epub:type="pagebreak" id="pg_51" role="doc-pagebreak"/>You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">The Project #14 PCB or solderless breadboard</li>
<li class="BL">An NE555 timer IC (not the CMOS 7555 version!)</li>
<li class="BL">An eight-pin IC socket</li>
<li class="BL">A 1N4001 diode</li>
<li class="BL">A 5 mm LED</li>
<li class="BL">1 <span class="symbol">×</span> 40 2.54 mm inline header pins (if using PCB)</li>
<li class="BL">Various jumper wires</li>
<li class="BL">A 2N7000 N-MOSFET</li>
<li class="BL">Two 1 k<span class="greek"><span lang="el" xml:lang="el">Ω</span></span>, 0.25 W, 1 percent resistors</li>
<li class="BL">A 10 kΩ, 0.25 W, 1 percent resistor</li>
<li class="BL">A 100 Ω, 0.25 W, 1 percent resistor</li>
<li class="BL">Other resistors (see the following section)</li>
<li class="BL">A 0.01 µF ceramic capacitor</li>
<li class="BL">A 0.1 µF ceramic capacitor</li>
<li class="BL">A 100 µF, 16 V electrolytic capacitor</li>
</ul>
<p class="TX"><a href="chapter4.xhtml#fig4-4">Figure 4-4</a> shows the schematic for this project.</p>
<figure class="IMG"><img alt="SCHEMATIC FOR PROJECT #14" class="img1" id="fig4-4" src="../images/fig4-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The schematic for Project #14</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 52. " epub:type="pagebreak" id="pg_52" role="doc-pagebreak"/>Before assembling the circuit, determine which values to use for R<sub>1</sub> and R<sub>2</sub> to control the length of the HIGH and LOW periods of the output, using the formulas provided in the previous section. The results will differ depending on whether you’re using a PCB or solderless breadboard, as the contacts inside a breadboard also have their own resistance value.</p>
<p class="TX">For those of you building with a PCB, the schematic shows three resistors for R<sub>e</sub>: R<sub>1A</sub>, R<sub>1B</sub>, and R<sub>1C</sub>. I have left space for up to three resistors to be used as a combined value for R<sub>1</sub> so that you can change resistor values if required by adding new resistors in the R<sub>1B</sub> or R<sub>1C</sub> spaces and cutting out the unwanted values. Alternately, you may need to use two or three resistors in parallel to get your exact required value.</p>
<p class="TX">To calculate the value of resistors in parallel, use the following:</p>
<p class="Equation">R<sub>T</sub> = 1 / (1 / R<sub>1A</sub> + 1 / R<sub>1B</sub> + 1 / R<sub>1C</sub> + …)</p>
<p class="BodyContinued">If you just need to use one resistor for R<sub>1</sub>, insert it into the R<sub>1A</sub> space on the PCB.</p>
<p class="TX">If you’re not sure what values to use for this project, a good default option is to use around 100 kΩ for R<sub>1</sub> and 4.7 kΩ for R<sub>2</sub>. This will create a HIGH delay of just over 57 seconds, close to a minute. With this delay, your Arduino must reset the timer more often than once every 7 seconds to avoid being reset by the timer itself.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h2-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The 555 Circuit’s Inner Workings</samp></h3>
<p class="TNI">Let’s take a closer look at the 555 circuit’s inner workings. When you apply power to the circuit, the 555 should start operating as described earlier, with the output signal connected to the Arduino’s RESET pin and starting as HIGH. The Arduino should operate as normal. Diode D<sub>1</sub>, connected between the 555’s output pin and the Arduino RESET pin, ensures no stray signals can reset the Arduino.</p>
<p class="TX">Over time, as determined by your R<sub>1</sub> values, capacitor C<sub>1</sub> should start charging via the 555’s trigger pin. When the Arduino sends a HIGH signal via the heartbeat pin, it should turn on the N-MOSFET Q<sub>1</sub>. Doing so not only blinks LED D<sub>3</sub> (a visual indication of the Arduino heartbeat signal) but also shorts the capacitor C<sub>1</sub> to GND via R<sub>6</sub>, emptying the capacitor. The capacitor C<sub>1</sub> then starts charging again, resetting the amount of time before the 555 can reset the Arduino.</p>
<p class="TX">If the Arduino keeps sending heartbeat pulses, the 555 timer never has a chance to change the output state to LOW and reset the Arduino, as discussed. However, if the Arduino stops sending heartbeat signals, capacitor C<sub>1</sub> will continue to charge until the 555’s threshold pin voltage reaches two-thirds of 5 V. At that point, the 555’s output changes state to LOW for a short period (determined by R<sub>2</sub>). This resets the Arduino and blinks LED <span aria-label=" Page 53. " epub:type="pagebreak" id="pg_53" role="doc-pagebreak"/>D<sub>2</sub> (a visual indication that the reset circuit has been activated). When the 555’s output pin is LOW, current can flow from 5V, through R<sub>3</sub> and the LED, and into the 555 output pin. When the output pin is LOW, current can flow into the pin, as opposed to current flowing out from the output pin when it is HIGH. The output then changes back to HIGH, and the process starts again.</p>
<p class="TX">Resistors R<sub>3</sub> and R<sub>4</sub> limit current to the LEDs, while resistor R<sub>5</sub> pulls down the N-MOSFET until activated, avoiding unplanned activation. Resistor R<sub>6</sub> protects C<sub>1</sub> while the capacitor is discharging, avoiding a dead short when a heartbeat signal is received. C<sub>2</sub> smooths the power supply over the circuit. Finally, the 555 requires C<sub>3</sub> for normal operation.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h2-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Circuit Assembly</samp></h3>
<p class="TNI">Assemble the project using the PCB shown in <a href="chapter4.xhtml#fig4-5">Figure 4-5</a> as usual: start with the lowest-profile parts, such as the resistors, and then work your way to the tallest parts (the capacitors and inline header pins).</p>
<figure class="IMG"><img alt="A PHOTO OF AN UNPOPULATED PRINTER CIRCUIT BOARD FOR PROJECT #14" class="img8" id="fig4-5" src="../images/fig4-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: The PCB for Project #14</samp></p></figcaption>
</figure>
<p class="TX">Don’t forget to use an IC socket for the 555 and match the notch at the end of the IC with the notch on the PCB. You may need to trim your inline header pins to get one strip of four pins.</p>
<p class="TX">Once assembled, your watchdog timer should resemble the one shown in <a href="chapter4.xhtml#fig4-6">Figure 4-6</a>.<span aria-label=" Page 54. " epub:type="pagebreak" id="pg_54" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE COMPLETED PRINTED CIRCUIT BOARD FOR PROJECT #14" class="img8" id="fig4-6" src="../images/fig4-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: The completed watchdog timer board</samp></p></figcaption>
</figure>
<p class="TX">Connect the 5V, RESET, and GND pins to the matching Arduino pins and connect the heartbeat pin to an unused digital pin on your Arduino. To make your sketch send a pulse at a frequency faster than the operation of the watchdog timer, consider the following example of using the watchdog timer. Upload the sketch after connecting the watchdog timer to your Arduino.</p>
<span id="pro-14"/>

<pre><code>// Project #14 - Watchdog timer

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define heartBeatPin 5

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void heartBeat()
{
    digitalWrite(heartBeatPin, HIGH);
    delay(100);
    digitalWrite(heartBeatPin, LOW);
}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void setup()
{
    pinMode(heartBeatPin, OUTPUT);
    heartBeat(); // Send heartbeat signal to watchdog timer
}

void loop()
{
    // Do things
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> heartBeat(); // Send heartbeat signal to watchdog timer
}
</code></pre>

<p class="TX">This sketch defines digital pin 5 as the heartbeat connection to the watchdog timer circuit <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">heartBeat()</samp> function generates the heartbeat pulse <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which simply flips the pin on and off for a moment—long enough <span aria-label=" Page 55. " epub:type="pagebreak" id="pg_55" role="doc-pagebreak"/>to reset the watchdog timer circuit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> sends the heartbeat to reset the watchdog as soon as possible after the Arduino is reset or powered up. Finally, the main loop <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> sends the heartbeat regularly.</p>
<p class="TX">Placing the <samp class="SANS_TheSansMonoCd_W5Regular_11">heartbeat()</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> is an ideal spot, assuming the time taken by a single run of the code in the loop is less than the timeout period of the watchdog. You can always insert more calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">heartBeat()</samp> in your other functions as well if you want to increase the number of watchdog-initiated resets of your project.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter covered why you’d want to use a watchdog timer, along with the theory of operating and building your own circuit. You learned how to use the watchdog timer method in order to maintain the reliability of future Arduino-based projects, as well as how to use other microcontrollers such as the ATtiny or with other electronic devices that have an output and reset on LOW input.</p>
<p class="TX">In the next chapter, you’ll learn to control multiple LEDs with a minimal number of digital output pins.</p>
</section>
</section>
</body>
</html>