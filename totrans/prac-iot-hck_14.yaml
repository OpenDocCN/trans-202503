- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Short Range Radio: Abusing RFID'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: IoT devices don’t always need a continuous wireless transmission across long
    distances. Manufacturers often use *short-range radio* technologies to connect
    devices equipped with cheap, low-powered transmitters. These technologies allow
    devices to exchange low volumes of data at longer intervals, and as a result,
    they’re well suited for IoT devices that want to save power when they’re not transmitting
    any data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we examine the most popular short-range radio solution, *Radio
    Frequency Identification (RFID)*. It’s often used in smart door locks and key
    card tags for user identification. You’ll learn to clone tags using a variety
    of methods, break the tags’ cryptographic keys, and change the information stored
    in the tags. Successfully utilizing these techniques could allow attackers to
    gain illicit access to a facility, for example. Then you’ll write a simple fuzzer
    to discover unknown vulnerabilities in RFID readers.
  prefs: []
  type: TYPE_NORMAL
- en: How RFID Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RFID was designed to replace barcode technology. It works by transmitting encoded
    data through radio waves; then it uses this data to identify a tagged entity.
    This entity might be a human, such as an employee who wants to access a company
    building; pets; automobiles passing through toll booths; or even simple goods.
  prefs: []
  type: TYPE_NORMAL
- en: RFID systems come in a broad range of shapes, supported ranges, and sizes, but
    we can usually identify the main components shown in [Figure 10-1](#figure10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](Images/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: Common RFID system components'
  prefs: []
  type: TYPE_NORMAL
- en: The RFID tag’s memory contains information that identifies an entity. The reader
    can read the tag’s information using a scanning antenna, which is usually externally
    connected and typically generates the constant electromagnetic field required
    for this wireless connection. When the tag’s antenna is within range of the reader’s,
    the reader’s electromagnetic field sends an electric current to power up the RFID
    tag. The tag can then receive commands from the RFID reader and send responses
    containing the identification data.
  prefs: []
  type: TYPE_NORMAL
- en: Several organizations have created standards and regulations that dictate the
    radio frequency, protocols, and procedures used to share information using RFID
    technologies. The following sections provide an overview of these variations,
    the security principles on which they’re based, and a testing methodology for
    RFID-enabled IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: Radio Frequency Bands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RFID relies on a group of technologies that operate in specific radio frequency
    bands, as listed in [Table 10-1](#table10-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-1: RFID Bands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Frequency band** | **Signal range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Very low frequency (VLF) | (3 kHz–30 kHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Low frequency (LF) | (30 kHz–300 kHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Medium frequency (MF) | (300 kHz–3,000 kHz) |'
  prefs: []
  type: TYPE_TB
- en: '| High frequency (HF) | (3,000 kHz–30 MHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Very high frequency (VHF) | (30 MHz–300 MHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Ultra high frequency (UHF) | (300 MHz–3,000 MHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Super high frequency (SHF) | (3,000 MHz–30 GHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Extremely high frequency (EHF) | (30 GHz–300 GHz) |'
  prefs: []
  type: TYPE_TB
- en: '| Uncategorized | (300 GHz–3,000 GHz) |'
  prefs: []
  type: TYPE_TB
- en: Each of these RFID technologies follows a specific protocol. The best technology
    to use for a system depends on factors such as the signal’s range, data transfer
    rate, accuracy, and implementation cost.
  prefs: []
  type: TYPE_NORMAL
- en: Passive and Active RFID Technologies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An RFID tag can rely on its own power source, such as an embedded battery, or
    receive its power from the reading antenna using the current induced from the
    received radio waves. We characterize these as *active* or *passive* technologies,
    as shown in [Figure 10-2](#figure10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10002](Images/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Passive and active technologies along the radio frequency spectrum'
  prefs: []
  type: TYPE_NORMAL
- en: Because active devices don’t need external power to start a communication process,
    they operate on higher frequencies and can continuously broadcast their signal.
    They can also support connections over longer ranges, so they’re often used as
    tracking beacons. Passive devices operate on the three lower frequencies of the
    RFID spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: Some special devices are *semi-passive*; they contain integrated power sources
    capable of powering the RFID tag microchip at all times without requiring power
    from the reader’s signal. For this reason, the devices respond faster and in a
    greater reading range than passive ones.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to identify the differences between the existing RFID technologies
    is to look at their radio waves. Low-frequency devices use long-range waves, whereas
    high-frequency devices use short-range waves ([Figure 10-3](#figure10-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10003](Images/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Wave forms depending on the frequency'
  prefs: []
  type: TYPE_NORMAL
- en: These RFID implementations also use antennas with very different dimensions
    and wire turns, as shown in [Table 10-2](#table10-2). The shape of each antenna
    provides the best range and data transfer rate for each wavelength used.
  prefs: []
  type: TYPE_NORMAL
- en: The Structure of RFID Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand existing cybersecurity threats in RFID tags, you need to understand
    the inner workings of these devices. Commercial tags usually comply with the ISO/IEC
    18000 and EPCglobal international standards, which define a series of diverse
    RFID technologies, each using a unique frequency range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-2: Antennas for Different Frequency Implementations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Low frequency** | **High frequency** | **Ultra high frequency** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![g10001](Images/g10001.png) | ![g10002](Images/g10002.png) | ![g10003](Images/g10003.png)
    |'
  prefs: []
  type: TYPE_TB
- en: Tag Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: EPCglobal divides RFID tags into six categories. A tag in each category has
    all the capabilities listed in the previous category, making it backward compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '*Class 0 tags* are passive tags that operate in UHF bands. The vendor preprograms
    them at the production factory. As a result, you can’t change the information
    stored in their memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Class 1 tags* can also operate in HF bands. In addition, they can be written
    only once after production. Many Class 1 tags can also process *cyclic redundancy
    checks (CRCs)* of the commands they receive. CRCs are a few extra bytes at the
    end of the commands for error detection.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Class 2 tags* can be written multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Class 3 tags* can contain embedded sensors that can record environmental parameters,
    such as the current temperature or the tag’s motion. These tags are semi-passive,
    because although they have an embedded power source, such as an integrated battery,
    they can’t initiate wireless communication with other tags or readers.'
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, *Class 4 tags* can initiate communication with other tags of
    the same class, making them active tags.
  prefs: []
  type: TYPE_NORMAL
- en: The most advanced tags are the *Class 5 tags*, which can provide power to other
    tags and communicate with all the previous tag classes. Class 5 tags can act as
    RFID readers.
  prefs: []
  type: TYPE_NORMAL
- en: Information Stored in RFID Tags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An RFID tag’s memory usually stores four kinds of data: (a) the *identification
    data*, which identifies the entity to which the tag is attached; (b) the *supplementary
    data,* which provides further details regarding the entity; (c) the *control data*,
    used for the tag’s internal configuration; and (d) the tag’s *manufacturer data*,
    which contains a tag’s *Unique Identifier (UID)* and details regarding the tag’s
    production, type, and vendor. You’ll find the first two kinds of data in all the
    commercial tags; the last two can differ based on the tag’s vendor.'
  prefs: []
  type: TYPE_NORMAL
- en: The identification data includes user-defined fields, such as bank accounts,
    product barcodes, and prices. It also includes a number of registers specified
    by the standards to which the tags adhere. For example, the ISO standard specifies
    the *Application Family Identifier (AFI)* value, a code that indicates the kind
    of object the tag belongs to. A tag for traveling baggage would use a different
    predefined AFI than a tag for a library book. Another important register, also
    specified by ISO, is the *Data Storage Format Identifier**(DSFID)*, which defines
    the logical organization of the user data.
  prefs: []
  type: TYPE_NORMAL
- en: The supplementary data can handle other details defined by the standards, such
    as Application Identifiers (AIs), ANSI MH-10 Data Identifiers (DIs), and ATA Text
    Element Identifiers (TEIs), which we won’t discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: RFID tags also support different kinds of security controls, depending on the
    tag vendor. Most have mechanisms that restrict the read or write operations on
    each user memory block and on the special registers containing the AFI and DSFID
    values. These lock mechanisms use data stored in the control memory and have default
    passwords preconfigured by the vendor but allow the tag owners to configure custom
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Low-Frequency RFID Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Low-frequency RFID devices include key cards that employees use to open doors,
    small glass tube tags implanted into pets, and temperature-resistant RFID tags
    for laundry, industrial, and logistics applications. These devices rely on passive
    RFID technology and operate in a range of 30 kHz to 300 kHz, although most of
    the devices that people use daily to track, access, or validate a task operate
    in the narrower range of 125 kHz to 134 kHz. The low-frequency tags have low memory
    capacities, a slow data transfer rate, and water and dust resistance, unlike the
    high frequency technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we use low-frequency tags for access control purposes. The reason is
    that their low memory capacity can handle only small amounts of data, such as
    IDs used to authenticate. One of the most sophisticated tags, HID Global’s ProxCard
    ([Figure 10-4](#figure10-4)), uses a small number of bytes to support unique IDs
    that a tag management system can use for user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10004](Images/f10004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: The HID ProxCard II, a popular low-frequency RFID tag'
  prefs: []
  type: TYPE_NORMAL
- en: Other companies, such as NXP with its Hitag2 tags and readers, introduced further
    security controls; for example, a mutual authentication protocol that uses a shared
    key to protect communications between the tag and reader. This technology is very
    popular in vehicle immobilization applications.
  prefs: []
  type: TYPE_NORMAL
- en: High-Frequency RFID Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find high-frequency RFID implemented globally in applications like payment
    systems, making it a game changer in the contactless world. Many people refer
    to this technology as *Near Field Communication (NFC)*, a term for devices operating
    over the 13.56 MHz frequency. Some of the most important NFC technologies are
    the MIFARE cards and the NFC microcontrollers integrated into mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular high-frequency tag vendors is NXP, which controls approximately
    85 percent of the contactless market. Mobile devices use many of its NFC chips.
    For example, the new versions of the iPhone XS and XS Max implement the NXP 100VB27
    controller. This allows the iPhones to communicate with other NFC transponders
    and perform tasks such as contactless payments. Additionally, NXP has some low-cost
    and well-documented microcontrollers, such as the PN532, used for research and
    development purposes. The PN532 supports reading and writing, peer-to-peer communication,
    and emulation modes.
  prefs: []
  type: TYPE_NORMAL
- en: NXP also designs the MIFARE cards, which are contactless smart cards based on
    ISO/IEC 14443\. The MIFARE brand has different families, such as MIFARE Classic,
    MIFARE Plus, MIFARE Ultralight, MIFARE DESFire, and MIFARE SAM. According to NXP,
    these cards implement AES and DES/Triple-DES encryption methods, whereas some
    versions, such as MIFARE Classic, MIFARE SAM, and MIFARE Plus, also support its
    proprietary encryption algorithm Crypto-1.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking RFID Systems with Proxmark3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll walk through a number of attacks against RFID tags. We’ll
    clone the tags, allowing you to impersonate a legitimate person or object. We’ll
    also circumvent the cards’ protections to tamper with their stored memory contents.
    In addition, we’ll build a simple fuzzer that you can use against devices with
    RFID reading capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As a card reader, we’ll use Proxmark3, a general-purpose RFID tool with a powerful
    field-programmable gate array (FPGA) microcontroller capable of reading and emulating
    low-frequency and high-frequency tags ([https://github.com/Proxmark/proxmark3/wiki](https://github.com/Proxmark/proxmark3/wiki)).
    Proxmark3 currently costs less than $300\. You can also use the Proxmark3 EVO
    and Proxmark3 RDV 4 versions of the tool. To read tags with Proxmark3, you’ll
    need antennas designed for the frequency band of the specific card you’re reading
    (reference [Table 10-2](#table10-2) for images of the antenna types). You can
    obtain these antennas from the same distributors that offer the Proxmark3 device.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also show you how to use free apps to transform any NFC-enabled Android
    device into a card reader for MIFARE cards.
  prefs: []
  type: TYPE_NORMAL
- en: To perform these tests, we’ll use an HID ProxCard, as well as a number of unprogrammed
    T55x7 tags and NXP MIFARE Classic 1KB cards, which cost less than $2 each.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Proxmark3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use Proxmark3, you’ll first have to install a number of required packages
    on your computer. Here’s how to do so using `apt` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `git` command to download the source code from the Proxmark3
    remote repository. Then navigate to its folder and run the `make` command to build
    the required binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re ready to plug the Proxmark3 into your computer using a USB cable.
    Once you’ve done so, identify the serial port to which the device is connected
    using the `dmesg` command, available in Kali Linux. You can use this command to
    get information about the hardware on a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Based on the output, we know the device is connected on the */dev/ttyACM0* serial
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Proxmark3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because Proxmark3’s source code changes frequently, we recommend that you update
    the device before using it. The device software consists of the operating system,
    the bootloader image, and the FPGA image. The bootloader executes the operating
    system, whereas the FPGA image is the code that executes in the device’s embedded
    FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest bootloader version is in the *bootrom.elf* file in the source code
    folders. To install it, hold down the Proxmark3’s button while the device is connected
    to your computer until you see a red and yellow light on the device. Then, while
    holding the button, use the *flasher* binary in the source code folder to install
    the image. As parameters, pass it Proxmark3’s serial interface and the `-b`parameter
    to define the bootloader’s image path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the latest versions of the operating system and FPGA image in
    the same file, named *fullimage.elf*, in the source code folders. If you’re using
    Kali Linux, you should also stop and disable the ModemManager. The ModemManager
    is the daemon that controls mobile broadband devices and connections in many Linux
    distributions; it can interfere with connected devices, such as Proxmark3\. To
    stop and disable this service, use the `systemectl`command, which is preinstalled
    in Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can use the Flasher tool to complete the flash again, this time without
    the `-b`parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Proxmark3 RVD 4.0 also supports a command to automate the full process
    of updating the bootloader, the operating system, and the FPGA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out if the update succeeded, execute the `Proxmark3` binary, which
    is located in the *client* folder, and pass it the device’s serial interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The command should output the device’s attributes, such as the embedded processor
    type, the memory size, and the architecture identifier, followed by the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Low- and High-Frequency Cards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s identify specific kinds of RFID cards. The Proxmark3 software comes
    with a preloaded list of known RFID tags for different vendors, and it supports
    vendor-specific commands that you can use to control these tags.
  prefs: []
  type: TYPE_NORMAL
- en: Before using the Proxmark3, connect it to an antenna that matches the card type.
    If you’re using the newer Proxmark3 RVD 4.0 model, the antennas will look slightly
    different because they’re more compact. Consult the vendor’s documentation to
    select the right one for each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxmark3 commands all begin with either the `lf` parameter, for interacting
    with the low-frequency cards, or the `hf` parameter, for interacting with the
    high-frequency cards. To identify nearby known tags, use the `search` parameter.
    In the following example, we use Proxmark3 to identify a Hitag2 low-frequency
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next command identifies an NXP ICode SLIX high-frequency tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the tag vendor, the command’s output might also include the manufacturer,
    microchip identification number, or known tag-specific vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Low-Frequency Tag Cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s clone a tag, starting with a low-frequency one. The low-frequency cards
    available on the market include HID ProxCard, Cotag, Awid, Indala, and Hitag,
    among others, but HID ProxCards are the most common. In this section, we’ll clone
    it using Proxmark3 and then create a new tag containing the same data. You could
    use this tag to impersonate the legitimate tagged entity, such as an employee,
    and unlock the corporate building’s smart door lock.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, use the low-frequency search command to identify cards that are in
    Proxmark3’s range. If the card in range is an HID, the output will typically look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, examine the supported vendor-specific tag commands for HID devices by
    providing `hid` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to read the tag data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The command should return the HID tag’s exact ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone this tag with the Proxmark3, use a blank or previously unprogrammed
    T55x7 card. These cards are normally compatible with EM4100, HID, and Indala technologies.
    Position the T55x7 card over the low-frequency antenna and execute the following
    command, passing it the ID of the tag you want to clone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now you could use the T55x7 card as though it were the original card.
  prefs: []
  type: TYPE_NORMAL
- en: High-Frequency Tag Cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although high-frequency technologies implement better security than low-frequency
    ones, inadequate or old implementations could be vulnerable to attacks. For example,
    the MIFARE Classic cards are among the most vulnerable high-frequency cards, because
    they use default keys and an insecure proprietary cryptographic mechanism. In
    this section, we’ll walk through the process of cloning a MIFARE Classic card.
  prefs: []
  type: TYPE_NORMAL
- en: MIFARE Classic Memory Allocation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand what MIFARE Classic’s possible attack vectors are, let’s analyze
    the memory allocation in the simplest MIFARE card: the MIFARE Classic 1KB ([Figure
    10-5](#figure10-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f10005](Images/f10005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: MIFARE Classic memory map'
  prefs: []
  type: TYPE_NORMAL
- en: The MIFARE Classic 1KB card has 16 sectors. Each sector occupies four blocks,
    and each block contains 16 bytes. The manufacturer saves the card’s UID in Sector
    0 of Block 0, which you can’t alter.
  prefs: []
  type: TYPE_NORMAL
- en: To access each sector, you’ll need two keys, A and B. The keys can be different,
    but many implementations use default keys (`FFFFFFFFFFFF` is a common one). These
    keys get stored in Block 3 of each sector, called the *sector trailer*. The sector
    trailer also stores the *access bits*, which establish the read and write permissions
    on each block using the two keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why having two keys is useful, let’s consider an example: the
    cards we use to ride a subway system. These cards might allow an RFID reader to
    readall data blocks with either key A or B but write to them only with key B.
    As a result, the RFID reader at the turnstile, which has only key A, can read
    the card’s data, unlock the turnstile for users with sufficient balance, and decrement
    their balance. But you’d need a special terminal equipped with key B to write,
    or increment, the users’ balance. The station cashier might be the only person
    who can operate this terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: The access bits are located between the two key types. If a company misconfigures
    these bits—for example, by unintentionally granting write permissions—adversaries
    could tamper with the sector’s block data. [Table 10-3](#table10-3) lists the
    possible access control permissions that you could define using these access bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-3: MIFARE Access Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access bits** | **Valid access control permissions** | **Block** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| C1[3,] C2[3,] C3[3,] | Read, write | 3 | Sector trailer |'
  prefs: []
  type: TYPE_TB
- en: '| C1[2,] C2[2,] C3[2] | Read, write, increment, decrement, transfer, restore
    | 2 | Data block |'
  prefs: []
  type: TYPE_TB
- en: '| C1[1,] C2[1,] C3[1] | Read, write, increment, decrement, transfer, restore
    | 1 | Data block |'
  prefs: []
  type: TYPE_TB
- en: '| C1[0,] C2[0,] C3[0,] | Read, write, increment, decrement, transfer, restore
    | 0 | Data block |'
  prefs: []
  type: TYPE_TB
- en: You could use various methods to exploit the MIFARE Classic cards. You might
    use special hardware, such as the Proxmark3 or an Arduino with a PN532 board.
    Even less sophisticated hardware, as simple as an Android phone, might be enough
    to copy, clone, and replay a MIFARE Classic card, but many hardware researchers
    prefer the Proxmark3 to other solutions because of its preloaded commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the attacks you could perform against the MIFARE Classic card, use
    the `hf mf`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most of the listed commands implement brute-force attacks against the authentication
    protocol used (such as the `chk` and `fchk` commands) or attacks for known vulnerabilities
    (such as the `nack`, `darkside`, and `hardnested` commands). We’ll use the `darkside`
    command in Chapter 15.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking the Keys with a Brute-Force Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To read the MIFARE card’s memory blocks, you need to find the keys for each
    of the 16 sectors. The simplest way to do this is to perform a brute-force attack
    and attempt to authenticate using a list of default keys. Proxmark3 has a special
    command for this attack, called `chk` (an abbreviation of the word check). This
    command uses a list of known passwords to try to read the card.
  prefs: []
  type: TYPE_NORMAL
- en: To perform this attack, first select the commands in the high-frequency band
    using the `hf` parameter, followed by the `mf` parameter, which will show you
    the commands for MIFARE cards. Then add the `chk` parameter to select the brute-force
    attack. You must also provide the number of blocks that you’re targeting. This
    can be a parameter between `0x00` and `0xFF`, or it can be the *** character,
    which selects all the blocks, followed by a number that specifies the tag’s memory
    size (`0` = 320 bytes, `1` = 1KB, `2` = 2KB, and `4` = 4KB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, provide the key type: `A` for type A keys, `B` for type B keys, and `?`
    for testing both types of keys. You can also use the `d` parameter to write the
    identified keys to a binary file or the `t` parameter to load the identified keys
    directly to the Proxmark3 emulator memory for further use, such as reading specific
    blocks or sectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Then you can specify either a space-separated list of keys or a file that contains
    these keys. Proxmark3 contains a default list in the source code folder at *./client/default_keys.dic*.
    If you don’t provide your own list or a file with the keys, Proxmark3 will use
    this file to test the 17 most common default keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example run of the brute-force attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command succeeds, it displays a table with the A and B keys for the
    16 sectors. If you used the `b` parameter, Proxmark3 stores the keys in a file
    named *dumpedkeys.bin ,* and the output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The latest versions of Proxmark3, such as RVD 4.0, support an optimized version
    of the same command, called `fchk`. It takes two parameters, the tag’s memory
    size and the `t` (transfer) parameter, which you can use to load the keys to the
    Proxmark3 memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Reading and Cloning the Card Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you know the keys, you can start reading sectors or blocks using the `rdbl`
    parameter. The following command reads block number 0 with the A key `FFFFFFFFFFFF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read a complete sector, using the same methodology, with the `hf mf
    rdsc`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To clone a MIFARE card, use the `dump`parameter. This parameter writes a file
    with all the information from the original card. You could save and reuse that
    file later to create a new, fresh copy of the original card.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dump` parameter lets you assign the name of a file or the type of technology
    that you want to dump. Just pass it the card’s memory size. In this example, we
    use `1` for the 1KB memory size (although because `1` is the default size, we
    could have omitted this). The command uses the keys we stored in the *dumpkeys.bin*
    file to access the card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command stores the data in a file named *hf-mf-B46F6F79-data.bin*. You
    can transfer files in the *.bin* format directly to another RFID tag.
  prefs: []
  type: TYPE_NORMAL
- en: Some Proxmark3 firmwares maintained by third-party developers will store the
    data in two more files with .*eml* and .*json* extensions. You could load the
    .*eml* file to the Proxmark3 memory for further use, and you could use the .*json*
    file with third-party software and other RFID emulation devices, such as the ChameleonMini.
    You can easily convert this data from one file format to another, either manually
    or by using a number of automated scripts that we’ll discuss in “Automating RFID
    Attacks Using the Proxmark3 Scripting Engine” on page 263\.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy the stored data to a new card, place the card within range of the Proxmark3’s
    antenna and use Proxmark3’s `restore`parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The card doesn’t need to be blank for this command to work, but the `restore`
    command uses *dumpkeys.bin*`` once`again to access the card. If the card’s current
    keys are different than the ones stored in the *dumpkeys.bin* file, the write
    operation will fail.` ``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
